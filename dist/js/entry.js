/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@toast-ui/chart/dist/toastui-chart.js":
/*!************************************************************!*\
  !*** ./node_modules/@toast-ui/chart/dist/toastui-chart.js ***!
  \************************************************************/
/***/ ((module) => {

/*!
 * TOAST UI Chart 4th Edition
 * @version 4.6.1 | Wed Dec 21 2022
 * @author NHN Cloud. FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(self, function() {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 3819:
/***/ (function(module) {

module.exports = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  } return it;
};


/***/ }),

/***/ 8505:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_909__) {

var isObject = __nested_webpack_require_909__(5052);

module.exports = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  } return it;
};


/***/ }),

/***/ 9736:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_1208__) {

var wellKnownSymbol = __nested_webpack_require_1208__(95);
var create = __nested_webpack_require_1208__(2391);
var definePropertyModule = __nested_webpack_require_1208__(1787);

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ 6637:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_1922__) {

"use strict";

var charAt = __nested_webpack_require_1922__(966).charAt;

// `AdvanceStringIndex` abstract operation
// https://tc39.es/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};


/***/ }),

/***/ 7728:
/***/ (function(module) {

module.exports = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  } return it;
};


/***/ }),

/***/ 1176:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_2523__) {

var isObject = __nested_webpack_require_2523__(5052);

module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  } return it;
};


/***/ }),

/***/ 3339:
/***/ (function(module) {

// eslint-disable-next-line es/no-typed-arrays -- safe
module.exports = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';


/***/ }),

/***/ 9918:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_2989__) {

"use strict";

var NATIVE_ARRAY_BUFFER = __nested_webpack_require_2989__(3339);
var DESCRIPTORS = __nested_webpack_require_2989__(7400);
var global = __nested_webpack_require_2989__(9859);
var isObject = __nested_webpack_require_2989__(5052);
var has = __nested_webpack_require_2989__(816);
var classof = __nested_webpack_require_2989__(1589);
var createNonEnumerableProperty = __nested_webpack_require_2989__(5762);
var redefine = __nested_webpack_require_2989__(7487);
var defineProperty = __nested_webpack_require_2989__(1787).f;
var getPrototypeOf = __nested_webpack_require_2989__(7567);
var setPrototypeOf = __nested_webpack_require_2989__(6540);
var wellKnownSymbol = __nested_webpack_require_2989__(95);
var uid = __nested_webpack_require_2989__(1441);

var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var Uint8ClampedArray = global.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array && getPrototypeOf(Int8Array);
var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype = Object.prototype;
var isPrototypeOf = ObjectPrototype.isPrototypeOf;

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
// Fixing native typed arrays in Opera Presto crashes the browser, see #595
var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQIRED = false;
var NAME;

var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};

var BigIntArrayConstructorsList = {
  BigInt64Array: 8,
  BigUint64Array: 8
};

var isView = function isView(it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return klass === 'DataView'
    || has(TypedArrayConstructorsList, klass)
    || has(BigIntArrayConstructorsList, klass);
};

var isTypedArray = function (it) {
  if (!isObject(it)) return false;
  var klass = classof(it);
  return has(TypedArrayConstructorsList, klass)
    || has(BigIntArrayConstructorsList, klass);
};

var aTypedArray = function (it) {
  if (isTypedArray(it)) return it;
  throw TypeError('Target is not a typed array');
};

var aTypedArrayConstructor = function (C) {
  if (setPrototypeOf) {
    if (isPrototypeOf.call(TypedArray, C)) return C;
  } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME)) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
      return C;
    }
  } throw TypeError('Target is not a typed array constructor');
};

var exportTypedArrayMethod = function (KEY, property, forced) {
  if (!DESCRIPTORS) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) try {
      delete TypedArrayConstructor.prototype[KEY];
    } catch (error) { /* empty */ }
  }
  if (!TypedArrayPrototype[KEY] || forced) {
    redefine(TypedArrayPrototype, KEY, forced ? property
      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
  }
};

var exportTypedArrayStaticMethod = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS) return;
  if (setPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global[ARRAY];
      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) try {
        delete TypedArrayConstructor[KEY];
      } catch (error) { /* empty */ }
    }
    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);
      } catch (error) { /* empty */ }
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      redefine(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME in TypedArrayConstructorsList) {
  if (!global[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;
}

// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow -- safe
  TypedArray = function TypedArray() {
    throw TypeError('Incorrect invocation');
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
  }
}

// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}

if (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {
  TYPED_ARRAY_TAG_REQIRED = true;
  defineProperty(TypedArrayPrototype, TO_STRING_TAG, { get: function () {
    return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
  } });
  for (NAME in TypedArrayConstructorsList) if (global[NAME]) {
    createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
  }
}

module.exports = {
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor,
  exportTypedArrayMethod: exportTypedArrayMethod,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype
};


/***/ }),

/***/ 3816:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_9265__) {

"use strict";

var global = __nested_webpack_require_9265__(9859);
var DESCRIPTORS = __nested_webpack_require_9265__(7400);
var NATIVE_ARRAY_BUFFER = __nested_webpack_require_9265__(3339);
var createNonEnumerableProperty = __nested_webpack_require_9265__(5762);
var redefineAll = __nested_webpack_require_9265__(8787);
var fails = __nested_webpack_require_9265__(4229);
var anInstance = __nested_webpack_require_9265__(7728);
var toInteger = __nested_webpack_require_9265__(6051);
var toLength = __nested_webpack_require_9265__(4237);
var toIndex = __nested_webpack_require_9265__(7331);
var IEEE754 = __nested_webpack_require_9265__(6201);
var getPrototypeOf = __nested_webpack_require_9265__(7567);
var setPrototypeOf = __nested_webpack_require_9265__(6540);
var getOwnPropertyNames = __nested_webpack_require_9265__(8151).f;
var defineProperty = __nested_webpack_require_9265__(1787).f;
var arrayFill = __nested_webpack_require_9265__(7065);
var setToStringTag = __nested_webpack_require_9265__(4555);
var InternalStateModule = __nested_webpack_require_9265__(6407);

var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length';
var WRONG_INDEX = 'Wrong index';
var NativeArrayBuffer = global[ARRAY_BUFFER];
var $ArrayBuffer = NativeArrayBuffer;
var $DataView = global[DATA_VIEW];
var $DataViewPrototype = $DataView && $DataView[PROTOTYPE];
var ObjectPrototype = Object.prototype;
var RangeError = global.RangeError;

var packIEEE754 = IEEE754.pack;
var unpackIEEE754 = IEEE754.unpack;

var packInt8 = function (number) {
  return [number & 0xFF];
};

var packInt16 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF];
};

var packInt32 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
};

var unpackInt32 = function (buffer) {
  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
};

var packFloat32 = function (number) {
  return packIEEE754(number, 23, 4);
};

var packFloat64 = function (number) {
  return packIEEE754(number, 52, 8);
};

var addGetter = function (Constructor, key) {
  defineProperty(Constructor[PROTOTYPE], key, { get: function () { return getInternalState(this)[key]; } });
};

var get = function (view, count, index, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = bytes.slice(start, start + count);
  return isLittleEndian ? pack : pack.reverse();
};

var set = function (view, count, index, conversion, value, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = conversion(+value);
  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
};

if (!NATIVE_ARRAY_BUFFER) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    setInternalState(this, {
      bytes: arrayFill.call(new Array(byteLength), 0),
      byteLength: byteLength
    });
    if (!DESCRIPTORS) this.byteLength = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = getInternalState(buffer).byteLength;
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    setInternalState(this, {
      buffer: buffer,
      byteLength: byteLength,
      byteOffset: offset
    });
    if (!DESCRIPTORS) {
      this.buffer = buffer;
      this.byteLength = byteLength;
      this.byteOffset = offset;
    }
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, 'byteLength');
    addGetter($DataView, 'buffer');
    addGetter($DataView, 'byteLength');
    addGetter($DataView, 'byteOffset');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
    }
  });
} else {
  /* eslint-disable no-new -- required for testing */
  if (!fails(function () {
    NativeArrayBuffer(1);
  }) || !fails(function () {
    new NativeArrayBuffer(-1);
  }) || fails(function () {
    new NativeArrayBuffer();
    new NativeArrayBuffer(1.5);
    new NativeArrayBuffer(NaN);
    return NativeArrayBuffer.name != ARRAY_BUFFER;
  })) {
  /* eslint-enable no-new -- required for testing */
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new NativeArrayBuffer(toIndex(length));
    };
    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE] = NativeArrayBuffer[PROTOTYPE];
    for (var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) {
        createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
      }
    }
    ArrayBufferPrototype.constructor = $ArrayBuffer;
  }

  // WebKit bug - the same parent prototype for typed arrays and data view
  if (setPrototypeOf && getPrototypeOf($DataViewPrototype) !== ObjectPrototype) {
    setPrototypeOf($DataViewPrototype, ObjectPrototype);
  }

  // iOS Safari 7.x bug
  var testView = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataViewPrototype.setInt8;
  testView.setInt8(0, 2147483648);
  testView.setInt8(1, 2147483649);
  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, { unsafe: true });
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);

module.exports = {
  ArrayBuffer: $ArrayBuffer,
  DataView: $DataView
};


/***/ }),

/***/ 7154:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_18197__) {

"use strict";

var toObject = __nested_webpack_require_18197__(2991);
var toAbsoluteIndex = __nested_webpack_require_18197__(3231);
var toLength = __nested_webpack_require_18197__(4237);

var min = Math.min;

// `Array.prototype.copyWithin` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.copywithin
// eslint-disable-next-line es/no-array-prototype-copywithin -- safe
module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),

/***/ 7065:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_19296__) {

"use strict";

var toObject = __nested_webpack_require_19296__(2991);
var toAbsoluteIndex = __nested_webpack_require_19296__(3231);
var toLength = __nested_webpack_require_19296__(4237);

// `Array.prototype.fill` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.fill
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),

/***/ 6570:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_20102__) {

"use strict";

var $forEach = __nested_webpack_require_20102__(9996).forEach;
var arrayMethodIsStrict = __nested_webpack_require_20102__(6038);

var STRICT_METHOD = arrayMethodIsStrict('forEach');

// `Array.prototype.forEach` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.foreach
module.exports = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
// eslint-disable-next-line es/no-array-prototype-foreach -- safe
} : [].forEach;


/***/ }),

/***/ 507:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_20728__) {

"use strict";

var bind = __nested_webpack_require_20728__(7636);
var toObject = __nested_webpack_require_20728__(2991);
var callWithSafeIterationClosing = __nested_webpack_require_20728__(4960);
var isArrayIteratorMethod = __nested_webpack_require_20728__(1943);
var toLength = __nested_webpack_require_20728__(4237);
var createProperty = __nested_webpack_require_20728__(2324);
var getIteratorMethod = __nested_webpack_require_20728__(8830);

// `Array.from` method implementation
// https://tc39.es/ecma262/#sec-array.from
module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject(arrayLike);
  var C = typeof this == 'function' ? this : Array;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length, result, step, iterator, next, value;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    result = new C();
    for (;!(step = next.call(iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty(result, index, value);
    }
  } else {
    length = toLength(O.length);
    result = new C(length);
    for (;length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty(result, index, value);
    }
  }
  result.length = index;
  return result;
};


/***/ }),

/***/ 9540:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_22542__) {

var toIndexedObject = __nested_webpack_require_22542__(905);
var toLength = __nested_webpack_require_22542__(4237);
var toAbsoluteIndex = __nested_webpack_require_22542__(3231);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 9996:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_23895__) {

var bind = __nested_webpack_require_23895__(7636);
var IndexedObject = __nested_webpack_require_23895__(9337);
var toObject = __nested_webpack_require_23895__(2991);
var toLength = __nested_webpack_require_23895__(4237);
var arraySpeciesCreate = __nested_webpack_require_23895__(7501);

var push = [].push;

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var IS_FILTER_OUT = TYPE == 7;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push.call(target, value); // filter
        } else switch (TYPE) {
          case 4: return false;             // every
          case 7: push.call(target, value); // filterOut
        }
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.es/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.es/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.es/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.es/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.es/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6),
  // `Array.prototype.filterOut` method
  // https://github.com/tc39/proposal-array-filtering
  filterOut: createMethod(7)
};


/***/ }),

/***/ 6462:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_26720__) {

"use strict";

/* eslint-disable es/no-array-prototype-lastindexof -- safe */
var toIndexedObject = __nested_webpack_require_26720__(905);
var toInteger = __nested_webpack_require_26720__(6051);
var toLength = __nested_webpack_require_26720__(4237);
var arrayMethodIsStrict = __nested_webpack_require_26720__(6038);

var min = Math.min;
var $lastIndexOf = [].lastIndexOf;
var NEGATIVE_ZERO = !!$lastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf');
var FORCED = NEGATIVE_ZERO || !STRICT_METHOD;

// `Array.prototype.lastIndexOf` method implementation
// https://tc39.es/ecma262/#sec-array.prototype.lastindexof
module.exports = FORCED ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
  // convert -0 to +0
  if (NEGATIVE_ZERO) return $lastIndexOf.apply(this, arguments) || 0;
  var O = toIndexedObject(this);
  var length = toLength(O.length);
  var index = length - 1;
  if (arguments.length > 1) index = min(index, toInteger(arguments[1]));
  if (index < 0) index = length + index;
  for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
  return -1;
} : $lastIndexOf;


/***/ }),

/***/ 1460:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_27943__) {

var fails = __nested_webpack_require_27943__(4229);
var wellKnownSymbol = __nested_webpack_require_27943__(95);
var V8_VERSION = __nested_webpack_require_27943__(6358);

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};


/***/ }),

/***/ 6038:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_28677__) {

"use strict";

var fails = __nested_webpack_require_28677__(4229);

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing
    method.call(null, argument || function () { throw 1; }, 1);
  });
};


/***/ }),

/***/ 3143:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_29118__) {

var aFunction = __nested_webpack_require_29118__(3819);
var toObject = __nested_webpack_require_29118__(2991);
var IndexedObject = __nested_webpack_require_29118__(9337);
var toLength = __nested_webpack_require_29118__(4237);

// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aFunction(callbackfn);
    var O = toObject(that);
    var self = IndexedObject(O);
    var length = toLength(O.length);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }
      index += i;
      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError('Reduce of empty array with no initial value');
      }
    }
    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
    return memo;
  };
};

module.exports = {
  // `Array.prototype.reduce` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduce
  left: createMethod(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
  right: createMethod(true)
};


/***/ }),

/***/ 7501:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_30506__) {

var isObject = __nested_webpack_require_30506__(5052);
var isArray = __nested_webpack_require_30506__(3718);
var wellKnownSymbol = __nested_webpack_require_30506__(95);

var SPECIES = wellKnownSymbol('species');

// `ArraySpeciesCreate` abstract operation
// https://tc39.es/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};


/***/ }),

/***/ 4960:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_31286__) {

var anObject = __nested_webpack_require_31286__(1176);
var iteratorClose = __nested_webpack_require_31286__(7281);

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    iteratorClose(iterator);
    throw error;
  }
};


/***/ }),

/***/ 4575:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_31791__) {

var wellKnownSymbol = __nested_webpack_require_31791__(95);

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line es/no-array-from, no-throw-literal -- required for testing
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),

/***/ 7079:
/***/ (function(module) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ 1589:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_33008__) {

var TO_STRING_TAG_SUPPORT = __nested_webpack_require_33008__(1601);
var classofRaw = __nested_webpack_require_33008__(7079);
var wellKnownSymbol = __nested_webpack_require_33008__(95);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};


/***/ }),

/***/ 8081:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_34068__) {

"use strict";

var defineProperty = __nested_webpack_require_34068__(1787).f;
var create = __nested_webpack_require_34068__(2391);
var redefineAll = __nested_webpack_require_34068__(8787);
var bind = __nested_webpack_require_34068__(7636);
var anInstance = __nested_webpack_require_34068__(7728);
var iterate = __nested_webpack_require_34068__(9003);
var defineIterator = __nested_webpack_require_34068__(7675);
var setSpecies = __nested_webpack_require_34068__(1832);
var DESCRIPTORS = __nested_webpack_require_34068__(7400);
var fastKey = __nested_webpack_require_34068__(5926).fastKey;
var InternalStateModule = __nested_webpack_require_34068__(6407);

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, CONSTRUCTOR_NAME);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        index: create(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!DESCRIPTORS) that.size = 0;
      if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
    });

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index;
      // change existing entry
      if (entry) {
        entry.value = value;
      // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS) state.size++;
        else that.size++;
        // add to index
        if (index !== 'F') state.index[index] = entry;
      } return that;
    };

    var getEntry = function (that, key) {
      var state = getInternalState(that);
      // fast case
      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index];
      // frozen object case
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };

    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }
        state.first = state.last = undefined;
        if (DESCRIPTORS) state.size = 0;
        else that.size = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (DESCRIPTORS) state.size--;
          else that.size--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        var state = getInternalState(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          // revert to the last existing entry
          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });

    redefineAll(C.prototype, IS_MAP ? {
      // 23.1.3.6 Map.prototype.get(key)
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // 23.1.3.9 Map.prototype.set(key, value)
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // 23.2.3.1 Set.prototype.add(value)
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS) defineProperty(C.prototype, 'size', {
      get: function () {
        return getInternalState(this).size;
      }
    });
    return C;
  },
  setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      // revert to the last existing entry
      while (entry && entry.removed) entry = entry.previous;
      // get next entry
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return { value: undefined, done: true };
      }
      // return step by kind
      if (kind == 'keys') return { value: entry.key, done: false };
      if (kind == 'values') return { value: entry.value, done: false };
      return { value: [entry.key, entry.value], done: false };
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(CONSTRUCTOR_NAME);
  }
};


/***/ }),

/***/ 9789:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_40775__) {

"use strict";

var $ = __nested_webpack_require_40775__(3103);
var global = __nested_webpack_require_40775__(9859);
var isForced = __nested_webpack_require_40775__(6541);
var redefine = __nested_webpack_require_40775__(7487);
var InternalMetadataModule = __nested_webpack_require_40775__(5926);
var iterate = __nested_webpack_require_40775__(9003);
var anInstance = __nested_webpack_require_40775__(7728);
var isObject = __nested_webpack_require_40775__(5052);
var fails = __nested_webpack_require_40775__(4229);
var checkCorrectnessOfIteration = __nested_webpack_require_40775__(4575);
var setToStringTag = __nested_webpack_require_40775__(4555);
var inheritIfRequired = __nested_webpack_require_40775__(835);

module.exports = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = global[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var exported = {};

  var fixMethod = function (KEY) {
    var nativeMethod = NativePrototype[KEY];
    redefine(NativePrototype, KEY,
      KEY == 'add' ? function add(value) {
        nativeMethod.call(this, value === 0 ? 0 : value);
        return this;
      } : KEY == 'delete' ? function (key) {
        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
      } : KEY == 'get' ? function get(key) {
        return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
      } : KEY == 'has' ? function has(key) {
        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
      } : function set(key, value) {
        nativeMethod.call(this, key === 0 ? 0 : key, value);
        return this;
      }
    );
  };

  var REPLACE = isForced(
    CONSTRUCTOR_NAME,
    typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
      new NativeConstructor().entries().next();
    }))
  );

  if (REPLACE) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule.REQUIRED = true;
  } else if (isForced(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new -- required for testing
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

    // weak collections should not contains .clear method
    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }

  exported[CONSTRUCTOR_NAME] = Constructor;
  $({ global: true, forced: Constructor != NativeConstructor }, exported);

  setToStringTag(Constructor, CONSTRUCTOR_NAME);

  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

  return Constructor;
};


/***/ }),

/***/ 7081:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_45077__) {

var has = __nested_webpack_require_45077__(816);
var ownKeys = __nested_webpack_require_45077__(4826);
var getOwnPropertyDescriptorModule = __nested_webpack_require_45077__(7933);
var definePropertyModule = __nested_webpack_require_45077__(1787);

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};


/***/ }),

/***/ 8127:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_45728__) {

var wellKnownSymbol = __nested_webpack_require_45728__(95);

var MATCH = wellKnownSymbol('match');

module.exports = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (error1) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (error2) { /* empty */ }
  } return false;
};


/***/ }),

/***/ 7528:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_46175__) {

var fails = __nested_webpack_require_46175__(4229);

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  // eslint-disable-next-line es/no-object-getprototypeof -- required for testing
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ 1720:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_46560__) {

var requireObjectCoercible = __nested_webpack_require_46560__(8885);

var quot = /"/g;

// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
// https://tc39.es/ecma262/#sec-createhtml
module.exports = function (string, tag, attribute, value) {
  var S = String(requireObjectCoercible(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};


/***/ }),

/***/ 3723:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_47109__) {

"use strict";

var IteratorPrototype = __nested_webpack_require_47109__(693).IteratorPrototype;
var create = __nested_webpack_require_47109__(2391);
var createPropertyDescriptor = __nested_webpack_require_47109__(5358);
var setToStringTag = __nested_webpack_require_47109__(4555);
var Iterators = __nested_webpack_require_47109__(5495);

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ 5762:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_47880__) {

var DESCRIPTORS = __nested_webpack_require_47880__(7400);
var definePropertyModule = __nested_webpack_require_47880__(1787);
var createPropertyDescriptor = __nested_webpack_require_47880__(5358);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 5358:
/***/ (function(module) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 2324:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_48586__) {

"use strict";

var toPrimitive = __nested_webpack_require_48586__(2066);
var definePropertyModule = __nested_webpack_require_48586__(1787);
var createPropertyDescriptor = __nested_webpack_require_48586__(5358);

module.exports = function (object, key, value) {
  var propertyKey = toPrimitive(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),

/***/ 7675:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_49094__) {

"use strict";

var $ = __nested_webpack_require_49094__(3103);
var createIteratorConstructor = __nested_webpack_require_49094__(3723);
var getPrototypeOf = __nested_webpack_require_49094__(7567);
var setPrototypeOf = __nested_webpack_require_49094__(6540);
var setToStringTag = __nested_webpack_require_49094__(4555);
var createNonEnumerableProperty = __nested_webpack_require_49094__(5762);
var redefine = __nested_webpack_require_49094__(7487);
var wellKnownSymbol = __nested_webpack_require_49094__(95);
var IS_PURE = __nested_webpack_require_49094__(4231);
var Iterators = __nested_webpack_require_49094__(5495);
var IteratorsCore = __nested_webpack_require_49094__(693);

var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;
    defaultIterator = function values() { return nativeIterator.call(this); };
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
  }
  Iterators[NAME] = defaultIterator;

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  return methods;
};


/***/ }),

/***/ 8423:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_53063__) {

var path = __nested_webpack_require_53063__(9276);
var has = __nested_webpack_require_53063__(816);
var wrappedWellKnownSymbolModule = __nested_webpack_require_53063__(5391);
var defineProperty = __nested_webpack_require_53063__(1787).f;

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};


/***/ }),

/***/ 7400:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_53548__) {

var fails = __nested_webpack_require_53548__(4229);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ 2635:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_53951__) {

var global = __nested_webpack_require_53951__(9859);
var isObject = __nested_webpack_require_53951__(5052);

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 5694:
/***/ (function(module) {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ 8801:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_55182__) {

var classof = __nested_webpack_require_55182__(7079);
var global = __nested_webpack_require_55182__(9859);

module.exports = classof(global.process) == 'process';


/***/ }),

/***/ 598:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_55417__) {

var getBuiltIn = __nested_webpack_require_55417__(1333);

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ 6358:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_55622__) {

var global = __nested_webpack_require_55622__(9859);
var userAgent = __nested_webpack_require_55622__(598);

var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

module.exports = version && +version;


/***/ }),

/***/ 3837:
/***/ (function(module) {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 3103:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_56457__) {

var global = __nested_webpack_require_56457__(9859);
var getOwnPropertyDescriptor = __nested_webpack_require_56457__(7933).f;
var createNonEnumerableProperty = __nested_webpack_require_56457__(5762);
var redefine = __nested_webpack_require_56457__(7487);
var setGlobal = __nested_webpack_require_56457__(2079);
var copyConstructorProperties = __nested_webpack_require_56457__(7081);
var isForced = __nested_webpack_require_56457__(6541);

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 4229:
/***/ (function(module) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 4954:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_59118__) {

"use strict";

// TODO: Remove from `core-js@4` since it's moved to entry points
__nested_webpack_require_59118__(7950);
var redefine = __nested_webpack_require_59118__(7487);
var fails = __nested_webpack_require_59118__(4229);
var wellKnownSymbol = __nested_webpack_require_59118__(95);
var createNonEnumerableProperty = __nested_webpack_require_59118__(5762);

var SPECIES = wellKnownSymbol('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

// IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
var REPLACE_KEEPS_$0 = (function () {
  // eslint-disable-next-line regexp/prefer-escape-replacement-dollar-char -- required for testing
  return 'a'.replace(/./, '$0') === '$0';
})();

var REPLACE = wellKnownSymbol('replace');
// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
  if (/./[REPLACE]) {
    return /./[REPLACE]('a', '$0') === '';
  }
  return false;
})();

// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  // eslint-disable-next-line regexp/no-empty-group -- required for testing
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

module.exports = function (KEY, length, exec, sham) {
  var SYMBOL = wellKnownSymbol(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {};
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () { execCalled = true; return null; };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !(
      REPLACE_SUPPORTS_NAMED_GROUPS &&
      REPLACE_KEEPS_$0 &&
      !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
    )) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === RegExp.prototype.exec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
        }
        return { done: true, value: nativeMethod.call(str, regexp, arg2) };
      }
      return { done: false };
    }, {
      REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
    });
    var stringMethod = methods[0];
    var regexMethod = methods[1];

    redefine(String.prototype, KEY, stringMethod);
    redefine(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return regexMethod.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return regexMethod.call(string, this); }
    );
  }

  if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
};


/***/ }),

/***/ 4990:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_63944__) {

"use strict";

var isArray = __nested_webpack_require_63944__(3718);
var toLength = __nested_webpack_require_63944__(4237);
var bind = __nested_webpack_require_63944__(7636);

// `FlattenIntoArray` abstract operation
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var flattenIntoArray = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? bind(mapper, thisArg, 3) : false;
  var element;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      if (depth > 0 && isArray(element)) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError('Exceed the acceptable array length');
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
};

module.exports = flattenIntoArray;


/***/ }),

/***/ 8476:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_65117__) {

var fails = __nested_webpack_require_65117__(4229);

module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-isextensible, es/no-object-preventextensions -- required for testing
  return Object.isExtensible(Object.preventExtensions({}));
});


/***/ }),

/***/ 7636:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_65470__) {

var aFunction = __nested_webpack_require_65470__(3819);

// optional / simple context binding
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0: return function () {
      return fn.call(that);
    };
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ 4128:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_66159__) {

"use strict";

var aFunction = __nested_webpack_require_66159__(3819);
var isObject = __nested_webpack_require_66159__(5052);

var slice = [].slice;
var factories = {};

var construct = function (C, argsLength, args) {
  if (!(argsLength in factories)) {
    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func -- we have no proper alternatives, IE8- only
    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
  } return factories[argsLength](C, args);
};

// `Function.prototype.bind` method implementation
// https://tc39.es/ecma262/#sec-function.prototype.bind
module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = slice.call(arguments, 1);
  var boundFunction = function bound(/* args... */) {
    var args = partArgs.concat(slice.call(arguments));
    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
  };
  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
  return boundFunction;
};


/***/ }),

/***/ 1333:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_67347__) {

var path = __nested_webpack_require_67347__(9276);
var global = __nested_webpack_require_67347__(9859);

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};


/***/ }),

/***/ 8830:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_67872__) {

var classof = __nested_webpack_require_67872__(1589);
var Iterators = __nested_webpack_require_67872__(5495);
var wellKnownSymbol = __nested_webpack_require_67872__(95);

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ 17:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_68280__) {

var toObject = __nested_webpack_require_68280__(2991);

var floor = Math.floor;
var replace = ''.replace;
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d{1,2}|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d{1,2})/g;

// https://tc39.es/ecma262/#sec-getsubstitution
module.exports = function (matched, str, position, captures, namedCaptures, replacement) {
  var tailPos = position + matched.length;
  var m = captures.length;
  var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
  if (namedCaptures !== undefined) {
    namedCaptures = toObject(namedCaptures);
    symbols = SUBSTITUTION_SYMBOLS;
  }
  return replace.call(replacement, symbols, function (match, ch) {
    var capture;
    switch (ch.charAt(0)) {
      case '$': return '$';
      case '&': return matched;
      case '`': return str.slice(0, position);
      case "'": return str.slice(tailPos);
      case '<':
        capture = namedCaptures[ch.slice(1, -1)];
        break;
      default: // \d\d?
        var n = +ch;
        if (n === 0) return match;
        if (n > m) {
          var f = floor(n / 10);
          if (f === 0) return match;
          if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
          return match;
        }
        capture = captures[n - 1];
    }
    return capture === undefined ? '' : capture;
  });
};


/***/ }),

/***/ 9859:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_69723__) {

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __nested_webpack_require_69723__.g == 'object' && __nested_webpack_require_69723__.g) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 816:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_70441__) {

var toObject = __nested_webpack_require_70441__(2991);

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function hasOwn(it, key) {
  return hasOwnProperty.call(toObject(it), key);
};


/***/ }),

/***/ 5977:
/***/ (function(module) {

module.exports = {};


/***/ }),

/***/ 3777:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_70793__) {

var getBuiltIn = __nested_webpack_require_70793__(1333);

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ 4394:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_70997__) {

var DESCRIPTORS = __nested_webpack_require_70997__(7400);
var fails = __nested_webpack_require_70997__(4229);
var createElement = __nested_webpack_require_70997__(2635);

// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- requied for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ 6201:
/***/ (function(module) {

// IEEE754 conversions based on https://github.com/feross/ieee754
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;

var pack = function (number, mantissaLength, bytes) {
  var buffer = new Array(bytes);
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
  var index = 0;
  var exponent, mantissa, c;
  number = abs(number);
  // eslint-disable-next-line no-self-compare -- NaN check
  if (number != number || number === Infinity) {
    // eslint-disable-next-line no-self-compare -- NaN check
    mantissa = number != number ? 1 : 0;
    exponent = eMax;
  } else {
    exponent = floor(log(number) / LN2);
    if (number * (c = pow(2, -exponent)) < 1) {
      exponent--;
      c *= 2;
    }
    if (exponent + eBias >= 1) {
      number += rt / c;
    } else {
      number += rt * pow(2, 1 - eBias);
    }
    if (number * c >= 2) {
      exponent++;
      c /= 2;
    }
    if (exponent + eBias >= eMax) {
      mantissa = 0;
      exponent = eMax;
    } else if (exponent + eBias >= 1) {
      mantissa = (number * c - 1) * pow(2, mantissaLength);
      exponent = exponent + eBias;
    } else {
      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
      exponent = 0;
    }
  }
  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);
  exponent = exponent << mantissaLength | mantissa;
  exponentLength += mantissaLength;
  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);
  buffer[--index] |= sign * 128;
  return buffer;
};

var unpack = function (buffer, mantissaLength) {
  var bytes = buffer.length;
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var nBits = exponentLength - 7;
  var index = bytes - 1;
  var sign = buffer[index--];
  var exponent = sign & 127;
  var mantissa;
  sign >>= 7;
  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);
  mantissa = exponent & (1 << -nBits) - 1;
  exponent >>= -nBits;
  nBits += mantissaLength;
  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);
  if (exponent === 0) {
    exponent = 1 - eBias;
  } else if (exponent === eMax) {
    return mantissa ? NaN : sign ? -Infinity : Infinity;
  } else {
    mantissa = mantissa + pow(2, mantissaLength);
    exponent = exponent - eBias;
  } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};

module.exports = {
  pack: pack,
  unpack: unpack
};


/***/ }),

/***/ 9337:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_74352__) {

var fails = __nested_webpack_require_74352__(4229);
var classof = __nested_webpack_require_74352__(7079);

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;


/***/ }),

/***/ 835:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_74947__) {

var isObject = __nested_webpack_require_74947__(5052);
var setPrototypeOf = __nested_webpack_require_74947__(6540);

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    typeof (NewTarget = dummy.constructor) == 'function' &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};


/***/ }),

/***/ 8511:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_75709__) {

var store = __nested_webpack_require_75709__(5353);

var functionToString = Function.toString;

// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof store.inspectSource != 'function') {
  store.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 5926:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_76135__) {

var hiddenKeys = __nested_webpack_require_76135__(5977);
var isObject = __nested_webpack_require_76135__(5052);
var has = __nested_webpack_require_76135__(816);
var defineProperty = __nested_webpack_require_76135__(1787).f;
var uid = __nested_webpack_require_76135__(1441);
var FREEZING = __nested_webpack_require_76135__(8476);

var METADATA = uid('meta');
var id = 0;

// eslint-disable-next-line es/no-object-isextensible -- safe
var isExtensible = Object.isExtensible || function () {
  return true;
};

var setMetadata = function (it) {
  defineProperty(it, METADATA, { value: {
    objectID: 'O' + ++id, // object ID
    weakData: {}          // weak collections IDs
  } });
};

var fastKey = function (it, create) {
  // return a primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMetadata(it);
  // return object ID
  } return it[METADATA].objectID;
};

var getWeakData = function (it, create) {
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMetadata(it);
  // return the store of weak collections IDs
  } return it[METADATA].weakData;
};

// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZING && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
  return it;
};

var meta = module.exports = {
  REQUIRED: false,
  fastKey: fastKey,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};

hiddenKeys[METADATA] = true;


/***/ }),

/***/ 6407:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_78011__) {

var NATIVE_WEAK_MAP = __nested_webpack_require_78011__(8694);
var global = __nested_webpack_require_78011__(9859);
var isObject = __nested_webpack_require_78011__(5052);
var createNonEnumerableProperty = __nested_webpack_require_78011__(5762);
var objectHas = __nested_webpack_require_78011__(816);
var shared = __nested_webpack_require_78011__(5353);
var sharedKey = __nested_webpack_require_78011__(4399);
var hiddenKeys = __nested_webpack_require_78011__(5977);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (objectHas(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 1943:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_79925__) {

var wellKnownSymbol = __nested_webpack_require_79925__(95);
var Iterators = __nested_webpack_require_79925__(5495);

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ 3718:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_80359__) {

var classof = __nested_webpack_require_80359__(7079);

// `IsArray` abstract operation
// https://tc39.es/ecma262/#sec-isarray
// eslint-disable-next-line es/no-array-isarray -- safe
module.exports = Array.isArray || function isArray(arg) {
  return classof(arg) == 'Array';
};


/***/ }),

/***/ 6541:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_80723__) {

var fails = __nested_webpack_require_80723__(4229);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : typeof detection == 'function' ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 5052:
/***/ (function(module) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ 4231:
/***/ (function(module) {

module.exports = false;


/***/ }),

/***/ 8311:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_81629__) {

var isObject = __nested_webpack_require_81629__(5052);
var classof = __nested_webpack_require_81629__(7079);
var wellKnownSymbol = __nested_webpack_require_81629__(95);

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.es/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};


/***/ }),

/***/ 9003:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_82128__) {

var anObject = __nested_webpack_require_82128__(1176);
var isArrayIteratorMethod = __nested_webpack_require_82128__(1943);
var toLength = __nested_webpack_require_82128__(4237);
var bind = __nested_webpack_require_82128__(7636);
var getIteratorMethod = __nested_webpack_require_82128__(8830);
var iteratorClose = __nested_webpack_require_82128__(7281);

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

module.exports = function (iterable, unboundFunction, options) {
  var that = options && options.that;
  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
  var INTERRUPTED = !!(options && options.INTERRUPTED);
  var fn = bind(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
  var iterator, iterFn, index, length, result, next, step;

  var stop = function (condition) {
    if (iterator) iteratorClose(iterator);
    return new Result(true, condition);
  };

  var callFn = function (value) {
    if (AS_ENTRIES) {
      anObject(value);
      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
    } return INTERRUPTED ? fn(value, stop) : fn(value);
  };

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = toLength(iterable.length); length > index; index++) {
        result = callFn(iterable[index]);
        if (result && result instanceof Result) return result;
      } return new Result(false);
    }
    iterator = iterFn.call(iterable);
  }

  next = iterator.next;
  while (!(step = next.call(iterator)).done) {
    try {
      result = callFn(step.value);
    } catch (error) {
      iteratorClose(iterator);
      throw error;
    }
    if (typeof result == 'object' && result && result instanceof Result) return result;
  } return new Result(false);
};


/***/ }),

/***/ 7281:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_84194__) {

var anObject = __nested_webpack_require_84194__(1176);

module.exports = function (iterator) {
  var returnMethod = iterator['return'];
  if (returnMethod !== undefined) {
    return anObject(returnMethod.call(iterator)).value;
  }
};


/***/ }),

/***/ 693:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_84514__) {

"use strict";

var fails = __nested_webpack_require_84514__(4229);
var getPrototypeOf = __nested_webpack_require_84514__(7567);
var createNonEnumerableProperty = __nested_webpack_require_84514__(5762);
var has = __nested_webpack_require_84514__(816);
var wellKnownSymbol = __nested_webpack_require_84514__(95);
var IS_PURE = __nested_webpack_require_84514__(4231);

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function () { return this; };

// `%IteratorPrototype%` object
// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

/* eslint-disable es/no-array-prototype-keys -- safe */
if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {
  var test = {};
  // FF44- legacy iterators case
  return IteratorPrototype[ITERATOR].call(test) !== test;
});

if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if ((!IS_PURE || NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {
  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ 5495:
/***/ (function(module) {

module.exports = {};


/***/ }),

/***/ 3839:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_86264__) {

var IS_NODE = __nested_webpack_require_86264__(8801);
var V8_VERSION = __nested_webpack_require_86264__(6358);
var fails = __nested_webpack_require_86264__(4229);

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  // eslint-disable-next-line es/no-symbol -- required for testing
  return !Symbol.sham &&
    // Chrome 38 Symbol has incorrect toString conversion
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    (IS_NODE ? V8_VERSION === 38 : V8_VERSION > 37 && V8_VERSION < 41);
});


/***/ }),

/***/ 8694:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_86964__) {

var global = __nested_webpack_require_86964__(9859);
var inspectSource = __nested_webpack_require_86964__(8511);

var WeakMap = global.WeakMap;

module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ 7272:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_87276__) {

var isRegExp = __nested_webpack_require_87276__(8311);

module.exports = function (it) {
  if (isRegExp(it)) {
    throw TypeError("The method doesn't accept regular expressions");
  } return it;
};


/***/ }),

/***/ 2391:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_87561__) {

var anObject = __nested_webpack_require_87561__(1176);
var defineProperties = __nested_webpack_require_87561__(219);
var enumBugKeys = __nested_webpack_require_87561__(3837);
var hiddenKeys = __nested_webpack_require_87561__(5977);
var html = __nested_webpack_require_87561__(3777);
var documentCreateElement = __nested_webpack_require_87561__(2635);
var sharedKey = __nested_webpack_require_87561__(4399);

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    /* global ActiveXObject -- old IE */
    activeXDocument = document.domain && new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.es/ecma262/#sec-object.create
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : defineProperties(result, Properties);
};


/***/ }),

/***/ 219:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_90456__) {

var DESCRIPTORS = __nested_webpack_require_90456__(7400);
var definePropertyModule = __nested_webpack_require_90456__(1787);
var anObject = __nested_webpack_require_90456__(1176);
var objectKeys = __nested_webpack_require_90456__(5632);

// `Object.defineProperties` method
// https://tc39.es/ecma262/#sec-object.defineproperties
// eslint-disable-next-line es/no-object-defineproperties -- safe
module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);
  return O;
};


/***/ }),

/***/ 1787:
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_91212__) {

var DESCRIPTORS = __nested_webpack_require_91212__(7400);
var IE8_DOM_DEFINE = __nested_webpack_require_91212__(4394);
var anObject = __nested_webpack_require_91212__(1176);
var toPrimitive = __nested_webpack_require_91212__(2066);

// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 7933:
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_92116__) {

var DESCRIPTORS = __nested_webpack_require_92116__(7400);
var propertyIsEnumerableModule = __nested_webpack_require_92116__(9195);
var createPropertyDescriptor = __nested_webpack_require_92116__(5358);
var toIndexedObject = __nested_webpack_require_92116__(905);
var toPrimitive = __nested_webpack_require_92116__(2066);
var has = __nested_webpack_require_92116__(816);
var IE8_DOM_DEFINE = __nested_webpack_require_92116__(4394);

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};


/***/ }),

/***/ 166:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_93160__) {

/* eslint-disable es/no-object-getownpropertynames -- safe */
var toIndexedObject = __nested_webpack_require_93160__(905);
var $getOwnPropertyNames = __nested_webpack_require_93160__(8151).f;

var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return $getOwnPropertyNames(it);
  } catch (error) {
    return windowNames.slice();
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]'
    ? getWindowNames(it)
    : $getOwnPropertyNames(toIndexedObject(it));
};


/***/ }),

/***/ 8151:
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_93998__) {

var internalObjectKeys = __nested_webpack_require_93998__(140);
var enumBugKeys = __nested_webpack_require_93998__(3837);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 894:
/***/ (function(__unused_webpack_module, exports) {

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 7567:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_94735__) {

var has = __nested_webpack_require_94735__(816);
var toObject = __nested_webpack_require_94735__(2991);
var sharedKey = __nested_webpack_require_94735__(4399);
var CORRECT_PROTOTYPE_GETTER = __nested_webpack_require_94735__(7528);

var IE_PROTO = sharedKey('IE_PROTO');
var ObjectPrototype = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
// eslint-disable-next-line es/no-object-getprototypeof -- safe
module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectPrototype : null;
};


/***/ }),

/***/ 140:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_95560__) {

var has = __nested_webpack_require_95560__(816);
var toIndexedObject = __nested_webpack_require_95560__(905);
var indexOf = __nested_webpack_require_95560__(9540).indexOf;
var hiddenKeys = __nested_webpack_require_95560__(5977);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ 5632:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_96198__) {

var internalObjectKeys = __nested_webpack_require_96198__(140);
var enumBugKeys = __nested_webpack_require_96198__(3837);

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ 9195:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 6540:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_97336__) {

/* eslint-disable no-proto -- safe */
var anObject = __nested_webpack_require_97336__(1176);
var aPossiblePrototype = __nested_webpack_require_97336__(8505);

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
// eslint-disable-next-line es/no-object-setprototypeof -- safe
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    // eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ 7664:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_98410__) {

var DESCRIPTORS = __nested_webpack_require_98410__(7400);
var objectKeys = __nested_webpack_require_98410__(5632);
var toIndexedObject = __nested_webpack_require_98410__(905);
var propertyIsEnumerable = __nested_webpack_require_98410__(9195).f;

// `Object.{ entries, values }` methods implementation
var createMethod = function (TO_ENTRIES) {
  return function (it) {
    var O = toIndexedObject(it);
    var keys = objectKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) {
        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

module.exports = {
  // `Object.entries` method
  // https://tc39.es/ecma262/#sec-object.entries
  entries: createMethod(true),
  // `Object.values` method
  // https://tc39.es/ecma262/#sec-object.values
  values: createMethod(false)
};


/***/ }),

/***/ 4059:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_99416__) {

"use strict";

var TO_STRING_TAG_SUPPORT = __nested_webpack_require_99416__(1601);
var classof = __nested_webpack_require_99416__(1589);

// `Object.prototype.toString` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ }),

/***/ 4826:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_99861__) {

var getBuiltIn = __nested_webpack_require_99861__(1333);
var getOwnPropertyNamesModule = __nested_webpack_require_99861__(8151);
var getOwnPropertySymbolsModule = __nested_webpack_require_99861__(894);
var anObject = __nested_webpack_require_99861__(1176);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 9276:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_100498__) {

var global = __nested_webpack_require_100498__(9859);

module.exports = global;


/***/ }),

/***/ 8787:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_100663__) {

var redefine = __nested_webpack_require_100663__(7487);

module.exports = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);
  return target;
};


/***/ }),

/***/ 7487:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_100941__) {

var global = __nested_webpack_require_100941__(9859);
var createNonEnumerableProperty = __nested_webpack_require_100941__(5762);
var has = __nested_webpack_require_100941__(816);
var setGlobal = __nested_webpack_require_100941__(2079);
var inspectSource = __nested_webpack_require_100941__(8511);
var InternalStateModule = __nested_webpack_require_100941__(6407);

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  var state;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) {
      createNonEnumerableProperty(value, 'name', key);
    }
    state = enforceInternalState(value);
    if (!state.source) {
      state.source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});


/***/ }),

/***/ 8115:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_102557__) {

var classof = __nested_webpack_require_102557__(7079);
var regexpExec = __nested_webpack_require_102557__(3466);

// `RegExpExec` abstract operation
// https://tc39.es/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }

  if (classof(R) !== 'RegExp') {
    throw TypeError('RegExp#exec called on incompatible receiver');
  }

  return regexpExec.call(R, S);
};



/***/ }),

/***/ 3466:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_103249__) {

"use strict";

var regexpFlags = __nested_webpack_require_103249__(895);
var stickyHelpers = __nested_webpack_require_103249__(5650);
var shared = __nested_webpack_require_103249__(3036);

var nativeExec = RegExp.prototype.exec;
var nativeReplace = shared('native-string-replace', String.prototype.replace);

var patchedExec = nativeExec;

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();

var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;

// nonparticipating capturing group, copied from es5-shim's String#split patch.
// eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group, regexp/no-lazy-ends -- testing
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;
    var sticky = UNSUPPORTED_Y && re.sticky;
    var flags = regexpFlags.call(re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = flags.replace('y', '');
      if (flags.indexOf('g') === -1) {
        flags += 'g';
      }

      strCopy = String(str).slice(re.lastIndex);
      // Support anchored sticky behavior.
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      }
      // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.
      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = nativeExec.call(sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = match.input.slice(charsAdded);
        match[0] = match[0].slice(charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ 895:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_106156__) {

"use strict";

var anObject = __nested_webpack_require_106156__(1176);

// `RegExp.prototype.flags` getter implementation
// https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ 5650:
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_106733__) {

"use strict";


var fails = __nested_webpack_require_106733__(4229);

// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
// so we use an intermediate function.
function RE(s, f) {
  return RegExp(s, f);
}

exports.UNSUPPORTED_Y = fails(function () {
  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
  var re = RE('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') != null;
});

exports.BROKEN_CARET = fails(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = RE('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') != null;
});


/***/ }),

/***/ 8885:
/***/ (function(module) {

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 2079:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_107717__) {

var global = __nested_webpack_require_107717__(9859);
var createNonEnumerableProperty = __nested_webpack_require_107717__(5762);

module.exports = function (key, value) {
  try {
    createNonEnumerableProperty(global, key, value);
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ 1832:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_108086__) {

"use strict";

var getBuiltIn = __nested_webpack_require_108086__(1333);
var definePropertyModule = __nested_webpack_require_108086__(1787);
var wellKnownSymbol = __nested_webpack_require_108086__(95);
var DESCRIPTORS = __nested_webpack_require_108086__(7400);

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  }
};


/***/ }),

/***/ 4555:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_108764__) {

var defineProperty = __nested_webpack_require_108764__(1787).f;
var has = __nested_webpack_require_108764__(816);
var wellKnownSymbol = __nested_webpack_require_108764__(95);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ 4399:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_109246__) {

var shared = __nested_webpack_require_109246__(3036);
var uid = __nested_webpack_require_109246__(1441);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 5353:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_109534__) {

var global = __nested_webpack_require_109534__(9859);
var setGlobal = __nested_webpack_require_109534__(2079);

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;


/***/ }),

/***/ 3036:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_109830__) {

var IS_PURE = __nested_webpack_require_109830__(4231);
var store = __nested_webpack_require_109830__(5353);

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.11.3',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: ' 2021 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ 7942:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_110264__) {

var anObject = __nested_webpack_require_110264__(1176);
var aFunction = __nested_webpack_require_110264__(3819);
var wellKnownSymbol = __nested_webpack_require_110264__(95);

var SPECIES = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.es/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
};


/***/ }),

/***/ 3689:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_110837__) {

var fails = __nested_webpack_require_110837__(4229);

// check the existence of a method, lowercase
// of a tag and escaping quotes in arguments
module.exports = function (METHOD_NAME) {
  return fails(function () {
    var test = ''[METHOD_NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  });
};


/***/ }),

/***/ 966:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_111253__) {

var toInteger = __nested_webpack_require_111253__(6051);
var requireObjectCoercible = __nested_webpack_require_111253__(8885);

// `String.prototype.{ codePointAt, at }` methods implementation
var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = String(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING ? S.charAt(position) : first
        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ 3124:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_112463__) {

"use strict";

var toInteger = __nested_webpack_require_112463__(6051);
var requireObjectCoercible = __nested_webpack_require_112463__(8885);

// `String.prototype.repeat` method implementation
// https://tc39.es/ecma262/#sec-string.prototype.repeat
module.exports = function repeat(count) {
  var str = String(requireObjectCoercible(this));
  var result = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
  return result;
};


/***/ }),

/***/ 1017:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_113091__) {

var requireObjectCoercible = __nested_webpack_require_113091__(8885);
var whitespaces = __nested_webpack_require_113091__(1647);

var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = String(requireObjectCoercible($this));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.es/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.es/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};


/***/ }),

/***/ 143:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_114214__) {

var classof = __nested_webpack_require_114214__(7079);

// `thisNumberValue` abstract operation
// https://tc39.es/ecma262/#sec-thisnumbervalue
module.exports = function (value) {
  if (typeof value != 'number' && classof(value) != 'Number') {
    throw TypeError('Incorrect invocation');
  }
  return +value;
};


/***/ }),

/***/ 3231:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_114612__) {

var toInteger = __nested_webpack_require_114612__(6051);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 7331:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_115141__) {

var toInteger = __nested_webpack_require_115141__(6051);
var toLength = __nested_webpack_require_115141__(4237);

// `ToIndex` abstract operation
// https://tc39.es/ecma262/#sec-toindex
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length or index');
  return length;
};


/***/ }),

/***/ 905:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_115615__) {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __nested_webpack_require_115615__(9337);
var requireObjectCoercible = __nested_webpack_require_115615__(8885);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 6051:
/***/ (function(module) {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.es/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};


/***/ }),

/***/ 4237:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_116264__) {

var toInteger = __nested_webpack_require_116264__(6051);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 2991:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_116651__) {

var requireObjectCoercible = __nested_webpack_require_116651__(8885);

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 4262:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_116974__) {

var toPositiveInteger = __nested_webpack_require_116974__(2002);

module.exports = function (it, BYTES) {
  var offset = toPositiveInteger(it);
  if (offset % BYTES) throw RangeError('Wrong offset');
  return offset;
};


/***/ }),

/***/ 2002:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_117279__) {

var toInteger = __nested_webpack_require_117279__(6051);

module.exports = function (it) {
  var result = toInteger(it);
  if (result < 0) throw RangeError("The argument can't be less than 0");
  return result;
};


/***/ }),

/***/ 2066:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_117578__) {

var isObject = __nested_webpack_require_117578__(5052);

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 1601:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_118441__) {

var wellKnownSymbol = __nested_webpack_require_118441__(95);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 2574:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_118732__) {

"use strict";

var $ = __nested_webpack_require_118732__(3103);
var global = __nested_webpack_require_118732__(9859);
var DESCRIPTORS = __nested_webpack_require_118732__(7400);
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __nested_webpack_require_118732__(8200);
var ArrayBufferViewCore = __nested_webpack_require_118732__(9918);
var ArrayBufferModule = __nested_webpack_require_118732__(3816);
var anInstance = __nested_webpack_require_118732__(7728);
var createPropertyDescriptor = __nested_webpack_require_118732__(5358);
var createNonEnumerableProperty = __nested_webpack_require_118732__(5762);
var toLength = __nested_webpack_require_118732__(4237);
var toIndex = __nested_webpack_require_118732__(7331);
var toOffset = __nested_webpack_require_118732__(4262);
var toPrimitive = __nested_webpack_require_118732__(2066);
var has = __nested_webpack_require_118732__(816);
var classof = __nested_webpack_require_118732__(1589);
var isObject = __nested_webpack_require_118732__(5052);
var create = __nested_webpack_require_118732__(2391);
var setPrototypeOf = __nested_webpack_require_118732__(6540);
var getOwnPropertyNames = __nested_webpack_require_118732__(8151).f;
var typedArrayFrom = __nested_webpack_require_118732__(5215);
var forEach = __nested_webpack_require_118732__(9996).forEach;
var setSpecies = __nested_webpack_require_118732__(1832);
var definePropertyModule = __nested_webpack_require_118732__(1787);
var getOwnPropertyDescriptorModule = __nested_webpack_require_118732__(7933);
var InternalStateModule = __nested_webpack_require_118732__(6407);
var inheritIfRequired = __nested_webpack_require_118732__(835);

var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var round = Math.round;
var RangeError = global.RangeError;
var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var DataView = ArrayBufferModule.DataView;
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
var TypedArray = ArrayBufferViewCore.TypedArray;
var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var isTypedArray = ArrayBufferViewCore.isTypedArray;
var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
var WRONG_LENGTH = 'Wrong length';

var fromList = function (C, list) {
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
};

var addGetter = function (it, key) {
  nativeDefineProperty(it, key, { get: function () {
    return getInternalState(this)[key];
  } });
};

var isArrayBuffer = function (it) {
  var klass;
  return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
};

var isTypedArrayIndex = function (target, key) {
  return isTypedArray(target)
    && typeof key != 'symbol'
    && key in target
    && String(+key) == String(key);
};

var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
  return isTypedArrayIndex(target, key = toPrimitive(key, true))
    ? createPropertyDescriptor(2, target[key])
    : nativeGetOwnPropertyDescriptor(target, key);
};

var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
  if (isTypedArrayIndex(target, key = toPrimitive(key, true))
    && isObject(descriptor)
    && has(descriptor, 'value')
    && !has(descriptor, 'get')
    && !has(descriptor, 'set')
    // TODO: add validation descriptor w/o calling accessors
    && !descriptor.configurable
    && (!has(descriptor, 'writable') || descriptor.writable)
    && (!has(descriptor, 'enumerable') || descriptor.enumerable)
  ) {
    target[key] = descriptor.value;
    return target;
  } return nativeDefineProperty(target, key, descriptor);
};

if (DESCRIPTORS) {
  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
    definePropertyModule.f = wrappedDefineProperty;
    addGetter(TypedArrayPrototype, 'buffer');
    addGetter(TypedArrayPrototype, 'byteOffset');
    addGetter(TypedArrayPrototype, 'byteLength');
    addGetter(TypedArrayPrototype, 'length');
  }

  $({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
    defineProperty: wrappedDefineProperty
  });

  module.exports = function (TYPE, wrapper, CLAMPED) {
    var BYTES = TYPE.match(/\d+$/)[0] / 8;
    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + TYPE;
    var SETTER = 'set' + TYPE;
    var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];
    var TypedArrayConstructor = NativeTypedArrayConstructor;
    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
    var exported = {};

    var getter = function (that, index) {
      var data = getInternalState(that);
      return data.view[GETTER](index * BYTES + data.byteOffset, true);
    };

    var setter = function (that, index, value) {
      var data = getInternalState(that);
      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
    };

    var addElement = function (that, index) {
      nativeDefineProperty(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
        anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
        var index = 0;
        var byteOffset = 0;
        var buffer, byteLength, length;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new ArrayBuffer(byteLength);
        } else if (isArrayBuffer(data)) {
          buffer = data;
          byteOffset = toOffset(offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - byteOffset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (isTypedArray(data)) {
          return fromList(TypedArrayConstructor, data);
        } else {
          return typedArrayFrom.call(TypedArrayConstructor, data);
        }
        setInternalState(that, {
          buffer: buffer,
          byteOffset: byteOffset,
          byteLength: byteLength,
          length: length,
          view: new DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
        anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
        return inheritIfRequired(function () {
          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
          if (isArrayBuffer(data)) return $length !== undefined
            ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)
            : typedArrayOffset !== undefined
              ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))
              : new NativeTypedArrayConstructor(data);
          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
          return typedArrayFrom.call(TypedArrayConstructor, data);
        }(), dummy, TypedArrayConstructor);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
        if (!(key in TypedArrayConstructor)) {
          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
        }
      });
      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
    }

    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
    }

    if (TYPED_ARRAY_TAG) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
    }

    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

    $({
      global: true, forced: TypedArrayConstructor != NativeTypedArrayConstructor, sham: !NATIVE_ARRAY_BUFFER_VIEWS
    }, exported);

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
    }

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
    }

    setSpecies(CONSTRUCTOR_NAME);
  };
} else module.exports = function () { /* empty */ };


/***/ }),

/***/ 8200:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_128124__) {

/* eslint-disable no-new -- required for testing */
var global = __nested_webpack_require_128124__(9859);
var fails = __nested_webpack_require_128124__(4229);
var checkCorrectnessOfIteration = __nested_webpack_require_128124__(4575);
var NATIVE_ARRAY_BUFFER_VIEWS = __nested_webpack_require_128124__(9918).NATIVE_ARRAY_BUFFER_VIEWS;

var ArrayBuffer = global.ArrayBuffer;
var Int8Array = global.Int8Array;

module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function () {
  Int8Array(1);
}) || !fails(function () {
  new Int8Array(-1);
}) || !checkCorrectnessOfIteration(function (iterable) {
  new Int8Array();
  new Int8Array(null);
  new Int8Array(1.5);
  new Int8Array(iterable);
}, true) || fails(function () {
  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
  return new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1;
});


/***/ }),

/***/ 8874:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_129048__) {

var aTypedArrayConstructor = __nested_webpack_require_129048__(9918).aTypedArrayConstructor;
var speciesConstructor = __nested_webpack_require_129048__(7942);

module.exports = function (instance, list) {
  var C = speciesConstructor(instance, instance.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
};


/***/ }),

/***/ 5215:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_129563__) {

var toObject = __nested_webpack_require_129563__(2991);
var toLength = __nested_webpack_require_129563__(4237);
var getIteratorMethod = __nested_webpack_require_129563__(8830);
var isArrayIteratorMethod = __nested_webpack_require_129563__(1943);
var bind = __nested_webpack_require_129563__(7636);
var aTypedArrayConstructor = __nested_webpack_require_129563__(9918).aTypedArrayConstructor;

module.exports = function from(source /* , mapfn, thisArg */) {
  var O = toObject(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var i, length, result, step, iterator, next;
  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    O = [];
    while (!(step = next.call(iterator)).done) {
      O.push(step.value);
    }
  }
  if (mapping && argumentsLength > 2) {
    mapfn = bind(mapfn, arguments[2], 2);
  }
  length = toLength(O.length);
  result = new (aTypedArrayConstructor(this))(length);
  for (i = 0; length > i; i++) {
    result[i] = mapping ? mapfn(O[i], i) : O[i];
  }
  return result;
};


/***/ }),

/***/ 1441:
/***/ (function(module) {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};


/***/ }),

/***/ 6969:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_131043__) {

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __nested_webpack_require_131043__(3839);

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 5391:
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_131338__) {

var wellKnownSymbol = __nested_webpack_require_131338__(95);

exports.f = wellKnownSymbol;


/***/ }),

/***/ 95:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_131512__) {

var global = __nested_webpack_require_131512__(9859);
var shared = __nested_webpack_require_131512__(3036);
var has = __nested_webpack_require_131512__(816);
var uid = __nested_webpack_require_131512__(1441);
var NATIVE_SYMBOL = __nested_webpack_require_131512__(3839);
var USE_SYMBOL_AS_UID = __nested_webpack_require_131512__(6969);

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    if (NATIVE_SYMBOL && has(Symbol, name)) {
      WellKnownSymbolsStore[name] = Symbol[name];
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
    }
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 1647:
/***/ (function(module) {

// a string of all valid unicode whitespaces
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ 2994:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_132706__) {

"use strict";

var $ = __nested_webpack_require_132706__(3103);
var fails = __nested_webpack_require_132706__(4229);
var ArrayBufferModule = __nested_webpack_require_132706__(3816);
var anObject = __nested_webpack_require_132706__(1176);
var toAbsoluteIndex = __nested_webpack_require_132706__(3231);
var toLength = __nested_webpack_require_132706__(4237);
var speciesConstructor = __nested_webpack_require_132706__(7942);

var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var DataView = ArrayBufferModule.DataView;
var nativeArrayBufferSlice = ArrayBuffer.prototype.slice;

var INCORRECT_SLICE = fails(function () {
  return !new ArrayBuffer(2).slice(1, undefined).byteLength;
});

// `ArrayBuffer.prototype.slice` method
// https://tc39.es/ecma262/#sec-arraybuffer.prototype.slice
$({ target: 'ArrayBuffer', proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
  slice: function slice(start, end) {
    if (nativeArrayBufferSlice !== undefined && end === undefined) {
      return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
    }
    var length = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    var result = new (speciesConstructor(this, ArrayBuffer))(toLength(fin - first));
    var viewSource = new DataView(this);
    var viewTarget = new DataView(result);
    var index = 0;
    while (first < fin) {
      viewTarget.setUint8(index++, viewSource.getUint8(first++));
    } return result;
  }
});


/***/ }),

/***/ 8178:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_134252__) {

"use strict";

var $ = __nested_webpack_require_134252__(3103);
var fails = __nested_webpack_require_134252__(4229);
var isArray = __nested_webpack_require_134252__(3718);
var isObject = __nested_webpack_require_134252__(5052);
var toObject = __nested_webpack_require_134252__(2991);
var toLength = __nested_webpack_require_134252__(4237);
var createProperty = __nested_webpack_require_134252__(2324);
var arraySpeciesCreate = __nested_webpack_require_134252__(7501);
var arrayMethodHasSpeciesSupport = __nested_webpack_require_134252__(1460);
var wellKnownSymbol = __nested_webpack_require_134252__(95);
var V8_VERSION = __nested_webpack_require_134252__(6358);

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

// `Array.prototype.concat` method
// https://tc39.es/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({ target: 'Array', proto: true, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars -- required for `.length`
  concat: function concat(arg) {
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = toLength(E.length);
        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});


/***/ }),

/***/ 2656:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_136658__) {

var $ = __nested_webpack_require_136658__(3103);
var fill = __nested_webpack_require_136658__(7065);
var addToUnscopables = __nested_webpack_require_136658__(9736);

// `Array.prototype.fill` method
// https://tc39.es/ecma262/#sec-array.prototype.fill
$({ target: 'Array', proto: true }, {
  fill: fill
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('fill');


/***/ }),

/***/ 5342:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_137128__) {

"use strict";

var $ = __nested_webpack_require_137128__(3103);
var $filter = __nested_webpack_require_137128__(9996).filter;
var arrayMethodHasSpeciesSupport = __nested_webpack_require_137128__(1460);

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');

// `Array.prototype.filter` method
// https://tc39.es/ecma262/#sec-array.prototype.filter
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ 9949:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_137817__) {

"use strict";

var $ = __nested_webpack_require_137817__(3103);
var $findIndex = __nested_webpack_require_137817__(9996).findIndex;
var addToUnscopables = __nested_webpack_require_137817__(9736);

var FIND_INDEX = 'findIndex';
var SKIPS_HOLES = true;

// Shouldn't skip holes
if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES = false; });

// `Array.prototype.findIndex` method
// https://tc39.es/ecma262/#sec-array.prototype.findindex
$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND_INDEX);


/***/ }),

/***/ 9228:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_138667__) {

"use strict";

var $ = __nested_webpack_require_138667__(3103);
var $find = __nested_webpack_require_138667__(9996).find;
var addToUnscopables = __nested_webpack_require_138667__(9736);

var FIND = 'find';
var SKIPS_HOLES = true;

// Shouldn't skip holes
if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

// `Array.prototype.find` method
// https://tc39.es/ecma262/#sec-array.prototype.find
$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND);


/***/ }),

/***/ 4870:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_139453__) {

"use strict";

var $ = __nested_webpack_require_139453__(3103);
var flattenIntoArray = __nested_webpack_require_139453__(4990);
var toObject = __nested_webpack_require_139453__(2991);
var toLength = __nested_webpack_require_139453__(4237);
var aFunction = __nested_webpack_require_139453__(3819);
var arraySpeciesCreate = __nested_webpack_require_139453__(7501);

// `Array.prototype.flatMap` method
// https://tc39.es/ecma262/#sec-array.prototype.flatmap
$({ target: 'Array', proto: true }, {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A;
    aFunction(callbackfn);
    A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return A;
  }
});


/***/ }),

/***/ 7233:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_140319__) {

var $ = __nested_webpack_require_140319__(3103);
var from = __nested_webpack_require_140319__(507);
var checkCorrectnessOfIteration = __nested_webpack_require_140319__(4575);

var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  // eslint-disable-next-line es/no-array-from -- required for testing
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.es/ecma262/#sec-array.from
$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
  from: from
});


/***/ }),

/***/ 9529:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_140895__) {

"use strict";

var $ = __nested_webpack_require_140895__(3103);
var $includes = __nested_webpack_require_140895__(9540).includes;
var addToUnscopables = __nested_webpack_require_140895__(9736);

// `Array.prototype.includes` method
// https://tc39.es/ecma262/#sec-array.prototype.includes
$({ target: 'Array', proto: true }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');


/***/ }),

/***/ 5735:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_141519__) {

"use strict";

var toIndexedObject = __nested_webpack_require_141519__(905);
var addToUnscopables = __nested_webpack_require_141519__(9736);
var Iterators = __nested_webpack_require_141519__(5495);
var InternalStateModule = __nested_webpack_require_141519__(6407);
var defineIterator = __nested_webpack_require_141519__(7675);

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.es/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.es/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.es/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.es/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
// https://tc39.es/ecma262/#sec-createmappedargumentsobject
Iterators.Arguments = Iterators.Array;

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ 6781:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_143720__) {

"use strict";

var $ = __nested_webpack_require_143720__(3103);
var IndexedObject = __nested_webpack_require_143720__(9337);
var toIndexedObject = __nested_webpack_require_143720__(905);
var arrayMethodIsStrict = __nested_webpack_require_143720__(6038);

var nativeJoin = [].join;

var ES3_STRINGS = IndexedObject != Object;
var STRICT_METHOD = arrayMethodIsStrict('join', ',');

// `Array.prototype.join` method
// https://tc39.es/ecma262/#sec-array.prototype.join
$({ target: 'Array', proto: true, forced: ES3_STRINGS || !STRICT_METHOD }, {
  join: function join(separator) {
    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
  }
});


/***/ }),

/***/ 3450:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_144460__) {

"use strict";

var $ = __nested_webpack_require_144460__(3103);
var $map = __nested_webpack_require_144460__(9996).map;
var arrayMethodHasSpeciesSupport = __nested_webpack_require_144460__(1460);

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');

// `Array.prototype.map` method
// https://tc39.es/ecma262/#sec-array.prototype.map
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ 2501:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_145125__) {

"use strict";

var $ = __nested_webpack_require_145125__(3103);
var isObject = __nested_webpack_require_145125__(5052);
var isArray = __nested_webpack_require_145125__(3718);
var toAbsoluteIndex = __nested_webpack_require_145125__(3231);
var toLength = __nested_webpack_require_145125__(4237);
var toIndexedObject = __nested_webpack_require_145125__(905);
var createProperty = __nested_webpack_require_145125__(2324);
var wellKnownSymbol = __nested_webpack_require_145125__(95);
var arrayMethodHasSpeciesSupport = __nested_webpack_require_145125__(1460);

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');

var SPECIES = wellKnownSymbol('species');
var nativeSlice = [].slice;
var max = Math.max;

// `Array.prototype.slice` method
// https://tc39.es/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = toLength(O.length);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
    var Constructor, result, n;
    if (isArray(O)) {
      Constructor = O.constructor;
      // cross-realm fallback
      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES];
        if (Constructor === null) Constructor = undefined;
      }
      if (Constructor === Array || Constructor === undefined) {
        return nativeSlice.call(O, k, fin);
      }
    }
    result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  }
});


/***/ }),

/***/ 9805:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_147105__) {

"use strict";

var $ = __nested_webpack_require_147105__(3103);
var toAbsoluteIndex = __nested_webpack_require_147105__(3231);
var toInteger = __nested_webpack_require_147105__(6051);
var toLength = __nested_webpack_require_147105__(4237);
var toObject = __nested_webpack_require_147105__(2991);
var arraySpeciesCreate = __nested_webpack_require_147105__(7501);
var createProperty = __nested_webpack_require_147105__(2324);
var arrayMethodHasSpeciesSupport = __nested_webpack_require_147105__(1460);

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');

var max = Math.max;
var min = Math.min;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

// `Array.prototype.splice` method
// https://tc39.es/ecma262/#sec-array.prototype.splice
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
  splice: function splice(start, deleteCount /* , ...items */) {
    var O = toObject(this);
    var len = toLength(O.length);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
    }
    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
    }
    A = arraySpeciesCreate(O, actualDeleteCount);
    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }
    A.length = actualDeleteCount;
    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
    }
    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }
    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});


/***/ }),

/***/ 3985:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_149751__) {

// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = __nested_webpack_require_149751__(9736);

// https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('flatMap');


/***/ }),

/***/ 6936:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_150128__) {

var DESCRIPTORS = __nested_webpack_require_150128__(7400);
var defineProperty = __nested_webpack_require_150128__(1787).f;

var FunctionPrototype = Function.prototype;
var FunctionPrototypeToString = FunctionPrototype.toString;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// Function instances `.name` property
// https://tc39.es/ecma262/#sec-function-instances-name
if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
  defineProperty(FunctionPrototype, NAME, {
    configurable: true,
    get: function () {
      try {
        return FunctionPrototypeToString.call(this).match(nameRE)[1];
      } catch (error) {
        return '';
      }
    }
  });
}


/***/ }),

/***/ 1245:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_150886__) {

"use strict";

var DESCRIPTORS = __nested_webpack_require_150886__(7400);
var global = __nested_webpack_require_150886__(9859);
var isForced = __nested_webpack_require_150886__(6541);
var redefine = __nested_webpack_require_150886__(7487);
var has = __nested_webpack_require_150886__(816);
var classof = __nested_webpack_require_150886__(7079);
var inheritIfRequired = __nested_webpack_require_150886__(835);
var toPrimitive = __nested_webpack_require_150886__(2066);
var fails = __nested_webpack_require_150886__(4229);
var create = __nested_webpack_require_150886__(2391);
var getOwnPropertyNames = __nested_webpack_require_150886__(8151).f;
var getOwnPropertyDescriptor = __nested_webpack_require_150886__(7933).f;
var defineProperty = __nested_webpack_require_150886__(1787).f;
var trim = __nested_webpack_require_150886__(1017).trim;

var NUMBER = 'Number';
var NativeNumber = global[NUMBER];
var NumberPrototype = NativeNumber.prototype;

// Opera ~12 has broken Object#toString
var BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER;

// `ToNumber` abstract operation
// https://tc39.es/ecma262/#sec-tonumber
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  var first, third, radix, maxCode, digits, length, index, code;
  if (typeof it == 'string' && it.length > 2) {
    it = trim(it);
    first = it.charCodeAt(0);
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
        default: return +it;
      }
      digits = it.slice(2);
      length = digits.length;
      for (index = 0; index < length; index++) {
        code = digits.charCodeAt(index);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

// `Number` constructor
// https://tc39.es/ecma262/#sec-number-constructor
if (isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
  var NumberWrapper = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var dummy = this;
    return dummy instanceof NumberWrapper
      // check on 1..constructor(foo) case
      && (BROKEN_CLASSOF ? fails(function () { NumberPrototype.valueOf.call(dummy); }) : classof(dummy) != NUMBER)
        ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
  };
  for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES2015 (in case, if modules with ES2015 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,' +
    // ESNext
    'fromString,range'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(NativeNumber, key = keys[j]) && !has(NumberWrapper, key)) {
      defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
    }
  }
  NumberWrapper.prototype = NumberPrototype;
  NumberPrototype.constructor = NumberWrapper;
  redefine(global, NUMBER, NumberWrapper);
}


/***/ }),

/***/ 8143:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_154380__) {

var $ = __nested_webpack_require_154380__(3103);

// `Number.MAX_SAFE_INTEGER` constant
// https://tc39.es/ecma262/#sec-number.max_safe_integer
$({ target: 'Number', stat: true }, {
  MAX_SAFE_INTEGER: 0x1FFFFFFFFFFFFF
});


/***/ }),

/***/ 2023:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_154705__) {

var $ = __nested_webpack_require_154705__(3103);

// `Number.MIN_SAFE_INTEGER` constant
// https://tc39.es/ecma262/#sec-number.min_safe_integer
$({ target: 'Number', stat: true }, {
  MIN_SAFE_INTEGER: -0x1FFFFFFFFFFFFF
});


/***/ }),

/***/ 1321:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_155031__) {

"use strict";

var $ = __nested_webpack_require_155031__(3103);
var toInteger = __nested_webpack_require_155031__(6051);
var thisNumberValue = __nested_webpack_require_155031__(143);
var repeat = __nested_webpack_require_155031__(3124);
var fails = __nested_webpack_require_155031__(4229);

var nativeToFixed = 1.0.toFixed;
var floor = Math.floor;

var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

var multiply = function (data, n, c) {
  var index = -1;
  var c2 = c;
  while (++index < 6) {
    c2 += n * data[index];
    data[index] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};

var divide = function (data, n) {
  var index = 6;
  var c = 0;
  while (--index >= 0) {
    c += data[index];
    data[index] = floor(c / n);
    c = (c % n) * 1e7;
  }
};

var dataToString = function (data) {
  var index = 6;
  var s = '';
  while (--index >= 0) {
    if (s !== '' || index === 0 || data[index] !== 0) {
      var t = String(data[index]);
      s = s === '' ? t : s + repeat.call('0', 7 - t.length) + t;
    }
  } return s;
};

var FORCED = nativeToFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !fails(function () {
  // V8 ~ Android 4.3-
  nativeToFixed.call({});
});

// `Number.prototype.toFixed` method
// https://tc39.es/ecma262/#sec-number.prototype.tofixed
$({ target: 'Number', proto: true, forced: FORCED }, {
  toFixed: function toFixed(fractionDigits) {
    var number = thisNumberValue(this);
    var fractDigits = toInteger(fractionDigits);
    var data = [0, 0, 0, 0, 0, 0];
    var sign = '';
    var result = '0';
    var e, z, j, k;

    if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits');
    // eslint-disable-next-line no-self-compare -- NaN check
    if (number != number) return 'NaN';
    if (number <= -1e21 || number >= 1e21) return String(number);
    if (number < 0) {
      sign = '-';
      number = -number;
    }
    if (number > 1e-21) {
      e = log(number * pow(2, 69, 1)) - 69;
      z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(data, 0, z);
        j = fractDigits;
        while (j >= 7) {
          multiply(data, 1e7, 0);
          j -= 7;
        }
        multiply(data, pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(data, 1 << 23);
          j -= 23;
        }
        divide(data, 1 << j);
        multiply(data, 1, 1);
        divide(data, 2);
        result = dataToString(data);
      } else {
        multiply(data, 0, z);
        multiply(data, 1 << -e, 0);
        result = dataToString(data) + repeat.call('0', fractDigits);
      }
    }
    if (fractDigits > 0) {
      k = result.length;
      result = sign + (k <= fractDigits
        ? '0.' + repeat.call('0', fractDigits - k) + result
        : result.slice(0, k - fractDigits) + '.' + result.slice(k - fractDigits));
    } else {
      result = sign + result;
    } return result;
  }
});


/***/ }),

/***/ 2144:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_158419__) {

var $ = __nested_webpack_require_158419__(3103);
var FREEZING = __nested_webpack_require_158419__(8476);
var fails = __nested_webpack_require_158419__(4229);
var isObject = __nested_webpack_require_158419__(5052);
var onFreeze = __nested_webpack_require_158419__(5926).onFreeze;

// eslint-disable-next-line es/no-object-freeze -- safe
var $freeze = Object.freeze;
var FAILS_ON_PRIMITIVES = fails(function () { $freeze(1); });

// `Object.freeze` method
// https://tc39.es/ecma262/#sec-object.freeze
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
  freeze: function freeze(it) {
    return $freeze && isObject(it) ? $freeze(onFreeze(it)) : it;
  }
});


/***/ }),

/***/ 8625:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_159154__) {

var $ = __nested_webpack_require_159154__(3103);
var fails = __nested_webpack_require_159154__(4229);
var toIndexedObject = __nested_webpack_require_159154__(905);
var nativeGetOwnPropertyDescriptor = __nested_webpack_require_159154__(7933).f;
var DESCRIPTORS = __nested_webpack_require_159154__(7400);

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetOwnPropertyDescriptor(1); });
var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
$({ target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
  }
});


/***/ }),

/***/ 2775:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_159972__) {

var $ = __nested_webpack_require_159972__(3103);
var DESCRIPTORS = __nested_webpack_require_159972__(7400);
var ownKeys = __nested_webpack_require_159972__(4826);
var toIndexedObject = __nested_webpack_require_159972__(905);
var getOwnPropertyDescriptorModule = __nested_webpack_require_159972__(7933);
var createProperty = __nested_webpack_require_159972__(2324);

// `Object.getOwnPropertyDescriptors` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject(object);
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var keys = ownKeys(O);
    var result = {};
    var index = 0;
    var key, descriptor;
    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty(result, key, descriptor);
    }
    return result;
  }
});


/***/ }),

/***/ 6928:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_161023__) {

var $ = __nested_webpack_require_161023__(3103);
var fails = __nested_webpack_require_161023__(4229);
var toObject = __nested_webpack_require_161023__(2991);
var nativeGetPrototypeOf = __nested_webpack_require_161023__(7567);
var CORRECT_PROTOTYPE_GETTER = __nested_webpack_require_161023__(7528);

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetPrototypeOf(1); });

// `Object.getPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.getprototypeof
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject(it));
  }
});



/***/ }),

/***/ 4769:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_161736__) {

var $ = __nested_webpack_require_161736__(3103);
var toObject = __nested_webpack_require_161736__(2991);
var nativeKeys = __nested_webpack_require_161736__(5632);
var fails = __nested_webpack_require_161736__(4229);

var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});


/***/ }),

/***/ 2506:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_162287__) {

var $ = __nested_webpack_require_162287__(3103);
var setPrototypeOf = __nested_webpack_require_162287__(6540);

// `Object.setPrototypeOf` method
// https://tc39.es/ecma262/#sec-object.setprototypeof
$({ target: 'Object', stat: true }, {
  setPrototypeOf: setPrototypeOf
});


/***/ }),

/***/ 8188:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_162650__) {

var TO_STRING_TAG_SUPPORT = __nested_webpack_require_162650__(1601);
var redefine = __nested_webpack_require_162650__(7487);
var toString = __nested_webpack_require_162650__(4059);

// `Object.prototype.toString` method
// https://tc39.es/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  redefine(Object.prototype, 'toString', toString, { unsafe: true });
}


/***/ }),

/***/ 7890:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_163104__) {

var $ = __nested_webpack_require_163104__(3103);
var $values = __nested_webpack_require_163104__(7664).values;

// `Object.values` method
// https://tc39.es/ecma262/#sec-object.values
$({ target: 'Object', stat: true }, {
  values: function values(O) {
    return $values(O);
  }
});


/***/ }),

/***/ 1229:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_163476__) {

var $ = __nested_webpack_require_163476__(3103);
var getBuiltIn = __nested_webpack_require_163476__(1333);
var aFunction = __nested_webpack_require_163476__(3819);
var anObject = __nested_webpack_require_163476__(1176);
var isObject = __nested_webpack_require_163476__(5052);
var create = __nested_webpack_require_163476__(2391);
var bind = __nested_webpack_require_163476__(4128);
var fails = __nested_webpack_require_163476__(4229);

var nativeConstruct = getBuiltIn('Reflect', 'construct');

// `Reflect.construct` method
// https://tc39.es/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  nativeConstruct(function () { /* empty */ });
});
var FORCED = NEW_TARGET_BUG || ARGS_BUG;

$({ target: 'Reflect', stat: true, forced: FORCED, sham: FORCED }, {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),

/***/ 4565:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_165703__) {

var $ = __nested_webpack_require_165703__(3103);
var isObject = __nested_webpack_require_165703__(5052);
var anObject = __nested_webpack_require_165703__(1176);
var has = __nested_webpack_require_165703__(816);
var getOwnPropertyDescriptorModule = __nested_webpack_require_165703__(7933);
var getPrototypeOf = __nested_webpack_require_165703__(7567);

// `Reflect.get` method
// https://tc39.es/ecma262/#sec-reflect.get
function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var descriptor, prototype;
  if (anObject(target) === receiver) return target[propertyKey];
  if (descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey)) return has(descriptor, 'value')
    ? descriptor.value
    : descriptor.get === undefined
      ? undefined
      : descriptor.get.call(receiver);
  if (isObject(prototype = getPrototypeOf(target))) return get(prototype, propertyKey, receiver);
}

$({ target: 'Reflect', stat: true }, {
  get: get
});


/***/ }),

/***/ 7368:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_166741__) {

var DESCRIPTORS = __nested_webpack_require_166741__(7400);
var global = __nested_webpack_require_166741__(9859);
var isForced = __nested_webpack_require_166741__(6541);
var inheritIfRequired = __nested_webpack_require_166741__(835);
var defineProperty = __nested_webpack_require_166741__(1787).f;
var getOwnPropertyNames = __nested_webpack_require_166741__(8151).f;
var isRegExp = __nested_webpack_require_166741__(8311);
var getFlags = __nested_webpack_require_166741__(895);
var stickyHelpers = __nested_webpack_require_166741__(5650);
var redefine = __nested_webpack_require_166741__(7487);
var fails = __nested_webpack_require_166741__(4229);
var enforceInternalState = __nested_webpack_require_166741__(6407).enforce;
var setSpecies = __nested_webpack_require_166741__(1832);
var wellKnownSymbol = __nested_webpack_require_166741__(95);

var MATCH = wellKnownSymbol('match');
var NativeRegExp = global.RegExp;
var RegExpPrototype = NativeRegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;

// "new" should create a new object, old webkit bug
var CORRECT_NEW = new NativeRegExp(re1) !== re1;

var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;

var FORCED = DESCRIPTORS && isForced('RegExp', (!CORRECT_NEW || UNSUPPORTED_Y || fails(function () {
  re2[MATCH] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
})));

// `RegExp` constructor
// https://tc39.es/ecma262/#sec-regexp-constructor
if (FORCED) {
  var RegExpWrapper = function RegExp(pattern, flags) {
    var thisIsRegExp = this instanceof RegExpWrapper;
    var patternIsRegExp = isRegExp(pattern);
    var flagsAreUndefined = flags === undefined;
    var sticky;

    if (!thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined) {
      return pattern;
    }

    if (CORRECT_NEW) {
      if (patternIsRegExp && !flagsAreUndefined) pattern = pattern.source;
    } else if (pattern instanceof RegExpWrapper) {
      if (flagsAreUndefined) flags = getFlags.call(pattern);
      pattern = pattern.source;
    }

    if (UNSUPPORTED_Y) {
      sticky = !!flags && flags.indexOf('y') > -1;
      if (sticky) flags = flags.replace(/y/g, '');
    }

    var result = inheritIfRequired(
      CORRECT_NEW ? new NativeRegExp(pattern, flags) : NativeRegExp(pattern, flags),
      thisIsRegExp ? this : RegExpPrototype,
      RegExpWrapper
    );

    if (UNSUPPORTED_Y && sticky) {
      var state = enforceInternalState(result);
      state.sticky = true;
    }

    return result;
  };
  var proxy = function (key) {
    key in RegExpWrapper || defineProperty(RegExpWrapper, key, {
      configurable: true,
      get: function () { return NativeRegExp[key]; },
      set: function (it) { NativeRegExp[key] = it; }
    });
  };
  var keys = getOwnPropertyNames(NativeRegExp);
  var index = 0;
  while (keys.length > index) proxy(keys[index++]);
  RegExpPrototype.constructor = RegExpWrapper;
  RegExpWrapper.prototype = RegExpPrototype;
  redefine(global, 'RegExp', RegExpWrapper);
}

// https://tc39.es/ecma262/#sec-get-regexp-@@species
setSpecies('RegExp');


/***/ }),

/***/ 7950:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_169853__) {

"use strict";

var $ = __nested_webpack_require_169853__(3103);
var exec = __nested_webpack_require_169853__(3466);

// `RegExp.prototype.exec` method
// https://tc39.es/ecma262/#sec-regexp.prototype.exec
$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
  exec: exec
});


/***/ }),

/***/ 8233:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_170229__) {

"use strict";

var redefine = __nested_webpack_require_170229__(7487);
var anObject = __nested_webpack_require_170229__(1176);
var fails = __nested_webpack_require_170229__(4229);
var flags = __nested_webpack_require_170229__(895);

var TO_STRING = 'toString';
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING];

var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = nativeToString.name != TO_STRING;

// `RegExp.prototype.toString` method
// https://tc39.es/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) {
  redefine(RegExp.prototype, TO_STRING, function toString() {
    var R = anObject(this);
    var p = String(R.source);
    var rf = R.flags;
    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? flags.call(R) : rf);
    return '/' + p + '/' + f;
  }, { unsafe: true });
}


/***/ }),

/***/ 3244:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_171276__) {

"use strict";

var collection = __nested_webpack_require_171276__(9789);
var collectionStrong = __nested_webpack_require_171276__(8081);

// `Set` constructor
// https://tc39.es/ecma262/#sec-set-objects
module.exports = collection('Set', function (init) {
  return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong);


/***/ }),

/***/ 1549:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_171735__) {

"use strict";

var $ = __nested_webpack_require_171735__(3103);
var createHTML = __nested_webpack_require_171735__(1720);
var forcedStringHTMLMethod = __nested_webpack_require_171735__(3689);

// `String.prototype.anchor` method
// https://tc39.es/ecma262/#sec-string.prototype.anchor
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('anchor') }, {
  anchor: function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  }
});


/***/ }),

/***/ 1235:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_172265__) {

"use strict";

var $ = __nested_webpack_require_172265__(3103);
var notARegExp = __nested_webpack_require_172265__(7272);
var requireObjectCoercible = __nested_webpack_require_172265__(8885);
var correctIsRegExpLogic = __nested_webpack_require_172265__(8127);

// `String.prototype.includes` method
// https://tc39.es/ecma262/#sec-string.prototype.includes
$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~String(requireObjectCoercible(this))
      .indexOf(notARegExp(searchString), arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ 8673:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_172981__) {

"use strict";

var charAt = __nested_webpack_require_172981__(966).charAt;
var InternalStateModule = __nested_webpack_require_172981__(6407);
var defineIterator = __nested_webpack_require_172981__(7675);

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return { value: undefined, done: true };
  point = charAt(string, index);
  state.index += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ 4069:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_174093__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __nested_webpack_require_174093__(4954);
var anObject = __nested_webpack_require_174093__(1176);
var toLength = __nested_webpack_require_174093__(4237);
var requireObjectCoercible = __nested_webpack_require_174093__(8885);
var advanceStringIndex = __nested_webpack_require_174093__(6637);
var regExpExec = __nested_webpack_require_174093__(8115);

// @@match logic
fixRegExpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.es/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = requireObjectCoercible(this);
      var matcher = regexp == undefined ? undefined : regexp[MATCH];
      return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative(nativeMatch, regexp, this);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);

      if (!rx.global) return regExpExec(rx, S);

      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});


/***/ }),

/***/ 5940:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_175735__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __nested_webpack_require_175735__(4954);
var anObject = __nested_webpack_require_175735__(1176);
var toLength = __nested_webpack_require_175735__(4237);
var toInteger = __nested_webpack_require_175735__(6051);
var requireObjectCoercible = __nested_webpack_require_175735__(8885);
var advanceStringIndex = __nested_webpack_require_175735__(6637);
var getSubstitution = __nested_webpack_require_175735__(17);
var regExpExec = __nested_webpack_require_175735__(8115);

var max = Math.max;
var min = Math.min;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
fixRegExpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
  var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

  return [
    // `String.prototype.replace` method
    // https://tc39.es/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = requireObjectCoercible(this);
      var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
      return replacer !== undefined
        ? replacer.call(searchValue, O, replaceValue)
        : nativeReplace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      if (
        (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0) ||
        (typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1)
      ) {
        var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
        if (res.done) return res.value;
      }

      var rx = anObject(regexp);
      var S = String(this);

      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);

      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;

        results.push(result);
        if (!global) break;

        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }

      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];

        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];
});


/***/ }),

/***/ 8319:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_179769__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __nested_webpack_require_179769__(4954);
var isRegExp = __nested_webpack_require_179769__(8311);
var anObject = __nested_webpack_require_179769__(1176);
var requireObjectCoercible = __nested_webpack_require_179769__(8885);
var speciesConstructor = __nested_webpack_require_179769__(7942);
var advanceStringIndex = __nested_webpack_require_179769__(6637);
var toLength = __nested_webpack_require_179769__(4237);
var callRegExpExec = __nested_webpack_require_179769__(8115);
var regexpExec = __nested_webpack_require_179769__(3466);
var stickyHelpers = __nested_webpack_require_179769__(5650);

var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;
var arrayPush = [].push;
var min = Math.min;
var MAX_UINT32 = 0xFFFFFFFF;

// @@split logic
fixRegExpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'.split(/(b)*/)[1] == 'c' ||
    // eslint-disable-next-line regexp/no-empty-group -- required for testing
    'test'.split(/(?:)/, -1).length != 4 ||
    'ab'.split(/(?:ab)*/).length != 2 ||
    '.'.split(/(.?)(.?)/).length != 4 ||
    // eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group -- required for testing
    '.'.split(/()()/).length > 1 ||
    ''.split(/.?/).length
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(requireObjectCoercible(this));
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (separator === undefined) return [string];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) {
        return nativeSplit.call(string, separator, lim);
      }
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy.lastIndex;
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
          lastLength = match[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim) break;
        }
        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
      }
      if (lastLastIndex === string.length) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output.length > lim ? output.slice(0, lim) : output;
    };
  // Chakra, V8
  } else if ('0'.split(undefined, 0).length) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
    };
  } else internalSplit = nativeSplit;

  return [
    // `String.prototype.split` method
    // https://tc39.es/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = requireObjectCoercible(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (UNSUPPORTED_Y ? 'g' : 'y');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(UNSUPPORTED_Y ? '^(?:' + rx.source + ')' : rx, flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = UNSUPPORTED_Y ? 0 : q;
        var z = callRegExpExec(splitter, UNSUPPORTED_Y ? S.slice(q) : S);
        var e;
        if (
          z === null ||
          (e = min(toLength(splitter.lastIndex + (UNSUPPORTED_Y ? q : 0)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
}, UNSUPPORTED_Y);


/***/ }),

/***/ 634:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_185297__) {

"use strict";
// `Symbol.prototype.description` getter
// https://tc39.es/ecma262/#sec-symbol.prototype.description

var $ = __nested_webpack_require_185297__(3103);
var DESCRIPTORS = __nested_webpack_require_185297__(7400);
var global = __nested_webpack_require_185297__(9859);
var has = __nested_webpack_require_185297__(816);
var isObject = __nested_webpack_require_185297__(5052);
var defineProperty = __nested_webpack_require_185297__(1787).f;
var copyConstructorProperties = __nested_webpack_require_185297__(7081);

var NativeSymbol = global.Symbol;

if (DESCRIPTORS && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
  // Safari 12 bug
  NativeSymbol().description !== undefined
)) {
  var EmptyStringDescriptionStore = {};
  // wrap Symbol constructor for correct work with undefined description
  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
    var result = this instanceof SymbolWrapper
      ? new NativeSymbol(description)
      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
      : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };
  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
  symbolPrototype.constructor = SymbolWrapper;

  var symbolToString = symbolPrototype.toString;
  var native = String(NativeSymbol('test')) == 'Symbol(test)';
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  defineProperty(symbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = isObject(this) ? this.valueOf() : this;
      var string = symbolToString.call(symbol);
      if (has(EmptyStringDescriptionStore, symbol)) return '';
      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  $({ global: true, forced: true }, {
    Symbol: SymbolWrapper
  });
}


/***/ }),

/***/ 796:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_187457__) {

var defineWellKnownSymbol = __nested_webpack_require_187457__(8423);

// `Symbol.iterator` well-known symbol
// https://tc39.es/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');


/***/ }),

/***/ 4115:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_187751__) {

"use strict";

var $ = __nested_webpack_require_187751__(3103);
var global = __nested_webpack_require_187751__(9859);
var getBuiltIn = __nested_webpack_require_187751__(1333);
var IS_PURE = __nested_webpack_require_187751__(4231);
var DESCRIPTORS = __nested_webpack_require_187751__(7400);
var NATIVE_SYMBOL = __nested_webpack_require_187751__(3839);
var USE_SYMBOL_AS_UID = __nested_webpack_require_187751__(6969);
var fails = __nested_webpack_require_187751__(4229);
var has = __nested_webpack_require_187751__(816);
var isArray = __nested_webpack_require_187751__(3718);
var isObject = __nested_webpack_require_187751__(5052);
var anObject = __nested_webpack_require_187751__(1176);
var toObject = __nested_webpack_require_187751__(2991);
var toIndexedObject = __nested_webpack_require_187751__(905);
var toPrimitive = __nested_webpack_require_187751__(2066);
var createPropertyDescriptor = __nested_webpack_require_187751__(5358);
var nativeObjectCreate = __nested_webpack_require_187751__(2391);
var objectKeys = __nested_webpack_require_187751__(5632);
var getOwnPropertyNamesModule = __nested_webpack_require_187751__(8151);
var getOwnPropertyNamesExternal = __nested_webpack_require_187751__(166);
var getOwnPropertySymbolsModule = __nested_webpack_require_187751__(894);
var getOwnPropertyDescriptorModule = __nested_webpack_require_187751__(7933);
var definePropertyModule = __nested_webpack_require_187751__(1787);
var propertyIsEnumerableModule = __nested_webpack_require_187751__(9195);
var createNonEnumerableProperty = __nested_webpack_require_187751__(5762);
var redefine = __nested_webpack_require_187751__(7487);
var shared = __nested_webpack_require_187751__(3036);
var sharedKey = __nested_webpack_require_187751__(4399);
var hiddenKeys = __nested_webpack_require_187751__(5977);
var uid = __nested_webpack_require_187751__(1441);
var wellKnownSymbol = __nested_webpack_require_187751__(95);
var wrappedWellKnownSymbolModule = __nested_webpack_require_187751__(5391);
var defineWellKnownSymbol = __nested_webpack_require_187751__(8423);
var setToStringTag = __nested_webpack_require_187751__(4555);
var InternalStateModule = __nested_webpack_require_187751__(6407);
var $forEach = __nested_webpack_require_187751__(9996).forEach;

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);
var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = global.Symbol;
var $stringify = getBuiltIn('JSON', 'stringify');
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');
var WellKnownSymbolsStore = shared('wks');
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var isSymbol = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return Object(it) instanceof $Symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPrimitive(P, true);
  anObject(Attributes);
  if (has(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(O, key, Attributes);
  } return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPrimitive(V, true);
  var enumerable = nativePropertyIsEnumerable.call(this, P);
  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPrimitive(P, true);
  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
  });
  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
      result.push(AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.es/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };

  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return getInternalState(this).tag;
  });

  redefine($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty($Symbol[PROTOTYPE], 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }
}

$({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  // `Symbol.for` method
  // https://tc39.es/ecma262/#sec-symbol.for
  'for': function (key) {
    var string = String(key);
    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = $Symbol(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  },
  // `Symbol.keyFor` method
  // https://tc39.es/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  },
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.es/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
$({ target: 'Object', stat: true, forced: fails(function () { getOwnPropertySymbolsModule.f(1); }) }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return getOwnPropertySymbolsModule.f(toObject(it));
  }
});

// `JSON.stringify` method behavior with symbols
// https://tc39.es/ecma262/#sec-json.stringify
if ($stringify) {
  var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function () {
    var symbol = $Symbol();
    // MS Edge converts symbol values to JSON as {}
    return $stringify([symbol]) != '[null]'
      // WebKit converts symbol values to JSON as null
      || $stringify({ a: symbol }) != '{}'
      // V8 throws on boxed symbols
      || $stringify(Object(symbol)) != '{}';
  });

  $({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, {
    // eslint-disable-next-line no-unused-vars -- required for `.length`
    stringify: function stringify(it, replacer, space) {
      var args = [it];
      var index = 1;
      var $replacer;
      while (arguments.length > index) args.push(arguments[index++]);
      $replacer = replacer;
      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
      if (!isArray(replacer)) replacer = function (key, value) {
        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return $stringify.apply(null, args);
    }
  });
}

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
  createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
}
// `Symbol.prototype[@@toStringTag]` property
// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;


/***/ }),

/***/ 5825:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_200399__) {

"use strict";

var ArrayBufferViewCore = __nested_webpack_require_200399__(9918);
var $copyWithin = __nested_webpack_require_200399__(7154);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.copyWithin` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.copywithin
exportTypedArrayMethod('copyWithin', function copyWithin(target, start /* , end */) {
  return $copyWithin.call(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
});


/***/ }),

/***/ 7170:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_201066__) {

"use strict";

var ArrayBufferViewCore = __nested_webpack_require_201066__(9918);
var $every = __nested_webpack_require_201066__(9996).every;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.every` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.every
exportTypedArrayMethod('every', function every(callbackfn /* , thisArg */) {
  return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 8857:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_201702__) {

"use strict";

var ArrayBufferViewCore = __nested_webpack_require_201702__(9918);
var $fill = __nested_webpack_require_201702__(7065);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.fill` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.fill
// eslint-disable-next-line no-unused-vars -- required for `.length`
exportTypedArrayMethod('fill', function fill(value /* , start, end */) {
  return $fill.apply(aTypedArray(this), arguments);
});


/***/ }),

/***/ 8329:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_202349__) {

"use strict";

var ArrayBufferViewCore = __nested_webpack_require_202349__(9918);
var $filter = __nested_webpack_require_202349__(9996).filter;
var fromSpeciesAndList = __nested_webpack_require_202349__(8874);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.filter` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.filter
exportTypedArrayMethod('filter', function filter(callbackfn /* , thisArg */) {
  var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  return fromSpeciesAndList(this, list);
});


/***/ }),

/***/ 427:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_203088__) {

"use strict";

var ArrayBufferViewCore = __nested_webpack_require_203088__(9918);
var $findIndex = __nested_webpack_require_203088__(9996).findIndex;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.findIndex` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.findindex
exportTypedArrayMethod('findIndex', function findIndex(predicate /* , thisArg */) {
  return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 6279:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_203750__) {

"use strict";

var ArrayBufferViewCore = __nested_webpack_require_203750__(9918);
var $find = __nested_webpack_require_203750__(9996).find;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.find` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.find
exportTypedArrayMethod('find', function find(predicate /* , thisArg */) {
  return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 1159:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_204377__) {

"use strict";

var ArrayBufferViewCore = __nested_webpack_require_204377__(9918);
var $forEach = __nested_webpack_require_204377__(9996).forEach;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.forEach` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.foreach
exportTypedArrayMethod('forEach', function forEach(callbackfn /* , thisArg */) {
  $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 2516:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_205020__) {

"use strict";

var ArrayBufferViewCore = __nested_webpack_require_205020__(9918);
var $includes = __nested_webpack_require_205020__(9540).includes;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.includes` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.includes
exportTypedArrayMethod('includes', function includes(searchElement /* , fromIndex */) {
  return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 4349:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_205685__) {

"use strict";

var ArrayBufferViewCore = __nested_webpack_require_205685__(9918);
var $indexOf = __nested_webpack_require_205685__(9540).indexOf;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.indexOf` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.indexof
exportTypedArrayMethod('indexOf', function indexOf(searchElement /* , fromIndex */) {
  return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 5273:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_206343__) {

"use strict";

var global = __nested_webpack_require_206343__(9859);
var ArrayBufferViewCore = __nested_webpack_require_206343__(9918);
var ArrayIterators = __nested_webpack_require_206343__(5735);
var wellKnownSymbol = __nested_webpack_require_206343__(95);

var ITERATOR = wellKnownSymbol('iterator');
var Uint8Array = global.Uint8Array;
var arrayValues = ArrayIterators.values;
var arrayKeys = ArrayIterators.keys;
var arrayEntries = ArrayIterators.entries;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var nativeTypedArrayIterator = Uint8Array && Uint8Array.prototype[ITERATOR];

var CORRECT_ITER_NAME = !!nativeTypedArrayIterator
  && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);

var typedArrayValues = function values() {
  return arrayValues.call(aTypedArray(this));
};

// `%TypedArray%.prototype.entries` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.entries
exportTypedArrayMethod('entries', function entries() {
  return arrayEntries.call(aTypedArray(this));
});
// `%TypedArray%.prototype.keys` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.keys
exportTypedArrayMethod('keys', function keys() {
  return arrayKeys.call(aTypedArray(this));
});
// `%TypedArray%.prototype.values` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.values
exportTypedArrayMethod('values', typedArrayValues, !CORRECT_ITER_NAME);
// `%TypedArray%.prototype[@@iterator]` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype-@@iterator
exportTypedArrayMethod(ITERATOR, typedArrayValues, !CORRECT_ITER_NAME);


/***/ }),

/***/ 6729:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_208077__) {

"use strict";

var ArrayBufferViewCore = __nested_webpack_require_208077__(9918);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $join = [].join;

// `%TypedArray%.prototype.join` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.join
// eslint-disable-next-line no-unused-vars -- required for `.length`
exportTypedArrayMethod('join', function join(separator) {
  return $join.apply(aTypedArray(this), arguments);
});


/***/ }),

/***/ 1801:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_208691__) {

"use strict";

var ArrayBufferViewCore = __nested_webpack_require_208691__(9918);
var $lastIndexOf = __nested_webpack_require_208691__(6462);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.lastIndexOf` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.lastindexof
// eslint-disable-next-line no-unused-vars -- required for `.length`
exportTypedArrayMethod('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
  return $lastIndexOf.apply(aTypedArray(this), arguments);
});


/***/ }),

/***/ 574:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_209386__) {

"use strict";

var ArrayBufferViewCore = __nested_webpack_require_209386__(9918);
var $map = __nested_webpack_require_209386__(9996).map;
var speciesConstructor = __nested_webpack_require_209386__(7942);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.map` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.map
exportTypedArrayMethod('map', function map(mapfn /* , thisArg */) {
  return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
    return new (aTypedArrayConstructor(speciesConstructor(O, O.constructor)))(length);
  });
});


/***/ }),

/***/ 9271:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_210238__) {

"use strict";

var ArrayBufferViewCore = __nested_webpack_require_210238__(9918);
var $reduceRight = __nested_webpack_require_210238__(3143).right;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.reduceRicht` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduceright
exportTypedArrayMethod('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
  return $reduceRight(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 5787:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_210933__) {

"use strict";

var ArrayBufferViewCore = __nested_webpack_require_210933__(9918);
var $reduce = __nested_webpack_require_210933__(3143).left;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.reduce` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reduce
exportTypedArrayMethod('reduce', function reduce(callbackfn /* , initialValue */) {
  return $reduce(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 3160:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_211597__) {

"use strict";

var ArrayBufferViewCore = __nested_webpack_require_211597__(9918);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var floor = Math.floor;

// `%TypedArray%.prototype.reverse` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.reverse
exportTypedArrayMethod('reverse', function reverse() {
  var that = this;
  var length = aTypedArray(that).length;
  var middle = floor(length / 2);
  var index = 0;
  var value;
  while (index < middle) {
    value = that[index];
    that[index++] = that[--length];
    that[length] = value;
  } return that;
});


/***/ }),

/***/ 5688:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_212351__) {

"use strict";

var ArrayBufferViewCore = __nested_webpack_require_212351__(9918);
var toLength = __nested_webpack_require_212351__(4237);
var toOffset = __nested_webpack_require_212351__(4262);
var toObject = __nested_webpack_require_212351__(2991);
var fails = __nested_webpack_require_212351__(4229);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

var FORCED = fails(function () {
  // eslint-disable-next-line es/no-typed-arrays -- required for testing
  new Int8Array(1).set({});
});

// `%TypedArray%.prototype.set` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.set
exportTypedArrayMethod('set', function set(arrayLike /* , offset */) {
  aTypedArray(this);
  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
  var length = this.length;
  var src = toObject(arrayLike);
  var len = toLength(src.length);
  var index = 0;
  if (len + offset > length) throw RangeError('Wrong length');
  while (index < len) this[offset + index] = src[index++];
}, FORCED);


/***/ }),

/***/ 3157:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_213478__) {

"use strict";

var ArrayBufferViewCore = __nested_webpack_require_213478__(9918);
var speciesConstructor = __nested_webpack_require_213478__(7942);
var fails = __nested_webpack_require_213478__(4229);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $slice = [].slice;

var FORCED = fails(function () {
  // eslint-disable-next-line es/no-typed-arrays -- required for testing
  new Int8Array(1).slice();
});

// `%TypedArray%.prototype.slice` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.slice
exportTypedArrayMethod('slice', function slice(start, end) {
  var list = $slice.call(aTypedArray(this), start, end);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
}, FORCED);


/***/ }),

/***/ 3333:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_214574__) {

"use strict";

var ArrayBufferViewCore = __nested_webpack_require_214574__(9918);
var $some = __nested_webpack_require_214574__(9996).some;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.some` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.some
exportTypedArrayMethod('some', function some(callbackfn /* , thisArg */) {
  return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ 315:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_215202__) {

"use strict";

var ArrayBufferViewCore = __nested_webpack_require_215202__(9918);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $sort = [].sort;

// `%TypedArray%.prototype.sort` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.sort
exportTypedArrayMethod('sort', function sort(comparefn) {
  return $sort.call(aTypedArray(this), comparefn);
});


/***/ }),

/***/ 8314:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_215746__) {

"use strict";

var ArrayBufferViewCore = __nested_webpack_require_215746__(9918);
var toLength = __nested_webpack_require_215746__(4237);
var toAbsoluteIndex = __nested_webpack_require_215746__(3231);
var speciesConstructor = __nested_webpack_require_215746__(7942);

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.subarray` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.subarray
exportTypedArrayMethod('subarray', function subarray(begin, end) {
  var O = aTypedArray(this);
  var length = O.length;
  var beginIndex = toAbsoluteIndex(begin, length);
  return new (speciesConstructor(O, O.constructor))(
    O.buffer,
    O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
    toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex)
  );
});


/***/ }),

/***/ 556:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_216694__) {

"use strict";

var global = __nested_webpack_require_216694__(9859);
var ArrayBufferViewCore = __nested_webpack_require_216694__(9918);
var fails = __nested_webpack_require_216694__(4229);

var Int8Array = global.Int8Array;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $toLocaleString = [].toLocaleString;
var $slice = [].slice;

// iOS Safari 6.x fails here
var TO_LOCALE_STRING_BUG = !!Int8Array && fails(function () {
  $toLocaleString.call(new Int8Array(1));
});

var FORCED = fails(function () {
  return [1, 2].toLocaleString() != new Int8Array([1, 2]).toLocaleString();
}) || !fails(function () {
  Int8Array.prototype.toLocaleString.call([1, 2]);
});

// `%TypedArray%.prototype.toLocaleString` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tolocalestring
exportTypedArrayMethod('toLocaleString', function toLocaleString() {
  return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice.call(aTypedArray(this)) : aTypedArray(this), arguments);
}, FORCED);


/***/ }),

/***/ 9224:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_217830__) {

"use strict";

var exportTypedArrayMethod = __nested_webpack_require_217830__(9918).exportTypedArrayMethod;
var fails = __nested_webpack_require_217830__(4229);
var global = __nested_webpack_require_217830__(9859);

var Uint8Array = global.Uint8Array;
var Uint8ArrayPrototype = Uint8Array && Uint8Array.prototype || {};
var arrayToString = [].toString;
var arrayJoin = [].join;

if (fails(function () { arrayToString.call({}); })) {
  arrayToString = function toString() {
    return arrayJoin.call(this);
  };
}

var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;

// `%TypedArray%.prototype.toString` method
// https://tc39.es/ecma262/#sec-%typedarray%.prototype.tostring
exportTypedArrayMethod('toString', arrayToString, IS_NOT_ARRAY_METHOD);


/***/ }),

/***/ 3675:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_218672__) {

var createTypedArrayConstructor = __nested_webpack_require_218672__(2574);

// `Uint8Array` constructor
// https://tc39.es/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint8', function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ 1939:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_219099__) {

var global = __nested_webpack_require_219099__(9859);
var DOMIterables = __nested_webpack_require_219099__(5694);
var forEach = __nested_webpack_require_219099__(6570);
var createNonEnumerableProperty = __nested_webpack_require_219099__(5762);

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  // some Chrome versions have non-configurable methods on DOMTokenList
  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
  } catch (error) {
    CollectionPrototype.forEach = forEach;
  }
}


/***/ }),

/***/ 6886:
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_219847__) {

var global = __nested_webpack_require_219847__(9859);
var DOMIterables = __nested_webpack_require_219847__(5694);
var ArrayIteratorMethods = __nested_webpack_require_219847__(5735);
var createNonEnumerableProperty = __nested_webpack_require_219847__(5762);
var wellKnownSymbol = __nested_webpack_require_219847__(95);

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_221589__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_221589__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__nested_webpack_require_221589__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__nested_webpack_require_221589__.o(definition, key) && !__nested_webpack_require_221589__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__nested_webpack_require_221589__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__nested_webpack_require_221589__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__nested_webpack_require_221589__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __nested_webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
// extracted by mini-css-extract-plugin

}();
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";

// EXPORTS
__nested_webpack_require_221589__.d(__nested_webpack_exports__, {
  "default": function() { return /* binding */ src_Chart; }
});

// UNUSED EXPORTS: AreaChart, BarChart, BoxPlotChart, BubbleChart, BulletChart, ColumnChart, ColumnLineChart, GaugeChart, HeatmapChart, LineAreaChart, LineChart, LineScatterChart, NestedPieChart, PieChart, RadarChart, RadialBarChart, ScatterChart, TreemapChart

// NAMESPACE OBJECT: ./src/brushes/label.ts
var label_namespaceObject = {};
__nested_webpack_require_221589__.r(label_namespaceObject);
__nested_webpack_require_221589__.d(label_namespaceObject, {
  "DEFAULT_LABEL_TEXT": function() { return DEFAULT_LABEL_TEXT; },
  "bubbleLabel": function() { return bubbleLabel; },
  "label": function() { return label; },
  "labelStyle": function() { return labelStyle; },
  "strokeLabelStyle": function() { return strokeLabelStyle; }
});

// NAMESPACE OBJECT: ./src/brushes/basic.ts
var basic_namespaceObject = {};
__nested_webpack_require_221589__.r(basic_namespaceObject);
__nested_webpack_require_221589__.d(basic_namespaceObject, {
  "arc": function() { return arc; },
  "circle": function() { return circle; },
  "clipRectArea": function() { return clipRectArea; },
  "line": function() { return line; },
  "pathRect": function() { return pathRect; },
  "rect": function() { return rect; }
});

// NAMESPACE OBJECT: ./src/brushes/axis.ts
var axis_namespaceObject = {};
__nested_webpack_require_221589__.r(axis_namespaceObject);
__nested_webpack_require_221589__.d(axis_namespaceObject, {
  "TICK_SIZE": function() { return TICK_SIZE; },
  "tick": function() { return tick; }
});

// NAMESPACE OBJECT: ./src/brushes/dataLabel.ts
var dataLabel_namespaceObject = {};
__nested_webpack_require_221589__.r(dataLabel_namespaceObject);
__nested_webpack_require_221589__.d(dataLabel_namespaceObject, {
  "dataLabel": function() { return dataLabel; },
  "drawBubbleLabel": function() { return drawBubbleLabel; },
  "getBubbleArrowPoints": function() { return getBubbleArrowPoints; }
});

// NAMESPACE OBJECT: ./src/brushes/spectrumLegend.ts
var spectrumLegend_namespaceObject = {};
__nested_webpack_require_221589__.r(spectrumLegend_namespaceObject);
__nested_webpack_require_221589__.d(spectrumLegend_namespaceObject, {
  "SPECTRUM_LEGEND_LABEL_HEIGHT": function() { return SPECTRUM_LEGEND_LABEL_HEIGHT; },
  "spectrumLegend": function() { return spectrumLegend; },
  "spectrumLegendBar": function() { return spectrumLegendBar; },
  "spectrumLegendTooltip": function() { return spectrumLegendTooltip; },
  "spectrumTooltip": function() { return spectrumTooltip; }
});

// NAMESPACE OBJECT: ./src/brushes/polygon.ts
var polygon_namespaceObject = {};
__nested_webpack_require_221589__.r(polygon_namespaceObject);
__nested_webpack_require_221589__.d(polygon_namespaceObject, {
  "polygon": function() { return polygon; }
});

// NAMESPACE OBJECT: ./src/brushes/scatterSeries.ts
var scatterSeries_namespaceObject = {};
__nested_webpack_require_221589__.r(scatterSeries_namespaceObject);
__nested_webpack_require_221589__.d(scatterSeries_namespaceObject, {
  "scatterSeries": function() { return scatterSeries; }
});

// NAMESPACE OBJECT: ./src/brushes/legend.ts
var legend_namespaceObject = {};
__nested_webpack_require_221589__.r(legend_namespaceObject);
__nested_webpack_require_221589__.d(legend_namespaceObject, {
  "LEGEND_CHECKBOX_SIZE": function() { return LEGEND_CHECKBOX_SIZE; },
  "LEGEND_ICON_SIZE": function() { return LEGEND_ICON_SIZE; },
  "LEGEND_ITEM_MARGIN_X": function() { return LEGEND_ITEM_MARGIN_X; },
  "LEGEND_MARGIN_X": function() { return LEGEND_MARGIN_X; },
  "getLegendItemHeight": function() { return getLegendItemHeight; },
  "legend": function() { return legend; }
});

// NAMESPACE OBJECT: ./src/brushes/lineSeries.ts
var brushes_lineSeries_namespaceObject = {};
__nested_webpack_require_221589__.r(brushes_lineSeries_namespaceObject);
__nested_webpack_require_221589__.d(brushes_lineSeries_namespaceObject, {
  "areaPoints": function() { return areaPoints; },
  "linePoints": function() { return linePoints; }
});

// NAMESPACE OBJECT: ./src/brushes/exportMenu.ts
var brushes_exportMenu_namespaceObject = {};
__nested_webpack_require_221589__.r(brushes_exportMenu_namespaceObject);
__nested_webpack_require_221589__.d(brushes_exportMenu_namespaceObject, {
  "exportMenuButton": function() { return exportMenuButton; }
});

// NAMESPACE OBJECT: ./src/brushes/resetButton.ts
var brushes_resetButton_namespaceObject = {};
__nested_webpack_require_221589__.r(brushes_resetButton_namespaceObject);
__nested_webpack_require_221589__.d(brushes_resetButton_namespaceObject, {
  "backButton": function() { return backButton; },
  "resetButton": function() { return resetButton; }
});

// NAMESPACE OBJECT: ./src/brushes/sector.ts
var brushes_sector_namespaceObject = {};
__nested_webpack_require_221589__.r(brushes_sector_namespaceObject);
__nested_webpack_require_221589__.d(brushes_sector_namespaceObject, {
  "sector": function() { return sector; }
});

// NAMESPACE OBJECT: ./src/brushes/circleLegend.ts
var brushes_circleLegend_namespaceObject = {};
__nested_webpack_require_221589__.r(brushes_circleLegend_namespaceObject);
__nested_webpack_require_221589__.d(brushes_circleLegend_namespaceObject, {
  "circleLegend": function() { return circleLegend; }
});

// NAMESPACE OBJECT: ./src/brushes/boxPlot.ts
var boxPlot_namespaceObject = {};
__nested_webpack_require_221589__.r(boxPlot_namespaceObject);
__nested_webpack_require_221589__.d(boxPlot_namespaceObject, {
  "boxPlot": function() { return boxPlot; }
});

// NAMESPACE OBJECT: ./src/brushes/gauge.ts
var gauge_namespaceObject = {};
__nested_webpack_require_221589__.r(gauge_namespaceObject);
__nested_webpack_require_221589__.d(gauge_namespaceObject, {
  "clockHand": function() { return clockHand; }
});

// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.object.set-prototype-of.js
var es_object_set_prototype_of = __nested_webpack_require_221589__(2506);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.object.get-prototype-of.js
var es_object_get_prototype_of = __nested_webpack_require_221589__(6928);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.reflect.construct.js
var es_reflect_construct = __nested_webpack_require_221589__(1229);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.reflect.get.js
var es_reflect_get = __nested_webpack_require_221589__(4565);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.object.get-own-property-descriptor.js
var es_object_get_own_property_descriptor = __nested_webpack_require_221589__(8625);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.object.keys.js
var es_object_keys = __nested_webpack_require_221589__(4769);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.symbol.js
var es_symbol = __nested_webpack_require_221589__(4115);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.filter.js
var es_array_filter = __nested_webpack_require_221589__(5342);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/web.dom-collections.for-each.js
var web_dom_collections_for_each = __nested_webpack_require_221589__(1939);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.object.get-own-property-descriptors.js
var es_object_get_own_property_descriptors = __nested_webpack_require_221589__(2775);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.symbol.description.js
var es_symbol_description = __nested_webpack_require_221589__(634);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.object.to-string.js
var es_object_to_string = __nested_webpack_require_221589__(8188);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.symbol.iterator.js
var es_symbol_iterator = __nested_webpack_require_221589__(796);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.iterator.js
var es_array_iterator = __nested_webpack_require_221589__(5735);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.string.iterator.js
var es_string_iterator = __nested_webpack_require_221589__(8673);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/web.dom-collections.iterator.js
var web_dom_collections_iterator = __nested_webpack_require_221589__(6886);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.map.js
var es_array_map = __nested_webpack_require_221589__(3450);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.concat.js
var es_array_concat = __nested_webpack_require_221589__(8178);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.from.js
var es_array_from = __nested_webpack_require_221589__(7233);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.slice.js
var es_array_slice = __nested_webpack_require_221589__(2501);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.function.name.js
var es_function_name = __nested_webpack_require_221589__(6936);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.regexp.exec.js
var es_regexp_exec = __nested_webpack_require_221589__(7950);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.string.split.js
var es_string_split = __nested_webpack_require_221589__(8319);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.splice.js
var es_array_splice = __nested_webpack_require_221589__(9805);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.includes.js
var es_array_includes = __nested_webpack_require_221589__(9529);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.find-index.js
var es_array_find_index = __nested_webpack_require_221589__(9949);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.number.constructor.js
var es_number_constructor = __nested_webpack_require_221589__(1245);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.find.js
var es_array_find = __nested_webpack_require_221589__(9228);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.number.to-fixed.js
var es_number_to_fixed = __nested_webpack_require_221589__(1321);
;// CONCATENATED MODULE: ./src/helpers/utils.ts
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }





















function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function isExist(value) {
  return !isUndefined(value) && !isNull(value);
}
function isDate(value) {
  return value instanceof Date;
}
function isUndefined(value) {
  return typeof value === 'undefined';
}
function isNull(value) {
  return value === null;
}
function isBoolean(value) {
  return typeof value === 'boolean';
}
function isNumber(value) {
  return typeof value === 'number';
}
function utils_isString(value) {
  return typeof value === 'string';
}
function isInteger(value) {
  return isNumber(value) && isFinite(value) && Math.floor(value) === value;
}
function isObject(obj) {
  return _typeof(obj) === 'object' && obj !== null;
}
function isFunction(value) {
  return typeof value === 'function';
}
function forEach(obj, cb) {
  for (var _key in obj) {
    if (obj.hasOwnProperty(_key)) {
      cb(obj[_key], _key);
    }
  }
}
function forEachArray(arr, iteratee) {
  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

  for (var _index = 0, len = arr.length; _index < len; _index += 1) {
    if (iteratee.call(context, arr[_index], _index, arr) === false) {
      break;
    }
  }
}
function range(start, stop, step) {
  if (isUndefined(stop)) {
    stop = start || 0;
    start = 0;
  }

  step = step || 1;
  var arr = [];

  if (stop) {
    var flag = step < 0 ? -1 : 1;
    stop *= flag;

    for (; start * flag < stop; start += step) {
      arr.push(start);
    }
  }

  return arr;
}
function toArray(arrayLike) {
  var arr = [];

  try {
    arr = Array.prototype.slice.call(arrayLike);
  } catch (e) {
    forEachArray(arrayLike, function (value) {
      arr.push(value);
    });
  }

  return arr;
}
function includes(arr, searchItem, searchIndex) {
  if (typeof searchIndex === 'number' && arr[searchIndex] !== searchItem) {
    return false;
  }

  var _iterator = _createForOfIteratorHelper(arr),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _item = _step.value;

      if (_item === searchItem) {
        return true;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return false;
}
function pick(obj) {
  for (var _len = arguments.length, propNames = new Array(_len > 1 ? _len - 1 : 0), _key2 = 1; _key2 < _len; _key2++) {
    propNames[_key2 - 1] = arguments[_key2];
  }

  var resultMap = {};
  Object.keys(obj).forEach(function (key) {
    if (includes(propNames, key)) {
      resultMap[key] = obj[key];
    }
  });
  return resultMap;
}
function omit(obj) {
  for (var _len2 = arguments.length, propNames = new Array(_len2 > 1 ? _len2 - 1 : 0), _key3 = 1; _key3 < _len2; _key3++) {
    propNames[_key3 - 1] = arguments[_key3];
  }

  var resultMap = {};
  Object.keys(obj).forEach(function (key) {
    if (!includes(propNames, key)) {
      resultMap[key] = obj[key];
    }
  });
  return resultMap;
}
function pickProperty(target, keys) {
  var length = keys.length;

  if (length) {
    for (var i = 0; i < length; i += 1) {
      if (isUndefined(target) || isNull(target)) {
        return null;
      }

      target = target[keys[i]];
    }
  }

  return target;
}
function pickPropertyWithMakeup(target, args) {
  var length = args.length;

  if (length) {
    for (var i = 0; i < length; i += 1) {
      if (isUndefined(target[args[i]])) {
        target[args[i]] = {};
      }

      target = target[args[i]];
    }
  }

  return target;
}
function debounce(fn) {
  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var timer;

  function debounced() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
      args[_key4] = arguments[_key4];
    }

    window.clearTimeout(timer);
    timer = window.setTimeout(function () {
      fn.apply(void 0, args);
    }, delay);
  }

  return debounced;
}
function merge(target) {
  target = target || {};

  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key5 = 1; _key5 < _len4; _key5++) {
    args[_key5 - 1] = arguments[_key5];
  }

  args.forEach(function (obj) {
    if (!obj) {
      return;
    }

    forEach(obj, function (item, key) {
      if (Object.prototype.toString.call(item) === '[object Object]') {
        target[key] = merge(target[key], item);
      } else {
        target[key] = item;
      }
    });
  });
  return target;
}
function throttle(fn) {
  var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var base = null;
  var isLeading = true;

  var tick = function tick() {
    fn.apply(void 0, arguments);
    base = null;
  };

  var stamp = 0;
  var debounced = debounce(tick, interval);

  function throttled() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key6 = 0; _key6 < _len5; _key6++) {
      args[_key6] = arguments[_key6];
    }

    if (isLeading) {
      tick.apply(void 0, args);
      isLeading = false;
      return;
    }

    stamp = Number(new Date());
    base = base || stamp;
    debounced(args);

    if (stamp - base >= interval) {
      tick(args);
    }
  }

  function reset() {
    // eslint-disable-line require-jsdoc
    isLeading = true;
    base = null;
  }

  throttled.reset = reset;
  return throttled;
}
function deepMergedCopy(targetObj, obj) {
  var resultObj = _objectSpread({}, targetObj);

  Object.keys(obj).forEach(function (prop) {
    if (isObject(resultObj[prop])) {
      if (Array.isArray(obj[prop])) {
        resultObj[prop] = deepCopyArray(obj[prop]);
      } else if (resultObj.hasOwnProperty(prop)) {
        resultObj[prop] = deepMergedCopy(resultObj[prop], obj[prop]);
      } else {
        resultObj[prop] = deepCopy(obj[prop]);
      }
    } else {
      resultObj[prop] = obj[prop];
    }
  });
  return resultObj;
}
function deepCopyArray(items) {
  return items.map(function (item) {
    if (isObject(item)) {
      return Array.isArray(item) ? deepCopyArray(item) : deepCopy(item);
    }

    return item;
  });
}
function deepCopy(obj) {
  var resultObj = {};
  var keys = Object.keys(obj);

  if (!keys.length) {
    return obj;
  }

  keys.forEach(function (prop) {
    if (isObject(obj[prop])) {
      resultObj[prop] = Array.isArray(obj[prop]) ? deepCopyArray(obj[prop]) : deepCopy(obj[prop]);
    } else {
      resultObj[prop] = obj[prop];
    }
  });
  return resultObj;
}
function sortCategories(x, y) {
  return isInteger(x) ? Number(x) - Number(y) : new Date(x).getTime() - new Date(y).getTime();
}
function sortNumber(x, y) {
  return x - y;
}
function first(items) {
  // eslint-disable-next-line no-undefined
  return items.length ? items[0] : undefined;
}
function last(items) {
  // eslint-disable-next-line no-undefined
  return items.length ? items[items.length - 1] : undefined;
}
function hasNegative() {
  var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return values.some(function (value) {
    return Number(value) < 0;
  });
}
function sum(items) {
  return items.reduce(function (a, b) {
    return a + b;
  }, 0);
}
function hasPositiveOnly(values) {
  return values.every(function (value) {
    return Number(value) >= 0;
  });
}
function hasNegativeOnly(values) {
  return values.every(function (value) {
    return Number(value) <= 0;
  });
}
function getFirstValidValue(values) {
  return values === null || values === void 0 ? void 0 : values.find(function (value) {
    return value !== null;
  });
}
function utils_getPercentageValue(text) {
  return Number(text.substr(0, text.length - 1));
}
function calculateSizeWithPercentString(size, value) {
  return isNumber(value) ? value : Number((size * utils_getPercentageValue(value) / 100).toFixed(2));
}
function getInitialSize(size) {
  return isNumber(size) ? size : 0;
}
function isAutoValue(value) {
  return value === 'auto';
}
;// CONCATENATED MODULE: ./src/message.ts
var message = {
  SELECT_SERIES_API_SELECTABLE_ERROR: 'It works only when the selectable option is true.',
  SELECT_SERIES_API_INDEX_ERROR: 'The index value is invalid.',
  ALREADY_OBSERVABLE_ERROR: 'Source object is observable already',
  CIRCLE_LEGEND_RENDER_ERROR: 'circleLegend is only possible when bubble series is present',
  noDataError: function noDataError(chartName) {
    return "There's no ".concat(chartName, " data!");
  },
  noBrushError: function noBrushError(brushName) {
    return "Brush don't exist in painter: ".concat(brushName);
  },
  DASH_SEGMENTS_UNAVAILABLE_ERROR: 'DashSegments option is available from IE11 and above.',
  SERIES_INDEX_ERROR: 'The seriesIndex value is invalid',
  AUTO_LAYOUT_CONTAINER_SIZE_ERROR: 'To use auto layout, the width or height of the container must be specified as a value such as "%" or "vh", "vw".'
};
;// CONCATENATED MODULE: ./src/store/reactive.ts
function reactive_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function reactive_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { reactive_typeof = function _typeof(obj) { return typeof obj; }; } else { reactive_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return reactive_typeof(obj); }

















var currentCollectorObserver = null;
var currentRunningObserver = null;
var observerCallCue = [];
var doingInvisibleWork = false;
function reactive_observe(fn) {
  var observer = function observer() {
    if (currentRunningObserver === observer) {
      return;
    } // If there is observer running or doing invisible work


    if (doingInvisibleWork || !isNull(currentRunningObserver)) {
      if (observerCallCue.includes(observer)) {
        observerCallCue.splice(observerCallCue.indexOf(observer), 1);
      } // We use observer call cue because avoid nested observer call.


      observerCallCue.push(observer); // or If there are no observers running. Run the observer and run the next observer in the call queue.
    } else if (isNull(currentRunningObserver)) {
      currentRunningObserver = observer;
      fn();
      currentRunningObserver = null;
      digestObserverCallCue();
    }
  };

  observer.deps = []; // first observer excution for collect dependencies

  currentCollectorObserver = observer;
  currentCollectorObserver();
  currentCollectorObserver = null;
  return function () {
    observer.deps.forEach(function (dep) {
      var index = dep.findIndex(function (ob) {
        return ob === observer;
      });
      dep.splice(index, 1);
    });
    observer.deps = [];
  };
}

function digestObserverCallCue() {
  if (observerCallCue.length) {
    var nextObserver = observerCallCue.shift();

    if (nextObserver) {
      nextObserver();
    }
  }
}

function isObservable(target) {
  return reactive_typeof(target) === 'object' && target.__toastUIChartOb__;
}
function reactive_observable(target) {
  var source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : target;

  if (isObservable(source)) {
    throw new Error(message.ALREADY_OBSERVABLE_ERROR);
  }

  if (!isObservable(target)) {
    Object.defineProperty(target, '__toastUIChartOb__', {
      enumerable: false
    });
  }

  var _loop = function _loop(key) {
    if (!source.hasOwnProperty(key)) {
      return "continue";
    }

    var obs = [];
    var value = source[key];
    var descriptor = Object.getOwnPropertyDescriptor(source, key);
    var preGetter = descriptor && descriptor.get;
    var preSetter = descriptor && descriptor.set;
    /* eslint-disable no-loop-func */

    Object.defineProperty(target, key, {
      configurable: true,
      enumerable: true,
      get: function get() {
        // It's some kind a trick to get observable information from closure using getter for notify()
        if (currentCollectorObserver === observableInfo) {
          return {
            target: target,
            key: key,
            value: value,
            obs: obs
          };
        }

        if (!doingInvisibleWork && currentCollectorObserver && !obs.includes(currentCollectorObserver)) {
          // if there is collector observer in running, collect current data as dependency
          obs.push(currentCollectorObserver);
          currentCollectorObserver.deps.push(obs);
        }

        return value;
      },
      set: function set(v) {
        var prevValue = value;

        if (preSetter) {
          preSetter.call(target, v);
          value = preGetter ? preGetter.call(target) : target[key];
        } else {
          value = v;
        }

        if (prevValue !== value) {
          // Run observers
          invokeObs(obs);
        }
      }
    });

    if (reactive_typeof(target[key]) === 'object' && !Array.isArray(target[key])) {
      reactive_observable(target[key]);
    }
    /* eslint-enable no-loop-func */

  };

  for (var key in source) {
    var _ret = _loop(key);

    if (_ret === "continue") continue;
  }

  return target;
}
function setValue(target, key, source) {
  return reactive_observable(target, reactive_defineProperty({}, key, source));
}
function extend(target, source) {
  if (isObservable(source)) {
    throw new Error(message.ALREADY_OBSERVABLE_ERROR);
  }

  return reactive_observable(target, source);
}
function reactive_notify(target, key) {
  var obInfo = observableInfo(target, key);

  if (obInfo) {
    invokeObs(obInfo.obs);
  }
}
function invisibleWork(fn) {
  doingInvisibleWork = true;
  fn();
  doingInvisibleWork = false;
  digestObserverCallCue();
}
function reactive_notifyByPath(holder, namePath) {
  var splited = namePath.split('.');
  var key = splited.splice(splited.length - 1, 1)[0];
  var target = pickProperty(holder, splited);

  if (target) {
    reactive_notify(target, key);
  }
}

function invokeObs(obs) {
  obs.forEach(function (ob) {
    return ob();
  });
}

function observableInfo(target, key) {
  currentCollectorObserver = observableInfo;
  var obInfo = target[key];
  currentCollectorObserver = null;

  if (reactive_typeof(obInfo) === 'object' && obInfo.hasOwnProperty('target') && obInfo.hasOwnProperty('obs')) {
    return obInfo;
  }

  return null;
}

function computed(target, key, fn) {
  var cachedValue;
  var computedBox = {};
  Object.defineProperty(computedBox, key, {
    configurable: true,
    enumerable: true,
    get: function get() {
      return cachedValue;
    }
  });
  extend(target, computedBox);
  reactive_observe(function () {
    var prevValue = cachedValue;
    cachedValue = fn();

    if (prevValue !== cachedValue) {
      target[key] = cachedValue;
    }
  });
}
function watch(holder, path, fn) {
  var splited = path.split('.');
  var key = splited.splice(splited.length - 1, 1)[0];
  var target = pickProperty(holder, splited);

  if (!target) {
    return null;
  }

  var obInfo = observableInfo(target, key);

  if (!obInfo) {
    return null;
  }

  var watcher = function watcher() {
    fn(target[key]);
  };

  obInfo.obs.push(watcher);
  return function () {
    var index = obInfo.obs.findIndex(function (ob) {
      return ob === watcher;
    });

    if (index > -1) {
      obInfo.obs.splice(index, 1);
    }
  };
}
function makeObservableObjectToNormal(obj) {
  return JSON.parse(JSON.stringify(obj));
}
;// CONCATENATED MODULE: ./src/store/store.ts
function store_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { store_typeof = function _typeof(obj) { return typeof obj; }; } else { store_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return store_typeof(obj); }














function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function store_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var Store = /*#__PURE__*/function () {
  function Store(initStoreState) {
    _classCallCheck(this, Store);

    store_defineProperty(this, "state", void 0);

    store_defineProperty(this, "initStoreState", void 0);

    store_defineProperty(this, "computed", {});

    store_defineProperty(this, "actions", {});

    this.initStoreState = deepCopy(initStoreState);
    this.setRootState({});
  }

  _createClass(Store, [{
    key: "setRootState",
    value: function setRootState(state) {
      reactive_observable(state);

      this.state = state;
    }
  }, {
    key: "setComputed",
    value: function setComputed(namePath, fn) {
      var holder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.computed;
      var splited = namePath.split('.');
      var key = splited.splice(splited.length - 1, 1)[0];
      var target = pickPropertyWithMakeup(holder, splited);
      computed(target, key, fn.bind(null, this.state, this.computed));
    }
  }, {
    key: "setWatch",
    value: function setWatch(namePath, fn) {
      return watch(this, namePath, fn);
    }
  }, {
    key: "setAction",
    value: function setAction(name, fn) {
      this.actions[name] = fn;
    }
  }, {
    key: "dispatch",
    value: function dispatch(name, payload, isInvisible) {
      var _this = this;

      // observe.setlayout  setLayout    state.layout getter 
      // state.layout  observe.setLayout .  
      //  observe    
      // extend(state.layout, layouts);   layout getter
      // layout   observe   
      if (isInvisible) {
        invisibleWork(function () {
          // console.log('dispatch', name, ...args);
          _this.actions[name].call(_this, _this, payload); // console.log('dispatch end', name);

        });
      } else {
        this.actions[name].call(this, this, payload);
      }
    }
  }, {
    key: "observe",
    value: function observe(fn) {
      return reactive_observe(fn.bind(this, this.state, this.computed));
    }
  }, {
    key: "observable",
    value: function observable(target) {
      return reactive_observable(target);
    }
  }, {
    key: "notifyByPath",
    value: function notifyByPath(namePath) {
      reactive_notifyByPath(this, namePath);
    }
  }, {
    key: "notify",
    value: function notify(target, key) {
      reactive_notify(target, key);
    }
  }, {
    key: "setModule",
    value: function setModule(name, param) {
      var _this2 = this;

      if (!param) {
        param = name;
        name = param.name;
      }

      if (param.state) {
        var moduleState = typeof param.state === 'function' ? param.state(this.initStoreState) : param.state;
        store_extend(this.state, moduleState);
      }

      if (param.computed) {
        forEach(param.computed, function (item, key) {
          _this2.setComputed(key, item);
        });
      }

      if (param.watch) {
        forEach(param.watch, function (item, key) {
          _this2.setWatch(key, item);
        });
      }

      if (param.action) {
        forEach(param.action, function (item, key) {
          _this2.setAction(key, item);
        });
      }

      if (param.observe) {
        forEach(param.observe, function (item) {
          _this2.observe(item);
        });
      }
    }
  }, {
    key: "setValue",
    value: function setValue(target, key, source) {
      store_extend(target, store_defineProperty({}, key, source));
    }
  }]);

  return Store;
}();


function store_extend(target, source) {
  var newItems = {};

  for (var k in source) {
    if (!source.hasOwnProperty(k)) {
      continue;
    }

    if (!isUndefined(target[k])) {
      if (store_typeof(source[k]) === 'object' && !Array.isArray(source[k])) {
        store_extend(target[k], source[k]);
      } else {
        target[k] = source[k];
      }
    } else {
      newItems[k] = source[k];
    }
  }

  if (Object.keys(newItems).length) {
    extend(target, newItems);
  }
}
;// CONCATENATED MODULE: ./src/store/root.ts







function root_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function root_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { root_ownKeys(Object(source), true).forEach(function (key) { root_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { root_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function root_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



function initialSize(containerEl, _ref) {
  var width = _ref.width,
      height = _ref.height;
  return {
    width: width === 0 ? containerEl.offsetWidth : width,
    height: height === 0 ? containerEl.offsetHeight : height
  };
}

var root = {
  name: 'root',
  state: function state(_ref2) {
    var _options$chart, _options$chart2, _options$chart3, _options$chart4;

    var options = _ref2.options;
    return {
      chart: root_objectSpread(root_objectSpread({}, options.chart), {}, {
        width: getInitialSize(options === null || options === void 0 ? void 0 : (_options$chart = options.chart) === null || _options$chart === void 0 ? void 0 : _options$chart.width),
        height: getInitialSize(options === null || options === void 0 ? void 0 : (_options$chart2 = options.chart) === null || _options$chart2 === void 0 ? void 0 : _options$chart2.height)
      }),
      usingContainerSize: {
        width: isAutoValue(options === null || options === void 0 ? void 0 : (_options$chart3 = options.chart) === null || _options$chart3 === void 0 ? void 0 : _options$chart3.width),
        height: isAutoValue(options === null || options === void 0 ? void 0 : (_options$chart4 = options.chart) === null || _options$chart4 === void 0 ? void 0 : _options$chart4.height)
      },
      container: {}
    };
  },
  action: {
    setChartSize: function setChartSize(_ref3, size) {
      var state = _ref3.state;
      state.chart.width = size.width;
      state.chart.height = size.height;
      this.notify(state, 'chart');
    },
    initChartSize: function initChartSize(_ref4, containerEl) {
      var _this = this;

      var state = _ref4.state;
      var _state$chart = state.chart,
          width = _state$chart.width,
          height = _state$chart.height;

      if (width === 0 || height === 0) {
        if (containerEl.parentNode) {
          this.dispatch('setChartSize', initialSize(containerEl, {
            width: width,
            height: height
          }));
        } else {
          setTimeout(function () {
            _this.dispatch('setChartSize', initialSize(containerEl, {
              width: width,
              height: height
            }));
          }, 0);
        }
      }
    },
    setUsingContainerSize: function setUsingContainerSize(_ref5, _ref6) {
      var state = _ref5.state;
      var width = _ref6.width,
          height = _ref6.height;
      state.usingContainerSize.width = width;
      state.usingContainerSize.height = height;
    }
  }
};
/* harmony default export */ var store_root = (root);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.set.js
var es_set = __nested_webpack_require_221589__(3244);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.string.match.js
var es_string_match = __nested_webpack_require_221589__(4069);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.fill.js
var es_array_fill = __nested_webpack_require_221589__(2656);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.string.replace.js
var es_string_replace = __nested_webpack_require_221589__(5940);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.regexp.to-string.js
var es_regexp_to_string = __nested_webpack_require_221589__(8233);
;// CONCATENATED MODULE: ./src/helpers/color.ts
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || color_unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function color_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return color_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return color_arrayLikeToArray(o, minLen); }

function color_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }




















var hexRX = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i;
var rgbRX = /rgb\((\d{1,3}), ?(\d{1,3}), ?(\d{1,3})\)/;
var rgbaRX = /rgba\((\d{1,3}), ?(\d{1,3}), ?(\d{1,3}), ?(1|0?\.?\d+)\)/;
/**
 * Color map.
 * http://stackoverflow.com/questions/1573053/javascript-function-to-convert-color-names-to-hex-codes
 * http://www.w3schools.com/HTML/html_colornames.asp
 * @ignore
 */

var colorMap = {
  aliceblue: '#f0f8ff',
  antiquewhite: '#faebd7',
  aqua: '#00ffff',
  aquamarine: '#7fffd4',
  azure: '#f0ffff',
  beige: '#f5f5dc',
  bisque: '#ffe4c4',
  black: '#000000',
  blanchedalmond: '#ffebcd',
  blue: '#0000ff',
  blueviolet: '#8a2be2',
  brown: '#a52a2a',
  burlywood: '#deb887',
  cadetblue: '#5f9ea0',
  chartreuse: '#7fff00',
  chocolate: '#d2691e',
  coral: '#ff7f50',
  cornflowerblue: '#6495ed',
  cornsilk: '#fff8dc',
  crimson: '#dc143c',
  cyan: '#00ffff',
  darkblue: '#00008b',
  darkcyan: '#008b8b',
  darkgoldenrod: '#b8860b',
  darkgray: '#a9a9a9',
  darkgreen: '#006400',
  darkkhaki: '#bdb76b',
  darkmagenta: '#8b008b',
  darkolivegreen: '#556b2f',
  darkorange: '#ff8c00',
  darkorchid: '#9932cc',
  darkred: '#8b0000',
  darksalmon: '#e9967a',
  darkseagreen: '#8fbc8f',
  darkslateblue: '#483d8b',
  darkslategray: '#2f4f4f',
  darkturquoise: '#00ced1',
  darkviolet: '#9400d3',
  deeppink: '#ff1493',
  deepskyblue: '#00bfff',
  dimgray: '#696969',
  dodgerblue: '#1e90ff',
  firebrick: '#b22222',
  floralwhite: '#fffaf0',
  forestgreen: '#228b22',
  fuchsia: '#ff00ff',
  gainsboro: '#dcdcdc',
  ghostwhite: '#f8f8ff',
  gold: '#ffd700',
  goldenrod: '#daa520',
  gray: '#808080',
  green: '#008000',
  greenyellow: '#adff2f',
  honeydew: '#f0fff0',
  hotpink: '#ff69b4',
  indianred: '#cd5c5c',
  indigo: '#4b0082',
  ivory: '#fffff0',
  khaki: '#f0e68c',
  lavender: '#e6e6fa',
  lavenderblush: '#fff0f5',
  lawngreen: '#7cfc00',
  lemonchiffon: '#fffacd',
  lightblue: '#add8e6',
  lightcoral: '#f08080',
  lightcyan: '#e0ffff',
  lightgoldenrodyellow: '#fafad2',
  lightgrey: '#d3d3d3',
  lightgreen: '#90ee90',
  lightpink: '#ffb6c1',
  lightsalmon: '#ffa07a',
  lightseagreen: '#20b2aa',
  lightskyblue: '#87cefa',
  lightslategray: '#778899',
  lightsteelblue: '#b0c4de',
  lightyellow: '#ffffe0',
  lime: '#00ff00',
  limegreen: '#32cd32',
  linen: '#faf0e6',
  magenta: '#ff00ff',
  maroon: '#800000',
  mediumaquamarine: '#66cdaa',
  mediumblue: '#0000cd',
  mediumorchid: '#ba55d3',
  mediumpurple: '#9370d8',
  mediumseagreen: '#3cb371',
  mediumslateblue: '#7b68ee',
  mediumspringgreen: '#00fa9a',
  mediumturquoise: '#48d1cc',
  mediumvioletred: '#c71585',
  midnightblue: '#191970',
  mintcream: '#f5fffa',
  mistyrose: '#ffe4e1',
  moccasin: '#ffe4b5',
  navajowhite: '#ffdead',
  navy: '#000080',
  oldlace: '#fdf5e6',
  olive: '#808000',
  olivedrab: '#6b8e23',
  orange: '#ffa500',
  orangered: '#ff4500',
  orchid: '#da70d6',
  palegoldenrod: '#eee8aa',
  palegreen: '#98fb98',
  paleturquoise: '#afeeee',
  palevioletred: '#d87093',
  papayawhip: '#ffefd5',
  peachpuff: '#ffdab9',
  peru: '#cd853f',
  pink: '#ffc0cb',
  plum: '#dda0dd',
  powderblue: '#b0e0e6',
  purple: '#800080',
  red: '#ff0000',
  rosybrown: '#bc8f8f',
  royalblue: '#4169e1',
  saddlebrown: '#8b4513',
  salmon: '#fa8072',
  sandybrown: '#f4a460',
  seagreen: '#2e8b57',
  seashell: '#fff5ee',
  sienna: '#a0522d',
  silver: '#c0c0c0',
  skyblue: '#87ceeb',
  slateblue: '#6a5acd',
  slategray: '#708090',
  snow: '#fffafa',
  springgreen: '#00ff7f',
  steelblue: '#4682b4',
  tan: '#d2b48c',
  teal: '#008080',
  thistle: '#d8bfd8',
  tomato: '#ff6347',
  turquoise: '#40e0d0',
  violet: '#ee82ee',
  wheat: '#f5deb3',
  white: '#ffffff',
  whitesmoke: '#f5f5f5',
  yellow: '#ffff00',
  yellowgreen: '#9acd32'
};

function leadingZero(number, length) {
  if (number.length > length) {
    return number;
  }

  var res = number;
  range(0, length - 1).forEach(function (_) {
    res = '0' + res;
  });
  return res.slice(length * -1);
}

function isValidRGB(str) {
  return hexRX.test(str);
}

function colorNameToHex(colorName) {
  return colorMap[colorName.toLowerCase()] || colorName;
} // @license RGB <-> HSV conversion utilities based off of http://www.cs.rit.edu/~ncs/color/t_convert.html


function hexToRGB(str) {
  var hexStr = colorNameToHex(str);

  if (!isValidRGB(hexStr)) {
    return false;
  }

  return hexStr.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function (m, r, g, b) {
    return '#' + r + r + g + g + b + b;
  }).substring(1).match(/.{2}/g).map(function (x) {
    return parseInt(x, 16);
  });
}
function rgbToHEX(r, g, b) {
  var hexPreFix = '#';
  var hexStr = hexPreFix + leadingZero(r.toString(16), 2) + leadingZero(g.toString(16), 2) + leadingZero(b.toString(16), 2);

  if (isValidRGB(hexStr)) {
    return hexStr;
  }

  return false;
}
function getRGBA(str, opacity) {
  var hexStr = colorNameToHex(str);

  if (isValidRGB(hexStr)) {
    var _ref = hexToRGB(hexStr),
        _ref2 = _slicedToArray(_ref, 3),
        r = _ref2[0],
        g = _ref2[1],
        b = _ref2[2];

    return "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(opacity, ")");
  }

  if (rgbRX.test(str)) {
    var match = rgbRX.exec(str);
    return "rgba(".concat(match[1], ", ").concat(match[2], ", ").concat(match[3], ", ").concat(opacity, ")");
  }

  if (rgbaRX.test(str)) {
    var _match = rgbaRX.exec(str);

    return "rgba(".concat(_match[1], ", ").concat(_match[2], ", ").concat(_match[3], ", ").concat(opacity, ")");
  }

  return str;
}
function getAlpha(str) {
  if (rgbaRX.test(str)) {
    var match = rgbaRX.exec(str);
    return Number(match[4]);
  }

  return 1;
}
function rgba(color) {
  var opacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var alpha = getAlpha(color) * opacity;
  return getRGBA(color, alpha);
}
;// CONCATENATED MODULE: ./src/helpers/style.ts









function style_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function style_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { style_ownKeys(Object(source), true).forEach(function (key) { style_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { style_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function style_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



function makeStyleObj(style, styleSet) {
  return style.reduce(function (acc, curValue) {
    if (utils_isString(curValue)) {
      return style_objectSpread(style_objectSpread({}, acc), styleSet[curValue]);
    }

    return style_objectSpread(style_objectSpread({}, acc), curValue);
  }, {});
}
function getTranslateString(x, y) {
  return "translate(".concat(x, "px,").concat(y, "px)");
}
function getTitleFontString(fontTheme) {
  var fontFamily = fontTheme.fontFamily,
      fontSize = fontTheme.fontSize,
      fontWeight = fontTheme.fontWeight;
  return "".concat(fontWeight, " ").concat(fontSize, "px ").concat(fontFamily);
}
function getFontStyleString(theme) {
  var color = theme.color,
      fontSize = theme.fontSize,
      fontFamily = theme.fontFamily,
      fontWeight = theme.fontWeight;
  return "font-weight: ".concat(fontWeight, "; font-family: ").concat(fontFamily, "; font-size: ").concat(fontSize, "px; color: ").concat(color, ";");
}
function getFont(theme) {
  return getTitleFontString(pick(theme, 'fontFamily', 'fontWeight', 'fontSize'));
}
function setLineDash(ctx, dashSegments) {
  if (ctx.setLineDash) {
    ctx.setLineDash(dashSegments);
  }
}
function getBoxTypeSeriesPadding(tickDistance) {
  return Math.floor(tickDistance * 0.15);
}
function fillStyle(ctx, fillOption) {
  ctx.fillStyle = fillOption;
  ctx.fill();
}
function strokeWithOptions(ctx, style) {
  var lineWidth = style.lineWidth,
      strokeStyle = style.strokeStyle;

  if (strokeStyle) {
    ctx.strokeStyle = strokeStyle;
  }

  if (lineWidth) {
    ctx.lineWidth = lineWidth;
  }

  if (ctx.lineWidth && getAlpha(String(ctx.strokeStyle))) {
    ctx.stroke();
  }
}
;// CONCATENATED MODULE: ./src/brushes/label.ts






var DEFAULT_LABEL_TEXT = 'normal 11px Arial';
var labelStyle = {
  default: {
    font: DEFAULT_LABEL_TEXT,
    fillStyle: '#333333',
    textAlign: 'left',
    textBaseline: 'middle'
  },
  title: {
    textBaseline: 'top'
  },
  axisTitle: {
    textBaseline: 'top'
  },
  rectLabel: {
    font: DEFAULT_LABEL_TEXT,
    fillStyle: 'rgba(0, 0, 0, 0.3)',
    textAlign: 'center',
    textBaseline: 'middle'
  }
};
var strokeLabelStyle = {
  none: {
    lineWidth: 1,
    strokeStyle: 'rgba(255, 255, 255, 0)'
  },
  stroke: {
    lineWidth: 4,
    strokeStyle: 'rgba(255, 255, 255, 0.5)'
  }
};
function label(ctx, labelModel) {
  var x = labelModel.x,
      y = labelModel.y,
      text = labelModel.text,
      style = labelModel.style,
      stroke = labelModel.stroke,
      opacity = labelModel.opacity,
      radian = labelModel.radian,
      rotationPosition = labelModel.rotationPosition;

  if (style) {
    var styleObj = makeStyleObj(style, labelStyle);
    Object.keys(styleObj).forEach(function (key) {
      ctx[key] = key === 'fillStyle' && isNumber(opacity) ? rgba(styleObj[key], opacity) : styleObj[key];
    });
  }

  ctx.save();

  if (radian) {
    var _rotationPosition$x, _rotationPosition$y, _rotationPosition$x2, _rotationPosition$y2;

    ctx.translate((_rotationPosition$x = rotationPosition === null || rotationPosition === void 0 ? void 0 : rotationPosition.x) !== null && _rotationPosition$x !== void 0 ? _rotationPosition$x : x, (_rotationPosition$y = rotationPosition === null || rotationPosition === void 0 ? void 0 : rotationPosition.y) !== null && _rotationPosition$y !== void 0 ? _rotationPosition$y : y);
    ctx.rotate(radian);
    ctx.translate(-((_rotationPosition$x2 = rotationPosition === null || rotationPosition === void 0 ? void 0 : rotationPosition.x) !== null && _rotationPosition$x2 !== void 0 ? _rotationPosition$x2 : x), -((_rotationPosition$y2 = rotationPosition === null || rotationPosition === void 0 ? void 0 : rotationPosition.y) !== null && _rotationPosition$y2 !== void 0 ? _rotationPosition$y2 : y));
  }

  if (stroke) {
    var strokeStyleObj = makeStyleObj(stroke, strokeLabelStyle);
    var strokeStyleKeys = Object.keys(strokeStyleObj);
    strokeStyleKeys.forEach(function (key) {
      ctx[key] = key === 'strokeStyle' && isNumber(opacity) ? rgba(strokeStyleObj[key], opacity) : strokeStyleObj[key];
    });

    if (strokeStyleKeys.length) {
      ctx.strokeText(text, x, y);
    }
  }

  ctx.fillText(text, x, y);
  ctx.restore();
}
var textBubbleStyle = {
  shadow: {
    shadowColor: 'rgba(0, 0, 0, 0.3)',
    shadowOffsetY: 2,
    shadowBlur: 4
  }
};
function bubbleLabel(ctx, model) {
  var _model$radian = model.radian,
      radian = _model$radian === void 0 ? 0 : _model$radian,
      rotationPosition = model.rotationPosition,
      _model$bubble = model.bubble,
      x = _model$bubble.x,
      y = _model$bubble.y,
      width = _model$bubble.width,
      height = _model$bubble.height,
      _model$bubble$radius = _model$bubble.radius,
      radius = _model$bubble$radius === void 0 ? 0 : _model$bubble$radius,
      _model$bubble$lineWid = _model$bubble.lineWidth,
      lineWidth = _model$bubble$lineWid === void 0 ? 1 : _model$bubble$lineWid,
      direction = _model$bubble.direction,
      _model$bubble$points = _model$bubble.points,
      points = _model$bubble$points === void 0 ? [] : _model$bubble$points,
      _model$bubble$fill = _model$bubble.fill,
      fill = _model$bubble$fill === void 0 ? '#fff' : _model$bubble$fill,
      _model$bubble$strokeS = _model$bubble.strokeStyle,
      strokeStyle = _model$bubble$strokeS === void 0 ? 'rgba(0, 0, 0, 0)' : _model$bubble$strokeS,
      _model$bubble$style = _model$bubble.style,
      bubbleStyle = _model$bubble$style === void 0 ? null : _model$bubble$style;

  if (width > 0 && height > 0) {
    var _rotationPosition$x3, _rotationPosition$y3;

    drawBubble(ctx, {
      x: x,
      y: y,
      radius: radius,
      width: width,
      height: height,
      style: bubbleStyle,
      fill: fill,
      strokeStyle: strokeStyle,
      lineWidth: lineWidth,
      direction: direction,
      points: points,
      radian: radian,
      rotationPosition: {
        x: (_rotationPosition$x3 = rotationPosition === null || rotationPosition === void 0 ? void 0 : rotationPosition.x) !== null && _rotationPosition$x3 !== void 0 ? _rotationPosition$x3 : x,
        y: (_rotationPosition$y3 = rotationPosition === null || rotationPosition === void 0 ? void 0 : rotationPosition.y) !== null && _rotationPosition$y3 !== void 0 ? _rotationPosition$y3 : y
      }
    });
  }

  if (model.label.text) {
    var _model$label = model.label,
        labelX = _model$label.x,
        labelY = _model$label.y,
        text = _model$label.text,
        _model$label$strokeSt = _model$label.strokeStyle,
        labelStrokeColor = _model$label$strokeSt === void 0 ? 'rgba(0, 0, 0, 0)' : _model$label$strokeSt,
        style = _model$label.style;
    ctx.shadowColor = 'rgba(0, 0, 0, 0)';
    label(ctx, {
      type: 'label',
      x: labelX,
      y: labelY,
      text: text,
      style: style,
      stroke: [{
        strokeStyle: labelStrokeColor
      }],
      radian: radian,
      rotationPosition: rotationPosition
    });
  }
}

function drawBubbleArrow(ctx, points) {
  if (!points.length) {
    return;
  }

  ctx.lineTo(points[0].x, points[0].y);
  ctx.lineTo(points[1].x, points[1].y);
  ctx.lineTo(points[2].x, points[2].y);
}

function drawBubble(ctx, model) {
  var x = model.x,
      y = model.y,
      width = model.width,
      height = model.height,
      style = model.style,
      _model$radius = model.radius,
      radius = _model$radius === void 0 ? 0 : _model$radius,
      strokeStyle = model.strokeStyle,
      fill = model.fill,
      _model$lineWidth = model.lineWidth,
      lineWidth = _model$lineWidth === void 0 ? 1 : _model$lineWidth,
      _model$points = model.points,
      points = _model$points === void 0 ? [] : _model$points,
      _model$direction = model.direction,
      direction = _model$direction === void 0 ? '' : _model$direction,
      radian = model.radian,
      rotationPosition = model.rotationPosition;
  var right = x + width;
  var bottom = y + height;
  ctx.beginPath();
  ctx.save();

  if (radian && rotationPosition) {
    ctx.translate(rotationPosition.x, rotationPosition.y);
    ctx.rotate(radian);
    ctx.translate(-rotationPosition.x, -rotationPosition.y);
  }

  ctx.moveTo(x + radius, y);

  if (direction === 'top') {
    drawBubbleArrow(ctx, points);
  }

  ctx.lineTo(right - radius, y);
  ctx.quadraticCurveTo(right, y, right, y + radius);

  if (direction === 'right') {
    drawBubbleArrow(ctx, points);
  }

  ctx.lineTo(right, y + height - radius);
  ctx.quadraticCurveTo(right, bottom, right - radius, bottom);

  if (direction === 'bottom') {
    drawBubbleArrow(ctx, points);
  }

  ctx.lineTo(x + radius, bottom);
  ctx.quadraticCurveTo(x, bottom, x, bottom - radius);

  if (direction === 'left') {
    drawBubbleArrow(ctx, points);
  }

  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);

  if (style) {
    var styleObj = makeStyleObj(style, textBubbleStyle);
    Object.keys(styleObj).forEach(function (key) {
      ctx[key] = styleObj[key];
    });
  }

  if (fill) {
    fillStyle(ctx, fill);
  }

  if (strokeStyle) {
    strokeWithOptions(ctx, {
      strokeStyle: strokeStyle,
      lineWidth: lineWidth
    });
  }

  ctx.restore();
}
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.string.anchor.js
var es_string_anchor = __nested_webpack_require_221589__(1549);
;// CONCATENATED MODULE: ./src/helpers/sector.ts








function sector_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function sector_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { sector_ownKeys(Object(source), true).forEach(function (key) { sector_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { sector_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function sector_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var DEGREE_180 = 180;
var DEGREE_NEGATIVE_180 = -180;
var DEGREE_360 = 360;
var DEGREE_0 = 0;
var DEGREE_NEGATIVE_90 = -90;
var DEGREE_90 = 90;
var MINIMUM_RADIUS = 10;
function makeAnchorPositionParam(anchor, model) {
  return sector_objectSpread({
    anchor: anchor
  }, pick(model, 'x', 'y', 'radius', 'degree', 'drawingStartAngle'));
}
function calculateDegreeToRadian(degree) {
  var drawingStartAngle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEGREE_NEGATIVE_90;
  var result = 0;

  if (degree % DEGREE_360 === 0) {
    result = Math.PI / DEGREE_180 * drawingStartAngle;
  } else if (degree >= 0) {
    result = Math.PI / DEGREE_180 * (degree + drawingStartAngle);
  }

  return result;
}
function calculateRadianToDegree(radian) {
  var drawingStartAngle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEGREE_NEGATIVE_90;
  return (radian * DEGREE_180 / Math.PI - drawingStartAngle + DEGREE_360) % DEGREE_360;
}
function getRadialAnchorPosition(param) {
  var anchor = param.anchor,
      x = param.x,
      y = param.y,
      _param$radius = param.radius,
      inner = _param$radius.inner,
      outer = _param$radius.outer,
      _param$degree = param.degree,
      start = _param$degree.start,
      end = _param$degree.end,
      _param$drawingStartAn = param.drawingStartAngle,
      drawingStartAngle = _param$drawingStartAn === void 0 ? DEGREE_NEGATIVE_90 : _param$drawingStartAn;
  var halfDegree = start + (end - start) / 2;
  var radian = calculateDegreeToRadian(halfDegree, drawingStartAngle);
  var r = anchor === 'outer' ? outer : (outer + inner) / 2;
  return getRadialPosition(x, y, r, radian);
}
function getRadialPosition(x, y, r, radian) {
  return {
    x: Math.round(x + r * Math.cos(radian)),
    y: Math.round(y + r * Math.sin(radian))
  };
}
function withinRadian(clockwise, startDegree, endDegree, currentDegree) {
  return clockwise ? startDegree <= currentDegree && endDegree >= currentDegree : startDegree >= currentDegree && endDegree <= currentDegree;
}
function initSectorOptions(options) {
  var _options$clockwise, _options$angleRange$s, _options$angleRange, _options$angleRange$e, _options$angleRange2;

  var clockwise = (_options$clockwise = options === null || options === void 0 ? void 0 : options.clockwise) !== null && _options$clockwise !== void 0 ? _options$clockwise : true;
  return {
    clockwise: clockwise,
    startAngle: (_options$angleRange$s = options === null || options === void 0 ? void 0 : (_options$angleRange = options.angleRange) === null || _options$angleRange === void 0 ? void 0 : _options$angleRange.start) !== null && _options$angleRange$s !== void 0 ? _options$angleRange$s : clockwise ? DEGREE_0 : DEGREE_360,
    endAngle: (_options$angleRange$e = options === null || options === void 0 ? void 0 : (_options$angleRange2 = options.angleRange) === null || _options$angleRange2 === void 0 ? void 0 : _options$angleRange2.end) !== null && _options$angleRange$e !== void 0 ? _options$angleRange$e : clockwise ? DEGREE_360 : DEGREE_0
  };
}
function getDefaultRadius(_ref) {
  var width = _ref.width,
      height = _ref.height;
  var isSemiCircular = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var maxLabelWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var maxLabelHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var result;

  if (isSemiCircular) {
    result = Math.min(width / 2, height) - maxLabelHeight;
  } else if (width > height) {
    result = height / 2 - maxLabelHeight;
  } else {
    result = width / 2 - maxLabelWidth;
  }

  return Math.max(result, MINIMUM_RADIUS);
}

function getRadian(startAngle, endAngle, drawingStartAngle, needCalculateByHalf) {
  var degree = needCalculateByHalf ? (endAngle + startAngle) / 2 : startAngle;
  return calculateDegreeToRadian(degree, drawingStartAngle);
}

function getRadialLabelAlign(model, anchor) {
  var needCalculateByHalf = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var _model$totalAngle = model.totalAngle,
      totalAngle = _model$totalAngle === void 0 ? DEGREE_360 : _model$totalAngle,
      _model$degree = model.degree,
      start = _model$degree.start,
      end = _model$degree.end,
      _model$drawingStartAn = model.drawingStartAngle,
      drawingStartAngle = _model$drawingStartAn === void 0 ? DEGREE_NEGATIVE_90 : _model$drawingStartAn;
  var textAlign = 'center';

  if (anchor !== 'outer') {
    return textAlign;
  }

  var radian0 = calculateDegreeToRadian(0, drawingStartAngle);
  var halfRadian = calculateDegreeToRadian(totalAngle / 2, drawingStartAngle);
  var radian = getRadian(start, end, drawingStartAngle, needCalculateByHalf);

  if (drawingStartAngle >= DEGREE_NEGATIVE_90 && drawingStartAngle < DEGREE_90) {
    if (radian0 < radian && halfRadian > radian) {
      textAlign = 'left';
    } else if (halfRadian < radian) {
      textAlign = 'right';
    }
  } else if (radian0 < radian && halfRadian > radian) {
    textAlign = 'right';
  } else if (halfRadian < radian) {
    textAlign = 'left';
  }

  return textAlign;
}
function getRadiusRanges(radiusRanges, padding) {
  return radiusRanges.reduce(function (acc, cur, index) {
    if (index) {
      acc.push({
        inner: cur + padding,
        outer: radiusRanges[index - 1] - padding
      });
    }

    if (index === radiusRanges.length - 1) {
      acc.push({
        inner: padding,
        outer: cur - padding
      });
    }

    return acc;
  }, []);
} // Recalculate to an angle between 0 and 360 degrees.

function calculateValidAngle(angle) {
  if (angle < DEGREE_0) {
    return DEGREE_360 + angle % DEGREE_360;
  }

  if (angle > DEGREE_360) {
    return angle % DEGREE_360;
  }

  return angle;
}
;// CONCATENATED MODULE: ./src/brushes/basic.ts





var circleStyle = {
  default: {
    strokeStyle: '#ffffff',
    lineWidth: 2
  },
  plot: {
    lineWidth: 1,
    strokeStyle: 'rgba(0, 0, 0, 0.05)'
  }
};
var rectStyle = {
  shadow: {
    shadowColor: 'rgba(0, 0, 0, 0.3)',
    shadowOffsetX: 2,
    shadowOffsetY: 2,
    shadowBlur: 6
  }
};
function clipRectArea(ctx, clipRectAreaModel) {
  var x = clipRectAreaModel.x,
      y = clipRectAreaModel.y,
      width = clipRectAreaModel.width,
      height = clipRectAreaModel.height;
  ctx.beginPath();
  ctx.rect(x, y, width, height);
  ctx.clip();
}
function pathRect(ctx, pathRectModel) {
  var x = pathRectModel.x,
      y = pathRectModel.y,
      width = pathRectModel.width,
      height = pathRectModel.height,
      _pathRectModel$radius = pathRectModel.radius,
      radius = _pathRectModel$radius === void 0 ? 0 : _pathRectModel$radius,
      _pathRectModel$stroke = pathRectModel.stroke,
      strokeStyle = _pathRectModel$stroke === void 0 ? 'black' : _pathRectModel$stroke,
      _pathRectModel$fill = pathRectModel.fill,
      fill = _pathRectModel$fill === void 0 ? '' : _pathRectModel$fill,
      _pathRectModel$lineWi = pathRectModel.lineWidth,
      lineWidth = _pathRectModel$lineWi === void 0 ? 1 : _pathRectModel$lineWi;
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();

  if (fill) {
    fillStyle(ctx, fill);
  }

  strokeWithOptions(ctx, {
    lineWidth: lineWidth,
    strokeStyle: strokeStyle
  });
}
function circle(ctx, circleModel) {
  var x = circleModel.x,
      y = circleModel.y,
      style = circleModel.style,
      radius = circleModel.radius,
      color = circleModel.color,
      _circleModel$angle = circleModel.angle,
      angle = _circleModel$angle === void 0 ? {
    start: 0,
    end: Math.PI * 2
  } : _circleModel$angle,
      lineWidth = circleModel.borderWidth,
      strokeStyle = circleModel.borderColor;
  ctx.beginPath();

  if (style) {
    var styleObj = makeStyleObj(style, circleStyle);
    Object.keys(styleObj).forEach(function (key) {
      ctx[key] = styleObj[key];
    });
  }

  ctx.arc(x, y, radius, angle.start, angle.end, true);
  strokeWithOptions(ctx, {
    lineWidth: lineWidth,
    strokeStyle: strokeStyle
  });
  fillStyle(ctx, color);
  ctx.closePath();
}
function line(ctx, lineModel) {
  var x = lineModel.x,
      y = lineModel.y,
      x2 = lineModel.x2,
      y2 = lineModel.y2,
      strokeStyle = lineModel.strokeStyle,
      lineWidth = lineModel.lineWidth,
      dashSegments = lineModel.dashSegments;
  ctx.beginPath();

  if (dashSegments) {
    setLineDash(ctx, dashSegments);
  }

  ctx.moveTo(x, y);
  ctx.lineTo(x2, y2);
  strokeWithOptions(ctx, {
    strokeStyle: strokeStyle,
    lineWidth: lineWidth
  });
  ctx.closePath();
}
function rect(ctx, model) {
  var x = model.x,
      y = model.y,
      width = model.width,
      height = model.height,
      style = model.style,
      _model$thickness = model.thickness,
      thickness = _model$thickness === void 0 ? 0 : _model$thickness,
      color = model.color,
      _model$borderColor = model.borderColor,
      borderColor = _model$borderColor === void 0 ? '#ffffff' : _model$borderColor;
  ctx.beginPath();

  if (style) {
    var styleObj = makeStyleObj(style, rectStyle);
    Object.keys(styleObj).forEach(function (key) {
      ctx[key] = styleObj[key];
    });
  }

  if (thickness) {
    ctx.fillStyle = borderColor;
    ctx.fillRect(x - thickness, y - thickness, width + thickness * 2, height + thickness * 2);
    ctx.shadowColor = 'rgba(0, 0, 0, 0)'; // reset shadow color
  }

  ctx.rect(x, y, width, height);
  fillStyle(ctx, color);
}
function arc(ctx, arcModel) {
  var x = arcModel.x,
      y = arcModel.y,
      _arcModel$angle = arcModel.angle,
      start = _arcModel$angle.start,
      end = _arcModel$angle.end,
      lineWidth = arcModel.borderWidth,
      strokeStyle = arcModel.borderColor,
      drawingStartAngle = arcModel.drawingStartAngle,
      radius = arcModel.radius,
      _arcModel$clockwise = arcModel.clockwise,
      clockwise = _arcModel$clockwise === void 0 ? true : _arcModel$clockwise;
  ctx.beginPath();
  var startRadian = calculateDegreeToRadian(start, drawingStartAngle);
  var endRadian = calculateDegreeToRadian(end, drawingStartAngle);
  ctx.arc(x, y, radius, startRadian, endRadian, !clockwise);
  strokeWithOptions(ctx, {
    lineWidth: lineWidth,
    strokeStyle: strokeStyle
  });
  ctx.closePath();
}
;// CONCATENATED MODULE: ./src/brushes/axis.ts

var TICK_SIZE = 5;
function tick(ctx, tickModel) {
  var x = tickModel.x,
      y = tickModel.y,
      isYAxis = tickModel.isYAxis,
      _tickModel$tickSize = tickModel.tickSize,
      tickSize = _tickModel$tickSize === void 0 ? TICK_SIZE : _tickModel$tickSize,
      strokeStyle = tickModel.strokeStyle,
      lineWidth = tickModel.lineWidth;
  var lineModel = {
    type: 'line',
    x: x,
    y: y,
    x2: x,
    y2: y,
    strokeStyle: strokeStyle,
    lineWidth: lineWidth
  };

  if (isYAxis) {
    lineModel.x2 += tickSize;
  } else {
    lineModel.y2 += tickSize;
  }

  line(ctx, lineModel);
}
;// CONCATENATED MODULE: ./src/helpers/calculator.ts
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || calculator_unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function calculator_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return calculator_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return calculator_arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return calculator_arrayLikeToArray(arr); }

function calculator_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }



















var LINE_HEIGHT_NORMAL = 1.2;
var ctx = document.createElement('canvas').getContext('2d');
function getTextWidth(text) {
  var font = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_LABEL_TEXT;
  ctx.font = font;
  return Math.ceil(ctx.measureText(text).width);
}
/*
 * Calculate height of canvas text
 * https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics
 * */

function getTextHeight(text) {
  var font = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_LABEL_TEXT;
  ctx.font = font;

  var _ctx$measureText = ctx.measureText(text),
      actualBoundingBoxAscent = _ctx$measureText.actualBoundingBoxAscent,
      actualBoundingBoxDescent = _ctx$measureText.actualBoundingBoxDescent;

  var validActualBoundingBox = isNumber(actualBoundingBoxAscent) && isNumber(actualBoundingBoxDescent);
  return validActualBoundingBox ? Math.ceil(Math.abs(actualBoundingBoxAscent) + Math.abs(actualBoundingBoxDescent)) + 1 : getFontHeight(font);
}
function getFontHeight() {
  var font = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_LABEL_TEXT;
  var fontSize = font.match(/\d+(?=px)/);
  return parseInt(String(Number(fontSize) * LINE_HEIGHT_NORMAL), 10);
}
function getAxisLabelAnchorPoint(labelHeight) {
  return crispPixel(TICK_SIZE * 2 + labelHeight / 2);
}

function getDecimalLength(value) {
  var _String$split$1$lengt, _String$split$;

  return (_String$split$1$lengt = (_String$split$ = String(value).split('.')[1]) === null || _String$split$ === void 0 ? void 0 : _String$split$.length) !== null && _String$split$1$lengt !== void 0 ? _String$split$1$lengt : 0;
}

function findMultipleNum() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var underPointLens = args.map(function (value) {
    return getDecimalLength(value);
  });
  var underPointLen = Math.max.apply(Math, _toConsumableArray(underPointLens));
  return Math.pow(10, underPointLen);
}

function add(a, b) {
  var multipleNum = findMultipleNum(a, b);
  return (a * multipleNum + b * multipleNum) / multipleNum;
}
function multiply(a, b) {
  var multipleNum = findMultipleNum(a, b);
  return a * multipleNum * (b * multipleNum) / (multipleNum * multipleNum);
}
function divide(a, b) {
  var multipleNum = findMultipleNum(a, b);
  return a * multipleNum / (b * multipleNum);
}
function calculator_sum(values) {
  var copyArr = values.slice();
  copyArr.unshift(0);
  return copyArr.reduce(function (base, value) {
    return add(parseFloat(String(base)), parseFloat(String(value)));
  });
}
function divisors(value) {
  var result = [];

  for (var a = 2, b; a * a <= value; a += 1) {
    if (value % a === 0) {
      b = value / a;
      result.push(a);

      if (b !== a) {
        result.push(b);
      }
    }
  }

  return result.sort(function (prev, next) {
    return prev - next;
  });
}
function makeLabelsFromLimit(limit, stepSize, isDateType) {
  var multipleNum = findMultipleNum(stepSize);
  var min = Math.round(limit.min * multipleNum);
  var max = Math.round(limit.max * multipleNum);
  var labels = range(min, max + 1, stepSize * multipleNum);
  return labels.map(function (label) {
    return String(isDateType ? new Date(label) : label / multipleNum);
  });
}
function makeTickPixelPositions(size, count) {
  var additionalPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var remainLastBlockIntervalPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var positions = [];

  if (count > 0) {
    positions = range(0, count).map(function (index) {
      var ratio = index === 0 ? 0 : index / (count - 1);
      return ratio * size + additionalPosition;
    });
  }

  if (remainLastBlockIntervalPosition) {
    positions.push(remainLastBlockIntervalPosition);
  }

  return positions;
}
function crispPixel(pixel) {
  var thickness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  var halfThickness = thickness / 2;
  return thickness % 2 ? (isInteger(pixel) ? pixel : Math.round(pixel - halfThickness)) + halfThickness : Math.round(pixel);
}

function getControlPoints(prev, cur, next) {
  // http://scaledinnovation.com/analytics/splines/aboutSplines.html
  var TENSION = 0.333;
  var x0 = prev.x,
      y0 = prev.y;
  var x1 = cur.x,
      y1 = cur.y;
  var x2 = next.x,
      y2 = next.y;
  var d12 = getDistance(next, cur);
  var d01 = getDistance(cur, prev);
  var fa = TENSION * d01 / (d01 + d12) || 0; // scaling factor for triangle Ta

  var fb = TENSION * d12 / (d01 + d12) || 0; // ditto for Tb, simplifies to fb=t-fa

  return {
    prev: {
      x: x1 - fa * (x2 - x0),
      // x2-x0 is the width of triangle T
      y: y1 - fa * (y2 - y0) // y2-y0 is the height of T

    },
    next: {
      x: x1 + fb * (x2 - x0),
      y: y1 + fb * (y2 - y0)
    }
  };
}

function setSplineControlPoint(points) {
  for (var i = 0, pointsSize = points.length, prev = points[0]; i < pointsSize; i += 1) {
    var point = points[i];

    if (isNull(point)) {
      prev = points[i + 1];
      continue;
    }

    var next = points[Math.min(i + 1, pointsSize - 1) % pointsSize];

    if (prev && next) {
      point.controlPoint = getControlPoints(prev, point, next);
    }

    prev = point;
  }
}
function getValueRatio(value, _ref) {
  var min = _ref.min,
      max = _ref.max;

  if (max === min) {
    return 0;
  }

  return (value - min) / (max - min);
}
function getDistance(point1, point2) {
  return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
}
function getMaxLengthLabelWidth(labels) {
  var maxLengthLabel = labels.reduce(function (acc, cur) {
    return acc.length > cur.length ? acc : cur;
  }, '');
  return getTextWidth(maxLengthLabel);
}
function getXPosition(axisData, offsetSize, value, dataIndex) {
  var pointOnColumn = axisData.pointOnColumn,
      tickDistance = axisData.tickDistance,
      labelRange = axisData.labelRange;
  var x;

  if (labelRange) {
    var xValue = utils_isString(value) ? Number(new Date(value)) : Number(value);
    var xValueRatio = getValueRatio(xValue, labelRange);
    x = xValueRatio * offsetSize;
  } else {
    x = tickDistance * dataIndex + (pointOnColumn ? tickDistance / 2 : 0);
  }

  return x;
}
;// CONCATENATED MODULE: ./src/helpers/arrayUtil.ts














function arrayUtil_slicedToArray(arr, i) { return arrayUtil_arrayWithHoles(arr) || arrayUtil_iterableToArrayLimit(arr, i) || arrayUtil_unsupportedIterableToArray(arr, i) || arrayUtil_nonIterableRest(); }

function arrayUtil_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function arrayUtil_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function arrayUtil_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function arrayUtil_toConsumableArray(arr) { return arrayUtil_arrayWithoutHoles(arr) || arrayUtil_iterableToArray(arr) || arrayUtil_unsupportedIterableToArray(arr) || arrayUtil_nonIterableSpread(); }

function arrayUtil_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function arrayUtil_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return arrayUtil_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayUtil_arrayLikeToArray(o, minLen); }

function arrayUtil_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function arrayUtil_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return arrayUtil_arrayLikeToArray(arr); }

function arrayUtil_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function max(arr, condition, context) {
  var result;

  if (!condition) {
    result = Math.max.apply(Math, arrayUtil_toConsumableArray(arr));
  } else {
    var _arr2 = arrayUtil_slicedToArray(arr, 1);

    result = _arr2[0];
    var rest = arr.slice(1);
    var maxValue = condition.call(context, result, 0);
    rest.forEach(function (item, index) {
      var compareValue = condition.call(context, item, index + 1);

      if (compareValue > maxValue) {
        maxValue = compareValue;
        result = item;
      }
    });
  }

  return result;
}
/**
 * Array pivot.
 * @memberOf module:arrayUtil
 * @param {Array.<Array>} arr2d target 2d array
 * @returns {Array.<Array>} pivoted 2d array
 */

function pivot(arr2d) {
  var result = [];
  var len = max(arr2d.map(function (arr) {
    return arr.length;
  }));
  arr2d.forEach(function (arr) {
    for (var index = 0; index < len; index += 1) {
      if (!result[index]) {
        result[index] = [];
      }

      result[index].push(arr[index]);
    }
  });
  return result;
}
function isSameArray(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }

  for (var i = 0; i < arr1.length; i += 1) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }

  return true;
}
function pluck(arr, property) {
  return arr.reduce(function (acc, cur) {
    return [].concat(arrayUtil_toConsumableArray(acc), [cur[property]]);
  }, []);
}
;// CONCATENATED MODULE: ./src/component/component.ts
function component_toConsumableArray(arr) { return component_arrayWithoutHoles(arr) || component_iterableToArray(arr) || component_unsupportedIterableToArray(arr) || component_nonIterableSpread(); }

function component_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function component_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return component_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return component_arrayLikeToArray(o, minLen); }

function component_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function component_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return component_arrayLikeToArray(arr); }

function component_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function component_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function component_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { component_ownKeys(Object(source), true).forEach(function (key) { component_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { component_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }





















function component_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function component_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function component_createClass(Constructor, protoProps, staticProps) { if (protoProps) component_defineProperties(Constructor.prototype, protoProps); if (staticProps) component_defineProperties(Constructor, staticProps); return Constructor; }

function component_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var Component = /*#__PURE__*/function () {
  function Component(_ref) {
    var store = _ref.store,
        eventBus = _ref.eventBus;

    component_classCallCheck(this, Component);

    component_defineProperty(this, "name", 'Component');

    component_defineProperty(this, "type", 'component');

    component_defineProperty(this, "rect", {
      x: 0,
      y: 0,
      height: 0,
      width: 0
    });

    component_defineProperty(this, "isShow", true);

    component_defineProperty(this, "selectable", void 0);

    component_defineProperty(this, "store", void 0);

    component_defineProperty(this, "eventBus", void 0);

    component_defineProperty(this, "models", void 0);

    component_defineProperty(this, "drawModels", void 0);

    component_defineProperty(this, "responders", void 0);

    component_defineProperty(this, "activeSeriesMap", void 0);

    this.store = store;
    this.eventBus = eventBus;
  }

  component_createClass(Component, [{
    key: "update",
    value: function update(delta) {
      var _this = this;

      if (!this.drawModels) {
        return;
      }

      if (Array.isArray(this.models)) {
        this.updateModels(this.drawModels, this.models, delta);
      } else {
        Object.keys(this.models).forEach(function (type) {
          var currentModels = _this.drawModels[type];
          var targetModels = _this.models[type];

          _this.updateModels(currentModels, targetModels, delta);
        });
      }
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      this.update(delta);
    }
  }, {
    key: "updateModels",
    value: function updateModels(currentModels, targetModels, delta) {
      var _this2 = this;

      currentModels.forEach(function (current, index) {
        var target = targetModels[index];
        Object.keys(current).forEach(function (key) {
          if (!current || !target) {
            return;
          }

          if (key[0] !== '_') {
            if (isNumber(current[key])) {
              current[key] = current[key] + (target[key] - current[key]) * delta;
            } else if (key === 'points') {
              var _this2$store$state$op;

              var matchedModel = _this2.getCurrentModelToMatchTargetModel(current[key], current[key], target[key]);

              var newPoints = matchedModel.map(function (curPoint, idx) {
                var next = target[key][idx];

                if (curPoint && next) {
                  var x = curPoint.x,
                      y = curPoint.y;
                  var nextX = next.x,
                      nextY = next.y;
                  return component_objectSpread(component_objectSpread({}, next), {}, {
                    x: x + (nextX - x) * delta,
                    y: y + (nextY - y) * delta
                  });
                }

                return next;
              });

              if ((_this2$store$state$op = _this2.store.state.options.series) !== null && _this2$store$state$op !== void 0 && _this2$store$state$op.spline) {
                setSplineControlPoint(newPoints);
              }

              current[key] = newPoints;
            } else {
              current[key] = target[key];
            }
          }
        });
      });
    }
  }, {
    key: "sync",
    value: function sync() {
      var _this3 = this;

      if (!this.drawModels) {
        return;
      }

      if (Array.isArray(this.models)) {
        this.syncModels(this.drawModels, this.models);
      } else if (!Object.keys(this.models).length) {
        this.drawModels = this.models;
      } else {
        Object.keys(this.models).forEach(function (type) {
          var currentModels = _this3.drawModels[type];
          var targetModels = _this3.models[type];

          _this3.syncModels(currentModels, targetModels, type);
        });
      }
    }
  }, {
    key: "getCurrentModelToMatchTargetModel",
    value: function getCurrentModelToMatchTargetModel(models, currentModels, targetModels) {
      var _getFirstValidValue;

      if (!models || !currentModels) {
        return component_toConsumableArray(targetModels);
      }

      if ((_getFirstValidValue = getFirstValidValue(targetModels)) !== null && _getFirstValidValue !== void 0 && _getFirstValidValue.name) {
        var modelNames = component_toConsumableArray(new Set(models.map(function (_ref2) {
          var name = _ref2.name;
          return name;
        })));

        var targetNames = component_toConsumableArray(new Set(targetModels.map(function (_ref3) {
          var name = _ref3.name;
          return name;
        })));

        var same = isSameArray(modelNames, targetNames);

        if (!same) {
          return this.getCurrentModelWithDifferentModel(models, currentModels, targetModels, modelNames, targetNames);
        }
      }

      var currentLength = currentModels.length;
      var targetLength = targetModels.length;

      if (currentLength < targetLength) {
        return [].concat(component_toConsumableArray(currentModels), component_toConsumableArray(targetModels.slice(currentLength, targetLength)));
      }

      if (currentLength > targetLength) {
        return currentModels.slice(0, targetLength);
      }

      return models;
    }
  }, {
    key: "getCurrentModelWithDifferentModel",
    value: function getCurrentModelWithDifferentModel(models, currentModels, targetModels, modelNames, targetNames) {
      var currentLength = currentModels.length;
      var targetLength = targetModels.length;

      if (currentLength > targetLength) {
        var newModels = models.filter(function (_ref4) {
          var name = _ref4.name;
          return includes(targetNames, name);
        });
        return newModels.length !== targetModels.length ? targetModels : newModels;
      }

      if (currentLength < targetLength) {
        var notIncludedModels = targetModels.reduce(function (acc, cur, idx) {
          var notIncluded = !includes(modelNames, cur.name);
          return notIncluded ? {
            models: [].concat(component_toConsumableArray(acc.models), [cur]),
            modelIdx: [].concat(component_toConsumableArray(acc.modelIdx), [idx])
          } : acc;
        }, {
          models: [],
          modelIdx: []
        });

        if (models.length + notIncludedModels.models.length === targetLength) {
          var _newModels = component_toConsumableArray(models);

          notIncludedModels.models.forEach(function (model, idx) {
            _newModels.splice(notIncludedModels.modelIdx[idx], 0, model);
          });
          return _newModels;
        }

        return targetModels;
      }

      return models;
    }
  }, {
    key: "syncModels",
    value: function syncModels(currentModels, targetModels, type) {
      var drawModels = type ? this.drawModels[type] : this.drawModels;
      var model = this.getCurrentModelToMatchTargetModel(drawModels, currentModels, targetModels);

      if (type) {
        this.drawModels[type] = model;
      } else {
        this.drawModels = model;
      }
    }
  }, {
    key: "getSelectableOption",
    value: function getSelectableOption(options) {
      var _options$series$selec, _options$series;

      return (_options$series$selec = options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : _options$series.selectable) !== null && _options$series$selec !== void 0 ? _options$series$selec : false;
    }
  }, {
    key: "renderDataLabels",
    value: function renderDataLabels(data, name) {
      var _this4 = this;

      setTimeout(function () {
        _this4.eventBus.emit('renderDataLabels', {
          data: data,
          name: name !== null && name !== void 0 ? name : _this4.name
        });
      }, 0);
    }
  }, {
    key: "draw",
    value: function draw(painter) {
      var models = this.drawModels ? this.drawModels : this.models;

      if (Array.isArray(models)) {
        painter.paintForEach(models);
      } else if (models) {
        Object.keys(models).forEach(function (item) {
          painter.paintForEach(models[item]);
        });
      }
    }
  }]);

  return Component;
}();


;// CONCATENATED MODULE: ./src/component/axis.ts
function axis_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { axis_typeof = function _typeof(obj) { return typeof obj; }; } else { axis_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return axis_typeof(obj); }

function axis_toConsumableArray(arr) { return axis_arrayWithoutHoles(arr) || axis_iterableToArray(arr) || axis_unsupportedIterableToArray(arr) || axis_nonIterableSpread(); }

function axis_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function axis_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return axis_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return axis_arrayLikeToArray(o, minLen); }

function axis_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function axis_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return axis_arrayLikeToArray(arr); }

function axis_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function axis_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function axis_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { axis_ownKeys(Object(source), true).forEach(function (key) { axis_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { axis_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }






















function axis_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function axis_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function axis_createClass(Constructor, protoProps, staticProps) { if (protoProps) axis_defineProperties(Constructor.prototype, protoProps); if (staticProps) axis_defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (axis_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function axis_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var AxisType;

(function (AxisType) {
  AxisType["X"] = "xAxis";
  AxisType["Y"] = "yAxis";
  AxisType["SECONDARY_Y"] = "secondaryYAxis";
  AxisType["CIRCULAR"] = "circularAxis";
  AxisType["VERTICAL"] = "verticalAxis";
})(AxisType || (AxisType = {}));

function getOffsetAndAnchorKey(hasBasedYAxis) {
  return {
    offsetKey: hasBasedYAxis ? 'y' : 'x',
    anchorKey: hasBasedYAxis ? 'x' : 'y'
  };
}

var Axis = /*#__PURE__*/function (_Component) {
  _inherits(Axis, _Component);

  var _super = _createSuper(Axis);

  function Axis() {
    var _this;

    axis_classCallCheck(this, Axis);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    axis_defineProperty(_assertThisInitialized(_this), "models", {
      label: [],
      tick: [],
      axisLine: []
    });

    axis_defineProperty(_assertThisInitialized(_this), "drawModels", void 0);

    axis_defineProperty(_assertThisInitialized(_this), "yAxisComponent", void 0);

    axis_defineProperty(_assertThisInitialized(_this), "theme", void 0);

    axis_defineProperty(_assertThisInitialized(_this), "axisSize", 0);

    return _this;
  }

  axis_createClass(Axis, [{
    key: "initialize",
    value: function initialize(_ref) {
      var name = _ref.name;
      this.type = 'axis';
      this.name = name;
      this.yAxisComponent = includes([AxisType.Y, AxisType.SECONDARY_Y], name);
    }
  }, {
    key: "render",
    value: function render(_ref2) {
      var _this2 = this;

      var layout = _ref2.layout,
          axes = _ref2.axes,
          theme = _ref2.theme,
          scale = _ref2.scale;

      if (axes.centerYAxis || !axes[this.name]) {
        return;
      }

      this.theme = getAxisTheme(theme, this.name);
      this.rect = layout[this.name];
      this.axisSize = this.yAxisComponent ? this.rect.height : this.rect.width;
      var viewLabels = axes[this.name].viewLabels;

      var _getOffsetAndAnchorKe = getOffsetAndAnchorKey(this.yAxisComponent),
          offsetKey = _getOffsetAndAnchorKe.offsetKey,
          anchorKey = _getOffsetAndAnchorKe.anchorKey;

      var renderOptions = this.makeRenderOptions(axes[this.name], scale === null || scale === void 0 ? void 0 : scale[this.name]);
      var hasOnlyAxisLine = this.hasOnlyAxisLine();

      if (!hasOnlyAxisLine) {
        this.models.label = this.renderLabelModels(viewLabels, offsetKey, anchorKey, renderOptions);
        this.models.tick = this.renderTickModels(offsetKey, anchorKey, renderOptions);
      }

      this.models.axisLine = [this.renderAxisLineModel()];

      if (!this.drawModels) {
        this.drawModels = {
          tick: [],
          label: [],
          axisLine: this.models.axisLine
        };
        ['tick', 'label'].forEach(function (type) {
          _this2.drawModels[type] = _this2.models[type].map(function (m) {
            var drawModel = axis_objectSpread({}, m);

            if (_this2.yAxisComponent) {
              drawModel.y = 0;
            } else {
              drawModel.x = 0;
            }

            return drawModel;
          });
        });
      }
    }
  }, {
    key: "renderAxisLineModel",
    value: function renderAxisLineModel() {
      var zeroPixel = crispPixel(0);
      var lineModel;
      var _this$theme = this.theme,
          strokeStyle = _this$theme.color,
          lineWidth = _this$theme.width;

      if (this.yAxisComponent) {
        var x = this.getYAxisXPoint();
        lineModel = {
          type: 'line',
          x: x,
          y: zeroPixel,
          x2: x,
          y2: crispPixel(this.axisSize),
          strokeStyle: strokeStyle,
          lineWidth: lineWidth
        };
      } else {
        lineModel = {
          type: 'line',
          x: zeroPixel,
          y: zeroPixel,
          x2: crispPixel(this.axisSize),
          y2: zeroPixel,
          strokeStyle: strokeStyle,
          lineWidth: lineWidth
        };
      }

      return lineModel;
    }
  }, {
    key: "renderTickModels",
    value: function renderTickModels(offsetKey, anchorKey, renderOptions) {
      var _this3 = this;

      var tickAnchorPoint = this.yAxisComponent ? this.getYAxisXPoint() : crispPixel(0);
      var tickInterval = renderOptions.tickInterval,
          relativePositions = renderOptions.relativePositions;
      var tickSize = includes([AxisType.SECONDARY_Y, AxisType.X], this.name) ? TICK_SIZE : -TICK_SIZE;
      return relativePositions.reduce(function (positions, position, index) {
        var _ref3;

        return index % tickInterval ? positions : [].concat(axis_toConsumableArray(positions), [(_ref3 = {
          type: 'tick',
          isYAxis: _this3.yAxisComponent,
          tickSize: tickSize
        }, axis_defineProperty(_ref3, offsetKey, crispPixel(position)), axis_defineProperty(_ref3, anchorKey, tickAnchorPoint), axis_defineProperty(_ref3, "strokeStyle", _this3.theme.color), axis_defineProperty(_ref3, "lineWidth", _this3.theme.width), _ref3)]);
      }, []);
    }
  }, {
    key: "renderLabelModels",
    value: function renderLabelModels(labels, offsetKey, anchorKey, renderOptions) {
      var needRotateLabel = renderOptions.needRotateLabel,
          radian = renderOptions.radian,
          offsetY = renderOptions.offsetY;
      var labelTheme = this.theme.label;
      var font = getTitleFontString(labelTheme);
      var textAlign = this.getLabelTextAlign(needRotateLabel);
      var style = ['default', {
        textAlign: textAlign,
        font: font,
        fillStyle: labelTheme.color
      }];
      var labelAnchorPoint = this.yAxisComponent ? this.getYAxisAnchorPoint() : offsetY;
      return labels.map(function (_ref4) {
        var _ref5;

        var text = _ref4.text,
            offsetPos = _ref4.offsetPos;
        return _ref5 = {
          type: 'label',
          text: text,
          style: style,
          radian: radian
        }, axis_defineProperty(_ref5, offsetKey, crispPixel(offsetPos)), axis_defineProperty(_ref5, anchorKey, labelAnchorPoint), _ref5;
      });
    }
  }, {
    key: "makeRenderOptions",
    value: function makeRenderOptions(axisData, scale) {
      var _scale$sizeRatio, _scale$positionRatio;

      var tickCount = axisData.tickCount,
          tickInterval = axisData.tickInterval;
      var sizeRatio = (_scale$sizeRatio = scale === null || scale === void 0 ? void 0 : scale.sizeRatio) !== null && _scale$sizeRatio !== void 0 ? _scale$sizeRatio : 1;
      var positionRatio = (_scale$positionRatio = scale === null || scale === void 0 ? void 0 : scale.positionRatio) !== null && _scale$positionRatio !== void 0 ? _scale$positionRatio : 0;
      var relativePositions = makeTickPixelPositions(this.axisSize * sizeRatio, tickCount, this.axisSize * positionRatio);

      if (this.yAxisComponent) {
        return {
          relativePositions: relativePositions,
          tickInterval: tickInterval
        };
      }

      var needRotateLabel = axisData.needRotateLabel,
          radian = axisData.radian,
          offsetY = axisData.offsetY;
      return {
        relativePositions: relativePositions,
        tickInterval: tickInterval,
        needRotateLabel: needRotateLabel,
        radian: radian,
        offsetY: offsetY
      };
    }
  }, {
    key: "getYAxisAnchorPoint",
    value: function getYAxisAnchorPoint() {
      return this.isRightSide() ? crispPixel(this.rect.width) : crispPixel(0);
    }
  }, {
    key: "getLabelTextAlign",
    value: function getLabelTextAlign(needRotateLabel) {
      var yAxisTextAlign = this.isRightSide() ? 'right' : 'left';
      var xAxisTextAlign = needRotateLabel ? 'left' : 'center';
      return this.yAxisComponent ? yAxisTextAlign : xAxisTextAlign;
    }
  }, {
    key: "isRightSide",
    value: function isRightSide() {
      return this.name === AxisType.SECONDARY_Y;
    }
  }, {
    key: "getYAxisXPoint",
    value: function getYAxisXPoint() {
      return this.isRightSide() ? crispPixel(0) : crispPixel(this.rect.width);
    }
  }, {
    key: "hasOnlyAxisLine",
    value: function hasOnlyAxisLine() {
      return this.yAxisComponent && !this.rect.width || this.name === AxisType.X && !this.rect.height;
    }
  }]);

  return Axis;
}(Component);


;// CONCATENATED MODULE: ./src/helpers/geometric.ts
var RAD = Math.PI / 180;
var ANGLE_90 = 90;
var ANGLE_CANDIDATES = [0, 25, 45, 65, 85, 90];
/**
 * Calculate adjacent.
 *
 *   H : Hypotenuse
 *   A : Adjacent
 *   O : Opposite
 *   D : Degree
 *
 *        /|
 *       / |
 *    H /  | O
 *     /   |
 *    /\ D |
 *    -----
 *       A
 */

function calculateAdjacent(degree, hypotenuse) {
  return Math.cos(degree * RAD) * hypotenuse;
}

function calculateOpposite(degree, hypotenuse) {
  return Math.sin(degree * RAD) * hypotenuse;
}

function calculateRotatedWidth(degree, width, height) {
  var centerHalf = calculateAdjacent(degree, width / 2);
  var sideHalf = calculateAdjacent(ANGLE_90 - degree, height / 2);
  return (centerHalf + sideHalf) * 2;
}
function calculateRotatedHeight(degree, width, height) {
  var centerHalf = calculateOpposite(degree, width / 2);
  var sideHalf = calculateOpposite(ANGLE_90 - degree, height / 2);
  return (centerHalf + sideHalf) * 2;
}
;// CONCATENATED MODULE: ./src/helpers/formatDate.ts



// https://github.com/nhn/tui.code-snippet/blob/master/formatDate/formatDate.js

var DEFAULT_DATE_FORMAT = 'YY-MM-DD hh:mm:ss';
function getDateFormat(date) {
  if (!date) {
    return;
  }

  return isObject(date) ? date.format : DEFAULT_DATE_FORMAT;
}
var tokens = /[\\]*YYYY|[\\]*YY|[\\]*MMMM|[\\]*MMM|[\\]*MM|[\\]*M|[\\]*DD|[\\]*D|[\\]*HH|[\\]*H|[\\]*mm|[\\]*m|[\\]*ss|[\\]*s|[\\]*A/gi;
var MONTH_STR = ['Invalid month', 'January', 'February', 'March', 'April', 'May', 'Jun', 'Jul', 'August', 'September', 'October', 'November', 'December'];
var MONTH_DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var replaceMap = {
  M: function M(date) {
    return Number(date.month);
  },
  MM: function MM(date) {
    var month = date.month;
    return Number(month) < 10 ? "0".concat(month) : month;
  },
  MMM: function MMM(date) {
    return MONTH_STR[Number(date.month)].substr(0, 3);
  },
  MMMM: function MMMM(date) {
    return MONTH_STR[Number(date.month)];
  },
  D: function D(date) {
    return Number(date.date);
  },
  d: function d(date) {
    return replaceMap.D(date);
  },
  // eslint-disable-line new-cap
  DD: function DD(date) {
    var dayInMonth = date.date;
    return Number(dayInMonth) < 10 ? "0".concat(dayInMonth) : dayInMonth;
  },
  dd: function dd(date) {
    return replaceMap.DD(date);
  },
  // eslint-disable-line new-cap
  YY: function YY(date) {
    return Number(date.year) % 100;
  },
  yy: function yy(date) {
    return replaceMap.YY(date);
  },
  // eslint-disable-line new-cap
  YYYY: function YYYY(date) {
    var prefix = '20';
    var year = date.year;

    if (year > 69 && year < 100) {
      prefix = '19';
    }

    return Number(year) < 100 ? prefix + String(year) : year;
  },
  yyyy: function yyyy(date) {
    return replaceMap.YYYY(date);
  },
  // eslint-disable-line new-cap
  A: function A(date) {
    return date.meridiem;
  },
  a: function a(date) {
    return date.meridiem;
  },
  hh: function hh(date) {
    var hour = date.hour;
    return Number(hour) < 10 ? '0' + hour : hour;
  },
  HH: function HH(date) {
    return replaceMap.hh(date);
  },
  h: function h(date) {
    return String(Number(date.hour));
  },
  H: function H(date) {
    return replaceMap.h(date);
  },
  m: function m(date) {
    return String(Number(date.minute));
  },
  mm: function mm(date) {
    var minute = date.minute;
    return Number(minute) < 10 ? "0".concat(minute) : minute;
  },
  s: function s(date) {
    return String(Number(date.second));
  },
  ss: function ss(date) {
    var second = date.second;
    return Number(second) < 10 ? "0".concat(second) : second;
  }
};

function isLeapYear(month, year) {
  return month === 2 && year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}

function isValidDate(y, m, d) {
  var year = Number(y);
  var month = Number(m);
  var date = Number(d);
  var isValidYear = year > -1 && year < 100 || year > 1969 && year < 2070;
  var isValidMonth = month > 0 && month < 13;

  if (!isValidYear || !isValidMonth) {
    return false;
  }

  var lastDayInMonth = isLeapYear(month, year) ? 29 : MONTH_DAYS[month];
  return date > 0 && date <= lastDayInMonth;
}
/*
 * key             | Shorthand
 * --------------- |-----------------------
 * years           | YY / YYYY / yy / yyyy
 * months(n)       | M / MM
 * months(str)     | MMM / MMMM
 * days            | D / DD / d / dd
 * hours           | H / HH / h / hh
 * minutes         | m / mm
 * seconds         | s / ss
 * meridiem(AM,PM) | A / a
 */


function formatDate(form, date, option) {
  var _option$meridiemSet$A;

  var am = (_option$meridiemSet$A = option === null || option === void 0 ? void 0 : option.meridiemSet.AM) !== null && _option$meridiemSet$A !== void 0 ? _option$meridiemSet$A : 'AM';
  var pm = (option === null || option === void 0 ? void 0 : option.meridiemSet.PM) || 'PM';
  var nDate;

  if (isDate(date)) {
    nDate = {
      year: date.getFullYear(),
      month: date.getMonth() + 1,
      date: date.getDate(),
      hour: date.getHours(),
      minute: date.getMinutes(),
      second: date.getSeconds()
    };
  } else {
    var year = date.year,
        month = date.month,
        hour = date.hour,
        minute = date.minute,
        second = date.second;
    nDate = {
      year: year,
      month: month,
      date: date.date,
      hour: hour,
      minute: minute,
      second: second
    };
  }

  if (!isValidDate(nDate.year, nDate.month, nDate.date)) {
    return '';
  }

  nDate.meridiem = '';

  if (/([^\\]|^)[aA]\b/.test(form)) {
    if (nDate.hour > 12) {
      // See the clock system: https://en.wikipedia.org/wiki/12-hour_clock
      nDate.hour %= 12;
    }

    if (nDate.hour === 0) {
      nDate.hour = 12;
    }

    nDate.meridiem = nDate.hour > 11 ? pm : am;
  }

  return form.replace(tokens, function (key) {
    if (key.indexOf('\\') > -1) {
      // escape character
      return key.replace(/\\/, '');
    }

    return replaceMap[key](nDate) || '';
  });
}
;// CONCATENATED MODULE: ./src/helpers/pieSeries.ts








var semiCircleCenterYRatio = {
  COUNTER_CLOCKWISE: 0.1,
  CLOCKWISE: 1
};
function hasClockwiseSemiCircle(clockwise, startAngle, endAngle) {
  return clockwise && (startAngle >= DEGREE_NEGATIVE_90 && endAngle <= DEGREE_90 || startAngle >= DEGREE_90 && endAngle <= DEGREE_180);
}
function hasCounterClockwiseSemiCircle(clockwise, startAngle, endAngle) {
  return !clockwise && (startAngle >= DEGREE_NEGATIVE_180 && endAngle <= DEGREE_90 || startAngle <= DEGREE_90 && endAngle >= DEGREE_NEGATIVE_90);
}
function getRadius(defaultRadius, radius) {
  return isString(radius) ? Number((defaultRadius * getPercentageValue(radius) / 100).toFixed(2)) : radius;
}
function getTotalAngle(clockwise, startAngle, endAngle) {
  var diffAngle = endAngle - startAngle;
  var absDiff = Math.abs(diffAngle);
  var needSubstractAngle = diffAngle > DEGREE_0 && absDiff !== DEGREE_360 && !clockwise || diffAngle < DEGREE_0 && absDiff !== DEGREE_360 && clockwise;
  return needSubstractAngle ? DEGREE_360 - absDiff : absDiff;
}
function isSemiCircle(clockwise, startAngle, endAngle) {
  return getTotalAngle(clockwise, startAngle, endAngle) <= DEGREE_180 && (hasClockwiseSemiCircle(clockwise, startAngle, endAngle) || hasCounterClockwiseSemiCircle(clockwise, startAngle, endAngle));
}
function getSemiCircleCenterY(rectHeight, clockwise) {
  return clockwise ? rectHeight * semiCircleCenterYRatio.CLOCKWISE : rectHeight * semiCircleCenterYRatio.COUNTER_CLOCKWISE;
}
function makePieTooltipData(seriesRawData) {
  var category = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  return seriesRawData.filter(function (_ref) {
    var data = _ref.data;
    return !isNull(data);
  }).map(function (_ref2) {
    var data = _ref2.data,
        name = _ref2.name,
        color = _ref2.color,
        rootParentName = _ref2.rootParentName;
    return {
      label: name,
      color: color,
      value: data,
      category: category,
      rootParentName: rootParentName,
      templateType: 'pie'
    };
  });
}
function hasNestedPieSeries(series) {
  var _series$pie$;

  return !!(series.pie && Array.isArray((_series$pie$ = series.pie[0]) === null || _series$pie$ === void 0 ? void 0 : _series$pie$.data));
}
function getNestedPieChartAliasNames(series) {
  return series.pie.map(function (_ref3) {
    var name = _ref3.name;
    return name;
  });
}
function pieTooltipLabelFormatter(percentValue) {
  var percentageString = percentValue.toFixed(2);
  var percent = parseFloat(percentageString);
  var needSlice = percentageString.length > 5;
  return "".concat(needSlice ? parseFloat(percentageString.substr(0, 4)) : String(percent), "%");
}
function hasOuterDataLabel(options, series) {
  var _options$series, _options$series$dataL;

  return !!series.pie && (options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : (_options$series$dataL = _options$series.dataLabels) === null || _options$series$dataL === void 0 ? void 0 : _options$series$dataL.anchor) === 'outer';
}
function hasOuterPieSeriesName(options, series) {
  var _options$series2, _options$series2$data, _options$series2$data2;

  return !!series.pie && (options === null || options === void 0 ? void 0 : (_options$series2 = options.series) === null || _options$series2 === void 0 ? void 0 : (_options$series2$data = _options$series2.dataLabels) === null || _options$series2$data === void 0 ? void 0 : (_options$series2$data2 = _options$series2$data.pieSeriesName) === null || _options$series2$data2 === void 0 ? void 0 : _options$series2$data2.anchor) === 'outer';
}
;// CONCATENATED MODULE: ./src/store/radialAxes.ts





var Y_LABEL_PADDING = 5;
var RADIAL_LABEL_PADDING = 25;
var RadialAxisType;

(function (RadialAxisType) {
  RadialAxisType["CIRCULAR"] = "circularAxis";
  RadialAxisType["VERTICAL"] = "verticalAxis";
})(RadialAxisType || (RadialAxisType = {}));

function getYAxisLabelAlign() {
  var clockwise = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
  var isLabelOnVerticalAxis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var align = 'center';

  if (isLabelOnVerticalAxis) {
    align = clockwise ? 'right' : 'left';
  }

  return align;
}

function getVerticalAxisData(_ref) {
  var labels = _ref.labels,
      pointOnColumn = _ref.pointOnColumn,
      intervalData = _ref.intervalData,
      isLabelOnVerticalAxis = _ref.isLabelOnVerticalAxis,
      verticalAxisLabelMargin = _ref.verticalAxisLabelMargin,
      verticalAxisLabelFont = _ref.verticalAxisLabelFont,
      defaultAxisData = _ref.defaultAxisData,
      radiusData = _ref.radiusData;
  var clockwise = defaultAxisData.clockwise,
      axisSize = defaultAxisData.axisSize,
      centerX = defaultAxisData.centerX,
      centerY = defaultAxisData.centerY,
      startAngle = defaultAxisData.startAngle,
      endAngle = defaultAxisData.endAngle;
  var radiusRanges = radiusData.radiusRanges,
      innerRadius = radiusData.innerRadius,
      outerRadius = radiusData.outerRadius;
  var labelInterval = intervalData.labelInterval;
  /*
  return {
    labels,
    tickDistance: (outerRadius - innerRadius) / labels.length,
    ...pick(defaultAxisData, 'axisSize', 'centerX', 'centerY', 'startAngle', 'endAngle'),
    pointOnColumn,
    radiusRanges,
    innerRadius,
    outerRadius,
    labelInterval,
    labelMargin: verticalAxisLabelMargin,
    labelAlign: getYAxisLabelAlign(clockwise, isLabelOnVerticalAxis),
    ...getMaxLabelSize(labels, verticalAxisLabelMargin, verticalAxisLabelFont),
  };
  */

  var _getMaxLabelSize = getMaxLabelSize(labels, verticalAxisLabelMargin, verticalAxisLabelFont),
      maxLabelWidth = _getMaxLabelSize.maxLabelWidth,
      maxLabelHeight = _getMaxLabelSize.maxLabelHeight;

  return {
    axisSize: axisSize,
    centerX: centerX,
    centerY: centerY,
    label: {
      labels: labels,
      interval: labelInterval,
      margin: verticalAxisLabelMargin,
      maxWidth: maxLabelWidth,
      maxHeight: maxLabelHeight,
      align: getYAxisLabelAlign(clockwise, isLabelOnVerticalAxis)
    },
    radius: {
      inner: innerRadius,
      outer: outerRadius,
      ranges: radiusRanges
    },
    angle: {
      start: startAngle,
      end: endAngle
    },
    tickDistance: (outerRadius - innerRadius) / labels.length,
    pointOnColumn: pointOnColumn
  };
}

function getCircularAxisData(_ref2) {
  var labels = _ref2.labels,
      intervalData = _ref2.intervalData,
      circularAxisLabelMargin = _ref2.circularAxisLabelMargin,
      circularAxisLabelFont = _ref2.circularAxisLabelFont,
      defaultAxisData = _ref2.defaultAxisData,
      radiusData = _ref2.radiusData;

  var _getMaxLabelSize2 = getMaxLabelSize(labels, circularAxisLabelMargin, circularAxisLabelFont),
      maxLabelWidth = _getMaxLabelSize2.maxLabelWidth,
      maxLabelHeight = _getMaxLabelSize2.maxLabelHeight;

  var totalAngle = defaultAxisData.totalAngle,
      clockwise = defaultAxisData.clockwise,
      axisSize = defaultAxisData.axisSize,
      centerX = defaultAxisData.centerX,
      centerY = defaultAxisData.centerY,
      startAngle = defaultAxisData.startAngle,
      endAngle = defaultAxisData.endAngle,
      drawingStartAngle = defaultAxisData.drawingStartAngle;
  var tickInterval = intervalData.tickInterval,
      labelInterval = intervalData.labelInterval;
  var innerRadius = radiusData.innerRadius,
      outerRadius = radiusData.outerRadius;
  var centralAngle = totalAngle / (labels.length + (totalAngle < DEGREE_360 ? -1 : DEGREE_0));
  /*
  return {
    labels,
    ...defaultAxisData,
    centralAngle,
    tickInterval,
    labelInterval,
    labelMargin: circularAxisLabelMargin,
    maxLabelWidth,
    maxLabelHeight,
    innerRadius,
    outerRadius,
  };
  */

  return {
    axisSize: axisSize,
    centerX: centerX,
    centerY: centerY,
    label: {
      labels: labels,
      interval: labelInterval,
      margin: circularAxisLabelMargin,
      maxWidth: maxLabelWidth,
      maxHeight: maxLabelHeight
    },
    radius: {
      inner: innerRadius,
      outer: outerRadius
    },
    angle: {
      start: startAngle,
      end: endAngle,
      total: totalAngle,
      central: centralAngle,
      drawingStart: drawingStartAngle
    },
    tickInterval: tickInterval,
    clockwise: clockwise
  };
}

function makeLabels(options, rawLabels, axisName) {
  var _options$axisName$lab, _options$axisName, _options$axisName$lab2;

  var formatter = (_options$axisName$lab = (_options$axisName = options[axisName]) === null || _options$axisName === void 0 ? void 0 : (_options$axisName$lab2 = _options$axisName.label) === null || _options$axisName$lab2 === void 0 ? void 0 : _options$axisName$lab2.formatter) !== null && _options$axisName$lab !== void 0 ? _options$axisName$lab : function (value) {
    return value;
  };
  return rawLabels.map(function (label, index) {
    return formatter(label, {
      index: index,
      labels: rawLabels,
      axisName: axisName
    });
  });
}

function getAxisLabels(isLabelOnVerticalAxis, options, categories, scale) {
  var valueAxisName = isLabelOnVerticalAxis ? RadialAxisType.CIRCULAR : RadialAxisType.VERTICAL;
  var _ref3 = scale[valueAxisName],
      limit = _ref3.limit,
      stepSize = _ref3.stepSize;
  var valueLabels = makeLabels(options, makeLabelsFromLimit(limit, stepSize), valueAxisName);
  var categoryLabels = makeLabels(options, categories, isLabelOnVerticalAxis ? RadialAxisType.VERTICAL : RadialAxisType.CIRCULAR);
  return {
    radialAxisLabels: isLabelOnVerticalAxis ? valueLabels : categoryLabels,
    yAxisLabels: isLabelOnVerticalAxis ? categoryLabels : valueLabels
  };
}

function getAxisLabelMargin(isLabelOnVerticalAxis, options) {
  var _verticalAxis$label$m, _verticalAxis, _verticalAxis$label, _options$circularAxis, _options$circularAxis2, _options$circularAxis3;

  return {
    verticalAxisLabelMargin: (_verticalAxis$label$m = options === null || options === void 0 ? void 0 : (_verticalAxis = options.verticalAxis) === null || _verticalAxis === void 0 ? void 0 : (_verticalAxis$label = _verticalAxis.label) === null || _verticalAxis$label === void 0 ? void 0 : _verticalAxis$label.margin) !== null && _verticalAxis$label$m !== void 0 ? _verticalAxis$label$m : isLabelOnVerticalAxis ? Y_LABEL_PADDING : 0,
    circularAxisLabelMargin: (_options$circularAxis = options === null || options === void 0 ? void 0 : (_options$circularAxis2 = options.circularAxis) === null || _options$circularAxis2 === void 0 ? void 0 : (_options$circularAxis3 = _options$circularAxis2.label) === null || _options$circularAxis3 === void 0 ? void 0 : _options$circularAxis3.margin) !== null && _options$circularAxis !== void 0 ? _options$circularAxis : RADIAL_LABEL_PADDING
  };
}

var axes = {
  name: 'radialAxes',
  state: function state() {
    return {
      radialAxes: {}
    };
  },
  action: {
    setRadialAxesData: function setRadialAxesData(_ref4) {
      var _options$series;

      var state = _ref4.state;
      var series = state.series,
          layout = state.layout,
          scale = state.scale;
      var categories = state.categories;
      var plot = layout.plot;
      var isLabelOnVerticalAxis = isLabelAxisOnYAxis({
        series: series,
        categories: categories
      });
      var options = state.options;
      var theme = state.theme;
      var circularAxisLabelFont = getTitleFontString(theme.circularAxis.label);
      var verticalAxisLabelFont = getTitleFontString(theme.verticalAxis.label);

      var _getAxisLabelMargin = getAxisLabelMargin(isLabelOnVerticalAxis, options),
          verticalAxisLabelMargin = _getAxisLabelMargin.verticalAxisLabelMargin,
          circularAxisLabelMargin = _getAxisLabelMargin.circularAxisLabelMargin;

      var _getAxisLabels = getAxisLabels(isLabelOnVerticalAxis, options, categories, scale),
          radialAxisLabels = _getAxisLabels.radialAxisLabels,
          yAxisLabels = _getAxisLabels.yAxisLabels;

      var _getMaxLabelSize3 = getMaxLabelSize(radialAxisLabels, circularAxisLabelMargin, circularAxisLabelFont),
          maxLabelWidth = _getMaxLabelSize3.maxLabelWidth,
          maxLabelHeight = _getMaxLabelSize3.maxLabelHeight;

      var defaultAxisData = getDefaultRadialAxisData(options, plot, maxLabelWidth, maxLabelHeight + circularAxisLabelMargin, isLabelOnVerticalAxis);
      var axisSize = defaultAxisData.axisSize;
      var radiusData = isLabelOnVerticalAxis ? getRadiusInfo(axisSize, options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : _options$series.radiusRange, yAxisLabels.length + 1) : {
        radiusRanges: makeTickPixelPositions(axisSize, yAxisLabels.length),
        innerRadius: 0,
        outerRadius: axisSize
      };
      var verticalAxisData = getVerticalAxisData({
        labels: yAxisLabels,
        pointOnColumn: isLabelOnVerticalAxis,
        isLabelOnVerticalAxis: isLabelOnVerticalAxis,
        intervalData: getInitAxisIntervalData(isLabelOnVerticalAxis, {
          axis: options.verticalAxis,
          categories: categories,
          layout: layout
        }),
        verticalAxisLabelMargin: verticalAxisLabelMargin,
        verticalAxisLabelFont: verticalAxisLabelFont,
        defaultAxisData: defaultAxisData,
        radiusData: radiusData
      });
      state.radialAxes = {
        circularAxis: getCircularAxisData({
          labels: radialAxisLabels,
          intervalData: getInitAxisIntervalData(true, {
            axis: options.circularAxis,
            categories: categories,
            layout: layout
          }),
          defaultAxisData: defaultAxisData,
          circularAxisLabelMargin: circularAxisLabelMargin,
          circularAxisLabelFont: circularAxisLabelFont,
          radiusData: radiusData
        }),
        verticalAxis: verticalAxisData
      };
    }
  },
  observe: {
    updateRadialAxes: function updateRadialAxes() {
      this.dispatch('setRadialAxesData');
    }
  }
};
/* harmony default export */ var radialAxes = (axes);
;// CONCATENATED MODULE: ./src/helpers/axes.ts
function axes_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function axes_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { axes_ownKeys(Object(source), true).forEach(function (key) { axes_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { axes_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function axes_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function axes_toConsumableArray(arr) { return axes_arrayWithoutHoles(arr) || axes_iterableToArray(arr) || axes_unsupportedIterableToArray(arr) || axes_nonIterableSpread(); }

function axes_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function axes_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return axes_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return axes_arrayLikeToArray(o, minLen); }

function axes_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function axes_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return axes_arrayLikeToArray(arr); }

function axes_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }






























function makeAdjustingIntervalInfo(blockCount, axisWidth, blockSize) {
  var remainBlockCount;
  var newBlockCount = Math.floor(axisWidth / blockSize);
  var intervalInfo = null;
  var interval = newBlockCount ? Math.floor(blockCount / newBlockCount) : blockCount;

  if (interval > 1) {
    // remainBlockCount : remaining block count after filling new blocks
    // | | | | | | | | | | | |  - previous block interval
    // |     |     |     |      - new block interval
    //                   |*|*|  - remaining block
    remainBlockCount = blockCount - interval * newBlockCount;

    if (remainBlockCount >= interval) {
      newBlockCount += Math.floor(remainBlockCount / interval);
      remainBlockCount = remainBlockCount % interval;
    }

    intervalInfo = {
      blockCount: newBlockCount,
      remainBlockCount: remainBlockCount,
      interval: interval
    };
  }

  return intervalInfo;
}

function getAutoAdjustingInterval(count, axisWidth, categories) {
  var autoInterval = {
    MIN_WIDTH: 90,
    MAX_WIDTH: 121,
    STEP_SIZE: 5
  };
  var LABEL_MARGIN = 5;

  if (categories !== null && categories !== void 0 && categories[0]) {
    var categoryMinWidth = getTextWidth(categories[0]);

    if (categoryMinWidth < axisWidth / count - LABEL_MARGIN) {
      return 1;
    }
  }

  var candidates = [];
  divisors(count).forEach(function (interval) {
    var intervalWidth = interval / count * axisWidth;

    if (intervalWidth >= autoInterval.MIN_WIDTH && intervalWidth <= autoInterval.MAX_WIDTH) {
      candidates.push({
        interval: interval,
        blockCount: Math.floor(count / interval),
        remainBlockCount: 0
      });
    }
  });

  if (!candidates.length) {
    var blockSizeRange = range(autoInterval.MIN_WIDTH, autoInterval.MAX_WIDTH, autoInterval.STEP_SIZE);
    candidates = blockSizeRange.reduce(function (acc, blockSize) {
      var candidate = makeAdjustingIntervalInfo(count, axisWidth, blockSize);
      return candidate ? [].concat(axes_toConsumableArray(acc), [candidate]) : acc;
    }, []);
  }

  var tickInterval = 1;

  if (candidates.length) {
    var candidate = candidates.reduce(function (acc, cur) {
      return cur.blockCount > acc.blockCount ? cur : acc;
    }, {
      blockCount: 0,
      interval: 1
    });
    tickInterval = candidate.interval;
  }

  return tickInterval;
}
function isLabelAxisOnYAxis(_ref) {
  var _series;

  var series = _ref.series,
      options = _ref.options,
      categories = _ref.categories;
  return !!series.bar || !!series.radialBar || !!series.gauge && Array.isArray(categories) && !categories.length || !!series.bullet && !(options !== null && options !== void 0 && (_series = options.series) !== null && _series !== void 0 && _series.vertical);
}
function hasBoxTypeSeries(series) {
  return !!series.column || !!series.bar || !!series.boxPlot || !!series.bullet;
}
function isPointOnColumn(series, options) {
  if (hasBoxTypeSeries(series)) {
    return true;
  }

  if (series.line || series.area) {
    var _options$xAxis;

    return Boolean((_options$xAxis = options.xAxis) === null || _options$xAxis === void 0 ? void 0 : _options$xAxis.pointOnColumn);
  }

  return false;
}
function isSeriesUsingRadialAxes(series) {
  return !!series.radar || !!series.radialBar || !!series.gauge;
}

function getAxisNameUsingRadialAxes(labelAxisOnYAxis) {
  return {
    valueAxisName: labelAxisOnYAxis ? 'circularAxis' : 'verticalAxis',
    labelAxisName: labelAxisOnYAxis ? 'verticalAxis' : 'circularAxis'
  };
}

function getAxisName(labelAxisOnYAxis, series) {
  return isSeriesUsingRadialAxes(series) ? getAxisNameUsingRadialAxes(labelAxisOnYAxis) : {
    valueAxisName: labelAxisOnYAxis ? 'xAxis' : 'yAxis',
    labelAxisName: labelAxisOnYAxis ? 'yAxis' : 'xAxis'
  };
}
function getSizeKey(labelAxisOnYAxis) {
  return {
    valueSizeKey: labelAxisOnYAxis ? 'width' : 'height',
    labelSizeKey: labelAxisOnYAxis ? 'height' : 'width'
  };
}
function getLimitOnAxis(labels) {
  var values = labels.map(function (label) {
    return Number(label);
  });
  return {
    min: Math.min.apply(Math, axes_toConsumableArray(values)),
    max: Math.max.apply(Math, axes_toConsumableArray(values))
  };
}
function hasSecondaryYAxis(options) {
  return Array.isArray(options === null || options === void 0 ? void 0 : options.yAxis) && options.yAxis.length === 2;
}
function getYAxisOption(options) {
  var secondaryYAxis = hasSecondaryYAxis(options);
  return {
    yAxis: secondaryYAxis ? options.yAxis[0] : options === null || options === void 0 ? void 0 : options.yAxis,
    secondaryYAxis: secondaryYAxis ? options.yAxis[1] : null
  };
}
function getValueAxisName(options, seriesName, valueAxisName) {
  var _getYAxisOption = getYAxisOption(options),
      secondaryYAxis = _getYAxisOption.secondaryYAxis;

  return (secondaryYAxis === null || secondaryYAxis === void 0 ? void 0 : secondaryYAxis.chartType) === seriesName ? 'secondaryYAxis' : valueAxisName;
}
function getValueAxisNames(options, valueAxisName) {
  if (includes([AxisType.X, AxisType.CIRCULAR, AxisType.VERTICAL], valueAxisName)) {
    return [valueAxisName];
  }

  var optionsUsingYAxis = options;

  var _getYAxisOption2 = getYAxisOption(optionsUsingYAxis),
      yAxis = _getYAxisOption2.yAxis,
      secondaryYAxis = _getYAxisOption2.secondaryYAxis;

  return secondaryYAxis ? [yAxis.chartType, secondaryYAxis.chartType].map(function (seriesName, index) {
    return seriesName ? getValueAxisName(optionsUsingYAxis, seriesName, valueAxisName) : ['yAxis', 'secondaryYAxis'][index];
  }) : [valueAxisName];
}
function getAxisTheme(theme, name) {
  var xAxis = theme.xAxis,
      yAxis = theme.yAxis,
      circularAxis = theme.circularAxis;
  var axisTheme;

  if (name === AxisType.X) {
    axisTheme = xAxis;
  } else if (Array.isArray(yAxis)) {
    axisTheme = name === AxisType.Y ? yAxis[0] : yAxis[1];
  } else if (name === RadialAxisType.CIRCULAR) {
    axisTheme = circularAxis;
  } else {
    axisTheme = yAxis;
  }

  return axisTheme;
}

function getRotationDegree(distance, labelWidth, labelHeight, axisLayout) {
  var degree = 0;
  ANGLE_CANDIDATES.every(function (angle) {
    var compareWidth = calculateRotatedWidth(angle, labelWidth, labelHeight);
    degree = angle;
    return compareWidth > distance || compareWidth / 2 > axisLayout.x;
  });
  return distance < labelWidth || labelWidth / 2 > axisLayout.x ? degree : 0;
}

function hasYAxisMaxLabelLengthChanged(previousAxes, currentAxes, field) {
  var prevYAxis = previousAxes[field];
  var yAxis = currentAxes[field];

  if (!prevYAxis && !yAxis) {
    return false;
  }

  return (prevYAxis === null || prevYAxis === void 0 ? void 0 : prevYAxis.maxLabelWidth) !== (yAxis === null || yAxis === void 0 ? void 0 : yAxis.maxLabelWidth);
}

function hasYAxisTypeMaxLabelChanged(previousAxes, currentAxes) {
  return hasYAxisMaxLabelLengthChanged(previousAxes, currentAxes, 'yAxis') || hasYAxisMaxLabelLengthChanged(previousAxes, currentAxes, 'secondaryYAxis');
}

function hasXAxisSizeChanged(previousAxes, currentAxes) {
  var prevMaxHeight = previousAxes.xAxis.maxHeight;
  var maxHeight = currentAxes.xAxis.maxHeight;
  return prevMaxHeight !== maxHeight;
}

function hasAxesLayoutChanged(previousAxes, currentAxes) {
  return hasYAxisTypeMaxLabelChanged(previousAxes, currentAxes) || hasXAxisSizeChanged(previousAxes, currentAxes);
}
function getRotatableOption(options) {
  var _options$xAxis$label$, _options$xAxis2, _options$xAxis2$label;

  return (_options$xAxis$label$ = options === null || options === void 0 ? void 0 : (_options$xAxis2 = options.xAxis) === null || _options$xAxis2 === void 0 ? void 0 : (_options$xAxis2$label = _options$xAxis2.label) === null || _options$xAxis2$label === void 0 ? void 0 : _options$xAxis2$label.rotatable) !== null && _options$xAxis$label$ !== void 0 ? _options$xAxis$label$ : true;
}
function getViewAxisLabels(axisData, axisSize) {
  var labels = axisData.labels,
      pointOnColumn = axisData.pointOnColumn,
      labelDistance = axisData.labelDistance,
      tickDistance = axisData.tickDistance,
      labelInterval = axisData.labelInterval,
      tickInterval = axisData.tickInterval,
      tickCount = axisData.tickCount,
      scale = axisData.scale;
  var axisSizeAppliedRatio = axisSize;
  var additional = 0;
  var labelAdjustment = 0;

  if (scale) {
    var _scale$sizeRatio, _scale$positionRatio;

    var sizeRatio = (_scale$sizeRatio = scale === null || scale === void 0 ? void 0 : scale.sizeRatio) !== null && _scale$sizeRatio !== void 0 ? _scale$sizeRatio : 1;
    var positionRatio = (_scale$positionRatio = scale === null || scale === void 0 ? void 0 : scale.positionRatio) !== null && _scale$positionRatio !== void 0 ? _scale$positionRatio : 0;
    axisSizeAppliedRatio = axisSize * sizeRatio;
    additional = axisSize * positionRatio;
  } else {
    var interval = labelInterval === tickInterval ? labelInterval : 1;
    labelAdjustment = pointOnColumn ? (labelDistance !== null && labelDistance !== void 0 ? labelDistance : tickDistance * interval) / 2 : 0;
  }

  var relativePositions = makeTickPixelPositions(axisSizeAppliedRatio, tickCount, additional);
  return labels.reduce(function (acc, text, index) {
    var offsetPos = relativePositions[index] + labelAdjustment;
    var needRender = !(index % labelInterval) && offsetPos <= axisSize;
    return needRender ? [].concat(axes_toConsumableArray(acc), [{
      offsetPos: offsetPos,
      text: text
    }]) : acc;
  }, []);
}
function makeTitleOption(title) {
  if (isUndefined(title)) {
    return title;
  }

  var defaultOption = {
    text: '',
    offsetX: 0,
    offsetY: 0
  };
  return utils_isString(title) ? axes_objectSpread(axes_objectSpread({}, defaultOption), {}, {
    text: title
  }) : axes_objectSpread(axes_objectSpread({}, defaultOption), title);
}
function getAxisFormatter(options, axisName) {
  var _axisOptions$axisName, _axisOptions$axisName2, _axisOptions$axisName3;

  var axisOptions = axes_objectSpread(axes_objectSpread({}, getYAxisOption(options)), {}, {
    xAxis: options.xAxis
  });

  return (_axisOptions$axisName = (_axisOptions$axisName2 = axisOptions[axisName]) === null || _axisOptions$axisName2 === void 0 ? void 0 : (_axisOptions$axisName3 = _axisOptions$axisName2.label) === null || _axisOptions$axisName3 === void 0 ? void 0 : _axisOptions$axisName3.formatter) !== null && _axisOptions$axisName !== void 0 ? _axisOptions$axisName : function (value) {
    return value;
  };
}
function getLabelsAppliedFormatter(labels, options, dateType, axisName) {
  var _options$axisName;

  var dateFormatter = getDateFormat(options === null || options === void 0 ? void 0 : (_options$axisName = options[axisName]) === null || _options$axisName === void 0 ? void 0 : _options$axisName.date);
  var formattedLabels = dateType && dateFormatter ? labels.map(function (label) {
    return formatDate(dateFormatter, new Date(label));
  }) : labels;
  var formatter = getAxisFormatter(options, axisName);
  return formattedLabels.map(function (label, index) {
    return formatter(label, {
      index: index,
      labels: labels,
      axisName: axisName
    });
  });
}
function makeRotationData(maxLabelWidth, maxLabelHeight, distance, rotatable, axisLayout) {
  var degree = getRotationDegree(distance, maxLabelWidth, maxLabelHeight, axisLayout);

  if (!rotatable || degree === 0) {
    return {
      needRotateLabel: false,
      radian: 0,
      rotationHeight: maxLabelHeight
    };
  }

  return {
    needRotateLabel: degree > 0,
    radian: calculateDegreeToRadian(degree, 0),
    rotationHeight: calculateRotatedHeight(degree, maxLabelWidth, maxLabelHeight)
  };
}
function getMaxLabelSize(labels, xMargin) {
  var font = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_LABEL_TEXT;
  var maxLengthLabel = labels.reduce(function (acc, cur) {
    return acc.length > cur.length ? acc : cur;
  }, '');
  return {
    maxLabelWidth: getTextWidth(maxLengthLabel, font) + xMargin,
    maxLabelHeight: getTextHeight(maxLengthLabel, font)
  };
}
function getLabelXMargin(axisName, options) {
  var _axisOptions$axisName4, _axisOptions$axisName5, _axisOptions$axisName6;

  if (axisName === 'xAxis') {
    return 0;
  }

  var axisOptions = getYAxisOption(options);
  return Math.abs((_axisOptions$axisName4 = axisOptions === null || axisOptions === void 0 ? void 0 : (_axisOptions$axisName5 = axisOptions[axisName]) === null || _axisOptions$axisName5 === void 0 ? void 0 : (_axisOptions$axisName6 = _axisOptions$axisName5.label) === null || _axisOptions$axisName6 === void 0 ? void 0 : _axisOptions$axisName6.margin) !== null && _axisOptions$axisName4 !== void 0 ? _axisOptions$axisName4 : 0);
}
function getInitAxisIntervalData(isLabelAxis, params) {
  var _axis$tick, _axis$label, _axis$scale;

  var axis = params.axis,
      categories = params.categories,
      layout = params.layout,
      isCoordinateTypeChart = params.isCoordinateTypeChart;
  var tickInterval = axis === null || axis === void 0 ? void 0 : (_axis$tick = axis.tick) === null || _axis$tick === void 0 ? void 0 : _axis$tick.interval;
  var labelInterval = axis === null || axis === void 0 ? void 0 : (_axis$label = axis.label) === null || _axis$label === void 0 ? void 0 : _axis$label.interval;
  var existIntervalOptions = isNumber(tickInterval) || isNumber(labelInterval);
  var needAdjustInterval = isLabelAxis && !isNumber(axis === null || axis === void 0 ? void 0 : (_axis$scale = axis.scale) === null || _axis$scale === void 0 ? void 0 : _axis$scale.stepSize) && !params.shift && !existIntervalOptions && !isCoordinateTypeChart;
  var initTickInterval = needAdjustInterval ? getInitTickInterval(categories, layout) : 1;
  var initLabelInterval = needAdjustInterval ? initTickInterval : 1;
  var axisData = {
    tickInterval: tickInterval !== null && tickInterval !== void 0 ? tickInterval : initTickInterval,
    labelInterval: labelInterval !== null && labelInterval !== void 0 ? labelInterval : initLabelInterval
  };
  return axisData;
}

function getInitTickInterval(categories, layout) {
  if (!categories || !layout) {
    return 1;
  }

  var width = layout.xAxis.width;
  var count = categories.length;
  return getAutoAdjustingInterval(count, width, categories);
}

function getDefaultRadialAxisData(options, plot) {
  var maxLabelWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var maxLabelHeight = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var isLabelOnVerticalAxis = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var centerX = plot.width / 2;

  if (isLabelOnVerticalAxis) {
    var _initSectorOptions = initSectorOptions(options === null || options === void 0 ? void 0 : options.series),
        startAngle = _initSectorOptions.startAngle,
        endAngle = _initSectorOptions.endAngle,
        clockwise = _initSectorOptions.clockwise;

    var isSemiCircular = isSemiCircle(clockwise, startAngle, endAngle);
    return {
      isSemiCircular: isSemiCircular,
      axisSize: getDefaultRadius(plot, isSemiCircular, maxLabelWidth, maxLabelHeight),
      centerX: centerX,
      centerY: isSemiCircular ? getSemiCircleCenterY(plot.height, clockwise) : plot.height / 2,
      totalAngle: getTotalAngle(clockwise, startAngle, endAngle),
      drawingStartAngle: startAngle,
      clockwise: clockwise,
      startAngle: startAngle,
      endAngle: endAngle
    };
  }

  return {
    isSemiCircular: false,
    axisSize: getDefaultRadius(plot, false, maxLabelWidth, maxLabelHeight),
    centerX: centerX,
    centerY: plot.height / 2,
    totalAngle: DEGREE_360,
    drawingStartAngle: DEGREE_0,
    clockwise: true,
    startAngle: DEGREE_0,
    endAngle: DEGREE_360
  };
}
function getRadiusInfo(axisSize, radiusRange) {
  var _radiusRange$inner, _radiusRange$outer;

  var count = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var innerRadius = calculateSizeWithPercentString(axisSize, (_radiusRange$inner = radiusRange === null || radiusRange === void 0 ? void 0 : radiusRange.inner) !== null && _radiusRange$inner !== void 0 ? _radiusRange$inner : 0);
  var outerRadius = calculateSizeWithPercentString(axisSize, (_radiusRange$outer = radiusRange === null || radiusRange === void 0 ? void 0 : radiusRange.outer) !== null && _radiusRange$outer !== void 0 ? _radiusRange$outer : axisSize);
  return {
    radiusRanges: makeTickPixelPositions(outerRadius - innerRadius, count, innerRadius).splice(innerRadius === 0 ? 1 : 0, count).reverse(),
    innerRadius: innerRadius,
    outerRadius: outerRadius
  };
}
function isDateType(options, axisName) {
  var _options$axisName2;

  return !!((_options$axisName2 = options[axisName]) !== null && _options$axisName2 !== void 0 && _options$axisName2.date);
}
;// CONCATENATED MODULE: ./src/helpers/coordinate.ts



function getCoordinateYValue(datum) {
  if (isNumber(datum)) {
    return datum;
  }

  return Array.isArray(datum) ? datum[1] : datum.y;
}
function getCoordinateXValue(datum) {
  return Array.isArray(datum) ? datum[0] : datum.x;
}
function isValueAfterLastCategory(value, categories) {
  var category = last(categories);

  if (!category) {
    return false;
  }

  return isNumber(value) ? value >= Number(category) : new Date(value) >= new Date(category);
}
function getCoordinateDataIndex(datum, categories, dataIndex, startIndex) {
  if (isNumber(datum)) {
    return dataIndex - startIndex;
  }

  var value = getCoordinateXValue(datum);
  var index = categories.findIndex(function (category) {
    return category === String(value);
  });

  if (index === -1 && isValueAfterLastCategory(value, categories)) {
    index = categories.length;
  }

  return index;
}

function isLineCoordinateSeries(series) {
  var _series$line$;

  if (!series.line) {
    return false;
  }

  var firstData = getFirstValidValue((_series$line$ = series.line[0]) === null || _series$line$ === void 0 ? void 0 : _series$line$.data);
  return firstData && (Array.isArray(firstData) || isObject(firstData));
}

function isCoordinateSeries(series) {
  return isLineCoordinateSeries(series) || !!series.scatter || !!series.bubble;
}
function isModelExistingInRect(rect, point) {
  var height = rect.height,
      width = rect.width;
  var x = point.x,
      y = point.y;
  return x >= 0 && x <= width && y >= 0 && y <= height;
}
function isMouseInRect(rect, mousePosition) {
  var x = rect.x,
      y = rect.y,
      width = rect.width,
      height = rect.height;
  return mousePosition.x >= x && mousePosition.x <= x + width && mousePosition.y >= y && mousePosition.y <= y + height;
}
;// CONCATENATED MODULE: ./src/store/axes.ts
function store_axes_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function store_axes_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { store_axes_ownKeys(Object(source), true).forEach(function (key) { store_axes_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { store_axes_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function store_axes_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function store_axes_toConsumableArray(arr) { return store_axes_arrayWithoutHoles(arr) || store_axes_iterableToArray(arr) || store_axes_unsupportedIterableToArray(arr) || store_axes_nonIterableSpread(); }

function store_axes_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function store_axes_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return store_axes_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return store_axes_arrayLikeToArray(o, minLen); }

function store_axes_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function store_axes_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return store_axes_arrayLikeToArray(arr); }

function store_axes_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

























function isCenterYAxis(options) {
  var _options$yAxis;

  var diverging = !!pickProperty(options, ['series', 'diverging']);
  var alignCenter = (options === null || options === void 0 ? void 0 : (_options$yAxis = options.yAxis) === null || _options$yAxis === void 0 ? void 0 : _options$yAxis.align) === 'center';
  return diverging && alignCenter;
}

function isDivergingBoxSeries(series, options) {
  var _options$series;

  return hasBoxTypeSeries(series) && !!((_options$series = options.series) !== null && _options$series !== void 0 && _options$series.diverging);
}

function getZeroPosition(limit, axisSize, labelAxisOnYAxis, isDivergingSeries) {
  var min = limit.min,
      max = limit.max;
  var hasZeroValue = min <= 0 && max >= 0;

  if (!hasZeroValue || isDivergingSeries) {
    return null;
  }

  var position = (0 - min) / (max - min) * axisSize;
  return labelAxisOnYAxis ? position : axisSize - position;
}

function getLabelAxisData(stateProp) {
  var axisSize = stateProp.axisSize,
      categories = stateProp.categories,
      series = stateProp.series,
      options = stateProp.options,
      theme = stateProp.theme,
      scale = stateProp.scale,
      initialAxisData = stateProp.initialAxisData,
      isCoordinateTypeChart = stateProp.isCoordinateTypeChart,
      axisName = stateProp.axisName;
  var hasLineSeries = !!series.line;
  var pointOnColumn = isPointOnColumn(series, options);
  var dateType = isDateType(options, axisName);
  var labelsBeforeFormatting = isCoordinateTypeChart ? makeLabelsFromLimit(scale.limit, scale.stepSize, dateType) : categories;
  var labels = getLabelsAppliedFormatter(labelsBeforeFormatting, options, dateType, axisName);
  var labelRange;

  if (scale && hasLineSeries) {
    var baseLabels = pointOnColumn ? labelsBeforeFormatting : categories;
    var values = baseLabels.map(function (value) {
      return dateType ? Number(new Date(value)) : Number(value);
    });
    labelRange = {
      min: Math.min.apply(Math, store_axes_toConsumableArray(values)),
      max: Math.max.apply(Math, store_axes_toConsumableArray(values))
    };
  }

  var rectResponderCount = categories.length;
  var tickIntervalCount = rectResponderCount - (pointOnColumn ? 0 : 1);
  var tickDistance = tickIntervalCount ? axisSize / tickIntervalCount : axisSize;
  var labelDistance = axisSize / (labels.length - (pointOnColumn ? 0 : 1));
  var tickCount = labels.length;

  if (pointOnColumn && !isCoordinateTypeChart) {
    tickCount += 1;
  }

  var viewLabels = getViewAxisLabels(store_axes_objectSpread({
    labels: labels,
    pointOnColumn: pointOnColumn,
    tickDistance: tickDistance,
    tickCount: tickCount,
    scale: scale
  }, initialAxisData), axisSize);
  var axisLabelMargin = getLabelXMargin(axisName, options);
  return store_axes_objectSpread(store_axes_objectSpread({
    labels: labels,
    viewLabels: viewLabels,
    pointOnColumn: pointOnColumn,
    labelDistance: labelDistance,
    tickDistance: tickDistance,
    tickCount: tickCount,
    labelRange: labelRange,
    rectResponderCount: rectResponderCount,
    isLabelAxis: true
  }, initialAxisData), getMaxLabelSize(labels, axisLabelMargin, getTitleFontString(theme.label)));
}

function getValueAxisData(stateProp) {
  var scale = stateProp.scale,
      axisSize = stateProp.axisSize,
      series = stateProp.series,
      options = stateProp.options,
      centerYAxis = stateProp.centerYAxis,
      initialAxisData = stateProp.initialAxisData,
      theme = stateProp.theme,
      labelOnYAxis = stateProp.labelOnYAxis,
      axisName = stateProp.axisName;
  var limit = scale.limit,
      stepSize = scale.stepSize;
  var size = centerYAxis ? centerYAxis === null || centerYAxis === void 0 ? void 0 : centerYAxis.xAxisHalfSize : axisSize;
  var divergingBoxSeries = isDivergingBoxSeries(series, options);
  var formatter = getAxisFormatter(options, axisName);
  var zeroPosition = getZeroPosition(limit, axisSize, isLabelAxisOnYAxis({
    series: series,
    options: options
  }), divergingBoxSeries);
  var valueLabels = makeLabelsFromLimit(limit, stepSize);

  if (!centerYAxis && divergingBoxSeries) {
    valueLabels = getDivergingValues(valueLabels);
  }

  var labels = valueLabels.map(function (label, index) {
    return formatter(label, {
      index: index,
      labels: valueLabels,
      axisName: axisName
    });
  });
  var tickDistance = size / Math.max(valueLabels.length, 1);
  var tickCount = valueLabels.length;
  var pointOnColumn = false;
  var viewLabels = getViewAxisLabels(store_axes_objectSpread({
    labels: labelOnYAxis ? labels : store_axes_toConsumableArray(labels).reverse(),
    pointOnColumn: pointOnColumn,
    tickDistance: tickDistance,
    tickCount: tickCount
  }, initialAxisData), size);
  var axisLabelMargin = getLabelXMargin(axisName, options);

  var axisData = store_axes_objectSpread(store_axes_objectSpread({
    labels: labels,
    viewLabels: viewLabels,
    pointOnColumn: pointOnColumn,
    isLabelAxis: false,
    tickCount: tickCount,
    tickDistance: tickDistance
  }, initialAxisData), getMaxLabelSize(labels, axisLabelMargin, getTitleFontString(theme.label)));

  if (isNumber(zeroPosition)) {
    axisData.zeroPosition = zeroPosition;
  }

  return axisData;
}

function getDivergingValues(valueLabels) {
  return hasNegativeOnly(valueLabels) ? valueLabels.reverse().slice(1).concat(valueLabels) : valueLabels.slice(1).reverse().concat(valueLabels);
}

function makeDefaultAxisData(isLabelAxis, params) {
  var _params$axis;

  var axisData = getInitAxisIntervalData(isLabelAxis, params);
  var title = makeTitleOption(params === null || params === void 0 ? void 0 : (_params$axis = params.axis) === null || _params$axis === void 0 ? void 0 : _params$axis.title);

  if (title) {
    axisData.title = title;
  }

  return axisData;
}

function getInitialAxisData(options, labelOnYAxis, categories, layout, isCoordinateTypeChart) {
  var _options$series2;

  var _getYAxisOption = getYAxisOption(options),
      yAxis = _getYAxisOption.yAxis,
      secondaryYAxis = _getYAxisOption.secondaryYAxis;

  var shift = options === null || options === void 0 ? void 0 : (_options$series2 = options.series) === null || _options$series2 === void 0 ? void 0 : _options$series2.shift;
  return {
    xAxis: makeDefaultAxisData(!labelOnYAxis, {
      categories: categories,
      axis: options === null || options === void 0 ? void 0 : options.xAxis,
      layout: layout,
      shift: shift,
      isCoordinateTypeChart: isCoordinateTypeChart
    }),
    yAxis: makeDefaultAxisData(labelOnYAxis, {
      axis: yAxis
    }),
    secondaryYAxis: secondaryYAxis ? makeDefaultAxisData(labelOnYAxis, {
      axis: secondaryYAxis
    }) : null
  };
}

function getSecondaryYAxisData(_ref) {
  var _getYAxisOption$secon, _getYAxisOption$secon2;

  var state = _ref.state,
      labelOnYAxis = _ref.labelOnYAxis,
      valueAxisSize = _ref.valueAxisSize,
      labelAxisSize = _ref.labelAxisSize,
      initialAxisData = _ref.initialAxisData,
      isCoordinateTypeChart = _ref.isCoordinateTypeChart;
  var scale = state.scale,
      options = state.options,
      series = state.series,
      theme = state.theme;
  var categories = state.categories;
  return labelOnYAxis ? getLabelAxisData({
    scale: scale.secondaryYAxis,
    axisSize: labelAxisSize,
    categories: (_getYAxisOption$secon = (_getYAxisOption$secon2 = getYAxisOption(options).secondaryYAxis) === null || _getYAxisOption$secon2 === void 0 ? void 0 : _getYAxisOption$secon2.categories) !== null && _getYAxisOption$secon !== void 0 ? _getYAxisOption$secon : categories,
    options: options,
    series: series,
    theme: getAxisTheme(theme, AxisType.SECONDARY_Y),
    initialAxisData: initialAxisData,
    isCoordinateTypeChart: isCoordinateTypeChart,
    axisName: AxisType.SECONDARY_Y
  }) : getValueAxisData({
    scale: scale.secondaryYAxis,
    axisSize: valueAxisSize,
    options: options,
    series: series,
    theme: getAxisTheme(theme, AxisType.SECONDARY_Y),
    centerYAxis: null,
    initialAxisData: initialAxisData,
    axisName: AxisType.SECONDARY_Y
  });
}

function makeXAxisData(_ref2) {
  var axisData = _ref2.axisData,
      axisSize = _ref2.axisSize,
      axisLayout = _ref2.axisLayout,
      centerYAxis = _ref2.centerYAxis,
      rotatable = _ref2.rotatable,
      _ref2$labelMargin = _ref2.labelMargin,
      labelMargin = _ref2$labelMargin === void 0 ? 0 : _ref2$labelMargin;
  var viewLabels = axisData.viewLabels,
      pointOnColumn = axisData.pointOnColumn,
      maxLabelWidth = axisData.maxLabelWidth,
      maxLabelHeight = axisData.maxLabelHeight;
  var offsetY = getAxisLabelAnchorPoint(maxLabelHeight) + labelMargin;
  var size = centerYAxis ? centerYAxis.xAxisHalfSize : axisSize;
  var distance = size / (viewLabels.length - (pointOnColumn ? 0 : 1));
  var rotationData = makeRotationData(maxLabelWidth, maxLabelHeight, distance, rotatable, axisLayout);
  var needRotateLabel = rotationData.needRotateLabel,
      rotationHeight = rotationData.rotationHeight;
  var maxHeight = (needRotateLabel ? rotationHeight : maxLabelHeight) + offsetY;
  return store_axes_objectSpread(store_axes_objectSpread(store_axes_objectSpread({}, axisData), rotationData), {}, {
    maxHeight: maxHeight,
    offsetY: offsetY
  });
}

function getAxisInfo(labelOnYAxis, plot, series) {
  var _getAxisName = getAxisName(labelOnYAxis, series),
      valueAxisName = _getAxisName.valueAxisName,
      labelAxisName = _getAxisName.labelAxisName;

  var _getSizeKey = getSizeKey(labelOnYAxis),
      valueSizeKey = _getSizeKey.valueSizeKey,
      labelSizeKey = _getSizeKey.labelSizeKey;

  var valueAxisSize = plot[valueSizeKey];
  var labelAxisSize = plot[labelSizeKey];
  return {
    valueAxisName: valueAxisName,
    valueAxisSize: valueAxisSize,
    labelAxisName: labelAxisName,
    labelAxisSize: labelAxisSize
  };
}

function getCategoriesWithTypes(categories, rawCategories) {
  var _ref3, _ref4;

  return {
    categories: (_ref3 = categories) !== null && _ref3 !== void 0 ? _ref3 : [],
    rawCategories: (_ref4 = rawCategories) !== null && _ref4 !== void 0 ? _ref4 : []
  };
}

var axes_axes = {
  name: 'axes',
  state: function state(_ref5) {
    var series = _ref5.series,
        options = _ref5.options;

    var _getYAxisOption2 = getYAxisOption(options),
        secondaryYAxis = _getYAxisOption2.secondaryYAxis;

    var axesState = {
      xAxis: {},
      yAxis: {}
    };

    if (!!series.bar && isCenterYAxis(options)) {
      axesState.centerYAxis = {};
    }

    if (secondaryYAxis) {
      axesState.secondaryYAxis = {};
    }

    return {
      axes: axesState
    };
  },
  action: {
    setAxesData: function setAxesData(_ref6) {
      var _options$xAxis, _options$xAxis$label;

      var state = _ref6.state,
          initStoreState = _ref6.initStoreState;
      var scale = state.scale,
          options = state.options,
          series = state.series,
          layout = state.layout,
          theme = state.theme;
      var xAxis = layout.xAxis,
          yAxis = layout.yAxis,
          plot = layout.plot;
      var isCoordinateTypeChart = isCoordinateSeries(initStoreState.series);
      var labelOnYAxis = isLabelAxisOnYAxis({
        series: series,
        options: options
      });

      var _getCategoriesWithTyp = getCategoriesWithTypes(state.categories, state.rawCategories),
          categories = _getCategoriesWithTyp.categories;

      var _getAxisInfo = getAxisInfo(labelOnYAxis, plot, series),
          valueAxisName = _getAxisInfo.valueAxisName,
          valueAxisSize = _getAxisInfo.valueAxisSize,
          labelAxisName = _getAxisInfo.labelAxisName,
          labelAxisSize = _getAxisInfo.labelAxisSize;

      var hasCenterYAxis = state.axes.centerYAxis;
      var initialAxisData = getInitialAxisData(options, labelOnYAxis, categories, layout, isCoordinateTypeChart);
      var valueAxisData = getValueAxisData({
        scale: scale[valueAxisName],
        axisSize: valueAxisSize,
        options: options,
        series: series,
        theme: getAxisTheme(theme, valueAxisName),
        centerYAxis: hasCenterYAxis ? {
          xAxisHalfSize: (xAxis.width - yAxis.width) / 2
        } : null,
        initialAxisData: initialAxisData[valueAxisName],
        labelOnYAxis: labelOnYAxis,
        axisName: valueAxisName
      });
      var labelAxisData = getLabelAxisData({
        scale: scale[labelAxisName],
        axisSize: labelAxisSize,
        categories: categories,
        options: options,
        series: series,
        theme: getAxisTheme(theme, labelAxisName),
        initialAxisData: initialAxisData[labelAxisName],
        isCoordinateTypeChart: isCoordinateTypeChart,
        labelOnYAxis: labelOnYAxis,
        axisName: labelAxisName
      });
      var secondaryYAxis, centerYAxis;

      if (state.axes.secondaryYAxis) {
        secondaryYAxis = getSecondaryYAxisData({
          state: state,
          labelOnYAxis: labelOnYAxis,
          valueAxisSize: valueAxisSize,
          labelAxisSize: labelAxisSize,
          labelAxisName: labelAxisName,
          valueAxisName: valueAxisName,
          initialAxisData: initialAxisData.secondaryYAxis,
          isCoordinateTypeChart: isCoordinateTypeChart
        });
      }

      if (hasCenterYAxis) {
        var xAxisHalfSize = (xAxis.width - yAxis.width) / 2;
        centerYAxis = deepMergedCopy(valueAxisData, {
          x: xAxis.x + xAxisHalfSize,
          xAxisHalfSize: xAxisHalfSize,
          secondStartX: (xAxis.width + yAxis.width) / 2,
          yAxisLabelAnchorPoint: yAxis.width / 2,
          yAxisHeight: yAxis.height
        });
      }

      var axesState = {
        xAxis: makeXAxisData({
          axisData: labelOnYAxis ? valueAxisData : labelAxisData,
          axisSize: labelOnYAxis ? valueAxisSize : labelAxisSize,
          axisLayout: layout.xAxis,
          centerYAxis: centerYAxis,
          rotatable: getRotatableOption(options),
          labelMargin: (_options$xAxis = options.xAxis) === null || _options$xAxis === void 0 ? void 0 : (_options$xAxis$label = _options$xAxis.label) === null || _options$xAxis$label === void 0 ? void 0 : _options$xAxis$label.margin
        }),
        yAxis: labelOnYAxis ? labelAxisData : valueAxisData,
        secondaryYAxis: secondaryYAxis,
        centerYAxis: centerYAxis
      };

      if (hasAxesLayoutChanged(state.axes, axesState)) {
        this.notify(state, 'layout');
      }

      state.axes = axesState;
    }
  },
  computed: {},
  observe: {
    updateAxes: function updateAxes() {
      this.dispatch('setAxesData');
    }
  }
};
/* harmony default export */ var store_axes = (axes_axes);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.string.includes.js
var es_string_includes = __nested_webpack_require_221589__(1235);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.join.js
var es_array_join = __nested_webpack_require_221589__(6781);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.object.freeze.js
var es_object_freeze = __nested_webpack_require_221589__(2144);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array-buffer.slice.js
var es_array_buffer_slice = __nested_webpack_require_221589__(2994);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.uint8-array.js
var es_typed_array_uint8_array = __nested_webpack_require_221589__(3675);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.copy-within.js
var es_typed_array_copy_within = __nested_webpack_require_221589__(5825);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.every.js
var es_typed_array_every = __nested_webpack_require_221589__(7170);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.fill.js
var es_typed_array_fill = __nested_webpack_require_221589__(8857);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.filter.js
var es_typed_array_filter = __nested_webpack_require_221589__(8329);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.find.js
var es_typed_array_find = __nested_webpack_require_221589__(6279);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.find-index.js
var es_typed_array_find_index = __nested_webpack_require_221589__(427);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.for-each.js
var es_typed_array_for_each = __nested_webpack_require_221589__(1159);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.includes.js
var es_typed_array_includes = __nested_webpack_require_221589__(2516);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.index-of.js
var es_typed_array_index_of = __nested_webpack_require_221589__(4349);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.iterator.js
var es_typed_array_iterator = __nested_webpack_require_221589__(5273);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.join.js
var es_typed_array_join = __nested_webpack_require_221589__(6729);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.last-index-of.js
var es_typed_array_last_index_of = __nested_webpack_require_221589__(1801);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.map.js
var es_typed_array_map = __nested_webpack_require_221589__(574);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.reduce.js
var es_typed_array_reduce = __nested_webpack_require_221589__(5787);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.reduce-right.js
var es_typed_array_reduce_right = __nested_webpack_require_221589__(9271);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.reverse.js
var es_typed_array_reverse = __nested_webpack_require_221589__(3160);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.set.js
var es_typed_array_set = __nested_webpack_require_221589__(5688);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.slice.js
var es_typed_array_slice = __nested_webpack_require_221589__(3157);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.some.js
var es_typed_array_some = __nested_webpack_require_221589__(3333);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.sort.js
var es_typed_array_sort = __nested_webpack_require_221589__(315);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.subarray.js
var es_typed_array_subarray = __nested_webpack_require_221589__(8314);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.to-locale-string.js
var es_typed_array_to_locale_string = __nested_webpack_require_221589__(556);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.typed-array.to-string.js
var es_typed_array_to_string = __nested_webpack_require_221589__(9224);
;// CONCATENATED MODULE: ./src/helpers/downloader.ts








var _templateObject;

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function downloader_toConsumableArray(arr) { return downloader_arrayWithoutHoles(arr) || downloader_iterableToArray(arr) || downloader_unsupportedIterableToArray(arr) || downloader_nonIterableSpread(); }

function downloader_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function downloader_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return downloader_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return downloader_arrayLikeToArray(o, minLen); }

function downloader_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function downloader_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return downloader_arrayLikeToArray(arr); }

function downloader_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }








































var DATA_URI_HEADERS = {
  xls: 'data:application/vnd.ms-excel;base64,',
  csv: 'data:text/csv;charset=utf-8,%EF%BB%BF'
  /* BOM for utf-8 */

};

function getDownloadMethod() {
  var method;
  var isDownloadAttributeSupported = !isUndefined(document.createElement('a').download);
  var isMSSaveOrOpenBlobSupported = !isUndefined(window.Blob && window.navigator.msSaveOrOpenBlob);

  if (isMSSaveOrOpenBlobSupported) {
    method = downloadWithMSSaveOrOpenBlob;
  } else if (isDownloadAttributeSupported) {
    method = downloadWithAnchorElementDownloadAttribute;
  }

  return method;
}
/**
 * Base64 string to blob
 * original source ref: https://github.com/miguelmota/base64toblob/blob/master/base64toblob.js
 * Licence: MIT Licence
 */


function base64toBlob(base64String) {
  var contentType = base64String.substr(0, base64String.indexOf(';base64,')).substr(base64String.indexOf(':') + 1);
  var sliceSize = 1024;
  var byteCharacters = atob(base64String.substr(base64String.indexOf(',') + 1));
  var byteArrays = [];

  for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
    var slice = byteCharacters.slice(offset, offset + sliceSize);
    var byteNumbers = new Array(slice.length);

    for (var i = 0; i < slice.length; i += 1) {
      byteNumbers[i] = slice.charCodeAt(i);
    }

    byteArrays.push(new window.Uint8Array(byteNumbers));
  }

  try {
    // for IE 11
    return new Blob(byteArrays, {
      type: contentType
    });
  } catch (e) {
    // for IE 10
    return new Blob(byteArrays.map(function (byteArr) {
      return byteArr.buffer;
    }), {
      type: contentType
    });
  }
}

function isImageExtension(extension) {
  return extension === 'jpeg' || extension === 'png';
}

function downloadWithMSSaveOrOpenBlob(fileName, extension, content, contentType) {
  var blobObject = isImageExtension(extension) ? base64toBlob(content) : new Blob([content], {
    type: contentType
  });
  window.navigator.msSaveOrOpenBlob(blobObject, "".concat(fileName, ".").concat(extension));
}

function downloadWithAnchorElementDownloadAttribute(fileName, extension, content) {
  if (content) {
    var anchorElement = document.createElement('a');
    anchorElement.href = content;
    anchorElement.target = '_blank';
    anchorElement.download = "".concat(fileName, ".").concat(extension);
    document.body.appendChild(anchorElement);
    anchorElement.click();
    anchorElement.remove();
  }
}

function oneLineTrim() {
  var normalTag = function normalTag(template) {
    for (var _len = arguments.length, expressions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      expressions[_key - 1] = arguments[_key];
    }

    return template.reduce(function (accumulator, part, i) {
      return accumulator + expressions[i - 1] + part;
    });
  };

  return normalTag.apply(void 0, arguments).replace(/\n\s*/g, '');
}

function isNeedDataEncoding() {
  var isDownloadAttributeSupported = !isUndefined(document.createElement('a').download);
  var isMSSaveOrOpenBlobSupported = !isUndefined(window.Blob && window.navigator.msSaveOrOpenBlob);
  return !isMSSaveOrOpenBlobSupported && isDownloadAttributeSupported;
}

function getBulletLongestArrayLength(arr, field) {
  return arr.reduce(function (acc, cur, idx) {
    var _cur$field;

    return !idx || acc < (cur === null || cur === void 0 ? void 0 : (_cur$field = cur[field]) === null || _cur$field === void 0 ? void 0 : _cur$field.length) ? cur[field].length : acc;
  }, 0);
}

function makeBulletExportData(_ref) {
  var series = _ref.series;
  var seriesData = series.bullet.data;
  var markerCount = getBulletLongestArrayLength(seriesData, 'markers');
  var rangeCount = getBulletLongestArrayLength(seriesData, 'ranges');
  var rangesHeaders = range(0, rangeCount).map(function (idx) {
    return "Range ".concat(idx + 1);
  });
  var markerHeaders = range(0, markerCount).map(function (idx) {
    return "Marker ".concat(idx + 1);
  });
  return seriesData.reduce(function (acc, _ref2) {
    var data = _ref2.data,
        markers = _ref2.markers,
        name = _ref2.name,
        ranges = _ref2.ranges;
    var rangeDatum = rangesHeaders.map(function (_, index) {
      var rangeData = ranges === null || ranges === void 0 ? void 0 : ranges[index];
      return rangeData ? "".concat(rangeData[0], " ~ ").concat(rangeData[1]) : '';
    });
    var markerDatum = markerHeaders.map(function (_, index) {
      var _markers$index;

      return (_markers$index = markers === null || markers === void 0 ? void 0 : markers[index]) !== null && _markers$index !== void 0 ? _markers$index : '';
    });
    return [].concat(downloader_toConsumableArray(acc), [[name, data !== null && data !== void 0 ? data : ''].concat(downloader_toConsumableArray(rangeDatum), downloader_toConsumableArray(markerDatum))]);
  }, [['', 'Actual'].concat(downloader_toConsumableArray(rangesHeaders), downloader_toConsumableArray(markerHeaders))]);
}

function makeHeatmapExportData(_ref3) {
  var categories = _ref3.categories,
      series = _ref3.series;
  var xCategories = categories.x;
  return series.heatmap.data.reduce(function (acc, _ref4) {
    var data = _ref4.data,
        yCategory = _ref4.yCategory;
    return [].concat(downloader_toConsumableArray(acc), [[yCategory].concat(downloader_toConsumableArray(data.map(function (datum) {
      return isNull(datum) ? '' : datum;
    })))]);
  }, [[''].concat(downloader_toConsumableArray(xCategories))]);
}

function recursiveTreemapData(_ref5, result) {
  var label = _ref5.label,
      data = _ref5.data,
      _ref5$children = _ref5.children,
      children = _ref5$children === void 0 ? [] : _ref5$children;

  if (data) {
    result.push([label, data]);
  }

  children.forEach(function (childrenData) {
    return recursiveTreemapData(childrenData, result);
  });
  return result;
}

function makeTreemapExportData(exportData) {
  var series = exportData.series;
  var result = [['Label', 'Data']];
  series.treemap.data.forEach(function (datum) {
    recursiveTreemapData(datum, result);
  });
  return result;
}

function makeBubbleExportData(exportData) {
  var series = exportData.series;
  return series.bubble.data.reduce(function (acc, _ref6) {
    var name = _ref6.name,
        data = _ref6.data;
    return [].concat(downloader_toConsumableArray(acc), downloader_toConsumableArray(data.map(function (datum) {
      return isNull(datum) ? [] : [name, datum.label, String(datum.x), datum.y, datum.r];
    })));
  }, [['Name', 'Label', 'X', 'Y', 'Radius']]);
}

function makeBoxPlotExportData(exportData) {
  var _exportData$categorie;

  var series = exportData.series;
  var categories = (_exportData$categorie = exportData.categories) !== null && _exportData$categorie !== void 0 ? _exportData$categorie : [];
  return series.boxPlot.data.reduce(function (acc, _ref7) {
    var name = _ref7.name,
        data = _ref7.data,
        outliers = _ref7.outliers;
    var values = (data !== null && data !== void 0 ? data : []).map(function (rawData, index) {
      var _find;

      var outlierValue = (_find = (outliers !== null && outliers !== void 0 ? outliers : []).find(function (outlier) {
        return outlier[0] === index;
      })) === null || _find === void 0 ? void 0 : _find[1];
      var value = outlierValue ? [].concat(downloader_toConsumableArray(rawData), [outlierValue]) : downloader_toConsumableArray(rawData);
      return value.join();
    });
    return [].concat(downloader_toConsumableArray(acc), [[name].concat(downloader_toConsumableArray(values))]);
  }, [[''].concat(downloader_toConsumableArray(categories))]);
}

function makePieExportData(exportData) {
  var _exportData$categorie2;

  var series = exportData.series;
  var categories = (_exportData$categorie2 = exportData.categories) !== null && _exportData$categorie2 !== void 0 ? _exportData$categorie2 : [];
  return series.pie.data.reduce(function (acc, _ref8) {
    var name = _ref8.name,
        data = _ref8.data;
    var values = Array.isArray(data) ? (data !== null && data !== void 0 ? data : []).reduce(function (accNestedPieValue, value) {
      var _value$data;

      return [].concat(downloader_toConsumableArray(accNestedPieValue), [[value.name, (_value$data = value.data) !== null && _value$data !== void 0 ? _value$data : '']]);
    }, []) : [[name, data !== null && data !== void 0 ? data : '']];
    return [].concat(downloader_toConsumableArray(acc), downloader_toConsumableArray(values));
  }, categories.length ? [[''].concat(downloader_toConsumableArray(categories))] : []);
}

function makeCoordinateExportDataValues(type, categories, data) {
  return categories.map(function (category, index) {
    if (type === 'area' && Array.isArray(data[index])) {
      return data[index].join();
    }

    var foundItem = data.find(function (value) {
      return category === String(getCoordinateXValue(value));
    });
    return foundItem ? getCoordinateYValue(foundItem) : '';
  });
}

function makeExportData(exportData) {
  var series = exportData.series;
  var categories = exportData.categories;
  return Object.keys(series).reduce(function (acc, type) {
    var result = series[type].data.map(function (_ref9) {
      var name = _ref9.name,
          data = _ref9.data;
      var values = !isNumber(getFirstValidValue(data)) && includes(['line', 'area', 'scatter'], type) ? makeCoordinateExportDataValues(type, categories, data) : data.map(function (value) {
        return Array.isArray(value) ? value.join() : value;
      });
      return [name].concat(downloader_toConsumableArray(values));
    });
    return [].concat(downloader_toConsumableArray(acc), downloader_toConsumableArray(result));
  }, series.gauge ? [] : [[''].concat(downloader_toConsumableArray(categories))]);
}

function get2DArrayFromRawData(exportData) {
  var result;
  var series = exportData.series;

  if (series.bullet) {
    result = makeBulletExportData(exportData);
  } else if (series.heatmap) {
    result = makeHeatmapExportData(exportData);
  } else if (series.bubble) {
    result = makeBubbleExportData(exportData);
  } else if (series.boxPlot) {
    result = makeBoxPlotExportData(exportData);
  } else if (series.pie) {
    result = makePieExportData(exportData);
  } else if (series.treemap) {
    result = makeTreemapExportData(exportData);
  } else {
    result = makeExportData(exportData);
  }

  return result;
}

function getTableElementStringForXLS(chartData2DArray) {
  var tableElementString = '<table>';
  chartData2DArray.forEach(function (row, rowIndex) {
    var cellTagName = rowIndex === 0 ? 'th' : 'td';
    tableElementString += '<tr>';
    row.forEach(function (cell, cellIndex) {
      var cellNumberClass = rowIndex !== 0 || cellIndex === 0 ? ' class="number"' : '';
      var cellString = "<".concat(cellTagName).concat(cellNumberClass, ">").concat(cell, "</").concat(cellTagName, ">");
      tableElementString += cellString;
    });
    tableElementString += '</tr>';
  });
  tableElementString += '</table>';
  return tableElementString;
}

function makeXLSBodyWithRawData(chartData2DArray) {
  return oneLineTrim(_templateObject || (_templateObject = _taggedTemplateLiteral(["<html xmlns:o=\"urn:schemas-microsoft-com:office:office\"\n        xmlns:x=\"urn:schemas-microsoft-com:office:excel\"\n        xmlns=\"http://www.w3.org/TR/REC-html40\">\n        <head>\n            <!--[if gte mso 9]>\n                <xml>\n                    <x:ExcelWorkbook>\n                        <x:ExcelWorksheets>\n                            <x:ExcelWorksheet>\n                                <x:Name>Ark1</x:Name>\n                                <x:WorksheetOptions>\n                                    <x:DisplayGridlines/>\n                                </x:WorksheetOptions>\n                            </x:ExcelWorksheet>\n                        </x:ExcelWorksheets>\n                        </x:ExcelWorkbook>\n                </xml>\n            <![endif]-->\n            <meta name=ProgId content=Excel.Sheet>\n            <meta charset=UTF-8>\n        </head>\n        <body>\n            ", "\n        </body>\n        </html>"])), getTableElementStringForXLS(chartData2DArray));
}

function makeCSVBodyWithRawData(chartData2DArray) {
  var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _option$lineDelimiter = option.lineDelimiter,
      lineDelimiter = _option$lineDelimiter === void 0 ? "\n" : _option$lineDelimiter,
      _option$itemDelimiter = option.itemDelimiter,
      itemDelimiter = _option$itemDelimiter === void 0 ? ',' : _option$itemDelimiter;
  var lastRowIndex = chartData2DArray.length - 1;
  var csvText = '';
  chartData2DArray.forEach(function (row, rowIndex) {
    var lastCellIndex = row.length - 1;
    row.forEach(function (cell, cellIndex) {
      var cellContent = isNumber(cell) ? cell : "\"".concat(cell, "\"");
      csvText += cellContent;

      if (cellIndex < lastCellIndex) {
        csvText += itemDelimiter;
      }
    });

    if (rowIndex < lastRowIndex) {
      csvText += lineDelimiter;
    }
  });
  return csvText;
}

function execDownload(fileName, extension, content, contentType) {
  var downloadMethod = getDownloadMethod();

  if (!utils_isString(content) || !downloadMethod) {
    return;
  }

  downloadMethod(fileName, extension, content, contentType);
}
function downloadSpreadSheet(fileName, extension, data) {
  var chartData2DArray = get2DArrayFromRawData(data);
  var contentType = DATA_URI_HEADERS[extension].replace(/(data:|;base64,|,%EF%BB%BF)/g, '');
  var content = '';

  if (extension === 'csv') {
    content = encodeURIComponent(makeCSVBodyWithRawData(chartData2DArray));
  } else {
    content = makeXLSBodyWithRawData(chartData2DArray);
  }

  if (isNeedDataEncoding()) {
    if (extension !== 'csv') {
      // base64 encoding for data URI scheme.
      content = window.btoa(unescape(encodeURIComponent(content)));
    }

    content = DATA_URI_HEADERS[extension] + content;
  }

  execDownload(fileName, extension, content, contentType);
}
;// CONCATENATED MODULE: ./src/component/exportMenu.ts
function exportMenu_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { exportMenu_typeof = function _typeof(obj) { return typeof obj; }; } else { exportMenu_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return exportMenu_typeof(obj); }

















function exportMenu_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function exportMenu_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function exportMenu_createClass(Constructor, protoProps, staticProps) { if (protoProps) exportMenu_defineProperties(Constructor.prototype, protoProps); if (staticProps) exportMenu_defineProperties(Constructor, staticProps); return Constructor; }

function exportMenu_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) exportMenu_setPrototypeOf(subClass, superClass); }

function exportMenu_setPrototypeOf(o, p) { exportMenu_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return exportMenu_setPrototypeOf(o, p); }

function exportMenu_createSuper(Derived) { var hasNativeReflectConstruct = exportMenu_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = exportMenu_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = exportMenu_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return exportMenu_possibleConstructorReturn(this, result); }; }

function exportMenu_possibleConstructorReturn(self, call) { if (call && (exportMenu_typeof(call) === "object" || typeof call === "function")) { return call; } return exportMenu_assertThisInitialized(self); }

function exportMenu_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function exportMenu_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function exportMenu_getPrototypeOf(o) { exportMenu_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return exportMenu_getPrototypeOf(o); }

function exportMenu_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var EXPORT_MENU_WIDTH = 140;
var exportExtensions = {
  IMAGES: ['png', 'jpeg'],
  SPREAD_SHEETS: ['xls', 'csv']
};
var BUTTON_RECT_SIZE = 24;

var ExportMenu = /*#__PURE__*/function (_Component) {
  exportMenu_inherits(ExportMenu, _Component);

  var _super = exportMenu_createSuper(ExportMenu);

  function ExportMenu() {
    var _this;

    exportMenu_classCallCheck(this, ExportMenu);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "responders", void 0);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "models", {
      exportMenuButton: []
    });

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "opened", false);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "fileName", void 0);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "data", void 0);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "chartEl", void 0);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "exportMenuEl", void 0);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "theme", void 0);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "chartBackgroundColor", void 0);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "chartWidth", 0);

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "toggleExportMenu", function () {
      _this.opened = !_this.opened;
      _this.models.exportMenuButton[0].opened = _this.opened;

      _this.eventBus.emit('needDraw');

      if (_this.opened) {
        _this.applyPanelWrapperStyle();

        _this.chartEl.appendChild(_this.exportMenuEl);
      } else {
        _this.chartEl.removeChild(_this.exportMenuEl);
      }
    });

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "getCanvasExportBtnRemoved", function () {
      var canvas = _this.chartEl.getElementsByTagName('canvas')[0];

      var ctx = canvas.getContext('2d');
      var _this$rect = _this.rect,
          x = _this$rect.x,
          y = _this$rect.y,
          h = _this$rect.height,
          w = _this$rect.width;
      ctx.clearRect(x, y, w, h);
      ctx.fillStyle = _this.chartBackgroundColor;
      ctx.fillRect(x, y, w, h);
      return canvas;
    });

    exportMenu_defineProperty(exportMenu_assertThisInitialized(_this), "onClickExportButton", function (ev) {
      var id = ev.target.id;
      var isImageExtension = exportExtensions.IMAGES.includes(id);
      var isSpreadSheetExtension = exportExtensions.SPREAD_SHEETS.includes(id);

      if (isImageExtension) {
        var canvas = _this.getCanvasExportBtnRemoved();

        execDownload(_this.fileName, id, canvas.toDataURL("image/".concat(id), 1));
      } else if (isSpreadSheetExtension) {
        downloadSpreadSheet(_this.fileName, id, _this.data);
      }

      if (isImageExtension || isSpreadSheetExtension) {
        _this.toggleExportMenu();
      }
    });

    return _this;
  }

  exportMenu_createClass(ExportMenu, [{
    key: "applyExportButtonPanelStyle",
    value: function applyExportButtonPanelStyle() {
      var exportMenuTitle = this.exportMenuEl.querySelector('.toastui-chart-export-menu-title');
      var menuBtnWrapper = this.exportMenuEl.querySelector('.toastui-chart-export-menu-btn-wrapper');
      exportMenuTitle.setAttribute('style', this.makePanelStyle('header'));
      menuBtnWrapper.setAttribute('style', this.makePanelStyle('body'));
    }
  }, {
    key: "makeExportMenuButton",
    value: function makeExportMenuButton() {
      var el = document.createElement('div');
      el.onclick = this.onClickExportButton;
      el.innerHTML = "\n        <div class=\"toastui-chart-export-menu\">\n          <p class=\"toastui-chart-export-menu-title\">Export to</p>\n          <div class=\"toastui-chart-export-menu-btn-wrapper\">\n            <button class=\"toastui-chart-export-menu-btn\" id=\"xls\">xls</button>\n            <button class=\"toastui-chart-export-menu-btn\" id=\"csv\">csv</button>\n            <button class=\"toastui-chart-export-menu-btn\" id=\"png\">png</button>\n            <button class=\"toastui-chart-export-menu-btn\" id=\"jpeg\">jpeg</button>\n          </div>\n        </div>\n      ";
      return el;
    }
  }, {
    key: "initialize",
    value: function initialize(_ref) {
      var chartEl = _ref.chartEl;
      this.chartEl = chartEl;
      this.type = 'exportMenu';
      this.name = 'exportMenu';
      this.exportMenuEl = this.makeExportMenuButton();
    }
  }, {
    key: "onClick",
    value: function onClick(_ref2) {
      var responders = _ref2.responders;

      if (responders.length) {
        this.toggleExportMenu();
      }
    }
  }, {
    key: "getFileName",
    value: function getFileName(title) {
      var _title$text;

      return utils_isString(title) ? title : (_title$text = title === null || title === void 0 ? void 0 : title.text) !== null && _title$text !== void 0 ? _title$text : 'toast-ui-chart';
    }
  }, {
    key: "render",
    value: function render(_ref3) {
      var _options$exportMenu;

      var options = _ref3.options,
          layout = _ref3.layout,
          chart = _ref3.chart,
          series = _ref3.series,
          rawCategories = _ref3.rawCategories,
          theme = _ref3.theme;
      this.isShow = isExportMenuVisible(options);
      this.chartWidth = chart.width;

      if (!this.isShow) {
        return;
      }

      this.chartBackgroundColor = theme.chart.backgroundColor;
      this.theme = theme.exportMenu;
      this.data = {
        series: series,
        categories: rawCategories
      };
      this.fileName = this.getFileName((options === null || options === void 0 ? void 0 : (_options$exportMenu = options.exportMenu) === null || _options$exportMenu === void 0 ? void 0 : _options$exportMenu.filename) || chart.title);
      this.applyExportButtonPanelStyle();
      this.rect = layout.exportMenu;
      this.models.exportMenuButton = [{
        type: 'exportMenuButton',
        x: 0,
        y: 0,
        opened: this.opened,
        theme: this.theme.button
      }];
      this.responders = [{
        type: 'rect',
        width: BUTTON_RECT_SIZE,
        height: BUTTON_RECT_SIZE,
        x: 0,
        y: 0
      }];
    }
  }, {
    key: "applyPanelWrapperStyle",
    value: function applyPanelWrapperStyle() {
      var exportMenu = this.exportMenuEl.querySelector('.toastui-chart-export-menu');
      var x = this.chartWidth - EXPORT_MENU_WIDTH - padding.X;
      var y = padding.Y + BUTTON_RECT_SIZE + 5;
      var _this$theme$panel = this.theme.panel,
          borderRadius = _this$theme$panel.borderRadius,
          borderWidth = _this$theme$panel.borderWidth,
          borderColor = _this$theme$panel.borderColor;
      var style = "\n      transform: ".concat(getTranslateString(x, y), ";\n      border: ").concat(borderWidth, "px solid ").concat(borderColor, ";\n      border-radius: ").concat(borderRadius, "px;");
      exportMenu.setAttribute('style', style);
    }
  }, {
    key: "makePanelStyle",
    value: function makePanelStyle(type) {
      var sectionTheme = this.theme.panel[type];
      var direction = type === 'header' ? 'top' : 'bottom';
      var _ref4 = this.theme.panel,
          borderRadius = _ref4.borderRadius,
          borderWidth = _ref4.borderWidth;
      var borderRadiusPx = "".concat(borderRadius - borderWidth, "px");
      return ["".concat(getFontStyleString(sectionTheme)), "border-".concat(direction, "-left-radius: ").concat(borderRadiusPx, ";"), "border-".concat(direction, "-right-radius: ").concat(borderRadiusPx, ";"), "background-color: ".concat(sectionTheme.backgroundColor, ";")].join('');
    }
  }]);

  return ExportMenu;
}(Component);


;// CONCATENATED MODULE: ./src/brushes/dataLabel.ts







function dataLabel_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function dataLabel_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { dataLabel_ownKeys(Object(source), true).forEach(function (key) { dataLabel_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { dataLabel_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function dataLabel_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






function dataLabel(ctx, model) {
  var x = model.x,
      y = model.y,
      text = model.text,
      textAlign = model.textAlign,
      textBaseline = model.textBaseline,
      opacity = model.opacity,
      callout = model.callout,
      theme = model.theme,
      radian = model.radian;
  var color = theme.color,
      textBubble = theme.textBubble;
  var font = getFont(theme);
  var textStyle = {
    textAlign: textAlign,
    textBaseline: textBaseline,
    font: font,
    fillStyle: color
  };
  var textStrokeStyle = getTextStrokeStyle(theme);

  if (callout) {
    var _callout$theme = callout.theme,
        lineWidth = _callout$theme.lineWidth,
        lineColor = _callout$theme.lineColor;
    line(ctx, dataLabel_objectSpread(dataLabel_objectSpread({
      type: 'line'
    }, pick(callout, 'x', 'y', 'x2', 'y2')), {}, {
      strokeStyle: lineColor,
      lineWidth: lineWidth
    }));
  }

  if (textBubble !== null && textBubble !== void 0 && textBubble.visible) {
    drawBubbleLabel(ctx, model);
    return;
  }

  label(ctx, {
    type: 'label',
    x: x,
    y: y,
    text: text,
    style: [textStyle],
    stroke: [textStrokeStyle],
    opacity: opacity,
    radian: radian
  });
}
function drawBubbleLabel(ctx, model) {
  var text = model.text,
      theme = model.theme,
      _model$radian = model.radian,
      radian = _model$radian === void 0 ? 0 : _model$radian;
  var _ref = theme,
      color = _ref.color,
      textStrokeColor = _ref.textStrokeColor;
  var font = getFont(theme);
  var bubbleRect = getBubbleRect(model);
  var x = bubbleRect.x,
      y = bubbleRect.y,
      width = bubbleRect.width,
      height = bubbleRect.height;
  bubbleLabel(ctx, {
    type: 'bubbleLabel',
    radian: radian,
    rotationPosition: {
      x: model.x,
      y: model.y
    },
    bubble: bubbleRect,
    label: {
      x: x + width / 2,
      y: y + height / 2,
      text: text,
      style: [{
        font: font,
        fillStyle: color,
        textAlign: 'center',
        textBaseline: 'middle'
      }],
      strokeStyle: textStrokeColor
    }
  });
}
function getBubbleArrowPoints(direction, _ref2, arrowPointTheme) {
  var x = _ref2.x,
      y = _ref2.y;
  var width = arrowPointTheme.width;
  var height = arrowPointTheme.height;
  var points = [];

  if (direction === 'top') {
    points = [{
      x: x - width / 2,
      y: y + height
    }, {
      x: x,
      y: y
    }, {
      x: x + width / 2,
      y: y + height
    }];
  } else if (direction === 'bottom') {
    points = [{
      x: x + width / 2,
      y: y - height
    }, {
      x: x,
      y: y
    }, {
      x: x - width / 2,
      y: y - height
    }];
  } else if (direction === 'right') {
    points = [{
      x: x - height,
      y: y - width / 2
    }, {
      x: x,
      y: y
    }, {
      x: x - height,
      y: y + width / 2
    }];
  } else if (direction === 'left') {
    points = [{
      x: x + height,
      y: y + width / 2
    }, {
      x: x,
      y: y
    }, {
      x: x + height,
      y: y - width / 2
    }];
  }

  return points;
}

function getBubbleRect(model) {
  var text = model.text,
      theme = model.theme,
      textAlign = model.textAlign,
      textBaseline = model.textBaseline;
  var font = getFont(theme);
  var _ref3 = theme.textBubble,
      arrow = _ref3.arrow,
      paddingX = _ref3.paddingX,
      paddingY = _ref3.paddingY,
      borderRadius = _ref3.borderRadius,
      borderColor = _ref3.borderColor,
      borderWidth = _ref3.borderWidth,
      backgroundColor = _ref3.backgroundColor,
      shadowBlur = _ref3.shadowBlur,
      shadowOffsetX = _ref3.shadowOffsetX,
      shadowOffsetY = _ref3.shadowOffsetY,
      shadowColor = _ref3.shadowColor;
  var labelWidth = getTextWidth(text, font);
  var width = labelWidth + paddingX * 2;
  var height = getTextHeight(text, font) + paddingY * 2;
  var x = model.x,
      y = model.y;

  if (textAlign === 'center') {
    x -= width / 2;
  } else if (includes(['right', 'end'], textAlign)) {
    x -= width;
  }

  if (textBaseline === 'middle') {
    y -= height / 2;
  } else if (textBaseline === 'bottom') {
    y -= height;
  }

  var rect = {
    x: x,
    y: y,
    width: width,
    height: height
  };
  return dataLabel_objectSpread(dataLabel_objectSpread({}, rect), {}, {
    radius: borderRadius,
    lineWidth: borderWidth,
    fill: backgroundColor,
    strokeStyle: borderColor,
    style: [{
      shadowBlur: shadowBlur,
      shadowOffsetX: shadowOffsetX,
      shadowOffsetY: shadowOffsetY,
      shadowColor: shadowColor
    }]
  }, getArrowInfo(rect, textAlign, textBaseline, arrow));
}

function getArrowInfo(rect, textAlign, textBaseline, theme) {
  var _theme$direction;

  if (!(theme !== null && theme !== void 0 && theme.visible)) {
    return null;
  }

  var arrowHeight = theme.height;
  var width = rect.width,
      height = rect.height;
  var direction = (_theme$direction = theme.direction) !== null && _theme$direction !== void 0 ? _theme$direction : getArrowDirection(textAlign, textBaseline);
  var boxX = rect.x,
      boxY = rect.y;
  var pointX = rect.x,
      pointY = rect.y;

  if (direction === 'top') {
    boxY += arrowHeight;
  } else if (direction === 'bottom') {
    boxY -= arrowHeight;
    pointY += height;
  } else if (direction === 'right') {
    boxX -= arrowHeight;
    pointX += width;
  } else if (direction === 'left') {
    boxX += arrowHeight;
  }

  if (textAlign === 'center') {
    pointX = rect.x + width / 2;
  } else if (textBaseline === 'middle') {
    pointY = rect.y + height / 2;
  }

  return {
    direction: direction,
    points: getBubbleArrowPoints(direction, {
      x: pointX,
      y: pointY
    }, theme),
    x: boxX,
    y: boxY
  };
}

function getArrowDirection(textAlign, textBaseline) {
  var direction = 'top';

  if (textAlign === 'center' && textBaseline === 'top') {
    direction = 'top';
  } else if (textAlign === 'center' && textBaseline === 'bottom') {
    direction = 'bottom';
  } else if (textBaseline === 'middle' && textAlign === 'right') {
    direction = 'right';
  } else if (textBaseline === 'middle' && textAlign === 'left') {
    direction = 'left';
  }

  return direction;
}

function getTextStrokeStyle(theme) {
  var textStrokeColor = theme.textStrokeColor;
  var textStrokeStyle = pick(theme, 'lineWidth', 'shadowColor', 'shadowBlur');

  if (textStrokeColor) {
    textStrokeStyle.strokeStyle = textStrokeColor;
  }

  return textStrokeStyle;
}
;// CONCATENATED MODULE: ./src/brushes/spectrumLegend.ts
function spectrumLegend_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function spectrumLegend_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { spectrumLegend_ownKeys(Object(source), true).forEach(function (key) { spectrumLegend_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { spectrumLegend_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function spectrumLegend_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }











var SPECTRUM_LEGEND_LABEL_HEIGHT = 12;
var spectrumLegendBar = {
  HEIGHT: 6,
  PADDING: 5
};
var spectrumLegendTooltip = {
  HEIGHT: 28,
  POINT_WIDTH: 8,
  POINT_HEIGHT: 6,
  PADDING: 6
};

function getBarStartPoint(model) {
  var align = model.align,
      modelX = model.x,
      modelY = model.y,
      labels = model.labels,
      width = model.width;
  var PADDING = spectrumLegendBar.PADDING;
  var x, y;

  if (align === 'top') {
    x = modelX;
    y = modelY + SPECTRUM_LEGEND_LABEL_HEIGHT + PADDING;
  } else if (align === 'bottom') {
    x = modelX;
    y = modelY + spectrumLegendTooltip.HEIGHT;
  } else if (align === 'left') {
    x = modelX + getMaxLengthLabelWidth(labels) + PADDING;
    y = modelY + SPECTRUM_LEGEND_LABEL_HEIGHT / 2;
  } else {
    x = modelX + width - (getMaxLengthLabelWidth(labels) + padding.X + PADDING * 2 + spectrumLegendBar.HEIGHT);
    y = modelY + SPECTRUM_LEGEND_LABEL_HEIGHT / 2;
  }

  return {
    x: x,
    y: y
  };
}

function getLabelsStartPoint(model) {
  var align = model.align,
      modelX = model.x,
      modelY = model.y,
      labels = model.labels,
      width = model.width;
  var x, y;

  if (align === 'top') {
    x = modelX;
    y = modelY;
  } else if (align === 'bottom') {
    x = modelX;
    y = modelY + spectrumLegendTooltip.HEIGHT + spectrumLegendBar.HEIGHT + spectrumLegendBar.PADDING;
  } else if (align === 'left') {
    x = modelX + getMaxLengthLabelWidth(labels);
    y = modelY;
  } else {
    x = modelX + width - getMaxLengthLabelWidth(labels) - padding.X;
    y = modelY;
  }

  return {
    x: x,
    y: y
  };
}

function getBarSize(width, height, verticalAlign) {
  var HEIGHT = spectrumLegendBar.HEIGHT;
  var barWidth = verticalAlign ? width : HEIGHT;
  var barHeight = verticalAlign ? HEIGHT : height - SPECTRUM_LEGEND_LABEL_HEIGHT;
  return {
    barWidth: barWidth,
    barHeight: barHeight
  };
}

function drawLabels(ctx, model) {
  var labels = model.labels,
      align = model.align,
      x = model.x,
      y = model.y,
      width = model.width,
      height = model.height,
      verticalAlign = model.verticalAlign;

  var _getBarSize = getBarSize(width, height, verticalAlign),
      barWidth = _getBarSize.barWidth,
      barHeight = _getBarSize.barHeight;

  var labelSize = labels.length - 1;
  var textBaseStyleMap = {
    left: {
      textAlign: 'right',
      textBaseline: 'top'
    },
    right: {
      textAlign: 'left',
      textBaseline: 'top'
    },
    top: {
      textAlign: 'center',
      textBaseline: 'top'
    },
    bottom: {
      textAlign: 'center',
      textBaseline: 'top'
    }
  };
  labels.forEach(function (text, idx) {
    var startX = verticalAlign ? x + barWidth / labelSize * idx : x;
    var startY = verticalAlign ? y : y + barHeight / labelSize * idx;
    label(ctx, {
      type: 'label',
      x: startX,
      y: startY,
      text: text,
      style: ['default', textBaseStyleMap[align]]
    });
  });
}

function drawBar(ctx, model) {
  var width = model.width,
      height = model.height,
      startColor = model.startColor,
      endColor = model.endColor,
      x = model.x,
      y = model.y,
      verticalAlign = model.verticalAlign;

  var _getBarSize2 = getBarSize(width, height, verticalAlign),
      barWidth = _getBarSize2.barWidth,
      barHeight = _getBarSize2.barHeight;

  var gradient = verticalAlign ? ctx.createLinearGradient(x, y, x + barWidth, y) : ctx.createLinearGradient(x, y, x, y + barHeight);
  gradient.addColorStop(0, startColor);
  gradient.addColorStop(1, endColor);
  ctx.fillStyle = gradient;
  ctx.fillRect(x, y, barWidth, barHeight);
}

function getTooltipArrowPoint(model) {
  var align = model.align,
      colorRatio = model.colorRatio,
      width = model.width,
      height = model.height,
      x = model.x,
      y = model.y,
      labels = model.labels,
      verticalAlign = model.verticalAlign;

  var _getBarSize3 = getBarSize(width, height, verticalAlign),
      barWidth = _getBarSize3.barWidth,
      barHeight = _getBarSize3.barHeight;

  var PADDING = spectrumLegendBar.PADDING,
      HEIGHT = spectrumLegendBar.HEIGHT;

  if (align === 'top') {
    return {
      x: x + barWidth * colorRatio,
      y: y + SPECTRUM_LEGEND_LABEL_HEIGHT + HEIGHT + PADDING * 2
    };
  }

  if (align === 'bottom') {
    return {
      x: x + barWidth * colorRatio,
      y: y + SPECTRUM_LEGEND_LABEL_HEIGHT + PADDING * 2
    };
  }

  if (align === 'left') {
    return {
      x: x + getMaxLengthLabelWidth(labels) + HEIGHT + PADDING * 2,
      y: y + barHeight * colorRatio + PADDING
    };
  }

  if (align === 'right') {
    return {
      x: x + width - (getMaxLengthLabelWidth(labels) + padding.X + PADDING * 3 + HEIGHT),
      y: y + barHeight * colorRatio + PADDING
    };
  }
}

function spectrumLegend(ctx, model) {
  var labelsStartPoint = getLabelsStartPoint(model);
  var barStartPoint = getBarStartPoint(model);
  drawLabels(ctx, spectrumLegend_objectSpread(spectrumLegend_objectSpread({}, model), labelsStartPoint));
  drawBar(ctx, spectrumLegend_objectSpread(spectrumLegend_objectSpread({}, model), barStartPoint));
}
function spectrumTooltip(ctx, model) {
  var _ref = getTooltipArrowPoint(model),
      x = _ref.x,
      y = _ref.y;

  var PADDING = spectrumLegendTooltip.PADDING,
      POINT_HEIGHT = spectrumLegendTooltip.POINT_HEIGHT,
      POINT_WIDTH = spectrumLegendTooltip.POINT_WIDTH;
  var align = model.align,
      text = model.text,
      color = model.color;
  var labelWidth = getTextWidth(text);
  var width = labelWidth + PADDING * 2;
  var height = SPECTRUM_LEGEND_LABEL_HEIGHT + PADDING * 2;
  var direction = align;
  var boxStartX = x;
  var boxStartY = y;

  if (align === 'top') {
    boxStartY += POINT_HEIGHT;
  } else if (align === 'right') {
    boxStartX -= width / 2 + POINT_HEIGHT;
    boxStartY -= height / 2;
  } else if (align === 'left') {
    boxStartX += width / 2 + POINT_HEIGHT;
    boxStartY -= height / 2;
  } else if (align === 'bottom') {
    boxStartY -= height + POINT_HEIGHT;
  }

  var points = getBubbleArrowPoints(align, {
    x: x,
    y: y
  }, {
    visible: true,
    width: POINT_WIDTH,
    height: POINT_HEIGHT
  });
  bubbleLabel(ctx, {
    type: 'bubbleLabel',
    bubble: {
      x: boxStartX - width / 2,
      y: boxStartY,
      width: width,
      height: height,
      points: points,
      direction: direction,
      fill: color
    },
    label: {
      text: text,
      x: boxStartX,
      y: boxStartY + height / 2,
      style: [{
        font: 'normal 11px Arial',
        fillStyle: '#333333',
        textAlign: 'center',
        textBaseline: 'middle'
      }]
    }
  });
}
;// CONCATENATED MODULE: ./src/store/layout.ts







function layout_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function layout_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { layout_ownKeys(Object(source), true).forEach(function (key) { layout_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { layout_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function layout_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








var padding = {
  X: 10,
  Y: 15
};
var X_AXIS_HEIGHT = 20;
var Y_AXIS_MIN_WIDTH = 40;
function isVerticalAlign(align) {
  return align === 'top' || align === 'bottom';
}

function getValidRectSize(size, width, height) {
  var _size$height, _size$width;

  return {
    height: (_size$height = size === null || size === void 0 ? void 0 : size.height) !== null && _size$height !== void 0 ? _size$height : height,
    width: (_size$width = size === null || size === void 0 ? void 0 : size.width) !== null && _size$width !== void 0 ? _size$width : width
  };
}

function getDefaultXAxisHeight(size) {
  var _size$xAxis;

  return (_size$xAxis = size.xAxis) !== null && _size$xAxis !== void 0 && _size$xAxis.height && !size.yAxis ? size.xAxis.height : X_AXIS_HEIGHT;
}

function getDefaultYAxisXPoint(yAxisRectParam) {
  var yAxisTitle = yAxisRectParam.yAxisTitle,
      isRightSide = yAxisRectParam.isRightSide,
      visibleSecondaryYAxis = yAxisRectParam.visibleSecondaryYAxis;
  var yAxisWidth = getDefaultYAxisWidth(yAxisRectParam);
  return isRightSide && visibleSecondaryYAxis ? Math.max(yAxisTitle.x + yAxisTitle.width - yAxisWidth, 0) : yAxisTitle.x;
}

function getYAxisXPoint(yAxisRectParam) {
  var chartSize = yAxisRectParam.chartSize,
      legend = yAxisRectParam.legend,
      circleLegend = yAxisRectParam.circleLegend,
      hasCenterYAxis = yAxisRectParam.hasCenterYAxis,
      maxLabelWidth = yAxisRectParam.maxLabelWidth;
  var width = chartSize.width;
  var align = legend.align;
  var yAxisWidth = getDefaultYAxisWidth(yAxisRectParam);
  var x = getDefaultYAxisXPoint(yAxisRectParam);

  if (hasCenterYAxis) {
    yAxisWidth = maxLabelWidth + (TICK_SIZE + padding.X) * 2;
    x = (width - legend.width - yAxisWidth + padding.X * 2) / 2;
  }

  if (legend.visible && align === 'left') {
    x = getDefaultYAxisXPoint(yAxisRectParam);
  }

  if (circleLegend.visible && align === 'left') {
    x = Math.max(circleLegend.width + padding.X, x);
  }

  return x;
}

function getYAxisYPoint(_ref) {
  var yAxisTitle = _ref.yAxisTitle;
  return yAxisTitle.y + yAxisTitle.height;
}

function getDefaultYAxisWidth(_ref2) {
  var _size$width2, _size;

  var maxLabelWidth = _ref2.maxLabelWidth,
      size = _ref2.size,
      isRightSide = _ref2.isRightSide;
  return (_size$width2 = size === null || size === void 0 ? void 0 : (_size = size[isRightSide ? 'secondaryYAxis' : 'yAxis']) === null || _size === void 0 ? void 0 : _size.width) !== null && _size$width2 !== void 0 ? _size$width2 : maxLabelWidth;
}

function getYAxisWidth(yAxisRectParam) {
  var hasCenterYAxis = yAxisRectParam.hasCenterYAxis,
      hasXYAxis = yAxisRectParam.hasXYAxis,
      maxLabelWidth = yAxisRectParam.maxLabelWidth,
      _yAxisRectParam$visib = yAxisRectParam.visibleSecondaryYAxis,
      visibleSecondaryYAxis = _yAxisRectParam$visib === void 0 ? false : _yAxisRectParam$visib,
      _yAxisRectParam$isRig = yAxisRectParam.isRightSide,
      isRightSide = _yAxisRectParam$isRig === void 0 ? false : _yAxisRectParam$isRig;
  var yAxisWidth = getDefaultYAxisWidth(yAxisRectParam);

  if (hasCenterYAxis && !isRightSide) {
    yAxisWidth = maxLabelWidth + (TICK_SIZE + padding.X) * 2;
  } else if (!hasXYAxis || isRightSide && !visibleSecondaryYAxis) {
    yAxisWidth = 0;
  }

  return yAxisWidth;
}

function getYAxisHeight(_ref3) {
  var _size$yAxis, _size$plot;

  var chartSize = _ref3.chartSize,
      legend = _ref3.legend,
      yAxisTitle = _ref3.yAxisTitle,
      hasXYAxis = _ref3.hasXYAxis,
      size = _ref3.size,
      xAxisTitleHeight = _ref3.xAxisTitleHeight;
  var height = chartSize.height;
  var align = legend.align,
      legendHeight = legend.height;
  var xAxisHeight = getDefaultXAxisHeight(size);
  var y = yAxisTitle.y + yAxisTitle.height;
  var yAxisHeight = height - y - xAxisHeight - xAxisTitleHeight;

  if (!hasXYAxis) {
    yAxisHeight = height - y;
  }

  if (legend.visible) {
    var topArea = Math.max(y, legendHeight);

    if (align === 'top') {
      yAxisHeight = height - topArea - (hasXYAxis ? X_AXIS_HEIGHT + xAxisTitleHeight : 0);
    } else if (align === 'bottom') {
      yAxisHeight = height - y - X_AXIS_HEIGHT - xAxisTitleHeight - legendHeight;
    }
  }

  if (!(size !== null && size !== void 0 && (_size$yAxis = size.yAxis) !== null && _size$yAxis !== void 0 && _size$yAxis.height) && size !== null && size !== void 0 && (_size$plot = size.plot) !== null && _size$plot !== void 0 && _size$plot.height) {
    yAxisHeight = size.plot.height;
  }

  return yAxisHeight;
}

function getYAxisRect(yAxisRectParam) {
  var size = yAxisRectParam.size,
      _yAxisRectParam$isRig2 = yAxisRectParam.isRightSide,
      isRightSide = _yAxisRectParam$isRig2 === void 0 ? false : _yAxisRectParam$isRig2;
  var x = getYAxisXPoint(yAxisRectParam);
  var y = getYAxisYPoint(yAxisRectParam);
  var yAxisWidth = getYAxisWidth(yAxisRectParam);
  var yAxisHeight = getYAxisHeight(yAxisRectParam);
  return layout_objectSpread({
    x: x,
    y: y
  }, getValidRectSize(isRightSide ? size === null || size === void 0 ? void 0 : size.secondaryYAxis : size === null || size === void 0 ? void 0 : size.yAxis, yAxisWidth, yAxisHeight));
}

function getXAxisWidth(_ref4) {
  var chartSize = _ref4.chartSize,
      yAxis = _ref4.yAxis,
      hasCenterYAxis = _ref4.hasCenterYAxis,
      legend = _ref4.legend,
      circleLegend = _ref4.circleLegend,
      secondaryYAxis = _ref4.secondaryYAxis,
      xAxisData = _ref4.xAxisData;
  var width = chartSize.width;
  var align = legend.align,
      legendWidth = legend.width;
  var legendVerticalAlign = isVerticalAlign(align);
  var xAxisWidth;

  if (legendVerticalAlign) {
    xAxisWidth = width - (yAxis.x + yAxis.width + padding.X);

    if (circleLegend.visible) {
      xAxisWidth -= circleLegend.width;
    }
  } else {
    xAxisWidth = width - (yAxis.width + Math.max(legendWidth, circleLegend.visible ? circleLegend.width : 0));
  }

  if (hasCenterYAxis) {
    xAxisWidth = width - (legendVerticalAlign ? 0 : legendWidth) - padding.X * 2;
  }

  if (secondaryYAxis.width) {
    xAxisWidth -= secondaryYAxis.width;
  }

  if (xAxisData !== null && xAxisData !== void 0 && xAxisData.maxLabelWidth) {
    // subtract half of the maximum label length to secure margin size
    xAxisWidth -= xAxisData.maxLabelWidth * 0.5;
  }

  return xAxisWidth;
}

function getXAxisHeight(xAxisData) {
  var _xAxisData$maxHeight;

  var hasXYAxis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (!hasXYAxis) {
    return 0;
  }

  return (_xAxisData$maxHeight = xAxisData === null || xAxisData === void 0 ? void 0 : xAxisData.maxHeight) !== null && _xAxisData$maxHeight !== void 0 ? _xAxisData$maxHeight : X_AXIS_HEIGHT;
}

function getXAxisRect(xAxisRectParam) {
  var hasXYAxis = xAxisRectParam.hasXYAxis,
      hasCenterYAxis = xAxisRectParam.hasCenterYAxis,
      yAxis = xAxisRectParam.yAxis,
      size = xAxisRectParam.size,
      xAxisData = xAxisRectParam.xAxisData;
  var x = hasCenterYAxis ? padding.X * 2 : yAxis.x + yAxis.width;
  var y = yAxis.y + yAxis.height;
  var xAxisWidth = getXAxisWidth(xAxisRectParam);
  var xAxisHeight = getXAxisHeight(xAxisData, hasXYAxis);
  return layout_objectSpread({
    x: x,
    y: y
  }, getValidRectSize(size === null || size === void 0 ? void 0 : size.xAxis, xAxisWidth, xAxisHeight));
}

function getLegendRect(legendRectParams) {
  var legend = legendRectParams.legend,
      xAxis = legendRectParams.xAxis,
      yAxis = legendRectParams.yAxis,
      chartSize = legendRectParams.chartSize,
      title = legendRectParams.title,
      hasXYAxis = legendRectParams.hasXYAxis,
      secondaryYAxis = legendRectParams.secondaryYAxis,
      xAxisTitleHeight = legendRectParams.xAxisTitleHeight;

  if (!legend.visible) {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }

  var align = legend.align,
      legendWidth = legend.width,
      legendHeight = legend.height;
  var width = chartSize.width;
  var verticalAlign = isVerticalAlign(align);
  var x = xAxis.x + xAxis.width + secondaryYAxis.width + padding.X;
  var y = Math.max(yAxis.y, BUTTON_RECT_SIZE);

  if (verticalAlign) {
    x = (width - legendWidth) / 2;

    if (align === 'top') {
      y = title.y + title.height;
    } else {
      y = yAxis.y + yAxis.height + (hasXYAxis ? xAxis.height + xAxisTitleHeight : padding.Y);
    }
  } else if (align === 'left') {
    x = padding.X;
  }

  return {
    width: legendWidth,
    height: legendHeight,
    x: x,
    y: y
  };
}

function getCircleLegendRect(xAxis, yAxis, align, width) {
  return {
    width: width,
    height: yAxis.height,
    x: align === 'left' ? padding.X : xAxis.x + xAxis.width + padding.X,
    y: yAxis.y
  };
}

function getPlotRect(xAxis, yAxis, size) {
  return layout_objectSpread({
    x: xAxis.x,
    y: yAxis.y
  }, getValidRectSize(size, xAxis.width, yAxis.height));
}

function getTitleRect(chartSize, exportMenu, visible, titleHeight) {
  var point = {
    x: padding.X,
    y: padding.Y
  };
  var marginBottom = 5;
  var width = visible ? chartSize.width - exportMenu.width : 0;
  var height = visible ? Math.max(titleHeight + marginBottom, exportMenu.height) : exportMenu.height;
  return layout_objectSpread({
    width: width,
    height: height
  }, point);
}

function getTopLegendAreaHeight(useSpectrumLegend, legendHeight) {
  return useSpectrumLegend ? SPECTRUM_LEGEND_LABEL_HEIGHT + spectrumLegendBar.PADDING * 2 + spectrumLegendTooltip.POINT_HEIGHT + spectrumLegendTooltip.HEIGHT + padding.Y : legendHeight + padding.Y;
}

function getYAxisTitleRect(_ref5) {
  var chartSize = _ref5.chartSize,
      visible = _ref5.visible,
      title = _ref5.title,
      _ref5$legend = _ref5.legend,
      legendAlign = _ref5$legend.align,
      legendWidth = _ref5$legend.width,
      legendHeight = _ref5$legend.height,
      legendVisible = _ref5$legend.visible,
      useSpectrumLegend = _ref5$legend.useSpectrumLegend,
      hasCenterYAxis = _ref5.hasCenterYAxis,
      visibleSecondaryYAxis = _ref5.visibleSecondaryYAxis,
      _ref5$isRightSide = _ref5.isRightSide,
      isRightSide = _ref5$isRightSide === void 0 ? false : _ref5$isRightSide,
      yAxisTitleHeight = _ref5.yAxisTitleHeight;
  var marginBottom = 5;
  var height = visible ? yAxisTitleHeight + marginBottom : 0;
  var verticalLegendAlign = isVerticalAlign(legendAlign);
  var width = (chartSize.width - (verticalLegendAlign ? padding.X * 2 : legendWidth)) / (visibleSecondaryYAxis ? 2 : 1);
  var point = {
    x: isRightSide ? title.x + width : title.x,
    y: title.y + title.height
  };

  if (legendVisible) {
    if (legendAlign === 'left') {
      point.x += legendWidth;
    } else if (legendAlign === 'top') {
      point.y += getTopLegendAreaHeight(useSpectrumLegend, legendHeight);
    }
  }

  if (hasCenterYAxis) {
    point.x = (width + padding.X * 2) / 2;
  }

  return layout_objectSpread({
    height: height,
    width: width
  }, point);
}

function getXAxisTitleRect(visible, xAxis, xAxisTitleHeight) {
  var point = {
    x: xAxis.x,
    y: xAxis.y + xAxis.height
  };
  var height = visible ? xAxisTitleHeight : 0;
  var width = visible ? xAxis.width : 0;
  return layout_objectSpread({
    height: height,
    width: width
  }, point);
}

function getExportMenuRect(chartSize, visible) {
  var marginY = 5;
  var x = visible ? padding.X + chartSize.width - BUTTON_RECT_SIZE : padding.X + chartSize.width;
  var y = padding.Y;
  var height = visible ? BUTTON_RECT_SIZE + marginY : 0;
  var width = visible ? BUTTON_RECT_SIZE : 0;
  return {
    x: x,
    y: y,
    height: height,
    width: width
  };
}

function getResetButtonRect(exportMenu, useResetButton) {
  var marginY = 5;
  var x = useResetButton ? exportMenu.x - BUTTON_RECT_SIZE - padding.X : 0;
  var y = useResetButton ? exportMenu.y : 0;
  var height = useResetButton ? BUTTON_RECT_SIZE + marginY : 0;
  var width = useResetButton ? BUTTON_RECT_SIZE : 0;
  return {
    x: x,
    y: y,
    height: height,
    width: width
  };
}

function isUsingResetButton(options) {
  var _options$series;

  return !!((_options$series = options.series) !== null && _options$series !== void 0 && _options$series.zoomable);
}
function isExportMenuVisible(options) {
  var _options$exportMenu;

  var visible = (_options$exportMenu = options.exportMenu) === null || _options$exportMenu === void 0 ? void 0 : _options$exportMenu.visible;
  return isUndefined(visible) ? true : visible;
}

function getYAxisMaxLabelWidth(maxLabelLength) {
  return maxLabelLength ? maxLabelLength + padding.X : Y_AXIS_MIN_WIDTH;
}

function pickOptionSize(option) {
  if (!option || isUndefined(option.width) && isUndefined(option.height)) {
    return null;
  }

  return pick(option, 'width', 'height');
}

function validOffsetValue(axis, plot, sizeKey) {
  var axisSize = axis[sizeKey];
  var plotSize = plot[sizeKey];

  if (isNumber(axisSize) && isNumber(plotSize)) {
    return Math.max(axisSize, plotSize);
  }
}

function getOptionSize(options) {
  var xAxis = pickOptionSize(options.xAxis);
  var yAxisOptions = getYAxisOption(options);
  var yAxis = pickOptionSize(yAxisOptions.yAxis);
  var secondaryYAxis = pickOptionSize(yAxisOptions.secondaryYAxis);
  var plot = pickOptionSize(options.plot);

  if (plot) {
    /*
    If both the width of the x-axis and the width of the plot are entered,
    set the maximum value.
    */
    if (xAxis) {
      xAxis.width = plot.width = validOffsetValue(xAxis, plot, 'width');
    }
    /*
    If both the height of the y-axis and the height of the plot are entered,
    set the maximum value.
    */


    if (yAxis) {
      yAxis.height = plot.height = validOffsetValue(yAxis, plot, 'height');
    }

    if (secondaryYAxis) {
      secondaryYAxis.height = plot.height = validOffsetValue(secondaryYAxis, plot, 'height');
    }
  }

  return {
    xAxis: xAxis,
    yAxis: yAxis,
    plot: plot,
    secondaryYAxis: secondaryYAxis
  };
}

function getAxisTitleHeight(axisTheme) {
  var offsetY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var fontSize = Array.isArray(axisTheme) ? Math.max(axisTheme[0].title.fontSize, axisTheme[1].title.fontSize) : axisTheme.title.fontSize;
  return fontSize + offsetY;
}

function adjustAxisSize(_ref6, layout, legendState) {
  var width = _ref6.width,
      height = _ref6.height;

  if (width < 0 || height < 0) {
    return;
  }

  var title = layout.title,
      yAxisTitle = layout.yAxisTitle,
      yAxis = layout.yAxis,
      xAxis = layout.xAxis,
      xAxisTitle = layout.xAxisTitle,
      legend = layout.legend,
      secondaryYAxis = layout.secondaryYAxis;
  var align = legendState.align;
  var hasVerticalLegend = isVerticalAlign(align);
  var legendHeight = hasVerticalLegend ? legend.height : 0;
  var diffHeight = xAxis.height + xAxisTitle.height + yAxis.height + yAxisTitle.height + title.height + legendHeight - height;

  if (diffHeight > 0) {
    yAxis.height -= diffHeight;
    xAxis.y -= diffHeight;
    xAxisTitle.y -= diffHeight;

    if (hasVerticalLegend) {
      legend.y -= diffHeight;
    }
  }

  secondaryYAxis.x = xAxis.x + xAxis.width;
  secondaryYAxis.height = yAxis.height;
}

function getCircularAxisTitleRect(plot, axisTheme, circularAxis) {
  var _title$offsetY;

  if (!circularAxis) {
    return layout_objectSpread({}, plot);
  }

  var x = plot.x,
      y = plot.y;
  var centerX = circularAxis.centerX,
      centerY = circularAxis.centerY,
      axisSize = circularAxis.axisSize,
      title = circularAxis.title,
      outer = circularAxis.radius.outer;
  var offsetY = (_title$offsetY = title === null || title === void 0 ? void 0 : title.offsetY) !== null && _title$offsetY !== void 0 ? _title$offsetY : 0;
  return {
    x: centerX + x - axisSize / 2,
    y: centerY + y - outer / 2,
    width: axisSize,
    height: axisTheme.title.fontSize + offsetY
  };
}

function hasXYAxes(series) {
  return !(series.pie || series.radar || series.treemap || series.radialBar || series.gauge);
}

function getYAxisOptions(options, hasXYAxis) {
  return hasXYAxis ? getYAxisOption(options) : {
    yAxis: null,
    secondaryYAxis: null
  };
}

var layout = {
  name: 'layout',
  state: function state() {
    return {
      layout: {}
    };
  },
  action: {
    setLayout: function setLayout(_ref7) {
      var _getAxisTitleHeight, _axes$yAxis, _axes$yAxis$title, _getAxisTitleHeight2, _axes$xAxis, _axes$xAxis$title, _options$chart, _axes$secondaryYAxis, _options$xAxis;

      var state = _ref7.state;
      var legendState = state.legend,
          theme = state.theme,
          circleLegendState = state.circleLegend,
          series = state.series,
          options = state.options,
          chart = state.chart,
          axes = state.axes,
          radialAxes = state.radialAxes;
      var width = chart.width,
          height = chart.height;
      var chartSize = {
        height: height - padding.Y * 2,
        width: width - padding.X * 2
      };
      var hasCenterYAxis = series.bar ? isCenterYAxis(options) : false;
      var hasXYAxis = hasXYAxes(series);
      var optionSize = getOptionSize(options);

      var _getYAxisOptions = getYAxisOptions(options, hasXYAxis),
          yAxisOption = _getYAxisOptions.yAxis,
          secondaryYAxisOption = _getYAxisOptions.secondaryYAxis;

      var visibleSecondaryYAxis = !!secondaryYAxisOption;
      var titleHeight = theme.title.fontSize;
      var yAxisTitleHeight = (_getAxisTitleHeight = getAxisTitleHeight(theme.yAxis, axes === null || axes === void 0 ? void 0 : (_axes$yAxis = axes.yAxis) === null || _axes$yAxis === void 0 ? void 0 : (_axes$yAxis$title = _axes$yAxis.title) === null || _axes$yAxis$title === void 0 ? void 0 : _axes$yAxis$title.offsetY)) !== null && _getAxisTitleHeight !== void 0 ? _getAxisTitleHeight : 0;
      var xAxisTitleHeight = (_getAxisTitleHeight2 = getAxisTitleHeight(theme.xAxis, axes === null || axes === void 0 ? void 0 : (_axes$xAxis = axes.xAxis) === null || _axes$xAxis === void 0 ? void 0 : (_axes$xAxis$title = _axes$xAxis.title) === null || _axes$xAxis$title === void 0 ? void 0 : _axes$xAxis$title.offsetY)) !== null && _getAxisTitleHeight2 !== void 0 ? _getAxisTitleHeight2 : 0; // Don't change the order!
      // exportMenu -> resetButton -> title -> yAxis.title -> yAxis -> secondaryYAxisTitle -> secondaryYAxis -> xAxis -> xAxis.title -> legend -> circleLegend -> plot -> circularAxis.title

      var exportMenu = getExportMenuRect(chartSize, isExportMenuVisible(options));
      var resetButton = getResetButtonRect(exportMenu, isUsingResetButton(options));
      var btnAreaRect = exportMenu.height ? exportMenu : resetButton;
      var title = getTitleRect(chartSize, btnAreaRect, !!((_options$chart = options.chart) !== null && _options$chart !== void 0 && _options$chart.title), titleHeight);
      var yAxisTitleVisible = !!(yAxisOption !== null && yAxisOption !== void 0 && yAxisOption.title) || !!(secondaryYAxisOption !== null && secondaryYAxisOption !== void 0 && secondaryYAxisOption.title);
      var yAxisTitle = getYAxisTitleRect({
        chartSize: chartSize,
        visible: yAxisTitleVisible,
        title: title,
        legend: legendState,
        hasCenterYAxis: hasCenterYAxis,
        visibleSecondaryYAxis: visibleSecondaryYAxis,
        yAxisTitleHeight: yAxisTitleHeight
      });
      var yAxis = getYAxisRect({
        chartSize: chartSize,
        legend: legendState,
        circleLegend: circleLegendState,
        yAxisTitle: yAxisTitle,
        hasCenterYAxis: hasCenterYAxis,
        hasXYAxis: hasXYAxis,
        maxLabelWidth: getYAxisMaxLabelWidth(axes === null || axes === void 0 ? void 0 : axes.yAxis.maxLabelWidth),
        size: optionSize,
        xAxisTitleHeight: xAxisTitleHeight
      });
      var secondaryYAxisTitle = getYAxisTitleRect({
        chartSize: chartSize,
        visible: yAxisTitleVisible,
        title: title,
        legend: legendState,
        hasCenterYAxis: hasCenterYAxis,
        isRightSide: true,
        visibleSecondaryYAxis: visibleSecondaryYAxis,
        yAxisTitleHeight: yAxisTitleHeight
      });
      var secondaryYAxis = getYAxisRect({
        chartSize: chartSize,
        legend: legendState,
        circleLegend: circleLegendState,
        yAxisTitle: secondaryYAxisTitle,
        hasCenterYAxis: hasCenterYAxis,
        hasXYAxis: hasXYAxis,
        maxLabelWidth: getYAxisMaxLabelWidth(axes === null || axes === void 0 ? void 0 : (_axes$secondaryYAxis = axes.secondaryYAxis) === null || _axes$secondaryYAxis === void 0 ? void 0 : _axes$secondaryYAxis.maxLabelWidth),
        size: optionSize,
        isRightSide: true,
        visibleSecondaryYAxis: visibleSecondaryYAxis,
        xAxisTitleHeight: xAxisTitleHeight
      });
      var xAxis = getXAxisRect({
        chartSize: chartSize,
        yAxis: yAxis,
        secondaryYAxis: secondaryYAxis,
        legend: legendState,
        circleLegend: circleLegendState,
        hasCenterYAxis: hasCenterYAxis,
        hasXYAxis: hasXYAxis,
        size: optionSize,
        xAxisData: axes === null || axes === void 0 ? void 0 : axes.xAxis
      });
      var xAxisTitle = getXAxisTitleRect(!!((_options$xAxis = options.xAxis) !== null && _options$xAxis !== void 0 && _options$xAxis.title), xAxis, xAxisTitleHeight);
      var legend = getLegendRect({
        chartSize: chartSize,
        xAxis: xAxis,
        yAxis: yAxis,
        secondaryYAxis: secondaryYAxis,
        title: title,
        legend: legendState,
        hasXYAxis: hasXYAxis,
        xAxisTitleHeight: xAxisTitleHeight
      });
      adjustAxisSize(chartSize, {
        title: title,
        yAxisTitle: yAxisTitle,
        yAxis: yAxis,
        xAxis: xAxis,
        xAxisTitle: xAxisTitle,
        legend: legend,
        secondaryYAxis: secondaryYAxis
      }, legendState);
      var circleLegend = getCircleLegendRect(xAxis, yAxis, legendState.align, circleLegendState.width);
      var plot = getPlotRect(xAxis, yAxis, optionSize.plot);
      var circularAxisTitle = getCircularAxisTitleRect(plot, theme.circularAxis, radialAxes === null || radialAxes === void 0 ? void 0 : radialAxes.circularAxis);
      store_extend(state.layout, {
        chart: {
          x: 0,
          y: 0,
          width: width,
          height: height
        },
        title: title,
        plot: plot,
        legend: legend,
        circleLegend: circleLegend,
        xAxis: xAxis,
        xAxisTitle: xAxisTitle,
        yAxis: yAxis,
        yAxisTitle: yAxisTitle,
        exportMenu: exportMenu,
        resetButton: resetButton,
        secondaryYAxisTitle: secondaryYAxisTitle,
        secondaryYAxis: secondaryYAxis,
        circularAxisTitle: circularAxisTitle
      });
    }
  },
  observe: {
    updateLayoutObserve: function updateLayoutObserve() {
      this.dispatch('setLayout');
    }
  }
};
/* harmony default export */ var store_layout = (layout);
;// CONCATENATED MODULE: ./src/helpers/range.ts


function isRangeValue(value) {
  return Array.isArray(value) && value.length === 2;
}
function isRangeData(data) {
  return Array.isArray(data) && isRangeValue(getFirstValidValue(data));
}
function isZooming(categories, zoomRange) {
  return !!(zoomRange && (zoomRange[0] !== 0 || zoomRange[1] !== categories.length - 1));
}
function getDataInRange(data, range) {
  if (!range) {
    return data;
  }

  return data.slice(range[0], range[1] + 1);
}
;// CONCATENATED MODULE: ./src/store/category.ts
function category_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function category_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { category_ownKeys(Object(source), true).forEach(function (key) { category_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { category_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function category_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





















function makeRawCategories(series, categories) {
  if (categories) {
    return categories;
  }

  var firstValues = new Set();
  Object.keys(series).forEach(function (key) {
    var _series$key$data;

    if (key === 'pie' || key === 'gauge') {
      return;
    }

    ((_series$key$data = series[key].data) !== null && _series$key$data !== void 0 ? _series$key$data : series[key]).forEach(function (_ref) {
      var data = _ref.data,
          name = _ref.name,
          visible = _ref.visible;

      if (Array.isArray(data)) {
        data.forEach(function (datum) {
          if (!isNull(datum)) {
            var rawXValue = getCoordinateXValue(datum);
            firstValues.add(isNumber(rawXValue) ? rawXValue : rawXValue.toString());
          }
        });
      } else if (key === 'bullet' && isUndefined(visible) || visible) {
        firstValues.add(name);
      }
    });
  });
  return Array.from(firstValues).sort(sortCategories).map(function (category) {
    return String(category);
  });
}
var category = {
  name: 'category',
  state: function state(_ref2) {
    var categories = _ref2.categories,
        series = _ref2.series;
    return {
      categories: makeRawCategories(series, categories)
    };
  },
  action: {
    setCategory: function setCategory(_ref3) {
      var state = _ref3.state,
          computed = _ref3.computed;
      var viewRange = computed.viewRange;
      var categories = state.rawCategories;

      if (viewRange) {
        if (Array.isArray(categories)) {
          categories = getDataInRange(categories, viewRange);
        } else {
          categories = category_objectSpread(category_objectSpread({}, categories), {}, {
            x: getDataInRange(categories.x, viewRange)
          });
        }
      }

      state.categories = categories;
      this.notify(state, 'categories');
    },
    initCategory: function initCategory(_ref4) {
      var initStoreState = _ref4.initStoreState,
          state = _ref4.state;
      var zoomRange = state.zoomRange;
      var categories = makeRawCategories(initStoreState.series);

      if (zoomRange && Array.isArray(categories)) {
        categories = getDataInRange(categories, zoomRange);
      }

      state.categories = categories;
      this.notify(state, 'categories');
    },
    removeCategoryByName: function removeCategoryByName(_ref5, name) {
      var state = _ref5.state;
      var index = state.categories.findIndex(function (seriesName) {
        return seriesName === name;
      });
      state.categories.splice(index, 1);
      this.notify(state, 'axes');
    }
  },
  observe: {
    updateCategory: function updateCategory() {
      this.dispatch('setCategory');
    }
  }
};
/* harmony default export */ var store_category = (category);
;// CONCATENATED MODULE: ./src/store/seriesData.ts
function seriesData_toConsumableArray(arr) { return seriesData_arrayWithoutHoles(arr) || seriesData_iterableToArray(arr) || seriesData_unsupportedIterableToArray(arr) || seriesData_nonIterableSpread(); }

function seriesData_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function seriesData_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function seriesData_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return seriesData_arrayLikeToArray(arr); }

function seriesData_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function seriesData_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { seriesData_ownKeys(Object(source), true).forEach(function (key) { seriesData_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { seriesData_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function seriesData_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function seriesData_slicedToArray(arr, i) { return seriesData_arrayWithHoles(arr) || seriesData_iterableToArrayLimit(arr, i) || seriesData_unsupportedIterableToArray(arr, i) || seriesData_nonIterableRest(); }

function seriesData_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function seriesData_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return seriesData_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return seriesData_arrayLikeToArray(o, minLen); }

function seriesData_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function seriesData_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function seriesData_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }































function initRange(series, categories) {
  var rawCategoriesLength;

  if (categories) {
    rawCategoriesLength = Array.isArray(categories) ? categories.length : categories.x.length;
  } else {
    rawCategoriesLength = Object.keys(makeRawCategories(series, categories)).length;
  }

  return [0, rawCategoriesLength - 1];
}

function initSelectionRange(series, options, categories) {
  var _options$series;

  if (!(series.line || series.area || series.column) || !((_options$series = options.series) !== null && _options$series !== void 0 && _options$series.rangeSelectable)) {
    return;
  }

  return initRange(series, categories);
}

function initZoomRange(series, options, categories) {
  var _options$series2;

  if (!(series.line || series.area) || !((_options$series2 = options.series) !== null && _options$series2 !== void 0 && _options$series2.zoomable)) {
    return;
  }

  return initRange(series, categories);
}

function initShiftRange(series, options, categories) {
  var _options$series3;

  if (!(series.line || series.area || series.column || series.heatmap) || !((_options$series3 = options.series) !== null && _options$series3 !== void 0 && _options$series3.shift)) {
    return;
  }

  return initRange(series, categories);
}

function getCoordinateDataRange(data, rawCategories, zoomRange) {
  var _zoomRange = seriesData_slicedToArray(zoomRange, 2),
      zoomStart = _zoomRange[0],
      zoomEnd = _zoomRange[1];

  var start, end;
  range(zoomStart, zoomEnd + 1).forEach(function (i) {
    var idx = data.findIndex(function (datum) {
      return getCoordinateXValue(datum).toString() === rawCategories[i];
    });

    if (idx !== -1) {
      if (isUndefined(start)) {
        start = idx;
      }

      if (!isUndefined(start)) {
        var _end;

        end = Math.max(idx, (_end = end) !== null && _end !== void 0 ? _end : 0);
      }
    }
  });
  return [start, end];
}

function getSeriesColors(colors, colorIndex, size, isColorByCategories) {
  return isColorByCategories ? colors.slice(0, size + 1) : colors[colorIndex % colors.length];
}

function getSeriesDataInRange(data, rawCategories, chartType, zoomRange) {
  if (!zoomRange) {
    return data;
  }

  var _zoomRange2 = seriesData_slicedToArray(zoomRange, 2),
      startIdx = _zoomRange2[0],
      endIdx = _zoomRange2[1];

  var firstValidValue = getFirstValidValue(data);
  var isCoordinateChart = chartType !== 'area' && !isUndefined(firstValidValue) && !isNumber(firstValidValue);

  if (isCoordinateChart) {
    var _getCoordinateDataRan = getCoordinateDataRange(data, rawCategories, zoomRange);

    var _getCoordinateDataRan2 = seriesData_slicedToArray(_getCoordinateDataRan, 2);

    startIdx = _getCoordinateDataRan2[0];
    endIdx = _getCoordinateDataRan2[1];
  } else {
    startIdx = startIdx > 1 ? startIdx - 1 : startIdx;
    endIdx = endIdx < rawCategories.length - 1 ? endIdx + 1 : endIdx;
  }

  return data.slice(startIdx, endIdx + 1);
}

function isCoordinateTypeSeries(series, chartType) {
  return isCoordinateSeries(series) && (isUndefined(chartType) || chartType === 'line' || chartType === 'scatter');
}

function isSeriesAlreadyExist(series, seriesName, data) {
  return series[seriesName].some(function (_ref) {
    var label = _ref.label;
    return label === data.name;
  });
}

function isTreemapSeriesAlreadyExist(series, data) {
  return series.treemap.some(function (_ref2) {
    var label = _ref2.label;
    return label === data.label;
  });
}

function isHeatmapSeriesAlreadyExist(categories, category) {
  return includes(categories.y, category);
}

function initDisabledSeries(series) {
  var nestedPieChart = hasNestedPieSeries(series);
  var disabledSeries = [];

  if (nestedPieChart) {
    series.pie.forEach(function (_ref3) {
      var data = _ref3.data;
      data.forEach(function (datum) {
        if (isBoolean(datum.visible) && !datum.visible) {
          disabledSeries.push(datum.name);
        }
      });
    });
  } else {
    Object.keys(series).forEach(function (type) {
      series[type].forEach(function (_ref4) {
        var name = _ref4.name,
            visible = _ref4.visible;

        if (isBoolean(visible) && !visible) {
          disabledSeries.push(name);
        }
      });
    });
  }

  return disabledSeries;
}

var seriesData = {
  name: 'seriesData',
  state: function state(_ref5) {
    var series = _ref5.series,
        categories = _ref5.categories,
        options = _ref5.options;
    return {
      rawCategories: makeRawCategories(series, categories),
      series: seriesData_objectSpread({}, series),
      selectionRange: initSelectionRange(series, options, categories),
      zoomRange: initZoomRange(series, options, categories),
      shiftRange: initShiftRange(series, options, categories),
      disabledSeries: initDisabledSeries(series)
    };
  },
  action: {
    setSeriesData: function setSeriesData(_ref6) {
      var state = _ref6.state,
          initStoreState = _ref6.initStoreState;
      var rawSeries = deepCopy(initStoreState.series);
      var disabledSeries = state.disabledSeries,
          theme = state.theme,
          zoomRange = state.zoomRange,
          rawCategories = state.rawCategories;
      var newSeriesData = {};
      var colorIndex = 0;
      Object.keys(rawSeries).forEach(function (seriesName) {
        var _originSeriesData$0$d, _originSeriesData$, _originSeriesData$$da;

        var _seriesName = theme.series[seriesName],
            colors = _seriesName.colors,
            iconTypes = _seriesName.iconTypes;
        var originSeriesData = rawSeries[seriesName].map(function (series) {
          var isColorByCategories = !!series.colorByCategories;
          var size = isColorByCategories ? rawCategories.length : 1;
          var color = colors ? getSeriesColors(colors, colorIndex, size, isColorByCategories) : '';
          colorIndex += size;
          return seriesData_objectSpread(seriesData_objectSpread({}, series), {}, {
            rawData: series.data,
            data: getSeriesDataInRange(series.data, rawCategories, seriesName, zoomRange),
            color: color
          });
        });

        if (seriesName === 'scatter') {
          originSeriesData = originSeriesData.map(function (series, idx) {
            return seriesData_objectSpread(seriesData_objectSpread({}, series), {}, {
              iconType: iconTypes ? iconTypes[idx] : 'circle'
            });
          });
        }

        var seriesCount = originSeriesData.length;
        var seriesGroupCount = (_originSeriesData$0$d = (_originSeriesData$ = originSeriesData[0]) === null || _originSeriesData$ === void 0 ? void 0 : (_originSeriesData$$da = _originSeriesData$.data) === null || _originSeriesData$$da === void 0 ? void 0 : _originSeriesData$$da.length) !== null && _originSeriesData$0$d !== void 0 ? _originSeriesData$0$d : 0;
        var data = originSeriesData.filter(function (_ref7) {
          var name = _ref7.name;
          return !disabledSeries.includes(name);
        });
        newSeriesData[seriesName] = {
          seriesCount: seriesCount,
          seriesGroupCount: seriesGroupCount,
          data: data,
          colors: colors
        };
      });
      store_extend(state.series, newSeriesData);
    },
    disableSeries: function disableSeries(_ref8, name) {
      var state = _ref8.state;
      state.disabledSeries.push(name);
      this.notify(state, 'disabledSeries');

      if (state.series.bullet) {
        this.dispatch('removeCategoryByName', name);
      }
    },
    enableSeries: function enableSeries(_ref9, name) {
      var state = _ref9.state;
      var index = state.disabledSeries.findIndex(function (disabled) {
        return disabled === name;
      });
      state.disabledSeries.splice(index, 1);
      this.notify(state, 'disabledSeries');

      if (state.series.bullet) {
        state.categories = state.series.bullet.data.map(function (_ref10) {
          var seriesName = _ref10.name;
          return seriesName;
        });
        this.notify(state, 'axes');
      }
    },
    selection: function selection(_ref11, rangeCategories) {
      var state = _ref11.state;
      var rawCategories = state.rawCategories;
      state.selectionRange = rangeCategories.map(function (rangeCategory) {
        return rawCategories.findIndex(function (category) {
          return category === rangeCategory;
        });
      });
      this.notify(state, 'selectionRange');
    },
    zoom: function zoom(_ref12, rangeCategories) {
      var state = _ref12.state;
      var rawCategories = state.rawCategories;
      state.zoomRange = rangeCategories.map(function (rangeCategory) {
        return rawCategories.findIndex(function (category) {
          return category === rangeCategory;
        });
      });
      this.notify(state, 'zoomRange');
    },
    resetZoom: function resetZoom(_ref13) {
      var state = _ref13.state,
          initStoreState = _ref13.initStoreState;
      var series = initStoreState.series,
          options = initStoreState.options;
      var rawCategories = state.rawCategories;
      state.zoomRange = initZoomRange(series, options, rawCategories);
      this.notify(state, 'zoomRange');
    },
    addData: function addData(_ref14, _ref15) {
      var state = _ref14.state,
          initStoreState = _ref14.initStoreState;
      var data = _ref15.data,
          category = _ref15.category,
          chartType = _ref15.chartType;
      var series = initStoreState.series;
      var coordinateChart = isCoordinateTypeSeries(state.series, chartType);
      var categories = initStoreState.categories;
      categories = series.heatmap ? categories.x : categories;

      if (category && Array.isArray(categories)) {
        var isExist = categories.some(function (c) {
          return c === category;
        });

        if (!isExist) {
          categories.push(category);

          if (Array.isArray(state.shiftRange)) {
            var _state$shiftRange = seriesData_slicedToArray(state.shiftRange, 2),
                start = _state$shiftRange[0],
                end = _state$shiftRange[1];

            state.shiftRange = [start + 1, end + 1];
          }
        }
      }

      if (chartType) {
        series[chartType].forEach(function (datum, idx) {
          datum.data.push(data[idx]);
        });
      } else {
        var _Object$keys = Object.keys(initStoreState.series),
            _Object$keys2 = seriesData_slicedToArray(_Object$keys, 1),
            seriesName = _Object$keys2[0];

        series[seriesName].forEach(function (datum, idx) {
          datum.data.push(data[idx]);
        });
      }

      this.notify(state, 'series');
      this.notify(state, 'rawCategories');

      if (Array.isArray(state.zoomRange)) {
        this.dispatch('resetZoom');
      }

      if (coordinateChart) {
        this.dispatch('initCategory');
      }
    },
    addSeries: function addSeries(_ref16, _ref17) {
      var state = _ref16.state,
          initStoreState = _ref16.initStoreState;
      var data = _ref17.data,
          chartType = _ref17.chartType,
          category = _ref17.category;
      var series = initStoreState.series,
          categories = initStoreState.categories;
      var coordinateChart = isCoordinateTypeSeries(state.series, chartType);
      var seriesName = chartType || Object.keys(series)[0];
      var isExist = isSeriesAlreadyExist(series, seriesName, data);

      if (!isExist) {
        series[seriesName].push(data);

        if (Array.isArray(categories) && category) {
          categories.push(category);
        }
      }

      this.dispatch('initThemeState');
      this.dispatch('initLegendState');
      this.notify(state, 'series');

      if (coordinateChart || seriesName === 'bullet') {
        this.dispatch('initCategory');
      }
    },
    addHeatmapSeries: function addHeatmapSeries(_ref18, _ref19) {
      var state = _ref18.state,
          initStoreState = _ref18.initStoreState;
      var data = _ref19.data,
          category = _ref19.category;
      var series = initStoreState.series,
          categories = initStoreState.categories;
      var isExist = isHeatmapSeriesAlreadyExist(categories, category);

      if (!isExist) {
        series.heatmap.push({
          data: data,
          yCategory: category
        });
      }

      if (!isExist && category) {
        categories.y.push(category);
        this.notify(state, 'rawCategories');
      }

      this.notify(state, 'series');
      this.dispatch('initThemeState');
      this.dispatch('initLegendState');
    },
    addTreemapSeries: function addTreemapSeries(_ref20, _ref21) {
      var state = _ref20.state,
          initStoreState = _ref20.initStoreState;
      var data = _ref21.data;
      var series = initStoreState.series;
      var isExist = isTreemapSeriesAlreadyExist(series, data);

      if (!isExist) {
        series.treemap.push(data);
      }

      this.notify(state, 'series');
      this.notify(state, 'treemapSeries');
      this.dispatch('initThemeState');
      this.dispatch('initLegendState');
    },
    setData: function setData(_ref22, _ref23) {
      var state = _ref22.state,
          initStoreState = _ref22.initStoreState;
      var series = _ref23.series,
          categories = _ref23.categories;
      initStoreState.series = series;
      var isNestedPieChart = hasNestedPieSeries(series);

      if (!isNestedPieChart) {
        state.rawCategories = makeRawCategories(series, categories);
      }

      this.dispatch('initThemeState');
      this.dispatch('initLegendState');
    },
    addOutlier: function addOutlier(_ref24, _ref25) {
      var _seriesRawData$outlie;

      var state = _ref24.state,
          initStoreState = _ref24.initStoreState;
      var seriesIndex = _ref25.seriesIndex,
          outliers = _ref25.outliers;
      var series = initStoreState.series;
      var seriesRawData = series.boxPlot[seriesIndex];

      if (!seriesRawData) {
        throw new Error(message.SERIES_INDEX_ERROR);
      }

      seriesRawData.outliers = [].concat(seriesData_toConsumableArray((_seriesRawData$outlie = seriesRawData.outliers) !== null && _seriesRawData$outlie !== void 0 ? _seriesRawData$outlie : []), seriesData_toConsumableArray(outliers));
      this.notify(state, 'series');
    }
  },
  observe: {
    updateSeriesData: function updateSeriesData() {
      this.dispatch('setSeriesData');
    }
  },
  computed: {
    isLineTypeSeriesZooming: function isLineTypeSeriesZooming(_ref26) {
      var zoomRange = _ref26.zoomRange,
          rawCategories = _ref26.rawCategories;
      return isZooming(rawCategories, zoomRange);
    },
    viewRange: function viewRange(_ref27) {
      var zoomRange = _ref27.zoomRange,
          shiftRange = _ref27.shiftRange;
      return zoomRange || shiftRange;
    }
  }
};
/* harmony default export */ var store_seriesData = (seriesData);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.flat-map.js
var es_array_flat_map = __nested_webpack_require_221589__(4870);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.array.unscopables.flat-map.js
var es_array_unscopables_flat_map = __nested_webpack_require_221589__(3985);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.object.values.js
var es_object_values = __nested_webpack_require_221589__(7890);
;// CONCATENATED MODULE: ./src/brushes/polygon.ts


function polygon(ctx, polygonModel) {
  var strokeStyle = polygonModel.color,
      points = polygonModel.points,
      lineWidth = polygonModel.lineWidth,
      fillColor = polygonModel.fillColor,
      _polygonModel$dashSeg = polygonModel.dashSegments,
      dashSegments = _polygonModel$dashSeg === void 0 ? [] : _polygonModel$dashSeg;

  if (!points.length) {
    return;
  }

  ctx.beginPath();

  if (dashSegments) {
    setLineDash(ctx, dashSegments);
  }

  points.forEach(function (_ref, idx) {
    var x = _ref.x,
        y = _ref.y;

    if (idx === 0) {
      ctx.moveTo(x, y);
      return;
    }

    ctx.lineTo(x, y);
  });
  ctx.lineTo(points[0].x, points[0].y);

  if (fillColor) {
    fillStyle(ctx, fillColor);
  }

  strokeWithOptions(ctx, {
    lineWidth: lineWidth,
    strokeStyle: strokeStyle
  });
  ctx.closePath();
}
;// CONCATENATED MODULE: ./src/brushes/scatterSeries.ts
function scatterSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function scatterSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { scatterSeries_ownKeys(Object(source), true).forEach(function (key) { scatterSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { scatterSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function scatterSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }













function regularPolygon(ctx, model) {
  var numberOfSides = model.numberOfSides,
      size = model.size,
      x = model.x,
      y = model.y,
      borderColor = model.borderColor,
      borderWidth = model.borderWidth,
      fillColor = model.fillColor;
  var s = size / 2;
  var shift = numberOfSides % 2 ? Math.PI / 180.0 * (10 + (numberOfSides - 3) / 2) * numberOfSides : 0;
  var step = 2 * Math.PI / numberOfSides;
  ctx.beginPath();

  for (var i = 0; i <= numberOfSides; i += 1) {
    var curStep = i * step + shift;
    ctx.lineTo(x + s * Math.cos(curStep), y + s * Math.sin(curStep));
  }

  ctx.strokeStyle = borderColor;
  ctx.lineWidth = borderWidth;
  fillStyle(ctx, fillColor);
  ctx.stroke();
  ctx.closePath();
} // https://programmingthomas.wordpress.com/2012/05/16/drawing-stars-with-html5-canvas/


function star(ctx, model) {
  var x = model.x,
      y = model.y,
      borderColor = model.borderColor,
      borderWidth = model.borderWidth,
      size = model.size,
      fillColor = model.fillColor;
  ctx.lineWidth = borderWidth;
  ctx.strokeStyle = borderColor;
  ctx.fillStyle = fillColor;
  ctx.save();
  ctx.beginPath();
  ctx.translate(x, y);
  ctx.moveTo(0, -size);

  for (var i = 0; i < 5; i += 1) {
    ctx.rotate(Math.PI / 5);
    ctx.lineTo(0, -size / 2);
    ctx.rotate(Math.PI / 5);
    ctx.lineTo(0, -size);
  }

  ctx.fill();
  ctx.stroke();
  ctx.restore();
  ctx.closePath();
}

function cross(ctx, model) {
  var x = model.x,
      y = model.y,
      borderColor = model.borderColor,
      borderWidth = model.borderWidth,
      size = model.size,
      fillColor = model.fillColor;
  var quarter = size / 4;
  var half = size / 2;
  var xPointsOffset = [-half, -half, -quarter, -quarter, quarter, quarter, half, half, quarter, quarter, -quarter, -quarter];
  var yPointsOffset = [];

  for (var idx = 0, len = xPointsOffset.length; idx < len; idx += 1) {
    var startIdx = 9;
    yPointsOffset.push(xPointsOffset[(startIdx + idx) % len]);
  }

  polygon(ctx, {
    type: 'polygon',
    lineWidth: borderWidth,
    color: borderColor,
    points: xPointsOffset.map(function (val, idx) {
      return {
        x: x + val,
        y: y + yPointsOffset[idx]
      };
    }),
    fillColor: fillColor
  });
}

function getNumberOfSidesByIconType(iconType) {
  switch (iconType) {
    case 'triangle':
      return 3;

    case 'diamond':
      return 4;

    case 'pentagon':
      return 5;

    case 'hexagon':
      return 6;
  }
}

function scatterSeries(ctx, model) {
  var x = model.x,
      y = model.y,
      borderColor = model.borderColor,
      borderWidth = model.borderWidth,
      fillColor = model.fillColor,
      iconType = model.iconType,
      size = model.size;
  var commonModel = {
    x: x,
    y: y,
    fillColor: fillColor,
    borderColor: borderColor,
    borderWidth: borderWidth,
    size: size
  };
  ctx.beginPath();

  switch (iconType) {
    case 'rect':
      pathRect(ctx, {
        type: 'pathRect',
        x: x - size / 2,
        y: y - size / 2,
        width: size,
        height: size,
        stroke: borderColor,
        lineWidth: borderWidth,
        fill: fillColor
      });
      break;

    case 'triangle':
    case 'pentagon':
    case 'diamond':
    case 'hexagon':
      regularPolygon(ctx, scatterSeries_objectSpread({
        type: 'regularPolygon',
        numberOfSides: getNumberOfSidesByIconType(iconType)
      }, commonModel));
      break;

    case 'star':
      star(ctx, scatterSeries_objectSpread(scatterSeries_objectSpread({
        type: 'star'
      }, commonModel), {}, {
        size: size / 2
      }));
      break;

    case 'cross':
      cross(ctx, scatterSeries_objectSpread({
        type: 'cross'
      }, commonModel));
      break;

    default:
      circle(ctx, {
        type: 'circle',
        x: x,
        y: y,
        radius: size / 2,
        style: [{
          strokeStyle: borderColor,
          lineWidth: borderWidth
        }],
        color: fillColor
      });
  }

  ctx.stroke();
  ctx.closePath();
}
;// CONCATENATED MODULE: ./src/brushes/legend.ts








var LEGEND_ITEM_MARGIN_X = 40;
var LEGEND_MARGIN_X = 5;
var LEGEND_CHECKBOX_SIZE = 12;
var LEGEND_ICON_SIZE = 12;
var ICON_BORDER_WIDTH = 1.5;
var INACTIVE_OPACITY = 0.3;
var RECT_SIZE = 10;
var LINE_ICON_PADDING = 2;
var CIRCLE_ICON_RADIUS = 6;
function getLegendItemHeight(fontSize) {
  return fontSize + padding.Y;
}

function drawLineIcon(ctx, x, y, color) {
  var xCurveOffset = [2, 2, 6, 6, 10, 10];
  var yCurveOffset = [8, 0, 0, 8, 8, 0];
  xCurveOffset.forEach(function (xOffset, idx) {
    if (idx === 5) {
      return;
    }

    line(ctx, {
      type: 'line',
      x: x + xOffset,
      y: y + yCurveOffset[idx],
      x2: x + xCurveOffset[idx + 1],
      y2: y + yCurveOffset[idx + 1],
      lineWidth: 2,
      strokeStyle: color
    });
  });
}

function drawCheckIcon(ctx, x, y, active) {
  var color = '#555555';
  var strokeStyle = active ? color : getRGBA(color, INACTIVE_OPACITY);
  line(ctx, {
    type: 'line',
    x: x + 2,
    y: y + 5,
    x2: x + 5,
    y2: y + 8,
    strokeStyle: strokeStyle,
    lineWidth: 2
  });
  line(ctx, {
    type: 'line',
    x: x + 5,
    y: y + 9,
    x2: x + 10,
    y2: y + 3,
    strokeStyle: strokeStyle,
    lineWidth: 2
  });
}

function drawCheckbox(ctx, x, y, renderOptions) {
  var active = renderOptions.active,
      checked = renderOptions.checked;
  var borderColor = active ? '#bbb' : getRGBA('#bbbbbb', INACTIVE_OPACITY);
  rect(ctx, {
    type: 'rect',
    x: x,
    y: y,
    width: LEGEND_CHECKBOX_SIZE,
    height: LEGEND_CHECKBOX_SIZE,
    color: '#fff',
    borderColor: borderColor,
    thickness: 1
  });

  if (checked) {
    drawCheckIcon(ctx, x, y, active);
  }
}

function drawIcon(ctx, x, y, renderOptions) {
  var iconType = renderOptions.iconType,
      active = renderOptions.active,
      color = renderOptions.color,
      showCheckbox = renderOptions.showCheckbox;
  var iconX = x + (showCheckbox ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0);
  var iconColor = active ? color : getRGBA(color, INACTIVE_OPACITY);

  if (iconType === 'rect') {
    rect(ctx, {
      type: 'rect',
      x: iconX,
      y: y + (LEGEND_CHECKBOX_SIZE - RECT_SIZE) / 2,
      width: RECT_SIZE,
      height: RECT_SIZE,
      color: iconColor
    });
  } else if (iconType === 'line') {
    drawLineIcon(ctx, iconX, y + LINE_ICON_PADDING, iconColor);
  } else if (iconType === 'circle') {
    circle(ctx, {
      type: 'circle',
      x: iconX + CIRCLE_ICON_RADIUS,
      y: y + CIRCLE_ICON_RADIUS,
      radius: CIRCLE_ICON_RADIUS,
      color: iconColor,
      style: ['default']
    });
  }
}

function drawScatterIcon(ctx, x, y, renderOptions) {
  var iconType = renderOptions.iconType,
      active = renderOptions.active,
      color = renderOptions.color,
      showCheckbox = renderOptions.showCheckbox;
  var iconX = x + (showCheckbox ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0);
  var iconColor = active ? color : getRGBA(color, INACTIVE_OPACITY);
  scatterSeries(ctx, {
    type: 'scatterSeries',
    iconType: iconType,
    x: iconX + CIRCLE_ICON_RADIUS,
    y: y + CIRCLE_ICON_RADIUS,
    borderColor: iconColor,
    size: CIRCLE_ICON_RADIUS * 2,
    fillColor: 'rgba(255, 255, 255, 0)',
    borderWidth: ICON_BORDER_WIDTH
  });
}

function drawLabel(ctx, x, y, text, renderOptions) {
  var active = renderOptions.active,
      showCheckbox = renderOptions.showCheckbox,
      font = renderOptions.font,
      fontColor = renderOptions.fontColor;
  var fillStyle = active ? fontColor : getRGBA(fontColor, INACTIVE_OPACITY);
  label(ctx, {
    type: 'label',
    x: x + LEGEND_ICON_SIZE + LEGEND_MARGIN_X + (showCheckbox ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0),
    y: y,
    text: text,
    style: ['default', {
      font: font,
      textBaseline: 'top',
      fillStyle: fillStyle
    }]
  });
}

function legend(ctx, model) {
  var data = model.data,
      showCheckbox = model.showCheckbox,
      align = model.align,
      fontSize = model.fontSize,
      fontFamily = model.fontFamily,
      fontWeight = model.fontWeight;
  var font = getTitleFontString({
    fontSize: fontSize,
    fontFamily: fontFamily,
    fontWeight: fontWeight
  });
  var fontColor = model.color;
  data.forEach(function (datum) {
    var x = datum.x,
        y = datum.y,
        checked = datum.checked,
        active = datum.active,
        color = datum.color,
        iconType = datum.iconType,
        useScatterChartIcon = datum.useScatterChartIcon,
        legendLabel = datum.viewLabel;
    var iconY = y - 1 + (getTextHeight(legendLabel, font) - 11) / 4;
    var renderOptions = {
      iconType: iconType,
      checked: checked,
      active: active,
      color: color,
      showCheckbox: showCheckbox,
      align: align,
      font: font,
      fontColor: fontColor
    };

    if (showCheckbox) {
      drawCheckbox(ctx, x, iconY, renderOptions);
    }

    if (useScatterChartIcon && iconType !== 'line') {
      drawScatterIcon(ctx, x, iconY, renderOptions);
    } else {
      drawIcon(ctx, x, iconY, renderOptions);
    }

    drawLabel(ctx, x, y, legendLabel, renderOptions);
  });
}
;// CONCATENATED MODULE: ./src/helpers/theme.ts







function theme_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function theme_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { theme_ownKeys(Object(source), true).forEach(function (key) { theme_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { theme_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function theme_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var DEFAULT_LINE_SERIES_WIDTH = 2;
var DEFAULT_LINE_SERIES_DOT_RADIUS = 3;
var DEFAULT_AREA_OPACITY = 0.3;
var DEFAULT_AREA_SELECTED_SERIES_OPACITY = DEFAULT_AREA_OPACITY;
var DEFAULT_AREA_UNSELECTED_SERIES_OPACITY = 0.06;
var radarDefault = {
  LINE_WIDTH: 2,
  DOT_RADIUS: 3,
  HOVER_DOT_RADIUS: 4,
  SELECTED_SERIES_OPACITY: 0.3,
  UNSELECTED_SERIES_OPACITY: 0.05
};
var boxDefault = {
  HOVER_THICKNESS: 4,
  BOX_HOVER: {
    shadowColor: 'rgba(0, 0, 0, 0.3)',
    shadowOffsetX: 2,
    shadowOffsetY: 2,
    shadowBlur: 6
  }
};
var boxplotDefault = {
  OUTLIER_RADIUS: 4,
  OUTLIER_BORDER_WIDTH: 2,
  LINE_TYPE: {
    whisker: {
      lineWidth: 1
    },
    maximum: {
      lineWidth: 1
    },
    minimum: {
      lineWidth: 1
    },
    median: {
      lineWidth: 1,
      color: '#ffffff'
    }
  }
};
var DEFAULT_BULLET_RANGE_OPACITY = [0.5, 0.3, 0.1];
var DEFAULT_PIE_LINE_WIDTH = 3;

function makeDefaultDataLabelsTheme() {
  var globalFontFamily = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Arial';
  return {
    fontFamily: globalFontFamily,
    fontSize: 11,
    fontWeight: 400,
    color: '#333333',
    useSeriesColor: false
  };
}

var DEFAULT_BUBBLE_ARROW = {
  width: 8,
  height: 6
};
var defaultSeriesTheme = {
  colors: ['#00a9ff', '#ffb840', '#ff5a46', '#00bd9f', '#785fff', '#f28b8c', '#989486', '#516f7d', '#28e6eb', '#28695f', '#96c85a', '#45ba3f', '#295ba0', '#2a4175', '#289399', '#66c8d3', '#617178', '#8a9a9a', '#bebebe', '#374b5a', '#64eba0', '#ffe155', '#ff9141', '#af4beb', '#ff73fa', '#ff55b2', '#2869f5', '#3296ff', '#8cc3ff', '#2828b9', '#fa8787', '#e13782', '#7d5aaa', '#643c91', '#d25f5f', '#fabe6e', '#c3a9eb', '#b9c8f5', '#73a0cd', '#0f5a8c'],
  startColor: '#ffe98a',
  endColor: '#d74177',
  lineWidth: DEFAULT_LINE_SERIES_WIDTH,
  dashSegments: [],
  borderWidth: 0,
  borderColor: '#ffffff',
  select: {
    dot: {
      radius: DEFAULT_LINE_SERIES_DOT_RADIUS,
      borderWidth: DEFAULT_LINE_SERIES_DOT_RADIUS + 2
    },
    areaOpacity: DEFAULT_AREA_SELECTED_SERIES_OPACITY,
    restSeries: {
      areaOpacity: DEFAULT_AREA_UNSELECTED_SERIES_OPACITY
    }
  },
  hover: {
    dot: {
      radius: DEFAULT_LINE_SERIES_DOT_RADIUS,
      borderWidth: DEFAULT_LINE_SERIES_DOT_RADIUS + 2
    }
  },
  dot: {
    radius: DEFAULT_LINE_SERIES_DOT_RADIUS
  },
  areaOpacity: DEFAULT_AREA_OPACITY
};
function makeAxisTitleTheme() {
  var globalFontFamily = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Arial';
  return {
    fontSize: 11,
    fontFamily: globalFontFamily,
    fontWeight: 700,
    color: '#bbbbbb'
  };
}

function makeCommonTextTheme() {
  var globalFontFamily = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Arial';
  return {
    fontSize: 11,
    fontFamily: globalFontFamily,
    fontWeight: 'normal',
    color: '#333333'
  };
}

function makeDefaultTheme(series) {
  var globalFontFamily = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Arial';
  var axisTitleTheme = makeAxisTitleTheme(globalFontFamily);
  var commonTextTheme = makeCommonTextTheme(globalFontFamily);
  var hasRadarSeries = !!(series !== null && series !== void 0 && series.radar);
  var hasGaugeSeries = !!(series !== null && series !== void 0 && series.gauge);
  return {
    chart: {
      fontFamily: globalFontFamily,
      backgroundColor: '#ffffff'
    },
    noData: {
      fontSize: 18,
      fontFamily: globalFontFamily,
      fontWeight: 'normal',
      color: '#333333'
    },
    title: {
      fontSize: 18,
      fontFamily: globalFontFamily,
      fontWeight: 100,
      color: '#333333'
    },
    yAxis: {
      title: theme_objectSpread({}, axisTitleTheme),
      label: theme_objectSpread({}, commonTextTheme),
      width: 1,
      color: '#333333'
    },
    xAxis: {
      title: theme_objectSpread({}, axisTitleTheme),
      label: theme_objectSpread({}, commonTextTheme),
      width: 1,
      color: '#333333'
    },
    verticalAxis: {
      label: theme_objectSpread(theme_objectSpread({}, commonTextTheme), {}, {
        textBubble: {
          visible: hasRadarSeries,
          backgroundColor: hasRadarSeries ? '#f3f3f3' : 'rgba(0, 0, 0, 0)',
          borderRadius: 7,
          paddingX: 7,
          paddingY: 2,
          borderColor: 'rgba(0, 0, 0, 0)',
          borderWidth: 1
        }
      })
    },
    circularAxis: {
      title: theme_objectSpread({}, axisTitleTheme),
      label: theme_objectSpread({}, commonTextTheme),
      lineWidth: 1,
      strokeStyle: hasGaugeSeries ? 'rgba(0, 0, 0, 0.5)' : 'rgba(0, 0, 0, 0.05)',
      dotColor: 'rgba(0, 0, 0, 0.5)',
      tick: {
        lineWidth: 1,
        strokeStyle: 'rgba(0, 0, 0, 0.5)'
      }
    },
    legend: {
      label: {
        color: '#333333',
        fontSize: 11,
        fontWeight: 'normal',
        fontFamily: globalFontFamily
      }
    },
    tooltip: {
      background: 'rgba(85, 85, 85, 0.95)',
      borderColor: 'rgba(255, 255, 255, 0)',
      borderWidth: 0,
      borderRadius: 3,
      borderStyle: 'solid',
      body: {
        fontSize: 12,
        fontFamily: "".concat(globalFontFamily, ", sans-serif"),
        fontWeight: 'normal',
        color: '#ffffff'
      },
      header: {
        fontSize: 13,
        fontFamily: "".concat(globalFontFamily, ", sans-serif"),
        fontWeight: 'bold',
        color: '#ffffff'
      }
    },
    plot: {
      lineColor: 'rgba(0, 0, 0, 0.05)',
      backgroundColor: 'rgba(255, 255, 255, 0)'
    },
    exportMenu: {
      button: theme_objectSpread(theme_objectSpread({}, makeBorderTheme(5, '#f4f4f4')), {}, {
        backgroundColor: '#f4f4f4',
        xIcon: {
          color: '#555555',
          lineWidth: 2
        },
        dotIcon: {
          color: '#555555',
          width: 2,
          height: 2,
          gap: 2
        }
      }),
      panel: theme_objectSpread(theme_objectSpread({}, makeBorderTheme(0, '#bab9ba')), {}, {
        header: theme_objectSpread(theme_objectSpread({}, commonTextTheme), {}, {
          backgroundColor: '#f4f4f4'
        }),
        body: theme_objectSpread(theme_objectSpread({}, commonTextTheme), {}, {
          backgroundColor: '#ffffff'
        })
      })
    }
  };
}

function makeBorderTheme(borderRadius, borderColor) {
  var borderWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  return {
    borderWidth: borderWidth,
    borderRadius: borderRadius,
    borderColor: borderColor
  };
}

function makeDefaultTextBubbleTheme() {
  var visible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var borderRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 7;
  var paddingX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;
  var paddingY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  var backgroundColor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '#ffffff';
  return {
    visible: visible,
    paddingX: paddingX,
    paddingY: paddingY,
    borderRadius: borderRadius,
    backgroundColor: backgroundColor,
    shadowColor: 'rgba(0, 0, 0, 0.3)',
    shadowOffsetY: 2,
    shadowBlur: 4
  };
}

function getLineTypeSeriesTheme(globalFontFamily) {
  var defaultDataLabelTheme = makeDefaultDataLabelsTheme(globalFontFamily);
  return {
    lineWidth: defaultSeriesTheme.lineWidth,
    dashSegments: defaultSeriesTheme.dashSegments,
    select: {
      dot: defaultSeriesTheme.select.dot
    },
    hover: {
      dot: defaultSeriesTheme.hover.dot
    },
    dot: defaultSeriesTheme.dot,
    dataLabels: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
      textBubble: theme_objectSpread(theme_objectSpread({}, makeDefaultTextBubbleTheme()), {}, {
        arrow: theme_objectSpread({
          visible: false,
          direction: 'bottom'
        }, DEFAULT_BUBBLE_ARROW)
      })
    })
  };
}

function getTreemapHeatmapSeriesTheme(globalFontFamily) {
  var defaultDataLabelTheme = makeDefaultDataLabelsTheme(globalFontFamily);
  return {
    startColor: defaultSeriesTheme.startColor,
    endColor: defaultSeriesTheme.endColor,
    borderWidth: 0,
    borderColor: '#ffffff',
    hover: {
      borderWidth: boxDefault.HOVER_THICKNESS,
      borderColor: '#ffffff'
    },
    select: {
      borderWidth: boxDefault.HOVER_THICKNESS,
      borderColor: '#ffffff'
    },
    dataLabels: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
      color: '#ffffff',
      textBubble: theme_objectSpread({}, makeDefaultTextBubbleTheme(false, 1, 5, 1, 'rgba(255, 255, 255, 0.5)'))
    })
  };
}

function getBarColumnSeriesTheme(globalFontFamily) {
  var defaultDataLabelTheme = makeDefaultDataLabelsTheme(globalFontFamily);
  return {
    areaOpacity: 1,
    hover: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
      borderWidth: boxDefault.HOVER_THICKNESS,
      borderColor: '#ffffff',
      groupedRect: {
        color: '#000000',
        opacity: 0.05
      }
    }),
    select: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
      borderWidth: boxDefault.HOVER_THICKNESS,
      borderColor: '#ffffff',
      groupedRect: {
        color: '#000000',
        opacity: 0.2
      },
      restSeries: {
        areaOpacity: 0.2
      },
      areaOpacity: 1
    }),
    connector: {
      color: 'rgba(51, 85, 139, 0.3)',
      lineWidth: 1,
      dashSegments: []
    },
    dataLabels: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
      textBubble: theme_objectSpread(theme_objectSpread({}, makeDefaultTextBubbleTheme(false, 1, 4, 3)), {}, {
        arrow: theme_objectSpread({
          visible: false
        }, DEFAULT_BUBBLE_ARROW)
      }),
      stackTotal: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
        textBubble: theme_objectSpread(theme_objectSpread({}, makeDefaultTextBubbleTheme(true, 1, 4, 3)), {}, {
          arrow: theme_objectSpread({
            visible: true
          }, DEFAULT_BUBBLE_ARROW)
        })
      })
    })
  };
}

var transparentColor = 'rgba(255, 255, 255, 0)';
var defaultThemeMakers = {
  line: function line(globalFontFamily) {
    return theme_objectSpread({}, getLineTypeSeriesTheme(globalFontFamily));
  },
  area: function area(globalFontFamily) {
    var lineTypeSeriesTheme = getLineTypeSeriesTheme(globalFontFamily);
    return theme_objectSpread(theme_objectSpread({}, lineTypeSeriesTheme), {}, {
      select: theme_objectSpread(theme_objectSpread({}, lineTypeSeriesTheme.select), {}, {
        areaOpacity: DEFAULT_AREA_SELECTED_SERIES_OPACITY,
        restSeries: defaultSeriesTheme.select.restSeries
      }),
      areaOpacity: DEFAULT_AREA_OPACITY
    });
  },
  treemap: function treemap(globalFontFamily) {
    return getTreemapHeatmapSeriesTheme(globalFontFamily);
  },
  heatmap: function heatmap(globalFontFamily) {
    return getTreemapHeatmapSeriesTheme(globalFontFamily);
  },
  scatter: function scatter() {
    return {
      size: 12,
      borderWidth: 1.5,
      fillColor: transparentColor,
      select: {
        fillColor: 'rgba(255, 255, 255, 1)',
        borderWidth: 2.5,
        size: 12
      },
      hover: {
        fillColor: 'rgba(255, 255, 255, 1)',
        borderWidth: 2.5,
        size: 12
      }
    };
  },
  bubble: function bubble() {
    return {
      borderWidth: 0,
      borderColor: transparentColor,
      select: {},
      hover: {
        shadowColor: 'rgba(0, 0, 0, 0.3)',
        shadowBlur: 2,
        shadowOffsetY: 2,
        lineWidth: 2
      }
    };
  },
  radar: function radar() {
    return {
      areaOpacity: radarDefault.SELECTED_SERIES_OPACITY,
      hover: {
        dot: {
          radius: radarDefault.HOVER_DOT_RADIUS,
          borderWidth: radarDefault.HOVER_DOT_RADIUS + 1
        }
      },
      select: {
        dot: {
          radius: radarDefault.HOVER_DOT_RADIUS,
          borderWidth: radarDefault.HOVER_DOT_RADIUS + 1
        },
        restSeries: {
          areaOpacity: radarDefault.UNSELECTED_SERIES_OPACITY
        },
        areaOpacity: radarDefault.SELECTED_SERIES_OPACITY
      },
      dot: {
        radius: radarDefault.DOT_RADIUS
      }
    };
  },
  bar: function bar(globalFontFamily) {
    return theme_objectSpread({}, getBarColumnSeriesTheme(globalFontFamily));
  },
  column: function column(globalFontFamily) {
    return theme_objectSpread({}, getBarColumnSeriesTheme(globalFontFamily));
  },
  bullet: function bullet(globalFontFamily) {
    var defaultDataLabelTheme = makeDefaultDataLabelsTheme(globalFontFamily);
    return {
      areaOpacity: 1,
      barWidthRatios: {
        rangeRatio: 1,
        bulletRatio: 0.5,
        markerRatio: 0.8
      },
      markerLineWidth: 1,
      borderWidth: 0,
      borderColor: 'rgba(255, 255, 255, 0)',
      hover: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
        borderWidth: boxDefault.HOVER_THICKNESS,
        borderColor: '#ffffff',
        groupedRect: {
          color: '#000000',
          opacity: 0.05
        }
      }),
      select: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
        borderWidth: boxDefault.HOVER_THICKNESS,
        borderColor: '#ffffff',
        groupedRect: {
          color: '#000000',
          opacity: 0.2
        },
        restSeries: {
          areaOpacity: 0.2
        },
        areaOpacity: 1
      }),
      dataLabels: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
        textBubble: theme_objectSpread(theme_objectSpread({}, makeDefaultTextBubbleTheme()), {}, {
          arrow: theme_objectSpread({
            visible: false
          }, DEFAULT_BUBBLE_ARROW)
        }),
        marker: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
          fontSize: 9,
          useSeriesColor: true,
          textBubble: theme_objectSpread(theme_objectSpread({}, makeDefaultTextBubbleTheme(true)), {}, {
            backgroundColor: 'rgba(255, 255, 255, 0.8)',
            shadowColor: 'rgba(0, 0, 0, 0.0)',
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            shadowBlur: 0,
            arrow: theme_objectSpread({
              visible: false
            }, DEFAULT_BUBBLE_ARROW)
          })
        })
      })
    };
  },
  boxPlot: function boxPlot() {
    return {
      areaOpacity: 1,
      barWidthRatios: {
        barRatio: 1,
        minMaxBarRatio: 0.5
      },
      markerLineWidth: 1,
      dot: {
        color: '#ffffff',
        radius: boxplotDefault.OUTLIER_RADIUS,
        borderWidth: boxplotDefault.OUTLIER_BORDER_WIDTH,
        useSeriesColor: false
      },
      rect: {
        borderWidth: 0
      },
      line: theme_objectSpread({}, boxplotDefault.LINE_TYPE),
      hover: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
        rect: {
          borderWidth: boxDefault.HOVER_THICKNESS,
          borderColor: '#ffffff'
        },
        dot: {
          radius: boxplotDefault.OUTLIER_RADIUS,
          borderWidth: 0,
          useSeriesColor: true
        },
        line: theme_objectSpread({}, boxplotDefault.LINE_TYPE)
      }),
      select: theme_objectSpread(theme_objectSpread({}, boxDefault.BOX_HOVER), {}, {
        rect: {
          borderWidth: boxDefault.HOVER_THICKNESS,
          borderColor: '#ffffff'
        },
        dot: {
          radius: boxplotDefault.OUTLIER_RADIUS,
          borderWidth: 0,
          useSeriesColor: true
        },
        line: theme_objectSpread({}, boxplotDefault.LINE_TYPE),
        restSeries: {
          areaOpacity: 0.2
        },
        areaOpacity: 1
      })
    };
  },
  pie: function pie(globalFontFamily, _ref) {
    var _ref$hasOuterAnchor = _ref.hasOuterAnchor,
        hasOuterAnchor = _ref$hasOuterAnchor === void 0 ? false : _ref$hasOuterAnchor,
        _ref$hasOuterAnchorPi = _ref.hasOuterAnchorPieSeriesName,
        hasOuterAnchorPieSeriesName = _ref$hasOuterAnchorPi === void 0 ? false : _ref$hasOuterAnchorPi;
    var isNestedPieChart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    var defaultDataLabelTheme = makeDefaultDataLabelsTheme(globalFontFamily);
    return {
      areaOpacity: 1,
      strokeStyle: isNestedPieChart ? '#ffffff' : 'rgba(255, 255, 255, 0)',
      lineWidth: isNestedPieChart ? 1 : 0,
      hover: {
        lineWidth: DEFAULT_PIE_LINE_WIDTH,
        strokeStyle: '#ffffff',
        shadowColor: '#cccccc',
        shadowBlur: 5,
        shadowOffsetX: 0,
        shadowOffsetY: 0
      },
      select: {
        lineWidth: DEFAULT_PIE_LINE_WIDTH,
        strokeStyle: '#ffffff',
        shadowColor: '#cccccc',
        shadowBlur: 5,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        restSeries: {
          areaOpacity: 0.3
        },
        areaOpacity: 1
      },
      dataLabels: {
        fontFamily: globalFontFamily,
        fontSize: 16,
        fontWeight: 600,
        color: hasOuterAnchor ? '#333333' : '#ffffff',
        useSeriesColor: hasOuterAnchor,
        textBubble: theme_objectSpread({}, makeDefaultTextBubbleTheme(false, 0)),
        callout: {
          lineWidth: 1,
          useSeriesColor: true,
          lineColor: '#e9e9e9'
        },
        pieSeriesName: theme_objectSpread(theme_objectSpread({}, defaultDataLabelTheme), {}, {
          useSeriesColor: hasOuterAnchorPieSeriesName,
          color: hasOuterAnchorPieSeriesName ? '#333333' : '#ffffff',
          textBubble: theme_objectSpread({}, makeDefaultTextBubbleTheme(false, 0))
        })
      }
    };
  },
  radialBar: function radialBar(globalFontFamily) {
    return {
      areaOpacity: 1,
      strokeStyle: 'rgba(255, 255, 255, 0)',
      lineWidth: 0,
      hover: {
        lineWidth: DEFAULT_PIE_LINE_WIDTH,
        strokeStyle: '#fff',
        shadowColor: '#cccccc',
        shadowBlur: 5,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        groupedSector: {
          color: '#000000',
          opacity: 0.05
        }
      },
      select: {
        lineWidth: DEFAULT_PIE_LINE_WIDTH,
        strokeStyle: '#fff',
        shadowColor: '#cccccc',
        shadowBlur: 5,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        restSeries: {
          areaOpacity: 0.3
        },
        areaOpacity: 1,
        groupedSector: {
          color: '#000000',
          opacity: 0.2
        }
      },
      dataLabels: {
        fontFamily: globalFontFamily,
        fontSize: 11,
        fontWeight: 400,
        color: '#333333',
        useSeriesColor: false,
        textBubble: theme_objectSpread({}, makeDefaultTextBubbleTheme(false, 0))
      }
    };
  },
  gauge: function gauge(globalFontFamily) {
    return {
      areaOpacity: 1,
      hover: {
        clockHand: {
          baseLine: 5
        },
        pin: {
          radius: 5,
          borderWidth: 5
        },
        solid: {
          lineWidth: DEFAULT_PIE_LINE_WIDTH,
          strokeStyle: '#ffffff',
          shadowColor: '#cccccc',
          shadowBlur: 5,
          shadowOffsetX: 0,
          shadowOffsetY: 0
        }
      },
      select: {
        clockHand: {
          baseLine: 5
        },
        pin: {
          radius: 6,
          borderWidth: 4
        },
        solid: {
          lineWidth: DEFAULT_PIE_LINE_WIDTH,
          strokeStyle: '#ffffff',
          shadowColor: '#cccccc',
          shadowBlur: 5,
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          restSeries: {
            areaOpacity: 0.3
          },
          areaOpacity: 1
        },
        areaOpacity: 1,
        restSeries: {
          areaOpacity: 0.3
        }
      },
      clockHand: {
        baseLine: 4
      },
      pin: {
        radius: 5,
        borderWidth: 5
      },
      solid: {
        lineWidth: 0,
        backgroundSolid: {
          color: 'rgba(0, 0, 0, 0.1)'
        }
      },
      dataLabels: {
        fontFamily: globalFontFamily,
        fontSize: 11,
        fontWeight: 400,
        color: '#333333',
        useSeriesColor: false,
        textBubble: theme_objectSpread(theme_objectSpread({}, makeDefaultTextBubbleTheme(true, 4, 4, 3)), {}, {
          shadowColor: 'rgba(0, 0, 0, 0)',
          shadowOffsetY: 0,
          shadowBlur: 0,
          borderColor: '#ccc',
          borderWidth: 1
        })
      }
    };
  }
};

function getSeriesTheme(globalFontFamily, seriesName, paramForPieSeries) {
  var isNestedPieChart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  if (seriesName === 'pie') {
    return defaultThemeMakers[seriesName](globalFontFamily, paramForPieSeries, isNestedPieChart);
  }

  if (includes(['bubble', 'radar', 'boxPlot'], seriesName)) {
    return defaultThemeMakers[seriesName]();
  }

  return defaultThemeMakers[seriesName](globalFontFamily);
}

function getDefaultTheme(series, pieSeriesOuterAnchors) {
  var globalFontFamily = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'Arial';
  var isNestedPieChart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
  var result = Object.keys(series).reduce(function (acc, seriesName) {
    return theme_objectSpread(theme_objectSpread({}, acc), {}, {
      series: theme_objectSpread(theme_objectSpread({}, acc.series), {}, theme_defineProperty({}, seriesName, getSeriesTheme(globalFontFamily, seriesName, pieSeriesOuterAnchors)))
    });
  }, makeDefaultTheme(series, globalFontFamily));

  if (isNestedPieChart) {
    var aliasNames = getNestedPieChartAliasNames(series);
    result.series.pie = aliasNames.reduce(function (acc, cur) {
      return theme_objectSpread(theme_objectSpread({}, acc), {}, theme_defineProperty({}, cur, getSeriesTheme(globalFontFamily, 'pie', pieSeriesOuterAnchors[cur], isNestedPieChart)));
    }, {});
  }

  return result;
}
;// CONCATENATED MODULE: ./src/helpers/validation.ts


function isAvailableShowTooltipInfo(info, eventDetectType, targetChartType) {
  var index = info.index,
      seriesIndex = info.seriesIndex,
      chartType = info.chartType;
  return isNumber(index) && (eventDetectType === 'grouped' || isNumber(seriesIndex)) && (isUndefined(chartType) || chartType === targetChartType);
}
function isAvailableSelectSeries(info, targetChartType) {
  var index = info.index,
      seriesIndex = info.seriesIndex,
      chartType = info.chartType;
  return isNumber(index) && isNumber(seriesIndex) && (isUndefined(chartType) || chartType === targetChartType);
}
function isNoData(series) {
  return Object.keys(series).reduce(function (acc, chartType) {
    return !series[chartType].data.length && acc;
  }, true);
}
;// CONCATENATED MODULE: ./src/helpers/legend.ts







function legend_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function legend_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { legend_ownKeys(Object(source), true).forEach(function (key) { legend_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { legend_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function legend_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


function getActiveSeriesMap(legend) {
  return legend.data.reduce(function (acc, _ref) {
    var active = _ref.active,
        label = _ref.label;
    return legend_objectSpread(legend_objectSpread({}, acc), {}, legend_defineProperty({}, label, active));
  }, {});
}
function showCircleLegend(options) {
  var _options$circleLegend, _options$circleLegend2;

  return (_options$circleLegend = options === null || options === void 0 ? void 0 : (_options$circleLegend2 = options.circleLegend) === null || _options$circleLegend2 === void 0 ? void 0 : _options$circleLegend2.visible) !== null && _options$circleLegend !== void 0 ? _options$circleLegend : true;
}
function showLegend(options, series) {
  var _options$series, _options$legend, _options$legend2;

  if (series.gauge || series.treemap && !((_options$series = options.series) !== null && _options$series !== void 0 && _options$series.useColorValue)) {
    return false;
  }

  return isUndefined((_options$legend = options.legend) === null || _options$legend === void 0 ? void 0 : _options$legend.visible) ? true : !!((_options$legend2 = options.legend) !== null && _options$legend2 !== void 0 && _options$legend2.visible);
}
function showCheckbox(options) {
  var _options$legend3, _options$legend4;

  return isUndefined((_options$legend3 = options.legend) === null || _options$legend3 === void 0 ? void 0 : _options$legend3.showCheckbox) ? true : !!((_options$legend4 = options.legend) !== null && _options$legend4 !== void 0 && _options$legend4.showCheckbox);
} // @TODO: Need to manage with chart type constant/Enum

function useRectIcon(type) {
  return includes(['bar', 'column', 'area', 'pie', 'boxPlot', 'bullet', 'radialBar'], type);
}

function useCircleIcon(type) {
  return includes(['bubble', 'scatter'], type);
}

function useLineIcon(type) {
  return includes(['line', 'radar'], type);
}

function getIconType(type) {
  var iconType = 'spectrum';

  if (useCircleIcon(type)) {
    iconType = 'circle';
  } else if (useRectIcon(type)) {
    iconType = 'rect';
  } else if (useLineIcon(type)) {
    iconType = 'line';
  }

  return iconType;
}
function getLegendAlign(options) {
  var _options$legend$align, _options$legend5;

  return (_options$legend$align = (_options$legend5 = options.legend) === null || _options$legend5 === void 0 ? void 0 : _options$legend5.align) !== null && _options$legend$align !== void 0 ? _options$legend$align : 'right';
}
;// CONCATENATED MODULE: ./src/store/legend.ts
function legend_slicedToArray(arr, i) { return legend_arrayWithHoles(arr) || legend_iterableToArrayLimit(arr, i) || legend_unsupportedIterableToArray(arr, i) || legend_nonIterableRest(); }

function legend_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function legend_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function legend_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function store_legend_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function store_legend_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { store_legend_ownKeys(Object(source), true).forEach(function (key) { store_legend_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { store_legend_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function store_legend_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function legend_toConsumableArray(arr) { return legend_arrayWithoutHoles(arr) || legend_iterableToArray(arr) || legend_unsupportedIterableToArray(arr) || legend_nonIterableSpread(); }

function legend_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function legend_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return legend_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return legend_arrayLikeToArray(o, minLen); }

function legend_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function legend_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return legend_arrayLikeToArray(arr); }

function legend_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

































var INITIAL_LEGEND_WIDTH = 100;
var INITIAL_CIRCLE_LEGEND_WIDTH = 150;
var COMPONENT_HEIGHT_EXCEPT_Y_AXIS = 100;
var ELLIPSIS_DOT_TEXT = '...';
var WIDEST_TEXT = 'W'; // The widest text width in Arial font.

var NUMBER_OF_BOTH_SIDES = 2;

function recalculateLegendWhenHeightOverflows(params, legendHeight) {
  var legendWidths = params.legendWidths,
      itemHeight = params.itemHeight;
  var totalHeight = legendWidths.length * itemHeight;
  var columnCount = Math.ceil(totalHeight / legendHeight);
  var rowCount = legendWidths.length / columnCount;
  var legendWidth = 0;
  range(0, columnCount).forEach(function (count) {
    legendWidth += Math.max.apply(Math, legend_toConsumableArray(legendWidths.slice(count * rowCount, (count + 1) * rowCount)));
  });
  legendWidth += LEGEND_ITEM_MARGIN_X * (columnCount - 1);
  return {
    legendWidth: legendWidth,
    legendHeight: rowCount * itemHeight + padding.Y,
    columnCount: columnCount,
    rowCount: rowCount
  };
}

function recalculateLegendWhenWidthOverflows(params, prevLegendWidth) {
  var legendWidths = params.legendWidths,
      itemHeight = params.itemHeight;
  var columnCount = 0;
  var legendWidth = 0;

  var _legendWidths$reduce = legendWidths.reduce(function (acc, width) {
    var widthWithMargin = LEGEND_ITEM_MARGIN_X + width;

    if (acc.totalWidth + width > prevLegendWidth) {
      acc.totalWidth = widthWithMargin;
      acc.rowCount += 1;
      acc.columnCount = 1;
      columnCount = Math.max(columnCount, acc.columnCount);
    } else {
      acc.totalWidth += widthWithMargin;
      acc.columnCount += 1;
    }

    legendWidth = Math.max(legendWidth, acc.totalWidth);
    return acc;
  }, {
    totalWidth: 0,
    rowCount: 1,
    columnCount: 0
  }),
      rowCount = _legendWidths$reduce.rowCount;

  return {
    legendHeight: itemHeight * rowCount,
    rowCount: rowCount,
    columnCount: columnCount,
    legendWidth: legendWidth
  };
}

function calculateLegendSize(params) {
  if (!params.visible) {
    return {
      legendWidth: 0,
      legendHeight: 0,
      rowCount: 0,
      columnCount: 0
    };
  }

  var chart = params.chart,
      verticalAlign = params.verticalAlign,
      legendWidths = params.legendWidths;

  var _calculateLegendWidth = calculateLegendWidth(params),
      legendWidth = _calculateLegendWidth.legendWidth,
      widthOverflow = _calculateLegendWidth.isOverflow;

  var _calculateLegendHeigh = calculateLegendHeight(params),
      legendHeight = _calculateLegendHeigh.legendHeight,
      heightOverflow = _calculateLegendHeigh.isOverflow;

  var columnCount = verticalAlign ? legendWidths.length : 1;
  var rowCount = verticalAlign ? Math.ceil(legendWidth / chart.width) : legendWidths.length;

  if (widthOverflow) {
    return recalculateLegendWhenWidthOverflows(params, legendWidth / rowCount);
  }

  if (heightOverflow) {
    return recalculateLegendWhenHeightOverflows(params, legendHeight);
  }

  return {
    legendWidth: legendWidth,
    legendHeight: legendHeight,
    columnCount: columnCount,
    rowCount: rowCount
  };
}

function calculateLegendHeight(params) {
  var verticalAlign = params.verticalAlign,
      itemHeight = params.itemHeight,
      legendWidths = params.legendWidths;

  var _getDefaultLegendSize = getDefaultLegendSize(params),
      chartHeight = _getDefaultLegendSize.height;

  var legendHeight;
  var isOverflow = false;

  if (verticalAlign) {
    legendHeight = chartHeight;
  } else {
    var totalHeight = legendWidths.length * itemHeight;
    isOverflow = chartHeight < totalHeight;
    legendHeight = isOverflow ? chartHeight : totalHeight;
  }

  return {
    legendHeight: legendHeight,
    isOverflow: isOverflow
  };
}

function getSpectrumLegendWidth(legendWidths, chartWidth, verticalAlign) {
  if (verticalAlign) {
    var labelAreaWidth = sum(legendWidths);
    return Math.max(chartWidth / 4, labelAreaWidth);
  }

  var spectrumAreaWidth = (spectrumLegendTooltip.PADDING + spectrumLegendBar.PADDING + padding.X) * NUMBER_OF_BOTH_SIDES + spectrumLegendTooltip.POINT_HEIGHT + spectrumLegendBar.HEIGHT;
  return Math.max.apply(Math, legend_toConsumableArray(legendWidths)) + spectrumAreaWidth;
}

function getSpectrumLegendHeight(itemHeight, chartHeight, verticalAlign) {
  return verticalAlign ? SPECTRUM_LEGEND_LABEL_HEIGHT + spectrumLegendBar.PADDING * NUMBER_OF_BOTH_SIDES + spectrumLegendTooltip.POINT_HEIGHT + spectrumLegendTooltip.HEIGHT + padding.Y : chartHeight * 3 / 4;
}

function getNormalLegendWidth(params) {
  var initialWidth = params.initialWidth,
      legendWidths = params.legendWidths,
      checkbox = params.checkbox,
      verticalAlign = params.verticalAlign;
  var isOverflow = false;
  var legendWidth;

  if (verticalAlign) {
    var _getDefaultLegendSize2 = getDefaultLegendSize(params),
        chartWidth = _getDefaultLegendSize2.width;

    var totalWidth = sum(legendWidths) + LEGEND_ITEM_MARGIN_X * (legendWidths.length - 1);
    isOverflow = totalWidth > chartWidth;
    legendWidth = totalWidth;
  } else {
    var labelAreaWidth = Math.max.apply(Math, legend_toConsumableArray(legendWidths));
    legendWidth = (checkbox ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0) + LEGEND_ICON_SIZE + LEGEND_MARGIN_X + Math.max(labelAreaWidth, initialWidth);
  }

  return {
    legendWidth: legendWidth,
    isOverflow: isOverflow
  };
}

function calculateLegendWidth(params) {
  var options = params.options,
      visible = params.visible;
  var legendOptions = options === null || options === void 0 ? void 0 : options.legend;

  if (!visible) {
    return {
      legendWidth: 0,
      isOverflow: false
    };
  }

  if (legendOptions !== null && legendOptions !== void 0 && legendOptions.width) {
    return {
      legendWidth: legendOptions.width,
      isOverflow: false
    };
  }

  return getNormalLegendWidth(params);
}

function getDefaultLegendSize(params) {
  var verticalAlign = params.verticalAlign,
      chart = params.chart,
      itemHeight = params.itemHeight,
      initialWidth = params.initialWidth,
      circleLegendVisible = params.circleLegendVisible;
  var restAreaHeight = COMPONENT_HEIGHT_EXCEPT_Y_AXIS + (circleLegendVisible ? INITIAL_CIRCLE_LEGEND_WIDTH : 0); // rest area temporary value (yAxisTitle.height + xAxis.height + circleLegend.height)

  return verticalAlign ? {
    width: chart.width - padding.X * NUMBER_OF_BOTH_SIDES,
    height: itemHeight
  } : {
    width: initialWidth,
    height: chart.height - restAreaHeight
  };
}

function getNestedPieLegendLabelsInfo(series, legendInfo) {
  var result = [];
  var maxTextLengthWithEllipsis = getMaxTextLengthWithEllipsis(legendInfo);
  series.pie.forEach(function (_ref) {
    var data = _ref.data;
    data.forEach(function (_ref2) {
      var name = _ref2.name,
          parentName = _ref2.parentName,
          visible = _ref2.visible;

      if (!parentName) {
        var _getViewLabelInfo = getViewLabelInfo(legendInfo, name, maxTextLengthWithEllipsis),
            width = _getViewLabelInfo.width,
            viewLabel = _getViewLabelInfo.viewLabel;

        result.push({
          label: name,
          type: 'pie',
          checked: visible !== null && visible !== void 0 ? visible : true,
          viewLabel: viewLabel,
          width: width
        });
      }
    });
  });
  return result;
}

function getMaxTextLengthWithEllipsis(legendInfo) {
  var _legendOptions$item;

  var legendOptions = legendInfo.legendOptions,
      font = legendInfo.font,
      checkboxVisible = legendInfo.checkboxVisible;
  var width = legendOptions === null || legendOptions === void 0 ? void 0 : (_legendOptions$item = legendOptions.item) === null || _legendOptions$item === void 0 ? void 0 : _legendOptions$item.width;

  if (isUndefined(width)) {
    return;
  }

  var checkboxWidth = checkboxVisible ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0;
  var iconWidth = LEGEND_ICON_SIZE + LEGEND_MARGIN_X;
  var ellipsisDotWidth = getTextWidth(ELLIPSIS_DOT_TEXT, font);
  var widestTextWidth = getTextWidth(WIDEST_TEXT, font);
  var maxTextCount = Math.floor((width - ellipsisDotWidth - checkboxWidth - iconWidth) / widestTextWidth);
  return maxTextCount > 0 ? maxTextCount : 0;
}

function getViewLabelInfo(legendInfo, label, maxTextLength) {
  var _legendOptions$item2;

  var checkboxVisible = legendInfo.checkboxVisible,
      useSpectrumLegend = legendInfo.useSpectrumLegend,
      font = legendInfo.font,
      legendOptions = legendInfo.legendOptions;
  var viewLabel = label;
  var itemWidth = legendOptions === null || legendOptions === void 0 ? void 0 : (_legendOptions$item2 = legendOptions.item) === null || _legendOptions$item2 === void 0 ? void 0 : _legendOptions$item2.width;
  var itemWidthWithFullText = getItemWidth(viewLabel, checkboxVisible, useSpectrumLegend, font);

  if (isNumber(itemWidth) && isNumber(maxTextLength) && itemWidth < itemWidthWithFullText) {
    viewLabel = "".concat(label.slice(0, maxTextLength)).concat(ELLIPSIS_DOT_TEXT);
  }

  return {
    viewLabel: viewLabel,
    width: itemWidth !== null && itemWidth !== void 0 ? itemWidth : itemWidthWithFullText
  };
}

function getLegendLabelsInfo(series, legendInfo, categories) {
  var maxTextLengthWithEllipsis = getMaxTextLengthWithEllipsis(legendInfo);
  var colorIndex = 0;
  return Object.keys(series).flatMap(function (type) {
    var labelInfo = series[type].map(function (_ref3) {
      var name = _ref3.name,
          colorValue = _ref3.colorValue,
          visible = _ref3.visible,
          colorByCategories = _ref3.colorByCategories;
      var label = colorValue ? colorValue : name;
      var currentColorIndex = colorIndex;

      var _getViewLabelInfo2 = getViewLabelInfo(legendInfo, label, maxTextLengthWithEllipsis),
          width = _getViewLabelInfo2.width,
          viewLabel = _getViewLabelInfo2.viewLabel;

      colorIndex += colorByCategories ? categories.length : 1;
      return {
        label: label,
        type: type,
        colorByCategories: !!colorByCategories,
        colorIndex: currentColorIndex,
        checked: visible !== null && visible !== void 0 ? visible : true,
        viewLabel: viewLabel,
        width: width
      };
    });
    colorIndex += series[type].length - 1;
    return labelInfo;
  });
}

function getItemWidth(label, checkboxVisible, useSpectrumLegend, font) {
  return (useSpectrumLegend ? 0 : (checkboxVisible ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0) + LEGEND_ICON_SIZE + LEGEND_MARGIN_X) + getTextWidth(label, font);
}

function getLegendDataAppliedTheme(data, series) {
  var colors = Object.values(series).reduce(function (acc, cur) {
    return cur && cur.colors ? [].concat(legend_toConsumableArray(acc), legend_toConsumableArray(cur.colors)) : acc;
  }, []);
  var hasColorByCategories = data.some(function (legend) {
    return legend.colorByCategories;
  });
  return data.map(function (datum, idx) {
    var colorByCategories = datum.colorByCategories,
        colorIndex = datum.colorIndex;
    var index = hasColorByCategories ? colorIndex || idx : idx;
    return store_legend_objectSpread(store_legend_objectSpread({}, datum), {}, {
      color: colorByCategories ? '#aaa' : colors[index % colors.length]
    });
  });
}

function getLegendState(options, series, categories) {
  var _useColorValue, _options$series, _options$theme, _options$theme$chart, _options$theme2, _options$theme2$legen;

  var useSpectrumLegend = (_useColorValue = options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : _options$series.useColorValue) !== null && _useColorValue !== void 0 ? _useColorValue : !!series.heatmap;
  var useScatterChartIcon = !!(series !== null && series !== void 0 && series.scatter);
  var checkboxVisible = useSpectrumLegend ? false : showCheckbox(options);
  var defaultTheme = makeDefaultTheme(series, options === null || options === void 0 ? void 0 : (_options$theme = options.theme) === null || _options$theme === void 0 ? void 0 : (_options$theme$chart = _options$theme.chart) === null || _options$theme$chart === void 0 ? void 0 : _options$theme$chart.fontFamily);
  var font = getTitleFontString(deepMergedCopy(defaultTheme.legend.label, store_legend_objectSpread({}, (_options$theme2 = options.theme) === null || _options$theme2 === void 0 ? void 0 : (_options$theme2$legen = _options$theme2.legend) === null || _options$theme2$legen === void 0 ? void 0 : _options$theme2$legen.label)));
  var legendInfo = {
    checkboxVisible: checkboxVisible,
    font: font,
    useSpectrumLegend: useSpectrumLegend,
    legendOptions: options.legend
  };
  var legendLabelsInfo = hasNestedPieSeries(series) ? getNestedPieLegendLabelsInfo(series, legendInfo) : getLegendLabelsInfo(series, legendInfo, categories);
  var data = legendLabelsInfo.map(function (_ref4) {
    var label = _ref4.label,
        type = _ref4.type,
        checked = _ref4.checked,
        width = _ref4.width,
        viewLabel = _ref4.viewLabel,
        colorByCategories = _ref4.colorByCategories,
        colorIndex = _ref4.colorIndex;
    return {
      label: label,
      active: true,
      checked: checked,
      width: width,
      iconType: getIconType(type),
      chartType: type,
      rowIndex: 0,
      columnIndex: 0,
      viewLabel: viewLabel,
      colorByCategories: colorByCategories,
      colorIndex: colorIndex
    };
  });
  return {
    useSpectrumLegend: useSpectrumLegend,
    useScatterChartIcon: useScatterChartIcon,
    data: data
  };
}

function getNextColumnRowIndex(params) {
  var verticalAlign = params.verticalAlign,
      columnCount = params.columnCount,
      rowCount = params.rowCount,
      legendCount = params.legendCount;
  var rowIndex = params.rowIndex,
      columnIndex = params.columnIndex;

  if (verticalAlign) {
    var maxLen = legendCount / rowCount;

    if (maxLen - 1 > columnIndex) {
      columnIndex += 1;
    } else {
      rowIndex += 1;
      columnIndex = 0;
    }
  } else {
    var _maxLen = legendCount / columnCount;

    if (_maxLen - 1 > rowIndex) {
      rowIndex += 1;
    } else {
      columnIndex += 1;
      rowIndex = 0;
    }
  }

  return [rowIndex, columnIndex];
}

function setIndexToLegendData(legendData, rowCount, columnCount, legendCount, verticalAlign) {
  var columnIndex = 0;
  var rowIndex = 0;
  legendData.forEach(function (datum) {
    datum.rowIndex = rowIndex;
    datum.columnIndex = columnIndex;

    var _getNextColumnRowInde = getNextColumnRowIndex({
      rowCount: rowCount,
      columnCount: columnCount,
      verticalAlign: verticalAlign,
      legendCount: legendCount,
      rowIndex: rowIndex,
      columnIndex: columnIndex
    });

    var _getNextColumnRowInde2 = legend_slicedToArray(_getNextColumnRowInde, 2);

    rowIndex = _getNextColumnRowInde2[0];
    columnIndex = _getNextColumnRowInde2[1];
  });
}

var legend_legend = {
  name: 'legend',
  state: function state(_ref5) {
    var options = _ref5.options,
        series = _ref5.series,
        categories = _ref5.categories;
    return {
      legend: getLegendState(options, series, categories),
      circleLegend: {}
    };
  },
  action: {
    initLegendState: function initLegendState(_ref6) {
      var state = _ref6.state,
          initStoreState = _ref6.initStoreState;
      store_extend(state.legend, getLegendState(initStoreState.options, initStoreState.series, initStoreState.categories));
    },
    setLegendLayout: function setLegendLayout(_ref7) {
      var state = _ref7.state;

      if (state.legend.useSpectrumLegend) {
        this.dispatch('setSpectrumLegendLayout');
      } else {
        this.dispatch('setNormalLegendLayout');
      }
    },
    setSpectrumLegendLayout: function setSpectrumLegendLayout(_ref8) {
      var state = _ref8.state;
      var legendData = state.legend.data,
          series = state.series,
          options = state.options,
          chart = state.chart,
          theme = state.theme;
      var align = getLegendAlign(options);
      var visible = showLegend(options, series);
      var verticalAlign = isVerticalAlign(align);
      var legendWidths = legendData.map(function (_ref9) {
        var width = _ref9.width;
        return width;
      });
      var itemHeight = getLegendItemHeight(theme.legend.label.fontSize);
      var width = getSpectrumLegendWidth(legendWidths, chart.width, verticalAlign);
      var height = getSpectrumLegendHeight(itemHeight, chart.height, verticalAlign);
      store_extend(state.legend, {
        visible: visible,
        align: align,
        width: width,
        height: height
      });
    },
    setNormalLegendLayout: function setNormalLegendLayout(_ref10) {
      var state = _ref10.state,
          initStoreState = _ref10.initStoreState;
      var legendData = state.legend.data,
          series = state.series,
          options = state.options,
          chart = state.chart,
          theme = state.theme;
      var align = getLegendAlign(options);
      var visible = showLegend(options, series);
      var checkbox = showCheckbox(options);
      var initialWidth = Math.min(chart.width / 5, INITIAL_LEGEND_WIDTH);
      var verticalAlign = isVerticalAlign(align);
      var isNestedPieChart = hasNestedPieSeries(initStoreState.series);
      var isScatterChart = !!series.scatter;
      var isBubbleChart = !!series.bubble;
      var circleLegendVisible = isBubbleChart ? showCircleLegend(options) : false;
      var legendWidths = legendData.map(function (_ref11) {
        var width = _ref11.width;
        return width;
      });
      var itemHeight = getLegendItemHeight(theme.legend.label.fontSize);

      var _calculateLegendSize = calculateLegendSize({
        initialWidth: initialWidth,
        legendWidths: legendWidths,
        options: options,
        verticalAlign: verticalAlign,
        visible: visible,
        checkbox: checkbox,
        chart: chart,
        itemHeight: itemHeight,
        circleLegendVisible: circleLegendVisible
      }),
          legendWidth = _calculateLegendSize.legendWidth,
          legendHeight = _calculateLegendSize.legendHeight,
          rowCount = _calculateLegendSize.rowCount,
          columnCount = _calculateLegendSize.columnCount;

      setIndexToLegendData(legendData, rowCount, columnCount, legendWidths.length, verticalAlign);
      store_extend(state.legend, {
        visible: visible,
        align: align,
        showCheckbox: checkbox,
        width: legendWidth,
        height: legendHeight
      });

      if (isBubbleChart && circleLegendVisible) {
        this.dispatch('updateCircleLegendLayout', {
          legendWidth: legendWidth
        });
      }

      if (!isNestedPieChart && !isNoData(series)) {
        this.dispatch('updateLegendColor');
      }

      if (isScatterChart) {
        this.dispatch('updateLegendIcon');
      }
    },
    updateCircleLegendLayout: function updateCircleLegendLayout(_ref12, _ref13) {
      var state = _ref12.state;
      var legendWidth = _ref13.legendWidth;
      var width = legendWidth === 0 ? INITIAL_CIRCLE_LEGEND_WIDTH : Math.min(legendWidth, INITIAL_CIRCLE_LEGEND_WIDTH);
      var radius = Math.max((width - LEGEND_MARGIN_X) / 2, 0);
      store_extend(state.circleLegend, {
        visible: true,
        width: width,
        radius: radius
      });
    },
    setLegendActiveState: function setLegendActiveState(_ref14, _ref15) {
      var state = _ref14.state;
      var name = _ref15.name,
          active = _ref15.active;
      var data = state.legend.data;
      var model = data.find(function (_ref16) {
        var label = _ref16.label;
        return label === name;
      });
      model.active = active;
      this.notify(state, 'legend');
    },
    setAllLegendActiveState: function setAllLegendActiveState(_ref17, active) {
      var state = _ref17.state;
      state.legend.data.forEach(function (datum) {
        datum.active = active;
      });
      this.notify(state, 'legend');
    },
    setLegendCheckedState: function setLegendCheckedState(_ref18, _ref19) {
      var state = _ref18.state;
      var name = _ref19.name,
          checked = _ref19.checked;
      var model = state.legend.data.find(function (_ref20) {
        var label = _ref20.label;
        return label === name;
      });
      model.checked = checked;
      this.notify(state, 'legend');
    },
    updateLegendColor: function updateLegendColor(_ref21) {
      var state = _ref21.state;
      var legendData = state.legend,
          series = state.series;
      var data = getLegendDataAppliedTheme(legendData.data, series);
      store_extend(state.legend, {
        data: data
      });
    },
    updateLegendIcon: function updateLegendIcon(_ref22) {
      var state = _ref22.state;
      var legendData = state.legend,
          series = state.series;
      var data = legendData.data.reduce(function (acc, cur) {
        var _series$scatter;

        if (cur.chartType === 'scatter' && (_series$scatter = series.scatter) !== null && _series$scatter !== void 0 && _series$scatter.data) {
          var model = series.scatter.data.find(function (_ref23) {
            var name = _ref23.name;
            return name === cur.label;
          });
          var iconType = model ? model.iconType : cur.iconType;
          return [].concat(legend_toConsumableArray(acc), [store_legend_objectSpread(store_legend_objectSpread({}, cur), {}, {
            iconType: iconType
          })]);
        }

        return [].concat(legend_toConsumableArray(acc), [cur]);
      }, []);
      store_extend(state.legend, {
        data: data
      });
    },
    updateNestedPieChartLegend: function updateNestedPieChartLegend(_ref24) {
      var state = _ref24.state;
      var legendData = state.legend,
          nestedPieSeries = state.nestedPieSeries;
      store_extend(state.legend, {
        data: getLegendDataAppliedTheme(legendData.data, nestedPieSeries)
      });
    }
  },
  observe: {
    updateLegendLayout: function updateLegendLayout() {
      this.dispatch('setLegendLayout');
    }
  }
};
/* harmony default export */ var store_legend = (legend_legend);
;// CONCATENATED MODULE: ./src/store/options.ts


function getOptionsBySize(size, options) {
  var _options$responsive;

  var rules = (_options$responsive = options.responsive) === null || _options$responsive === void 0 ? void 0 : _options$responsive.rules;
  return Array.isArray(rules) ? rules.reduce(function (acc, cur) {
    return cur.condition(size) ? deepMergedCopy(acc, cur.options) : acc;
  }, options) : options;
}

function getSize(usingContainerSize, containerSize, chartSize) {
  var usingContainerWidth = usingContainerSize.width,
      usingContainerHeight = usingContainerSize.height;
  return {
    width: usingContainerWidth ? containerSize.width : chartSize === null || chartSize === void 0 ? void 0 : chartSize.width,
    height: usingContainerHeight ? containerSize.height : chartSize === null || chartSize === void 0 ? void 0 : chartSize.height
  };
}

var optionsData = {
  name: 'options',
  state: function state(_ref) {
    var options = _ref.options;
    return {
      originalOptions: deepCopy(options),
      options: options
    };
  },
  action: {
    setOptions: function setOptions(_ref2) {
      var state = _ref2.state;
      var _state$chart = state.chart,
          width = _state$chart.width,
          height = _state$chart.height;

      if (width < 0 || height < 0) {
        return;
      }

      state.options = getOptionsBySize({
        width: width,
        height: height
      }, state.originalOptions);
    },
    initOptions: function initOptions(_ref3, _ref4) {
      var initStoreState = _ref3.initStoreState,
          state = _ref3.state;
      var options = _ref4.options,
          containerSize = _ref4.containerSize;
      initStoreState.options = options;
      state.originalOptions = deepCopy(options);
      var usingContainerSize = state.usingContainerSize,
          originalOptions = state.originalOptions;
      var size = getSize(usingContainerSize, containerSize, {
        width: originalOptions.chart.width,
        height: originalOptions.chart.height
      });
      this.dispatch('setChartSize', size);
    },
    updateOptions: function updateOptions(_ref5, _ref6) {
      var _originalOptions$char, _originalOptions$char2;

      var state = _ref5.state,
          initStoreState = _ref5.initStoreState;
      var options = _ref6.options,
          containerSize = _ref6.containerSize;
      initStoreState.options = deepMergedCopy(initStoreState.options, options);
      state.originalOptions = deepMergedCopy(state.originalOptions, options);
      var usingContainerSize = state.usingContainerSize,
          originalOptions = state.originalOptions;
      var size = getSize(usingContainerSize, containerSize, {
        width: (_originalOptions$char = originalOptions.chart) === null || _originalOptions$char === void 0 ? void 0 : _originalOptions$char.width,
        height: (_originalOptions$char2 = originalOptions.chart) === null || _originalOptions$char2 === void 0 ? void 0 : _originalOptions$char2.height
      });
      this.dispatch('setChartSize', size);
      this.dispatch('initThemeState');
    }
  },
  observe: {
    updateOptions: function updateOptions() {
      this.dispatch('setOptions');
    }
  }
};
/* harmony default export */ var options = (optionsData);
;// CONCATENATED MODULE: ./src/store/theme.ts
function theme_toConsumableArray(arr) { return theme_arrayWithoutHoles(arr) || theme_iterableToArray(arr) || theme_unsupportedIterableToArray(arr) || theme_nonIterableSpread(); }

function theme_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function theme_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return theme_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return theme_arrayLikeToArray(o, minLen); }

function theme_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function theme_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return theme_arrayLikeToArray(arr); }

function theme_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function store_theme_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function store_theme_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { store_theme_ownKeys(Object(source), true).forEach(function (key) { store_theme_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { store_theme_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function store_theme_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }























function getCommonSeriesOptions(options, series, isNestedPieChart) {
  var theme = options === null || options === void 0 ? void 0 : options.theme;

  if (!(theme !== null && theme !== void 0 && theme.series)) {
    return {};
  }

  var seriesNames = isNestedPieChart ? getNestedPieChartAliasNames(series) : Object.keys(series);
  return seriesNames.reduce(function (acc, seriesName) {
    delete acc[seriesName];
    return acc;
  }, store_theme_objectSpread({}, theme.series));
}

function getThemeAppliedSecondaryYAxis(options) {
  var _options$theme, _options$theme$chart;

  var theme = store_theme_objectSpread({}, options.theme);

  if (!Array.isArray(theme.yAxis)) {
    return theme;
  }

  var axisTitleTheme = makeAxisTitleTheme(options === null || options === void 0 ? void 0 : (_options$theme = options.theme) === null || _options$theme === void 0 ? void 0 : (_options$theme$chart = _options$theme.chart) === null || _options$theme$chart === void 0 ? void 0 : _options$theme$chart.fontFamily);
  var yAxis = theme.yAxis.map(function (yAxisTheme) {
    return deepMergedCopy({
      title: store_theme_objectSpread({}, axisTitleTheme)
    }, store_theme_objectSpread({}, yAxisTheme));
  });
  return store_theme_objectSpread(store_theme_objectSpread({}, theme), {}, {
    yAxis: yAxis
  });
}

function getThemeOptionsWithSeriesName(options, series, commonSeriesOptions, isNestedPieChart) {
  var theme = getThemeAppliedSecondaryYAxis(options);

  if (!(theme !== null && theme !== void 0 && theme.series)) {
    return store_theme_objectSpread({}, theme);
  }

  var seriesTheme = store_theme_objectSpread(store_theme_objectSpread({}, theme), {}, {
    series: {}
  });

  var seriesNames = Object.keys(series);
  var isComboChart = seriesNames.length > 1;

  if (isNestedPieChart) {
    var aliasNames = getNestedPieChartAliasNames(series);
    seriesTheme.series = {
      pie: aliasNames.reduce(function (acc, aliasName) {
        var _theme$series;

        return store_theme_objectSpread(store_theme_objectSpread({}, acc), {}, store_theme_defineProperty({}, aliasName, deepMergedCopy((_theme$series = theme.series) === null || _theme$series === void 0 ? void 0 : _theme$series[aliasName], omit(commonSeriesOptions, 'colors'))));
      }, {})
    };
  } else if (isComboChart) {
    seriesTheme.series = store_theme_objectSpread({}, seriesNames.reduce(function (acc, seriesName) {
      var _theme$series2;

      return store_theme_objectSpread(store_theme_objectSpread({}, acc), {}, store_theme_defineProperty({}, seriesName, deepMergedCopy((_theme$series2 = theme.series) === null || _theme$series2 === void 0 ? void 0 : _theme$series2[seriesName], omit(commonSeriesOptions, 'colors'))));
    }, {}));
  } else {
    seriesTheme.series = store_theme_defineProperty({}, seriesNames[0], theme.series);
  }

  return seriesTheme;
}

function setColors(theme, series, commonSeriesOptions, isNestedPieChart, categories) {
  var _ref;

  var index = 0;
  var commonColorsOption = [].concat(theme_toConsumableArray((_ref = commonSeriesOptions === null || commonSeriesOptions === void 0 ? void 0 : commonSeriesOptions.colors) !== null && _ref !== void 0 ? _ref : []), theme_toConsumableArray(defaultSeriesTheme.colors));
  var themeNames = isNestedPieChart ? getNestedPieChartAliasNames(series) : Object.keys(series);
  themeNames.forEach(function (name, idx) {
    var _target$name;

    var themeSeries = series[name] || [];
    var filteredSeries = themeSeries.filter(function (chartSeries) {
      return chartSeries.colorByCategories;
    });
    var hasColorByCategories = filteredSeries.length > 0;
    var size;

    if (isNestedPieChart) {
      size = series.pie[idx].data.length;
    } else if (hasColorByCategories) {
      var rejectedSeries = themeSeries.filter(function (chartSeries) {
        return !chartSeries.colorByCategories;
      });
      size = rejectedSeries.length + categories.length;
    } else {
      size = series[name].length;
    }

    var target = isNestedPieChart ? theme.series.pie : theme.series;

    if (!((_target$name = target[name]) !== null && _target$name !== void 0 && _target$name.colors)) {
      target[name] = store_theme_objectSpread(store_theme_objectSpread({}, target[name]), {}, {
        colors: commonColorsOption.slice(index, index + size)
      });
      index += size;
    }
  });
}

function setPlot(theme) {
  ['vertical', 'horizontal'].reduce(function (acc, cur) {
    if (!acc[cur]) {
      acc[cur] = {
        lineColor: acc.lineColor
      };
    }

    return acc;
  }, theme.plot);
}

function checkAnchorPieSeriesOption(options, series, alias) {
  var _options$series, _options$series$alias, _options$series$alias2, _options$series2, _options$series2$alia, _options$series2$alia2, _options$series2$alia3;

  return {
    hasOuterAnchor: !!series.pie && (options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : (_options$series$alias = _options$series[alias]) === null || _options$series$alias === void 0 ? void 0 : (_options$series$alias2 = _options$series$alias.dataLabels) === null || _options$series$alias2 === void 0 ? void 0 : _options$series$alias2.anchor) === 'outer',
    hasOuterAnchorPieSeriesName: !!series.pie && (options === null || options === void 0 ? void 0 : (_options$series2 = options.series) === null || _options$series2 === void 0 ? void 0 : (_options$series2$alia = _options$series2[alias]) === null || _options$series2$alia === void 0 ? void 0 : (_options$series2$alia2 = _options$series2$alia.dataLabels) === null || _options$series2$alia2 === void 0 ? void 0 : (_options$series2$alia3 = _options$series2$alia2.pieSeriesName) === null || _options$series2$alia3 === void 0 ? void 0 : _options$series2$alia3.anchor) === 'outer'
  };
}

function getTheme(options, series, categories) {
  var _options$theme2, _options$theme2$chart;

  var isNestedPieChart = hasNestedPieSeries(series);
  var commonSeriesOptions = getCommonSeriesOptions(options, series, isNestedPieChart);
  var pieSeriesOuterAnchors = {
    hasOuterAnchor: hasOuterDataLabel(options, series),
    hasOuterAnchorPieSeriesName: hasOuterPieSeriesName(options, series)
  };

  if (isNestedPieChart) {
    var aliasNames = getNestedPieChartAliasNames(series);
    pieSeriesOuterAnchors = aliasNames.reduce(function (acc, cur) {
      return store_theme_objectSpread(store_theme_objectSpread({}, acc), {}, store_theme_defineProperty({}, cur, checkAnchorPieSeriesOption(options, series, cur)));
    }, {});
  }

  var globalFontFamily = options === null || options === void 0 ? void 0 : (_options$theme2 = options.theme) === null || _options$theme2 === void 0 ? void 0 : (_options$theme2$chart = _options$theme2.chart) === null || _options$theme2$chart === void 0 ? void 0 : _options$theme2$chart.fontFamily;
  var theme = deepMergedCopy(getDefaultTheme(series, pieSeriesOuterAnchors, globalFontFamily, isNestedPieChart), getThemeOptionsWithSeriesName(options, series, commonSeriesOptions, isNestedPieChart));

  if (!series.heatmap) {
    setColors(theme, series, commonSeriesOptions, isNestedPieChart, categories);
  }

  setPlot(theme);
  return theme;
}

var theme = {
  name: 'theme',
  state: function state(_ref2) {
    var options = _ref2.options,
        series = _ref2.series,
        categories = _ref2.categories;
    return {
      theme: getTheme(options, series, categories)
    };
  },
  action: {
    initThemeState: function initThemeState(_ref3) {
      var state = _ref3.state,
          initStoreState = _ref3.initStoreState;
      state.theme = getTheme(state.options, initStoreState.series, initStoreState.categories);
    }
  },
  observe: {
    updateTheme: function updateTheme() {
      this.dispatch('initThemeState');
    }
  }
};
/* harmony default export */ var store_theme = (theme);
;// CONCATENATED MODULE: ./src/eventEmitter.ts


function eventEmitter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function eventEmitter_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function eventEmitter_createClass(Constructor, protoProps, staticProps) { if (protoProps) eventEmitter_defineProperties(Constructor.prototype, protoProps); if (staticProps) eventEmitter_defineProperties(Constructor, staticProps); return Constructor; }

function eventEmitter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var EventEmitter = /*#__PURE__*/function () {
  function EventEmitter() {
    eventEmitter_classCallCheck(this, EventEmitter);

    eventEmitter_defineProperty(this, "handlers", []);
  }

  eventEmitter_createClass(EventEmitter, [{
    key: "on",
    value: function on(type, handler) {
      if (!this.handlers[type]) {
        this.handlers[type] = [];
      }

      this.handlers[type].push(handler);
    }
  }, {
    key: "emit",
    value: function emit(type) {
      var _this$handlers$type;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      (_this$handlers$type = this.handlers[type]) === null || _this$handlers$type === void 0 ? void 0 : _this$handlers$type.forEach(function (handler) {
        return handler.apply(void 0, args);
      });
    }
  }]);

  return EventEmitter;
}();


;// CONCATENATED MODULE: ./src/component/componentManager.ts



function componentManager_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function componentManager_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function componentManager_createClass(Constructor, protoProps, staticProps) { if (protoProps) componentManager_defineProperties(Constructor.prototype, protoProps); if (staticProps) componentManager_defineProperties(Constructor, staticProps); return Constructor; }

function componentManager_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var ComponentManager = /*#__PURE__*/function () {
  function ComponentManager(_ref) {
    var store = _ref.store,
        eventBus = _ref.eventBus;

    componentManager_classCallCheck(this, ComponentManager);

    componentManager_defineProperty(this, "components", []);

    componentManager_defineProperty(this, "store", void 0);

    componentManager_defineProperty(this, "eventBus", void 0);

    this.store = store;
    this.eventBus = eventBus;
  }

  componentManager_createClass(ComponentManager, [{
    key: "add",
    value: function add(ComponentCtor, initialParam) {
      var _this = this;

      var component = new ComponentCtor({
        store: this.store,
        eventBus: this.eventBus
      });

      if (component.initialize) {
        component.initialize(initialParam);
      }

      var proc = function proc() {
        component.render(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1]); // rest 

        component.sync();

        _this.eventBus.emit('needLoop');
      };

      this.store.observe(function () {
        proc.apply(void 0, arguments);
      });
      proc = debounce(proc);
      this.components.push(component);
    }
  }, {
    key: "remove",
    value: function remove(ComponentCtor) {
      this.components = this.components.filter(function (component) {
        return !(component instanceof ComponentCtor);
      });
    }
  }, {
    key: "clear",
    value: function clear() {
      this.components = [];
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "invoke",
    value: function invoke(method, params) {
      this.components.forEach(function (component) {
        var fn = component[method];

        if (fn) {
          fn.call(component, params);
        }
      });
    }
  }, {
    key: "forEach",
    value: function forEach(iteratee) {
      this.components.forEach(iteratee);
    }
  }]);

  return ComponentManager;
}();


;// CONCATENATED MODULE: ./src/painter.ts



function painter_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function painter_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function painter_createClass(Constructor, protoProps, staticProps) { if (protoProps) painter_defineProperties(Constructor.prototype, protoProps); if (staticProps) painter_defineProperties(Constructor, staticProps); return Constructor; }

function painter_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var Painter = /*#__PURE__*/function () {
  function Painter(chart) {
    painter_classCallCheck(this, Painter);

    painter_defineProperty(this, "width", 0);

    painter_defineProperty(this, "height", 0);

    painter_defineProperty(this, "brushes", {});

    painter_defineProperty(this, "chart", void 0);

    painter_defineProperty(this, "canvas", void 0);

    painter_defineProperty(this, "ctx", void 0);

    this.chart = chart;
  }

  painter_createClass(Painter, [{
    key: "showUnsupportedCanvasFeatureError",
    value: function showUnsupportedCanvasFeatureError() {
      if (!this.ctx.setLineDash) {
        console.warn(message.DASH_SEGMENTS_UNAVAILABLE_ERROR);
      }
    }
  }, {
    key: "setup",
    value: function setup() {
      var _this$chart$store$sta = this.chart.store.state.chart,
          height = _this$chart$store$sta.height,
          width = _this$chart$store$sta.width;

      if (!this.canvas) {
        var canvas = document.createElement('canvas');
        this.canvas = canvas;
        this.chart.el.appendChild(canvas);
        canvas.addEventListener('click', this.chart);
        canvas.addEventListener('mousemove', this.chart);
        canvas.addEventListener('mousedown', this.chart);
        canvas.addEventListener('mouseup', this.chart);
        canvas.addEventListener('mouseout', this.chart);

        var _ctx = canvas.getContext('2d');

        if (_ctx) {
          this.ctx = _ctx;
        }
      }

      this.setSize(width, height);
      this.showUnsupportedCanvasFeatureError();
    }
  }, {
    key: "setSize",
    value: function setSize(width, height) {
      this.canvas.style.width = "".concat(width, "px");
      this.canvas.style.height = "".concat(height, "px");
      var ratio = 1;

      if ('deviceXDPI' in window.screen) {
        // IE mobile or IE
        ratio = window.screen.deviceXDPI / window.screen.logicalXDPI;
      } else if (window.hasOwnProperty('devicePixelRatio')) {
        ratio = window.devicePixelRatio;
      }

      this.width = width * ratio || 0;
      this.height = height * ratio || 0;
      this.scaleCanvasRatio(ratio);
    }
  }, {
    key: "scaleCanvasRatio",
    value: function scaleCanvasRatio(ratio) {
      this.canvas.width = this.width;
      this.canvas.height = this.height;
      this.ctx.scale(ratio, ratio);
    }
  }, {
    key: "add",
    value: function add(name, brush) {
      this.brushes[name] = brush;
    }
  }, {
    key: "addGroups",
    value: function addGroups(groups) {
      var _this = this;

      groups.forEach(function (group) {
        Object.keys(group).forEach(function (key) {
          _this.add(key, group[key]);
        });
      });
    }
  }, {
    key: "paint",
    value: function paint(name, brushModel) {
      if (this.brushes[name]) {
        this.brushes[name](this.ctx, brushModel);
      } else {
        throw new Error(message.noBrushError(name));
      }
    }
  }, {
    key: "paintForEach",
    value: function paintForEach(brushModels) {
      var _this2 = this;

      brushModels.forEach(function (m) {
        return _this2.paint(m.type, m);
      });
    }
  }, {
    key: "beforeFrame",
    value: function beforeFrame() {
      this.ctx.clearRect(0, 0, this.width, this.height);
      this.ctx.fillStyle = 'transparent';
      this.ctx.fillRect(0, 0, this.width, this.height);
    }
  }, {
    key: "beforeDraw",
    value: function beforeDraw(transX, transY) {
      this.ctx.save();
      this.ctx.translate(transX, transY);
    }
  }, {
    key: "afterDraw",
    value: function afterDraw() {
      this.ctx.restore();
    }
  }]);

  return Painter;
}();


;// CONCATENATED MODULE: ./src/animator.ts



function animator_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function animator_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function animator_createClass(Constructor, protoProps, staticProps) { if (protoProps) animator_defineProperties(Constructor.prototype, protoProps); if (staticProps) animator_defineProperties(Constructor, staticProps); return Constructor; }

function animator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var Animator = /*#__PURE__*/function () {
  function Animator() {
    animator_classCallCheck(this, Animator);

    animator_defineProperty(this, "anims", []);

    animator_defineProperty(this, "state", 'IDLE');

    animator_defineProperty(this, "requestId", null);

    animator_defineProperty(this, "firstRendering", true);
  }

  animator_createClass(Animator, [{
    key: "add",
    value: function add(_ref) {
      var _this = this;

      var chart = _ref.chart,
          duration = _ref.duration,
          requester = _ref.requester,
          _ref$onCompleted = _ref.onCompleted,
          onCompleted = _ref$onCompleted === void 0 ? function () {} : _ref$onCompleted,
          _ref$onFrame = _ref.onFrame,
          onFrame = _ref$onFrame === void 0 ? function (delta) {
        if (!_this.firstRendering) {
          chart.update(delta);
        }

        if (_this.firstRendering) {
          chart.initUpdate(delta);

          if (delta === 1) {
            _this.firstRendering = false;
          }
        }
      } : _ref$onFrame;

      if (this.anims.length) {
        this.reset();
      }

      if (this.state === 'IDLE') {
        this.anims.push({
          chart: chart,
          requester: requester,
          duration: duration,
          onFrame: onFrame,
          onCompleted: onCompleted,
          start: null,
          current: null,
          completed: false
        });
        this.start();
      }
    }
  }, {
    key: "reset",
    value: function reset() {
      this.anims.forEach(function (anim) {
        anim.current = 1;
        anim.onFrame(anim.current);
        anim.completed = true;
      });
      this.anims = [];
      this.cancelAnimFrame();
      this.state = 'IDLE';
      this.requestId = null;
    }
  }, {
    key: "start",
    value: function start() {
      if (this.anims.length) {
        this.state = 'RUNNING';
        this.runFrame();
      }
    }
  }, {
    key: "runFrame",
    value: function runFrame() {
      var _this2 = this;

      this.requestId = window.requestAnimationFrame(function (timestamp) {
        _this2.runAnims(timestamp);
      });
    }
  }, {
    key: "runAnims",
    value: function runAnims(timestamp) {
      this.next(timestamp);

      if (this.anims.length) {
        this.runFrame();
      } else {
        this.state = 'IDLE';
        this.requestId = null;
      }
    }
  }, {
    key: "next",
    value: function next(timestamp) {
      var _this3 = this;

      this.anims.forEach(function (anim) {
        if (isNull(anim.start)) {
          anim.start = timestamp;
        }

        Object.defineProperty(anim.chart, '___animId___', {
          value: timestamp,
          enumerable: false,
          writable: false,
          configurable: true
        });
        anim.current = anim.duration ? Math.min((timestamp - anim.start) / anim.duration, 1) : 1;
        anim.onFrame(anim.current);
        anim.completed = anim.current === 1;
      });
      this.anims.forEach(function (anim) {
        if (anim.chart.___animId___ === timestamp) {
          anim.chart.draw();
          delete anim.chart.___animId___;
        }

        if (anim.completed) {
          _this3.cancelAnimFrame();

          anim.onCompleted();
          anim.chart.eventBus.emit('animationCompleted', anim.requester);
        }
      });
      this.anims = this.anims.filter(function (anim) {
        return !anim.completed;
      });
    }
  }, {
    key: "cancelAnimFrame",
    value: function cancelAnimFrame() {
      if (this.requestId) {
        window.cancelAnimationFrame(this.requestId);
      }
    }
  }]);

  return Animator;
}();


;// CONCATENATED MODULE: ./src/responderDetectors.ts











function responderDetectors_slicedToArray(arr, i) { return responderDetectors_arrayWithHoles(arr) || responderDetectors_iterableToArrayLimit(arr, i) || responderDetectors_unsupportedIterableToArray(arr, i) || responderDetectors_nonIterableRest(); }

function responderDetectors_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function responderDetectors_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return responderDetectors_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return responderDetectors_arrayLikeToArray(o, minLen); }

function responderDetectors_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function responderDetectors_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function responderDetectors_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }




function withinRotationRect(_ref) {
  var slope = _ref.slope,
      yIntercept = _ref.yIntercept,
      mouseX = _ref.mouseX,
      mouseY = _ref.mouseY,
      modelXPositions = _ref.modelXPositions,
      compX = _ref.compX,
      compY = _ref.compY,
      _ref$detectionSize = _ref.detectionSize,
      detectionSize = _ref$detectionSize === void 0 ? 0 : _ref$detectionSize;

  var _modelXPositions = responderDetectors_slicedToArray(modelXPositions, 2),
      x1 = _modelXPositions[0],
      x2 = _modelXPositions[1];

  var posY = slope * (mouseX - compX) + yIntercept;
  var withinRadius = x1 > x2 && mouseX >= compX + x2 && mouseX <= compX + x1 || x1 < x2 && mouseX <= compX + x2 && mouseX >= compX + x1;
  var withinDetectionSize = posY - detectionSize + compY <= mouseY && mouseY <= posY + detectionSize + compY;
  return withinRadius && withinDetectionSize;
}

var responderDetectors = {
  circle: function circle(mousePosition, model, componentRect) {
    var x = mousePosition.x,
        y = mousePosition.y;
    var modelX = model.x,
        modelY = model.y,
        radius = model.radius,
        detectionSize = model.detectionSize;
    var compX = componentRect.x,
        compY = componentRect.y;
    var radiusAdjustment = isUndefined(detectionSize) ? 10 : detectionSize;
    return Math.pow(x - (modelX + compX), 2) + Math.pow(y - (modelY + compY), 2) < Math.pow(radius + radiusAdjustment, 2);
  },
  rect: function rect(mousePosition, model) {
    var componentRect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    var x = mousePosition.x,
        y = mousePosition.y;
    var modelX = model.x,
        modelY = model.y,
        width = model.width,
        height = model.height;
    var compX = componentRect.x,
        compY = componentRect.y;
    return x >= modelX + compX && x <= modelX + compX + width && y >= modelY + compY && y <= modelY + compY + height;
  },
  sector: function sector(mousePosition, model) {
    var componentRect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    var x = mousePosition.x,
        y = mousePosition.y;
    var modelX = model.x,
        modelY = model.y,
        _model$radius = model.radius,
        outer = _model$radius.outer,
        inner = _model$radius.inner,
        _model$degree = model.degree,
        start = _model$degree.start,
        end = _model$degree.end,
        drawingStartAngle = model.drawingStartAngle,
        clockwise = model.clockwise;
    var compX = componentRect.x,
        compY = componentRect.y;
    var xPos = x - (modelX + compX);
    var yPos = y - (modelY + compY);
    var insideOuterRadius = Math.pow(xPos, 2) + Math.pow(yPos, 2) < Math.pow(outer, 2);
    var outsideInnerRadius = Math.pow(xPos, 2) + Math.pow(yPos, 2) > Math.pow(inner, 2);
    var withinRadius = insideOuterRadius && outsideInnerRadius;
    var detectionDegree = calculateRadianToDegree(Math.atan2(yPos, xPos), drawingStartAngle);
    return withinRadius && withinRadian(clockwise, start, end, detectionDegree);
  },
  line: function line(mousePosition, model) {
    var componentRect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    var x = mousePosition.x,
        y = mousePosition.y;
    var compX = componentRect.x,
        compY = componentRect.y;
    var modelX = model.x,
        modelY = model.y,
        x2 = model.x2,
        y2 = model.y2,
        _model$detectionSize = model.detectionSize,
        detectionSize = _model$detectionSize === void 0 ? 3 : _model$detectionSize;
    var numerator = y2 - modelY;
    var denominator = x2 - modelX;
    var withinLine = false;

    if (numerator === 0) {
      var minX = Math.min(modelX, x2);
      var maxX = Math.max(modelX, x2);
      withinLine = x - compX >= minX && x - compX <= maxX && y >= modelY + compY - detectionSize && y <= modelY + compY + detectionSize;
    } else if (denominator === 0) {
      var minY = Math.min(modelY, y2);
      var maxY = Math.max(modelY, y2);
      withinLine = y - compY >= minY && y - compY <= maxY && x >= modelX + compX - detectionSize && x <= modelX + compX + detectionSize;
    } else {
      var slope = numerator / denominator;
      var xPos = x - (modelX + compX);
      var yPos = y - (modelY + compY);
      withinLine = slope * xPos === yPos;
    }

    return withinLine;
  },
  boxPlot: function boxPlot(mousePosition, model) {
    var componentRect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    return ['rect', 'median', 'minimum', 'maximum', 'upperWhisker', 'lowerWhisker'].some(function (prop) {
      if (!model[prop]) {
        return false;
      }

      return prop === 'rect' ? responderDetectors.rect(mousePosition, model[prop], componentRect) : responderDetectors.line(mousePosition, model[prop], componentRect);
    });
  },
  clockHand: function clockHand(mousePosition, model) {
    var componentRect = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    var x = mousePosition.x,
        y = mousePosition.y;
    var compX = componentRect.x,
        compY = componentRect.y;
    var centerX = model.x,
        centerY = model.y,
        x2 = model.x2,
        y2 = model.y2,
        _model$detectionSize2 = model.detectionSize,
        detectionSize = _model$detectionSize2 === void 0 ? 5 : _model$detectionSize2;
    var numerator = y2 - centerY;
    var denominator = x2 - centerX;
    var withinClockHand = false;

    if (numerator === 0) {
      var minX = Math.min(centerX, x2);
      var maxX = Math.max(centerX, x2);
      withinClockHand = x - compX >= minX && x - compX <= maxX && y >= centerY + compY - detectionSize && y <= centerY + compY + detectionSize;
    } else if (denominator === 0) {
      var minY = Math.min(centerY, y2);
      var maxY = Math.max(centerY, y2);
      withinClockHand = y - compY >= minY && y - compY <= maxY && x >= centerX + compX - detectionSize && x <= centerX + compX + detectionSize;
    } else {
      var slope = numerator / denominator;
      var yIntercept = centerY - slope * centerX;
      withinClockHand = withinRotationRect({
        slope: slope,
        yIntercept: yIntercept,
        mouseX: x,
        mouseY: y,
        modelXPositions: [centerX, x2],
        compX: compX,
        compY: compY,
        detectionSize: detectionSize
      });
    }

    return withinClockHand;
  }
};
;// CONCATENATED MODULE: ./src/helpers/googleAnalytics.ts





var MS_7_DAYS = 7 * 24 * 60 * 60 * 1000;

function isExpired(date) {
  var now = new Date().getTime();
  return now - date > MS_7_DAYS;
}

function imagePing(url, trackingInfo) {
  var queryString = Object.keys(trackingInfo).map(function (id, index) {
    return "".concat(index ? '&' : '').concat(id, "=").concat(trackingInfo[id]);
  }).join('');
  var trackingElement = document.createElement('img');
  trackingElement.src = "".concat(url, "?").concat(queryString);
  trackingElement.style.display = 'none';
  document.body.appendChild(trackingElement);
  document.body.removeChild(trackingElement);
  return trackingElement;
}

function sendHostname() {
  var hostname = location.hostname;
  var applicationKeyForStorage = "TOAST UI chart for ".concat(hostname, ": Statistics");
  var date = window.localStorage.getItem(applicationKeyForStorage);

  if (date && !isExpired(Number(date))) {
    return;
  }

  window.localStorage.setItem(applicationKeyForStorage, String(new Date().getTime()));
  setTimeout(function () {
    if (document.readyState === 'interactive' || document.readyState === 'complete') {
      imagePing('https://www.google-analytics.com/collect', {
        v: 1,
        t: 'event',
        tid: 'UA-129983528-2',
        cid: hostname,
        dp: hostname,
        dh: 'chart',
        el: 'chart',
        ec: 'use'
      });
    }
  }, 1000);
}
;// CONCATENATED MODULE: ./src/charts/chart.ts
function chart_toConsumableArray(arr) { return chart_arrayWithoutHoles(arr) || chart_iterableToArray(arr) || chart_unsupportedIterableToArray(arr) || chart_nonIterableSpread(); }

function chart_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function chart_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return chart_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return chart_arrayLikeToArray(o, minLen); }

function chart_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function chart_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return chart_arrayLikeToArray(arr); }

function chart_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function chart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function chart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { chart_ownKeys(Object(source), true).forEach(function (key) { chart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { chart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



















function chart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function chart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function chart_createClass(Constructor, protoProps, staticProps) { if (protoProps) chart_defineProperties(Constructor.prototype, protoProps); if (staticProps) chart_defineProperties(Constructor, staticProps); return Constructor; }

function chart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



















var DEFAULT_ANIM_DURATION = 500;

function getUsingContainerSize(eventName, usingContainerSize, width, height) {
  var usingContainerWidth = usingContainerSize.width,
      usingContainerHeight = usingContainerSize.height;
  var isAutoWidth = isAutoValue(width);
  var isAutoHeight = isAutoValue(height);
  return eventName === 'updateOptions' ? {
    width: !isUndefined(width) && usingContainerWidth !== isAutoWidth ? isAutoWidth : usingContainerWidth,
    height: !isUndefined(height) && usingContainerHeight !== isAutoHeight ? isAutoHeight : usingContainerHeight
  } : {
    width: isAutoWidth,
    height: isAutoHeight
  };
}
/**
 * @class
 * @abstract
 * Abstract class used to implement each chart.
 */


var Chart = /*#__PURE__*/function () {
  function Chart(props) {
    var _this = this,
        _options$chart4,
        _options$chart5;

    chart_classCallCheck(this, Chart);

    chart_defineProperty(this, "store", void 0);

    chart_defineProperty(this, "___animId___", null);

    chart_defineProperty(this, "animator", void 0);

    chart_defineProperty(this, "containerEl", void 0);

    chart_defineProperty(this, "el", void 0);

    chart_defineProperty(this, "ctx", void 0);

    chart_defineProperty(this, "painter", new Painter(this));

    chart_defineProperty(this, "eventBus", new EventEmitter());

    chart_defineProperty(this, "componentManager", void 0);

    chart_defineProperty(this, "modules", void 0);

    chart_defineProperty(this, "enteredComponents", []);

    chart_defineProperty(this, "animationControlFlag", {
      resizing: false,
      updating: false
    });

    chart_defineProperty(this, "resizeObserver", null);

    chart_defineProperty(this, "debounceResizeEvent", debounce(function () {
      var _this$containerEl = _this.containerEl,
          offsetWidth = _this$containerEl.offsetWidth,
          offsetHeight = _this$containerEl.offsetHeight;

      _this.resizeChartSize(offsetWidth, offsetHeight);
    }, 100));

    chart_defineProperty(this, "getCheckedLegend", function () {
      var data = _this.store.state.legend.data;
      return data.filter(function (datum) {
        return datum.checked;
      }).map(function (datum) {
        return pick(datum, 'chartType', 'label', 'checked');
      });
    });

    chart_defineProperty(this, "getOptions", function () {
      return makeObservableObjectToNormal(_this.store.initStoreState.options);
    });

    chart_defineProperty(this, "on", function (eventName, handler) {
      /**
       * Register Events that occur when click legend label
       * @event ChartBase#clickLegendLabel
       * @param {object} info selected legend information
       * @api
       * @example
       * chart.on('clickLegendLabel', (info) => {
       *   console.log(info);
       * });
       */

      /**
       * Register Events that occur when click legend checkbox
       * @event ChartBase#clickLegendCheckbox
       * @param {object} info selected legend info
       * @api
       * @example
       * chart.on('clickLegendCheckbox', (info) => {
       *   console.log(info);
       * });
       */

      /**
       * Register Events that occur when select series
       * @event ChartBase#selectSeries
       * @param {object} info selected series info
       * @api
       * @example
       * chart.on('selectSeries', (info) => {
       *   console.log(info);
       * });
       */

      /**
       * Register Events that occur when unselect series
       * @event ChartBase#unselectSeries
       * @param {object} info unselected series info
       * @api
       * @example
       * chart.on('unselectSeries', (info) => {
       *   console.log(info);
       * });
       */

      /**
       * Register Events that occur when hover to series
       * @event ChartBase#hoverSeries
       * @param {object} info hovered series info
       * @api
       * @example
       * chart.on('hoverSeries', (info) => {
       *   console.log(info);
       * });
       */

      /**
       * Register Events that occur when unhover from series
       * @event ChartBase#unhoverSeries
       * @param {object} info unhovered series info
       * @api
       * @example
       * chart.on('unhoverSeries', (info) => {
       *  console.log(info);
       * });
       */

      /**
       * Register Events that occur when zooming
       * @event ChartBase#zoom
       * @param {string[]} dataRange - []
       * @api
       * @example
       * chart.on('zoom', (dataRange) => {
       *    console.log(dataRange);
       * });
       */

      /**
       * Register Events that occur when zoom is reset
       * @event ChartBase#resetZoom
       * @api
       * @example
       * chart.on('resetZoom', () => {});
       */
      _this.eventBus.on(eventName, handler);
    });

    chart_defineProperty(this, "destroy", function () {
      _this.componentManager.clear();

      _this.clearResizeEvent();

      _this.containerEl.innerHTML = '';
    });

    chart_defineProperty(this, "selectSeries", function (seriesInfo) {
      if (!_this.isSelectableSeries()) {
        throw new Error(message.SELECT_SERIES_API_SELECTABLE_ERROR);
      }

      _this.eventBus.emit('selectSeries', chart_objectSpread(chart_objectSpread({}, seriesInfo), {}, {
        state: _this.store.state
      }));
    });

    chart_defineProperty(this, "unselectSeries", function () {
      if (!_this.isSelectableSeries()) {
        throw new Error(message.SELECT_SERIES_API_SELECTABLE_ERROR);
      }

      _this.store.dispatch('setAllLegendActiveState', true);

      _this.eventBus.emit('resetSelectedSeries');
    });

    chart_defineProperty(this, "resize", function (size) {
      _this.resetSeries();

      _this.dispatchOptionsEvent('updateOptions', {
        chart: chart_objectSpread({}, size)
      });
    });

    chart_defineProperty(this, "resetSeries", function () {
      _this.eventBus.emit('resetHoveredSeries');

      _this.eventBus.emit('resetSelectedSeries');
    });

    chart_defineProperty(this, "setResizeEventListeners", function (eventName, options) {
      var _options$chart, _options$chart2;

      var usingContainerSize = _this.store.state.usingContainerSize;
      var usingContainerWidth = usingContainerSize.width,
          usingContainerHeight = usingContainerSize.height;
      var width = options === null || options === void 0 ? void 0 : (_options$chart = options.chart) === null || _options$chart === void 0 ? void 0 : _options$chart.width;
      var height = options === null || options === void 0 ? void 0 : (_options$chart2 = options.chart) === null || _options$chart2 === void 0 ? void 0 : _options$chart2.height;
      var isAutoWidth = isAutoValue(width);
      var isAutoHeight = isAutoValue(height);

      _this.store.dispatch('setUsingContainerSize', getUsingContainerSize(eventName, usingContainerSize, width, height));

      if ((usingContainerWidth || usingContainerHeight) && isNumber(width) && isNumber(height)) {
        _this.clearResizeEvent();
      } else if (!(usingContainerWidth || usingContainerHeight) && (isAutoWidth || isAutoHeight)) {
        _this.setResizeEvent();
      }
    });

    var el = props.el,
        _options = props.options,
        series = props.series,
        categories = props.categories,
        modules = props.modules;
    this.modules = modules !== null && modules !== void 0 ? modules : [];

    if (isUndefined(_options.usageStatistics) || _options.usageStatistics) {
      sendHostname();
    }

    this.containerEl = el;
    this.el = this.createChartWrapper();
    this.containerEl.appendChild(this.el);
    this.animator = new Animator();
    this.store = new Store({
      series: series,
      categories: categories,
      options: _options
    });
    this.componentManager = new ComponentManager({
      store: this.store,
      eventBus: this.eventBus
    });
    this.eventBus.on('needLoop', debounce(function () {
      var _options$chart3;

      var duration = _this.getAnimationDuration((_options$chart3 = _options.chart) === null || _options$chart3 === void 0 ? void 0 : _options$chart3.animation);

      if (_this.animationControlFlag.resizing) {
        var _options$responsive;

        duration = isUndefined(_options.responsive) ? _this.getAnimationDuration() : _this.getAnimationDuration((_options$responsive = _options.responsive) === null || _options$responsive === void 0 ? void 0 : _options$responsive.animation);
        _this.animationControlFlag.resizing = false;
      }

      _this.eventBus.emit('loopStart');

      _this.animator.add({
        onCompleted: function onCompleted() {
          _this.eventBus.emit('loopComplete');
        },
        chart: _this,
        duration: duration,
        requester: _this
      });
    }, 10));
    this.eventBus.on('needSubLoop', function (opts) {
      _this.animator.add(chart_objectSpread(chart_objectSpread({}, opts), {}, {
        chart: _this
      }));
    });
    this.eventBus.on('needDraw', debounce(function () {
      _this.draw();
    }, 10));
    this.initialize();
    this.store.observe(function () {
      _this.painter.setup();
    });

    if (isAutoValue(_options === null || _options === void 0 ? void 0 : (_options$chart4 = _options.chart) === null || _options$chart4 === void 0 ? void 0 : _options$chart4.width) || isAutoValue(_options === null || _options === void 0 ? void 0 : (_options$chart5 = _options.chart) === null || _options$chart5 === void 0 ? void 0 : _options$chart5.height)) {
      this.setResizeEvent();
    }
  }

  chart_createClass(Chart, [{
    key: "getAnimationDuration",
    value: function getAnimationDuration(animationOption) {
      var firstRendering = this.animator.firstRendering;
      var _this$animationContro = this.animationControlFlag,
          resizing = _this$animationContro.resizing,
          updating = _this$animationContro.updating;
      var duration;

      if (!firstRendering && !resizing || isUndefined(animationOption)) {
        duration = DEFAULT_ANIM_DURATION;
      } else if (isBoolean(animationOption)) {
        duration = animationOption ? DEFAULT_ANIM_DURATION : 0;
      } else if (isNumber(animationOption.duration)) {
        duration = animationOption.duration;
      }

      if (updating) {
        duration = 0;
      }

      this.animationControlFlag.updating = false;
      return duration;
    }
  }, {
    key: "createChartWrapper",
    value: function createChartWrapper() {
      var el = document.createElement('div');
      el.classList.add('toastui-chart-wrapper');
      return el;
    }
  }, {
    key: "resizeChartSize",
    value: function resizeChartSize(containerWidth, containerHeight) {
      this.animationControlFlag.resizing = true;
      var _this$store$state = this.store.state,
          _this$store$state$usi = _this$store$state.usingContainerSize,
          usingContainerWidth = _this$store$state$usi.width,
          usingContainerHeight = _this$store$state$usi.height,
          _this$store$state$cha = _this$store$state.chart,
          width = _this$store$state$cha.width,
          height = _this$store$state$cha.height;

      if (!(usingContainerWidth || usingContainerHeight) || !(containerWidth || containerHeight) || containerWidth === width && containerHeight === height) {
        this.animationControlFlag.resizing = false;
        return;
      } // @TODO: For updates where the data doesn't change, it looks good to recalculate the selected series position.


      this.resetSeries();
      this.store.dispatch('setChartSize', {
        width: usingContainerWidth ? containerWidth : width,
        height: usingContainerHeight ? containerHeight : height
      });
      this.draw();
    }
  }, {
    key: "setResizeEvent",
    value: function setResizeEvent() {
      var _this2 = this;

      var usingContainerSize = this.store.state.usingContainerSize;

      if (usingContainerSize.height && !this.containerEl.style.height.length || usingContainerSize.width && !this.containerEl.style.width.length) {
        throw new Error(message.AUTO_LAYOUT_CONTAINER_SIZE_ERROR);
      }

      var isResizeObserverAPIExist = typeof ResizeObserver === 'undefined';

      if (isResizeObserverAPIExist) {
        window.addEventListener('resize', this.debounceResizeEvent);
      } else {
        this.resizeObserver = new ResizeObserver(function (entries) {
          entries.forEach(function () {
            _this2.debounceResizeEvent();
          });
        });
        this.resizeObserver.observe(this.containerEl);
      }
    }
  }, {
    key: "clearResizeEvent",
    value: function clearResizeEvent() {
      if (this.resizeObserver) {
        this.resizeObserver.unobserve(this.containerEl);
        this.resizeObserver.disconnect();
        this.resizeObserver = null;
      } else {
        window.removeEventListener('resize', this.debounceResizeEvent);
      }
    }
  }, {
    key: "handleCanvasMouseEvent",
    value: function handleCanvasMouseEvent(eventType, mousePosition) {
      var _this3 = this;

      var newEnteredComponents = [];
      this.componentManager.forEach(function (component) {
        if (eventType === 'mousemove') {
          var exist = _this3.enteredComponents.some(function (enteredComponent) {
            return enteredComponent === component;
          });

          if (isMouseInRect(component.rect, mousePosition)) {
            newEnteredComponents.push(component);

            if (!exist && component.onMouseenterComponent) {
              component.onMouseenterComponent();
            }
          } else if (exist && component.onMouseoutComponent) {
            component.onMouseoutComponent();
          }
        } else if (eventType === 'mouseout' && component.onMouseoutComponent) {
          component.onMouseoutComponent();
        }
      });
      this.enteredComponents = newEnteredComponents;
    }
  }, {
    key: "handleResponderEvent",
    value: function handleResponderEvent(event, mousePosition) {
      var eventType = event.type;
      var delegationMethod = "on".concat(eventType[0].toUpperCase() + eventType.substring(1));
      var allResponders = [];
      this.componentManager.forEach(function (component) {
        if (!component[delegationMethod]) {
          return;
        }

        if (!responderDetectors.rect(mousePosition, component.rect)) {
          return;
        }

        var detected = (component.responders || []).filter(function (m) {
          return responderDetectors[m.type](mousePosition, m, component.rect);
        });

        if (detected.length) {
          allResponders.push({
            component: component,
            detected: detected
          });
        }

        component[delegationMethod]({
          mousePosition: mousePosition,
          responders: detected
        }, event);
      });

      if (this.handleEventForAllResponders) {
        this.handleEventForAllResponders(event, allResponders, delegationMethod, mousePosition);
      }
    }
  }, {
    key: "handleEvent",
    value: function handleEvent(event) {
      var clientX = event.clientX,
          clientY = event.clientY,
          eventType = event.type;
      var canvas = this.painter.ctx.canvas;

      var _canvas$getBoundingCl = canvas.getBoundingClientRect(),
          width = _canvas$getBoundingCl.width,
          height = _canvas$getBoundingCl.height,
          left = _canvas$getBoundingCl.left,
          top = _canvas$getBoundingCl.top; // Calculate scale for chart affected by a CSS transform.


      var scaleX = width / canvas.offsetWidth;
      var scaleY = height / canvas.offsetHeight;
      var mousePosition = {
        x: (clientX - left) / scaleX,
        y: (clientY - top) / scaleY
      };

      if (eventType === 'mousemove' || eventType === 'mouseout') {
        this.handleCanvasMouseEvent(eventType, mousePosition);
      }

      this.handleResponderEvent(event, mousePosition);
    }
  }, {
    key: "initStore",
    value: function initStore() {
      var _this4 = this;

      [store_root, options, store_theme, store_seriesData, store_legend, store_layout, store_category].concat(chart_toConsumableArray(this.modules)).forEach(function (module) {
        return _this4.store.setModule(module);
      });
    }
  }, {
    key: "initialize",
    value: function initialize() {
      this.initStore();
      this.store.dispatch('initChartSize', this.containerEl);
    }
  }, {
    key: "draw",
    value: function draw() {
      var _this5 = this;

      this.painter.beforeFrame();
      this.componentManager.forEach(function (component) {
        if (!component.isShow) {
          return;
        }

        _this5.painter.beforeDraw(component.rect.x, component.rect.y);

        if (component.beforeDraw) {
          component.beforeDraw(_this5.painter);
        }

        component.draw(_this5.painter);

        _this5.painter.afterDraw();
      });
    }
  }, {
    key: "update",
    value: function update(delta) {
      this.componentManager.invoke('update', delta);
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      this.componentManager.invoke('initUpdate', delta);
    }
  }, {
    key: "isSelectableSeries",
    value: function isSelectableSeries() {
      var _this$store$initStore;

      return (_this$store$initStore = this.store.initStoreState.options.series) === null || _this$store$initStore === void 0 ? void 0 : _this$store$initStore.selectable;
    }
    /**
     * Select series. It works only when the selectable option is true.
     * @param {Object} seriesInfo - Information of the series to be selected
     *      @param {number} [seriesInfo.seriesIndex] - Index of series
     *      @param {number} [seriesInfo.index] - Index of data within series
     *      @param {string} [seriesInfo.name] - Specify name for NestedPie Chart
     *      @param {string} [seriesInfo.chartType] - Specify which chart to select when using LineArea, LineScatter, and ColumnLine charts.specifies which chart to select when using LineArea, LineScatter, and ColumnLine charts.
     * @api
     * @example
     * chart.selectSeries({index: 1, seriesIndex: 2});
     */

  }, {
    key: "setTooltipOffset",
    value:
    /**
     * Set tooltip offset.
     * @param {Object} offset - Offset size
     *   @param {number} [offset.x] Offset value to move title horizontally
     *   @param {number} [offset.y] Offset value to move title vertically
     * @api
     * @example
     * chart.setTooltipOffset({x: 10, y: -20});
     */
    function setTooltipOffset(offset) {
      var offsetX = offset.x,
          offsetY = offset.y;
      this.store.dispatch('updateOptions', {
        options: {
          tooltip: {
            offsetX: offsetX,
            offsetY: offsetY
          }
        }
      });
    }
  }, {
    key: "dispatchOptionsEvent",
    value: function dispatchOptionsEvent(eventName, options) {
      this.setResizeEventListeners(eventName, options);
      var _this$containerEl2 = this.containerEl,
          offsetWidth = _this$containerEl2.offsetWidth,
          offsetHeight = _this$containerEl2.offsetHeight;
      this.store.dispatch(eventName, {
        options: options,
        containerSize: {
          width: offsetWidth,
          height: offsetHeight
        }
      });
    }
  }]);

  return Chart;
}();


// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.number.max-safe-integer.js
var es_number_max_safe_integer = __nested_webpack_require_221589__(8143);
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.number.min-safe-integer.js
var es_number_min_safe_integer = __nested_webpack_require_221589__(2023);
;// CONCATENATED MODULE: ./src/store/dataRange.ts

























function dataRange_slicedToArray(arr, i) { return dataRange_arrayWithHoles(arr) || dataRange_iterableToArrayLimit(arr, i) || dataRange_unsupportedIterableToArray(arr, i) || dataRange_nonIterableRest(); }

function dataRange_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function dataRange_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function dataRange_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function dataRange_toConsumableArray(arr) { return dataRange_arrayWithoutHoles(arr) || dataRange_iterableToArray(arr) || dataRange_unsupportedIterableToArray(arr) || dataRange_nonIterableSpread(); }

function dataRange_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function dataRange_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return dataRange_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dataRange_arrayLikeToArray(o, minLen); }

function dataRange_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function dataRange_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return dataRange_arrayLikeToArray(arr); }

function dataRange_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }







function getLimitSafely(baseValues) {
  var isXAxis = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var limit = {
    min: Math.min.apply(Math, dataRange_toConsumableArray(baseValues)),
    max: Math.max.apply(Math, dataRange_toConsumableArray(baseValues))
  };

  if (baseValues.length === 1) {
    var _baseValues = dataRange_slicedToArray(baseValues, 1),
        firstValue = _baseValues[0];

    if (isXAxis) {
      limit.min = firstValue;
      limit.max = firstValue;
    } else if (firstValue > 0) {
      limit.min = 0;
    } else if (firstValue === 0) {
      limit.max = 10;
    } else {
      limit.max = 0;
    }
  } else if (limit.min === 0 && limit.max === 0) {
    limit.max = 10;
  } else if (limit.min === limit.max) {
    limit.min -= limit.min / 10;
    limit.max += limit.max / 10;
  }

  return limit;
}

function initDataRange(accDataRangeValue, curDataRangeValue, axisName) {
  var _accDataRangeValue$ax, _accDataRangeValue$ax2, _accDataRangeValue$ax3, _accDataRangeValue$ax4;

  var defaultDataRange = {
    min: Number.MAX_SAFE_INTEGER,
    max: Number.MIN_SAFE_INTEGER
  };
  return {
    min: Math.min(curDataRangeValue[axisName].min, (_accDataRangeValue$ax = (_accDataRangeValue$ax2 = accDataRangeValue[axisName]) === null || _accDataRangeValue$ax2 === void 0 ? void 0 : _accDataRangeValue$ax2.min) !== null && _accDataRangeValue$ax !== void 0 ? _accDataRangeValue$ax : defaultDataRange.min),
    max: Math.max(curDataRangeValue[axisName].max, (_accDataRangeValue$ax3 = (_accDataRangeValue$ax4 = accDataRangeValue[axisName]) === null || _accDataRangeValue$ax4 === void 0 ? void 0 : _accDataRangeValue$ax4.max) !== null && _accDataRangeValue$ax3 !== void 0 ? _accDataRangeValue$ax3 : defaultDataRange.max)
  };
}

function getTotalDataRange(seriesDataRange) {
  return Object.values(seriesDataRange).reduce(function (acc, cur) {
    if (cur.xAxis) {
      acc.xAxis = initDataRange(acc, cur, 'xAxis');
    }

    if (cur.yAxis) {
      acc.yAxis = initDataRange(acc, cur, 'yAxis');
    }

    if (cur.secondaryYAxis) {
      acc.secondaryYAxis = initDataRange(acc, cur, 'secondaryYAxis');
    }

    if (cur.circularAxis) {
      acc.circularAxis = initDataRange(acc, cur, 'circularAxis');
    }

    if (cur.verticalAxis) {
      acc.verticalAxis = initDataRange(acc, cur, 'verticalAxis');
    }

    return acc;
  }, {});
}

function setSeriesDataRange(_ref) {
  var options = _ref.options,
      seriesName = _ref.seriesName,
      values = _ref.values,
      valueAxisName = _ref.valueAxisName,
      seriesDataRange = _ref.seriesDataRange;
  var axisNames;

  if (includes([AxisType.X, AxisType.CIRCULAR, AxisType.VERTICAL], valueAxisName)) {
    axisNames = [valueAxisName];
  } else {
    var optionsUsingYAxis = options;

    var _getYAxisOption = getYAxisOption(optionsUsingYAxis),
        secondaryYAxis = _getYAxisOption.secondaryYAxis;

    axisNames = hasSecondaryYAxis(optionsUsingYAxis) && secondaryYAxis !== null && secondaryYAxis !== void 0 && secondaryYAxis.chartType ? [secondaryYAxis.chartType === seriesName ? 'secondaryYAxis' : 'yAxis'] : getValueAxisNames(optionsUsingYAxis, valueAxisName);
  }

  axisNames.forEach(function (axisName) {
    seriesDataRange[seriesName][axisName] = getLimitSafely(dataRange_toConsumableArray(new Set(values)));
  });
  return seriesDataRange;
}

function getBoxPlotValues(series, seriesName) {
  return series[seriesName].data.flatMap(function (_ref2) {
    var data = _ref2.data,
        _ref2$outliers = _ref2.outliers,
        outliers = _ref2$outliers === void 0 ? [] : _ref2$outliers;
    return [].concat(dataRange_toConsumableArray((data !== null && data !== void 0 ? data : []).flatMap(function (datum) {
      return datum;
    })), dataRange_toConsumableArray((outliers !== null && outliers !== void 0 ? outliers : []).flatMap(function (datum) {
      return datum;
    })));
  });
}

function getBulletValues(series, seriesName) {
  return series[seriesName].data.flatMap(function (_ref3) {
    var data = _ref3.data,
        markers = _ref3.markers,
        ranges = _ref3.ranges;
    return [data].concat(dataRange_toConsumableArray((markers !== null && markers !== void 0 ? markers : []).flatMap(function (datum) {
      return datum;
    })), dataRange_toConsumableArray((ranges !== null && ranges !== void 0 ? ranges : []).flatMap(function (range) {
      return range;
    })));
  });
}

function getCoordinateDataValues(values, categories, hasDateValue) {
  var yAxisValues = values.filter(function (value) {
    return !isNull(value);
  }).map(function (value) {
    return getCoordinateYValue(value);
  });
  var xAxisValues = categories.map(function (value) {
    return hasDateValue ? Number(new Date(value)) : Number(value);
  });
  return {
    xAxisValues: xAxisValues,
    yAxisValues: yAxisValues
  };
}

var dataRange = {
  name: 'dataRange',
  state: function state() {
    return {
      dataRange: {}
    };
  },
  action: {
    setDataRange: function setDataRange(_ref4) {
      var state = _ref4.state,
          initStoreState = _ref4.initStoreState;
      var series = state.series,
          disabledSeries = state.disabledSeries,
          stackSeries = state.stackSeries,
          categories = state.categories,
          options = state.options;
      var seriesDataRange = {};
      var labelAxisOnYAxis = isLabelAxisOnYAxis({
        series: series,
        options: options,
        categories: categories
      });

      var _getAxisName = getAxisName(labelAxisOnYAxis, series),
          labelAxisName = _getAxisName.labelAxisName,
          valueAxisName = _getAxisName.valueAxisName;

      Object.keys(series).forEach(function (seriesName) {
        var _stackSeries$seriesNa;

        seriesDataRange[seriesName] = {};
        var values = series[seriesName].data.flatMap(function (_ref5) {
          var data = _ref5.data,
              name = _ref5.name;
          return disabledSeries.includes(name) ? [] : data;
        });
        var firstExistValue = getFirstValidValue(values);

        if (isCoordinateSeries(initStoreState.series)) {
          var _options$xAxis;

          var hasDateValue = !!((_options$xAxis = options.xAxis) !== null && _options$xAxis !== void 0 && _options$xAxis.date);

          var _getCoordinateDataVal = getCoordinateDataValues(values, categories, hasDateValue),
              yAxisValues = _getCoordinateDataVal.yAxisValues,
              xAxisValues = _getCoordinateDataVal.xAxisValues;

          values = yAxisValues;
          seriesDataRange[seriesName][labelAxisName] = getLimitSafely(dataRange_toConsumableArray(xAxisValues), true);
        } else if (!series[seriesName].data.length) {
          values = [];
        } else if (isRangeValue(firstExistValue)) {
          values = values.reduce(function (arr, value) {
            if (isNull(value)) {
              return arr;
            }

            return Array.isArray(value) ? [].concat(dataRange_toConsumableArray(arr), dataRange_toConsumableArray(value)) : dataRange_toConsumableArray(value);
          }, []);
        } else if (stackSeries && (_stackSeries$seriesNa = stackSeries[seriesName]) !== null && _stackSeries$seriesNa !== void 0 && _stackSeries$seriesNa.stack) {
          values = stackSeries[seriesName].dataRangeValues;
        } else if (seriesName === 'boxPlot') {
          values = getBoxPlotValues(series, seriesName);
        } else if (seriesName === 'bullet') {
          values = getBulletValues(series, seriesName);
        }

        if (includes(['bar', 'column', 'radar', 'bullet'], seriesName)) {
          values.push(0);
        }

        setSeriesDataRange({
          options: options,
          seriesName: seriesName,
          values: values,
          valueAxisName: valueAxisName,
          seriesDataRange: seriesDataRange
        });
      });
      var newDataRange = getTotalDataRange(seriesDataRange);
      store_extend(state.dataRange, newDataRange);
    }
  },
  observe: {
    updateDataRange: function updateDataRange() {
      this.dispatch('setDataRange');
    }
  }
};
/* harmony default export */ var store_dataRange = (dataRange);
;// CONCATENATED MODULE: ./src/scale/coordinateScaleCalculator.ts
function coordinateScaleCalculator_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function coordinateScaleCalculator_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { coordinateScaleCalculator_ownKeys(Object(source), true).forEach(function (key) { coordinateScaleCalculator_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { coordinateScaleCalculator_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function coordinateScaleCalculator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function coordinateScaleCalculator_toConsumableArray(arr) { return coordinateScaleCalculator_arrayWithoutHoles(arr) || coordinateScaleCalculator_iterableToArray(arr) || coordinateScaleCalculator_unsupportedIterableToArray(arr) || coordinateScaleCalculator_nonIterableSpread(); }

function coordinateScaleCalculator_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function coordinateScaleCalculator_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return coordinateScaleCalculator_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return coordinateScaleCalculator_arrayLikeToArray(o, minLen); }

function coordinateScaleCalculator_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function coordinateScaleCalculator_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return coordinateScaleCalculator_arrayLikeToArray(arr); }

function coordinateScaleCalculator_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }





















var SNAP_VALUES = [1, 2, 5, 10];
var DEFAULT_PIXELS_PER_STEP = 88;

function adjustLimitForOverflow(_ref, stepSize, overflowed) {
  var min = _ref.min,
      max = _ref.max;
  return {
    min: overflowed.min ? min - stepSize : min,
    max: overflowed.max ? max + stepSize : max
  };
}

function isSeriesOverflowed(scaleData, _ref2, scaleOption) {
  var min = _ref2.min,
      max = _ref2.max;
  var scaleDataLimit = scaleData.limit;
  var hasMinOption = isNumber(scaleOption === null || scaleOption === void 0 ? void 0 : scaleOption.min);
  var hasMaxOption = isNumber(scaleOption === null || scaleOption === void 0 ? void 0 : scaleOption.max);
  var isOverflowedMin = !hasMinOption && scaleDataLimit.min === min && scaleDataLimit.min !== 0;
  var isOverflowedMax = !hasMaxOption && scaleDataLimit.max === max && scaleDataLimit.max !== 0;

  if (!isOverflowedMin && !isOverflowedMax) {
    return null;
  }

  return {
    min: isOverflowedMin,
    max: isOverflowedMax
  };
}

function getDigits(num) {
  var logNumberDividedLN10 = num === 0 ? 1 : Math.log(Math.abs(num)) / Math.LN10;
  return Math.pow(10, Math.floor(logNumberDividedLN10));
}

function getSnappedNumber(num) {
  var snapNumber = 0;

  for (var i = 0, t = SNAP_VALUES.length; i < t; i += 1) {
    snapNumber = SNAP_VALUES[i];
    var guideValue = (snapNumber + (SNAP_VALUES[i + 1] || snapNumber)) / 2;

    if (num <= guideValue) {
      break;
    }
  }

  return snapNumber;
}

function getNormalizedStep(stepSize) {
  var placeNumber = getDigits(stepSize);
  var simplifiedStepValue = stepSize / placeNumber;
  return getSnappedNumber(simplifiedStepValue) * placeNumber;
}
/**
 * Get normalized limit values
 * max = 155 and step = 10 ---> max = 160
 */


function getNormalizedLimit(limit, stepSize) {
  var min = limit.min,
      max = limit.max;
  var minNumber = Math.min(getDigits(max), getDigits(stepSize));
  var placeNumber = minNumber > 1 ? 1 : 1 / minNumber;
  var fixedStep = stepSize * placeNumber; // ceil max value step digits

  max = Math.ceil(max * placeNumber / fixedStep) * fixedStep / placeNumber;

  if (min > stepSize) {
    // floor min value to multiples of step
    min = Math.floor(min * placeNumber / fixedStep) * fixedStep / placeNumber;
  } else if (min < 0) {
    min = -(Math.ceil(Math.abs(min) * placeNumber / fixedStep) * fixedStep) / placeNumber;
  } else {
    min = 0;
  }

  return {
    min: min,
    max: max
  };
}

function getNormalizedStepCount(limitSize, stepSize) {
  var multiplier = 1 / Math.min(getDigits(limitSize), getDigits(stepSize));
  return Math.ceil(limitSize * multiplier / (stepSize * multiplier));
}

function hasStepSize(stepSize) {
  return isNumber(stepSize);
}

function getNormalizedScale(scaleData, scale) {
  var stepSize = hasStepSize(scale.stepSize) ? scaleData.stepSize : getNormalizedStep(scaleData.stepSize);
  var edge = getNormalizedLimit(scaleData.limit, stepSize);
  var limitSize = Math.abs(edge.max - edge.min);
  var stepCount = getNormalizedStepCount(limitSize, stepSize);
  return {
    limit: {
      min: edge.min,
      max: edge.max
    },
    stepSize: stepSize,
    stepCount: stepCount
  };
}

function getRoughScale(scale, offsetSize) {
  var minStepSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var min = scale.min,
      max = scale.max;
  var limitSize = Math.abs(max - min);
  var valuePerPixel = limitSize / offsetSize;
  var stepCount = Math.ceil(offsetSize / DEFAULT_PIXELS_PER_STEP);
  var pixelsPerStep = offsetSize / stepCount;
  var stepSize = valuePerPixel * pixelsPerStep;

  if (hasStepSize(scale.stepSize)) {
    stepSize = scale.stepSize;
    stepCount = limitSize / stepSize;
  } else if (isNumber(minStepSize) && stepSize < minStepSize) {
    stepSize = minStepSize;
    stepCount = limitSize / stepSize;
  }

  return {
    limit: {
      min: min,
      max: max
    },
    stepSize: stepSize,
    stepCount: stepCount
  };
}

function makeScaleOption(dataRange, scaleOptions) {
  var _scaleOptions$max, _scaleOptions$min, _scaleOptions$stepSiz;

  return {
    max: (_scaleOptions$max = scaleOptions === null || scaleOptions === void 0 ? void 0 : scaleOptions.max) !== null && _scaleOptions$max !== void 0 ? _scaleOptions$max : dataRange.max,
    min: (_scaleOptions$min = scaleOptions === null || scaleOptions === void 0 ? void 0 : scaleOptions.min) !== null && _scaleOptions$min !== void 0 ? _scaleOptions$min : dataRange.min,
    stepSize: (_scaleOptions$stepSiz = scaleOptions === null || scaleOptions === void 0 ? void 0 : scaleOptions.stepSize) !== null && _scaleOptions$stepSiz !== void 0 ? _scaleOptions$stepSiz : 'auto'
  };
}
function calculateCoordinateScale(options) {
  var dataRange = options.dataRange,
      scaleOption = options.scaleOption,
      offsetSize = options.offsetSize,
      minStepSize = options.minStepSize,
      useSpectrumLegend = options.useSpectrumLegend;
  var scale = makeScaleOption(dataRange, scaleOption);
  var roughScale = getRoughScale(scale, offsetSize, minStepSize);
  var normalizedScale = getNormalizedScale(roughScale, scale);
  var overflowed = useSpectrumLegend ? null : isSeriesOverflowed(normalizedScale, scale, scaleOption);

  if (overflowed) {
    var stepSize = normalizedScale.stepSize,
        limit = normalizedScale.limit;
    normalizedScale.limit = adjustLimitForOverflow(limit, stepSize, overflowed);
  }

  return normalizedScale;
}
function getStackScaleData(type) {
  if (type === 'minusPercentStack') {
    return {
      limit: {
        min: -100,
        max: 0
      },
      stepSize: 25,
      stepCount: 5
    };
  }

  if (type === 'dualPercentStack') {
    return {
      limit: {
        min: -100,
        max: 100
      },
      stepSize: 25,
      stepCount: 9
    };
  }

  if (type === 'divergingPercentStack') {
    return {
      limit: {
        min: -100,
        max: 100
      },
      stepSize: 25,
      stepCount: 9
    };
  }

  return {
    limit: {
      min: 0,
      max: 100
    },
    stepSize: 25,
    stepCount: 5
  };
}
function calculateXAxisScaleForCoordinateLineType(scale, options, categories) {
  var dateType = isDateType(options, AxisType.X);
  var values = categories.map(function (value) {
    return dateType ? Number(new Date(value)) : Number(value);
  });
  var limit = scale.limit,
      stepSize = scale.stepSize;
  var min = Math.min.apply(Math, coordinateScaleCalculator_toConsumableArray(values));
  var max = Math.max.apply(Math, coordinateScaleCalculator_toConsumableArray(values));

  var newLimit = coordinateScaleCalculator_objectSpread({}, limit);

  var distance = max - min;
  var positionRatio = 0;
  var sizeRatio = 1;

  if (distance) {
    if (limit.min < min) {
      newLimit.min += stepSize;
      positionRatio = (newLimit.min - min) / distance;
      sizeRatio -= positionRatio;
    }

    if (limit.max > max) {
      newLimit.max -= stepSize;
      sizeRatio -= (max - newLimit.max) / distance;
    }
  }

  var limitSize = Math.abs(newLimit.max - newLimit.min);
  var newStepCount = getNormalizedStepCount(limitSize, stepSize);
  return {
    limit: newLimit,
    stepCount: newStepCount,
    stepSize: stepSize,
    positionRatio: positionRatio,
    sizeRatio: sizeRatio
  };
}
;// CONCATENATED MODULE: ./src/scale/datetimeScaleCalculator.ts








function datetimeScaleCalculator_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function datetimeScaleCalculator_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { datetimeScaleCalculator_ownKeys(Object(source), true).forEach(function (key) { datetimeScaleCalculator_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { datetimeScaleCalculator_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function datetimeScaleCalculator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




var msMap = {
  year: 31536000000,
  month: 2678400000,
  week: 604800000,
  date: 86400000,
  hour: 3600000,
  minute: 60000,
  second: 1000
};
function calculateDatetimeScale(options) {
  var dataRange = options.dataRange,
      rawCategoriesSize = options.rawCategoriesSize,
      scaleOption = options.scaleOption;
  var datetimeInfo = makeDatetimeInfo(dataRange, rawCategoriesSize, scaleOption);
  var minDate = datetimeInfo.minDate,
      divisionNumber = datetimeInfo.divisionNumber,
      limit = datetimeInfo.limit;
  var scale = calculateCoordinateScale(datetimeScaleCalculator_objectSpread(datetimeScaleCalculator_objectSpread({}, omit(options, 'scaleOption')), {}, {
    dataRange: limit,
    minStepSize: 1
  }));
  return restoreScaleToDatetimeType(scale, minDate, divisionNumber);
}
var msTypes = ['year', 'month', 'week', 'date', 'hour', 'minute', 'second'];

function restoreScaleToDatetimeType(scale, minDate, divisionNumber) {
  var limit = scale.limit,
      stepSize = scale.stepSize;
  var min = limit.min,
      max = limit.max;
  return datetimeScaleCalculator_objectSpread(datetimeScaleCalculator_objectSpread({}, scale), {}, {
    stepSize: multiply(stepSize, divisionNumber),
    limit: {
      min: multiply(add(min, minDate), divisionNumber),
      max: multiply(add(max, minDate), divisionNumber)
    }
  });
}

function makeDatetimeInfo(limit, count, scaleOption) {
  var _scaleOption$stepSize;

  var dateType = findDateType(limit, count);
  var divisionNumber = (_scaleOption$stepSize = scaleOption === null || scaleOption === void 0 ? void 0 : scaleOption.stepSize) !== null && _scaleOption$stepSize !== void 0 ? _scaleOption$stepSize : msMap[dateType];
  var scale = makeScaleOption(limit, scaleOption);
  var minDate = divide(Number(new Date(scale.min)), divisionNumber);
  var maxDate = divide(Number(new Date(scale.max)), divisionNumber);
  return {
    divisionNumber: divisionNumber,
    minDate: minDate,
    limit: {
      min: 0,
      max: maxDate - minDate
    }
  };
}

function findDateType(_ref, count) {
  var max = _ref.max,
      min = _ref.min;
  var diff = max - min;
  var lastTypeIndex = msTypes.length - 1;
  var foundType;

  if (diff) {
    msTypes.every(function (type, index) {
      var millisecond = msMap[type];
      var dividedCount = Math.floor(diff / millisecond);
      var foundIndex;

      if (dividedCount) {
        foundIndex = index < lastTypeIndex && dividedCount < 2 && dividedCount < count ? index + 1 : index;
        foundType = msTypes[foundIndex];
      }

      return !isExist(foundIndex);
    });
  } else {
    foundType = 'second';
  }

  return foundType;
}
;// CONCATENATED MODULE: ./src/store/stackSeriesData.ts
function stackSeriesData_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function stackSeriesData_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { stackSeriesData_ownKeys(Object(source), true).forEach(function (key) { stackSeriesData_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { stackSeriesData_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function stackSeriesData_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function stackSeriesData_toConsumableArray(arr) { return stackSeriesData_arrayWithoutHoles(arr) || stackSeriesData_iterableToArray(arr) || stackSeriesData_unsupportedIterableToArray(arr) || stackSeriesData_nonIterableSpread(); }

function stackSeriesData_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function stackSeriesData_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return stackSeriesData_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return stackSeriesData_arrayLikeToArray(o, minLen); }

function stackSeriesData_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function stackSeriesData_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return stackSeriesData_arrayLikeToArray(arr); }

function stackSeriesData_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }





















function isPercentStack(stack) {
  return !!((stack === null || stack === void 0 ? void 0 : stack.type) === 'percent');
}
function isGroupStack(rawData) {
  return !Array.isArray(rawData);
}
function hasPercentStackSeries(stackSeries) {
  if (!stackSeries) {
    return false;
  }

  return Object.keys(stackSeries).some(function (seriesName) {
    return isPercentStack(stackSeries[seriesName].stack);
  });
}
function pickStackOption(options) {
  return pickProperty(options, ['series', 'stack']) || pickProperty(options, ['series', 'column', 'stack']) || pickProperty(options, ['series', 'area', 'stack']);
}

function makeStackData(seriesData) {
  var seriesCount = seriesData.length;
  var groupCountLengths = seriesData.map(function (_ref) {
    var rawData = _ref.rawData;
    return rawData.length;
  });
  var seriesGroupCount = Math.max.apply(Math, stackSeriesData_toConsumableArray(groupCountLengths));
  var stackData = [];

  for (var i = 0; i < seriesGroupCount; i += 1) {
    var stackValues = [];

    for (var j = 0; j < seriesCount; j += 1) {
      stackValues.push(seriesData[j].rawData[i]);
    }

    stackData[i] = {
      values: stackValues,
      sum: sum(stackValues),
      total: {
        positive: sum(stackValues.filter(function (value) {
          return value >= 0;
        })),
        negative: sum(stackValues.filter(function (value) {
          return value < 0;
        }))
      }
    };
  }

  return stackData;
}

function makeStackGroupData(seriesData) {
  var stackData = {};

  var stackGroupIds = stackSeriesData_toConsumableArray(new Set(seriesData.map(function (_ref2) {
    var stackGroup = _ref2.stackGroup;
    return stackGroup;
  })));

  stackGroupIds.forEach(function (groupId) {
    var filtered = seriesData.filter(function (_ref3) {
      var stackGroup = _ref3.stackGroup;
      return groupId === stackGroup;
    });
    stackData[groupId] = makeStackData(filtered);
  });
  return stackData;
}

function initializeStack(stackOption) {
  if (!stackOption) {
    return;
  }

  var defaultStackOption = {
    type: 'normal',
    connector: false
  };

  if (isStackObject(stackOption)) {
    return stackSeriesData_objectSpread(stackSeriesData_objectSpread({}, defaultStackOption), stackOption);
  }

  return defaultStackOption;
}

function isStackObject(stackOption) {
  return isObject(stackOption);
}

function hasStackGrouped(seriesRawData) {
  return seriesRawData.some(function (rawData) {
    return rawData.hasOwnProperty('stackGroup');
  });
}

function getStackDataRangeValues(stackData) {
  var values = [];

  if (Array.isArray(stackData)) {
    values = [0].concat(stackSeriesData_toConsumableArray(getSumValues(stackData)));
  } else {
    for (var groupId in stackData) {
      if (Object.prototype.hasOwnProperty.call(stackData, groupId)) {
        values = [0].concat(stackSeriesData_toConsumableArray(values), stackSeriesData_toConsumableArray(getSumValues(stackData[groupId])));
      }
    }
  }

  return values;
}

function getSumValues(stackData) {
  var positiveSum = stackData.map(function (_ref4) {
    var total = _ref4.total;
    return total.positive;
  });
  var negativeSum = stackData.map(function (_ref5) {
    var total = _ref5.total;
    return total.negative;
  });
  return [].concat(stackSeriesData_toConsumableArray(negativeSum), stackSeriesData_toConsumableArray(positiveSum));
}

function getStackDataValues(stackData) {
  if (!isGroupStack(stackData)) {
    return stackData;
  }

  var stackDataValues = [];

  if (isGroupStack(stackData)) {
    Object.keys(stackData).forEach(function (groupId) {
      stackDataValues = [].concat(stackSeriesData_toConsumableArray(stackDataValues), stackSeriesData_toConsumableArray(stackData[groupId]));
    });
  }

  return stackDataValues;
}

function checkIfNegativeAndPositiveValues(stackData) {
  return {
    hasNegative: stackData.map(function (_ref6) {
      var total = _ref6.total;
      return total.negative;
    }).some(function (total) {
      return total < 0;
    }),
    hasPositive: stackData.map(function (_ref7) {
      var total = _ref7.total;
      return total.positive;
    }).some(function (total) {
      return total >= 0;
    })
  };
}

function getScaleType(stackData, stackType, diverging) {
  var _checkIfNegativeAndPo = checkIfNegativeAndPositiveValues(stackData),
      hasPositive = _checkIfNegativeAndPo.hasPositive,
      hasNegative = _checkIfNegativeAndPo.hasNegative;

  if (stackType === 'percent') {
    if (diverging) {
      return 'divergingPercentStack';
    }

    if (hasNegative && hasPositive) {
      return 'dualPercentStack';
    }

    if (!hasNegative && hasPositive) {
      return 'percentStack';
    }

    if (hasNegative && !hasPositive) {
      return 'minusPercentStack';
    }
  }
}

function initStackSeries(series, options) {
  var stackSeries = {};
  Object.keys(series).forEach(function (seriesName) {
    var chartType = seriesName;
    var stackOption = pickStackOption(options);

    if (stackOption) {
      if (!stackSeries[chartType]) {
        stackSeries[chartType] = {};
      }

      stackSeries[chartType].stack = initializeStack(stackOption);
    } else if (seriesName === 'radialBar') {
      stackSeries[seriesName] = {
        stack: true
      };
    }
  });
  return stackSeries;
}

var stackSeriesData = {
  name: 'stackSeriesData',
  state: function state(_ref8) {
    var series = _ref8.series,
        options = _ref8.options;
    return {
      stackSeries: initStackSeries(series, options)
    };
  },
  action: {
    setStackSeriesData: function setStackSeriesData(_ref9) {
      var state = _ref9.state;
      var series = state.series,
          stackSeries = state.stackSeries,
          options = state.options;
      var stackOption = pickStackOption(options);
      var newStackSeries = {};
      Object.keys(series).forEach(function (seriesName) {
        var _options$series;

        var seriesData = series[seriesName];
        var data = seriesData.data,
            seriesCount = seriesData.seriesCount,
            seriesGroupCount = seriesData.seriesGroupCount;
        var isRadialBar = seriesName === 'radialBar';

        if (stackOption) {
          if (!stackSeries[seriesName]) {
            stackSeries[seriesName] = {};
          }

          stackSeries[seriesName].stack = initializeStack(stackOption);
        } else if (!isRadialBar) {
          stackSeries[seriesName] = null;
          delete stackSeries[seriesName];
        }

        var _ref10 = stackSeries[seriesName] || {},
            stack = _ref10.stack;

        var diverging = !!((_options$series = options.series) !== null && _options$series !== void 0 && _options$series.diverging);

        if (stack) {
          var _stack$type;

          var stackData = hasStackGrouped(data) ? makeStackGroupData(data) : makeStackData(data);
          var stackType = (_stack$type = stack.type) !== null && _stack$type !== void 0 ? _stack$type : 'normal';
          var dataRangeValues = getStackDataRangeValues(stackData);
          newStackSeries[seriesName] = {
            data: data,
            seriesCount: seriesCount,
            seriesGroupCount: seriesGroupCount,
            stackData: stackData,
            dataRangeValues: dataRangeValues,
            scaleType: getScaleType(getStackDataValues(stackData), stackType, diverging)
          };
          state.stackSeries[seriesName].stackData = stackData;
        }

        store_extend(state.stackSeries, newStackSeries);
      });
    }
  },
  observe: {
    updateStackSeriesData: function updateStackSeriesData() {
      this.dispatch('setStackSeriesData');
    }
  }
};
/* harmony default export */ var store_stackSeriesData = (stackSeriesData);
;// CONCATENATED MODULE: ./src/store/scale.ts








var MIN_OFFSET_SIZE = 1;

function getLabelScaleData(state, labelAxisOnYAxis, scaleOptions, labelAxisName) {
  var _options$xAxis, _xAxis;

  var dataRange = state.dataRange,
      layout = state.layout,
      series = state.series,
      options = state.options;
  var categories = state.categories;
  var rawCategories = state.rawCategories;

  var _getSizeKey = getSizeKey(labelAxisOnYAxis),
      labelSizeKey = _getSizeKey.labelSizeKey;

  var dateTypeLabel = isExist((_options$xAxis = options.xAxis) === null || _options$xAxis === void 0 ? void 0 : _options$xAxis.date);
  var labelOptions = {
    dataRange: dataRange[labelAxisName],
    offsetSize: Math.max(layout.plot[labelSizeKey], MIN_OFFSET_SIZE),
    scaleOption: scaleOptions[labelAxisName],
    rawCategoriesSize: rawCategories.length
  };
  var result;

  if (dataRange[labelAxisName]) {
    result = dateTypeLabel ? calculateDatetimeScale(labelOptions) : calculateCoordinateScale(labelOptions);
  }

  if (series.line && categories && !((_xAxis = options.xAxis) !== null && _xAxis !== void 0 && _xAxis.pointOnColumn)) {
    result = calculateXAxisScaleForCoordinateLineType(result, options, categories);
  }

  return result;
}

function getValueScaleData(state, labelAxisOnYAxis, scaleOptions, valueAxisName, isCoordinateTypeChart) {
  var dataRange = state.dataRange,
      layout = state.layout,
      series = state.series,
      stackSeries = state.stackSeries;

  var _getSizeKey2 = getSizeKey(labelAxisOnYAxis),
      valueSizeKey = _getSizeKey2.valueSizeKey;

  var result;

  if (hasPercentStackSeries(stackSeries)) {
    Object.keys(series).forEach(function (seriesName) {
      result = getStackScaleData(stackSeries[seriesName].scaleType);
    });
  } else if (isCoordinateTypeChart) {
    var valueOptions = {
      dataRange: dataRange[valueAxisName],
      offsetSize: Math.max(layout.plot[valueSizeKey], MIN_OFFSET_SIZE),
      scaleOption: scaleOptions[valueAxisName]
    };
    result = calculateCoordinateScale(valueOptions);
  } else {
    result = calculateCoordinateScale({
      dataRange: dataRange[valueAxisName],
      offsetSize: Math.max(layout.plot[valueSizeKey], MIN_OFFSET_SIZE),
      scaleOption: scaleOptions[valueAxisName]
    });
  }

  return result;
}

function getScaleOptions(options, series, valueAxisName) {
  var scaleOptions = {};

  if (isSeriesUsingRadialAxes(series)) {
    var _options$valueAxisNam;

    scaleOptions[valueAxisName] = options === null || options === void 0 ? void 0 : (_options$valueAxisNam = options[valueAxisName]) === null || _options$valueAxisNam === void 0 ? void 0 : _options$valueAxisNam.scale;
  } else {
    var _options$xAxis2;

    var _getYAxisOption = getYAxisOption(options),
        yAxis = _getYAxisOption.yAxis,
        secondaryYAxis = _getYAxisOption.secondaryYAxis;

    scaleOptions.xAxis = options === null || options === void 0 ? void 0 : (_options$xAxis2 = options.xAxis) === null || _options$xAxis2 === void 0 ? void 0 : _options$xAxis2.scale;
    scaleOptions.yAxis = yAxis === null || yAxis === void 0 ? void 0 : yAxis.scale;

    if (secondaryYAxis) {
      scaleOptions.secondaryYAxis = secondaryYAxis === null || secondaryYAxis === void 0 ? void 0 : secondaryYAxis.scale;
    }
  }

  return scaleOptions;
}

var scale = {
  name: 'scale',
  state: function state() {
    return {
      scale: {}
    };
  },
  action: {
    setScale: function setScale(_ref) {
      var state = _ref.state,
          initStoreState = _ref.initStoreState;
      var series = state.series,
          options = state.options,
          categories = state.categories;
      var labelAxisOnYAxis = isLabelAxisOnYAxis({
        series: series,
        options: options,
        categories: categories
      });

      var _getAxisName = getAxisName(labelAxisOnYAxis, series),
          labelAxisName = _getAxisName.labelAxisName,
          valueAxisName = _getAxisName.valueAxisName;

      var scaleOptions = getScaleOptions(options, series, valueAxisName);
      var isCoordinateTypeChart = isCoordinateSeries(initStoreState.series);
      var scaleData = {};
      getValueAxisNames(options, valueAxisName).forEach(function (axisName) {
        scaleData[axisName] = getValueScaleData(state, labelAxisOnYAxis, scaleOptions, axisName, isCoordinateTypeChart);
      });

      if (isCoordinateTypeChart) {
        scaleData[labelAxisName] = getLabelScaleData(state, labelAxisOnYAxis, scaleOptions, labelAxisName);
      }

      state.scale = scaleData;
    }
  },
  observe: {
    updateScale: function updateScale() {
      this.dispatch('setScale');
    }
  }
};
/* harmony default export */ var store_scale = (scale);
;// CONCATENATED MODULE: ./src/helpers/plot.ts

function isExistPlotId(plots, data) {
  return plots.some(function (_ref) {
    var bandId = _ref.id;
    return !isUndefined(bandId) && !isUndefined(data.id) && bandId === data.id;
  });
}
;// CONCATENATED MODULE: ./src/store/plot.ts
function plot_toConsumableArray(arr) { return plot_arrayWithoutHoles(arr) || plot_iterableToArray(arr) || plot_unsupportedIterableToArray(arr) || plot_nonIterableSpread(); }

function plot_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function plot_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function plot_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return plot_arrayLikeToArray(arr); }





















function plot_slicedToArray(arr, i) { return plot_arrayWithHoles(arr) || plot_iterableToArrayLimit(arr, i) || plot_unsupportedIterableToArray(arr, i) || plot_nonIterableRest(); }

function plot_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function plot_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return plot_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return plot_arrayLikeToArray(o, minLen); }

function plot_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function plot_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function plot_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }







function getOverlappingRange(ranges) {
  var overlappingRanges = ranges.reduce(function (acc, _ref) {
    var range = _ref.range;

    var _acc = plot_slicedToArray(acc, 2),
        accStart = _acc[0],
        accEnd = _acc[1];

    var _ref2 = range,
        _ref3 = plot_slicedToArray(_ref2, 2),
        start = _ref3[0],
        end = _ref3[1];

    return [Math.min(accStart, start), Math.max(accEnd, end)];
  }, [Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);
  return {
    range: overlappingRanges,
    color: ranges[0].color
  };
}

function getCategoryIndex(value, categories) {
  return categories.findIndex(function (category) {
    return category === String(value);
  });
}

function getValidValue(value, categories) {
  var isDateType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (isDateType) {
    return Number(new Date(value));
  }

  if (utils_isString(value)) {
    return getCategoryIndex(value, categories);
  }

  return value;
}

function makePlotLines(categories, isDateType) {
  var plotLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  return plotLines.map(function (_ref4) {
    var value = _ref4.value,
        color = _ref4.color,
        opacity = _ref4.opacity;
    return {
      value: getValidValue(value, categories, isDateType),
      color: rgba(color, opacity)
    };
  });
}

function makePlotBands(categories, isDateType) {
  var plotBands = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
  return plotBands.flatMap(function (_ref5) {
    var range = _ref5.range,
        _ref5$mergeOverlappin = _ref5.mergeOverlappingRanges,
        mergeOverlappingRanges = _ref5$mergeOverlappin === void 0 ? false : _ref5$mergeOverlappin,
        bgColor = _ref5.color,
        opacity = _ref5.opacity;
    var color = rgba(bgColor, opacity);
    var rangeArray = isRangeValue(range[0]) ? range : [range];
    var ranges = rangeArray.map(function (rangeData) {
      return {
        range: rangeData.map(function (value) {
          return getValidValue(value, categories, isDateType);
        }),
        color: color
      };
    });
    return mergeOverlappingRanges ? getOverlappingRange(ranges) : ranges;
  });
}

var plot = {
  name: 'plot',
  state: function state(_ref6) {
    var _plot$visible, _plot;

    var options = _ref6.options;
    return {
      plot: {
        visible: (_plot$visible = options === null || options === void 0 ? void 0 : (_plot = options.plot) === null || _plot === void 0 ? void 0 : _plot.visible) !== null && _plot$visible !== void 0 ? _plot$visible : true,
        lines: [],
        bands: []
      }
    };
  },
  action: {
    setPlot: function setPlot(_ref7) {
      var _options$xAxis, _lineAreaOptions$plot, _options$xAxis2, _lineAreaOptions$plot2;

      var state = _ref7.state;
      var series = state.series,
          options = state.options;

      if (!(series.area || series.line)) {
        return;
      }

      var rawCategories = state.rawCategories;
      var lineAreaOptions = options;
      var lines = makePlotLines(rawCategories, !!(options !== null && options !== void 0 && (_options$xAxis = options.xAxis) !== null && _options$xAxis !== void 0 && _options$xAxis.date), lineAreaOptions === null || lineAreaOptions === void 0 ? void 0 : (_lineAreaOptions$plot = lineAreaOptions.plot) === null || _lineAreaOptions$plot === void 0 ? void 0 : _lineAreaOptions$plot.lines);
      var bands = makePlotBands(rawCategories, !!(options !== null && options !== void 0 && (_options$xAxis2 = options.xAxis) !== null && _options$xAxis2 !== void 0 && _options$xAxis2.date), lineAreaOptions === null || lineAreaOptions === void 0 ? void 0 : (_lineAreaOptions$plot2 = lineAreaOptions.plot) === null || _lineAreaOptions$plot2 === void 0 ? void 0 : _lineAreaOptions$plot2.bands);
      store_extend(state.plot, {
        lines: lines,
        bands: bands
      });
    },
    addPlotLine: function addPlotLine(_ref8, _ref9) {
      var _plot$lines, _state$options, _state$options$plot;

      var state = _ref8.state;
      var data = _ref9.data;
      var lines = (_plot$lines = (_state$options = state.options) === null || _state$options === void 0 ? void 0 : (_state$options$plot = _state$options.plot) === null || _state$options$plot === void 0 ? void 0 : _state$options$plot.lines) !== null && _plot$lines !== void 0 ? _plot$lines : [];

      if (!isExistPlotId(lines, data)) {
        this.dispatch('updateOptions', {
          options: {
            plot: {
              lines: [].concat(plot_toConsumableArray(lines), [data])
            }
          }
        });
      }
    },
    addPlotBand: function addPlotBand(_ref10, _ref11) {
      var _plot$bands, _state$options2, _state$options2$plot;

      var state = _ref10.state;
      var data = _ref11.data;
      var bands = (_plot$bands = (_state$options2 = state.options) === null || _state$options2 === void 0 ? void 0 : (_state$options2$plot = _state$options2.plot) === null || _state$options2$plot === void 0 ? void 0 : _state$options2$plot.bands) !== null && _plot$bands !== void 0 ? _plot$bands : [];

      if (!isExistPlotId(bands, data)) {
        this.dispatch('updateOptions', {
          options: {
            plot: {
              bands: [].concat(plot_toConsumableArray(bands), [data])
            }
          }
        });
      }
    },
    removePlotLine: function removePlotLine(_ref12, _ref13) {
      var _plot$lines2, _state$options3, _state$options3$plot;

      var state = _ref12.state;
      var id = _ref13.id;
      var lines = ((_plot$lines2 = (_state$options3 = state.options) === null || _state$options3 === void 0 ? void 0 : (_state$options3$plot = _state$options3.plot) === null || _state$options3$plot === void 0 ? void 0 : _state$options3$plot.lines) !== null && _plot$lines2 !== void 0 ? _plot$lines2 : []).filter(function (_ref14) {
        var lineId = _ref14.id;
        return lineId !== id;
      });
      this.dispatch('updateOptions', {
        options: {
          plot: {
            lines: lines
          }
        }
      });
    },
    removePlotBand: function removePlotBand(_ref15, _ref16) {
      var _plot$bands2, _state$options4, _state$options4$plot;

      var state = _ref15.state;
      var id = _ref16.id;
      var bands = ((_plot$bands2 = (_state$options4 = state.options) === null || _state$options4 === void 0 ? void 0 : (_state$options4$plot = _state$options4.plot) === null || _state$options4$plot === void 0 ? void 0 : _state$options4$plot.bands) !== null && _plot$bands2 !== void 0 ? _plot$bands2 : []).filter(function (_ref17) {
        var bandId = _ref17.id;
        return bandId !== id;
      });
      this.dispatch('updateOptions', {
        options: {
          plot: {
            bands: bands
          }
        }
      });
    }
  },
  observe: {
    updatePlot: function updatePlot() {
      this.dispatch('setPlot');
    }
  }
};
/* harmony default export */ var store_plot = (plot);
;// CONCATENATED MODULE: ./src/helpers/tooltip.ts




function isBubblePointType(value) {
  return value.hasOwnProperty('r');
}

function getValueString(value) {
  var result = '';

  if (isRangeValue(value)) {
    result = "".concat(value[0], " ~ ").concat(value[1]);
  } else if (isObject(value) && !Array.isArray(value)) {
    result = "(".concat(value.x, ", ").concat(value.y, ")") + (isBubblePointType(value) ? ", r: ".concat(value.r) : '');
  } else {
    result = String(value);
  }

  return result;
}
;// CONCATENATED MODULE: ./src/helpers/tooltipTemplate.ts
function tooltipTemplate_slicedToArray(arr, i) { return tooltipTemplate_arrayWithHoles(arr) || tooltipTemplate_iterableToArrayLimit(arr, i) || tooltipTemplate_unsupportedIterableToArray(arr, i) || tooltipTemplate_nonIterableRest(); }

function tooltipTemplate_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function tooltipTemplate_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function tooltipTemplate_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function tooltipTemplate_toConsumableArray(arr) { return tooltipTemplate_arrayWithoutHoles(arr) || tooltipTemplate_iterableToArray(arr) || tooltipTemplate_unsupportedIterableToArray(arr) || tooltipTemplate_nonIterableSpread(); }

function tooltipTemplate_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function tooltipTemplate_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return tooltipTemplate_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return tooltipTemplate_arrayLikeToArray(o, minLen); }

function tooltipTemplate_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function tooltipTemplate_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return tooltipTemplate_arrayLikeToArray(arr); }

function tooltipTemplate_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }




















function getSeriesNameTemplate(label, color) {
  return "<span class=\"toastui-chart-series-name\">\n    <i class=\"toastui-chart-icon\" style=\"background: ".concat(color, "\"></i>\n    <span class=\"toastui-chart-name\">").concat(label, "</span>\n  </span>");
}

function getTitleValueTemplate(title, value) {
  return "<div class=\"toastui-chart-tooltip-series\">\n    <span class=\"toastui-chart-series-name\">".concat(title, "</span>\n    <span class=\"toastui-chart-series-value\">").concat(value, "</span>\n  </div>");
}

function getColorValueTemplate(color, value) {
  return "<div class=\"toastui-chart-tooltip-series\">\n    <i class=\"toastui-chart-icon\" style=\"background: ".concat(color, "\"></i>\n    <span class=\"toastui-chart-series-value\">").concat(value, "</span>\n  </div>");
}

function makeBulletDataTemplate(data, titleType) {
  return data.filter(function (_ref) {
    var title = _ref.title;
    return title === titleType;
  }).sort(function (a, b) {
    if (isRangeValue(a.value) && isRangeValue(b.value)) {
      return a.value[0] - b.value[0];
    }

    if (isNumber(a.value) && isNumber(b.value)) {
      return a.value - b.value;
    }

    return 0;
  }).map(function (_ref2) {
    var formattedValue = _ref2.formattedValue,
        color = _ref2.color;
    return getColorValueTemplate(color, formattedValue);
  }).join('');
}

function getDefaultTemplate(model, _ref3, theme) {
  var header = _ref3.header,
      body = _ref3.body;
  var borderColor = theme.borderColor,
      borderWidth = theme.borderWidth,
      background = theme.background,
      borderRadius = theme.borderRadius,
      borderStyle = theme.borderStyle;
  var style = "border: ".concat(borderWidth, "px ").concat(borderStyle, " ").concat(borderColor, ";border-radius: ").concat(borderRadius, "px;background: ").concat(background, ";");
  return "<div class=\"toastui-chart-tooltip\" style=\"".concat(style, "\">").concat(header).concat(body, "</div>");
}
function getHeaderTemplate(_ref4, theme) {
  var category = _ref4.category;
  return category ? "<div class=\"toastui-chart-tooltip-category\" style=\"".concat(getFontStyleString(theme.header), "\">\n        ").concat(category, "\n      </div>") : '';
}

function getDefaultBodyTemplate(_ref5, theme) {
  var data = _ref5.data;
  return "\n    <div class=\"toastui-chart-tooltip-series-wrapper\" style=\"".concat(getFontStyleString(theme.body), "\">\n      ").concat(data.map(function (_ref6) {
    var label = _ref6.label,
        color = _ref6.color,
        formattedValue = _ref6.formattedValue;
    return "<div class=\"toastui-chart-tooltip-series\">\n                ".concat(getSeriesNameTemplate(label, color), "\n                <span class=\"toastui-chart-series-value\">").concat(formattedValue, "</span>\n              </div>");
  }).join(''), "\n    </div>");
}

function getBoxPlotTemplate(_ref7, theme) {
  var data = _ref7.data;
  var groupedData = data.reduce(function (acc, item, index) {
    if (!index) {
      return item;
    }

    if (acc.category === item.category && acc.label === item.label) {
      acc.value = [].concat(tooltipTemplate_toConsumableArray(acc.value), tooltipTemplate_toConsumableArray(item.value));
    }

    return acc;
  }, {});
  return "\n    <div class=\"toastui-chart-tooltip-series-wrapper\" style=\"".concat(getFontStyleString(theme.body), "\">\n      ").concat([groupedData].map(function (_ref8) {
    var label = _ref8.label,
        color = _ref8.color,
        values = _ref8.value;
    return "<div class=\"toastui-chart-tooltip-series\">\n              ".concat(getSeriesNameTemplate(label, color), "\n            </div>\n            <div>\n          ").concat(values.map(function (_ref9) {
      var title = _ref9.title,
          formattedValue = _ref9.formattedValue;
      return getTitleValueTemplate(title, formattedValue);
    }).join(''), "\n            </div>");
  }).join(''), "\n    </div>");
}

function getBulletTemplate(_ref10, theme) {
  var data = _ref10.data;
  return data.length > 1 ? getBulletGroupedTemplate(data, theme) : getBulletBasicTemplate(data, theme);
}

function getBulletBasicTemplate(data, theme) {
  return "\n    <div class=\"toastui-chart-tooltip-series-wrapper\" style=\"".concat(getFontStyleString(theme.body), "\">\n      ").concat(data.map(function (_ref11) {
    var label = _ref11.label,
        color = _ref11.color,
        values = _ref11.value;
    return "<div class=\"toastui-chart-tooltip-series\">".concat(getSeriesNameTemplate(label, color), "</div>\n            ").concat(values.map(function (_ref12) {
      var title = _ref12.title,
          formattedValue = _ref12.formattedValue;
      return getTitleValueTemplate(title, formattedValue);
    }).join(''));
  }).join(''), "\n    </div>");
}

function getBulletGroupedTemplate(data, theme) {
  var bulletData = data.map(function (_ref13) {
    var value = _ref13.value;
    return value[0];
  });

  var _map = ['Actual', 'Range', 'Marker'].map(function (titleType) {
    return makeBulletDataTemplate(bulletData, titleType);
  }),
      _map2 = tooltipTemplate_slicedToArray(_map, 3),
      actual = _map2[0],
      ranges = _map2[1],
      markers = _map2[2];

  return "<div class=\"toastui-chart-tooltip-category\" style=\"".concat(getFontStyleString(theme.header), "\">\n      ").concat(data[0].label, "\n    </div>\n    <div class=\"toastui-chart-tooltip-series-wrapper\" style=\"").concat(getFontStyleString(theme.body), "\">\n      ").concat(actual ? '<div class="toastui-chart-tooltip-title">Actual</div>' : '', " ").concat(actual, "\n      ").concat(ranges ? '<div class="toastui-chart-tooltip-title">Ranges</div>' : '', " ").concat(ranges, "\n      ").concat(markers ? '<div class="toastui-chart-tooltip-title">Markers</div>' : '', " ").concat(markers, "\n    </div>");
}

function getPieTemplate(_ref14, theme) {
  var data = _ref14.data;
  return "\n    <div class=\"toastui-chart-tooltip-series-wrapper\" style=\"".concat(getFontStyleString(theme.body), "\">\n      ").concat(data.map(function (_ref15) {
    var label = _ref15.label,
        color = _ref15.color,
        formattedValue = _ref15.formattedValue,
        percentValue = _ref15.percentValue;
    return "<div class=\"toastui-chart-tooltip-series\">\n          ".concat(getSeriesNameTemplate(label, color), "\n          <span class=\"toastui-chart-series-value\">").concat(pieTooltipLabelFormatter(percentValue), "&nbsp;&nbsp;(").concat(formattedValue, ")</span>\n        </div>");
  }).join(''), "\n    </div>");
}

function getHeatmapTemplate(_ref16, theme) {
  var data = _ref16.data;
  return "".concat(data.map(function (_ref17) {
    var label = _ref17.label,
        color = _ref17.color,
        formattedValue = _ref17.formattedValue;
    return "<div class=\"toastui-chart-tooltip-category\" style=\"".concat(getFontStyleString(theme.header), "\">\n          ").concat(label, "\n        </div>\n        <div class=\"toastui-chart-tooltip-series-wrapper\" style=\"").concat(getFontStyleString(theme.body), "\">\n          <div class=\"toastui-chart-tooltip-series\">\n            ").concat(getSeriesNameTemplate(formattedValue, color), "\n          </div>\n        </div>");
  }).join(''));
}

var tooltipTemplates = {
  default: getDefaultTemplate,
  defaultHeader: getHeaderTemplate,
  defaultBody: getDefaultBodyTemplate,
  boxPlot: getBoxPlotTemplate,
  bullet: getBulletTemplate,
  pie: getPieTemplate,
  heatmap: getHeatmapTemplate
};
function getBodyTemplate(type) {
  return tooltipTemplates[type || 'defaultBody'];
}
// EXTERNAL MODULE: ../../node_modules/core-js/modules/es.regexp.constructor.js
var es_regexp_constructor = __nested_webpack_require_221589__(7368);
;// CONCATENATED MODULE: ./src/helpers/dom.ts
function findNodes(element, selector) {
  return element.querySelectorAll(selector);
}
function removeNode(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
;// CONCATENATED MODULE: ./src/helpers/htmlSanitizer.ts











var HTML_ATTR_LIST_RX = new RegExp('^(abbr|align|alt|axis|bgcolor|border|cellpadding|cellspacing|class|clear|' + 'color|cols|compact|coords|dir|face|headers|height|hreflang|hspace|' + 'ismap|lang|language|nohref|nowrap|rel|rev|rows|rules|' + 'scope|scrolling|shape|size|span|start|summary|tabindex|target|title|type|' + 'valign|value|vspace|width|checked|mathvariant|encoding|id|name|' + 'background|cite|href|longdesc|src|usemap|xlink:href|data-+|checked|style)', 'g');
var SVG_ATTR_LIST_RX = new RegExp('^(accent-height|accumulate|additive|alphabetic|arabic-form|ascent|' + 'baseProfile|bbox|begin|by|calcMode|cap-height|class|color|color-rendering|content|' + 'cx|cy|d|dx|dy|descent|display|dur|end|fill|fill-rule|font-family|font-size|font-stretch|' + 'font-style|font-variant|font-weight|from|fx|fy|g1|g2|glyph-name|gradientUnits|hanging|' + 'height|horiz-adv-x|horiz-origin-x|ideographic|k|keyPoints|keySplines|keyTimes|lang|' + 'marker-end|marker-mid|marker-start|markerHeight|markerUnits|markerWidth|mathematical|' + 'max|min|offset|opacity|orient|origin|overline-position|overline-thickness|panose-1|' + 'path|pathLength|points|preserveAspectRatio|r|refX|refY|repeatCount|repeatDur|' + 'requiredExtensions|requiredFeatures|restart|rotate|rx|ry|slope|stemh|stemv|stop-color|' + 'stop-opacity|strikethrough-position|strikethrough-thickness|stroke|stroke-dasharray|' + 'stroke-dashoffset|stroke-linecap|stroke-linejoin|stroke-miterlimit|stroke-opacity|' + 'stroke-width|systemLanguage|target|text-anchor|to|transform|type|u1|u2|underline-position|' + 'underline-thickness|unicode|unicode-range|units-per-em|values|version|viewBox|visibility|' + 'width|widths|x|x-height|x1|x2|xlink:actuate|xlink:arcrole|xlink:role|xlink:show|xlink:title|' + 'xlink:type|xml:base|xml:lang|xml:space|xmlns|xmlns:xlink|y|y1|y2|zoomAndPan)', 'g');
var DEFAULT_TAG_DENY_LIST = ['script', 'iframe', 'textarea', 'form', 'button', 'select', 'input', 'meta', 'style', 'link', 'title', 'embed', 'object'];
var XSS_ATTR_RX = /href|src|background/gi;
var XSS_VALUE_RX = /((java|vb|live)script|x):/gi;
var ON_EVENT_RX = /^on\S+/;
function sanitizeHTML(html) {
  var root = document.createElement('div');

  if (utils_isString(html)) {
    html = html.replace(/<!--[\s\S]*?-->/g, '');
    root.innerHTML = html;
  } else {
    root.appendChild(html);
  }

  removeUnnecessaryTags(root);
  leaveOnlyWhitelistAttribute(root);
  return root.innerHTML;
}

function removeUnnecessaryTags(html) {
  var removedTags = findNodes(html, DEFAULT_TAG_DENY_LIST.join(','));
  removedTags.forEach(function (node) {
    removeNode(node);
  });
}

function isXSSAttribute(attrName, attrValue) {
  return attrName.match(XSS_ATTR_RX) && attrValue.match(XSS_VALUE_RX);
}

function removeBlacklistAttributes(node, blacklistAttrs) {
  blacklistAttrs.forEach(function (_ref) {
    var name = _ref.name;

    if (ON_EVENT_RX.test(name)) {
      node[name] = null;
    }

    if (node.getAttribute(name)) {
      node.removeAttribute(name);
    }
  });
}

function leaveOnlyWhitelistAttribute(html) {
  findNodes(html, '*').forEach(function (node) {
    var attributes = node.attributes;
    var blacklist = toArray(attributes).filter(function (attr) {
      var name = attr.name,
          value = attr.value;
      var htmlAttr = name.match(HTML_ATTR_LIST_RX);
      var svgAttr = name.match(SVG_ATTR_LIST_RX);
      var xssAttr = htmlAttr && isXSSAttribute(name, value);
      return !htmlAttr && !svgAttr || xssAttr;
    });
    removeBlacklistAttributes(node, blacklist);
  });
}
;// CONCATENATED MODULE: ./src/component/tooltip.ts
function tooltip_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { tooltip_typeof = function _typeof(obj) { return typeof obj; }; } else { tooltip_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return tooltip_typeof(obj); }

function tooltip_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function tooltip_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { tooltip_ownKeys(Object(source), true).forEach(function (key) { tooltip_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { tooltip_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function tooltip_toConsumableArray(arr) { return tooltip_arrayWithoutHoles(arr) || tooltip_iterableToArray(arr) || tooltip_unsupportedIterableToArray(arr) || tooltip_nonIterableSpread(); }

function tooltip_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function tooltip_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return tooltip_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return tooltip_arrayLikeToArray(o, minLen); }

function tooltip_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function tooltip_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return tooltip_arrayLikeToArray(arr); }

function tooltip_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

























function tooltip_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function tooltip_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function tooltip_createClass(Constructor, protoProps, staticProps) { if (protoProps) tooltip_defineProperties(Constructor.prototype, protoProps); if (staticProps) tooltip_defineProperties(Constructor, staticProps); return Constructor; }

function tooltip_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) tooltip_setPrototypeOf(subClass, superClass); }

function tooltip_setPrototypeOf(o, p) { tooltip_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return tooltip_setPrototypeOf(o, p); }

function tooltip_createSuper(Derived) { var hasNativeReflectConstruct = tooltip_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = tooltip_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = tooltip_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return tooltip_possibleConstructorReturn(this, result); }; }

function tooltip_possibleConstructorReturn(self, call) { if (call && (tooltip_typeof(call) === "object" || typeof call === "function")) { return call; } return tooltip_assertThisInitialized(self); }

function tooltip_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function tooltip_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function tooltip_getPrototypeOf(o) { tooltip_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return tooltip_getPrototypeOf(o); }

function tooltip_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var DEFAULT_TOOLTIP_TRANSITION = 'transform 0.2s ease';

var Tooltip = /*#__PURE__*/function (_Component) {
  tooltip_inherits(Tooltip, _Component);

  var _super = tooltip_createSuper(Tooltip);

  function Tooltip() {
    var _this;

    tooltip_classCallCheck(this, Tooltip);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "chartEl", void 0);

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "tooltipContainerEl", void 0);

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "templateFunc", void 0);

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "theme", void 0);

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "offsetX", void 0);

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "offsetY", void 0);

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "formatter", void 0);

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "tooltipInfoModels", {});

    tooltip_defineProperty(tooltip_assertThisInitialized(_this), "onSeriesPointHovered", function (_ref) {
      var models = _ref.models,
          name = _ref.name;
      _this.tooltipInfoModels[name] = models !== null && models !== void 0 && models.length ? tooltip_toConsumableArray(models) : [];
      var isShow = !!_this.getTooltipInfoModels().length;

      if (isShow) {
        _this.renderTooltip();
      } else {
        _this.removeTooltip();
      }
    });

    return _this;
  }

  tooltip_createClass(Tooltip, [{
    key: "isTooltipContainerOverflow",
    value: function isTooltipContainerOverflow(x, y) {
      var _this$tooltipContaine = this.tooltipContainerEl.getBoundingClientRect(),
          width = _this$tooltipContaine.width,
          height = _this$tooltipContaine.height;

      var _this$rect = this.rect,
          rectX = _this$rect.x,
          rectY = _this$rect.y,
          rectWidth = _this$rect.width,
          rectHeight = _this$rect.height;
      return {
        overflowX: x > rectX + rectWidth || x + width > rectX + rectWidth,
        overflowY: y > rectY + rectHeight || y + height > rectY + rectHeight
      };
    }
  }, {
    key: "getPositionInRect",
    value: function getPositionInRect(model) {
      var target = model.target;
      var startX = this.rect.x + model.x;
      var startY = this.rect.y + model.y;
      var x = startX + target.radius + target.width + this.offsetX;
      var y = startY + this.offsetY;

      var _this$isTooltipContai = this.isTooltipContainerOverflow(x, y),
          overflowX = _this$isTooltipContai.overflowX,
          overflowY = _this$isTooltipContai.overflowY;

      var _this$tooltipContaine2 = this.tooltipContainerEl.getBoundingClientRect(),
          width = _this$tooltipContaine2.width,
          height = _this$tooltipContaine2.height;

      if (overflowX) {
        x = startX - (width + target.radius + this.offsetX) > 0 ? startX - (width + target.radius + this.offsetX) : startX + this.offsetX;
      }

      if (overflowY) {
        y = startY + target.height - (height + this.offsetY) > 0 ? startY + target.height - (height + this.offsetY) : y;
      }

      return {
        x: x,
        y: y
      };
    }
  }, {
    key: "setTooltipPosition",
    value: function setTooltipPosition(model) {
      var _this$getPositionInRe = this.getPositionInRect(model),
          x = _this$getPositionInRe.x,
          y = _this$getPositionInRe.y;

      this.tooltipContainerEl.style.transform = getTranslateString(x, y);
    }
  }, {
    key: "getTooltipInfoModels",
    value: function getTooltipInfoModels() {
      return Object.values(this.tooltipInfoModels).flatMap(function (item) {
        return item;
      });
    }
  }, {
    key: "renderTooltip",
    value: function renderTooltip() {
      var _this2 = this;

      var model = this.getTooltipInfoModels().reduce(function (acc, item) {
        var data = item.data,
            x = item.x,
            y = item.y,
            radius = item.radius,
            width = item.width,
            height = item.height;
        acc.x = acc.x ? (acc.x + x) / 2 : x;
        acc.y = acc.y ? (acc.y + y) / 2 : y;

        if (isNumber(radius)) {
          acc.target.radius = radius;
        }

        if (width) {
          acc.target.width = width;
        }

        if (height) {
          acc.target.height = height;
        }

        acc.data.push(tooltip_objectSpread(tooltip_objectSpread({}, data), {}, {
          value: Array.isArray(data.value) ? data.value.map(function (titleValue) {
            return tooltip_objectSpread(tooltip_objectSpread({}, titleValue), {}, {
              formattedValue: _this2.getFormattedValue(titleValue.value, data)
            });
          }) : data.value,
          formattedValue: _this2.getFormattedValue(data.value, data)
        }));

        if (!acc.category && data.category) {
          acc.category = data.category;
        }

        if (data.templateType) {
          acc.templateType = data.templateType;
        }

        return acc;
      }, {
        type: 'tooltip',
        x: 0,
        y: 0,
        data: [],
        target: {
          radius: 0,
          width: 0,
          height: 0
        }
      });
      this.tooltipContainerEl.innerHTML = sanitizeHTML(this.templateFunc(model, {
        header: tooltipTemplates.defaultHeader(model, this.theme),
        body: getBodyTemplate(model.templateType)(model, this.theme)
      }, this.theme));
      this.setTooltipPosition(model);
    }
  }, {
    key: "initialize",
    value: function initialize(_ref2) {
      var chartEl = _ref2.chartEl;
      this.type = 'tooltip';
      this.name = 'tooltip';
      this.chartEl = chartEl;
      this.tooltipContainerEl = document.createElement('div');
      this.tooltipContainerEl.classList.add('toastui-chart-tooltip-container');

      var _this$chartEl$getBoun = this.chartEl.getBoundingClientRect(),
          width = _this$chartEl$getBoun.width,
          height = _this$chartEl$getBoun.height,
          top = _this$chartEl$getBoun.top,
          left = _this$chartEl$getBoun.left;

      this.tooltipContainerEl.style.transform = getTranslateString(left + width / 2, top + height / 2);
      this.chartEl.appendChild(this.tooltipContainerEl);
      this.eventBus.on('seriesPointHovered', this.onSeriesPointHovered);
    }
  }, {
    key: "removeTooltip",
    value: function removeTooltip() {
      this.tooltipContainerEl.innerHTML = '';
    }
  }, {
    key: "setTooltipTransition",
    value: function setTooltipTransition(options) {
      var _options$tooltip;

      var transition = (_options$tooltip = options.tooltip) === null || _options$tooltip === void 0 ? void 0 : _options$tooltip.transition;

      if (isBoolean(transition) && transition) {
        this.tooltipContainerEl.style.transition = DEFAULT_TOOLTIP_TRANSITION;
      } else if (utils_isString(transition)) {
        this.tooltipContainerEl.style.transition = transition;
      }
    }
  }, {
    key: "render",
    value: function render(_ref3) {
      var _options$tooltip$temp, _options$tooltip2, _options$tooltip$offs, _options$tooltip3, _options$tooltip$offs2, _options$tooltip4, _options$tooltip5;

      var layout = _ref3.layout,
          options = _ref3.options,
          theme = _ref3.theme;
      this.setTooltipTransition(options);
      this.rect = layout.plot;
      this.theme = theme.tooltip;
      this.templateFunc = (_options$tooltip$temp = options === null || options === void 0 ? void 0 : (_options$tooltip2 = options.tooltip) === null || _options$tooltip2 === void 0 ? void 0 : _options$tooltip2.template) !== null && _options$tooltip$temp !== void 0 ? _options$tooltip$temp : tooltipTemplates.default;
      this.offsetX = (_options$tooltip$offs = options === null || options === void 0 ? void 0 : (_options$tooltip3 = options.tooltip) === null || _options$tooltip3 === void 0 ? void 0 : _options$tooltip3.offsetX) !== null && _options$tooltip$offs !== void 0 ? _options$tooltip$offs : 10;
      this.offsetY = (_options$tooltip$offs2 = options === null || options === void 0 ? void 0 : (_options$tooltip4 = options.tooltip) === null || _options$tooltip4 === void 0 ? void 0 : _options$tooltip4.offsetY) !== null && _options$tooltip$offs2 !== void 0 ? _options$tooltip$offs2 : 0;
      this.formatter = options === null || options === void 0 ? void 0 : (_options$tooltip5 = options.tooltip) === null || _options$tooltip5 === void 0 ? void 0 : _options$tooltip5.formatter;
    }
  }, {
    key: "getFormattedValue",
    value: function getFormattedValue(value, tooltipDataInfo) {
      return this.formatter ? this.formatter(value, tooltipDataInfo) : getValueString(value);
    }
  }]);

  return Tooltip;
}(Component);


;// CONCATENATED MODULE: ./src/component/plot.ts
function plot_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { plot_typeof = function _typeof(obj) { return typeof obj; }; } else { plot_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return plot_typeof(obj); }

function plot_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function plot_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { plot_ownKeys(Object(source), true).forEach(function (key) { plot_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { plot_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function component_plot_toConsumableArray(arr) { return component_plot_arrayWithoutHoles(arr) || component_plot_iterableToArray(arr) || component_plot_unsupportedIterableToArray(arr) || component_plot_nonIterableSpread(); }

function component_plot_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function component_plot_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function component_plot_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return component_plot_arrayLikeToArray(arr); }

function component_plot_slicedToArray(arr, i) { return component_plot_arrayWithHoles(arr) || component_plot_iterableToArrayLimit(arr, i) || component_plot_unsupportedIterableToArray(arr, i) || component_plot_nonIterableRest(); }

function component_plot_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function component_plot_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return component_plot_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return component_plot_arrayLikeToArray(o, minLen); }

function component_plot_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function component_plot_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function component_plot_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }






















function plot_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function plot_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function plot_createClass(Constructor, protoProps, staticProps) { if (protoProps) plot_defineProperties(Constructor.prototype, protoProps); if (staticProps) plot_defineProperties(Constructor, staticProps); return Constructor; }

function plot_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) plot_setPrototypeOf(subClass, superClass); }

function plot_setPrototypeOf(o, p) { plot_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return plot_setPrototypeOf(o, p); }

function plot_createSuper(Derived) { var hasNativeReflectConstruct = plot_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = plot_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = plot_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return plot_possibleConstructorReturn(this, result); }; }

function plot_possibleConstructorReturn(self, call) { if (call && (plot_typeof(call) === "object" || typeof call === "function")) { return call; } return plot_assertThisInitialized(self); }

function plot_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function plot_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function plot_getPrototypeOf(o) { plot_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return plot_getPrototypeOf(o); }

function plot_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





function getValidIndex(index) {
  var startIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return ~~index ? index - startIndex : index;
}

function validXPosition(_ref) {
  var axisData = _ref.axisData,
      offsetSize = _ref.offsetSize,
      value = _ref.value,
      _ref$startIndex = _ref.startIndex,
      startIndex = _ref$startIndex === void 0 ? 0 : _ref$startIndex;
  var dataIndex = getValidIndex(value, startIndex);
  var x = getXPosition(axisData, offsetSize, value, dataIndex);
  return x > 0 ? Math.min(offsetSize, x) : 0;
}

function getPlotAxisData(vertical, axes) {
  return vertical ? axes.xAxis : axes.yAxis;
}

var Plot = /*#__PURE__*/function (_Component) {
  plot_inherits(Plot, _Component);

  var _super = plot_createSuper(Plot);

  function Plot() {
    var _this;

    plot_classCallCheck(this, Plot);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    plot_defineProperty(plot_assertThisInitialized(_this), "models", {
      plot: [],
      line: [],
      band: []
    });

    plot_defineProperty(plot_assertThisInitialized(_this), "startIndex", 0);

    plot_defineProperty(plot_assertThisInitialized(_this), "theme", void 0);

    return _this;
  }

  plot_createClass(Plot, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'plot';
    }
  }, {
    key: "getPlotAxisSize",
    value: function getPlotAxisSize(vertical) {
      return {
        offsetSize: vertical ? this.rect.width : this.rect.height,
        anchorSize: vertical ? this.rect.height : this.rect.width
      };
    }
  }, {
    key: "renderLines",
    value: function renderLines(axes, categories) {
      var _this2 = this;

      var lines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      return lines.map(function (_ref2) {
        var value = _ref2.value,
            color = _ref2.color;

        var _this2$getPlotAxisSiz = _this2.getPlotAxisSize(true),
            offsetSize = _this2$getPlotAxisSiz.offsetSize;

        var position = validXPosition({
          axisData: getPlotAxisData(true, axes),
          offsetSize: offsetSize,
          value: value,
          categories: categories,
          startIndex: _this2.startIndex
        });
        return _this2.makeLineModel(true, position, {
          color: color
        });
      });
    }
  }, {
    key: "renderBands",
    value: function renderBands(axes, categories) {
      var _this3 = this;

      var bands = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

      var _this$getPlotAxisSize = this.getPlotAxisSize(true),
          offsetSize = _this$getPlotAxisSize.offsetSize,
          anchorSize = _this$getPlotAxisSize.anchorSize;

      return bands.map(function (_ref3) {
        var range = _ref3.range,
            color = _ref3.color;

        var _map = range.map(function (value) {
          return validXPosition({
            axisData: getPlotAxisData(true, axes),
            offsetSize: offsetSize,
            value: value,
            categories: categories,
            startIndex: _this3.startIndex
          });
        }),
            _map2 = component_plot_slicedToArray(_map, 2),
            start = _map2[0],
            end = _map2[1];

        return {
          type: 'rect',
          x: crispPixel(start),
          y: crispPixel(0),
          width: end - start,
          height: anchorSize,
          color: color
        };
      });
    }
  }, {
    key: "renderPlotLineModels",
    value: function renderPlotLineModels(relativePositions, vertical) {
      var _ref5,
          _this4 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var size = options.size,
          startPosition = options.startPosition,
          axes = options.axes;
      var _ref4 = this.theme[vertical ? 'vertical' : 'horizontal'],
          color = _ref4.lineColor,
          lineWidth = _ref4.lineWidth,
          dashSegments = _ref4.dashSegments;
      var tickInterval = ((_ref5 = vertical ? axes === null || axes === void 0 ? void 0 : axes.xAxis : axes === null || axes === void 0 ? void 0 : axes.yAxis) === null || _ref5 === void 0 ? void 0 : _ref5.tickInterval) || 1;
      return relativePositions.filter(function (_, idx) {
        return !(idx % tickInterval);
      }).map(function (position) {
        return _this4.makeLineModel(vertical, position, {
          color: color,
          lineWidth: lineWidth,
          dashSegments: dashSegments
        }, size !== null && size !== void 0 ? size : _this4.rect.width, startPosition !== null && startPosition !== void 0 ? startPosition : 0);
      });
    }
  }, {
    key: "renderPlotsForCenterYAxis",
    value: function renderPlotsForCenterYAxis(axes) {
      var _ref6 = axes.centerYAxis,
          xAxisHalfSize = _ref6.xAxisHalfSize,
          secondStartX = _ref6.secondStartX,
          yAxisHeight = _ref6.yAxisHeight; // vertical

      var xAxisTickCount = axes.xAxis.tickCount;
      var verticalLines = [].concat(component_plot_toConsumableArray(this.renderPlotLineModels(makeTickPixelPositions(xAxisHalfSize, xAxisTickCount), true)), component_plot_toConsumableArray(this.renderPlotLineModels(makeTickPixelPositions(xAxisHalfSize, xAxisTickCount, secondStartX), true))); // horizontal

      var yAxisTickCount = axes.yAxis.tickCount;
      var yAxisTickPixelPositions = makeTickPixelPositions(yAxisHeight, yAxisTickCount);
      var horizontalLines = [].concat(component_plot_toConsumableArray(this.renderPlotLineModels(yAxisTickPixelPositions, false, {
        size: xAxisHalfSize
      })), component_plot_toConsumableArray(this.renderPlotLineModels(yAxisTickPixelPositions, false, {
        size: xAxisHalfSize,
        startPosition: secondStartX
      })));
      return [].concat(component_plot_toConsumableArray(verticalLines), component_plot_toConsumableArray(horizontalLines));
    }
  }, {
    key: "renderPlots",
    value: function renderPlots(axes, scale) {
      var vertical = true;
      return axes.centerYAxis ? this.renderPlotsForCenterYAxis(axes) : [].concat(component_plot_toConsumableArray(this.renderPlotLineModels(this.getHorizontalTickPixelPositions(axes), !vertical, {
        axes: axes
      })), component_plot_toConsumableArray(this.renderPlotLineModels(this.getVerticalTickPixelPositions(axes, scale), vertical, {
        axes: axes
      })));
    }
  }, {
    key: "getVerticalTickPixelPositions",
    value: function getVerticalTickPixelPositions(axes, scale) {
      var _this$getPlotAxisSize2 = this.getPlotAxisSize(true),
          offsetSize = _this$getPlotAxisSize2.offsetSize;

      var axisData = getPlotAxisData(true, axes);

      if (axisData !== null && axisData !== void 0 && axisData.labelRange) {
        var _scale$xAxis$sizeRati, _scale$xAxis, _scale$xAxis$position, _scale$xAxis2;

        var sizeRatio = (_scale$xAxis$sizeRati = scale === null || scale === void 0 ? void 0 : (_scale$xAxis = scale.xAxis) === null || _scale$xAxis === void 0 ? void 0 : _scale$xAxis.sizeRatio) !== null && _scale$xAxis$sizeRati !== void 0 ? _scale$xAxis$sizeRati : 1;
        var positionRatio = (_scale$xAxis$position = scale === null || scale === void 0 ? void 0 : (_scale$xAxis2 = scale.xAxis) === null || _scale$xAxis2 === void 0 ? void 0 : _scale$xAxis2.positionRatio) !== null && _scale$xAxis$position !== void 0 ? _scale$xAxis$position : 0;
        var axisSizeAppliedRatio = offsetSize * sizeRatio;
        var additional = offsetSize * positionRatio;
        return makeTickPixelPositions(axisSizeAppliedRatio, axisData.tickCount, additional);
      }

      return makeTickPixelPositions(offsetSize, axisData.tickCount);
    }
  }, {
    key: "getHorizontalTickPixelPositions",
    value: function getHorizontalTickPixelPositions(axes) {
      var _this$getPlotAxisSize3 = this.getPlotAxisSize(false),
          offsetSize = _this$getPlotAxisSize3.offsetSize;

      var axisData = getPlotAxisData(false, axes);
      return makeTickPixelPositions(offsetSize, axisData.tickCount);
    }
  }, {
    key: "renderPlotBackgroundRect",
    value: function renderPlotBackgroundRect() {
      return plot_objectSpread(plot_objectSpread({
        type: 'rect',
        x: 0,
        y: 0
      }, pick(this.rect, 'width', 'height')), {}, {
        color: this.theme.backgroundColor
      });
    }
  }, {
    key: "render",
    value: function render(state) {
      var _zoomRange$, _ref7;

      var layout = state.layout,
          axes = state.axes,
          plot = state.plot,
          zoomRange = state.zoomRange,
          theme = state.theme,
          scale = state.scale;

      if (!plot) {
        return;
      }

      this.rect = layout.plot;
      this.startIndex = (_zoomRange$ = zoomRange === null || zoomRange === void 0 ? void 0 : zoomRange[0]) !== null && _zoomRange$ !== void 0 ? _zoomRange$ : 0;
      this.theme = theme.plot;
      var categories = (_ref7 = state.categories) !== null && _ref7 !== void 0 ? _ref7 : [];
      var lines = plot.lines,
          bands = plot.bands,
          visible = plot.visible;
      this.models.line = this.renderLines(axes, categories, lines);
      this.models.band = this.renderBands(axes, categories, bands);

      if (visible) {
        this.models.plot = [this.renderPlotBackgroundRect()].concat(component_plot_toConsumableArray(this.renderPlots(axes, scale)));
      }
    }
  }, {
    key: "makeLineModel",
    value: function makeLineModel(vertical, position, _ref8, sizeWidth) {
      var color = _ref8.color,
          _ref8$dashSegments = _ref8.dashSegments,
          dashSegments = _ref8$dashSegments === void 0 ? [] : _ref8$dashSegments,
          _ref8$lineWidth = _ref8.lineWidth,
          lineWidth = _ref8$lineWidth === void 0 ? 1 : _ref8$lineWidth;
      var xPos = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var x = vertical ? crispPixel(position) : crispPixel(xPos);
      var y = vertical ? crispPixel(0) : crispPixel(position);
      var width = vertical ? 0 : sizeWidth !== null && sizeWidth !== void 0 ? sizeWidth : this.rect.width;
      var height = vertical ? this.rect.height : 0;
      return {
        type: 'line',
        x: x,
        y: y,
        x2: x + width,
        y2: y + height,
        strokeStyle: color,
        lineWidth: lineWidth,
        dashSegments: dashSegments
      };
    }
  }, {
    key: "beforeDraw",
    value: function beforeDraw(painter) {
      painter.ctx.strokeStyle = 'rgba(0, 0, 0, 0.05)';
      painter.ctx.lineWidth = 1;
    }
  }]);

  return Plot;
}(Component);


;// CONCATENATED MODULE: ./src/helpers/responders.ts
function responders_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function responders_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { responders_ownKeys(Object(source), true).forEach(function (key) { responders_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { responders_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function responders_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function responders_toConsumableArray(arr) { return responders_arrayWithoutHoles(arr) || responders_iterableToArray(arr) || responders_unsupportedIterableToArray(arr) || responders_nonIterableSpread(); }

function responders_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function responders_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return responders_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return responders_arrayLikeToArray(o, minLen); }

function responders_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function responders_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return responders_arrayLikeToArray(arr); }

function responders_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }























// eslint-disable-next-line complexity
function isSameSeriesResponder(_ref) {
  var models = _ref.models,
      comparisonModel = _ref.comparisonModel,
      name = _ref.name,
      eventDetectType = _ref.eventDetectType;

  switch (name) {
    case 'heatmap':
      return isClickSameNameResponder(models, comparisonModel);

    case 'bullet':
      return eventDetectType === 'grouped' ? isClickSameGroupedRectResponder(models, comparisonModel) : isClickSameNameResponder(models, comparisonModel);

    case 'radar':
    case 'bubble':
    case 'scatter':
    case 'area':
    case 'line':
      return isClickSameCircleResponder(models, comparisonModel);

    case 'pie':
      return isClickSameDataResponder(models, comparisonModel);

    case 'column':
    case 'bar':
      return eventDetectType === 'grouped' ? isClickSameGroupedRectResponder(models, comparisonModel) : isClickSameDataResponder(models, comparisonModel);

    case 'boxPlot':
      return eventDetectType === 'grouped' ? isClickSameDataResponder(models, comparisonModel) : isClickSameBoxPlotDataResponder(models, comparisonModel);

    case 'treemap':
      return isClickSameLabelResponder(models, comparisonModel);

    case 'gauge':
      return isClickSameNameResponder(models, comparisonModel);

    default:
      return false;
  }
}
function getNearestResponder(responders, mousePosition, rect) {
  var minDistance = Infinity;
  var result = [];
  responders.forEach(function (responder) {
    var x = responder.x,
        y = responder.y,
        radius = responder.radius;
    var responderPoint = {
      x: x + rect.x,
      y: y + rect.y
    };
    var distance = getDistance(responderPoint, mousePosition);

    if (minDistance > distance) {
      minDistance = distance;
      result = [responder];
    } else if (minDistance === distance) {
      if (result.length && result[0].radius > radius) {
        result = [responder];
      } else {
        result.push(responder);
      }
    }
  });
  return result;
}
function makeRectResponderModel(rect, axis, categories) {
  var vertical = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var pointOnColumn = axis.pointOnColumn,
      tickDistance = axis.tickDistance,
      rectResponderCount = axis.rectResponderCount;
  var width = rect.width,
      height = rect.height;
  var halfDetectAreaIndex = pointOnColumn ? [] : [0, rectResponderCount - 1];
  var halfSize = tickDistance / 2;
  return range(0, rectResponderCount).map(function (index) {
    var half = halfDetectAreaIndex.includes(index);
    var size = half ? halfSize : tickDistance;
    var startPos = 0;

    if (index !== 0) {
      startPos += pointOnColumn ? tickDistance * index : halfSize + tickDistance * (index - 1);
    }

    return {
      type: 'rect',
      y: vertical ? 0 : startPos,
      height: vertical ? height : size,
      x: vertical ? startPos : 0,
      width: vertical ? size : width,
      index: index,
      label: categories[index]
    };
  });
}
function responders_makeRectResponderModelForCoordinateType(responderInfo, rect) {
  var width = rect.width,
      height = rect.height;
  var startPos = 0;
  return responderInfo.sort(function (a, b) {
    return a.x - b.x;
  }).reduce(function (acc, model, index) {
    var x = model.x,
        label = model.label;
    var next = responderInfo[index + 1];
    var endPos = next ? (next.x + x) / 2 : width;
    var rectResponderModel = {
      type: 'rect',
      x: startPos,
      y: 0,
      width: endPos - startPos,
      height: height,
      label: label,
      index: index
    };
    startPos = endPos;
    return [].concat(responders_toConsumableArray(acc), [rectResponderModel]);
  }, []);
}
function makeTooltipCircleMap(seriesCircleModel, tooltipDataArr) {
  var dataMap = tooltipDataArr.reduce(function (acc, cur) {
    var index = cur.index,
        seriesIndex = cur.seriesIndex;

    if (!acc[seriesIndex]) {
      acc[seriesIndex] = [];
    }

    acc[seriesIndex][index] = cur;
    return acc;
  }, []);
  return seriesCircleModel.reduce(function (acc, model) {
    var seriesIndex = model.seriesIndex,
        index = model.index;
    var data = dataMap[seriesIndex][index];
    var category = data.category;

    if (!category) {
      return acc;
    }

    if (!acc[category]) {
      acc[category] = [];
    }

    acc[category].push(responders_objectSpread(responders_objectSpread({}, model), {}, {
      data: data
    }));
    return acc;
  }, {});
}
function getDeepestNode(responders) {
  return responders.reduce(function (acc, responder) {
    if (!acc.length || responder.depth > acc[0].depth) {
      return [responder];
    }

    return acc;
  }, []);
}
function isClickSameNameResponder(responders, selectedSeries) {
  return responders.length && (selectedSeries === null || selectedSeries === void 0 ? void 0 : selectedSeries.length) && responders[0].name === selectedSeries[0].name;
}
function isClickSameCircleResponder(responders, selectedSeries) {
  var same = false;

  if (responders.length && selectedSeries !== null && selectedSeries !== void 0 && selectedSeries.length && responders.length === selectedSeries.length) {
    same = responders.reduce(function (acc, cur, idx) {
      return acc && cur.seriesIndex === selectedSeries[idx].seriesIndex && cur.index === selectedSeries[idx].index;
    }, true);
  }

  return same;
}
function isClickSameDataResponder(responders, selectedSeries) {
  var same = false;

  if (responders.length && selectedSeries !== null && selectedSeries !== void 0 && selectedSeries.length && responders.length === selectedSeries.length) {
    same = responders.reduce(function (acc, cur, idx) {
      var _cur$data, _selectedSeries$idx$d, _cur$data2, _selectedSeries$idx$d2;

      return acc && ((_cur$data = cur.data) === null || _cur$data === void 0 ? void 0 : _cur$data.label) === ((_selectedSeries$idx$d = selectedSeries[idx].data) === null || _selectedSeries$idx$d === void 0 ? void 0 : _selectedSeries$idx$d.label) && ((_cur$data2 = cur.data) === null || _cur$data2 === void 0 ? void 0 : _cur$data2.category) === ((_selectedSeries$idx$d2 = selectedSeries[idx].data) === null || _selectedSeries$idx$d2 === void 0 ? void 0 : _selectedSeries$idx$d2.category);
    }, true);
  }

  return same;
}
function isClickSameLabelResponder(responders, selectedSeries) {
  return responders.length && (selectedSeries === null || selectedSeries === void 0 ? void 0 : selectedSeries.length) && responders[0].label === selectedSeries[0].label;
}
function isClickSameGroupedRectResponder(responders, selectedSeries) {
  return responders.length && (selectedSeries === null || selectedSeries === void 0 ? void 0 : selectedSeries.length) && responders[0].index === selectedSeries[0].index;
}
function isClickSameBoxPlotDataResponder(responders, selectedSeries) {
  var same = false;

  if (responders.length && selectedSeries !== null && selectedSeries !== void 0 && selectedSeries.length) {
    var _selectedSeries$0$dat, _selectedSeries$0$dat2;

    var _responders$ = responders[0],
        type = _responders$.type,
        data = _responders$.data;
    same = type === selectedSeries[0].type && (data === null || data === void 0 ? void 0 : data.label) === ((_selectedSeries$0$dat = selectedSeries[0].data) === null || _selectedSeries$0$dat === void 0 ? void 0 : _selectedSeries$0$dat.label) && (data === null || data === void 0 ? void 0 : data.category) === ((_selectedSeries$0$dat2 = selectedSeries[0].data) === null || _selectedSeries$0$dat2 === void 0 ? void 0 : _selectedSeries$0$dat2.category);
  }

  return same;
}
function makeGroupedSectorResponderModel(radiusRanges, renderOptions, categories) {
  var centerX = renderOptions.centerX,
      centerY = renderOptions.centerY,
      _renderOptions$angleR = renderOptions.angleRange,
      start = _renderOptions$angleR.start,
      end = _renderOptions$angleR.end,
      clockwise = renderOptions.clockwise;
  return getRadiusRanges(radiusRanges, 0).map(function (radius, index) {
    return {
      type: 'sector',
      x: centerX,
      y: centerY,
      degree: {
        start: start,
        end: end
      },
      radius: radius,
      name: categories[index],
      clockwise: clockwise,
      index: index
    };
  });
}
;// CONCATENATED MODULE: ./src/helpers/dataLabels.ts
function dataLabels_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function dataLabels_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { dataLabels_ownKeys(Object(source), true).forEach(function (key) { dataLabels_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { dataLabels_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function dataLabels_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }













var RADIUS_PADDING = 30;
var CALLOUT_LENGTH = 20;

function getDefaultAnchor(type) {
  var withStack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var anchor = 'auto';

  switch (type) {
    case 'point':
      anchor = 'center';
      break;

    case 'rect':
      anchor = !withStack ? 'auto' : 'center';
      break;

    case 'sector':
    case 'treemapSeriesName':
      anchor = 'center';
      break;

    case 'stackTotal':
      anchor = 'auto';
      break;
  }

  return anchor;
}

function getAnchor(dataLabelOptions, type) {
  var withStack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return type !== 'stackTotal' && includes(['center', 'start', 'end', 'auto', 'outer'], dataLabelOptions.anchor) ? dataLabelOptions.anchor : getDefaultAnchor(type, withStack);
}

function getDefaultDataLabelsOptions(dataLabelOptions, type) {
  var _pieSeriesName;

  var withStack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var anchor = getAnchor(dataLabelOptions, type, withStack);
  var _dataLabelOptions$off = dataLabelOptions.offsetX,
      offsetX = _dataLabelOptions$off === void 0 ? 0 : _dataLabelOptions$off,
      _dataLabelOptions$off2 = dataLabelOptions.offsetY,
      offsetY = _dataLabelOptions$off2 === void 0 ? 0 : _dataLabelOptions$off2;
  var formatter = isFunction(dataLabelOptions.formatter) ? dataLabelOptions.formatter : function (value) {
    return String(value) || '';
  };
  var options = {
    anchor: anchor,
    offsetX: offsetX,
    offsetY: offsetY,
    formatter: formatter
  };

  if (withStack) {
    var stackTotal = dataLabelOptions.stackTotal;
    options.stackTotal = {
      visible: isBoolean(stackTotal === null || stackTotal === void 0 ? void 0 : stackTotal.visible) ? stackTotal.visible : true,
      formatter: isFunction(stackTotal === null || stackTotal === void 0 ? void 0 : stackTotal.formatter) ? stackTotal.formatter : formatter
    };
  }

  if (type === 'sector' && (_pieSeriesName = dataLabelOptions.pieSeriesName) !== null && _pieSeriesName !== void 0 && _pieSeriesName.visible) {
    options.pieSeriesName = dataLabels_objectSpread(dataLabels_objectSpread({}, {
      anchor: 'center'
    }), dataLabelOptions.pieSeriesName);
  }

  return options;
}
function makePointLabelInfo(point, dataLabelOptions, rect) {
  var width = rect.width,
      height = rect.height;
  var anchor = dataLabelOptions.anchor,
      _dataLabelOptions$off3 = dataLabelOptions.offsetX,
      offsetX = _dataLabelOptions$off3 === void 0 ? 0 : _dataLabelOptions$off3,
      _dataLabelOptions$off4 = dataLabelOptions.offsetY,
      offsetY = _dataLabelOptions$off4 === void 0 ? 0 : _dataLabelOptions$off4,
      formatter = dataLabelOptions.formatter;
  var name = point.name,
      theme = point.theme;
  var textBaseline = 'middle';

  if (anchor === 'end') {
    textBaseline = 'bottom';
  } else if (anchor === 'start') {
    textBaseline = 'top';
  }

  var xWithOffset = point.x + offsetX;
  var yWithOffset = point.y + offsetY;
  var x = xWithOffset < 0 || xWithOffset > width ? point.x : xWithOffset;
  var y = yWithOffset < 0 || yWithOffset > height ? point.y : yWithOffset;
  return {
    type: 'point',
    x: x,
    y: y,
    text: formatter(point.value, point.data),
    textAlign: 'center',
    textBaseline: textBaseline,
    name: name,
    theme: theme
  };
}

function isHorizontal(direction) {
  return includes(['left', 'right'], direction);
}

function makeHorizontalRectPosition(rect, anchor) {
  var x = rect.x,
      y = rect.y,
      width = rect.width,
      height = rect.height,
      direction = rect.direction;
  var textBaseline = 'middle';
  var posY = y + height / 2;
  var textAlign = 'center';
  var posX;

  if (direction === 'right') {
    switch (anchor) {
      case 'start':
        textAlign = 'left';
        posX = x;
        break;

      case 'end':
        textAlign = 'right';
        posX = x + width;
        break;

      case 'center':
        textAlign = 'center';
        posX = x + width / 2;
        break;

      default:
        textAlign = 'left';
        posX = x + width;
    }
  } else {
    switch (anchor) {
      case 'start':
        textAlign = 'right';
        posX = x + width;
        break;

      case 'end':
        textAlign = 'left';
        posX = x;
        break;

      case 'center':
        textAlign = 'center';
        posX = x + width / 2;
        break;

      default:
        textAlign = 'right';
        posX = x;
    }
  }

  return {
    x: posX,
    y: posY,
    textAlign: textAlign,
    textBaseline: textBaseline
  };
}

function makeVerticalRectPosition(rect, anchor) {
  var x = rect.x,
      y = rect.y,
      width = rect.width,
      height = rect.height,
      direction = rect.direction;
  var textAlign = 'center';
  var posX = x + width / 2;
  var textBaseline = 'middle';
  var posY = 0;

  if (direction === 'top') {
    switch (anchor) {
      case 'end':
        textBaseline = 'top';
        posY = y;
        break;

      case 'start':
        textBaseline = 'bottom';
        posY = y + height;
        break;

      case 'center':
        textBaseline = 'middle';
        posY = y + height / 2;
        break;

      default:
        textBaseline = 'bottom';
        posY = y;
    }
  } else {
    switch (anchor) {
      case 'end':
        textBaseline = 'bottom';
        posY = y + height;
        break;

      case 'start':
        textBaseline = 'top';
        posY = y;
        break;

      case 'center':
        textBaseline = 'middle';
        posY = y + height / 2;
        break;

      default:
        textBaseline = 'top';
        posY = y + height;
        break;
    }
  }

  return {
    x: posX,
    y: posY,
    textAlign: textAlign,
    textBaseline: textBaseline
  };
}

function adjustOverflowHorizontalRect(rect, dataLabelOptions, position) {
  var width = rect.width,
      value = rect.value,
      direction = rect.direction,
      plot = rect.plot,
      theme = rect.theme;
  var formatter = dataLabelOptions.formatter;
  var font = getFont(theme);
  var text = utils_isString(value) ? value : formatter(value);
  var textWidth = getTextWidth(text, font);
  var x = position.x,
      textAlign = position.textAlign;
  var isOverflow = direction === 'left' && x - textWidth < 0 || x + textWidth > plot.size;

  if (isOverflow) {
    x = rect.x + width;
    textAlign = 'right';

    if (direction === 'left' && width >= textWidth) {
      x = rect.x;
      textAlign = 'left';
    }
  }

  return {
    x: x,
    textAlign: textAlign
  };
}

function adjustOverflowVerticalRect(rect, dataLabelOptions, position) {
  var height = rect.height,
      direction = rect.direction,
      plot = rect.plot,
      theme = rect.theme,
      value = rect.value;
  var font = getFont(theme);
  var plotSize = plot.size;
  var textHeight = getTextHeight("".concat(value), font); // @TODO: formatter  

  var y = position.y,
      textBaseline = position.textBaseline;
  var isOverflow = !(direction === 'bottom') && y - textHeight < 0 || y + textHeight > plotSize;

  if (isOverflow) {
    y = rect.y;
    textBaseline = 'top';

    if (y + textHeight > plotSize) {
      y = rect.y;
      textBaseline = 'bottom';
    }

    if (direction === 'bottom') {
      y = rect.y + height;
      textBaseline = 'bottom';
    }
  }

  return {
    y: y,
    textBaseline: textBaseline
  };
}

function makeHorizontalRectLabelInfo(rect, dataLabelOptions) {
  var anchor = dataLabelOptions.anchor,
      _dataLabelOptions$off5 = dataLabelOptions.offsetX,
      offsetX = _dataLabelOptions$off5 === void 0 ? 0 : _dataLabelOptions$off5,
      _dataLabelOptions$off6 = dataLabelOptions.offsetY,
      offsetY = _dataLabelOptions$off6 === void 0 ? 0 : _dataLabelOptions$off6;
  var direction = rect.direction,
      _rect$plot = rect.plot,
      _rect$plot$x = _rect$plot.x,
      startOffsetX = _rect$plot$x === void 0 ? 0 : _rect$plot$x,
      _rect$plot$y = _rect$plot.y,
      startOffsetY = _rect$plot$y === void 0 ? 0 : _rect$plot$y;
  var position = makeHorizontalRectPosition(rect, anchor);
  var posX = position.x,
      posY = position.y,
      textAlign = position.textAlign;

  if (anchor === 'auto') {
    var adjustRect = adjustOverflowHorizontalRect(rect, dataLabelOptions, {
      x: posX,
      textAlign: textAlign
    });
    posX = adjustRect.x;
    textAlign = adjustRect.textAlign;
  }

  posY += offsetY;

  if (direction === 'left') {
    posX = posX - offsetX;
  } else {
    posX = posX + offsetX;
  }

  var padding = 10;

  if (textAlign === 'right') {
    posX -= padding;
  } else if (textAlign === 'left') {
    posX += padding;
  }

  posX -= startOffsetX;
  posY -= startOffsetY;
  return {
    x: posX,
    y: posY,
    textAlign: textAlign,
    textBaseline: position.textBaseline
  };
}

function makeVerticalRectLabelInfo(rect, dataLabelOptions) {
  var anchor = dataLabelOptions.anchor,
      _dataLabelOptions$off7 = dataLabelOptions.offsetX,
      offsetX = _dataLabelOptions$off7 === void 0 ? 0 : _dataLabelOptions$off7,
      _dataLabelOptions$off8 = dataLabelOptions.offsetY,
      offsetY = _dataLabelOptions$off8 === void 0 ? 0 : _dataLabelOptions$off8;
  var direction = rect.direction,
      _rect$plot2 = rect.plot,
      _rect$plot2$x = _rect$plot2.x,
      startOffsetX = _rect$plot2$x === void 0 ? 0 : _rect$plot2$x,
      _rect$plot2$y = _rect$plot2.y,
      startOffsetY = _rect$plot2$y === void 0 ? 0 : _rect$plot2$y;
  var position = makeVerticalRectPosition(rect, anchor);
  var posX = position.x,
      posY = position.y,
      textBaseline = position.textBaseline;

  if (anchor === 'auto') {
    var adjustRect = adjustOverflowVerticalRect(rect, dataLabelOptions, position);
    posY = adjustRect.y;
    textBaseline = adjustRect.textBaseline;
  }

  posX += offsetX;

  if (direction === 'top') {
    posY = posY + offsetY;
  } else if (direction === 'bottom') {
    posY = posY - offsetY;
  }

  var padding = 5;

  if (textBaseline === 'bottom') {
    posY -= padding;
  } else if (textBaseline === 'top') {
    posY += padding;
  }

  posX -= startOffsetX;
  posY -= startOffsetY;
  return {
    x: posX,
    y: posY,
    textAlign: position.textAlign,
    textBaseline: textBaseline
  };
}

function makeRectLabelInfo(rect, dataLabelOptions) {
  var type = rect.type,
      value = rect.value,
      direction = rect.direction,
      name = rect.name,
      theme = rect.theme;
  var horizontal = isHorizontal(direction);
  var labelPosition = horizontal ? makeHorizontalRectLabelInfo(rect, dataLabelOptions) : makeVerticalRectLabelInfo(rect, dataLabelOptions);
  var formatter = type === 'stackTotal' ? dataLabelOptions.stackTotal.formatter : dataLabelOptions.formatter;
  return dataLabels_objectSpread(dataLabels_objectSpread({
    type: type
  }, labelPosition), {}, {
    text: utils_isString(value) ? value : formatter(value),
    name: name,
    seriesColor: rect.color,
    theme: theme
  });
}
function makeSectorLabelPosition(model, dataLabelOptions) {
  var anchor = dataLabelOptions.anchor;
  var position = getRadialAnchorPosition(makeAnchorPositionParam(anchor, dataLabels_objectSpread(dataLabels_objectSpread({}, model), {}, {
    radius: dataLabels_objectSpread(dataLabels_objectSpread({}, model.radius), {}, {
      outer: anchor === 'outer' ? model.radius.outer + RADIUS_PADDING : model.radius.outer
    })
  })));
  var textAlign = getRadialLabelAlign(model, anchor);
  return dataLabels_objectSpread(dataLabels_objectSpread({}, position), {}, {
    textAlign: textAlign,
    textBaseline: hasSameAnchorPieDataLabel(dataLabelOptions) ? 'bottom' : 'middle'
  });
}

function makeSectorBarLabelPosition(model, dataLabelOptions) {
  var anchor = dataLabelOptions.anchor;
  var clockwise = model.clockwise,
      _model$degree = model.degree,
      start = _model$degree.start,
      end = _model$degree.end,
      _model$radius = model.radius,
      inner = _model$radius.inner,
      outer = _model$radius.outer;
  var startAngle = start;
  var endAngle = end;
  var textAlign = 'center';
  var rotationDegree = (start + end) / 2;

  if (anchor === 'start') {
    textAlign = clockwise ? 'left' : 'right';
    endAngle = startAngle;
    rotationDegree = start;
  } else if (anchor === 'end') {
    textAlign = clockwise ? 'right' : 'left';
    startAngle = endAngle;
    rotationDegree = end;
  }

  var _getRadialAnchorPosit = getRadialAnchorPosition(makeAnchorPositionParam(anchor, dataLabels_objectSpread(dataLabels_objectSpread({}, model), {}, {
    degree: {
      start: startAngle,
      end: endAngle
    },
    radius: {
      inner: inner,
      outer: outer
    }
  }))),
      x = _getRadialAnchorPosit.x,
      y = _getRadialAnchorPosit.y;

  return {
    x: x,
    y: y,
    textAlign: textAlign,
    textBaseline: 'middle',
    radian: calculateDegreeToRadian(rotationDegree, 0)
  };
}

function makeSectorBarLabelInfo(model, dataLabelOptions) {
  var formatter = dataLabelOptions.formatter;
  var labelPosition = makeSectorBarLabelPosition(model, dataLabelOptions);
  var value = model.value,
      name = model.name,
      dataLabelTheme = model.theme;

  var theme = dataLabels_objectSpread(dataLabels_objectSpread({}, dataLabelTheme), {}, {
    color: dataLabelTheme.useSeriesColor ? model.color : dataLabelTheme.color
  });

  return dataLabels_objectSpread(dataLabels_objectSpread({
    type: 'sector'
  }, labelPosition), {}, {
    text: formatter(value),
    name: name,
    theme: theme
  });
}
function makeSectorLabelInfo(model, dataLabelOptions) {
  var formatter = dataLabelOptions.formatter;
  var labelPosition = makeSectorLabelPosition(model, dataLabelOptions);
  var value = model.value,
      name = model.name,
      dataLabelTheme = model.theme;
  var anchor = dataLabelOptions.anchor;

  var theme = dataLabels_objectSpread(dataLabels_objectSpread({}, dataLabelTheme), {}, {
    color: dataLabelTheme.useSeriesColor ? model.color : dataLabelTheme.color
  });

  return dataLabels_objectSpread(dataLabels_objectSpread({
    type: 'sector'
  }, labelPosition), {}, {
    text: formatter(value),
    name: name,
    callout: hasSectorCallout(dataLabelOptions) ? getPieDataLabelCallout(model, anchor) : null,
    theme: theme
  });
}
function makePieSeriesNameLabelInfo(model, dataLabelOptions) {
  var _dataLabelOptions$pie;

  var seriesNameAnchor = (_dataLabelOptions$pie = dataLabelOptions.pieSeriesName) === null || _dataLabelOptions$pie === void 0 ? void 0 : _dataLabelOptions$pie.anchor;
  var hasOuterAnchor = seriesNameAnchor === 'outer';
  var position = getRadialAnchorPosition(makeAnchorPositionParam(seriesNameAnchor, dataLabels_objectSpread(dataLabels_objectSpread({}, model), {}, {
    radius: dataLabels_objectSpread(dataLabels_objectSpread({}, model.radius), {}, {
      outer: hasOuterAnchor ? model.radius.outer + RADIUS_PADDING : model.radius.outer
    })
  })));
  var textAlign = getRadialLabelAlign(model, seriesNameAnchor);
  var pieSeriesNameTheme = model.theme.pieSeriesName;

  var theme = dataLabels_objectSpread(dataLabels_objectSpread({}, pieSeriesNameTheme), {}, {
    color: pieSeriesNameTheme.useSeriesColor ? model.color : pieSeriesNameTheme.color
  });

  return dataLabels_objectSpread(dataLabels_objectSpread({
    type: 'pieSeriesName'
  }, position), {}, {
    text: model.name,
    callout: hasPieSeriesNameCallout(dataLabelOptions) ? getPieDataLabelCallout(model, seriesNameAnchor) : null,
    textAlign: textAlign,
    textBaseline: hasSameAnchorPieDataLabel(dataLabelOptions) ? 'top' : 'middle',
    theme: theme
  });
}
function getDataLabelsOptions(options, name) {
  var _options$series, _options$series$name, _options$series2;

  return (options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : (_options$series$name = _options$series[name]) === null || _options$series$name === void 0 ? void 0 : _options$series$name.dataLabels) || (options === null || options === void 0 ? void 0 : (_options$series2 = options.series) === null || _options$series2 === void 0 ? void 0 : _options$series2.dataLabels) || {};
}
function makeLineLabelInfo(model, dataLabelOptions) {
  var value = model.value,
      textAlign = model.textAlign,
      textBaseline = model.textBaseline;
  var formatter = dataLabelOptions.formatter;
  return dataLabels_objectSpread(dataLabels_objectSpread({}, model), {}, {
    x: model.x,
    y: (model.y + model.y2) / 2,
    textAlign: textAlign !== null && textAlign !== void 0 ? textAlign : 'center',
    textBaseline: textBaseline !== null && textBaseline !== void 0 ? textBaseline : 'middle',
    text: utils_isString(value) ? value : formatter(value)
  });
}

function hasSameAnchorPieDataLabel(dataLabelOptions) {
  var _dataLabelOptions$pie2;

  return dataLabelOptions.anchor === ((_dataLabelOptions$pie2 = dataLabelOptions.pieSeriesName) === null || _dataLabelOptions$pie2 === void 0 ? void 0 : _dataLabelOptions$pie2.anchor);
}

function hasSectorCallout(dataLabelOptions) {
  var _dataLabelOptions$pie3;

  return dataLabelOptions.anchor === 'outer' || ((_dataLabelOptions$pie3 = dataLabelOptions.pieSeriesName) === null || _dataLabelOptions$pie3 === void 0 ? void 0 : _dataLabelOptions$pie3.anchor) !== 'outer';
}

function hasPieSeriesNameCallout(dataLabelOptions) {
  var _dataLabelOptions$pie4;

  return dataLabelOptions.anchor !== 'outer' || ((_dataLabelOptions$pie4 = dataLabelOptions.pieSeriesName) === null || _dataLabelOptions$pie4 === void 0 ? void 0 : _dataLabelOptions$pie4.anchor) === 'outer';
}

function getPieDataLabelCallout(model, anchor) {
  if (anchor !== 'outer') {
    return null;
  }

  var _getRadialAnchorPosit2 = getRadialAnchorPosition(makeAnchorPositionParam('outer', dataLabels_objectSpread(dataLabels_objectSpread({}, model), {}, {
    radius: dataLabels_objectSpread(dataLabels_objectSpread({}, model.radius), {}, {
      outer: model.radius.outer + CALLOUT_LENGTH
    })
  }))),
      x = _getRadialAnchorPosit2.x,
      y = _getRadialAnchorPosit2.y;

  var _getRadialAnchorPosit3 = getRadialAnchorPosition(makeAnchorPositionParam('outer', dataLabels_objectSpread({}, model))),
      x2 = _getRadialAnchorPosit3.x,
      y2 = _getRadialAnchorPosit3.y;

  var callout = model.theme.callout;

  var theme = dataLabels_objectSpread(dataLabels_objectSpread({}, callout), {}, {
    lineColor: callout.useSeriesColor ? model.color : callout.lineColor
  });

  return {
    x: x,
    y: y,
    x2: x2,
    y2: y2,
    theme: theme
  };
}
;// CONCATENATED MODULE: ./src/component/lineSeries.ts
function lineSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { lineSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { lineSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return lineSeries_typeof(obj); }

function lineSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function lineSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { lineSeries_ownKeys(Object(source), true).forEach(function (key) { lineSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { lineSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
























function lineSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function lineSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function lineSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) lineSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) lineSeries_defineProperties(Constructor, staticProps); return Constructor; }

function lineSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) lineSeries_setPrototypeOf(subClass, superClass); }

function lineSeries_setPrototypeOf(o, p) { lineSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return lineSeries_setPrototypeOf(o, p); }

function lineSeries_createSuper(Derived) { var hasNativeReflectConstruct = lineSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = lineSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = lineSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return lineSeries_possibleConstructorReturn(this, result); }; }

function lineSeries_possibleConstructorReturn(self, call) { if (call && (lineSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return lineSeries_assertThisInitialized(self); }

function lineSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function lineSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function lineSeries_getPrototypeOf(o) { lineSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return lineSeries_getPrototypeOf(o); }

function lineSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }













var LineSeries = /*#__PURE__*/function (_Component) {
  lineSeries_inherits(LineSeries, _Component);

  var _super = lineSeries_createSuper(LineSeries);

  function LineSeries() {
    var _this;

    lineSeries_classCallCheck(this, LineSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "models", {
      rect: [],
      series: [],
      dot: []
    });

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "drawModels", void 0);

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "responders", void 0);

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "theme", void 0);

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "activatedResponders", []);

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "eventDetectType", 'nearest');

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "tooltipCircleMap", void 0);

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "startIndex", void 0);

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "yAxisName", 'yAxis');

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.eventBus.emit('needDraw');
    });

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "selectSeries", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex;

      if (!isAvailableSelectSeries(info, 'line')) {
        return;
      }

      var category = _this.getResponderCategoryByIndex(index);

      if (!category) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      var model = _this.tooltipCircleMap[category][seriesIndex];

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      var models = _this.getResponderSeriesWithTheme([model], 'select');

      _this.eventBus.emit('renderSelectedSeries', {
        models: models,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    lineSeries_defineProperty(lineSeries_assertThisInitialized(_this), "showTooltip", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex;

      if (!isAvailableShowTooltipInfo(info, _this.eventDetectType, 'line')) {
        return;
      }

      var category = _this.getResponderCategoryByIndex(index);

      if (!category) {
        return;
      }

      var models = _this.eventDetectType === 'grouped' ? _this.tooltipCircleMap[category] : [_this.tooltipCircleMap[category][seriesIndex]];

      if (!(models !== null && models !== void 0 && models.length)) {
        return;
      }

      _this.onMousemoveNearType(models);

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  lineSeries_createClass(LineSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'line';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      this.drawModels.rect[0].width = this.models.rect[0].width * delta;
    }
  }, {
    key: "setEventDetectType",
    value: function setEventDetectType(series, options) {
      var _options$series;

      if (series.area || series.column) {
        this.eventDetectType = 'grouped';
      }

      if (options !== null && options !== void 0 && (_options$series = options.series) !== null && _options$series !== void 0 && _options$series.eventDetectType) {
        this.eventDetectType = options.series.eventDetectType;
      }

      if (series.scatter) {
        this.eventDetectType = 'near';
      }
    }
  }, {
    key: "render",
    value: function render(chartState, computed) {
      var _ref, _ref2, _options$series2, _viewRange$;

      var viewRange = computed.viewRange;
      var layout = chartState.layout,
          series = chartState.series,
          scale = chartState.scale,
          axes = chartState.axes,
          legend = chartState.legend,
          theme = chartState.theme;

      if (!series.line) {
        throw new Error(message.noDataError(this.name));
      }

      var categories = (_ref = chartState.categories) !== null && _ref !== void 0 ? _ref : [];
      var rawCategories = (_ref2 = chartState.rawCategories) !== null && _ref2 !== void 0 ? _ref2 : [];

      var options = lineSeries_objectSpread({}, chartState.options);

      if (options !== null && options !== void 0 && options.series && 'line' in options.series) {
        options.series = lineSeries_objectSpread(lineSeries_objectSpread({}, options.series), options.series.line);
      }

      this.setEventDetectType(series, options);
      var labelAxisData = axes.xAxis;
      var seriesOptions = (_options$series2 = options.series) !== null && _options$series2 !== void 0 ? _options$series2 : {};
      var lineSeriesData = series.line.data;
      this.theme = theme.series.line;
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.startIndex = (_viewRange$ = viewRange === null || viewRange === void 0 ? void 0 : viewRange[0]) !== null && _viewRange$ !== void 0 ? _viewRange$ : 0;
      this.selectable = this.getSelectableOption(options);
      this.yAxisName = getValueAxisName(options, this.name, 'yAxis');
      var lineSeriesModel = this.renderLinePointsModel(lineSeriesData, scale, labelAxisData, seriesOptions, categories);

      var _this$renderCircleMod = this.renderCircleModel(lineSeriesModel, seriesOptions),
          dotSeriesModel = _this$renderCircleMod.dotSeriesModel,
          responderModel = _this$renderCircleMod.responderModel;

      var tooltipDataArr = this.makeTooltipData(lineSeriesData, categories);
      this.tooltipCircleMap = makeTooltipCircleMap(responderModel, tooltipDataArr);
      this.models = {
        rect: [this.renderClipRectAreaModel()],
        series: lineSeriesModel,
        dot: dotSeriesModel
      };

      if (!this.drawModels) {
        this.drawModels = lineSeries_objectSpread(lineSeries_objectSpread({}, this.models), {}, {
          rect: [this.renderClipRectAreaModel(true)]
        });
      }

      if (getDataLabelsOptions(options, this.name).visible) {
        this.renderDataLabels(this.getDataLabels(lineSeriesModel));
      }

      var coordinateType = isCoordinateSeries(series);
      this.responders = this.getResponders({
        labelAxisData: labelAxisData,
        responderModel: responderModel,
        tooltipDataArr: tooltipDataArr,
        categories: categories,
        rawCategories: rawCategories,
        coordinateType: coordinateType
      });
    }
  }, {
    key: "getResponders",
    value: function getResponders(_ref3) {
      var labelAxisData = _ref3.labelAxisData,
          responderModel = _ref3.responderModel,
          tooltipDataArr = _ref3.tooltipDataArr,
          categories = _ref3.categories,
          rawCategories = _ref3.rawCategories,
          coordinateType = _ref3.coordinateType;

      if (this.eventDetectType === 'near') {
        return this.makeNearTypeResponderModel(responderModel, tooltipDataArr, rawCategories);
      }

      if (this.eventDetectType === 'point') {
        return this.makeNearTypeResponderModel(responderModel, tooltipDataArr, rawCategories, 0);
      }

      if (coordinateType) {
        var rectResponderInfo = this.getRectResponderInfoForCoordinateType(responderModel, rawCategories);
        return responders_makeRectResponderModelForCoordinateType(rectResponderInfo, this.rect);
      }

      return makeRectResponderModel(this.rect, labelAxisData, categories);
    }
  }, {
    key: "makeNearTypeResponderModel",
    value: function makeNearTypeResponderModel(seriesCircleModel, tooltipDataArr, categories, detectionSize) {
      return seriesCircleModel.map(function (m, index) {
        return lineSeries_objectSpread(lineSeries_objectSpread({}, m), {}, {
          data: tooltipDataArr[index],
          detectionSize: detectionSize,
          label: categories[m.index]
        });
      });
    }
  }, {
    key: "makeTooltipData",
    value: function makeTooltipData(lineSeriesData, categories) {
      var _this2 = this;

      return lineSeriesData.flatMap(function (_ref4, seriesIndex) {
        var rawData = _ref4.rawData,
            name = _ref4.name,
            color = _ref4.color;
        return rawData.map(function (datum, index) {
          return isNull(datum) ? {} : {
            label: name,
            color: color,
            value: getCoordinateYValue(datum),
            category: categories[getCoordinateDataIndex(datum, categories, index, _this2.startIndex)],
            seriesIndex: seriesIndex,
            index: index
          };
        });
      });
    }
  }, {
    key: "renderClipRectAreaModel",
    value: function renderClipRectAreaModel(isDrawModel) {
      return {
        type: 'clipRectArea',
        x: 0,
        y: 0,
        width: isDrawModel ? 0 : this.rect.width,
        height: this.rect.height
      };
    }
  }, {
    key: "renderLinePointsModel",
    value: function renderLinePointsModel(seriesRawData, scale, axisData, options, categories) {
      var _this3 = this;

      var spline = options.spline;
      var yAxisLimit = scale[this.yAxisName].limit;
      var _this$theme = this.theme,
          lineWidth = _this$theme.lineWidth,
          dashSegments = _this$theme.dashSegments;
      return seriesRawData.map(function (_ref5, seriesIndex) {
        var rawData = _ref5.rawData,
            name = _ref5.name,
            seriesColor = _ref5.color;
        var points = [];
        var active = _this3.activeSeriesMap[name];
        rawData.forEach(function (datum, idx) {
          if (isNull(datum)) {
            return points.push(null);
          }

          var value = getCoordinateYValue(datum);
          var yValueRatio = getValueRatio(value, yAxisLimit);
          var y = (1 - yValueRatio) * _this3.rect.height;
          var x = getXPosition(axisData, _this3.rect.width, getCoordinateXValue(datum), getCoordinateDataIndex(datum, categories, idx, _this3.startIndex));
          points.push({
            x: x,
            y: y,
            value: value
          });
        });

        if (spline) {
          setSplineControlPoint(points);
        }

        return {
          type: 'linePoints',
          points: points,
          seriesIndex: seriesIndex,
          name: name,
          color: getRGBA(seriesColor, active ? 1 : 0.3),
          lineWidth: lineWidth,
          dashSegments: dashSegments
        };
      });
    }
  }, {
    key: "getRectResponderInfoForCoordinateType",
    value: function getRectResponderInfoForCoordinateType(circleModel, categories) {
      var _this4 = this;

      var duplicateCheckMap = {};
      var modelInRange = circleModel.filter(function (_ref6) {
        var x = _ref6.x;
        return x >= 0 && x <= _this4.rect.width;
      });
      return modelInRange.reduce(function (acc, model) {
        var index = model.index,
            x = model.x;

        if (!duplicateCheckMap[x]) {
          var label = categories[index];
          duplicateCheckMap[x] = true;
          acc.push({
            x: x,
            label: label
          });
        }

        return acc;
      }, []);
    }
  }, {
    key: "renderCircleModel",
    value: function renderCircleModel(lineSeriesModel, options) {
      var _this5 = this;

      var dotSeriesModel = [];
      var responderModel = [];
      var showDot = !!options.showDot;
      var _this$theme2 = this.theme,
          hover = _this$theme2.hover,
          dotTheme = _this$theme2.dot;
      var hoverDotTheme = hover.dot;
      lineSeriesModel.forEach(function (_ref7, seriesIndex) {
        var color = _ref7.color,
            name = _ref7.name,
            points = _ref7.points;
        var active = _this5.activeSeriesMap[name];
        points.forEach(function (point, index) {
          var _hoverDotTheme$color;

          if (isNull(point)) {
            return;
          }

          var x = point.x,
              y = point.y;
          var model = {
            type: 'circle',
            x: x,
            y: y,
            seriesIndex: seriesIndex,
            name: name,
            index: index
          };

          if (showDot) {
            var _dotTheme$borderColor;

            dotSeriesModel.push(lineSeries_objectSpread(lineSeries_objectSpread({}, model), {}, {
              radius: dotTheme.radius,
              color: getRGBA(color, active ? 1 : 0.3),
              style: [{
                lineWidth: dotTheme.borderWidth,
                strokeStyle: (_dotTheme$borderColor = dotTheme.borderColor) !== null && _dotTheme$borderColor !== void 0 ? _dotTheme$borderColor : color
              }]
            }));
          }

          responderModel.push(lineSeries_objectSpread(lineSeries_objectSpread({}, model), {}, {
            radius: hoverDotTheme.radius,
            color: (_hoverDotTheme$color = hoverDotTheme.color) !== null && _hoverDotTheme$color !== void 0 ? _hoverDotTheme$color : getRGBA(color, 1),
            style: ['default']
          }));
        });
      });
      return {
        dotSeriesModel: dotSeriesModel,
        responderModel: responderModel
      };
    }
  }, {
    key: "getCircleModelsFromRectResponders",
    value: function getCircleModelsFromRectResponders(responders, mousePositions) {
      var _this$tooltipCircleMa, _responders$;

      if (!responders.length || !responders[0].label) {
        return [];
      }

      var models = (_this$tooltipCircleMa = this.tooltipCircleMap[(_responders$ = responders[0]) === null || _responders$ === void 0 ? void 0 : _responders$.label]) !== null && _this$tooltipCircleMa !== void 0 ? _this$tooltipCircleMa : [];
      return this.eventDetectType === 'grouped' ? models : getNearestResponder(models, mousePositions, this.rect);
    }
  }, {
    key: "onMousemoveNearType",
    value: function onMousemoveNearType(responders) {
      this.eventBus.emit('renderHoveredSeries', {
        models: this.getResponderSeriesWithTheme(responders, 'hover'),
        name: this.name,
        eventDetectType: this.eventDetectType
      });
      this.activatedResponders = responders;
    }
  }, {
    key: "onMousemoveNearestType",
    value: function onMousemoveNearestType(responders, mousePositions) {
      var circleModels = this.getCircleModelsFromRectResponders(responders, mousePositions);
      this.onMousemoveNearType(circleModels);
    }
  }, {
    key: "onMousemoveGroupedType",
    value: function onMousemoveGroupedType(responders) {
      var circleModels = this.getCircleModelsFromRectResponders(responders);
      this.onMousemoveNearType(circleModels);
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref8) {
      var responders = _ref8.responders,
          mousePosition = _ref8.mousePosition;

      if (this.eventDetectType === 'nearest') {
        this.onMousemoveNearestType(responders, mousePosition);
      } else if (includes(['near', 'point'], this.eventDetectType)) {
        this.onMousemoveNearType(responders);
      } else {
        this.onMousemoveGroupedType(responders);
      }

      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "getDataLabels",
    value: function getDataLabels(seriesModels) {
      var dataLabelTheme = this.theme.dataLabels;
      return seriesModels.flatMap(function (_ref9) {
        var points = _ref9.points,
            name = _ref9.name,
            color = _ref9.color;
        return points.map(function (point) {
          return isNull(point) ? {} : lineSeries_objectSpread(lineSeries_objectSpread({
            type: 'point'
          }, point), {}, {
            name: name,
            theme: lineSeries_objectSpread(lineSeries_objectSpread({}, dataLabelTheme), {}, {
              color: dataLabelTheme.useSeriesColor ? color : dataLabelTheme.color
            })
          });
        });
      });
    }
  }, {
    key: "getResponderSeriesWithTheme",
    value: function getResponderSeriesWithTheme(models, type) {
      var _ref10 = this.theme[type].dot,
          radius = _ref10.radius,
          color = _ref10.color,
          borderWidth = _ref10.borderWidth,
          borderColor = _ref10.borderColor;
      return models.map(function (model) {
        var modelColor = color !== null && color !== void 0 ? color : model.color;
        return lineSeries_objectSpread(lineSeries_objectSpread({}, model), {}, {
          radius: radius,
          color: modelColor,
          style: [{
            lineWidth: borderWidth,
            strokeStyle: borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(modelColor, 0.5)
          }]
        });
      });
    }
  }, {
    key: "onClick",
    value: function onClick(_ref11) {
      var responders = _ref11.responders,
          mousePosition = _ref11.mousePosition;

      if (this.selectable) {
        var models;

        if (this.eventDetectType === 'near') {
          models = responders;
        } else {
          models = this.getCircleModelsFromRectResponders(responders, mousePosition);
        }

        this.eventBus.emit('renderSelectedSeries', {
          models: this.getResponderSeriesWithTheme(models, 'select'),
          name: this.name
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "getResponderCategoryByIndex",
    value: function getResponderCategoryByIndex(index) {
      var _responder$data;

      var responder = Object.values(this.tooltipCircleMap).flatMap(function (val) {
        return val;
      }).find(function (model) {
        return model.index === index;
      });
      return responder === null || responder === void 0 ? void 0 : (_responder$data = responder.data) === null || _responder$data === void 0 ? void 0 : _responder$data.category;
    }
  }]);

  return LineSeries;
}(Component);


;// CONCATENATED MODULE: ./src/component/legend.ts
function legend_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { legend_typeof = function _typeof(obj) { return typeof obj; }; } else { legend_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return legend_typeof(obj); }

function component_legend_toConsumableArray(arr) { return component_legend_arrayWithoutHoles(arr) || component_legend_iterableToArray(arr) || component_legend_unsupportedIterableToArray(arr) || component_legend_nonIterableSpread(); }

function component_legend_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function component_legend_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return component_legend_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return component_legend_arrayLikeToArray(o, minLen); }

function component_legend_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function component_legend_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return component_legend_arrayLikeToArray(arr); }

function component_legend_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function component_legend_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function component_legend_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { component_legend_ownKeys(Object(source), true).forEach(function (key) { component_legend_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { component_legend_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }






















function legend_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function legend_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function legend_createClass(Constructor, protoProps, staticProps) { if (protoProps) legend_defineProperties(Constructor.prototype, protoProps); if (staticProps) legend_defineProperties(Constructor, staticProps); return Constructor; }

function legend_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) legend_setPrototypeOf(subClass, superClass); }

function legend_setPrototypeOf(o, p) { legend_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return legend_setPrototypeOf(o, p); }

function legend_createSuper(Derived) { var hasNativeReflectConstruct = legend_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = legend_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = legend_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return legend_possibleConstructorReturn(this, result); }; }

function legend_possibleConstructorReturn(self, call) { if (call && (legend_typeof(call) === "object" || typeof call === "function")) { return call; } return legend_assertThisInitialized(self); }

function legend_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function legend_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function legend_getPrototypeOf(o) { legend_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return legend_getPrototypeOf(o); }

function component_legend_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









var Legend = /*#__PURE__*/function (_Component) {
  legend_inherits(Legend, _Component);

  var _super = legend_createSuper(Legend);

  function Legend() {
    var _this;

    legend_classCallCheck(this, Legend);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    component_legend_defineProperty(legend_assertThisInitialized(_this), "models", void 0);

    component_legend_defineProperty(legend_assertThisInitialized(_this), "responders", void 0);

    component_legend_defineProperty(legend_assertThisInitialized(_this), "theme", void 0);

    component_legend_defineProperty(legend_assertThisInitialized(_this), "activatedResponders", []);

    component_legend_defineProperty(legend_assertThisInitialized(_this), "seriesColorMap", {});

    component_legend_defineProperty(legend_assertThisInitialized(_this), "seriesIconTypeMap", {});

    component_legend_defineProperty(legend_assertThisInitialized(_this), "onClickCheckbox", function (responders) {
      var _responders$ = responders[0],
          label = _responders$.label,
          checked = _responders$.checked;

      _this.store.dispatch('setAllLegendActiveState', true);

      _this.store.dispatch('setLegendCheckedState', {
        name: label,
        checked: !checked
      });

      if (checked) {
        _this.store.dispatch('disableSeries', label);
      } else {
        _this.store.dispatch('enableSeries', label);
      }

      _this.eventBus.emit('needDraw');
    });

    component_legend_defineProperty(legend_assertThisInitialized(_this), "onClickLabel", function (responders) {
      var label = responders[0].label;

      _this.eventBus.emit('resetSelectedSeries');

      if (_this.activatedResponders.length && _this.activatedResponders[0].label === label) {
        _this.store.dispatch('setAllLegendActiveState', true);

        _this.activatedResponders = [];
      } else {
        _this.store.dispatch('setAllLegendActiveState', false);

        _this.store.dispatch('setLegendActiveState', {
          name: label,
          active: true
        });

        _this.activatedResponders = responders;
      }

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  legend_createClass(Legend, [{
    key: "onClick",
    value: function onClick(_ref) {
      var responders = _ref.responders;

      if (responders.length) {
        var data = responders[0].data;

        if ((data === null || data === void 0 ? void 0 : data.name) === 'checkbox') {
          this.eventBus.emit('clickLegendCheckbox', makeObservableObjectToNormal(responders));
        } else {
          this.eventBus.emit('clickLegendLabel', makeObservableObjectToNormal(responders));
        }
      }
    }
  }, {
    key: "initialize",
    value: function initialize() {
      this.type = 'legend';
      this.name = 'legend';
      this.eventBus.on('clickLegendCheckbox', this.onClickCheckbox);
      this.eventBus.on('clickLegendLabel', this.onClickLabel);
    }
  }, {
    key: "initColorAndIconTypeMap",
    value: function initColorAndIconTypeMap(legendData) {
      var _this2 = this;

      this.seriesColorMap = {};
      this.seriesIconTypeMap = {};
      legendData.forEach(function (_ref2) {
        var label = _ref2.label,
            color = _ref2.color,
            iconType = _ref2.iconType;
        _this2.seriesColorMap[label] = color;
        _this2.seriesIconTypeMap[label] = iconType;
      });
    }
  }, {
    key: "getXPositionWhenVerticalAlign",
    value: function getXPositionWhenVerticalAlign(data) {
      var _data$reduce = data.reduce(function (acc, datum) {
        var rowIndex = datum.rowIndex,
            columnIndex = datum.columnIndex,
            width = datum.width;

        if (isUndefined(acc.rowWidths[rowIndex])) {
          acc.rowWidths[rowIndex] = 0;
          acc.offset[rowIndex] = [0];
        }

        acc.rowWidths[rowIndex] += width + (columnIndex ? LEGEND_ITEM_MARGIN_X : 0);
        acc.offset[rowIndex][columnIndex + 1] = acc.offset[rowIndex][columnIndex] + LEGEND_ITEM_MARGIN_X + width;
        return acc;
      }, {
        offset: [],
        rowWidths: []
      }),
          offset = _data$reduce.offset,
          rowWidths = _data$reduce.rowWidths;

      var width = this.rect.width;
      rowWidths.forEach(function (rowWidth, rowIndex) {
        var xMargin = (width - rowWidth) / 2;
        offset[rowIndex] = offset[rowIndex].map(function (xOffset) {
          return xOffset + xMargin;
        });
      });
      return offset;
    }
  }, {
    key: "getXPositionWhenHorizontalAlign",
    value: function getXPositionWhenHorizontalAlign(data) {
      var maxWidths = data.reduce(function (acc, datum) {
        var columnIndex = datum.columnIndex,
            width = datum.width;

        if (isUndefined(acc[columnIndex])) {
          acc[columnIndex] = 0;
        }

        acc[columnIndex] = Math.max(acc[columnIndex], width);
        return acc;
      }, []);
      return data.reduce(function (acc, datum) {
        var rowIndex = datum.rowIndex,
            columnIndex = datum.columnIndex;

        if (isUndefined(acc[rowIndex])) {
          acc[rowIndex] = [0];
        }

        acc[rowIndex][columnIndex + 1] = acc[rowIndex][columnIndex] + LEGEND_ITEM_MARGIN_X + maxWidths[columnIndex];
        return acc;
      }, []);
    }
  }, {
    key: "renderLegendModel",
    value: function renderLegendModel(legend) {
      var _this3 = this;

      var data = legend.data,
          showCheckbox = legend.showCheckbox,
          align = legend.align,
          useScatterChartIcon = legend.useScatterChartIcon;
      var verticalAlign = isVerticalAlign(align);
      var itemHeight = getLegendItemHeight(this.theme.label.fontSize);
      var xPosition = verticalAlign ? this.getXPositionWhenVerticalAlign(data) : this.getXPositionWhenHorizontalAlign(data);
      return [component_legend_objectSpread({
        type: 'legend',
        align: align,
        showCheckbox: showCheckbox,
        data: data.map(function (datum) {
          var _this3$seriesIconType;

          var label = datum.label,
              iconType = datum.iconType,
              rowIndex = datum.rowIndex,
              columnIndex = datum.columnIndex;
          return component_legend_objectSpread(component_legend_objectSpread({}, datum), {}, {
            iconType: (_this3$seriesIconType = _this3.seriesIconTypeMap[label]) !== null && _this3$seriesIconType !== void 0 ? _this3$seriesIconType : iconType,
            color: _this3.seriesColorMap[label],
            x: xPosition[rowIndex][columnIndex],
            y: padding.Y + itemHeight * rowIndex,
            useScatterChartIcon: useScatterChartIcon
          });
        })
      }, this.theme.label)];
    }
  }, {
    key: "makeCheckboxResponder",
    value: function makeCheckboxResponder(data, showCheckbox) {
      return showCheckbox ? data.map(function (m) {
        return component_legend_objectSpread(component_legend_objectSpread({}, m), {}, {
          type: 'rect',
          x: m.x,
          y: m.y,
          width: LEGEND_CHECKBOX_SIZE,
          height: LEGEND_CHECKBOX_SIZE,
          data: {
            name: 'checkbox'
          }
        });
      }) : [];
    }
  }, {
    key: "makeLabelResponder",
    value: function makeLabelResponder(data, showCheckbox) {
      var font = getTitleFontString(this.theme.label);
      return data.map(function (m) {
        return component_legend_objectSpread(component_legend_objectSpread({}, m), {}, {
          type: 'rect',
          x: m.x + (showCheckbox ? LEGEND_CHECKBOX_SIZE + LEGEND_MARGIN_X : 0) + LEGEND_ICON_SIZE + LEGEND_MARGIN_X,
          y: m.y,
          width: getTextWidth(m.label, font),
          data: {
            name: 'label'
          },
          height: LEGEND_CHECKBOX_SIZE
        });
      });
    }
  }, {
    key: "render",
    value: function render(_ref3) {
      var layout = _ref3.layout,
          legend = _ref3.legend,
          theme = _ref3.theme;
      this.isShow = legend.visible && !!legend.data.length;

      if (!this.isShow) {
        return;
      } // @TODO: stack     (  ) 


      var showCheckbox = legend.showCheckbox,
          legendData = legend.data;
      this.rect = layout.legend;
      this.theme = theme.legend;
      this.initColorAndIconTypeMap(legendData);
      this.models = this.renderLegendModel(legend);
      var data = this.models[0].data;
      var checkboxResponder = this.makeCheckboxResponder(data, showCheckbox);
      var labelResponder = this.makeLabelResponder(data, showCheckbox);
      this.responders = [].concat(component_legend_toConsumableArray(checkboxResponder), component_legend_toConsumableArray(labelResponder));
    }
  }]);

  return Legend;
}(Component);


;// CONCATENATED MODULE: ./src/component/dataLabels.ts
function dataLabels_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { dataLabels_typeof = function _typeof(obj) { return typeof obj; }; } else { dataLabels_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return dataLabels_typeof(obj); }

function component_dataLabels_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function component_dataLabels_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { component_dataLabels_ownKeys(Object(source), true).forEach(function (key) { component_dataLabels_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { component_dataLabels_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function dataLabels_toConsumableArray(arr) { return dataLabels_arrayWithoutHoles(arr) || dataLabels_iterableToArray(arr) || dataLabels_unsupportedIterableToArray(arr) || dataLabels_nonIterableSpread(); }

function dataLabels_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function dataLabels_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return dataLabels_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return dataLabels_arrayLikeToArray(o, minLen); }

function dataLabels_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function dataLabels_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return dataLabels_arrayLikeToArray(arr); }

function dataLabels_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }























function dataLabels_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function dataLabels_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function dataLabels_createClass(Constructor, protoProps, staticProps) { if (protoProps) dataLabels_defineProperties(Constructor.prototype, protoProps); if (staticProps) dataLabels_defineProperties(Constructor, staticProps); return Constructor; }

function dataLabels_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) dataLabels_setPrototypeOf(subClass, superClass); }

function dataLabels_setPrototypeOf(o, p) { dataLabels_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return dataLabels_setPrototypeOf(o, p); }

function dataLabels_createSuper(Derived) { var hasNativeReflectConstruct = dataLabels_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = dataLabels_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = dataLabels_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return dataLabels_possibleConstructorReturn(this, result); }; }

function dataLabels_possibleConstructorReturn(self, call) { if (call && (dataLabels_typeof(call) === "object" || typeof call === "function")) { return call; } return dataLabels_assertThisInitialized(self); }

function dataLabels_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function dataLabels_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function dataLabels_getPrototypeOf(o) { dataLabels_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return dataLabels_getPrototypeOf(o); }

function component_dataLabels_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







function getLabelInfo(model, labelOptions, rect, name) {
  var type = model.type;
  var dataLabel = [];

  if (type === 'point') {
    dataLabel.push(makePointLabelInfo(model, labelOptions, rect));
  } else if (type === 'sector') {
    if (name === 'radialBar') {
      dataLabel.push(makeSectorBarLabelInfo(model, labelOptions));
    } else {
      var _labelOptions$pieSeri;

      dataLabel.push(makeSectorLabelInfo(model, labelOptions));

      if ((_labelOptions$pieSeri = labelOptions.pieSeriesName) !== null && _labelOptions$pieSeri !== void 0 && _labelOptions$pieSeri.visible) {
        var seriesNameLabel = makePieSeriesNameLabelInfo(model, labelOptions);
        dataLabel.push(seriesNameLabel);
      }
    }
  } else if (type === 'line') {
    dataLabel.push(makeLineLabelInfo(model, labelOptions));
  } else {
    dataLabel.push(makeRectLabelInfo(model, labelOptions));
  }

  return dataLabel;
}

var DataLabels = /*#__PURE__*/function (_Component) {
  dataLabels_inherits(DataLabels, _Component);

  var _super = dataLabels_createSuper(DataLabels);

  function DataLabels() {
    var _this;

    dataLabels_classCallCheck(this, DataLabels);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    component_dataLabels_defineProperty(dataLabels_assertThisInitialized(_this), "models", void 0);

    component_dataLabels_defineProperty(dataLabels_assertThisInitialized(_this), "drawModels", void 0);

    component_dataLabels_defineProperty(dataLabels_assertThisInitialized(_this), "options", void 0);

    component_dataLabels_defineProperty(dataLabels_assertThisInitialized(_this), "dataLabelsMap", {});

    component_dataLabels_defineProperty(dataLabels_assertThisInitialized(_this), "renderSeriesDataLabels", function (seriesDataLabel) {
      _this.appendDataLabels(seriesDataLabel);

      _this.models = _this.renderLabelModel();

      if (!_this.drawModels) {
        _this.drawModels = _this.getDrawModelsAppliedOpacity(0);
      } else {
        _this.sync();
      }
    });

    return _this;
  }

  dataLabels_createClass(DataLabels, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'dataLabels';
      this.name = 'dataLabels';
      this.eventBus.on('renderDataLabels', this.renderSeriesDataLabels);
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      if (!this.drawModels) {
        return;
      }

      this.drawModels = this.getDrawModelsAppliedOpacity(delta);
    }
  }, {
    key: "render",
    value: function render(_ref) {
      var layout = _ref.layout,
          options = _ref.options,
          series = _ref.series,
          nestedPieSeries = _ref.nestedPieSeries;
      this.rect = layout.plot;
      this.options = options;
      this.isShow = this.visibleDataLabels(series, nestedPieSeries);
    }
  }, {
    key: "visibleDataLabels",
    value: function visibleDataLabels(series, nestedPieSeries) {
      var _this$options$series,
          _this$options$series$,
          _this2 = this;

      var visibleCommonSeriesDataLabels = !!((_this$options$series = this.options.series) !== null && _this$options$series !== void 0 && (_this$options$series$ = _this$options$series.dataLabels) !== null && _this$options$series$ !== void 0 && _this$options$series$.visible);
      var visibleComboSeriesDataLabels = Object.keys(series).some(function (seriesName) {
        var _this2$options$series, _this2$options$series2, _this2$options$series3;

        return !!((_this2$options$series = _this2.options.series) !== null && _this2$options$series !== void 0 && (_this2$options$series2 = _this2$options$series[seriesName]) !== null && _this2$options$series2 !== void 0 && (_this2$options$series3 = _this2$options$series2.dataLabels) !== null && _this2$options$series3 !== void 0 && _this2$options$series3.visible);
      });
      var visibleNestedPieSeriesDataLabels = !!(nestedPieSeries && Object.keys(nestedPieSeries).some(function (alias) {
        var _this2$options$series4, _this2$options$series5, _this2$options$series6;

        return !!((_this2$options$series4 = _this2.options.series) !== null && _this2$options$series4 !== void 0 && (_this2$options$series5 = _this2$options$series4[alias]) !== null && _this2$options$series5 !== void 0 && (_this2$options$series6 = _this2$options$series5.dataLabels) !== null && _this2$options$series6 !== void 0 && _this2$options$series6.visible);
      }));
      return visibleCommonSeriesDataLabels || visibleComboSeriesDataLabels || visibleNestedPieSeriesDataLabels;
    }
  }, {
    key: "appendDataLabels",
    value: function appendDataLabels(_ref2) {
      var _this3 = this;

      var name = _ref2.name,
          data = _ref2.data;
      var dataLabelOptions = getDataLabelsOptions(this.options, name);
      var withStack = !!pickStackOption(this.options);
      var labels = [];
      data.forEach(function (model) {
        var _labelOptions$stackTo;

        var type = model.type,
            value = model.value;
        var labelOptions = getDefaultDataLabelsOptions(dataLabelOptions, type, withStack);
        var disableStackTotal = type === 'stackTotal' && !((_labelOptions$stackTo = labelOptions.stackTotal) !== null && _labelOptions$stackTo !== void 0 && _labelOptions$stackTo.visible);

        if (disableStackTotal || isUndefined(value)) {
          return;
        }

        labels.splice.apply(labels, [labels.length, 0].concat(dataLabels_toConsumableArray(getLabelInfo(model, labelOptions, _this3.rect, name))));
      });
      this.dataLabelsMap[name] = {
        data: labels,
        options: dataLabelOptions
      };
    }
  }, {
    key: "getDrawModelsAppliedOpacity",
    value: function getDrawModelsAppliedOpacity(opacity) {
      var _this4 = this;

      return Object.keys(this.models).reduce(function (acc, key) {
        return component_dataLabels_objectSpread(component_dataLabels_objectSpread({}, acc), {}, component_dataLabels_defineProperty({}, key, _this4.models[key].map(function (m) {
          return component_dataLabels_objectSpread(component_dataLabels_objectSpread({}, m), {}, {
            opacity: opacity
          });
        })));
      }, {
        series: [],
        total: []
      });
    }
  }, {
    key: "renderLabelModel",
    value: function renderLabelModel() {
      var _this5 = this;

      return Object.keys(this.dataLabelsMap).map(function (seriesName) {
        var data = _this5.dataLabelsMap[seriesName].data;
        return _this5.makeLabelModel(data);
      }).reduce(function (acc, cur) {
        return {
          series: [].concat(dataLabels_toConsumableArray(acc.series), dataLabels_toConsumableArray(cur.series)),
          total: [].concat(dataLabels_toConsumableArray(acc.total), dataLabels_toConsumableArray(cur.total))
        };
      }, {
        series: [],
        total: []
      });
    }
  }, {
    key: "makeLabelModel",
    value: function makeLabelModel(dataLabels) {
      var _this6 = this;

      return dataLabels.reduce(function (acc, dataLabel) {
        var _acc$modelName;

        var type = dataLabel.type,
            x = dataLabel.x,
            y = dataLabel.y,
            text = dataLabel.text,
            textAlign = dataLabel.textAlign,
            textBaseline = dataLabel.textBaseline,
            name = dataLabel.name,
            callout = dataLabel.callout,
            theme = dataLabel.theme,
            radian = dataLabel.radian;

        if (!isModelExistingInRect(_this6.rect, {
          x: x,
          y: y
        })) {
          return acc;
        }

        var modelName = type === 'stackTotal' ? 'total' : 'series';
        return component_dataLabels_objectSpread(component_dataLabels_objectSpread({}, acc), {}, component_dataLabels_defineProperty({}, modelName, [].concat(dataLabels_toConsumableArray((_acc$modelName = acc[modelName]) !== null && _acc$modelName !== void 0 ? _acc$modelName : []), [{
          type: 'dataLabel',
          dataLabelType: type,
          text: text,
          x: x,
          y: y,
          textAlign: textAlign,
          textBaseline: textBaseline,
          opacity: 1,
          name: name,
          callout: callout,
          theme: theme,
          radian: radian
        }])));
      }, {
        series: [],
        total: []
      });
    }
  }]);

  return DataLabels;
}(Component);


;// CONCATENATED MODULE: ./src/component/axisTitle.ts
function axisTitle_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { axisTitle_typeof = function _typeof(obj) { return typeof obj; }; } else { axisTitle_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return axisTitle_typeof(obj); }

function axisTitle_slicedToArray(arr, i) { return axisTitle_arrayWithHoles(arr) || axisTitle_iterableToArrayLimit(arr, i) || axisTitle_unsupportedIterableToArray(arr, i) || axisTitle_nonIterableRest(); }

function axisTitle_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function axisTitle_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return axisTitle_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return axisTitle_arrayLikeToArray(o, minLen); }

function axisTitle_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function axisTitle_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function axisTitle_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
















function axisTitle_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function axisTitle_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function axisTitle_createClass(Constructor, protoProps, staticProps) { if (protoProps) axisTitle_defineProperties(Constructor.prototype, protoProps); if (staticProps) axisTitle_defineProperties(Constructor, staticProps); return Constructor; }

function axisTitle_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) axisTitle_setPrototypeOf(subClass, superClass); }

function axisTitle_setPrototypeOf(o, p) { axisTitle_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return axisTitle_setPrototypeOf(o, p); }

function axisTitle_createSuper(Derived) { var hasNativeReflectConstruct = axisTitle_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = axisTitle_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = axisTitle_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return axisTitle_possibleConstructorReturn(this, result); }; }

function axisTitle_possibleConstructorReturn(self, call) { if (call && (axisTitle_typeof(call) === "object" || typeof call === "function")) { return call; } return axisTitle_assertThisInitialized(self); }

function axisTitle_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function axisTitle_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function axisTitle_getPrototypeOf(o) { axisTitle_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return axisTitle_getPrototypeOf(o); }

function axisTitle_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var AxisTitle = /*#__PURE__*/function (_Component) {
  axisTitle_inherits(AxisTitle, _Component);

  var _super = axisTitle_createSuper(AxisTitle);

  function AxisTitle() {
    var _this;

    axisTitle_classCallCheck(this, AxisTitle);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    axisTitle_defineProperty(axisTitle_assertThisInitialized(_this), "models", void 0);

    axisTitle_defineProperty(axisTitle_assertThisInitialized(_this), "isYAxis", void 0);

    axisTitle_defineProperty(axisTitle_assertThisInitialized(_this), "isCircularAxis", void 0);

    axisTitle_defineProperty(axisTitle_assertThisInitialized(_this), "theme", void 0);

    return _this;
  }

  axisTitle_createClass(AxisTitle, [{
    key: "initialize",
    value: function initialize(_ref) {
      var name = _ref.name;
      this.type = 'axisTitle';
      this.name = name;
      this.isYAxis = includes([AxisType.Y, AxisType.SECONDARY_Y], name);
      this.isCircularAxis = this.name === AxisType.CIRCULAR;
    }
  }, {
    key: "getTitlePosition",
    value: function getTitlePosition(offsetX, offsetY) {
      if (this.isCircularAxis) {
        return [this.rect.width / 2 + offsetX, this.rect.height / 2 + offsetY];
      }

      return this.isYAxis ? [this.name === AxisType.Y ? offsetX : this.rect.width + offsetX, offsetY] : [this.rect.width + offsetX, offsetY];
    }
  }, {
    key: "renderAxisTitle",
    value: function renderAxisTitle(option, textAlign) {
      var text = option.text,
          offsetX = option.offsetX,
          offsetY = option.offsetY;

      var _this$getTitlePositio = this.getTitlePosition(offsetX, offsetY),
          _this$getTitlePositio2 = axisTitle_slicedToArray(_this$getTitlePositio, 2),
          x = _this$getTitlePositio2[0],
          y = _this$getTitlePositio2[1];

      var font = getTitleFontString(this.theme);
      var fillStyle = this.theme.color;
      return [{
        type: 'label',
        text: text,
        x: x,
        y: y,
        style: ['axisTitle', {
          textAlign: textAlign,
          fillStyle: fillStyle,
          font: font
        }]
      }];
    }
  }, {
    key: "getTextAlign",
    value: function getTextAlign() {
      var hasCenterYAxis = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.name === AxisType.Y) {
        return hasCenterYAxis ? 'center' : 'left';
      }

      if (this.isCircularAxis) {
        return 'center';
      }

      return 'right';
    }
  }, {
    key: "getCircularAxisTitleRect",
    value: function getCircularAxisTitleRect(option, plotRect, circularAxisData) {
      var x = plotRect.x,
          y = plotRect.y;
      var centerX = circularAxisData.centerX,
          centerY = circularAxisData.centerY,
          axisSize = circularAxisData.axisSize,
          outerRadius = circularAxisData.radius.outer;
      var offsetY = option.offsetY;
      return {
        x: centerX + x - axisSize / 2,
        y: centerY + y - outerRadius / 2,
        width: axisSize,
        height: this.theme.fontSize + offsetY
      };
    }
  }, {
    key: "render",
    value: function render(_ref2) {
      var _radialAxes$this$name, _axes$this$name;

      var axes = _ref2.axes,
          radialAxes = _ref2.radialAxes,
          layout = _ref2.layout,
          theme = _ref2.theme;
      var titleOption = this.isCircularAxis ? (_radialAxes$this$name = radialAxes[this.name]) === null || _radialAxes$this$name === void 0 ? void 0 : _radialAxes$this$name.title : (_axes$this$name = axes[this.name]) === null || _axes$this$name === void 0 ? void 0 : _axes$this$name.title;
      this.isShow = !!titleOption;

      if (!this.isShow) {
        return;
      }

      this.theme = getAxisTheme(theme, this.name).title;
      this.rect = layout["".concat(this.name, "Title")];
      this.models = this.renderAxisTitle(titleOption, this.getTextAlign(!!(axes !== null && axes !== void 0 && axes.centerYAxis)));
    }
  }]);

  return AxisTitle;
}(Component);


;// CONCATENATED MODULE: ./src/component/title.ts
function title_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { title_typeof = function _typeof(obj) { return typeof obj; }; } else { title_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return title_typeof(obj); }














function title_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function title_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function title_createClass(Constructor, protoProps, staticProps) { if (protoProps) title_defineProperties(Constructor.prototype, protoProps); if (staticProps) title_defineProperties(Constructor, staticProps); return Constructor; }

function title_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) title_setPrototypeOf(subClass, superClass); }

function title_setPrototypeOf(o, p) { title_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return title_setPrototypeOf(o, p); }

function title_createSuper(Derived) { var hasNativeReflectConstruct = title_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = title_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = title_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return title_possibleConstructorReturn(this, result); }; }

function title_possibleConstructorReturn(self, call) { if (call && (title_typeof(call) === "object" || typeof call === "function")) { return call; } return title_assertThisInitialized(self); }

function title_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function title_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function title_getPrototypeOf(o) { title_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return title_getPrototypeOf(o); }

function title_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var Title = /*#__PURE__*/function (_Component) {
  title_inherits(Title, _Component);

  var _super = title_createSuper(Title);

  function Title() {
    var _this;

    title_classCallCheck(this, Title);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    title_defineProperty(title_assertThisInitialized(_this), "models", void 0);

    title_defineProperty(title_assertThisInitialized(_this), "theme", void 0);

    return _this;
  }

  title_createClass(Title, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'title';
      this.name = 'title';
    }
  }, {
    key: "renderTitle",
    value: function renderTitle(options) {
      var text = '';
      var x = 0;
      var y = 0;
      var align = 'left';

      if (utils_isString(options)) {
        text = options;
      } else {
        var _options$align, _options$offsetX, _options$offsetY;

        text = options.text;
        align = (_options$align = options.align) !== null && _options$align !== void 0 ? _options$align : 'left';
        x += (_options$offsetX = options.offsetX) !== null && _options$offsetX !== void 0 ? _options$offsetX : 0;
        y += (_options$offsetY = options.offsetY) !== null && _options$offsetY !== void 0 ? _options$offsetY : 0;
      }

      var font = getTitleFontString(this.theme);
      var textWidth = getTextWidth(text, font);

      if (align === 'center') {
        x += (this.rect.width - textWidth) / 2;
      } else if (align === 'right') {
        x += this.rect.width - textWidth;
      }

      return [{
        type: 'label',
        x: x,
        y: y,
        text: text,
        style: ['title', {
          font: font,
          fillStyle: this.theme.color
        }]
      }];
    }
  }, {
    key: "render",
    value: function render(_ref) {
      var _options$chart;

      var options = _ref.options,
          layout = _ref.layout,
          theme = _ref.theme;
      this.isShow = !!((_options$chart = options.chart) !== null && _options$chart !== void 0 && _options$chart.title);

      if (!this.isShow) {
        return;
      }

      this.theme = theme.title;
      this.rect = layout.title;
      this.models = this.renderTitle(options.chart.title);
    }
  }]);

  return Title;
}(Component);


;// CONCATENATED MODULE: ./src/component/hoveredSeries.ts
function hoveredSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { hoveredSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { hoveredSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return hoveredSeries_typeof(obj); }

function hoveredSeries_slicedToArray(arr, i) { return hoveredSeries_arrayWithHoles(arr) || hoveredSeries_iterableToArrayLimit(arr, i) || hoveredSeries_unsupportedIterableToArray(arr, i) || hoveredSeries_nonIterableRest(); }

function hoveredSeries_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function hoveredSeries_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function hoveredSeries_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function hoveredSeries_toConsumableArray(arr) { return hoveredSeries_arrayWithoutHoles(arr) || hoveredSeries_iterableToArray(arr) || hoveredSeries_unsupportedIterableToArray(arr) || hoveredSeries_nonIterableSpread(); }

function hoveredSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function hoveredSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return hoveredSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return hoveredSeries_arrayLikeToArray(o, minLen); }

function hoveredSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function hoveredSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return hoveredSeries_arrayLikeToArray(arr); }

function hoveredSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }





















function hoveredSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function hoveredSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function hoveredSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) hoveredSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) hoveredSeries_defineProperties(Constructor, staticProps); return Constructor; }

function hoveredSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) hoveredSeries_setPrototypeOf(subClass, superClass); }

function hoveredSeries_setPrototypeOf(o, p) { hoveredSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return hoveredSeries_setPrototypeOf(o, p); }

function hoveredSeries_createSuper(Derived) { var hasNativeReflectConstruct = hoveredSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = hoveredSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = hoveredSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return hoveredSeries_possibleConstructorReturn(this, result); }; }

function hoveredSeries_possibleConstructorReturn(self, call) { if (call && (hoveredSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return hoveredSeries_assertThisInitialized(self); }

function hoveredSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function hoveredSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function hoveredSeries_getPrototypeOf(o) { hoveredSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return hoveredSeries_getPrototypeOf(o); }

function hoveredSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var guideLineType = {
  line: 'circle',
  area: 'circle',
  boxPlot: 'boxPlot'
};

var HoveredSeries = /*#__PURE__*/function (_Component) {
  hoveredSeries_inherits(HoveredSeries, _Component);

  var _super = hoveredSeries_createSuper(HoveredSeries);

  function HoveredSeries() {
    var _this;

    hoveredSeries_classCallCheck(this, HoveredSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    hoveredSeries_defineProperty(hoveredSeries_assertThisInitialized(_this), "models", {
      guideLine: []
    });

    hoveredSeries_defineProperty(hoveredSeries_assertThisInitialized(_this), "isShow", false);

    hoveredSeries_defineProperty(hoveredSeries_assertThisInitialized(_this), "modelForGuideLine", void 0);

    hoveredSeries_defineProperty(hoveredSeries_assertThisInitialized(_this), "renderHoveredSeries", function (_ref) {
      var models = _ref.models,
          name = _ref.name,
          eventDetectType = _ref.eventDetectType;

      var prevModels = _this.getSeriesModels(name);

      _this.models[name] = hoveredSeries_toConsumableArray(models);
      _this.isShow = !!_this.getSeriesModels().length;
      var isSame = !!(prevModels !== null && prevModels !== void 0 && prevModels.length) && !!models.length && isSameSeriesResponder({
        models: models,
        comparisonModel: prevModels,
        eventDetectType: eventDetectType,
        name: name
      });

      if (prevModels !== null && prevModels !== void 0 && prevModels.length && !models.length) {
        _this.eventBus.emit('unhoverSeries', makeObservableObjectToNormal(prevModels));
      } else if (models.length && !isSame) {
        _this.eventBus.emit('hoverSeries', makeObservableObjectToNormal(models));
      }

      _this.modelForGuideLine = _this.getModelForGuideLine(name);

      if (eventDetectType === 'grouped') {
        _this.renderGroupedModels(name);
      }
    });

    hoveredSeries_defineProperty(hoveredSeries_assertThisInitialized(_this), "resetHoveredSeries", function () {
      _this.models = {
        guideLine: []
      };
    });

    return _this;
  }

  hoveredSeries_createClass(HoveredSeries, [{
    key: "getSeriesModels",
    value: function getSeriesModels(type) {
      var _ref2;

      var _this$models = this.models,
          guideLine = _this$models.guideLine,
          models = _objectWithoutProperties(_this$models, ["guideLine"]);

      return (_ref2 = type ? models[type] : Object.values(models)) === null || _ref2 === void 0 ? void 0 : _ref2.flatMap(function (val) {
        return val;
      });
    }
  }, {
    key: "hasGuideLine",
    value: function hasGuideLine() {
      var _this$getSeriesModels = this.getSeriesModels().filter(function (_ref3) {
        var type = _ref3.type;
        return type === 'rect';
      }),
          _this$getSeriesModels2 = hoveredSeries_slicedToArray(_this$getSeriesModels, 1),
          rectModel = _this$getSeriesModels2[0];

      return !isUndefined(this.modelForGuideLine) && isUndefined(rectModel);
    }
  }, {
    key: "getModelForGuideLine",
    value: function getModelForGuideLine(name) {
      return this.getSeriesModels().filter(function (_ref4) {
        var type = _ref4.type;
        return type === guideLineType[name];
      })[0];
    }
  }, {
    key: "renderGroupedModels",
    value: function renderGroupedModels(name) {
      if (includes(Object.keys(guideLineType), name)) {
        if (this.isShow && this.hasGuideLine()) {
          this.models.guideLine = [this.renderGuideLineModel(this.modelForGuideLine)];
        } else {
          this.models.guideLine = [];
        }
      }
    }
  }, {
    key: "renderGuideLineModel",
    value: function renderGuideLineModel(model) {
      var x = crispPixel(model.type === 'boxPlot' && model.boxPlotDetection ? model.boxPlotDetection.x + model.boxPlotDetection.width / 2 : model.x);
      return {
        type: 'line',
        x: x,
        y: 0,
        x2: x,
        y2: this.rect.height,
        strokeStyle: '#ddd',
        lineWidth: 1
      };
    }
  }, {
    key: "initialize",
    value: function initialize() {
      this.type = 'hoveredSeries';
      this.name = 'hoveredSeries';
      this.eventBus.on('renderHoveredSeries', this.renderHoveredSeries);
      this.eventBus.on('resetHoveredSeries', this.resetHoveredSeries);
    }
  }, {
    key: "render",
    value: function render(_ref5) {
      var layout = _ref5.layout;
      this.rect = layout.plot;
    }
  }]);

  return HoveredSeries;
}(Component);


;// CONCATENATED MODULE: ./src/component/rangeSelection.ts
function rangeSelection_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { rangeSelection_typeof = function _typeof(obj) { return typeof obj; }; } else { rangeSelection_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return rangeSelection_typeof(obj); }

function rangeSelection_toConsumableArray(arr) { return rangeSelection_arrayWithoutHoles(arr) || rangeSelection_iterableToArray(arr) || rangeSelection_unsupportedIterableToArray(arr) || rangeSelection_nonIterableSpread(); }

function rangeSelection_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function rangeSelection_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function rangeSelection_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return rangeSelection_arrayLikeToArray(arr); }

function rangeSelection_slicedToArray(arr, i) { return rangeSelection_arrayWithHoles(arr) || rangeSelection_iterableToArrayLimit(arr, i) || rangeSelection_unsupportedIterableToArray(arr, i) || rangeSelection_nonIterableRest(); }

function rangeSelection_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function rangeSelection_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return rangeSelection_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return rangeSelection_arrayLikeToArray(o, minLen); }

function rangeSelection_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function rangeSelection_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function rangeSelection_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function rangeSelection_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function rangeSelection_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { rangeSelection_ownKeys(Object(source), true).forEach(function (key) { rangeSelection_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { rangeSelection_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

























function rangeSelection_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function rangeSelection_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function rangeSelection_createClass(Constructor, protoProps, staticProps) { if (protoProps) rangeSelection_defineProperties(Constructor.prototype, protoProps); if (staticProps) rangeSelection_defineProperties(Constructor, staticProps); return Constructor; }

function rangeSelection_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) rangeSelection_setPrototypeOf(subClass, superClass); }

function rangeSelection_setPrototypeOf(o, p) { rangeSelection_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return rangeSelection_setPrototypeOf(o, p); }

function rangeSelection_createSuper(Derived) { var hasNativeReflectConstruct = rangeSelection_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = rangeSelection_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = rangeSelection_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return rangeSelection_possibleConstructorReturn(this, result); }; }

function rangeSelection_possibleConstructorReturn(self, call) { if (call && (rangeSelection_typeof(call) === "object" || typeof call === "function")) { return call; } return rangeSelection_assertThisInitialized(self); }

function rangeSelection_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function rangeSelection_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function rangeSelection_getPrototypeOf(o) { rangeSelection_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return rangeSelection_getPrototypeOf(o); }

function rangeSelection_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








var DRAG_MIN_WIDTH = 15;

var RangeSelection = /*#__PURE__*/function (_Component) {
  rangeSelection_inherits(RangeSelection, _Component);

  var _super = rangeSelection_createSuper(RangeSelection);

  function RangeSelection() {
    var _this;

    rangeSelection_classCallCheck(this, RangeSelection);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    rangeSelection_defineProperty(rangeSelection_assertThisInitialized(_this), "models", {
      selectionArea: []
    });

    rangeSelection_defineProperty(rangeSelection_assertThisInitialized(_this), "responders", void 0);

    rangeSelection_defineProperty(rangeSelection_assertThisInitialized(_this), "startIndex", void 0);

    rangeSelection_defineProperty(rangeSelection_assertThisInitialized(_this), "dragStartPosition", null);

    rangeSelection_defineProperty(rangeSelection_assertThisInitialized(_this), "dragStartPoint", null);

    rangeSelection_defineProperty(rangeSelection_assertThisInitialized(_this), "isDragging", false);

    return _this;
  }

  rangeSelection_createClass(RangeSelection, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'rangeSelection';
    }
  }, {
    key: "render",
    value: function render(state, computed) {
      var _viewRange$;

      if (!state.selectionRange && !state.zoomRange) {
        return;
      }

      this.resetSelectionArea();
      var viewRange = computed.viewRange;
      var layout = state.layout,
          axes = state.axes,
          series = state.series,
          scale = state.scale;
      var categories = state.categories;
      this.rect = layout.plot;
      this.startIndex = (_viewRange$ = viewRange === null || viewRange === void 0 ? void 0 : viewRange[0]) !== null && _viewRange$ !== void 0 ? _viewRange$ : 0;
      var coordinateChart = isCoordinateSeries(series);

      if (coordinateChart) {
        var responderInfo = this.getRectResponderInfoForCoordinateType(series, scale, axes.xAxis, categories);
        this.responders = this.makeRectResponderModelForCoordinateType(responderInfo, categories);
      } else {
        this.responders = this.makeRectResponderModel(categories, axes.xAxis);
      }
    }
  }, {
    key: "getRectResponderInfoForCoordinateType",
    value: function getRectResponderInfoForCoordinateType(series, scale, axisData, categories) {
      var _this2 = this;

      var points = [];
      var duplicateCheckMap = {};
      Object.keys(series).forEach(function (seriesName) {
        var data = series[seriesName].data;
        data.forEach(function (_ref) {
          var rawData = _ref.rawData;
          rawData.forEach(function (datum, idx) {
            if (isNull(datum)) {
              return;
            }

            var dataIndex = getCoordinateDataIndex(datum, categories, idx, _this2.startIndex);
            var x = getXPosition(axisData, _this2.rect.width, getCoordinateXValue(datum), dataIndex);
            var xWithinRect = x >= 0 && x <= _this2.rect.width;

            if (!duplicateCheckMap[x] && xWithinRect) {
              duplicateCheckMap[x] = true;
              points.push({
                x: x,
                label: categories[dataIndex]
              });
            }
          });
        });
      });
      return points;
    }
  }, {
    key: "resetSelectionArea",
    value: function resetSelectionArea() {
      this.dragStartPosition = null;
      this.dragStartPoint = null;
      this.models.selectionArea = [];
      this.isDragging = false;
    }
  }, {
    key: "onMousedown",
    value: function onMousedown(_ref2) {
      var responders = _ref2.responders,
          mousePosition = _ref2.mousePosition;

      if (responders.length) {
        this.dragStartPoint = responders.find(function (responder) {
          return responder.data.name === 'selectionArea';
        });
        this.dragStartPosition = mousePosition;
      }
    }
  }, {
    key: "onMouseup",
    value: function onMouseup(_ref3) {
      var _this3 = this;

      var responders = _ref3.responders;

      if (this.isDragging && this.dragStartPoint && responders.length) {
        var dragRange = [this.dragStartPoint, responders[0]].sort(function (a, b) {
          return a.index - b.index;
        }).map(function (m) {
          var _m$data;

          return (_m$data = m.data) === null || _m$data === void 0 ? void 0 : _m$data.value;
        });
        var _this$store$state = this.store.state,
            series = _this$store$state.series,
            options = _this$store$state.options;
        var seriesOptions = options.series;

        if (!series.column && seriesOptions !== null && seriesOptions !== void 0 && seriesOptions.zoomable) {
          this.store.dispatch('zoom', dragRange);
          this.eventBus.emit('zoom', makeObservableObjectToNormal(dragRange));
        }

        if (seriesOptions !== null && seriesOptions !== void 0 && seriesOptions.rangeSelectable) {
          this.eventBus.emit('rangeSelection', dragRange);
        }

        this.eventBus.emit('resetHoveredSeries');
        this.eventBus.emit('hideTooltip'); // @TODO: Should occur after the series' click event
        // Additional logic to control the sequence of events with each other is required.

        setTimeout(function () {
          _this3.eventBus.emit('resetSelectedSeries');
        });
      }

      this.resetSelectionArea();
    }
  }, {
    key: "makeRectResponderModel",
    value: function makeRectResponderModel(categories, axisData) {
      var categorySize = categories.length;
      var pointOnColumn = axisData.pointOnColumn,
          tickDistance = axisData.tickDistance;
      var height = this.rect.height;
      var halfDetectAreaIndex = pointOnColumn ? [] : [0, categorySize - 1];
      var halfWidth = tickDistance / 2;
      return range(0, categorySize).map(function (index) {
        var half = halfDetectAreaIndex.includes(index);
        var width = half ? halfWidth : tickDistance;
        var startX = 0;

        if (index !== 0) {
          startX += pointOnColumn ? tickDistance * index : halfWidth + tickDistance * (index - 1);
        }

        return {
          type: 'rect',
          x: startX,
          y: 0,
          height: height,
          width: width,
          index: index,
          data: {
            name: 'selectionArea',
            value: categories[index]
          }
        };
      });
    }
  }, {
    key: "makeRectResponderModelForCoordinateType",
    value: function makeRectResponderModelForCoordinateType(responderInfo, categories) {
      var responders = responders_makeRectResponderModelForCoordinateType(responderInfo, this.rect);

      return responders.map(function (m, idx) {
        return rangeSelection_objectSpread(rangeSelection_objectSpread({}, m), {}, {
          data: {
            name: 'selectionArea',
            value: categories[idx]
          }
        });
      });
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref4) {
      var responders = _ref4.responders,
          mousePosition = _ref4.mousePosition;

      if (!responders.length) {
        return;
      }

      if (this.dragStartPosition && !this.isDragging) {
        var x = mousePosition.x;
        var startX = this.dragStartPosition.x;
        this.isDragging = Math.abs(startX - x) > DRAG_MIN_WIDTH;
      }

      if (this.isDragging) {
        var startIndex = this.dragStartPoint.index;
        var endIndex = responders[0].index;

        var _sort = [startIndex, endIndex].sort(sortNumber),
            _sort2 = rangeSelection_slicedToArray(_sort, 2),
            start = _sort2[0],
            end = _sort2[1];

        var includedResponders = this.responders.slice(start, end + 1);
        this.models.selectionArea = rangeSelection_toConsumableArray(includedResponders.map(function (m) {
          return rangeSelection_objectSpread(rangeSelection_objectSpread({}, m), {}, {
            x: m.x,
            y: 0,
            type: 'rect',
            color: 'rgba(0, 0, 0, 0.2)'
          });
        }));
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "onMouseoutComponent",
    value: function onMouseoutComponent() {
      this.resetSelectionArea();
    }
  }]);

  return RangeSelection;
}(Component);


;// CONCATENATED MODULE: ./src/component/resetButton.ts
function resetButton_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { resetButton_typeof = function _typeof(obj) { return typeof obj; }; } else { resetButton_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return resetButton_typeof(obj); }














function resetButton_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function resetButton_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function resetButton_createClass(Constructor, protoProps, staticProps) { if (protoProps) resetButton_defineProperties(Constructor.prototype, protoProps); if (staticProps) resetButton_defineProperties(Constructor, staticProps); return Constructor; }

function resetButton_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) resetButton_setPrototypeOf(subClass, superClass); }

function resetButton_setPrototypeOf(o, p) { resetButton_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return resetButton_setPrototypeOf(o, p); }

function resetButton_createSuper(Derived) { var hasNativeReflectConstruct = resetButton_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = resetButton_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = resetButton_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return resetButton_possibleConstructorReturn(this, result); }; }

function resetButton_possibleConstructorReturn(self, call) { if (call && (resetButton_typeof(call) === "object" || typeof call === "function")) { return call; } return resetButton_assertThisInitialized(self); }

function resetButton_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function resetButton_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function resetButton_getPrototypeOf(o) { resetButton_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return resetButton_getPrototypeOf(o); }

function resetButton_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var ResetButton = /*#__PURE__*/function (_Component) {
  resetButton_inherits(ResetButton, _Component);

  var _super = resetButton_createSuper(ResetButton);

  function ResetButton() {
    var _this;

    resetButton_classCallCheck(this, ResetButton);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    resetButton_defineProperty(resetButton_assertThisInitialized(_this), "responders", void 0);

    resetButton_defineProperty(resetButton_assertThisInitialized(_this), "models", void 0);

    return _this;
  }

  resetButton_createClass(ResetButton, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'resetButton';
      this.name = 'resetButton';
    }
  }, {
    key: "onClick",
    value: function onClick(_ref) {
      var responders = _ref.responders;

      if (responders.length) {
        this.eventBus.emit('resetZoom');
        this.store.dispatch('resetZoom');
      }
    }
  }, {
    key: "render",
    value: function render(_ref2, computed) {
      var options = _ref2.options,
          layout = _ref2.layout;

      if (!isUsingResetButton(options)) {
        return;
      }

      this.rect = layout.resetButton;
      this.isShow = computed.isLineTypeSeriesZooming;
      this.models = this.isShow ? [{
        type: 'resetButton',
        x: 0,
        y: 0
      }] : [];
      this.responders = this.isShow ? [{
        type: 'rect',
        x: 0,
        y: 0,
        width: BUTTON_RECT_SIZE,
        height: BUTTON_RECT_SIZE
      }] : [];
    }
  }]);

  return ResetButton;
}(Component);


;// CONCATENATED MODULE: ./src/component/selectedSeries.ts
function selectedSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { selectedSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { selectedSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return selectedSeries_typeof(obj); }

function selectedSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function selectedSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { selectedSeries_ownKeys(Object(source), true).forEach(function (key) { selectedSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { selectedSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }






















function selectedSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function selectedSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function selectedSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) selectedSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) selectedSeries_defineProperties(Constructor, staticProps); return Constructor; }

function selectedSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) selectedSeries_setPrototypeOf(subClass, superClass); }

function selectedSeries_setPrototypeOf(o, p) { selectedSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return selectedSeries_setPrototypeOf(o, p); }

function selectedSeries_createSuper(Derived) { var hasNativeReflectConstruct = selectedSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = selectedSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = selectedSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return selectedSeries_possibleConstructorReturn(this, result); }; }

function selectedSeries_possibleConstructorReturn(self, call) { if (call && (selectedSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return selectedSeries_assertThisInitialized(self); }

function selectedSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function selectedSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function selectedSeries_getPrototypeOf(o) { selectedSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return selectedSeries_getPrototypeOf(o); }

function selectedSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var SelectedSeries = /*#__PURE__*/function (_Component) {
  selectedSeries_inherits(SelectedSeries, _Component);

  var _super = selectedSeries_createSuper(SelectedSeries);

  function SelectedSeries() {
    var _this;

    selectedSeries_classCallCheck(this, SelectedSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    selectedSeries_defineProperty(selectedSeries_assertThisInitialized(_this), "models", {});

    selectedSeries_defineProperty(selectedSeries_assertThisInitialized(_this), "seriesModels", {});

    selectedSeries_defineProperty(selectedSeries_assertThisInitialized(_this), "activeSeriesNames", {});

    selectedSeries_defineProperty(selectedSeries_assertThisInitialized(_this), "isShow", false);

    selectedSeries_defineProperty(selectedSeries_assertThisInitialized(_this), "renderSelectedSeries", function (selectedSeriesEventModel) {
      var name = selectedSeriesEventModel.name,
          alias = selectedSeriesEventModel.alias;

      var models = _this.getSelectedSeriesModelsForRendering(selectedSeriesEventModel);

      _this.models[alias || name] = isSameSeriesResponder(selectedSeries_objectSpread(selectedSeries_objectSpread({}, selectedSeriesEventModel), {}, {
        models: models,
        comparisonModel: _this.models[alias || name]
      })) ? [] : models;
      _this.seriesModels[alias || name] = _this.getSelectedSeriesModels(selectedSeriesEventModel);
      _this.isShow = !!Object.values(_this.models).flatMap(function (value) {
        return value;
      }).length;

      _this.eventBus.emit(_this.isShow ? 'selectSeries' : 'unselectSeries', makeObservableObjectToNormal(_this.seriesModels));

      _this.activeSeriesNames[name] = _this.getSeriesNames(selectedSeriesEventModel.models, name);

      _this.setActiveState();
    });

    selectedSeries_defineProperty(selectedSeries_assertThisInitialized(_this), "resetSelectedSeries", function () {
      _this.models = {};

      _this.store.dispatch('setAllLegendActiveState', true);
    });

    return _this;
  }

  selectedSeries_createClass(SelectedSeries, [{
    key: "getSeriesNames",
    value: function getSeriesNames(selectedSeries, name) {
      var _this2 = this;

      var names = [];

      if (includes(['line', 'area', 'radar', 'bubble', 'scatter', 'bullet', 'boxPlot'], name)) {
        selectedSeries.forEach(function (model) {
          var label = model.name;

          if (label) {
            names.push(label);
          }
        });
      } else if (includes(['bar', 'column', 'radialBar'], name)) {
        selectedSeries.forEach(function (model) {
          var _data;

          var label = (_data = model.data) === null || _data === void 0 ? void 0 : _data.label;

          if (label) {
            names.push(label);
          }
        });
      } else if (name === 'pie') {
        Object.keys(this.models).flatMap(function (key) {
          return _this2.models[key];
        }).forEach(function (model) {
          var _data2, _data3;

          var label = ((_data2 = model.data) === null || _data2 === void 0 ? void 0 : _data2.rootParentName) || ((_data3 = model.data) === null || _data3 === void 0 ? void 0 : _data3.label);

          if (label) {
            names.push(label);
          }
        });
      }

      return names;
    }
  }, {
    key: "getSelectedSeriesModelsForRendering",
    value: function getSelectedSeriesModelsForRendering(selectedSeriesEventModel) {
      var models = selectedSeriesEventModel.models,
          eventDetectType = selectedSeriesEventModel.eventDetectType,
          name = selectedSeriesEventModel.name;
      var renderingModels = models;

      if ((name === 'column' || name === 'bar' || name === 'bullet') && eventDetectType === 'grouped') {
        renderingModels = models.filter(function (model) {
          return !model.data;
        });
      } else if (name === 'radialBar' && eventDetectType === 'grouped') {
        renderingModels = models.filter(function (model) {
          return !model.data;
        });
      }

      return renderingModels;
    }
  }, {
    key: "getSelectedSeriesModels",
    value: function getSelectedSeriesModels(selectedSeriesEventModel) {
      var models = selectedSeriesEventModel.models,
          eventDetectType = selectedSeriesEventModel.eventDetectType,
          name = selectedSeriesEventModel.name;
      var selectedSeriesModels = models;

      if ((name === 'column' || name === 'bar' || name === 'bullet') && eventDetectType === 'grouped') {
        selectedSeriesModels = models.filter(function (model) {
          return model.data;
        });
      } else if (name === 'radialBar' && eventDetectType === 'grouped') {
        selectedSeriesModels = models.filter(function (model) {
          return model.data;
        });
      }

      return selectedSeriesModels;
    }
  }, {
    key: "setActiveState",
    value: function setActiveState() {
      var _this3 = this;

      if (this.isShow) {
        this.store.dispatch('setAllLegendActiveState', false);
        Object.values(this.activeSeriesNames).forEach(function (names) {
          names.forEach(function (name) {
            _this3.store.dispatch('setLegendActiveState', {
              name: name,
              active: true
            });
          });
        });
      } else {
        this.store.dispatch('setAllLegendActiveState', true);
      }

      this.eventBus.emit('needDraw');
    }
  }, {
    key: "initialize",
    value: function initialize() {
      this.type = 'selectedSeries';
      this.name = 'selectedSeries';
      this.eventBus.on('renderSelectedSeries', this.renderSelectedSeries);
      this.eventBus.on('resetSelectedSeries', this.resetSelectedSeries);
    }
  }, {
    key: "render",
    value: function render(_ref) {
      var layout = _ref.layout;
      this.rect = layout.plot;
    }
  }]);

  return SelectedSeries;
}(Component);


;// CONCATENATED MODULE: ./src/component/background.ts
function background_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { background_typeof = function _typeof(obj) { return typeof obj; }; } else { background_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return background_typeof(obj); }

function background_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function background_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { background_ownKeys(Object(source), true).forEach(function (key) { background_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { background_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



















function background_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function background_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function background_createClass(Constructor, protoProps, staticProps) { if (protoProps) background_defineProperties(Constructor.prototype, protoProps); if (staticProps) background_defineProperties(Constructor, staticProps); return Constructor; }

function background_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) background_setPrototypeOf(subClass, superClass); }

function background_setPrototypeOf(o, p) { background_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return background_setPrototypeOf(o, p); }

function background_createSuper(Derived) { var hasNativeReflectConstruct = background_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = background_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = background_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return background_possibleConstructorReturn(this, result); }; }

function background_possibleConstructorReturn(self, call) { if (call && (background_typeof(call) === "object" || typeof call === "function")) { return call; } return background_assertThisInitialized(self); }

function background_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function background_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function background_getPrototypeOf(o) { background_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return background_getPrototypeOf(o); }

function background_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var Background = /*#__PURE__*/function (_Component) {
  background_inherits(Background, _Component);

  var _super = background_createSuper(Background);

  function Background() {
    var _this;

    background_classCallCheck(this, Background);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    background_defineProperty(background_assertThisInitialized(_this), "models", void 0);

    background_defineProperty(background_assertThisInitialized(_this), "theme", void 0);

    return _this;
  }

  background_createClass(Background, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'background';
      this.name = 'background';
    }
  }, {
    key: "render",
    value: function render(_ref) {
      var layout = _ref.layout,
          theme = _ref.theme;
      var _layout$chart = layout.chart,
          width = _layout$chart.width,
          height = _layout$chart.height;
      this.theme = theme.chart;
      this.rect = {
        x: 0,
        y: 0,
        width: width,
        height: height
      };
      this.models = [background_objectSpread(background_objectSpread({
        type: 'rect'
      }, this.rect), {}, {
        color: this.theme.backgroundColor
      })];
    }
  }]);

  return Background;
}(Component);


;// CONCATENATED MODULE: ./src/component/noDataText.ts
function noDataText_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { noDataText_typeof = function _typeof(obj) { return typeof obj; }; } else { noDataText_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return noDataText_typeof(obj); }

function noDataText_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function noDataText_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { noDataText_ownKeys(Object(source), true).forEach(function (key) { noDataText_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { noDataText_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



















function noDataText_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function noDataText_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function noDataText_createClass(Constructor, protoProps, staticProps) { if (protoProps) noDataText_defineProperties(Constructor.prototype, protoProps); if (staticProps) noDataText_defineProperties(Constructor, staticProps); return Constructor; }

function noDataText_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) noDataText_setPrototypeOf(subClass, superClass); }

function noDataText_setPrototypeOf(o, p) { noDataText_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return noDataText_setPrototypeOf(o, p); }

function noDataText_createSuper(Derived) { var hasNativeReflectConstruct = noDataText_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = noDataText_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = noDataText_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return noDataText_possibleConstructorReturn(this, result); }; }

function noDataText_possibleConstructorReturn(self, call) { if (call && (noDataText_typeof(call) === "object" || typeof call === "function")) { return call; } return noDataText_assertThisInitialized(self); }

function noDataText_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function noDataText_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function noDataText_getPrototypeOf(o) { noDataText_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return noDataText_getPrototypeOf(o); }

function noDataText_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var DEFAULT_NO_DATA_TEXT = 'No data to display';

var NoDataText = /*#__PURE__*/function (_Component) {
  noDataText_inherits(NoDataText, _Component);

  var _super = noDataText_createSuper(NoDataText);

  function NoDataText() {
    var _this;

    noDataText_classCallCheck(this, NoDataText);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    noDataText_defineProperty(noDataText_assertThisInitialized(_this), "models", void 0);

    return _this;
  }

  noDataText_createClass(NoDataText, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'noDataText';
      this.name = 'noDataText';
    }
  }, {
    key: "getCenterPosition",
    value: function getCenterPosition(text, font) {
      var textWidth = getTextWidth(text, font);
      var textHeight = getTextHeight(text, font);
      return {
        x: (this.rect.width - textWidth) / 2,
        y: (this.rect.height - textHeight) / 2
      };
    }
  }, {
    key: "render",
    value: function render(_ref) {
      var _options$lang$noData, _options$lang;

      var layout = _ref.layout,
          series = _ref.series,
          options = _ref.options,
          theme = _ref.theme;
      var text = (_options$lang$noData = options === null || options === void 0 ? void 0 : (_options$lang = options.lang) === null || _options$lang === void 0 ? void 0 : _options$lang.noData) !== null && _options$lang$noData !== void 0 ? _options$lang$noData : DEFAULT_NO_DATA_TEXT;
      var labelTheme = theme.noData;
      var font = getTitleFontString(labelTheme);
      var fillStyle = labelTheme.color;
      this.isShow = isNoData(series);
      this.rect = layout.plot;
      this.models = [noDataText_objectSpread(noDataText_objectSpread({
        type: 'label'
      }, this.getCenterPosition(text, font)), {}, {
        text: text,
        style: [{
          font: font,
          fillStyle: fillStyle
        }]
      })];
    }
  }]);

  return NoDataText;
}(Component);


;// CONCATENATED MODULE: ./src/brushes/lineSeries.ts



function linePoints(ctx, pointsModel) {
  var strokeStyle = pointsModel.color,
      lineWidth = pointsModel.lineWidth,
      points = pointsModel.points,
      _pointsModel$dashSegm = pointsModel.dashSegments,
      dashSegments = _pointsModel$dashSegm === void 0 ? [] : _pointsModel$dashSegm;
  ctx.lineCap = 'round';
  ctx.beginPath();

  if (dashSegments) {
    setLineDash(ctx, dashSegments);
  }

  var start = false;
  points.forEach(function (point, idx) {
    var _points, _points$controlPoint;

    if (isNull(point)) {
      start = false;
      return;
    }

    if (!start) {
      ctx.moveTo(point.x, point.y);
      start = true;
      return;
    }

    if (point.controlPoint && (_points = points[idx - 1]) !== null && _points !== void 0 && (_points$controlPoint = _points.controlPoint) !== null && _points$controlPoint !== void 0 && _points$controlPoint.next) {
      var _next = points[idx - 1].controlPoint.next,
          prevX = _next.x,
          prevY = _next.y;
      var controlPoint = point.controlPoint,
          x = point.x,
          y = point.y;
      ctx.bezierCurveTo(prevX, prevY, controlPoint.prev.x, controlPoint.prev.y, x, y);
    } else {
      ctx.lineTo(point.x, point.y);
    }
  });
  strokeWithOptions(ctx, {
    lineWidth: lineWidth,
    strokeStyle: strokeStyle
  });
  ctx.closePath();
  setLineDash(ctx, []);
}
function areaPoints(ctx, areaPointsModel) {
  var fillColor = areaPointsModel.fillColor;
  ctx.beginPath();
  linePoints(ctx, areaPointsModel);
  fillStyle(ctx, fillColor);
  ctx.closePath();
}
;// CONCATENATED MODULE: ./src/brushes/exportMenu.ts
function exportMenu_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function exportMenu_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { exportMenu_ownKeys(Object(source), true).forEach(function (key) { brushes_exportMenu_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { exportMenu_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function brushes_exportMenu_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










function drawXIcon(ctx, icon, rectSize) {
  var startX = icon.x,
      startY = icon.y,
      _icon$theme = icon.theme,
      strokeStyle = _icon$theme.color,
      lineWidth = _icon$theme.lineWidth;
  var offset = rectSize / 3;
  var x = startX + offset;
  var y = startY + offset;
  var x2 = startX + offset * 2;
  var y2 = startY + offset * 2;
  var points = [{
    x: x,
    y: y,
    x2: x2,
    y2: y2
  }, {
    x: x,
    y: y2,
    x2: x2,
    y2: y
  }];
  points.forEach(function (p) {
    line(ctx, exportMenu_objectSpread(exportMenu_objectSpread({
      type: 'line'
    }, p), {}, {
      strokeStyle: strokeStyle,
      lineWidth: lineWidth
    }));
  });
}

function drawMoreIcon(ctx, icon, rectSize) {
  var x = icon.x,
      y = icon.y,
      _icon$theme2 = icon.theme,
      color = _icon$theme2.color,
      width = _icon$theme2.width,
      height = _icon$theme2.height,
      gap = _icon$theme2.gap;
  var paddingX = (rectSize - width) / 2;
  var paddingY = (rectSize - (height * 3 + gap * 2)) / 2;
  var centerX = x + paddingX;
  var points = [{
    x: centerX,
    y: y + paddingY
  }, {
    x: centerX,
    y: y + paddingY + height + gap
  }, {
    x: centerX,
    y: y + paddingY + (height + gap) * 2
  }];
  points.forEach(function (p) {
    rect(ctx, exportMenu_objectSpread(exportMenu_objectSpread({
      type: 'rect'
    }, p), {}, {
      color: color,
      width: width,
      height: height
    }));
  });
}

function exportMenuButton(ctx, exportMenuButtonModel) {
  var opened = exportMenuButtonModel.opened,
      xPos = exportMenuButtonModel.x,
      yPos = exportMenuButtonModel.y,
      theme = exportMenuButtonModel.theme;
  var _ref = theme,
      borderColor = _ref.borderColor,
      backgroundColor = _ref.backgroundColor,
      borderWidth = _ref.borderWidth,
      borderRadius = _ref.borderRadius,
      xIcon = _ref.xIcon,
      dotIcon = _ref.dotIcon;
  var x = xPos + borderWidth;
  var y = yPos + borderWidth;
  var rectSize = BUTTON_RECT_SIZE - 2 * borderWidth;
  pathRect(ctx, {
    type: 'pathRect',
    x: x,
    y: y,
    fill: backgroundColor,
    stroke: borderColor,
    width: rectSize,
    height: rectSize,
    radius: borderRadius,
    lineWidth: borderWidth
  });

  if (opened) {
    drawXIcon(ctx, {
      x: x,
      y: y,
      theme: xIcon
    }, rectSize);
  } else {
    drawMoreIcon(ctx, {
      x: x,
      y: y,
      theme: dotIcon
    }, rectSize);
  }
}
;// CONCATENATED MODULE: ./src/brushes/resetButton.ts



var ARROW_HEIGHT = 3;
var ARROW_WIDTH = 6;

function drawResetIcon(ctx, point) {
  var x = point.x,
      y = point.y;
  var centerX = x + BUTTON_RECT_SIZE / 2;
  var centerY = y + BUTTON_RECT_SIZE / 2;
  var tickSize = BUTTON_RECT_SIZE / 10;
  var color = '#545454';
  circle(ctx, {
    type: 'circle',
    x: centerX,
    y: centerY,
    radius: tickSize * 2,
    angle: {
      start: 0,
      end: Math.PI / 2
    },
    color: 'transparent',
    style: [{
      lineWidth: 2,
      strokeStyle: color
    }]
  });
  var pointStartX = centerX + tickSize * 2;
  var pointStartY = centerY;
  var points = [{
    x: pointStartX - ARROW_WIDTH / 2,
    y: pointStartY
  }, {
    x: pointStartX + ARROW_WIDTH / 2,
    y: pointStartY
  }, {
    x: pointStartX,
    y: pointStartY + ARROW_HEIGHT
  }];
  areaPoints(ctx, {
    type: 'areaPoints',
    points: points,
    lineWidth: 1,
    color: color,
    fillColor: color
  });
}

function drawBackIcon(ctx, point) {
  var barWidth = 4;
  var radius = BUTTON_RECT_SIZE / 7;
  var x = point.x,
      y = point.y;
  var centerX = x + BUTTON_RECT_SIZE / 2;
  var centerY = y + BUTTON_RECT_SIZE / 2;
  var color = '#545454';
  line(ctx, {
    type: 'line',
    lineWidth: 2,
    x: centerX - barWidth / 2,
    y: centerY + radius,
    x2: centerX + barWidth / 2,
    y2: centerY + radius,
    strokeStyle: color
  });
  line(ctx, {
    type: 'line',
    lineWidth: 2,
    x: centerX - barWidth / 2,
    y: centerY - radius,
    x2: centerX + barWidth / 2,
    y2: centerY - radius,
    strokeStyle: color
  });
  circle(ctx, {
    type: 'circle',
    x: centerX + barWidth / 2,
    y: centerY,
    radius: radius,
    angle: {
      start: Math.PI / 2,
      end: Math.PI * 3 / 2
    },
    color: 'transparent',
    style: [{
      lineWidth: 2,
      strokeStyle: color
    }]
  });
  var pointStartX = centerX - barWidth / 2;
  var pointStartY = centerY - radius;
  var points = [{
    x: pointStartX - ARROW_HEIGHT,
    y: pointStartY
  }, {
    x: pointStartX,
    y: pointStartY - ARROW_WIDTH / 2
  }, {
    x: pointStartX,
    y: pointStartY + ARROW_WIDTH / 2
  }];
  areaPoints(ctx, {
    type: 'areaPoints',
    points: points,
    lineWidth: 1,
    color: color,
    fillColor: color
  });
}

function backButton(ctx, backButtonModel) {
  var x = backButtonModel.x,
      y = backButtonModel.y;
  pathRect(ctx, {
    type: 'pathRect',
    x: x,
    y: y,
    fill: '#f4f4f4',
    stroke: '#f4f4f4',
    width: BUTTON_RECT_SIZE,
    height: BUTTON_RECT_SIZE,
    radius: 5
  });
  drawBackIcon(ctx, {
    x: x,
    y: y
  });
}
function resetButton(ctx, resetButtonModel) {
  var x = resetButtonModel.x,
      y = resetButtonModel.y;
  pathRect(ctx, {
    type: 'pathRect',
    x: x,
    y: y,
    fill: '#f4f4f4',
    stroke: '#f4f4f4',
    width: BUTTON_RECT_SIZE,
    height: BUTTON_RECT_SIZE,
    radius: 5
  });
  drawResetIcon(ctx, {
    x: x,
    y: y
  });
}
;// CONCATENATED MODULE: ./src/charts/lineChart.ts
function lineChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { lineChart_typeof = function _typeof(obj) { return typeof obj; }; } else { lineChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return lineChart_typeof(obj); }


















function lineChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function lineChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { lineChart_ownKeys(Object(source), true).forEach(function (key) { lineChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { lineChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function lineChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function lineChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function lineChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function lineChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) lineChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) lineChart_defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = lineChart_getPrototypeOf(object); if (object === null) break; } return object; }

function lineChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) lineChart_setPrototypeOf(subClass, superClass); }

function lineChart_setPrototypeOf(o, p) { lineChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return lineChart_setPrototypeOf(o, p); }

function lineChart_createSuper(Derived) { var hasNativeReflectConstruct = lineChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = lineChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = lineChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return lineChart_possibleConstructorReturn(this, result); }; }

function lineChart_possibleConstructorReturn(self, call) { if (call && (lineChart_typeof(call) === "object" || typeof call === "function")) { return call; } return lineChart_assertThisInitialized(self); }

function lineChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function lineChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function lineChart_getPrototypeOf(o) { lineChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return lineChart_getPrototypeOf(o); }






























/**
 * @class
 * @classdesc Line Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Line Chart.
 *     @param {Array<string>} [props.data.categories] - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<number|Object|Array>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Line Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.showDot=false] - Whether to show dot or not.
 *       @param {boolean} [props.options.series.spline=false] - Whether to make spline chart or not.
 *       @param {boolean} [props.options.series.zoomable=false] - Whether to use zoom feature or not.
 *       @param {boolean} [props.options.series.rangeSelectable=false] - Whether to use range selection feature or not.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'near', 'nearest', 'grouped', 'point' is available.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.pointOnColumn=false] - Whether to move the start of the chart to the center of the column.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *       @param {Array<Object>} [props.options.plot.lines] - Plot lines information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *       @param {Array<Object>} [props.options.plot.bands] - Plot bands information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Line Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var LineChart = /*#__PURE__*/function (_Chart) {
  lineChart_inherits(LineChart, _Chart);

  var _super = lineChart_createSuper(LineChart);

  function LineChart(props) {
    var _props$data;

    lineChart_classCallCheck(this, LineChart);

    return _super.call(this, {
      el: props.el,
      options: props.options,
      series: {
        line: props.data.series
      },
      categories: (_props$data = props.data) === null || _props$data === void 0 ? void 0 : _props$data.categories,
      modules: [store_dataRange, store_scale, store_axes, store_plot]
    });
  }

  lineChart_createClass(LineChart, [{
    key: "initialize",
    value: function initialize() {
      _get(lineChart_getPrototypeOf(LineChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Plot);
      this.componentManager.add(Legend);
      this.componentManager.add(LineSeries);
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(Axis, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(DataLabels);
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(RangeSelection);
      this.componentManager.add(ResetButton);
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, brushes_lineSeries_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, brushes_resetButton_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array<number|Object|Array>} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */

  }, {
    key: "addData",
    value: function addData(data, category) {
      var _this$store$state$opt;

      if ((_this$store$state$opt = this.store.state.options.series) !== null && _this$store$state$opt !== void 0 && _this$store$state$opt.showDot) {
        this.animationControlFlag.updating = true;
      }

      this.resetSeries();
      this.store.dispatch('addData', {
        data: data,
        category: category
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number|Object|Array>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          line: series
        },
        categories: categories
      });
    }
    /**
     * Add plot line.
     * @param {Object} data - Plot info.
     *    @param {string|number} data.value - The value where the plot line will be drawn.
     *    @param {string} data.color - Plot line color.
     *    @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
     * @api
     * @example
     * chart.addPlotLine({
     *   value: 2,
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotLine",
    value: function addPlotLine(data) {
      this.store.dispatch('addPlotLine', {
        data: data
      });
    }
    /**
     * Remove plot line with id.
     * @param {string} id - Id of the plot line to be removed.
     * @api
     * @example
     * chart.removePlotLine('plot-1');
     */

  }, {
    key: "removePlotLine",
    value: function removePlotLine(id) {
      this.store.dispatch('removePlotLine', {
        id: id
      });
    }
    /**
     * Add plot band.
     * @param {Object} data - Plot info.
     *   @param {Array<string|number>} data.range - The range to be drawn.
     *   @param {string} data.color - Plot band color.
     *   @param {string} [data.id] - Plot id. The value on which the removePlotBand is based.
     * @api
     * @example
     * chart.addPlotBand({
     *   value: [2, 4],
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotBand",
    value: function addPlotBand(data) {
      this.store.dispatch('addPlotBand', {
        data: data
      });
    }
    /**
     * Remove plot band with id.
     * @param {string} id - id of the plot band to be removed
     * @api
     * @example
     * chart.removePlotBand('plot-1');
     */

  }, {
    key: "removePlotBand",
    value: function removePlotBand(id) {
      this.store.dispatch('removePlotBand', {
        id: id
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only seriesIndex is needed.
     *      @param {number} [seriesInfo.seriesIndex] - Index of series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', lineChart_objectSpread({}, seriesInfo));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return LineChart;
}(Chart);


;// CONCATENATED MODULE: ./src/component/pieSeries.ts
function pieSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { pieSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { pieSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return pieSeries_typeof(obj); }

function pieSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function pieSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { pieSeries_ownKeys(Object(source), true).forEach(function (key) { pieSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { pieSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function pieSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function pieSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function pieSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) pieSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) pieSeries_defineProperties(Constructor, staticProps); return Constructor; }

function pieSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) pieSeries_setPrototypeOf(subClass, superClass); }

function pieSeries_setPrototypeOf(o, p) { pieSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return pieSeries_setPrototypeOf(o, p); }

function pieSeries_createSuper(Derived) { var hasNativeReflectConstruct = pieSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = pieSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = pieSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return pieSeries_possibleConstructorReturn(this, result); }; }

function pieSeries_possibleConstructorReturn(self, call) { if (call && (pieSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return pieSeries_assertThisInitialized(self); }

function pieSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function pieSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function pieSeries_getPrototypeOf(o) { pieSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return pieSeries_getPrototypeOf(o); }

function pieSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




































function getCalculatedRadiusRange(_ref) {
  var alias = _ref.alias,
      renderOptions = _ref.renderOptions,
      radiusRangeMap = _ref.radiusRangeMap,
      pieIndex = _ref.pieIndex,
      radiusRanges = _ref.radiusRanges,
      totalPieAliasCount = _ref.totalPieAliasCount;
  var radiusRangeLength = Object.keys(radiusRangeMap).length;
  var _renderOptions$defaul = renderOptions.defaultRadius,
      defaultRadius = _renderOptions$defaul === void 0 ? 0 : _renderOptions$defaul;
  var _renderOptions$radius = renderOptions.radiusRange,
      inner = _renderOptions$radius.inner,
      outer = _renderOptions$radius.outer;

  if (!radiusRangeMap[alias]) {
    if (!radiusRangeLength) {
      var radius = defaultRadius / totalPieAliasCount;
      inner = pieIndex * radius;
      outer = (pieIndex + 1) * radius;
    } else {
      var _radiusRanges;

      if (pieIndex && radiusRanges[pieIndex - 1].outer) {
        inner = radiusRanges[pieIndex - 1].outer;
      }

      if ((_radiusRanges = radiusRanges[pieIndex + 1]) !== null && _radiusRanges !== void 0 && _radiusRanges.inner) {
        outer = radiusRanges[pieIndex + 1].inner;
      } else if (pieIndex === totalPieAliasCount - 1) {
        outer = defaultRadius;
      } else {
        var _radiusRanges$outer, _radiusRanges2, _radiusRanges$inner, _radiusRanges3;

        var _radius = (defaultRadius - ((_radiusRanges$outer = (_radiusRanges2 = radiusRanges[pieIndex - 1]) === null || _radiusRanges2 === void 0 ? void 0 : _radiusRanges2.outer) !== null && _radiusRanges$outer !== void 0 ? _radiusRanges$outer : 0) - ((_radiusRanges$inner = (_radiusRanges3 = radiusRanges[pieIndex + 1]) === null || _radiusRanges3 === void 0 ? void 0 : _radiusRanges3.inner) !== null && _radiusRanges$inner !== void 0 ? _radiusRanges$inner : 0)) / (totalPieAliasCount - radiusRangeLength);

        outer = inner + _radius;
      }
    }
  }

  return {
    inner: inner,
    outer: outer
  };
}

function getPieSeriesOpacityByDepth(originAlpha, depth, indexOfGroup) {
  var brightness = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.85;
  var depthAlpha = Number((originAlpha * Math.pow(brightness, depth)).toFixed(2));
  return Number(Math.pow(depthAlpha, indexOfGroup + 1).toFixed(2));
}

function getMaxDataLabelSize(seriesNameLabels, options, dataLabelTheme) {
  var _options$pieSeriesNam, _options$pieSeriesNam2;

  var outerLabels = [{
    hasOuterLabel: options.visible && options.anchor === 'outer',
    labels: ['00.00%'],
    // up to 5 digits
    theme: dataLabelTheme
  }, {
    hasOuterLabel: ((_options$pieSeriesNam = options.pieSeriesName) === null || _options$pieSeriesNam === void 0 ? void 0 : _options$pieSeriesNam.visible) && ((_options$pieSeriesNam2 = options.pieSeriesName) === null || _options$pieSeriesNam2 === void 0 ? void 0 : _options$pieSeriesNam2.anchor) === 'outer',
    labels: seriesNameLabels,
    theme: dataLabelTheme.pieSeriesName
  }];
  return outerLabels.reduce(function (acc, cur) {
    var width = acc.width,
        height = acc.height;
    var hasOuterLabel = cur.hasOuterLabel,
        labels = cur.labels,
        theme = cur.theme;

    if (hasOuterLabel) {
      var _getMaxLabelSize = getMaxLabelSize(labels, 0, getFont(theme)),
          maxLabelWidth = _getMaxLabelSize.maxLabelWidth,
          maxLabelHeight = _getMaxLabelSize.maxLabelHeight;

      return {
        width: Math.max(maxLabelWidth + RADIUS_PADDING, width),
        height: Math.max(maxLabelHeight + RADIUS_PADDING, height)
      };
    }

    return acc;
  }, {
    width: 0,
    height: 0
  });
}

var PieSeries = /*#__PURE__*/function (_Component) {
  pieSeries_inherits(PieSeries, _Component);

  var _super = pieSeries_createSuper(PieSeries);

  function PieSeries() {
    var _this;

    pieSeries_classCallCheck(this, PieSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "models", {
      series: []
    });

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "drawModels", void 0);

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "responders", void 0);

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "activatedResponders", []);

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "alias", void 0);

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "theme", void 0);

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.alias || _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.alias || _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "selectSeries", function (_ref2) {
      var seriesIndex = _ref2.seriesIndex,
          name = _ref2.name;

      if (!isNumber(seriesIndex) || !isUndefined(name) && name !== _this.alias) {
        return;
      }

      var model = _this.responders[seriesIndex];

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: _this.getResponderModelsWithTheme([model], 'select'),
        name: _this.name,
        alias: _this.alias
      });

      _this.eventBus.emit('needDraw');
    });

    pieSeries_defineProperty(pieSeries_assertThisInitialized(_this), "showTooltip", function (_ref3) {
      var seriesIndex = _ref3.seriesIndex,
          name = _ref3.name;

      if (!isNumber(seriesIndex) || !isUndefined(name) && name !== _this.alias) {
        return;
      }

      var models = [_this.responders[seriesIndex]];

      if (!models.length) {
        return;
      }

      _this.eventBus.emit('renderHoveredSeries', {
        models: _this.getResponderModelsWithTheme(models, 'hover'),
        name: _this.name,
        alias: _this.alias
      });

      _this.activatedResponders = _this.makeTooltipResponder(models);

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.alias || _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  pieSeries_createClass(PieSeries, [{
    key: "initUpdate",
    value: function initUpdate(delta) {
      if (!this.drawModels) {
        return;
      }

      var currentDegree;
      var index = this.models.series.findIndex(function (_ref4) {
        var clockwise = _ref4.clockwise,
            _ref4$degree = _ref4.degree,
            start = _ref4$degree.start,
            end = _ref4$degree.end,
            totalAngle = _ref4.totalAngle;
        currentDegree = clockwise ? totalAngle * delta : DEGREE_360 - totalAngle * delta;
        return withinRadian(clockwise, start, end, currentDegree);
      });
      this.syncEndAngle(index < 0 ? this.models.series.length : index);

      if (~index) {
        this.drawModels.series[index].degree.end = currentDegree;
      }
    }
  }, {
    key: "syncEndAngle",
    value: function syncEndAngle(index) {
      if (index < 1) {
        return;
      }

      for (var i = 0; i < index; i += 1) {
        var prevTargetEndDegree = this.models.series[i].degree.end;

        if (this.drawModels.series[i].degree.end !== prevTargetEndDegree) {
          this.drawModels.series[i].degree.end = prevTargetEndDegree;
        }
      }
    }
  }, {
    key: "initialize",
    value: function initialize(param) {
      var _param$alias;

      this.type = 'series';
      this.name = 'pie';
      this.alias = (_param$alias = param === null || param === void 0 ? void 0 : param.alias) !== null && _param$alias !== void 0 ? _param$alias : '';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "render",
    value: function render(chartState) {
      var _ref5,
          _this2 = this;

      var layout = chartState.layout,
          series = chartState.series,
          legend = chartState.legend,
          options = chartState.options,
          nestedPieSeries = chartState.nestedPieSeries,
          theme = chartState.theme;
      var categories = (_ref5 = chartState.categories) !== null && _ref5 !== void 0 ? _ref5 : [];

      if (!series.pie) {
        throw new Error(message.noDataError(this.name));
      }

      var pieTheme = theme.series.pie;
      this.theme = this.alias ? pieTheme[this.alias] : pieTheme;
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      var seriesModel, tooltipDataModel;
      var dataLabelsOptions = getDataLabelsOptions(options, this.alias);

      if (nestedPieSeries) {
        var data = nestedPieSeries[this.alias].data;
        var pieAlias = Object.keys(nestedPieSeries);
        var pieIndex = pieAlias.findIndex(function (alias) {
          return alias === _this2.alias;
        }); // check the data label of the last Pie series

        var lastAlias = last(pieAlias);
        var lastSeries = nestedPieSeries[lastAlias];
        var maxPieDataLabelSize = getMaxDataLabelSize(lastSeries.data.map(function (_ref6) {
          var name = _ref6.name;
          return name;
        }), getDataLabelsOptions(options, lastAlias), this.theme.dataLabels);
        var renderOptionsMap = this.getRenderOptionsMap(options, pieAlias, maxPieDataLabelSize);
        seriesModel = this.renderPieModel(data, renderOptionsMap[this.alias], pieIndex);
        tooltipDataModel = makePieTooltipData(data, categories === null || categories === void 0 ? void 0 : categories[pieIndex]);
      } else {
        var _series$pie;

        var pieData = (_series$pie = series.pie) === null || _series$pie === void 0 ? void 0 : _series$pie.data;

        var _getMaxDataLabelSize = getMaxDataLabelSize(pieData.map(function (_ref7) {
          var name = _ref7.name;
          return name;
        }), dataLabelsOptions, this.theme.dataLabels),
            width = _getMaxDataLabelSize.width,
            height = _getMaxDataLabelSize.height;

        var renderOptions = this.makeRenderOptions(options, width, height);
        seriesModel = this.renderPieModel(pieData, renderOptions);
        tooltipDataModel = makePieTooltipData(pieData, categories === null || categories === void 0 ? void 0 : categories[0]);
      }

      this.models.series = seriesModel;

      if (!this.drawModels) {
        this.drawModels = {
          series: this.models.series.map(function (m) {
            return pieSeries_objectSpread(pieSeries_objectSpread({}, m), {}, {
              degree: pieSeries_objectSpread(pieSeries_objectSpread({}, m.degree), {}, {
                end: m.degree.start
              })
            });
          })
        };
      }

      if (dataLabelsOptions.visible) {
        var dataLabelData = seriesModel.map(function (m) {
          return pieSeries_objectSpread(pieSeries_objectSpread({}, m), {}, {
            value: "".concat(pieTooltipLabelFormatter(m.percentValue)),
            theme: _this2.theme.dataLabels
          });
        });
        this.renderDataLabels(dataLabelData, this.alias);
      }

      this.responders = seriesModel.map(function (m, index) {
        return pieSeries_objectSpread(pieSeries_objectSpread({}, m), {}, {
          type: 'sector',
          radius: m.radius,
          seriesIndex: index,
          data: pieSeries_objectSpread(pieSeries_objectSpread({}, tooltipDataModel[index]), {}, {
            percentValue: m.percentValue
          }),
          color: getRGBA(m.color, 1)
        });
      });
    }
  }, {
    key: "getRadiusRangeMap",
    value: function getRadiusRangeMap(options, pieAlias) {
      var _this3 = this;

      return pieAlias.reduce(function (acc, alias) {
        var seriesOptions = _this3.getOptions(options, alias).series;

        if (seriesOptions !== null && seriesOptions !== void 0 && seriesOptions.radiusRange) {
          acc[alias] = seriesOptions === null || seriesOptions === void 0 ? void 0 : seriesOptions.radiusRange;
        }

        return acc;
      }, {});
    }
  }, {
    key: "getRenderOptionsMap",
    value: function getRenderOptionsMap(options, pieAlias, maxPieDataLabelSize) {
      var renderOptionsMap = this.initRenderOptionsMap(options, pieAlias, maxPieDataLabelSize);
      var radiusRangeMap = this.getRadiusRangeMap(options, pieAlias);
      pieAlias.forEach(function (alias, pieIndex) {
        var radiusRanges = Object.values(renderOptionsMap).map(function (_ref8) {
          var radiusRange = _ref8.radiusRange;
          return radiusRange;
        });
        renderOptionsMap[alias].radiusRange = getCalculatedRadiusRange({
          alias: alias,
          renderOptions: renderOptionsMap[alias],
          radiusRangeMap: radiusRangeMap,
          pieIndex: pieIndex,
          radiusRanges: radiusRanges,
          totalPieAliasCount: pieAlias.length
        });
      });
      return renderOptionsMap;
    }
  }, {
    key: "initRenderOptionsMap",
    value: function initRenderOptionsMap(options, pieAlias, _ref9) {
      var _this4 = this;

      var width = _ref9.width,
          height = _ref9.height;
      return pieAlias.reduce(function (acc, alias) {
        return pieSeries_objectSpread(pieSeries_objectSpread({}, acc), {}, pieSeries_defineProperty({}, alias, _this4.makeRenderOptions(_this4.getOptions(options, alias), width, height)));
      }, {});
    }
  }, {
    key: "getOptions",
    value: function getOptions(chartOptions, alias) {
      var options = pieSeries_objectSpread({}, chartOptions);

      if (options !== null && options !== void 0 && options.series && alias) {
        options.series = pieSeries_objectSpread(pieSeries_objectSpread({}, options.series), options.series[alias]);
      }

      return options;
    }
  }, {
    key: "makeRenderOptions",
    value: function makeRenderOptions(options) {
      var _seriesOptions$clockw, _seriesOptions$angleR, _seriesOptions$angleR2, _seriesOptions$angleR3, _seriesOptions$angleR4, _seriesOptions$radius, _seriesOptions$radius2, _seriesOptions$radius3, _seriesOptions$radius4;

      var maxDataLabelWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var maxDataLabelHeight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var seriesOptions = options.series;
      var clockwise = (_seriesOptions$clockw = seriesOptions === null || seriesOptions === void 0 ? void 0 : seriesOptions.clockwise) !== null && _seriesOptions$clockw !== void 0 ? _seriesOptions$clockw : true;
      var startAngle = (_seriesOptions$angleR = seriesOptions === null || seriesOptions === void 0 ? void 0 : (_seriesOptions$angleR2 = seriesOptions.angleRange) === null || _seriesOptions$angleR2 === void 0 ? void 0 : _seriesOptions$angleR2.start) !== null && _seriesOptions$angleR !== void 0 ? _seriesOptions$angleR : DEGREE_0;
      var endAngle = (_seriesOptions$angleR3 = seriesOptions === null || seriesOptions === void 0 ? void 0 : (_seriesOptions$angleR4 = seriesOptions.angleRange) === null || _seriesOptions$angleR4 === void 0 ? void 0 : _seriesOptions$angleR4.end) !== null && _seriesOptions$angleR3 !== void 0 ? _seriesOptions$angleR3 : DEGREE_360;
      var totalAngle = getTotalAngle(clockwise, startAngle, endAngle);
      var isSemiCircular = isSemiCircle(clockwise, startAngle, endAngle);
      var _this$rect = this.rect,
          width = _this$rect.width,
          height = _this$rect.height;
      var defaultRadius = getDefaultRadius(this.rect, isSemiCircular, maxDataLabelWidth, maxDataLabelHeight);
      var innerRadius = calculateSizeWithPercentString(defaultRadius, (_seriesOptions$radius = seriesOptions === null || seriesOptions === void 0 ? void 0 : (_seriesOptions$radius2 = seriesOptions.radiusRange) === null || _seriesOptions$radius2 === void 0 ? void 0 : _seriesOptions$radius2.inner) !== null && _seriesOptions$radius !== void 0 ? _seriesOptions$radius : 0);
      var outerRadius = calculateSizeWithPercentString(defaultRadius, (_seriesOptions$radius3 = seriesOptions === null || seriesOptions === void 0 ? void 0 : (_seriesOptions$radius4 = seriesOptions.radiusRange) === null || _seriesOptions$radius4 === void 0 ? void 0 : _seriesOptions$radius4.outer) !== null && _seriesOptions$radius3 !== void 0 ? _seriesOptions$radius3 : this.alias ? 0 : defaultRadius);
      var cx = width / 2;
      var cy = isSemiCircular ? getSemiCircleCenterY(this.rect.height, clockwise) : height / 2;
      return {
        clockwise: clockwise,
        cx: cx,
        cy: cy,
        drawingStartAngle: startAngle - DEGREE_90,
        radiusRange: {
          inner: innerRadius,
          outer: outerRadius
        },
        angleRange: {
          start: startAngle,
          end: endAngle
        },
        totalAngle: totalAngle,
        defaultRadius: defaultRadius
      };
    }
  }, {
    key: "renderPieModel",
    value: function renderPieModel(seriesRawData, renderOptions, pieIndex) {
      var _this5 = this;

      var sectorModels = [];
      var total = seriesRawData.reduce(function (sum, _ref10) {
        var data = _ref10.data;
        return sum + (data !== null && data !== void 0 ? data : 0);
      }, 0);
      var clockwise = renderOptions.clockwise,
          cx = renderOptions.cx,
          cy = renderOptions.cy,
          drawingStartAngle = renderOptions.drawingStartAngle,
          _renderOptions$radius2 = renderOptions.radiusRange,
          inner = _renderOptions$radius2.inner,
          outer = _renderOptions$radius2.outer,
          totalAngle = renderOptions.totalAngle;
      var defaultStartDegree = clockwise ? DEGREE_0 : DEGREE_360;
      var _this$theme = this.theme,
          lineWidth = _this$theme.lineWidth,
          strokeStyle = _this$theme.strokeStyle;
      seriesRawData.forEach(function (rawData, seriesIndex) {
        var color = _this5.alias ? _this5.getAliasSeriesColor(rawData, seriesRawData, pieIndex) : _this5.getSeriesColor(rawData);
        var data = rawData.data,
            name = rawData.name;

        if (data) {
          var degree = Math.max(data / total * totalAngle, 1) * (clockwise ? 1 : -1);
          var percentValue = data / total * 100;
          var prevModel = sectorModels[sectorModels.length - 1];
          var startDegree = seriesIndex && prevModel ? prevModel.degree.end : defaultStartDegree;
          var endDegree = clockwise ? Math.min(startDegree + degree, DEGREE_360) : Math.max(startDegree + degree, DEGREE_0);
          sectorModels.push({
            type: 'sector',
            name: name,
            color: color,
            x: cx,
            y: cy,
            degree: {
              start: startDegree,
              end: endDegree
            },
            radius: {
              inner: inner,
              outer: outer
            },
            value: data,
            style: [{
              strokeStyle: strokeStyle
            }],
            lineWidth: lineWidth,
            clockwise: clockwise,
            drawingStartAngle: drawingStartAngle,
            totalAngle: totalAngle,
            percentValue: percentValue
          });
        }
      });
      return sectorModels;
    }
  }, {
    key: "makeTooltipResponder",
    value: function makeTooltipResponder(responders) {
      var _this6 = this;

      return responders.map(function (responder) {
        return pieSeries_objectSpread(pieSeries_objectSpread({}, responder), getRadialAnchorPosition(makeAnchorPositionParam('center', _this6.models.series[responder.seriesIndex])));
      });
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref11) {
      var responders = _ref11.responders;
      this.eventBus.emit('renderHoveredSeries', {
        models: this.getResponderModelsWithTheme(responders, 'hover'),
        name: this.alias || this.name
      });
      this.activatedResponders = this.makeTooltipResponder(responders);
      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.alias || this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "onClick",
    value: function onClick(_ref12) {
      var responders = _ref12.responders;

      if (this.selectable) {
        this.eventBus.emit('renderSelectedSeries', {
          models: this.getResponderModelsWithTheme(responders, 'select'),
          name: this.name,
          alias: this.alias
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "getResponderModelsWithTheme",
    value: function getResponderModelsWithTheme(responders, type) {
      var theme = this.theme[type];
      var lineWidth = theme.lineWidth;
      var isSameLineWidth = this.theme.lineWidth === lineWidth;
      var thickness = isSameLineWidth ? 0 : lineWidth * 0.5;
      return responders.map(function (m) {
        var _theme$color;

        return pieSeries_objectSpread(pieSeries_objectSpread({}, m), {}, {
          color: (_theme$color = theme === null || theme === void 0 ? void 0 : theme.color) !== null && _theme$color !== void 0 ? _theme$color : m.color,
          lineWidth: lineWidth,
          style: [pick(theme, 'strokeStyle', 'shadowBlur', 'shadowColor', 'shadowOffsetX', 'shadowOffsetY')],
          radius: {
            inner: Math.max(m.radius.inner - thickness, 0),
            outer: m.radius.outer + thickness
          }
        });
      });
    }
  }, {
    key: "getOpacity",
    value: function getOpacity(active, selectedState) {
      var _this$theme2 = this.theme,
          select = _this$theme2.select,
          areaOpacity = _this$theme2.areaOpacity;
      var _ref13 = select,
          selectedAreaOpacity = _ref13.areaOpacity,
          restAreaOpacity = _ref13.restSeries.areaOpacity;
      var selectThemeOpacity = active ? selectedAreaOpacity : restAreaOpacity;
      return selectedState ? selectThemeOpacity : areaOpacity;
    }
  }, {
    key: "getIndexOfGroup",
    value: function getIndexOfGroup(seriesRawData, parentName, name) {
      return seriesRawData.filter(function (datum) {
        return parentName === datum.parentName;
      }).findIndex(function (datum) {
        return name === datum.name;
      });
    }
  }, {
    key: "getSeriesColor",
    value: function getSeriesColor(rawData) {
      var color = rawData.color,
          name = rawData.name;
      var active = this.activeSeriesMap[name];
      var opacity = this.getOpacity(active, this.hasActiveSeries());
      return getRGBA(color, opacity);
    }
  }, {
    key: "getAliasSeriesColor",
    value: function getAliasSeriesColor(rawData, seriesRawData, pieIndex) {
      var color = rawData.color,
          name = rawData.name;
      var selectedColor = this.theme.select.color;
      var rootParentName = rawData.rootParentName,
          parentName = rawData.parentName;
      var indexOfGroup = this.getIndexOfGroup(seriesRawData, parentName, name);
      var opacity = this.getAliasSeriesOpacity(rootParentName, parentName, pieIndex, indexOfGroup, name);
      var active = this.activeSeriesMap[rootParentName !== null && rootParentName !== void 0 ? rootParentName : name];
      var seriesColor = active ? selectedColor !== null && selectedColor !== void 0 ? selectedColor : color : color;
      return getRGBA(seriesColor, opacity);
    }
  }, {
    key: "getAliasSeriesOpacity",
    value: function getAliasSeriesOpacity(rootParentName, parentName, pieIndex, indexOfGroup, name) {
      var active = this.activeSeriesMap[rootParentName !== null && rootParentName !== void 0 ? rootParentName : name];
      var opacity = this.getOpacity(active, this.hasActiveSeries());
      return pieIndex && parentName ? getPieSeriesOpacityByDepth(opacity, pieIndex, indexOfGroup) : opacity;
    }
  }, {
    key: "hasActiveSeries",
    value: function hasActiveSeries() {
      return Object.values(this.activeSeriesMap).some(function (elem) {
        return !elem;
      });
    }
  }]);

  return PieSeries;
}(Component);


;// CONCATENATED MODULE: ./src/brushes/sector.ts




function sector(ctx, sectorModel) {
  var _sectorModel$degree = sectorModel.degree,
      start = _sectorModel$degree.start,
      end = _sectorModel$degree.end,
      color = sectorModel.color,
      style = sectorModel.style,
      lineWidth = sectorModel.lineWidth;

  if (start === end) {
    return;
  }

  var isCircle = Math.abs(start - end) === DEGREE_360;
  ctx.beginPath();

  if (style) {
    var styleObj = makeStyleObj(style, {});
    Object.keys(styleObj).forEach(function (key) {
      ctx[key] = styleObj[key];
    });
  }

  if (isCircle) {
    drawCircle(ctx, sectorModel);
  } else {
    drawSector(ctx, sectorModel);
  }

  ctx.closePath();
  fillStyle(ctx, color);

  if (lineWidth) {
    ctx.lineWidth = lineWidth;
    ctx.stroke();
  }
}

function drawSector(ctx, sectorModel) {
  var x = sectorModel.x,
      y = sectorModel.y,
      _sectorModel$radius = sectorModel.radius,
      inner = _sectorModel$radius.inner,
      outer = _sectorModel$radius.outer,
      _sectorModel$degree2 = sectorModel.degree,
      start = _sectorModel$degree2.start,
      end = _sectorModel$degree2.end,
      clockwise = sectorModel.clockwise,
      drawingStartAngle = sectorModel.drawingStartAngle;

  if (inner < 0 || outer < 0) {
    return;
  }

  var startRadian = calculateDegreeToRadian(start, drawingStartAngle);
  var endRadian = calculateDegreeToRadian(end, drawingStartAngle);

  if (!inner) {
    ctx.moveTo(x, y);
  }

  ctx.arc(x, y, outer, startRadian, endRadian, !clockwise);

  if (inner) {
    ctx.arc(x, y, inner, endRadian, startRadian, clockwise);
  }
}

function drawCircle(ctx, sectorModel) {
  var x = sectorModel.x,
      y = sectorModel.y,
      _sectorModel$radius2 = sectorModel.radius,
      inner = _sectorModel$radius2.inner,
      outer = _sectorModel$radius2.outer,
      clockwise = sectorModel.clockwise;
  ctx.arc(x, y, outer, 0, 2 * Math.PI, !clockwise);

  if (inner) {
    var _getRadialPosition = getRadialPosition(x, y, inner, 0),
        innerStartPosX = _getRadialPosition.x,
        innerStartPosY = _getRadialPosition.y;

    var startX = inner ? innerStartPosX : x;
    var startY = inner ? innerStartPosY : y;
    ctx.moveTo(startX, startY);
    ctx.arc(x, y, inner, 0, 2 * Math.PI, clockwise);
  }
}
;// CONCATENATED MODULE: ./src/charts/pieChart.ts
function pieChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { pieChart_typeof = function _typeof(obj) { return typeof obj; }; } else { pieChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return pieChart_typeof(obj); }


















function pieChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function pieChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { pieChart_ownKeys(Object(source), true).forEach(function (key) { pieChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { pieChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function pieChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function pieChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function pieChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function pieChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) pieChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) pieChart_defineProperties(Constructor, staticProps); return Constructor; }

function pieChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { pieChart_get = Reflect.get; } else { pieChart_get = function _get(target, property, receiver) { var base = pieChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return pieChart_get(target, property, receiver || target); }

function pieChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = pieChart_getPrototypeOf(object); if (object === null) break; } return object; }

function pieChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) pieChart_setPrototypeOf(subClass, superClass); }

function pieChart_setPrototypeOf(o, p) { pieChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return pieChart_setPrototypeOf(o, p); }

function pieChart_createSuper(Derived) { var hasNativeReflectConstruct = pieChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = pieChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = pieChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return pieChart_possibleConstructorReturn(this, result); }; }

function pieChart_possibleConstructorReturn(self, call) { if (call && (pieChart_typeof(call) === "object" || typeof call === "function")) { return call; } return pieChart_assertThisInitialized(self); }

function pieChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function pieChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function pieChart_getPrototypeOf(o) { pieChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return pieChart_getPrototypeOf(o); }



















/**
 * @class
 * @classdesc Pie Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Pie Chart.
 *     @param {Array<string>} [props.data.categories] - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {number} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Pie Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *       @param {Array<number>|Array<string>} [props.options.series.radiusRange] - Specifies the radius of the circle drawn. It is specified by entering a number or percent string value in start and end.
 *       @param {Array<number>} [props.options.series.angleRange] - The range of angles to which the circle will be drawn. It is specified by putting number in start and end.
 *       @param {boolean} [props.options.series.clockwise] - Whether it will be drawn clockwise.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Pie Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var PieChart = /*#__PURE__*/function (_Chart) {
  pieChart_inherits(PieChart, _Chart);

  var _super = pieChart_createSuper(PieChart);

  function PieChart(_ref) {
    var el = _ref.el,
        options = _ref.options,
        data = _ref.data;

    pieChart_classCallCheck(this, PieChart);

    return _super.call(this, {
      el: el,
      options: options,
      series: {
        pie: data.series
      },
      categories: data.categories
    });
  }

  pieChart_createClass(PieChart, [{
    key: "initialize",
    value: function initialize() {
      pieChart_get(pieChart_getPrototypeOf(PieChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Legend);
      this.componentManager.add(PieSeries);
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(DataLabels);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, brushes_sector_namespaceObject, dataLabel_namespaceObject]);
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<Object>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: 10,
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['A'],
     *   series: [
     *     {name: 'a', data: 10},
     *     {name: 'b', data: 20},
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          pie: series
        },
        categories: categories
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.alias - alias name.
     * @api
     * @example
     * chart.showTooltip({seriesIndex: 1, alias: 'name'});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', pieChart_objectSpread(pieChart_objectSpread({}, seriesInfo), {}, {
        state: this.store.state
      }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return PieChart;
}(Chart);


;// CONCATENATED MODULE: ./src/store/heatmapAxes.ts







function heatmapAxes_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function heatmapAxes_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { heatmapAxes_ownKeys(Object(source), true).forEach(function (key) { heatmapAxes_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { heatmapAxes_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function heatmapAxes_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






function getHeatmapAxisData(stateProp, axisType) {
  var _options$axisType$tic, _options$axisType, _options$axisType$tic2, _options$axisType$lab, _options$axisType2, _options$axisType2$la, _options$axisType3;

  var categories = stateProp.categories,
      axisSize = stateProp.axisSize,
      axisLayout = stateProp.axisLayout,
      options = stateProp.options,
      theme = stateProp.theme;
  var isLabelAxis = axisType === AxisType.X;
  var axisName = isLabelAxis ? 'x' : 'y';
  var dateType = isDateType(options, axisType);
  var labels = getLabelsAppliedFormatter(categories[axisName], options, dateType, axisType);
  var tickIntervalCount = labels.length;
  var tickDistance = tickIntervalCount ? axisSize / tickIntervalCount : axisSize;
  var labelDistance = axisSize / tickIntervalCount;
  var pointOnColumn = true;
  var tickCount = tickIntervalCount + 1;
  var tickInterval = (_options$axisType$tic = (_options$axisType = options[axisType]) === null || _options$axisType === void 0 ? void 0 : (_options$axisType$tic2 = _options$axisType.tick) === null || _options$axisType$tic2 === void 0 ? void 0 : _options$axisType$tic2.interval) !== null && _options$axisType$tic !== void 0 ? _options$axisType$tic : 1;
  var labelInterval = (_options$axisType$lab = (_options$axisType2 = options[axisType]) === null || _options$axisType2 === void 0 ? void 0 : (_options$axisType2$la = _options$axisType2.label) === null || _options$axisType2$la === void 0 ? void 0 : _options$axisType2$la.interval) !== null && _options$axisType$lab !== void 0 ? _options$axisType$lab : 1;
  var viewLabels = getViewAxisLabels({
    labels: labels,
    pointOnColumn: pointOnColumn,
    tickDistance: tickDistance,
    tickCount: tickCount,
    tickInterval: tickInterval,
    labelInterval: labelInterval
  }, axisSize);
  var labelXMargin = getLabelXMargin(axisType, options);

  var _getMaxLabelSize = getMaxLabelSize(labels, labelXMargin, getTitleFontString(theme.label)),
      maxLabelWidth = _getMaxLabelSize.maxLabelWidth,
      maxLabelHeight = _getMaxLabelSize.maxLabelHeight;

  var axisData = {
    labels: labels,
    viewLabels: viewLabels,
    pointOnColumn: pointOnColumn,
    isLabelAxis: isLabelAxis,
    tickCount: tickCount,
    tickDistance: tickDistance,
    labelDistance: labelDistance,
    tickInterval: tickInterval,
    labelInterval: labelInterval,
    title: makeTitleOption((_options$axisType3 = options[axisType]) === null || _options$axisType3 === void 0 ? void 0 : _options$axisType3.title),
    maxLabelWidth: maxLabelWidth,
    maxLabelHeight: maxLabelHeight
  };

  if (axisType === AxisType.X) {
    var _options$xAxis$label$, _options$xAxis, _options$xAxis$label;

    var labelMargin = (_options$xAxis$label$ = (_options$xAxis = options.xAxis) === null || _options$xAxis === void 0 ? void 0 : (_options$xAxis$label = _options$xAxis.label) === null || _options$xAxis$label === void 0 ? void 0 : _options$xAxis$label.margin) !== null && _options$xAxis$label$ !== void 0 ? _options$xAxis$label$ : 0;
    var offsetY = getAxisLabelAnchorPoint(maxLabelHeight) + labelMargin;
    var distance = axisSize / viewLabels.length;
    var rotationData = makeRotationData(maxLabelWidth, maxLabelHeight, distance, getRotatableOption(options), axisLayout);
    var needRotateLabel = rotationData.needRotateLabel,
        rotationHeight = rotationData.rotationHeight;
    var maxHeight = (needRotateLabel ? rotationHeight : maxLabelHeight) + offsetY;
    return heatmapAxes_objectSpread(heatmapAxes_objectSpread(heatmapAxes_objectSpread({}, axisData), rotationData), {}, {
      maxHeight: maxHeight,
      offsetY: offsetY
    });
  }

  return axisData;
}

var heatmapAxes_axes = {
  name: 'axes',
  state: function state() {
    return {
      axes: {
        xAxis: {},
        yAxis: {}
      }
    };
  },
  action: {
    setAxesData: function setAxesData(_ref) {
      var state = _ref.state;
      var layout = state.layout,
          theme = state.theme;
      var _layout$plot = layout.plot,
          width = _layout$plot.width,
          height = _layout$plot.height;
      var categories = state.categories;
      var options = state.options;
      var xAxisData = getHeatmapAxisData({
        axisSize: width,
        categories: categories,
        options: options,
        theme: getAxisTheme(theme, AxisType.X),
        axisLayout: layout[AxisType.X]
      }, AxisType.X);
      var yAxisData = getHeatmapAxisData({
        axisSize: height,
        categories: categories,
        options: options,
        theme: getAxisTheme(theme, AxisType.Y)
      }, AxisType.Y);
      var axesState = {
        xAxis: xAxisData,
        yAxis: yAxisData
      };

      if (hasAxesLayoutChanged(state.axes, axesState)) {
        this.notify(state, 'layout');
      }

      state.axes = axesState;
    }
  },
  computed: {},
  observe: {
    updateAxes: function updateAxes() {
      this.dispatch('setAxesData');
    }
  }
};
/* harmony default export */ var heatmapAxes = (heatmapAxes_axes);
;// CONCATENATED MODULE: ./src/store/heatmapSeriesData.ts



function makeHeatmapSeries(series, categories, viewRange) {
  if (!series.heatmap) {
    return [];
  }

  return series.heatmap.data.map(function (rowSeries, y) {
    var yCategory = rowSeries.yCategory,
        data = rowSeries.data;
    return getDataInRange(data, viewRange).map(function (colorValue, x) {
      return {
        colorValue: colorValue,
        category: {
          x: categories.x[x],
          y: yCategory
        },
        indexes: [x, y]
      };
    });
  });
}

var heatmapSeriesData = {
  name: 'heatmapSeriesData',
  state: function state() {
    return {
      heatmapSeries: []
    };
  },
  action: {
    setHeatmapSeriesData: function setHeatmapSeriesData(_ref) {
      var state = _ref.state,
          computed = _ref.computed;
      state.heatmapSeries = makeHeatmapSeries(state.series, state.categories, computed.viewRange);
    }
  },
  observe: {
    updateTreemapSeriesData: function updateTreemapSeriesData() {
      this.dispatch('setHeatmapSeriesData');
    }
  }
};
/* harmony default export */ var store_heatmapSeriesData = (heatmapSeriesData);
;// CONCATENATED MODULE: ./src/store/treemapSeriesData.ts
function treemapSeriesData_toConsumableArray(arr) { return treemapSeriesData_arrayWithoutHoles(arr) || treemapSeriesData_iterableToArray(arr) || treemapSeriesData_unsupportedIterableToArray(arr) || treemapSeriesData_nonIterableSpread(); }

function treemapSeriesData_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function treemapSeriesData_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return treemapSeriesData_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return treemapSeriesData_arrayLikeToArray(o, minLen); }

function treemapSeriesData_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function treemapSeriesData_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return treemapSeriesData_arrayLikeToArray(arr); }

function treemapSeriesData_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }



















var TREEMAP_ID_PREFIX = '__TOAST_UI_TREEMAP';
var TREEMAP_ROOT_ID = "".concat(TREEMAP_ID_PREFIX, "_ROOT");

function makeTreeModel(series, indexes, depth, parentId) {
  var _series$data;

  var idx = last(indexes);
  var id = parentId ? "".concat(parentId, "_").concat(idx) : "".concat(TREEMAP_ID_PREFIX, "_").concat(idx);
  var colorValue = series.colorValue;
  var models = [{
    label: series.label,
    hasChild: !!series.children,
    id: id,
    indexes: indexes,
    parentId: parentId ? parentId : TREEMAP_ROOT_ID,
    depth: depth,
    data: (_series$data = series.data) !== null && _series$data !== void 0 ? _series$data : 0,
    colorValue: colorValue
  }];

  if (series.children) {
    series.children.forEach(function (child, childIdx) {
      if (!isNull(child.data)) {
        models.push.apply(models, treemapSeriesData_toConsumableArray(makeTreeModel(child, [].concat(treemapSeriesData_toConsumableArray(indexes), [childIdx]), depth + 1, id)));
      }
    });
  }

  return models;
}

function setParentSeriesData(treemapSeries) {
  treemapSeries.forEach(function (_ref) {
    var parentId = _ref.parentId,
        data = _ref.data;

    if (parentId !== TREEMAP_ROOT_ID) {
      treemapSeries.find(function (_ref2) {
        var id = _ref2.id;
        return id === parentId;
      }).data += data;
    }
  });
}

function setParentColorValue(treemapSeries) {
  treemapSeries.forEach(function (datum) {
    var id = datum.id,
        colorValue = datum.colorValue;

    if (isUndefined(colorValue)) {
      var series = treemapSeries.filter(function (_ref3) {
        var parentId = _ref3.parentId;
        return parentId === id;
      });
      var totalColorValue = series.reduce(function (acc, cur) {
        return acc + (isUndefined(cur.colorValue) ? 0 : cur.colorValue);
      }, 0);
      datum.colorValue = totalColorValue / series.length;
    }
  });
}

function setRatio(treemapSeries) {
  var rootTotal = treemapSeries.filter(function (_ref4) {
    var parentId = _ref4.parentId;
    return parentId === TREEMAP_ROOT_ID;
  }).reduce(function (acc, _ref5) {
    var data = _ref5.data;
    return acc + data;
  }, 0);
  treemapSeries.forEach(function (series) {
    var total = series.parentId === TREEMAP_ROOT_ID ? rootTotal : treemapSeries.find(function (_ref6) {
      var id = _ref6.id;
      return id === series.parentId;
    }).data;
    series.ratio = series.data / total;
  });
}

function makeTreemapSeries(series, options) {
  var _options$series;

  if (!series.treemap) {
    return [];
  }

  var treemapSeries = series.treemap.data.filter(function (datum) {
    return !isNull(datum.data);
  }).map(function (datum, idx) {
    return makeTreeModel(datum, [idx], 0);
  }).flatMap(function (s) {
    return s;
  }).sort(function (a, b) {
    return b.depth - a.depth;
  });
  setParentSeriesData(treemapSeries);
  setRatio(treemapSeries);

  if ((_options$series = options.series) !== null && _options$series !== void 0 && _options$series.useColorValue) {
    setParentColorValue(treemapSeries);
  }

  return treemapSeries;
}

var treemapSeriesData = {
  name: 'treemapSeriesData',
  state: function state() {
    return {
      treemapSeries: []
    };
  },
  action: {
    setTreemapSeriesData: function setTreemapSeriesData(_ref7) {
      var state = _ref7.state;
      state.treemapSeries = makeTreemapSeries(state.series, state.options);
    }
  },
  observe: {
    updateTreemapSeriesData: function updateTreemapSeriesData() {
      this.dispatch('setTreemapSeriesData');
    }
  }
};
/* harmony default export */ var store_treemapSeriesData = (treemapSeriesData);
;// CONCATENATED MODULE: ./src/store/colorValueScale.ts
function colorValueScale_toConsumableArray(arr) { return colorValueScale_arrayWithoutHoles(arr) || colorValueScale_iterableToArray(arr) || colorValueScale_unsupportedIterableToArray(arr) || colorValueScale_nonIterableSpread(); }

function colorValueScale_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function colorValueScale_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return colorValueScale_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return colorValueScale_arrayLikeToArray(o, minLen); }

function colorValueScale_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function colorValueScale_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return colorValueScale_arrayLikeToArray(arr); }

function colorValueScale_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }





















var colorValueScale = {
  name: 'colorValueScale',
  state: function state() {
    return {
      treemapZoomId: {
        prev: TREEMAP_ROOT_ID,
        cur: TREEMAP_ROOT_ID
      },
      colorValueScale: {}
    };
  },
  action: {
    setColorValueScale: function setColorValueScale(_ref) {
      var state = _ref.state;
      var layout = state.layout,
          treemapSeries = state.treemapSeries,
          legend = state.legend,
          heatmapSeries = state.heatmapSeries;

      if (!legend.useSpectrumLegend) {
        return;
      }

      var series = treemapSeries !== null && treemapSeries !== void 0 ? treemapSeries : heatmapSeries.flatMap(function (value) {
        return value;
      });
      var values = series.reduce(function (acc, _ref2) {
        var colorValue = _ref2.colorValue;
        return colorValue ? [].concat(colorValueScale_toConsumableArray(acc), [colorValue]) : acc;
      }, []);
      var dataRange = getLimitSafely(colorValueScale_toConsumableArray(new Set(values)));
      var offsetSize = isVerticalAlign(legend.align) ? layout.plot.width / 2 : layout.plot.height;
      store_extend(state.colorValueScale, calculateCoordinateScale({
        dataRange: dataRange,
        offsetSize: offsetSize,
        useSpectrumLegend: true,
        scaleOption: {}
      }));
    },
    setTreemapZoomId: function setTreemapZoomId(_ref3, id) {
      var state = _ref3.state;
      state.treemapZoomId.prev = state.treemapZoomId.cur;
      state.treemapZoomId.cur = id;
    },
    zoomBack: function zoomBack(_ref4) {
      var _prevSeries$parentId;

      var state = _ref4.state;
      var treemapSeries = state.treemapSeries,
          treemapZoomId = state.treemapZoomId;
      var prev = treemapZoomId.prev;
      var prevSeries = treemapSeries.find(function (_ref5) {
        var id = _ref5.id;
        return id === prev;
      });
      state.treemapZoomId.prev = (_prevSeries$parentId = prevSeries === null || prevSeries === void 0 ? void 0 : prevSeries.parentId) !== null && _prevSeries$parentId !== void 0 ? _prevSeries$parentId : TREEMAP_ROOT_ID;
      state.treemapZoomId.cur = prev;
    }
  },
  observe: {
    updateColorValueScale: function updateColorValueScale() {
      this.dispatch('setColorValueScale');
    }
  },
  computed: {
    isTreemapSeriesZooming: function isTreemapSeriesZooming(_ref6) {
      var treemapZoomId = _ref6.treemapZoomId;
      return treemapZoomId && treemapZoomId.cur !== treemapZoomId.prev;
    }
  }
};
/* harmony default export */ var store_colorValueScale = (colorValueScale);
;// CONCATENATED MODULE: ./src/component/spectrumLegend.ts
function spectrumLegend_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { spectrumLegend_typeof = function _typeof(obj) { return typeof obj; }; } else { spectrumLegend_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return spectrumLegend_typeof(obj); }

function spectrumLegend_toConsumableArray(arr) { return spectrumLegend_arrayWithoutHoles(arr) || spectrumLegend_iterableToArray(arr) || spectrumLegend_unsupportedIterableToArray(arr) || spectrumLegend_nonIterableSpread(); }

function spectrumLegend_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function spectrumLegend_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function spectrumLegend_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return spectrumLegend_arrayLikeToArray(arr); }

function spectrumLegend_slicedToArray(arr, i) { return spectrumLegend_arrayWithHoles(arr) || spectrumLegend_iterableToArrayLimit(arr, i) || spectrumLegend_unsupportedIterableToArray(arr, i) || spectrumLegend_nonIterableRest(); }

function spectrumLegend_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function spectrumLegend_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return spectrumLegend_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return spectrumLegend_arrayLikeToArray(o, minLen); }

function spectrumLegend_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function spectrumLegend_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function spectrumLegend_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
















function spectrumLegend_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function spectrumLegend_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function spectrumLegend_createClass(Constructor, protoProps, staticProps) { if (protoProps) spectrumLegend_defineProperties(Constructor.prototype, protoProps); if (staticProps) spectrumLegend_defineProperties(Constructor, staticProps); return Constructor; }

function spectrumLegend_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) spectrumLegend_setPrototypeOf(subClass, superClass); }

function spectrumLegend_setPrototypeOf(o, p) { spectrumLegend_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return spectrumLegend_setPrototypeOf(o, p); }

function spectrumLegend_createSuper(Derived) { var hasNativeReflectConstruct = spectrumLegend_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = spectrumLegend_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = spectrumLegend_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return spectrumLegend_possibleConstructorReturn(this, result); }; }

function spectrumLegend_possibleConstructorReturn(self, call) { if (call && (spectrumLegend_typeof(call) === "object" || typeof call === "function")) { return call; } return spectrumLegend_assertThisInitialized(self); }

function spectrumLegend_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function spectrumLegend_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function spectrumLegend_getPrototypeOf(o) { spectrumLegend_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return spectrumLegend_getPrototypeOf(o); }

function component_spectrumLegend_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var SpectrumLegend = /*#__PURE__*/function (_Component) {
  spectrumLegend_inherits(SpectrumLegend, _Component);

  var _super = spectrumLegend_createSuper(SpectrumLegend);

  function SpectrumLegend() {
    var _this;

    spectrumLegend_classCallCheck(this, SpectrumLegend);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    component_spectrumLegend_defineProperty(spectrumLegend_assertThisInitialized(_this), "models", void 0);

    component_spectrumLegend_defineProperty(spectrumLegend_assertThisInitialized(_this), "labels", []);

    component_spectrumLegend_defineProperty(spectrumLegend_assertThisInitialized(_this), "align", void 0);

    component_spectrumLegend_defineProperty(spectrumLegend_assertThisInitialized(_this), "renderSpectrumTooltip", function (_ref) {
      var _ref2 = spectrumLegend_slicedToArray(_ref, 1),
          responderData = _ref2[0];

      if (responderData) {
        var _assertThisInitialize = spectrumLegend_assertThisInitialized(_this),
            labels = _assertThisInitialize.labels,
            align = _assertThisInitialize.align;

        var colorValue = responderData.colorValue,
            color = responderData.color;
        var _this$rect = _this.rect,
            width = _this$rect.width,
            height = _this$rect.height;
        _this.models.tooltip = [{
          type: 'spectrumTooltip',
          width: width,
          height: height,
          x: 0,
          y: 0,
          labels: labels,
          align: align,
          colorRatio: responderData.colorRatio,
          color: color,
          text: String(colorValue),
          verticalAlign: isVerticalAlign(align)
        }];
      } else {
        _this.models.tooltip = [];
      }
    });

    return _this;
  }

  spectrumLegend_createClass(SpectrumLegend, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'spectrumLegend';
      this.name = 'spectrumLegend';
    }
  }, {
    key: "makeLabels",
    value: function makeLabels(scale) {
      var stepCount = scale.stepCount,
          limit = scale.limit,
          stepSize = scale.stepSize;
      var minValue = limit.min;
      return range(0, stepCount + 1).reduce(function (labels, value) {
        return [].concat(spectrumLegend_toConsumableArray(labels), [String(minValue + stepSize * value)]);
      }, []);
    }
  }, {
    key: "renderSpectrumLegendModel",
    value: function renderSpectrumLegendModel(startColor, endColor) {
      var labels = this.labels,
          align = this.align;
      var _this$rect2 = this.rect,
          width = _this$rect2.width,
          height = _this$rect2.height;
      return [{
        type: 'spectrumLegend',
        width: width,
        height: height,
        x: 0,
        y: 0,
        labels: labels,
        align: align,
        startColor: startColor,
        endColor: endColor,
        verticalAlign: isVerticalAlign(this.align)
      }];
    }
  }, {
    key: "render",
    value: function render(_ref3) {
      var _theme$series, _theme$series2;

      var layout = _ref3.layout,
          legend = _ref3.legend,
          colorValueScale = _ref3.colorValueScale,
          theme = _ref3.theme;
      this.rect = layout.legend;
      this.align = legend.align;
      this.isShow = legend.visible && !!legend.data.length;

      if (!this.isShow) {
        return;
      }

      this.labels = this.makeLabels(colorValueScale);

      var _ref4 = ((_theme$series = theme.series) === null || _theme$series === void 0 ? void 0 : _theme$series.heatmap) || ((_theme$series2 = theme.series) === null || _theme$series2 === void 0 ? void 0 : _theme$series2.treemap),
          startColor = _ref4.startColor,
          endColor = _ref4.endColor;

      this.models = {
        legend: this.renderSpectrumLegendModel(startColor, endColor),
        tooltip: []
      };
      this.eventBus.on('renderSpectrumTooltip', this.renderSpectrumTooltip);
    }
  }]);

  return SpectrumLegend;
}(Component);


;// CONCATENATED MODULE: ./src/helpers/colorSpectrum.ts
function colorSpectrum_toConsumableArray(arr) { return colorSpectrum_arrayWithoutHoles(arr) || colorSpectrum_iterableToArray(arr) || colorSpectrum_unsupportedIterableToArray(arr) || colorSpectrum_nonIterableSpread(); }

function colorSpectrum_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function colorSpectrum_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return colorSpectrum_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return colorSpectrum_arrayLikeToArray(o, minLen); }

function colorSpectrum_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function colorSpectrum_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return colorSpectrum_arrayLikeToArray(arr); }

function colorSpectrum_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }














function makeDistances(startRGB, endRGB) {
  return startRGB.map(function (value, index) {
    return endRGB[index] - value;
  });
}
function getColorRatio(limit, value) {
  if (isUndefined(value)) {
    return;
  }

  var divNumber = Math.abs(limit.max - limit.min);
  return divNumber && !isNull(value) ? (value - limit.min) / divNumber : 0;
}
function getSpectrumColor(ratio, distances, startRGB) {
  var rgbColor = startRGB.map(function (start, index) {
    return start + parseInt(String(distances[index] * ratio), 10);
  });
  var color = rgbToHEX.apply(void 0, colorSpectrum_toConsumableArray(rgbColor));
  return utils_isString(color) ? color : '';
}
;// CONCATENATED MODULE: ./src/component/heatmapSeries.ts
function heatmapSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { heatmapSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { heatmapSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return heatmapSeries_typeof(obj); }

function heatmapSeries_slicedToArray(arr, i) { return heatmapSeries_arrayWithHoles(arr) || heatmapSeries_iterableToArrayLimit(arr, i) || heatmapSeries_unsupportedIterableToArray(arr, i) || heatmapSeries_nonIterableRest(); }

function heatmapSeries_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function heatmapSeries_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function heatmapSeries_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function heatmapSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function heatmapSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { heatmapSeries_ownKeys(Object(source), true).forEach(function (key) { heatmapSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { heatmapSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function heatmapSeries_toConsumableArray(arr) { return heatmapSeries_arrayWithoutHoles(arr) || heatmapSeries_iterableToArray(arr) || heatmapSeries_unsupportedIterableToArray(arr) || heatmapSeries_nonIterableSpread(); }

function heatmapSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function heatmapSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return heatmapSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return heatmapSeries_arrayLikeToArray(o, minLen); }

function heatmapSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function heatmapSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return heatmapSeries_arrayLikeToArray(arr); }

function heatmapSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
























function heatmapSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function heatmapSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function heatmapSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) heatmapSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) heatmapSeries_defineProperties(Constructor, staticProps); return Constructor; }

function heatmapSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) heatmapSeries_setPrototypeOf(subClass, superClass); }

function heatmapSeries_setPrototypeOf(o, p) { heatmapSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return heatmapSeries_setPrototypeOf(o, p); }

function heatmapSeries_createSuper(Derived) { var hasNativeReflectConstruct = heatmapSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = heatmapSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = heatmapSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return heatmapSeries_possibleConstructorReturn(this, result); }; }

function heatmapSeries_possibleConstructorReturn(self, call) { if (call && (heatmapSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return heatmapSeries_assertThisInitialized(self); }

function heatmapSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function heatmapSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function heatmapSeries_getPrototypeOf(o) { heatmapSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return heatmapSeries_getPrototypeOf(o); }

function heatmapSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









var HeatmapSeries = /*#__PURE__*/function (_Component) {
  heatmapSeries_inherits(HeatmapSeries, _Component);

  var _super = heatmapSeries_createSuper(HeatmapSeries);

  function HeatmapSeries() {
    var _this;

    heatmapSeries_classCallCheck(this, HeatmapSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "models", void 0);

    heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "responders", void 0);

    heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "theme", void 0);

    heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "activatedResponders", []);

    heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.emitMouseEvent([]);
    });

    heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "selectSeries", function (_ref) {
      var _state$series$heatmap;

      var index = _ref.index,
          seriesIndex = _ref.seriesIndex,
          state = _ref.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var dataSize = (_state$series$heatmap = state.series.heatmap) === null || _state$series$heatmap === void 0 ? void 0 : _state$series$heatmap[0].data.length;
      var responderIndex = seriesIndex * dataSize + index;
      var model = _this.responders[responderIndex];

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: _this.getRespondersWithTheme([model], 'select'),
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    heatmapSeries_defineProperty(heatmapSeries_assertThisInitialized(_this), "showTooltip", function (_ref2) {
      var _state$series$heatmap2;

      var index = _ref2.index,
          seriesIndex = _ref2.seriesIndex,
          state = _ref2.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var dataSize = (_state$series$heatmap2 = state.series.heatmap) === null || _state$series$heatmap2 === void 0 ? void 0 : _state$series$heatmap2[0].data.length;
      var responderIndex = seriesIndex * dataSize + index;
      var model = _this.responders[responderIndex];

      if (model) {
        _this.emitMouseEvent([model]);
      }
    });

    return _this;
  }

  heatmapSeries_createClass(HeatmapSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'heatmap';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "render",
    value: function render(chartState) {
      var layout = chartState.layout,
          heatmapSeries = chartState.heatmapSeries,
          axes = chartState.axes,
          theme = chartState.theme,
          colorValueScale = chartState.colorValueScale,
          options = chartState.options;

      if (!heatmapSeries) {
        throw new Error(message.noDataError(this.name));
      }

      this.theme = theme.series.heatmap;
      this.selectable = this.getSelectableOption(options);
      this.rect = layout.plot;
      var cellSize = {
        height: axes.yAxis.tickDistance,
        width: axes.xAxis.tickDistance
      };
      this.models = {
        series: this.renderHeatmapSeries(heatmapSeries, cellSize, colorValueScale)
      };

      if (getDataLabelsOptions(options, this.name).visible) {
        this.renderDataLabels(this.makeDataLabels());
      }

      this.responders = this.makeHeatmapSeriesResponder();
    }
  }, {
    key: "makeDataLabels",
    value: function makeDataLabels() {
      var dataLabelTheme = this.theme.dataLabels;
      return this.models.series.reduce(function (acc, m) {
        return isNull(m.colorValue) ? acc : [].concat(heatmapSeries_toConsumableArray(acc), [heatmapSeries_objectSpread(heatmapSeries_objectSpread({}, m), {}, {
          type: 'treemapSeriesName',
          value: m.colorValue,
          direction: 'left',
          plot: {
            x: 0,
            y: 0,
            size: 0
          },
          theme: heatmapSeries_objectSpread(heatmapSeries_objectSpread({}, dataLabelTheme), {}, {
            color: dataLabelTheme.useSeriesColor ? m.color : dataLabelTheme.color
          })
        })]);
      }, []);
    }
  }, {
    key: "makeHeatmapSeriesResponder",
    value: function makeHeatmapSeriesResponder() {
      return this.models.series.reduce(function (acc, model) {
        return isNull(model.colorValue) ? acc : [].concat(heatmapSeries_toConsumableArray(acc), [heatmapSeries_objectSpread(heatmapSeries_objectSpread({}, model), {}, {
          data: heatmapSeries_objectSpread(heatmapSeries_objectSpread({}, model), {}, {
            label: model.name,
            value: model.colorValue,
            templateType: 'heatmap'
          }),
          thickness: boxDefault.HOVER_THICKNESS,
          style: ['shadow']
        })]);
      }, []);
    }
  }, {
    key: "renderHeatmapSeries",
    value: function renderHeatmapSeries(seriesData, cellSize, colorValueScale) {
      var _this$theme = this.theme,
          startColor = _this$theme.startColor,
          endColor = _this$theme.endColor,
          borderColor = _this$theme.borderColor,
          borderWidth = _this$theme.borderWidth;
      var startRGB = hexToRGB(startColor);
      var distances = makeDistances(startRGB, hexToRGB(endColor));
      var height = cellSize.height,
          width = cellSize.width;
      return seriesData.flatMap(function (data) {
        return data.flatMap(function (datum) {
          var indexes = datum.indexes,
              colorValue = datum.colorValue,
              category = datum.category;
          var name = "".concat(category.x, ", ").concat(category.y);

          var _indexes = heatmapSeries_slicedToArray(indexes, 2),
              xIndex = _indexes[0],
              yIndex = _indexes[1];

          var colorRatio = getColorRatio(colorValueScale.limit, colorValue);
          var color = isNull(colorValue) ? 'rgba(0, 0, 0, 0)' : getSpectrumColor(colorRatio, distances, startRGB);
          var thickness = borderWidth;
          return {
            type: 'rect',
            name: name,
            width: width - thickness * 2,
            height: height - thickness * 2,
            x: width * xIndex + thickness,
            y: height * yIndex + thickness,
            colorValue: colorValue,
            colorRatio: colorRatio,
            color: color,
            thickness: thickness,
            borderColor: borderColor
          };
        });
      });
    }
  }, {
    key: "getRespondersWithTheme",
    value: function getRespondersWithTheme(responders, type) {
      var _this2 = this;

      return responders.map(function (responder) {
        return deepMergedCopy(responder, heatmapSeries_objectSpread(heatmapSeries_objectSpread({}, _this2.theme[type]), {}, {
          style: ['shadow']
        }));
      });
    }
  }, {
    key: "onClick",
    value: function onClick(_ref3) {
      var responders = _ref3.responders;

      if (this.selectable) {
        this.eventBus.emit('renderSelectedSeries', {
          models: this.getRespondersWithTheme(responders, 'select'),
          name: this.name
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref4) {
      var responders = _ref4.responders;
      this.activatedResponders = responders;
      this.emitMouseEvent(responders);
    }
  }, {
    key: "emitMouseEvent",
    value: function emitMouseEvent(responders) {
      this.eventBus.emit('renderHoveredSeries', {
        models: this.getRespondersWithTheme(responders, 'hover'),
        name: this.name
      });
      this.eventBus.emit('seriesPointHovered', {
        models: responders,
        name: this.name
      });
      this.eventBus.emit('renderSpectrumTooltip', responders);
      this.eventBus.emit('needDraw');
    }
  }]);

  return HeatmapSeries;
}(Component);


;// CONCATENATED MODULE: ./src/charts/heatmapChart.ts
function heatmapChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { heatmapChart_typeof = function _typeof(obj) { return typeof obj; }; } else { heatmapChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return heatmapChart_typeof(obj); }

function heatmapChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function heatmapChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { heatmapChart_ownKeys(Object(source), true).forEach(function (key) { heatmapChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { heatmapChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function heatmapChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function heatmapChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function heatmapChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function heatmapChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) heatmapChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) heatmapChart_defineProperties(Constructor, staticProps); return Constructor; }

function heatmapChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { heatmapChart_get = Reflect.get; } else { heatmapChart_get = function _get(target, property, receiver) { var base = heatmapChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return heatmapChart_get(target, property, receiver || target); }

function heatmapChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = heatmapChart_getPrototypeOf(object); if (object === null) break; } return object; }

function heatmapChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) heatmapChart_setPrototypeOf(subClass, superClass); }

function heatmapChart_setPrototypeOf(o, p) { heatmapChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return heatmapChart_setPrototypeOf(o, p); }

function heatmapChart_createSuper(Derived) { var hasNativeReflectConstruct = heatmapChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = heatmapChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = heatmapChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return heatmapChart_possibleConstructorReturn(this, result); }; }

function heatmapChart_possibleConstructorReturn(self, call) { if (call && (heatmapChart_typeof(call) === "object" || typeof call === "function")) { return call; } return heatmapChart_assertThisInitialized(self); }

function heatmapChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function heatmapChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function heatmapChart_getPrototypeOf(o) { heatmapChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return heatmapChart_getPrototypeOf(o); }










































function getSeriesWithYCategory(series, categories) {
  return series.map(function (rowSeries, y) {
    return {
      data: rowSeries,
      yCategory: categories.y[y]
    };
  });
}
/**
 * @class
 * @classdesc Heatmap Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Heatmap Chart.
 *     @param {Object} props.data.categories
 *       @param {Array<string>} props.data.categories.x - X Categories.
 *       @param {Array<string>} props.data.categories.y - Y Categories.
 *     @param {Array<Array<number>>} props.data.series - Series data.
 *   @param {Object} [props.options] - Options for making Heatmap Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {boolean|Object} [props.options.yAxis.date] - Whether the y axis label is of date type. Format option used for date type. Whether the y axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Heatmap Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object} [props.options.theme.yAxis] - Y Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */


var HeatmapChart = /*#__PURE__*/function (_Chart) {
  heatmapChart_inherits(HeatmapChart, _Chart);

  var _super = heatmapChart_createSuper(HeatmapChart);

  function HeatmapChart(props) {
    heatmapChart_classCallCheck(this, HeatmapChart);

    return _super.call(this, {
      el: props.el,
      categories: props.data.categories,
      options: props.options,
      series: {
        heatmap: getSeriesWithYCategory(props.data.series, props.data.categories)
      },
      modules: [store_heatmapSeriesData, store_colorValueScale, heatmapAxes]
    });
  }

  heatmapChart_createClass(HeatmapChart, [{
    key: "initialize",
    value: function initialize() {
      heatmapChart_get(heatmapChart_getPrototypeOf(HeatmapChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(SpectrumLegend);
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HeatmapSeries);
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(DataLabels);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, spectrumLegend_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */

  }, {
    key: "addData",
    value: function addData(data, category) {
      this.animationControlFlag.updating = true;
      this.resetSeries();
      this.store.dispatch('addData', {
        data: data,
        category: category
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number>} data.data - Array of data to be added.
     * @param {Object} dataInfo - Category information of the series.
     *   @param {Object} dataInfo.category - Y category.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data, dataInfo) {
      this.resetSeries();
      this.store.dispatch('addHeatmapSeries', heatmapChart_objectSpread({
        data: data
      }, dataInfo));
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     *   @param {Array<string>} data.categories.x - X Categories.
     *   @param {Array<string>} data.categories.y - Y Categories.
     * @param {Array<Array<number>>} data.series - Series data.
     * @api
     * @example
     * chart.setData({
     *   categories: {
     *     x: ['1', '2', '3' ],
     *     y: ['A', 'B'],
     *   },
     *   series: [
     *     [1, 2, 3],
     *     [4, 5, 6],
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          heatmap: getSeriesWithYCategory(series, categories)
        },
        categories: categories
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.index - Index of data within series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', heatmapChart_objectSpread(heatmapChart_objectSpread({}, seriesInfo), {}, {
        state: this.store.state
      }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return HeatmapChart;
}(Chart);


;// CONCATENATED MODULE: ./src/component/areaSeries.ts
function areaSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { areaSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { areaSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return areaSeries_typeof(obj); }

function areaSeries_toConsumableArray(arr) { return areaSeries_arrayWithoutHoles(arr) || areaSeries_iterableToArray(arr) || areaSeries_unsupportedIterableToArray(arr) || areaSeries_nonIterableSpread(); }

function areaSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function areaSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return areaSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return areaSeries_arrayLikeToArray(o, minLen); }

function areaSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function areaSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return areaSeries_arrayLikeToArray(arr); }

function areaSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function areaSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function areaSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { areaSeries_ownKeys(Object(source), true).forEach(function (key) { areaSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { areaSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }



























function areaSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function areaSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function areaSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) areaSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) areaSeries_defineProperties(Constructor, staticProps); return Constructor; }

function areaSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) areaSeries_setPrototypeOf(subClass, superClass); }

function areaSeries_setPrototypeOf(o, p) { areaSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return areaSeries_setPrototypeOf(o, p); }

function areaSeries_createSuper(Derived) { var hasNativeReflectConstruct = areaSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = areaSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = areaSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return areaSeries_possibleConstructorReturn(this, result); }; }

function areaSeries_possibleConstructorReturn(self, call) { if (call && (areaSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return areaSeries_assertThisInitialized(self); }

function areaSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function areaSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function areaSeries_getPrototypeOf(o) { areaSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return areaSeries_getPrototypeOf(o); }

function areaSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }












var seriesOpacity = {
  INACTIVE: 0.06,
  ACTIVE: 1
};

var AreaSeries = /*#__PURE__*/function (_Component) {
  areaSeries_inherits(AreaSeries, _Component);

  var _super = areaSeries_createSuper(AreaSeries);

  function AreaSeries() {
    var _this;

    areaSeries_classCallCheck(this, AreaSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "models", {
      rect: [],
      series: [],
      dot: []
    });

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "drawModels", void 0);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "theme", void 0);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "responders", void 0);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "activatedResponders", []);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "eventDetectType", 'nearest');

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "tooltipCircleMap", void 0);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "linePointsModel", void 0);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "baseYPosition", void 0);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "isStackChart", false);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "isRangeChart", false);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "isSplineChart", false);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "startIndex", void 0);

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.eventBus.emit('needDraw');
    });

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "selectSeries", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex;

      if (!isAvailableSelectSeries(info, 'area')) {
        return;
      }

      var category = _this.getResponderCategoryByIndex(index);

      if (!category) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      var model = _this.tooltipCircleMap[category][seriesIndex];

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      var models = _this.getResponderSeriesWithTheme([model], 'select');

      _this.eventBus.emit('renderSelectedSeries', {
        models: models,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    areaSeries_defineProperty(areaSeries_assertThisInitialized(_this), "showTooltip", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex;

      if (!isAvailableShowTooltipInfo(info, _this.eventDetectType, 'area')) {
        return;
      }

      var category = _this.getResponderCategoryByIndex(index);

      if (!category) {
        return;
      }

      var models = _this.eventDetectType === 'grouped' ? _this.tooltipCircleMap[category] : [_this.tooltipCircleMap[category][seriesIndex]];

      if (!models.length) {
        return;
      }

      _this.onMousemoveNearType(models);

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  areaSeries_createClass(AreaSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'area';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      if (!this.drawModels) {
        return;
      }

      this.drawModels.rect[0].width = this.models.rect[0].width * delta;
    }
  }, {
    key: "getBaseYPosition",
    value: function getBaseYPosition(limit) {
      var baseValue = limit.min >= 0 ? limit.min : Math.min(limit.max, 0);
      var intervalSize = this.rect.height / (limit.max - limit.min);
      return (limit.max - baseValue) * intervalSize;
    }
  }, {
    key: "getStackValue",
    value: function getStackValue(areaStackSeries, seriesIndex, index) {
      var type = areaStackSeries.stack.type;
      var _areaStackSeries$stac = areaStackSeries.stackData[index],
          values = _areaStackSeries$stac.values,
          sumValue = _areaStackSeries$stac.sum;
      var stackedValue = sum(values.slice(0, seriesIndex + 1));
      return type === 'percent' ? stackedValue * 100 / sumValue : stackedValue;
    }
  }, {
    key: "setEventDetectType",
    value: function setEventDetectType(series, options) {
      var _options$series;

      if (options !== null && options !== void 0 && (_options$series = options.series) !== null && _options$series !== void 0 && _options$series.eventDetectType) {
        this.eventDetectType = options.series.eventDetectType;
      }

      if (series.line || this.isStackChart) {
        this.eventDetectType = 'grouped';
      }
    }
  }, {
    key: "getAreaOptions",
    value: function getAreaOptions(options) {
      var _newOptions$series;

      var newOptions = areaSeries_objectSpread({}, options);

      if ((_newOptions$series = newOptions.series) !== null && _newOptions$series !== void 0 && _newOptions$series.area) {
        newOptions.series = areaSeries_objectSpread(areaSeries_objectSpread({}, newOptions.series), newOptions.series.area);
      }

      return newOptions;
    }
  }, {
    key: "render",
    value: function render(chartState, computed) {
      var _ref, _viewRange$, _options$series$splin, _options$series2, _getFirstValidValue, _options$series3;

      var viewRange = computed.viewRange;
      var layout = chartState.layout,
          series = chartState.series,
          scale = chartState.scale,
          axes = chartState.axes,
          legend = chartState.legend,
          stackSeries = chartState.stackSeries,
          theme = chartState.theme;

      if (!series.area) {
        throw new Error(message.noDataError(this.name));
      }

      var areaStackSeries;
      var options = this.getAreaOptions(chartState.options);
      var categories = chartState.categories;
      var rawCategories = (_ref = chartState.rawCategories) !== null && _ref !== void 0 ? _ref : [];
      this.theme = theme.series.area;
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.startIndex = (_viewRange$ = viewRange === null || viewRange === void 0 ? void 0 : viewRange[0]) !== null && _viewRange$ !== void 0 ? _viewRange$ : 0;
      this.selectable = this.getSelectableOption(options);
      this.isSplineChart = (_options$series$splin = (_options$series2 = options.series) === null || _options$series2 === void 0 ? void 0 : _options$series2.spline) !== null && _options$series$splin !== void 0 ? _options$series$splin : false;
      var limit = scale[getValueAxisName(options, this.name, 'yAxis')].limit;
      var _ref2 = axes.xAxis,
          tickDistance = _ref2.tickDistance,
          pointOnColumn = _ref2.pointOnColumn,
          tickCount = _ref2.tickCount;
      var areaData = series.area.data;
      this.baseYPosition = this.getBaseYPosition(limit);

      if (stackSeries !== null && stackSeries !== void 0 && stackSeries.area) {
        this.isStackChart = true;
        areaStackSeries = stackSeries.area;
      } else if (isRangeData((_getFirstValidValue = getFirstValidValue(areaData)) === null || _getFirstValidValue === void 0 ? void 0 : _getFirstValidValue.data)) {
        this.isRangeChart = true;
      }

      this.setEventDetectType(series, options);
      var renderOptions = {
        pointOnColumn: pointOnColumn,
        options: options.series || {},
        tickDistance: tickDistance,
        tickCount: tickCount,
        areaStackSeries: areaStackSeries
      };
      this.linePointsModel = this.renderLinePointsModel(areaData, limit, renderOptions);
      var areaSeriesModel = this.renderAreaPointsModel();
      var showDot = !!((_options$series3 = options.series) !== null && _options$series3 !== void 0 && _options$series3.showDot);

      var _this$renderCircleMod = this.renderCircleModel(showDot),
          dotSeriesModel = _this$renderCircleMod.dotSeriesModel,
          responderModel = _this$renderCircleMod.responderModel;

      var tooltipDataArr = this.makeTooltipData(areaData, rawCategories);
      this.models = deepCopy({
        rect: [this.renderClipRectAreaModel()],
        series: [].concat(areaSeries_toConsumableArray(this.linePointsModel), areaSeries_toConsumableArray(areaSeriesModel)),
        dot: dotSeriesModel
      });

      if (!this.drawModels) {
        this.drawModels = areaSeries_objectSpread(areaSeries_objectSpread({}, this.models), {}, {
          rect: [this.renderClipRectAreaModel(true)]
        });
      }

      if (getDataLabelsOptions(options, this.name).visible) {
        this.renderDataLabels(this.getDataLabels(areaSeriesModel));
      }

      this.tooltipCircleMap = makeTooltipCircleMap(responderModel, tooltipDataArr);
      this.responders = this.getResponders(responderModel, tooltipDataArr, categories, rawCategories, axes.xAxis);
    }
  }, {
    key: "getResponders",
    value: function getResponders(responderModel, tooltipDataArr, categories, rawCategories, axisData) {
      if (this.eventDetectType === 'near') {
        return this.makeNearTypeResponderModel(responderModel, tooltipDataArr, rawCategories);
      }

      if (this.eventDetectType === 'point') {
        return this.makeNearTypeResponderModel(responderModel, tooltipDataArr, rawCategories, 0);
      }

      return makeRectResponderModel(this.rect, axisData, categories);
    }
  }, {
    key: "makeNearTypeResponderModel",
    value: function makeNearTypeResponderModel(seriesCircleModel, tooltipDataArr, categories, detectionSize) {
      var tooltipDataLength = tooltipDataArr.length;
      return seriesCircleModel.map(function (m, dataIndex) {
        return areaSeries_objectSpread(areaSeries_objectSpread({}, m), {}, {
          data: tooltipDataArr[dataIndex % tooltipDataLength],
          detectionSize: detectionSize,
          label: categories[m.index]
        });
      });
    }
  }, {
    key: "renderClipRectAreaModel",
    value: function renderClipRectAreaModel(isDrawModel) {
      return {
        type: 'clipRectArea',
        x: 0,
        y: 0,
        width: isDrawModel ? 0 : this.rect.width,
        height: this.rect.height
      };
    }
  }, {
    key: "makeTooltipData",
    value: function makeTooltipData(areaData, categories) {
      var _this2 = this;

      return areaData.flatMap(function (_ref3, seriesIndex) {
        var rawData = _ref3.rawData,
            name = _ref3.name,
            color = _ref3.color;
        var tooltipData = [];
        rawData.forEach(function (datum, index) {
          if (!isNull(datum)) {
            var value = _this2.isRangeChart ? "".concat(datum[0], " ~ ").concat(datum[1]) : datum;
            tooltipData.push({
              label: name,
              color: color,
              value: value,
              category: categories[index],
              seriesIndex: seriesIndex,
              index: index
            });
          }
        });
        return tooltipData;
      });
    }
  }, {
    key: "getLinePointModelValue",
    value: function getLinePointModelValue(datum, pairModel) {
      if (this.isRangeChart) {
        return pairModel ? datum[0] : datum[1];
      }

      return datum;
    }
  }, {
    key: "getLinePointModel",
    value: function getLinePointModel(series, seriesIndex, limit, renderOptions) {
      var _this3 = this;

      var pointOnColumn = renderOptions.pointOnColumn,
          tickDistance = renderOptions.tickDistance,
          pairModel = renderOptions.pairModel,
          areaStackSeries = renderOptions.areaStackSeries;
      var rawData = series.rawData,
          name = series.name,
          seriesColor = series.color;
      var active = this.activeSeriesMap[name];
      var points = [];
      var color = getRGBA(seriesColor, active ? seriesOpacity.ACTIVE : seriesOpacity.INACTIVE);
      var _this$theme = this.theme,
          lineWidth = _this$theme.lineWidth,
          dashSegments = _this$theme.dashSegments;
      rawData.forEach(function (datum, idx) {
        if (isNull(datum)) {
          points.push(null);
          return;
        }

        var value = _this3.getLinePointModelValue(datum, pairModel);

        var stackedValue = _this3.isStackChart ? _this3.getStackValue(areaStackSeries, seriesIndex, idx) : value;
        var valueRatio = getValueRatio(stackedValue, limit);
        var x = tickDistance * (idx - _this3.startIndex) + (pointOnColumn ? tickDistance / 2 : 0);
        var y = (1 - valueRatio) * _this3.rect.height;
        points.push({
          x: x,
          y: y,
          value: value
        });
      });

      if (pairModel) {
        points.reverse(); // for range spline
      }

      if (this.isSplineChart) {
        setSplineControlPoint(points);
      }

      return {
        type: 'linePoints',
        lineWidth: lineWidth,
        dashSegments: dashSegments,
        color: color,
        points: points,
        seriesIndex: seriesIndex,
        name: name
      };
    }
  }, {
    key: "renderLinePointsModel",
    value: function renderLinePointsModel(seriesRawData, limit, renderOptions) {
      var _this4 = this;

      var linePointsModels = seriesRawData.map(function (series, seriesIndex) {
        return _this4.getLinePointModel(series, seriesIndex, limit, renderOptions);
      });

      if (this.isRangeChart) {
        var renderOptionsForPair = deepMergedCopy(renderOptions, {
          pairModel: true
        });
        var pair = seriesRawData.map(function (series, seriesIndex) {
          return _this4.getLinePointModel(series, seriesIndex, limit, renderOptionsForPair);
        });
        linePointsModels.push.apply(linePointsModels, areaSeries_toConsumableArray(pair));
      }

      return linePointsModels;
    }
  }, {
    key: "getCombinedPoints",
    value: function getCombinedPoints(start, end) {
      var startPoints = start >= 0 ? this.linePointsModel[start].points : [];

      var reversedEndPoints = areaSeries_toConsumableArray(this.linePointsModel[end].points).reverse();

      return [].concat(areaSeries_toConsumableArray(startPoints), areaSeries_toConsumableArray(reversedEndPoints));
    }
  }, {
    key: "renderRangeAreaSeries",
    value: function renderRangeAreaSeries(linePointsModel) {
      var _this5 = this;

      var model = [];
      linePointsModel.forEach(function (m) {
        var areaPoints = [];
        var points = m.points;
        points.slice(0, points.length / 2 + 1).forEach(function (point, i) {
          var lastPoint = i === points.length / 2 - 1;
          var nullPoint = isNull(point);

          if (!nullPoint) {
            areaPoints.push(point);
          }

          if (areaPoints.length && (lastPoint || nullPoint)) {
            var pairPoints = areaPoints.map(function (areaPoint, idx) {
              var curIdx = points.length / 2 + i - areaPoints.length + idx + (!nullPoint && lastPoint ? 1 : 0);
              return points[curIdx];
            }).reverse();
            model.push(areaSeries_objectSpread(areaSeries_objectSpread({}, m), {}, {
              type: 'areaPoints',
              lineWidth: 0,
              color: 'rgba(0, 0, 0, 0)',
              // make area border transparent
              fillColor: _this5.getAreaOpacity(m.name, m.color),
              points: [].concat(areaSeries_toConsumableArray(areaPoints), areaSeries_toConsumableArray(pairPoints))
            }));
            areaPoints = [];
          }
        });
      });
      return model;
    }
  }, {
    key: "renderAreaSeries",
    value: function renderAreaSeries(linePointsModel) {
      var _this6 = this;

      var model = [];
      var bottomYPoint = [];
      linePointsModel.forEach(function (m) {
        var areaPoints = [];
        var curBottomYPoint = [].concat(bottomYPoint);
        var points = m.points;
        points.forEach(function (point, i) {
          var lastPoint = i === points.length - 1;
          var nullPoint = isNull(point);

          if (!isNull(point)) {
            areaPoints.push(point);
          }

          if (areaPoints.length && (nullPoint || lastPoint)) {
            var pairPoints = areaPoints.map(function (areaPoint, idx) {
              var curIdx = i - areaPoints.length + idx + (!nullPoint && lastPoint ? 1 : 0);
              var bottom = isUndefined(curBottomYPoint[curIdx]) ? _this6.baseYPosition : curBottomYPoint[curIdx];

              if (_this6.isStackChart) {
                bottomYPoint[curIdx] = areaPoint.y;
              }

              return {
                x: areaPoint.x,
                y: bottom
              };
            }).reverse();

            if (_this6.isStackChart && _this6.isSplineChart) {
              setSplineControlPoint(pairPoints); // set spline for new stack pair points
            }

            model.push(areaSeries_objectSpread(areaSeries_objectSpread({}, m), {}, {
              type: 'areaPoints',
              lineWidth: 0,
              color: 'rgba(0, 0, 0, 0)',
              // make area border transparent
              fillColor: _this6.getAreaOpacity(m.name, m.color),
              points: [].concat(areaSeries_toConsumableArray(areaPoints), areaSeries_toConsumableArray(pairPoints))
            }));
            areaPoints = [];
          }
        });
      });
      return model;
    }
  }, {
    key: "getCombinedLinePointsModel",
    value: function getCombinedLinePointsModel() {
      var _this7 = this;

      if (!this.isRangeChart) {
        return this.linePointsModel;
      }

      var len = this.linePointsModel.length / 2;
      return range(0, len).reduce(function (acc, i) {
        var start = i;
        var end = len + i;

        var points = _this7.getCombinedPoints(start, end);

        return [].concat(areaSeries_toConsumableArray(acc), [areaSeries_objectSpread(areaSeries_objectSpread({}, _this7.linePointsModel[i]), {}, {
          points: points
        })]);
      }, []);
    }
  }, {
    key: "getAreaOpacity",
    value: function getAreaOpacity(name, color) {
      var _this$theme2 = this.theme,
          select = _this$theme2.select,
          areaOpacity = _this$theme2.areaOpacity;
      var active = this.activeSeriesMap[name];
      var selected = Object.values(this.activeSeriesMap).some(function (elem) {
        return !elem;
      });
      return selected ? getRGBA(color, active ? select.areaOpacity : select.restSeries.areaOpacity) : getRGBA(color, areaOpacity);
    }
  }, {
    key: "renderAreaPointsModel",
    value: function renderAreaPointsModel() {
      var combinedLinePointsModel = this.getCombinedLinePointsModel();
      return this.isRangeChart ? this.renderRangeAreaSeries(combinedLinePointsModel) : this.renderAreaSeries(combinedLinePointsModel);
    }
  }, {
    key: "renderCircleModel",
    value: function renderCircleModel(showDot) {
      var _this8 = this;

      var dotSeriesModel = [];
      var responderModel = [];
      var dotTheme = this.theme.dot;
      this.linePointsModel.forEach(function (_ref4, modelIndex) {
        var points = _ref4.points,
            color = _ref4.color,
            seriesIndex = _ref4.seriesIndex,
            name = _ref4.name;
        var isPairLinePointsModel = _this8.isRangeChart && modelIndex >= _this8.linePointsModel.length / 2;
        var active = _this8.activeSeriesMap[name];
        points.forEach(function (point, index) {
          if (isNull(point)) {
            return;
          }

          var model = areaSeries_objectSpread(areaSeries_objectSpread({
            type: 'circle'
          }, point), {}, {
            seriesIndex: seriesIndex,
            name: name,
            index: isPairLinePointsModel ? points.length - index - 1 : index
          });

          if (showDot) {
            var _dotTheme$borderColor;

            dotSeriesModel.push(areaSeries_objectSpread(areaSeries_objectSpread({}, model), {}, {
              radius: dotTheme.radius,
              color: getRGBA(color, active ? 1 : 0.3),
              style: [{
                lineWidth: dotTheme.borderWidth,
                strokeStyle: (_dotTheme$borderColor = dotTheme.borderColor) !== null && _dotTheme$borderColor !== void 0 ? _dotTheme$borderColor : color
              }]
            }));
          }

          responderModel.push.apply(responderModel, areaSeries_toConsumableArray(_this8.getResponderSeriesWithTheme([model], 'hover', color)));
        });
      });
      return {
        dotSeriesModel: dotSeriesModel,
        responderModel: responderModel
      };
    }
  }, {
    key: "getPairCircleModel",
    value: function getPairCircleModel(circleModels) {
      var _this9 = this;

      var pairCircleModels = [];
      circleModels.forEach(function (circle) {
        var seriesIndex = circle.seriesIndex,
            y = circle.y,
            data = circle.data;
        var category = data.category;

        var pairCircleModel = _this9.tooltipCircleMap[category].find(function (model) {
          return model.seriesIndex === seriesIndex && model.y !== y;
        });

        pairCircleModels.push(pairCircleModel);
      });
      return pairCircleModels;
    }
  }, {
    key: "getCircleModelsFromRectResponders",
    value: function getCircleModelsFromRectResponders(responders, mousePositions) {
      var _this$tooltipCircleMa;

      if (!responders.length || !responders[0].label) {
        return [];
      }

      var models = (_this$tooltipCircleMa = this.tooltipCircleMap[responders[0].label]) !== null && _this$tooltipCircleMa !== void 0 ? _this$tooltipCircleMa : [];
      return this.eventDetectType === 'grouped' ? models : getNearestResponder(models, mousePositions, this.rect);
    }
  }, {
    key: "onMousemoveGroupedType",
    value: function onMousemoveGroupedType(responders) {
      var circleModels = this.getCircleModelsFromRectResponders(responders);
      this.eventBus.emit('renderHoveredSeries', {
        models: circleModels,
        name: this.name,
        eventDetectType: this.eventDetectType
      });
      this.activatedResponders = this.isRangeChart ? circleModels.slice(0, circleModels.length / 2) // for rendering unique tooltip data
      : circleModels;
    }
  }, {
    key: "onMousemoveNearestType",
    value: function onMousemoveNearestType(responders, mousePositions) {
      var circleModels = this.getCircleModelsFromRectResponders(responders, mousePositions);
      this.onMousemoveNearType(circleModels);
    }
  }, {
    key: "onMousemoveNearType",
    value: function onMousemoveNearType(responders) {
      var pairCircleModels = [];

      if (this.isRangeChart) {
        pairCircleModels = this.getPairCircleModel(responders);
      }

      var hoveredSeries = [].concat(areaSeries_toConsumableArray(responders), areaSeries_toConsumableArray(pairCircleModels));
      this.eventBus.emit('renderHoveredSeries', {
        models: hoveredSeries,
        name: this.name,
        eventDetectType: this.eventDetectType
      });
      this.activatedResponders = responders;
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref5) {
      var responders = _ref5.responders,
          mousePosition = _ref5.mousePosition;

      if (this.eventDetectType === 'nearest') {
        this.onMousemoveNearestType(responders, mousePosition);
      } else if (['near', 'point'].includes(this.eventDetectType)) {
        this.onMousemoveNearType(responders);
      } else {
        this.onMousemoveGroupedType(responders);
      }

      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "getDataLabels",
    value: function getDataLabels(seriesModels) {
      var dataLabelTheme = this.theme.dataLabels;
      return seriesModels.flatMap(function (_ref6) {
        var points = _ref6.points,
            name = _ref6.name,
            fillColor = _ref6.fillColor;
        return points.map(function (point) {
          return isNull(point) ? {} : areaSeries_objectSpread(areaSeries_objectSpread({
            type: 'point'
          }, point), {}, {
            name: name,
            theme: areaSeries_objectSpread(areaSeries_objectSpread({}, dataLabelTheme), {}, {
              color: dataLabelTheme.useSeriesColor ? getRGBA(fillColor, 1) : dataLabelTheme.color
            })
          });
        });
      });
    }
  }, {
    key: "getResponderSeriesWithTheme",
    value: function getResponderSeriesWithTheme(models, type, seriesColor) {
      var _ref7 = this.theme[type].dot,
          radius = _ref7.radius,
          color = _ref7.color,
          borderWidth = _ref7.borderWidth,
          borderColor = _ref7.borderColor;
      return models.map(function (model) {
        var _ref8;

        var modelColor = (_ref8 = color !== null && color !== void 0 ? color : model.color) !== null && _ref8 !== void 0 ? _ref8 : seriesColor;
        return areaSeries_objectSpread(areaSeries_objectSpread({}, model), {}, {
          radius: radius,
          color: modelColor,
          style: [{
            lineWidth: borderWidth,
            strokeStyle: borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(modelColor, 0.5)
          }]
        });
      });
    }
  }, {
    key: "onClick",
    value: function onClick(_ref9) {
      var responders = _ref9.responders,
          mousePosition = _ref9.mousePosition;

      if (this.selectable) {
        var models;

        if (this.eventDetectType === 'near') {
          models = responders;
        } else {
          models = this.getCircleModelsFromRectResponders(responders, mousePosition);
        }

        this.eventBus.emit('renderSelectedSeries', {
          models: this.getResponderSeriesWithTheme(models, 'select'),
          name: this.name
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "getResponderCategoryByIndex",
    value: function getResponderCategoryByIndex(index) {
      var _responder$data;

      var responder = Object.values(this.tooltipCircleMap).flatMap(function (val) {
        return val;
      }).find(function (model) {
        return model.index === index;
      });
      return responder === null || responder === void 0 ? void 0 : (_responder$data = responder.data) === null || _responder$data === void 0 ? void 0 : _responder$data.category;
    }
  }]);

  return AreaSeries;
}(Component);


;// CONCATENATED MODULE: ./src/charts/areaChart.ts
function areaChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { areaChart_typeof = function _typeof(obj) { return typeof obj; }; } else { areaChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return areaChart_typeof(obj); }


















function areaChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function areaChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { areaChart_ownKeys(Object(source), true).forEach(function (key) { areaChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { areaChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function areaChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function areaChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function areaChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function areaChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) areaChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) areaChart_defineProperties(Constructor, staticProps); return Constructor; }

function areaChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { areaChart_get = Reflect.get; } else { areaChart_get = function _get(target, property, receiver) { var base = areaChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return areaChart_get(target, property, receiver || target); }

function areaChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = areaChart_getPrototypeOf(object); if (object === null) break; } return object; }

function areaChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) areaChart_setPrototypeOf(subClass, superClass); }

function areaChart_setPrototypeOf(o, p) { areaChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return areaChart_setPrototypeOf(o, p); }

function areaChart_createSuper(Derived) { var hasNativeReflectConstruct = areaChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = areaChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = areaChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return areaChart_possibleConstructorReturn(this, result); }; }

function areaChart_possibleConstructorReturn(self, call) { if (call && (areaChart_typeof(call) === "object" || typeof call === "function")) { return call; } return areaChart_assertThisInitialized(self); }

function areaChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function areaChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function areaChart_getPrototypeOf(o) { areaChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return areaChart_getPrototypeOf(o); }































/**
 * @class
 * @classdesc Area Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Area Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<number|Array<number>>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Area Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.showDot=false] - Whether to show dot or not.
 *       @param {boolean} [props.options.series.spline=false] - Whether to make spline chart or not.
 *       @param {boolean} [props.options.series.zoomable=false] - Whether to use zoom feature or not.
 *       @param {boolean} [props.options.series.rangeSelectable=false] - Whether to use range selection feature or not.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'near', 'nearest', 'grouped', 'point' is available.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *       @param {boolean|Object} [props.options.series.stack] - Option to decide whether to use stack chart and type of stack chart. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Area Chart guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.pointOnColumn=false] - Whether to move the start of the chart to the center of the column.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *       @param {Array<Object>} [props.options.plot.lines] - Plot lines information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *       @param {Array<Object>} [props.options.plot.bands] - Plot bands information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Area Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var AreaChart = /*#__PURE__*/function (_Chart) {
  areaChart_inherits(AreaChart, _Chart);

  var _super = areaChart_createSuper(AreaChart);

  function AreaChart(props) {
    areaChart_classCallCheck(this, AreaChart);

    return _super.call(this, {
      el: props.el,
      options: props.options,
      series: {
        area: props.data.series
      },
      categories: props.data.categories,
      modules: [store_stackSeriesData, store_dataRange, store_scale, store_axes, store_plot]
    });
  }

  areaChart_createClass(AreaChart, [{
    key: "initialize",
    value: function initialize() {
      areaChart_get(areaChart_getPrototypeOf(AreaChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Plot);
      this.componentManager.add(Legend);
      this.componentManager.add(AreaSeries);
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(Axis, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(DataLabels);
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(ResetButton);
      this.componentManager.add(RangeSelection);
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, brushes_lineSeries_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, brushes_resetButton_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */

  }, {
    key: "addData",
    value: function addData(data, category) {
      this.resetSeries();
      this.animationControlFlag.updating = true;
      this.store.dispatch('addData', {
        data: data,
        category: category
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number|Array<number>>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          area: series
        },
        categories: categories
      });
    }
    /**
     * Add plot line.
     * @param {Object} data - Plot info.
     *   @param {string|number} data.value - The value where the plot line will be drawn.
     *   @param {string} data.color - Plot line color.
     *   @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
     * @api
     * @example
     * chart.addPlotLine({
     *   value: 2,
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotLine",
    value: function addPlotLine(data) {
      this.store.dispatch('addPlotLine', {
        data: data
      });
    }
    /**
     * Remove plot line with id.
     * @param {string} id - Id of the plot line to be removed.
     * @api
     * @example
     * chart.removePlotLine('plot-1');
     */

  }, {
    key: "removePlotLine",
    value: function removePlotLine(id) {
      this.store.dispatch('removePlotLine', {
        id: id
      });
    }
    /**
     * Add plot band.
     * @param {Object} data - Plot info.
     * @param {Array<string|number>} data.range - The range to be drawn.
     * @param {string} data.color - Plot band color.
     * @param {string} [data.id] - Plot id. The value on which the removePlotBand is based.
     * @api
     * @example
     * chart.addPlotBand({
     *   value: [2, 4],
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotBand",
    value: function addPlotBand(data) {
      this.store.dispatch('addPlotBand', {
        data: data
      });
    }
    /**
     * Remove plot band with id.
     * @param {string} id - id of the plot band to be removed.
     * @api
     * @example
     * chart.removePlotBand('plot-1');
     */

  }, {
    key: "removePlotBand",
    value: function removePlotBand(id) {
      this.store.dispatch('removePlotBand', {
        id: id
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only seriesIndex is needed.
     *      @param {number} [seriesInfo.seriesIndex] - Index of series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', areaChart_objectSpread({}, seriesInfo));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return AreaChart;
}(Chart);


;// CONCATENATED MODULE: ./src/component/scatterSeries.ts
function scatterSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { scatterSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { scatterSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return scatterSeries_typeof(obj); }

function scatterSeries_toConsumableArray(arr) { return scatterSeries_arrayWithoutHoles(arr) || scatterSeries_iterableToArray(arr) || scatterSeries_unsupportedIterableToArray(arr) || scatterSeries_nonIterableSpread(); }

function scatterSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function scatterSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return scatterSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return scatterSeries_arrayLikeToArray(o, minLen); }

function scatterSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function scatterSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return scatterSeries_arrayLikeToArray(arr); }

function scatterSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function component_scatterSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function component_scatterSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { component_scatterSeries_ownKeys(Object(source), true).forEach(function (key) { component_scatterSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { component_scatterSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }


























function scatterSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function scatterSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function scatterSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) scatterSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) scatterSeries_defineProperties(Constructor, staticProps); return Constructor; }

function scatterSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) scatterSeries_setPrototypeOf(subClass, superClass); }

function scatterSeries_setPrototypeOf(o, p) { scatterSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return scatterSeries_setPrototypeOf(o, p); }

function scatterSeries_createSuper(Derived) { var hasNativeReflectConstruct = scatterSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = scatterSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = scatterSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return scatterSeries_possibleConstructorReturn(this, result); }; }

function scatterSeries_possibleConstructorReturn(self, call) { if (call && (scatterSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return scatterSeries_assertThisInitialized(self); }

function scatterSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function scatterSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function scatterSeries_getPrototypeOf(o) { scatterSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return scatterSeries_getPrototypeOf(o); }

function component_scatterSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }












var ScatterSeries = /*#__PURE__*/function (_Component) {
  scatterSeries_inherits(ScatterSeries, _Component);

  var _super = scatterSeries_createSuper(ScatterSeries);

  function ScatterSeries() {
    var _this;

    scatterSeries_classCallCheck(this, ScatterSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "theme", void 0);

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "models", {
      series: []
    });

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "drawModels", void 0);

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "responders", void 0);

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "activatedResponders", []);

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "rect", void 0);

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "getModelsForSelectInfo", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex,
          state = info.state;

      if (!isNumber(index) || !isNumber(seriesIndex) || !isAvailableSelectSeries(info, 'scatter')) {
        return;
      }

      var name = state.series.scatter.data[seriesIndex].name;
      return [_this.responders.filter(function (_ref) {
        var dataName = _ref.name;
        return dataName === name;
      })[index]];
    });

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "selectSeries", function (info) {
      var models = _this.getModelsForSelectInfo(info);

      if (!models) {
        return;
      }

      var closestModel = _this.getClosestModel(models);

      if (!models.length) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: _this.getResponderAppliedTheme(closestModel, 'select'),
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    component_scatterSeries_defineProperty(scatterSeries_assertThisInitialized(_this), "showTooltip", function (info) {
      var models = _this.getModelsForSelectInfo(info);

      if (!models) {
        return;
      }

      _this.eventBus.emit('renderHoveredSeries', {
        models: models,
        name: _this.name
      });

      _this.activatedResponders = models;

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  scatterSeries_createClass(ScatterSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'scatter';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      var _this2 = this;

      this.drawModels.series.forEach(function (model, index) {
        model.size = _this2.models.series[index].size * delta;
      });
    }
  }, {
    key: "render",
    value: function render(chartState) {
      var _labelRange,
          _axes$xAxis,
          _this3 = this;

      var layout = chartState.layout,
          series = chartState.series,
          scale = chartState.scale,
          legend = chartState.legend,
          options = chartState.options,
          theme = chartState.theme,
          axes = chartState.axes;

      if (!series.scatter) {
        throw new Error(message.noDataError(this.name));
      }

      var scatterData = series.scatter.data;
      this.theme = theme.series.scatter;
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      var limit = (_labelRange = (_axes$xAxis = axes.xAxis) === null || _axes$xAxis === void 0 ? void 0 : _axes$xAxis.labelRange) !== null && _labelRange !== void 0 ? _labelRange : scale.xAxis.limit; // labelRange is created only for line scatter charts

      var seriesModel = this.renderScatterPointsModel(scatterData, limit, scale[getValueAxisName(options, this.name, 'yAxis')].limit);
      var tooltipModel = this.makeTooltipModel(scatterData);
      this.models.series = seriesModel;

      if (!this.drawModels) {
        this.drawModels = deepCopy(this.models);
      }

      this.responders = seriesModel.map(function (m, index) {
        return component_scatterSeries_objectSpread(component_scatterSeries_objectSpread({}, m), {}, {
          type: 'circle',
          detectionSize: 0,
          radius: _this3.theme.size / 2,
          color: m.fillColor,
          style: [{
            strokeStyle: m.borderColor,
            lineWidth: m.borderWidth
          }],
          data: tooltipModel[index]
        });
      });
    }
  }, {
    key: "renderScatterPointsModel",
    value: function renderScatterPointsModel(seriesRawData, xAxisLimit, yAxisLimit) {
      var _this4 = this;

      return seriesRawData.flatMap(function (_ref2, seriesIndex) {
        var data = _ref2.data,
            name = _ref2.name,
            seriesColor = _ref2.color,
            iconType = _ref2.iconType;
        var models = [];
        var active = _this4.activeSeriesMap[name];
        var color = getRGBA(seriesColor, active ? 1 : 0.3);
        data.forEach(function (datum, index) {
          var rawXValue = getCoordinateXValue(datum);
          var xValue = utils_isString(rawXValue) ? Number(new Date(rawXValue)) : Number(rawXValue);
          var yValue = getCoordinateYValue(datum);
          var xValueRatio = getValueRatio(xValue, xAxisLimit);
          var yValueRatio = getValueRatio(yValue, yAxisLimit);
          var x = xValueRatio * _this4.rect.width;
          var y = (1 - yValueRatio) * _this4.rect.height;
          models.push(component_scatterSeries_objectSpread({
            x: x,
            y: y,
            type: 'scatterSeries',
            iconType: iconType,
            seriesIndex: seriesIndex,
            name: name,
            borderColor: color,
            index: index
          }, pick(_this4.theme, 'borderWidth', 'size', 'fillColor')));
        });
        return models;
      });
    }
  }, {
    key: "makeTooltipModel",
    value: function makeTooltipModel(circleData) {
      return scatterSeries_toConsumableArray(circleData).flatMap(function (_ref3) {
        var data = _ref3.data,
            name = _ref3.name,
            color = _ref3.color;
        var tooltipData = [];
        data.forEach(function (datum) {
          var value = {
            x: getCoordinateXValue(datum),
            y: getCoordinateYValue(datum)
          };
          tooltipData.push({
            label: name,
            color: color,
            value: value
          });
        });
        return tooltipData;
      });
    }
  }, {
    key: "getClosestModel",
    value: function getClosestModel(closestResponder) {
      if (!closestResponder.length) {
        return [];
      }

      var model = this.models.series.find(function (_ref4) {
        var index = _ref4.index,
            seriesIndex = _ref4.seriesIndex;
        return isNumber(index) && isNumber(seriesIndex) && index === closestResponder[0].index && seriesIndex === closestResponder[0].seriesIndex;
      });
      return model ? [model] : [];
    }
  }, {
    key: "getResponderAppliedTheme",
    value: function getResponderAppliedTheme(closestModel, type) {
      var _this5 = this;

      var _this$theme$type = this.theme[type],
          fillColor = _this$theme$type.fillColor,
          size = _this$theme$type.size;
      return closestModel.map(function (m) {
        return deepMergedCopy(m, component_scatterSeries_objectSpread(component_scatterSeries_objectSpread({}, _this5.theme[type]), {}, {
          color: fillColor,
          radius: size / 2
        }));
      });
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref5) {
      var responders = _ref5.responders,
          mousePosition = _ref5.mousePosition;
      var closestResponder = getNearestResponder(responders, mousePosition, this.rect);
      var closestModel = this.getClosestModel(closestResponder);
      closestModel = this.getResponderAppliedTheme(closestModel, 'hover');
      this.eventBus.emit('renderHoveredSeries', {
        models: closestModel,
        name: this.name
      });
      this.activatedResponders = closestResponder;
      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "onClick",
    value: function onClick(_ref6) {
      var responders = _ref6.responders,
          mousePosition = _ref6.mousePosition;

      if (this.selectable) {
        var closestResponder = getNearestResponder(responders, mousePosition, this.rect);
        var closestModel = this.getClosestModel(closestResponder);
        closestModel = this.getResponderAppliedTheme(closestModel, 'select');
        this.eventBus.emit('renderSelectedSeries', {
          models: closestModel,
          name: this.name
        });
        this.eventBus.emit('needDraw');
      }
    }
  }]);

  return ScatterSeries;
}(Component);


;// CONCATENATED MODULE: ./src/charts/lineScatterChart.ts
function lineScatterChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { lineScatterChart_typeof = function _typeof(obj) { return typeof obj; }; } else { lineScatterChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return lineScatterChart_typeof(obj); }


















function lineScatterChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function lineScatterChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { lineScatterChart_ownKeys(Object(source), true).forEach(function (key) { lineScatterChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { lineScatterChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function lineScatterChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function lineScatterChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function lineScatterChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function lineScatterChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) lineScatterChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) lineScatterChart_defineProperties(Constructor, staticProps); return Constructor; }

function lineScatterChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { lineScatterChart_get = Reflect.get; } else { lineScatterChart_get = function _get(target, property, receiver) { var base = lineScatterChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return lineScatterChart_get(target, property, receiver || target); }

function lineScatterChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = lineScatterChart_getPrototypeOf(object); if (object === null) break; } return object; }

function lineScatterChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) lineScatterChart_setPrototypeOf(subClass, superClass); }

function lineScatterChart_setPrototypeOf(o, p) { lineScatterChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return lineScatterChart_setPrototypeOf(o, p); }

function lineScatterChart_createSuper(Derived) { var hasNativeReflectConstruct = lineScatterChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = lineScatterChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = lineScatterChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return lineScatterChart_possibleConstructorReturn(this, result); }; }

function lineScatterChart_possibleConstructorReturn(self, call) { if (call && (lineScatterChart_typeof(call) === "object" || typeof call === "function")) { return call; } return lineScatterChart_assertThisInitialized(self); }

function lineScatterChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function lineScatterChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function lineScatterChart_getPrototypeOf(o) { lineScatterChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return lineScatterChart_getPrototypeOf(o); }































/**
 * @class
 * @classdesc LineScatter Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making LineArea Chart.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {Array<Object>} props.data.series.line - Line series data. Only coordinate type data is possible.
 *       @param {Array<Object>} props.data.series.scatter - Scatter series data.
 *   @param {Object} [props.options] - Options for making LineScatter Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series] - Write common options in the upper depth and separate options to be applied to each chart.
 *       @param {Object} [props.options.series.line] - Options to be applied to the line chart. 'spline', 'showDot' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Line Chart guide} on github.
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.pointOnColumn=false] - Whether to move the start of the chart to the center of the column.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|LineScatter Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme. Each theme to be applied to the two charts should be written separately.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var LineScatterChart = /*#__PURE__*/function (_Chart) {
  lineScatterChart_inherits(LineScatterChart, _Chart);

  var _super = lineScatterChart_createSuper(LineScatterChart);

  function LineScatterChart(props) {
    lineScatterChart_classCallCheck(this, LineScatterChart);

    return _super.call(this, {
      el: props.el,
      options: props.options,
      series: props.data.series,
      modules: [store_dataRange, store_scale, store_axes, store_plot]
    });
  }

  lineScatterChart_createClass(LineScatterChart, [{
    key: "initialize",
    value: function initialize() {
      lineScatterChart_get(lineScatterChart_getPrototypeOf(LineScatterChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Plot);
      this.componentManager.add(Legend);
      this.componentManager.add(LineSeries);
      this.componentManager.add(ScatterSeries);
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(Axis, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(DataLabels);
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(RangeSelection);
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, brushes_lineSeries_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, brushes_resetButton_namespaceObject, scatterSeries_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array} data - Array of data to be added.
     * @param {string} chartType - Which type of chart to add.
     * @api
     * @example
     * chart.addData([{x: 10, y: 20}, {x: 30, y: 40}], 'line');
     */

  }, {
    key: "addData",
    value: function addData(data, chartType) {
      this.animationControlFlag.updating = true;
      this.resetSeries();
      this.store.dispatch('addData', {
        data: data,
        chartType: chartType
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<Object>} data.data - Array of data to be added.
     * @param {Object} dataInfo - Which type of chart to add.
     *   @param {Object} dataInfo.chartType - Chart type.
     * @api
     * @example
     * chart.addSeries(
     *   {
     *     name: 'newSeries',
     *     data: [{x: 10, y: 20}, {x: 30, y: 40}],
     *   },
     *   {
     *     chartType: 'line'
     *   });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data, dataInfo) {
      this.resetSeries();
      this.store.dispatch('addSeries', lineScatterChart_objectSpread({
        data: data
      }, dataInfo));
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   series: {
     *     line: [
     *       {
     *         name: 'A',
     *         data: [{x: 10, y: 20}, {x: 30, y: 40}],
     *       }
     *     ],
     *     scatter: [
     *       {
     *         name: 'B',
     *         data: [{x: 30, y: 20}, {x: 40, y: 40}],
     *       }
     *     ]
     *   }
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      this.resetSeries();
      this.store.dispatch('setData', data);
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     line: {
     *       showDot: true,
     *     },
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     line: {
     *       showDot: true,
     *     },
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed
     *      @param {number} seriesInfo.seriesIndex - Index of series
     *      @param {number} seriesInfo.index - Index of data within series
     *      @param {string} seriesInfo.chartType - Specify which chart to select.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2, chartType: 'scatter'});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', lineScatterChart_objectSpread(lineScatterChart_objectSpread({}, seriesInfo), {}, {
        state: this.store.state
      }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return LineScatterChart;
}(Chart);


;// CONCATENATED MODULE: ./src/charts/lineAreaChart.ts
function lineAreaChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { lineAreaChart_typeof = function _typeof(obj) { return typeof obj; }; } else { lineAreaChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return lineAreaChart_typeof(obj); }


















function lineAreaChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function lineAreaChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { lineAreaChart_ownKeys(Object(source), true).forEach(function (key) { lineAreaChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { lineAreaChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function lineAreaChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function lineAreaChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function lineAreaChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function lineAreaChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) lineAreaChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) lineAreaChart_defineProperties(Constructor, staticProps); return Constructor; }

function lineAreaChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { lineAreaChart_get = Reflect.get; } else { lineAreaChart_get = function _get(target, property, receiver) { var base = lineAreaChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return lineAreaChart_get(target, property, receiver || target); }

function lineAreaChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = lineAreaChart_getPrototypeOf(object); if (object === null) break; } return object; }

function lineAreaChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) lineAreaChart_setPrototypeOf(subClass, superClass); }

function lineAreaChart_setPrototypeOf(o, p) { lineAreaChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return lineAreaChart_setPrototypeOf(o, p); }

function lineAreaChart_createSuper(Derived) { var hasNativeReflectConstruct = lineAreaChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = lineAreaChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = lineAreaChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return lineAreaChart_possibleConstructorReturn(this, result); }; }

function lineAreaChart_possibleConstructorReturn(self, call) { if (call && (lineAreaChart_typeof(call) === "object" || typeof call === "function")) { return call; } return lineAreaChart_assertThisInitialized(self); }

function lineAreaChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function lineAreaChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function lineAreaChart_getPrototypeOf(o) { lineAreaChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return lineAreaChart_getPrototypeOf(o); }
































/**
 * @class
 * @classdesc LineArea Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making LineArea Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {Array<Object>} props.data.series.line - Line series data. Coordinate types data is not possible.
 *       @param {Array<Object>} props.data.series.area - Area series data.
 *   @param {Object} [props.options] - Options for making LineArea Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series] - Write common options in the upper depth and separate options to be applied to each chart.
 *       @param {Object} [props.options.series.line] - Options to be applied to the line chart. 'spline', 'showDot', 'dataLabels' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Line Chart guide} on github.
 *       @param {Object} [props.options.series.area] - Options to be applied to the area chart. 'stack', 'spline', 'showDot', 'dataLabels' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Area Chart guide} on github.
 *       @param {boolean} [props.options.series.zoomable=false] - Whether to use zoom feature or not.
 *       @param {boolean} [props.options.series.rangeSelectable=false] - Whether to use range selection feature or not.
 *       @param {boolean} [props.options.series.showDot=false] - Whether to show dot or not.
 *       @param {boolean} [props.options.series.spline=false] - Whether to make spline chart or not.
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.pointOnColumn=false] - Whether to move the start of the chart to the center of the column.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *       @param {Array<Object>} [props.options.plot.lines] - Plot lines information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *       @param {Array<Object>} [props.options.plot.bands] - Plot bands information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|LineArea Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme. Each theme to be applied to the two charts should be written separately.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var LineAreaChart = /*#__PURE__*/function (_Chart) {
  lineAreaChart_inherits(LineAreaChart, _Chart);

  var _super = lineAreaChart_createSuper(LineAreaChart);

  function LineAreaChart(props) {
    lineAreaChart_classCallCheck(this, LineAreaChart);

    return _super.call(this, {
      el: props.el,
      options: props.options,
      series: props.data.series,
      categories: props.data.categories,
      modules: [store_stackSeriesData, store_dataRange, store_scale, store_axes, store_plot]
    });
  }

  lineAreaChart_createClass(LineAreaChart, [{
    key: "initialize",
    value: function initialize() {
      lineAreaChart_get(lineAreaChart_getPrototypeOf(LineAreaChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Plot);
      this.componentManager.add(Legend);
      this.componentManager.add(AreaSeries);
      this.componentManager.add(LineSeries);
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(Axis, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(DataLabels);
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(RangeSelection);
      this.componentManager.add(ResetButton);
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, brushes_lineSeries_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, brushes_resetButton_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array<number>} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @param {string} chartType - Which type of chart to add.
     * @api
     * @example
     * chart.addData([10, 20], '6', 'line');
     */

  }, {
    key: "addData",
    value: function addData(data, category, chartType) {
      this.animationControlFlag.updating = true;
      this.resetSeries();
      this.store.dispatch('addData', {
        data: data,
        category: category,
        chartType: chartType
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number>} data.data - Array of data to be added.
     * @param {Object} dataInfo - Which type of chart to add.
     *   @param {Object} dataInfo.chartType - Chart type.
     * @api
     * @example
     * chart.addSeries(
     *   {
     *     name: 'newSeries',
     *     data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     *   },
     *   {
     *     chartType: 'line'
     *   });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data, dataInfo) {
      this.resetSeries();
      this.store.dispatch('addSeries', lineAreaChart_objectSpread({
        data: data
      }, dataInfo));
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: {
     *     line: [
     *       {
     *         name: 'A',
     *         data: [1, 2, 3],
     *       }
     *     ],
     *     area: [
     *       {
     *         name: 'B',
     *         data: [4, 5, 6],
     *       }
     *     ]
     *   }
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      this.resetSeries();
      this.store.dispatch('setData', data);
    }
    /**
     * Add plot line.
     * @param {Object} data - plot info
     *   @param {string|number} data.value - The value where the plot line will be drawn.
     *   @param {string} data.color - Plot line color.
     *   @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
     * @api
     * @example
     * chart.addPlotLine({
     *   value: 2,
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotLine",
    value: function addPlotLine(data) {
      this.store.dispatch('addPlotLine', {
        data: data
      });
    }
    /**
     * Remove plot line with id.
     * @param {string} id - Id of the plot line to be removed.
     * @api
     * @example
     * chart.removePlotLine('plot-1');
     */

  }, {
    key: "removePlotLine",
    value: function removePlotLine(id) {
      this.store.dispatch('removePlotLine', {
        id: id
      });
    }
    /**
     * Add plot band.
     * @param {Object} data - Plot info.
     * @param {Array<string|number>} data.range - The range to be drawn.
     * @param {string} data.color - Plot band color.
     * @param {string} [data.id] - Plot id. The value on which the removePlotBand is based.
     * @api
     * @example
     * chart.addPlotBand({
     *   value: [2, 4],
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotBand",
    value: function addPlotBand(data) {
      this.store.dispatch('addPlotBand', {
        data: data
      });
    }
    /**
     * Remove plot band with id.
     * @param {string} id - Id of the plot band to be removed.
     * @api
     * @example
     * chart.removePlotBand('plot-1');
     */

  }, {
    key: "removePlotBand",
    value: function removePlotBand(id) {
      this.store.dispatch('removePlotBand', {
        id: id
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     line: {
     *       showDot: true
     *     },
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     line: {
     *       showDot: true,
     *     },
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.index - Index of data within series.
     *      @param {string} seriesInfo.chartType - Specify which chart to select.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2, chartType: 'line'});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', lineAreaChart_objectSpread({}, seriesInfo));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return LineAreaChart;
}(Chart);


;// CONCATENATED MODULE: ./src/helpers/boxSeries.ts
function limitNegative(value, min, max) {
  var result = value;

  if (result >= max) {
    return 0;
  }

  if (max < 0) {
    result = Math.min(value - max, 0);
  }

  if (value < min) {
    result -= value - min;
  }

  return result;
}

function limitPositive(value, min, max) {
  var result = value;

  if (min > 0) {
    result = Math.max(value - min, 0);
  }

  if (value > max) {
    result -= value - max;
  }

  return result;
}

function calibrateDrawingValue(value, min, max) {
  return value < 0 ? limitNegative(value, min, max) : limitPositive(value, min, max);
}
function sumValuesBeforeIndex(values, targetIndex) {
  var includeTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var target = values[targetIndex];
  return values.reduce(function (total, value, idx) {
    var isBefore = includeTarget ? idx <= targetIndex : idx < targetIndex;
    var isSameSign = value * target >= 0;
    return isBefore && isSameSign ? total + value : total;
  }, 0);
}
function outsideRange(values, currentIndex, min, max) {
  var value = values[currentIndex];
  var totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);
  var positive = value >= 0;
  var negative = value < 0;
  return positive && totalOfIndexBefore >= max || negative && totalOfIndexBefore <= min || currentIndex === 0 && positive && value < min || currentIndex === 0 && negative && value > max;
}
function calibrateBoxStackDrawingValue(values, currentIndex, min, max) {
  var totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);
  var totalOfValues = sumValuesBeforeIndex(values, currentIndex, true);

  if (outsideRange(values, currentIndex, min, max)) {
    return null;
  }

  if (currentIndex === 0) {
    return calibrateDrawingValue(values[currentIndex], min, max);
  }

  if (totalOfIndexBefore < min && totalOfValues > max) {
    return max - min;
  }

  var result = values[currentIndex];

  if (totalOfValues > max) {
    result = max - totalOfIndexBefore;
  } else if (totalOfValues < min) {
    result = min - totalOfIndexBefore;
  } else if (totalOfIndexBefore < min) {
    result = totalOfValues - min;
  } else if (totalOfIndexBefore > max) {
    result = totalOfValues - max;
  }

  return result;
}
;// CONCATENATED MODULE: ./src/component/boxSeries.ts
function boxSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { boxSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { boxSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return boxSeries_typeof(obj); }

function boxSeries_toConsumableArray(arr) { return boxSeries_arrayWithoutHoles(arr) || boxSeries_iterableToArray(arr) || boxSeries_unsupportedIterableToArray(arr) || boxSeries_nonIterableSpread(); }

function boxSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function boxSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function boxSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return boxSeries_arrayLikeToArray(arr); }

function boxSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function boxSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { boxSeries_ownKeys(Object(source), true).forEach(function (key) { boxSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { boxSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
























function boxSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function boxSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function boxSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) boxSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) boxSeries_defineProperties(Constructor, staticProps); return Constructor; }

function boxSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) boxSeries_setPrototypeOf(subClass, superClass); }

function boxSeries_setPrototypeOf(o, p) { boxSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return boxSeries_setPrototypeOf(o, p); }

function boxSeries_createSuper(Derived) { var hasNativeReflectConstruct = boxSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = boxSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = boxSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return boxSeries_possibleConstructorReturn(this, result); }; }

function boxSeries_possibleConstructorReturn(self, call) { if (call && (boxSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return boxSeries_assertThisInitialized(self); }

function boxSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function boxSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function boxSeries_getPrototypeOf(o) { boxSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return boxSeries_getPrototypeOf(o); }

function boxSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function boxSeries_slicedToArray(arr, i) { return boxSeries_arrayWithHoles(arr) || boxSeries_iterableToArrayLimit(arr, i) || boxSeries_unsupportedIterableToArray(arr, i) || boxSeries_nonIterableRest(); }

function boxSeries_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function boxSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return boxSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return boxSeries_arrayLikeToArray(o, minLen); }

function boxSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function boxSeries_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function boxSeries_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }














var SeriesDirection;

(function (SeriesDirection) {
  SeriesDirection[SeriesDirection["POSITIVE"] = 0] = "POSITIVE";
  SeriesDirection[SeriesDirection["NEGATIVE"] = 1] = "NEGATIVE";
  SeriesDirection[SeriesDirection["BOTH"] = 2] = "BOTH";
})(SeriesDirection || (SeriesDirection = {}));

var BOX = {
  BAR: 'bar',
  COLUMN: 'column'
};
function isLeftBottomSide(seriesIndex) {
  return !!(seriesIndex % 2);
}

function calculateBarLength(value, min, max) {
  if (isRangeValue(value)) {
    var _value = boxSeries_slicedToArray(value, 2),
        start = _value[0],
        end = _value[1];

    if (start < min) {
      start = min;
    }

    if (end > max) {
      end = max;
    }

    return end - start;
  }

  return calibrateDrawingValue(value, min, max);
}

var BoxSeries = /*#__PURE__*/function (_Component) {
  boxSeries_inherits(BoxSeries, _Component);

  var _super = boxSeries_createSuper(BoxSeries);

  function BoxSeries() {
    var _this;

    boxSeries_classCallCheck(this, BoxSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "models", {
      series: []
    });

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "drawModels", void 0);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "responders", void 0);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "activatedResponders", []);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "isBar", true);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "valueAxis", 'xAxis');

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "labelAxis", 'yAxis');

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "anchorSizeKey", 'height');

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "offsetSizeKey", 'width');

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "basePosition", 0);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "leftBasePosition", 0);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "rightBasePosition", 0);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "isRangeData", false);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "offsetKey", 'x');

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "eventDetectType", 'point');

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "tooltipRectMap", void 0);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "theme", void 0);

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.eventBus.emit('needDraw');
    });

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "selectSeries", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex;

      if (!isAvailableSelectSeries(info, 'column')) {
        return;
      }

      var model = _this.tooltipRectMap[seriesIndex][index];

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: _this.getRespondersWithTheme([model], 'select'),
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    boxSeries_defineProperty(boxSeries_assertThisInitialized(_this), "showTooltip", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex;

      if (!isAvailableShowTooltipInfo(info, _this.eventDetectType, 'column')) {
        return;
      }

      var models = _this.eventDetectType === 'grouped' ? _this.getGroupedRect([_this.responders[index]], 'hover') : _this.getRespondersWithTheme([_this.tooltipRectMap[index][seriesIndex]], 'hover');

      if (!models.length) {
        return;
      }

      _this.eventBus.emit('renderHoveredSeries', {
        models: models,
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.activatedResponders = _this.eventDetectType === 'grouped' ? _this.tooltipRectMap[index] : models;

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  boxSeries_createClass(BoxSeries, [{
    key: "initialize",
    value: function initialize(_ref) {
      var name = _ref.name,
          stackChart = _ref.stackChart;
      this.initializeFields(name);

      if (!stackChart) {
        this.eventBus.on('selectSeries', this.selectSeries);
        this.eventBus.on('showTooltip', this.showTooltip);
        this.eventBus.on('hideTooltip', this.onMouseoutComponent);
      }
    }
  }, {
    key: "initializeFields",
    value: function initializeFields(name) {
      this.type = 'series';
      this.name = name;
      this.isBar = name === BOX.BAR;
      this.offsetKey = this.isBar ? 'x' : 'y';
      this.valueAxis = this.isBar ? 'xAxis' : 'yAxis';
      this.labelAxis = this.isBar ? 'yAxis' : 'xAxis';
      this.anchorSizeKey = this.isBar ? 'height' : 'width';
      this.offsetSizeKey = this.isBar ? 'width' : 'height';
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      if (!this.drawModels) {
        return;
      }

      if (this.isRangeData) {
        this.initUpdateRangeData(delta);
        return;
      }

      this.initUpdateClipRect(delta);
      this.initUpdateConnector(delta);
    }
  }, {
    key: "initUpdateRangeData",
    value: function initUpdateRangeData(delta) {
      var _this2 = this;

      var series = this.drawModels.series;
      this.drawModels.clipRect = this.models.clipRect;
      var target = this.models.series;
      series.forEach(function (current, index) {
        var targetModel = target[index];

        if (delta === 0) {
          current[_this2.offsetSizeKey] = 0;
        }

        var offsetSize = current[_this2.offsetSizeKey] + (targetModel[_this2.offsetSizeKey] - current[_this2.offsetSizeKey]) * delta;
        current[_this2.offsetSizeKey] = offsetSize;

        if (!_this2.isBar) {
          current[_this2.offsetKey] = targetModel[_this2.offsetKey] + targetModel[_this2.offsetSizeKey] - offsetSize;
        }
      });
    }
  }, {
    key: "initUpdateClipRect",
    value: function initUpdateClipRect(delta) {
      var clipRect = this.drawModels.clipRect;

      if (!clipRect) {
        return;
      }

      var current = clipRect[0];
      var key = this.offsetSizeKey;
      var target = this.models.clipRect[0];
      var offsetSize = current[key] + (target[key] - current[key]) * delta;
      current[key] = offsetSize;
      current[this.offsetKey] = Math.max(this.basePosition - offsetSize * this.basePosition / target[key], 0);
    }
  }, {
    key: "initUpdateConnector",
    value: function initUpdateConnector(delta) {
      var connector = this.drawModels.connector;

      if (!connector) {
        return;
      }

      var target = this.models.connector;
      connector.forEach(function (current, index) {
        var alpha = getAlpha(target[index].strokeStyle) * delta;
        current.strokeStyle = getRGBA(current.strokeStyle, alpha);
      });
    }
  }, {
    key: "setEventDetectType",
    value: function setEventDetectType(series, options) {
      var _options$series;

      if (series.line) {
        this.eventDetectType = 'grouped';
      }

      if (options !== null && options !== void 0 && (_options$series = options.series) !== null && _options$series !== void 0 && _options$series.eventDetectType) {
        this.eventDetectType = options.series.eventDetectType;
      }
    }
  }, {
    key: "getOptions",
    value: function getOptions(chartOptions) {
      var options = boxSeries_objectSpread({}, chartOptions);

      if (options !== null && options !== void 0 && options.series && options.series.column) {
        options.series = boxSeries_objectSpread(boxSeries_objectSpread({}, options.series), options.series.column);
      }

      return options;
    }
  }, {
    key: "render",
    value: function render(chartState, computed) {
      var _ref2,
          _options$series2,
          _this3 = this;

      var layout = chartState.layout,
          series = chartState.series,
          axes = chartState.axes,
          stackSeries = chartState.stackSeries,
          legend = chartState.legend,
          theme = chartState.theme,
          scale = chartState.scale;
      this.isShow = !(stackSeries && stackSeries[this.name]);

      if (!this.isShow) {
        return;
      }

      var categories = (_ref2 = chartState.categories) !== null && _ref2 !== void 0 ? _ref2 : [];
      var options = this.getOptions(chartState.options);
      this.setEventDetectType(series, options);
      this.theme = theme.series[this.name];
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      this.valueAxis = getValueAxisName(options, this.name, this.isBar ? 'xAxis' : 'yAxis');
      var seriesData = series[this.name].data.map(function (seriesDatum) {
        return boxSeries_objectSpread(boxSeries_objectSpread({}, seriesDatum), {}, {
          data: getDataInRange(seriesDatum.data, computed.viewRange)
        });
      });

      if (axes.centerYAxis) {
        this.valueAxis = 'centerYAxis';
      }

      var tickDistance = axes[this.labelAxis].tickDistance;
      var diverging = !!((_options$series2 = options.series) !== null && _options$series2 !== void 0 && _options$series2.diverging);

      var _this$getScaleData = this.getScaleData(scale),
          limit = _this$getScaleData.limit,
          stepSize = _this$getScaleData.stepSize;

      var labels = makeLabelsFromLimit(limit, stepSize);

      var _getLimitOnAxis = getLimitOnAxis(labels),
          min = _getLimitOnAxis.min,
          max = _getLimitOnAxis.max;

      this.basePosition = this.getBasePosition(axes[this.valueAxis]);
      var offsetSize = this.getOffsetSize();
      var centerYAxis = axes.centerYAxis;

      if (diverging) {
        var _this$getDivergingBas = this.getDivergingBasePosition(centerYAxis),
            _this$getDivergingBas2 = boxSeries_slicedToArray(_this$getDivergingBas, 2),
            left = _this$getDivergingBas2[0],
            right = _this$getDivergingBas2[1];

        this.basePosition = this.getOffsetSize() / 2;
        this.leftBasePosition = left;
        this.rightBasePosition = right;
        offsetSize = this.getOffsetSizeWithDiverging(centerYAxis);
      }

      var renderOptions = {
        min: min,
        max: max,
        tickDistance: tickDistance,
        diverging: diverging,
        ratio: this.getValueRatio(min, max, offsetSize),
        hasNegativeValue: hasNegative(labels),
        seriesDirection: this.getSeriesDirection(labels),
        defaultPadding: getBoxTypeSeriesPadding(tickDistance)
      };
      var seriesModels = this.renderSeriesModel(seriesData, renderOptions);
      var tooltipData = this.makeTooltipData(seriesData, renderOptions, categories);
      var clipRect = this.renderClipRectAreaModel();
      this.models = {
        clipRect: [clipRect],
        series: seriesModels
      };

      if (!this.drawModels) {
        this.drawModels = {
          clipRect: [this.initClipRect(clipRect)],
          series: deepCopyArray(seriesModels)
        };
      }

      if (getDataLabelsOptions(options, this.name).visible) {
        var dataLabelData = seriesModels.reduce(function (acc, data) {
          return isRangeValue(data.value) ? [].concat(boxSeries_toConsumableArray(acc), boxSeries_toConsumableArray(_this3.makeDataLabelRangeData(data))) : [].concat(boxSeries_toConsumableArray(acc), [_this3.makeDataLabel(data, centerYAxis)]);
        }, []);
        this.renderDataLabels(dataLabelData);
      }

      this.tooltipRectMap = this.makeTooltipRectMap(seriesModels, tooltipData);
      this.responders = this.getBoxSeriesResponders(seriesModels, tooltipData, axes, categories);
    }
  }, {
    key: "getScaleData",
    value: function getScaleData(scale) {
      return scale[this.valueAxis === 'centerYAxis' ? 'xAxis' : this.valueAxis];
    }
  }, {
    key: "getBoxSeriesResponders",
    value: function getBoxSeriesResponders(seriesModels, tooltipData, axes, categories) {
      var hoveredSeries = this.renderHoveredSeriesModel(seriesModels);
      return this.eventDetectType === 'grouped' ? makeRectResponderModel(this.rect, this.isBar ? axes.yAxis : axes.xAxis, categories, !this.isBar) : hoveredSeries.map(function (m, index) {
        return boxSeries_objectSpread(boxSeries_objectSpread({}, m), {}, {
          data: tooltipData[index]
        });
      });
    }
  }, {
    key: "makeTooltipRectMap",
    value: function makeTooltipRectMap(seriesModels, tooltipDataArr) {
      return seriesModels.reduce(function (acc, cur, dataIndex) {
        var index = cur.index;

        var tooltipModel = boxSeries_objectSpread(boxSeries_objectSpread({}, cur), {}, {
          data: tooltipDataArr[dataIndex]
        });

        if (!acc[index]) {
          acc[index] = [];
        }

        acc[index].push(tooltipModel);
        return acc;
      }, []);
    }
  }, {
    key: "renderClipRectAreaModel",
    value: function renderClipRectAreaModel() {
      return {
        type: 'clipRectArea',
        x: 0,
        y: 0,
        width: this.rect.width,
        height: this.rect.height
      };
    }
  }, {
    key: "initClipRect",
    value: function initClipRect(clipRect) {
      return {
        type: 'clipRectArea',
        width: this.isBar ? 0 : clipRect.width,
        height: this.isBar ? clipRect.height : 0,
        x: this.isBar ? 0 : clipRect.x,
        y: this.isBar ? clipRect.y : 0
      };
    }
  }, {
    key: "renderSeriesModel",
    value: function renderSeriesModel(seriesData, renderOptions) {
      var _this4 = this;

      var tickDistance = renderOptions.tickDistance,
          diverging = renderOptions.diverging;
      var seriesLength = seriesData.length;
      var validDiverging = diverging && seriesData.length === 2;
      var columnWidth = this.getColumnWidth(renderOptions, seriesLength, validDiverging);
      var seriesModels = [];
      var padding = (tickDistance - columnWidth * (validDiverging ? 1 : seriesLength)) / 2;
      seriesData.forEach(function (_ref3, seriesIndex) {
        var data = _ref3.data,
            seriesColor = _ref3.color,
            name = _ref3.name,
            colorByCategories = _ref3.colorByCategories;
        var seriesPos = (diverging ? 0 : seriesIndex) * columnWidth + padding;
        var isLBSideWithDiverging = diverging && isLeftBottomSide(seriesIndex);
        var colorLength = colorByCategories ? seriesColor.length : 1;
        _this4.isRangeData = isRangeData(data);
        data.forEach(function (value, index) {
          var dataStart = seriesPos + index * tickDistance;

          var barLength = _this4.makeBarLength(value, renderOptions);

          var color = _this4.getSeriesColor(name, colorByCategories ? seriesColor[index % colorLength] : seriesColor);

          if (isNumber(barLength)) {
            var startPosition = _this4.getStartPosition(barLength, value, renderOptions, isLBSideWithDiverging);

            seriesModels.push(boxSeries_objectSpread(boxSeries_objectSpread({
              type: 'rect',
              color: color,
              value: value
            }, _this4.getAdjustedRect(dataStart, startPosition, barLength, columnWidth)), {}, {
              name: name,
              index: index
            }));
          }
        });
      });
      return seriesModels;
    }
  }, {
    key: "renderHoveredSeriesModel",
    value: function renderHoveredSeriesModel(seriesModel) {
      var _this5 = this;

      return seriesModel.map(function (data) {
        return _this5.makeHoveredSeriesModel(data);
      });
    }
  }, {
    key: "makeHoveredSeriesModel",
    value: function makeHoveredSeriesModel(data) {
      var _ref4 = data,
          x = _ref4.x,
          y = _ref4.y,
          width = _ref4.width,
          height = _ref4.height,
          color = _ref4.color,
          index = _ref4.index;
      return {
        type: 'rect',
        color: getRGBA(color, 1),
        x: x,
        y: y,
        width: width,
        height: height,
        index: index
      };
    }
  }, {
    key: "getRectModelsFromRectResponders",
    value: function getRectModelsFromRectResponders(responders) {
      var _this$tooltipRectMap;

      if (!responders.length) {
        return [];
      }

      return (_this$tooltipRectMap = this.tooltipRectMap[responders[0].index]) !== null && _this$tooltipRectMap !== void 0 ? _this$tooltipRectMap : [];
    }
  }, {
    key: "getGroupedRect",
    value: function getGroupedRect(responders, type) {
      var rectModels = this.getRectModelsFromRectResponders(responders);
      var _ref5 = this.theme[type].groupedRect,
          color = _ref5.color,
          opacity = _ref5.opacity;
      return rectModels.length ? responders.map(function (m) {
        return boxSeries_objectSpread(boxSeries_objectSpread({}, m), {}, {
          color: getRGBA(color, opacity)
        });
      }) : [];
    }
  }, {
    key: "onMousemoveGroupedType",
    value: function onMousemoveGroupedType(responders) {
      var rectModels = this.getRectModelsFromRectResponders(responders);
      this.eventBus.emit('renderHoveredSeries', {
        models: this.getGroupedRect(responders, 'hover'),
        name: this.name,
        eventDetectType: this.eventDetectType
      });
      this.activatedResponders = rectModels;
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref6) {
      var responders = _ref6.responders;

      if (this.eventDetectType === 'grouped') {
        this.onMousemoveGroupedType(responders);
      } else {
        this.eventBus.emit('renderHoveredSeries', {
          models: this.getRespondersWithTheme(responders, 'hover'),
          name: this.name,
          eventDetectType: this.eventDetectType
        });
        this.activatedResponders = responders;
      }

      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "makeTooltipData",
    value: function makeTooltipData(seriesData, renderOptions, categories) {
      var _this6 = this;

      var tooltipData = [];
      seriesData.forEach(function (_ref7) {
        var data = _ref7.data,
            name = _ref7.name,
            color = _ref7.color,
            colorByCategories = _ref7.colorByCategories;
        data.forEach(function (value, dataIndex) {
          if (!isNull(value)) {
            var barLength = _this6.makeBarLength(value, renderOptions);

            if (isNumber(barLength)) {
              tooltipData.push({
                label: name,
                color: colorByCategories ? color[dataIndex] : color,
                value: _this6.getTooltipValue(value),
                category: categories.length ? categories[dataIndex] : ''
              });
            }
          }
        });
      });
      return tooltipData;
    }
  }, {
    key: "getTooltipValue",
    value: function getTooltipValue(value) {
      return isRangeValue(value) ? "".concat(value[0], " ~ ").concat(value[1]) : value;
    }
  }, {
    key: "getBasePosition",
    value: function getBasePosition(_ref8) {
      var labels = _ref8.labels,
          tickCount = _ref8.tickCount,
          zeroPosition = _ref8.zeroPosition;
      var valueLabels = this.isBar ? labels : boxSeries_toConsumableArray(labels).reverse();
      var tickPositions = makeTickPixelPositions(this.getOffsetSize(), tickCount);
      var seriesDirection = this.getSeriesDirection(valueLabels);
      return zeroPosition ? zeroPosition : this.getTickPositionIfNotZero(tickPositions, seriesDirection);
    }
  }, {
    key: "getDivergingBasePosition",
    value: function getDivergingBasePosition(centerYAxis) {
      var leftZeroPosition, rightZeroPosition;

      if (centerYAxis) {
        leftZeroPosition = centerYAxis.xAxisHalfSize;
        rightZeroPosition = centerYAxis.secondStartX;
      } else {
        var divergingZeroPosition = this.getOffsetSize() / 2;
        leftZeroPosition = rightZeroPosition = divergingZeroPosition;
      }

      return [leftZeroPosition, rightZeroPosition];
    }
  }, {
    key: "getOffsetSize",
    value: function getOffsetSize() {
      return this.rect[this.offsetSizeKey];
    }
  }, {
    key: "getValueRatio",
    value: function getValueRatio(min, max, size) {
      return size / (max - min);
    }
  }, {
    key: "makeBarLength",
    value: function makeBarLength(value, renderOptions) {
      if (isNull(value)) {
        return null;
      }

      var min = renderOptions.min,
          max = renderOptions.max,
          ratio = renderOptions.ratio;
      var calculatedValue = calculateBarLength(value, min, max);
      return Math.max(this.getBarLength(calculatedValue, ratio), 2);
    }
  }, {
    key: "getBarLength",
    value: function getBarLength(value, ratio) {
      return value < 0 ? Math.abs(value) * ratio : value * ratio;
    }
  }, {
    key: "getStartPositionWithRangeValue",
    value: function getStartPositionWithRangeValue(value, barLength, renderOptions) {
      var min = renderOptions.min,
          ratio = renderOptions.ratio;

      var _value2 = boxSeries_slicedToArray(value, 1),
          start = _value2[0];

      if (start < min) {
        start = min;
      }

      var startPosition = (start - min) * ratio;
      return this.isBar ? startPosition : this.getOffsetSize() - startPosition - barLength;
    }
  }, {
    key: "getStartPosition",
    value: function getStartPosition(barLength, value, renderOptions, isLBSideWithDiverging) {
      var diverging = renderOptions.diverging,
          seriesDirection = renderOptions.seriesDirection;
      var startPos;

      if (isRangeValue(value)) {
        startPos = this.getStartPositionWithRangeValue(value, barLength, renderOptions);
      } else if (diverging) {
        startPos = isLBSideWithDiverging ? this.getStartPosOnLeftBottomSide(barLength, diverging) : this.getStartPosOnRightTopSide(barLength, diverging);
      } else if (seriesDirection === SeriesDirection.POSITIVE) {
        startPos = this.getStartPosOnRightTopSide(barLength);
      } else if (seriesDirection === SeriesDirection.NEGATIVE) {
        startPos = this.getStartPosOnLeftBottomSide(barLength);
      } else {
        startPos = value < 0 ? this.getStartPosOnLeftBottomSide(barLength) : this.getStartPosOnRightTopSide(barLength);
      }

      return startPos;
    }
  }, {
    key: "getStartPosOnRightTopSide",
    value: function getStartPosOnRightTopSide(barLength) {
      var diverging = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var pos;

      if (diverging) {
        pos = this.isBar ? this.rightBasePosition : this.rightBasePosition - barLength;
      } else {
        pos = this.isBar ? this.basePosition : this.basePosition - barLength;
      }

      return pos;
    }
  }, {
    key: "getStartPosOnLeftBottomSide",
    value: function getStartPosOnLeftBottomSide(barLength) {
      var diverging = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var pos;

      if (diverging) {
        pos = this.isBar ? this.leftBasePosition - barLength : this.leftBasePosition;
      } else {
        pos = this.isBar ? this.basePosition - barLength : this.basePosition;
      }

      return pos;
    }
  }, {
    key: "getAdjustedRect",
    value: function getAdjustedRect(seriesPosition, dataPosition, barLength, columnWidth) {
      return {
        x: this.isBar ? dataPosition : seriesPosition,
        y: this.isBar ? seriesPosition : dataPosition,
        width: this.isBar ? barLength : columnWidth,
        height: this.isBar ? columnWidth : barLength
      };
    }
  }, {
    key: "getColumnWidth",
    value: function getColumnWidth(renderOptions, seriesLength) {
      var validDiverging = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var tickDistance = renderOptions.tickDistance,
          defaultPadding = renderOptions.defaultPadding;
      seriesLength = validDiverging ? 1 : seriesLength;
      var themeBarWidth = this.theme.barWidth;
      return themeBarWidth ? calculateSizeWithPercentString(tickDistance, themeBarWidth) : (tickDistance - defaultPadding * 2) / seriesLength;
    }
  }, {
    key: "getSeriesDirection",
    value: function getSeriesDirection(labels) {
      var result = SeriesDirection.BOTH;

      if (hasPositiveOnly(labels)) {
        result = SeriesDirection.POSITIVE;
      } else if (hasNegativeOnly(labels)) {
        result = SeriesDirection.NEGATIVE;
      }

      return result;
    }
  }, {
    key: "getTickPositionIfNotZero",
    value: function getTickPositionIfNotZero(tickPositions, direction) {
      if (!tickPositions.length) {
        return 0;
      }

      var firstTickPosition = Number(first(tickPositions));
      var lastTickPosition = Number(last(tickPositions));

      if (direction === SeriesDirection.POSITIVE) {
        return this.isBar ? firstTickPosition : lastTickPosition;
      }

      if (direction === SeriesDirection.NEGATIVE) {
        return this.isBar ? lastTickPosition : firstTickPosition;
      }

      return 0;
    }
  }, {
    key: "makeDataLabel",
    value: function makeDataLabel(rect, centerYAxis) {
      var dataLabels = this.theme.dataLabels;
      return boxSeries_objectSpread(boxSeries_objectSpread({}, rect), {}, {
        direction: this.getDataLabelDirection(rect, centerYAxis),
        plot: {
          x: 0,
          y: 0,
          size: this.getOffsetSize()
        },
        theme: boxSeries_objectSpread(boxSeries_objectSpread({}, omit(dataLabels, 'stackTotal')), {}, {
          color: dataLabels.useSeriesColor ? rect.color : dataLabels.color
        })
      });
    }
  }, {
    key: "makeDataLabelRangeData",
    value: function makeDataLabelRangeData(rect) {
      var _this7 = this;

      var dataLabels = this.theme.dataLabels;
      return rect.value.reduce(function (acc, value, index) {
        return [].concat(boxSeries_toConsumableArray(acc), [boxSeries_objectSpread(boxSeries_objectSpread({}, rect), {}, {
          value: value,
          direction: _this7.getDataLabelRangeDataDirection(index % 2 === 0),
          plot: {
            x: 0,
            y: 0,
            size: _this7.getOffsetSize()
          },
          theme: boxSeries_objectSpread(boxSeries_objectSpread({}, omit(dataLabels, 'stackTotal')), {}, {
            color: dataLabels.useSeriesColor ? rect.color : dataLabels.color
          })
        })]);
      }, []);
    }
  }, {
    key: "getDataLabelRangeDataDirection",
    value: function getDataLabelRangeDataDirection(isEven) {
      var direction;

      if (this.isBar) {
        direction = isEven ? 'left' : 'right';
      } else {
        direction = isEven ? 'bottom' : 'top';
      }

      return direction;
    }
  }, {
    key: "getDataLabelDirection",
    value: function getDataLabelDirection(rect, centerYAxis) {
      var direction;

      if (this.isBar) {
        var basePos = centerYAxis ? this.leftBasePosition : this.basePosition;
        direction = rect.x < basePos ? 'left' : 'right';
      } else {
        direction = rect.y >= this.basePosition ? 'bottom' : 'top';
      }

      return direction;
    }
  }, {
    key: "getOffsetSizeWithDiverging",
    value: function getOffsetSizeWithDiverging(centerYAxis) {
      return centerYAxis ? centerYAxis.xAxisHalfSize : this.getOffsetSize() / 2;
    }
  }, {
    key: "onClick",
    value: function onClick(_ref9) {
      var responders = _ref9.responders;

      if (this.selectable) {
        var models;

        if (this.eventDetectType === 'grouped') {
          models = [].concat(boxSeries_toConsumableArray(this.getGroupedRect(responders, 'select')), boxSeries_toConsumableArray(this.getRectModelsFromRectResponders(responders)));
        } else {
          models = this.getRespondersWithTheme(responders, 'select');
        }

        this.eventBus.emit('renderSelectedSeries', {
          models: models,
          name: this.name,
          eventDetectType: this.eventDetectType
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "getRespondersWithTheme",
    value: function getRespondersWithTheme(responders, type) {
      var _this$theme$type = this.theme[type],
          color = _this$theme$type.color,
          borderColor = _this$theme$type.borderColor,
          borderWidth = _this$theme$type.borderWidth,
          shadowBlur = _this$theme$type.shadowBlur,
          shadowColor = _this$theme$type.shadowColor,
          shadowOffsetX = _this$theme$type.shadowOffsetX,
          shadowOffsetY = _this$theme$type.shadowOffsetY;
      return responders.map(function (model) {
        return boxSeries_objectSpread(boxSeries_objectSpread({}, model), {}, {
          color: color !== null && color !== void 0 ? color : model.color,
          thickness: borderWidth,
          borderColor: borderColor,
          style: [{
            shadowBlur: shadowBlur,
            shadowColor: shadowColor,
            shadowOffsetX: shadowOffsetX,
            shadowOffsetY: shadowOffsetY
          }]
        });
      });
    }
  }, {
    key: "getSeriesColor",
    value: function getSeriesColor(name, color) {
      var _this$theme = this.theme,
          select = _this$theme.select,
          areaOpacity = _this$theme.areaOpacity;
      var active = this.activeSeriesMap[name];
      var selected = Object.values(this.activeSeriesMap).some(function (elem) {
        return !elem;
      });
      return selected ? getRGBA(color, active ? select.areaOpacity : select.restSeries.areaOpacity) : getRGBA(color, areaOpacity);
    }
  }]);

  return BoxSeries;
}(Component);


;// CONCATENATED MODULE: ./src/component/boxStackSeries.ts
function boxStackSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { boxStackSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { boxStackSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return boxStackSeries_typeof(obj); }

function boxStackSeries_toConsumableArray(arr) { return boxStackSeries_arrayWithoutHoles(arr) || boxStackSeries_iterableToArray(arr) || boxStackSeries_unsupportedIterableToArray(arr) || boxStackSeries_nonIterableSpread(); }

function boxStackSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function boxStackSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function boxStackSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return boxStackSeries_arrayLikeToArray(arr); }

function boxStackSeries_slicedToArray(arr, i) { return boxStackSeries_arrayWithHoles(arr) || boxStackSeries_iterableToArrayLimit(arr, i) || boxStackSeries_unsupportedIterableToArray(arr, i) || boxStackSeries_nonIterableRest(); }

function boxStackSeries_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function boxStackSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return boxStackSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return boxStackSeries_arrayLikeToArray(o, minLen); }

function boxStackSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function boxStackSeries_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function boxStackSeries_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function boxStackSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function boxStackSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function boxStackSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) boxStackSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) boxStackSeries_defineProperties(Constructor, staticProps); return Constructor; }

function boxStackSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) boxStackSeries_setPrototypeOf(subClass, superClass); }

function boxStackSeries_setPrototypeOf(o, p) { boxStackSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return boxStackSeries_setPrototypeOf(o, p); }

function boxStackSeries_createSuper(Derived) { var hasNativeReflectConstruct = boxStackSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = boxStackSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = boxStackSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return boxStackSeries_possibleConstructorReturn(this, result); }; }

function boxStackSeries_possibleConstructorReturn(self, call) { if (call && (boxStackSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return boxStackSeries_assertThisInitialized(self); }

function boxStackSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function boxStackSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function boxStackSeries_getPrototypeOf(o) { boxStackSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return boxStackSeries_getPrototypeOf(o); }

























function boxStackSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function boxStackSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { boxStackSeries_ownKeys(Object(source), true).forEach(function (key) { boxStackSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { boxStackSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function boxStackSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }














function boxStackSeries_calibrateDrawingValue(values, seriesIndex, renderOptions) {
  var stack = renderOptions.stack,
      min = renderOptions.min,
      max = renderOptions.max;
  return isPercentStack(stack) ? values[seriesIndex] : calibrateBoxStackDrawingValue(values, seriesIndex, min, max);
}

function getDivisorForPercent(total, scaleType) {
  var positive = total.positive,
      negative = total.negative;
  var divisor = positive + Math.abs(negative);

  if (includes(['dualPercentStack', 'divergingPercentStack'], scaleType)) {
    divisor *= 2;
  }

  return divisor;
}

function getDirectionKeys(seriesDirection) {
  var result = ['positive', 'negative'];

  if (seriesDirection === SeriesDirection.POSITIVE) {
    result = ['positive'];
  } else if (seriesDirection === SeriesDirection.NEGATIVE) {
    result = ['negative'];
  }

  return result;
}

function getStackSeriesDataInViewRange(stackSeriesData, viewRange) {
  if (!viewRange) {
    return stackSeriesData;
  }

  var stackData = Array.isArray(stackSeriesData.stackData) ? getDataInRange(stackSeriesData.stackData, viewRange) : boxStackSeries_objectSpread({}, Object.keys(stackSeriesData.stackData).reduce(function (acc, name) {
    return boxStackSeries_objectSpread(boxStackSeries_objectSpread({}, acc), {}, boxStackSeries_defineProperty({}, name, getDataInRange(stackSeriesData.stackData[name], viewRange)));
  }, {}));
  var data = stackSeriesData.data.map(function (seriesDatum) {
    return boxStackSeries_objectSpread(boxStackSeries_objectSpread({}, seriesDatum), {}, {
      data: getDataInRange(seriesDatum.data, viewRange)
    });
  });
  return boxStackSeries_objectSpread(boxStackSeries_objectSpread({}, stackSeriesData), {}, {
    data: data,
    stackData: stackData
  });
}

var BoxStackSeries = /*#__PURE__*/function (_BoxSeries) {
  boxStackSeries_inherits(BoxStackSeries, _BoxSeries);

  var _super = boxStackSeries_createSuper(BoxStackSeries);

  function BoxStackSeries() {
    var _this;

    boxStackSeries_classCallCheck(this, BoxStackSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    boxStackSeries_defineProperty(boxStackSeries_assertThisInitialized(_this), "selectSeries", function (_ref) {
      var index = _ref.index,
          seriesIndex = _ref.seriesIndex,
          state = _ref.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var stackSeries = state.stackSeries;
      var stackSeriesData = stackSeries[_this.name];
      var name = stackSeriesData.data[seriesIndex].name;

      var model = _this.tooltipRectMap[index].find(function (_ref2) {
        var seriesName = _ref2.name;
        return seriesName === name;
      });

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: _this.getRespondersWithTheme([model], 'select'),
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  boxStackSeries_createClass(BoxStackSeries, [{
    key: "initialize",
    value: function initialize(_ref3) {
      var name = _ref3.name,
          stackChart = _ref3.stackChart;
      this.initializeFields(name);

      if (stackChart) {
        this.eventBus.on('selectSeries', this.selectSeries);
        this.eventBus.on('showTooltip', this.showTooltip);
        this.eventBus.on('hideTooltip', this.onMouseoutComponent);
      }
    }
  }, {
    key: "render",
    value: function render(chartState, computed) {
      var _ref4, _options$series;

      var layout = chartState.layout,
          seriesData = chartState.series,
          axes = chartState.axes,
          stackSeries = chartState.stackSeries,
          legend = chartState.legend,
          theme = chartState.theme,
          scale = chartState.scale;
      var viewRange = computed.viewRange;
      this.isShow = !!stackSeries[this.name];

      if (!this.isShow) {
        return;
      }

      var categories = (_ref4 = chartState.categories) !== null && _ref4 !== void 0 ? _ref4 : [];
      var options = this.getOptions(chartState.options);
      this.setEventDetectType(seriesData, options);
      this.theme = theme.series[this.name];
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      var stackSeriesData = getStackSeriesDataInViewRange(stackSeries[this.name], viewRange);
      var tickDistance = axes[this.labelAxis].tickDistance;
      var diverging = !!((_options$series = options.series) !== null && _options$series !== void 0 && _options$series.diverging);

      var _this$getScaleData = this.getScaleData(scale),
          limit = _this$getScaleData.limit,
          stepSize = _this$getScaleData.stepSize;

      var labels = makeLabelsFromLimit(limit, stepSize);

      var _getLimitOnAxis = getLimitOnAxis(labels),
          min = _getLimitOnAxis.min,
          max = _getLimitOnAxis.max;

      var stack = stackSeriesData.stack,
          scaleType = stackSeriesData.scaleType;
      this.basePosition = this.getBasePosition(axes[this.valueAxis]);
      var offsetSize = this.getOffsetSize();
      var centerYAxis = axes.centerYAxis;

      if (diverging) {
        var _this$getDivergingBas = this.getDivergingBasePosition(centerYAxis),
            _this$getDivergingBas2 = boxStackSeries_slicedToArray(_this$getDivergingBas, 2),
            left = _this$getDivergingBas2[0],
            right = _this$getDivergingBas2[1];

        this.basePosition = this.getOffsetSize() / 2;
        this.leftBasePosition = left;
        this.rightBasePosition = right;
        offsetSize = this.getOffsetSizeWithDiverging(centerYAxis);
      }

      var renderOptions = {
        stack: stack,
        scaleType: scaleType,
        tickDistance: tickDistance,
        min: min,
        max: max,
        diverging: diverging,
        hasNegativeValue: hasNegative(labels),
        seriesDirection: this.getSeriesDirection(labels),
        defaultPadding: getBoxTypeSeriesPadding(tickDistance),
        offsetSize: offsetSize,
        centerYAxis: centerYAxis
      };

      var _this$renderStackSeri = this.renderStackSeriesModel(stackSeriesData, renderOptions),
          series = _this$renderStackSeri.series,
          connector = _this$renderStackSeri.connector;

      var clipRect = this.renderClipRectAreaModel();
      var tooltipData = this.getTooltipData(stackSeriesData, categories);
      this.models = {
        clipRect: [clipRect],
        series: series,
        connector: connector
      };

      if (!this.drawModels) {
        this.drawModels = {
          clipRect: [this.initClipRect(clipRect)],
          series: deepCopyArray(series),
          connector: deepCopyArray(connector)
        };
      }

      if (getDataLabelsOptions(options, this.name).visible) {
        var dataLabelData = this.getDataLabels(series, renderOptions);
        var stackTotalData = this.getTotalDataLabels(stackSeriesData, renderOptions);
        this.renderDataLabels([].concat(boxStackSeries_toConsumableArray(dataLabelData), boxStackSeries_toConsumableArray(stackTotalData)));
      }

      this.tooltipRectMap = this.makeTooltipRectMap(series, tooltipData);
      this.responders = this.getBoxSeriesResponders(series, tooltipData, axes, categories);
    }
  }, {
    key: "renderStackSeriesModel",
    value: function renderStackSeriesModel(seriesData, renderOptions) {
      var stackData = seriesData.stackData;
      return isGroupStack(stackData) ? this.makeStackGroupSeriesModel(seriesData, renderOptions) : this.makeStackSeriesModel(stackData, renderOptions, seriesData.data);
    }
  }, {
    key: "makeStackSeriesModel",
    value: function makeStackSeriesModel(stackData, renderOptions, seriesRawData) {
      var _this2 = this;

      var stackGroupCount = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var stackGroupIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var seriesModels = [];
      var columnWidth = this.getStackColumnWidth(renderOptions, stackGroupCount);
      var diverging = renderOptions.diverging;
      var isLBSideWithDiverging = diverging && isLeftBottomSide(stackGroupIndex);
      stackData.forEach(function (_ref5, dataIndex) {
        var values = _ref5.values,
            total = _ref5.total;

        var seriesPos = _this2.getSeriesPosition(renderOptions, columnWidth, dataIndex, stackGroupIndex, stackGroupCount);

        var ratio = _this2.getStackValueRatio(total, renderOptions);

        values.forEach(function (value, seriesIndex) {
          var _this2$getStackRectIn = _this2.getStackRectInfo(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging),
              barLength = _this2$getStackRectIn.barLength,
              dataPosition = _this2$getStackRectIn.dataPosition;

          var _seriesRawData$series = seriesRawData[seriesIndex],
              name = _seriesRawData$series.name,
              colorByCategories = _seriesRawData$series.colorByCategories,
              rawColor = _seriesRawData$series.color;
          var active = _this2.activeSeriesMap[name];
          var colorLength = rawColor.length || 1;
          var hexColor = colorByCategories ? rawColor[dataIndex % colorLength] : rawColor;
          var color = getRGBA(hexColor, active ? 1 : 0.2);
          seriesModels.push(boxStackSeries_objectSpread(boxStackSeries_objectSpread({
            type: 'rect',
            color: color,
            name: name,
            value: value
          }, _this2.getAdjustedRect(seriesPos, dataPosition, barLength !== null && barLength !== void 0 ? barLength : 0, columnWidth)), {}, {
            index: dataIndex
          }));
        });
      });
      return {
        series: seriesModels,
        connector: this.makeConnectorSeriesModel(stackData, renderOptions, stackGroupCount, stackGroupIndex)
      };
    }
  }, {
    key: "makeStackGroupSeriesModel",
    value: function makeStackGroupSeriesModel(stackSeries, renderOptions) {
      var _this3 = this;

      var stack = renderOptions.stack;
      var stackGroupData = stackSeries.stackData;
      var seriesRawData = stackSeries.data;
      var stackGroupIds = Object.keys(stackGroupData);
      var seriesModels = [];
      var connectorModels = [];
      stackGroupIds.forEach(function (groupId, groupIndex) {
        var filtered = seriesRawData.filter(function (_ref6) {
          var stackGroup = _ref6.stackGroup;
          return stackGroup === groupId;
        });

        var _this3$makeStackSerie = _this3.makeStackSeriesModel(stackGroupData[groupId], renderOptions, filtered, stackGroupIds.length, groupIndex),
            series = _this3$makeStackSerie.series,
            connector = _this3$makeStackSerie.connector;

        seriesModels = [].concat(boxStackSeries_toConsumableArray(seriesModels), boxStackSeries_toConsumableArray(series));

        if (stack.connector) {
          connectorModels = [].concat(boxStackSeries_toConsumableArray(connectorModels), boxStackSeries_toConsumableArray(connector));
        }
      });
      return {
        series: seriesModels,
        connector: connectorModels
      };
    }
  }, {
    key: "makeConnectorSeriesModel",
    value: function makeConnectorSeriesModel(stackData, renderOptions) {
      var _this4 = this;

      var stackGroupCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var stackGroupIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var diverging = renderOptions.diverging,
          connector = renderOptions.stack.connector;

      if (!connector) {
        return [];
      }

      var columnWidth = this.getStackColumnWidth(renderOptions, stackGroupCount);
      var isLBSideWithDiverging = diverging && isLeftBottomSide(stackGroupIndex);
      var connectorPoints = [];
      stackData.forEach(function (_ref7, index) {
        var values = _ref7.values,
            total = _ref7.total;

        var seriesPos = _this4.getSeriesPosition(renderOptions, columnWidth, index, stackGroupIndex, stackGroupCount);

        var points = [];

        var ratio = _this4.getStackValueRatio(total, renderOptions);

        values.forEach(function (value, seriesIndex) {
          var _this4$getStackRectIn = _this4.getStackRectInfo(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging),
              barLength = _this4$getStackRectIn.barLength,
              dataPosition = _this4$getStackRectIn.dataPosition;

          var _this4$getAdjustedRec = _this4.getAdjustedRect(seriesPos, dataPosition, barLength, columnWidth),
              x = _this4$getAdjustedRec.x,
              y = _this4$getAdjustedRec.y;

          var xPos = !isLBSideWithDiverging && _this4.isBar ? x + barLength : x;
          var yPos = isLBSideWithDiverging && !_this4.isBar ? y + barLength : y;
          points.push({
            x: xPos,
            y: yPos
          });
        });
        connectorPoints.push(points);
      });
      return this.makeConnectorModel(connectorPoints, connector, columnWidth);
    }
  }, {
    key: "getTooltipData",
    value: function getTooltipData(seriesData, categories) {
      var seriesRawData = seriesData.data;
      var stackData = seriesData.stackData;
      var colors = seriesRawData.map(function (_ref8) {
        var color = _ref8.color;
        return color;
      });
      return isGroupStack(stackData) ? this.makeGroupStackTooltipData(seriesRawData, stackData, categories) : this.makeStackTooltipData(seriesRawData, stackData, colors, categories);
    }
  }, {
    key: "makeGroupStackTooltipData",
    value: function makeGroupStackTooltipData(seriesRawData, stackData, categories) {
      var _this5 = this;

      return Object.keys(stackData).flatMap(function (groupId) {
        var rawDataWithSameGroupId = seriesRawData.filter(function (_ref9) {
          var stackGroup = _ref9.stackGroup;
          return stackGroup === groupId;
        });
        var colors = rawDataWithSameGroupId.map(function (_ref10) {
          var color = _ref10.color;
          return color;
        });
        return _this5.makeStackTooltipData(rawDataWithSameGroupId, stackData[groupId], colors, categories);
      });
    }
  }, {
    key: "makeStackTooltipData",
    value: function makeStackTooltipData(seriesRawData, stackData, colors, categories) {
      var tooltipData = [];
      stackData.forEach(function (_ref11, dataIndex) {
        var values = _ref11.values;
        values.forEach(function (value, seriesIndex) {
          tooltipData.push({
            label: seriesRawData[seriesIndex].name,
            color: colors[seriesIndex],
            value: value,
            category: categories.length ? categories[dataIndex] : ''
          });
        });
      });
      return tooltipData;
    }
  }, {
    key: "makeConnectorModel",
    value: function makeConnectorModel(pointsForConnector, connector, columnWidth) {
      var _this6 = this;

      if (!connector || !pointsForConnector.length) {
        return [];
      }

      var _this$theme$connector = this.theme.connector,
          color = _this$theme$connector.color,
          lineWidth = _this$theme$connector.lineWidth,
          dashSegments = _this$theme$connector.dashSegments;
      var connectorModels = [];
      var seriesDataCount = pointsForConnector.length;
      var seriesCount = pointsForConnector[0].length;

      var _loop = function _loop(seriesIndex) {
        var points = [];

        for (var dataIndex = 0; dataIndex < seriesDataCount; dataIndex += 1) {
          points.push(pointsForConnector[dataIndex][seriesIndex]);
        }

        points.forEach(function (point, index) {
          var x = point.x,
              y = point.y;

          if (index < points.length - 1) {
            var _points = points[index + 1],
                nextX = _points.x,
                nextY = _points.y;
            connectorModels.push({
              type: 'line',
              x: _this6.isBar ? x : x + columnWidth,
              y: _this6.isBar ? y + columnWidth : y,
              x2: nextX,
              y2: nextY,
              dashSegments: dashSegments,
              strokeStyle: color,
              lineWidth: lineWidth
            });
          }
        });
      };

      for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex += 1) {
        _loop(seriesIndex);
      }

      return connectorModels;
    }
  }, {
    key: "getStackValueRatio",
    value: function getStackValueRatio(total, renderOptions) {
      var stackType = renderOptions.stack.type,
          scaleType = renderOptions.scaleType,
          min = renderOptions.min,
          max = renderOptions.max,
          offsetSize = renderOptions.offsetSize;

      if (stackType === 'percent') {
        return offsetSize / getDivisorForPercent(total, scaleType);
      }

      return this.getValueRatio(min, max, offsetSize);
    }
  }, {
    key: "getStackBarLength",
    value: function getStackBarLength(values, seriesIndex, ratio, renderOptions) {
      var value = boxStackSeries_calibrateDrawingValue(values, seriesIndex, renderOptions);
      return isNumber(value) ? this.getBarLength(value, ratio) : null;
    }
  }, {
    key: "getStackColumnWidth",
    value: function getStackColumnWidth(renderOptions, stackGroupCount) {
      var tickDistance = renderOptions.tickDistance,
          diverging = renderOptions.diverging,
          defaultPadding = renderOptions.defaultPadding;
      var divisor = diverging ? 1 : stackGroupCount;
      var themeBarWidth = this.theme.barWidth;
      return themeBarWidth ? calculateSizeWithPercentString(tickDistance, themeBarWidth) : (tickDistance - defaultPadding * 2) / divisor;
    }
  }, {
    key: "getSeriesPosition",
    value: function getSeriesPosition(renderOptions, columnWidth, dataIndex, stackGroupIndex, stackGroupCount) {
      var tickDistance = renderOptions.tickDistance,
          diverging = renderOptions.diverging;
      var groupIndex = diverging ? 0 : stackGroupIndex;
      var groupCount = diverging ? 1 : stackGroupCount;
      var padding = (tickDistance - columnWidth * groupCount) / 2;
      return dataIndex * tickDistance + padding + columnWidth * groupIndex;
    }
  }, {
    key: "getStackStartPosition",
    value: function getStackStartPosition(values, currentIndex, ratio, renderOptions, isLBSideWithDiverging) {
      var stack = renderOptions.stack,
          diverging = renderOptions.diverging,
          seriesDirection = renderOptions.seriesDirection;
      var startPos;

      if (diverging) {
        startPos = isLBSideWithDiverging ? this.calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio) : this.calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio);
      } else if (isPercentStack(stack)) {
        startPos = this.calcStartPositionWithPercent(values, currentIndex, ratio);
      } else if (seriesDirection === SeriesDirection.POSITIVE) {
        startPos = this.calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio);
      } else if (seriesDirection === SeriesDirection.NEGATIVE) {
        startPos = this.calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio);
      } else {
        startPos = this.calcStartPositionWithStack(values, currentIndex, renderOptions, ratio);
      }

      return startPos;
    }
  }, {
    key: "calcStartPosOnLeftBottomSide",
    value: function calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio) {
      var min = renderOptions.min,
          max = renderOptions.max,
          diverging = renderOptions.diverging;
      var basePosition = diverging ? this.leftBasePosition : this.basePosition;
      var totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);
      var totalOfValues = sumValuesBeforeIndex(values, currentIndex, true);
      var collideEdge = totalOfValues < min;
      var usingValue = this.isBar ? totalOfValues : totalOfIndexBefore;
      var result = max < 0 ? Math.min(usingValue - max, 0) : usingValue;
      var pos;

      if (this.isBar) {
        pos = collideEdge ? 0 : basePosition - Math.abs(result) * ratio;
      } else {
        pos = basePosition + Math.abs(result) * ratio;
      }

      return pos;
    }
  }, {
    key: "calcStartPosOnRightTopSide",
    value: function calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio) {
      var min = renderOptions.min,
          max = renderOptions.max,
          diverging = renderOptions.diverging;
      var basePosition = diverging ? this.rightBasePosition : this.basePosition;
      var totalOfIndexBefore = sumValuesBeforeIndex(values, currentIndex, false);
      var totalOfValues = sumValuesBeforeIndex(values, currentIndex, true);
      var collideEdge = totalOfValues > max;
      var usingValue = this.isBar ? totalOfIndexBefore : totalOfValues;
      var result = min > 0 ? Math.max(usingValue - min, 0) : usingValue;
      var barLength = result * ratio;
      var pos;

      if (this.isBar) {
        pos = basePosition + barLength;
      } else {
        pos = collideEdge ? 0 : basePosition - barLength;
      }

      return pos;
    }
  }, {
    key: "calcStartPositionWithStack",
    value: function calcStartPositionWithStack(values, currentIndex, renderOptions, ratio) {
      return values[currentIndex] < 0 ? this.calcStartPosOnLeftBottomSide(values, currentIndex, renderOptions, ratio) : this.calcStartPosOnRightTopSide(values, currentIndex, renderOptions, ratio);
    }
  }, {
    key: "calcStartPositionWithPercent",
    value: function calcStartPositionWithPercent(values, currentIndex, ratio) {
      var basePosition = this.basePosition;
      var totalPrevValues = sumValuesBeforeIndex(values, currentIndex, this.isBar ? values[currentIndex] < 0 : values[currentIndex] > 0);
      return this.isBar ? totalPrevValues * ratio + basePosition : basePosition - totalPrevValues * ratio;
    }
  }, {
    key: "getStackRectInfo",
    value: function getStackRectInfo(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging) {
      var barLength = this.getStackBarLength(values, seriesIndex, ratio, renderOptions);
      var dataPosition = this.getStackStartPosition(values, seriesIndex, ratio, renderOptions, isLBSideWithDiverging);
      return {
        barLength: barLength,
        dataPosition: dataPosition
      };
    }
  }, {
    key: "getDataLabels",
    value: function getDataLabels(seriesModels, renderOptions) {
      var _this7 = this;

      return seriesModels.map(function (data) {
        return _this7.makeDataLabel(data, renderOptions.centerYAxis);
      });
    }
  }, {
    key: "getTotalDataLabels",
    value: function getTotalDataLabels(seriesData, renderOptions) {
      var stackData = seriesData.stackData,
          stack = seriesData.stack;

      if (isPercentStack(stack)) {
        return [];
      }

      return isGroupStack(stackData) ? this.makeGroupTotalDataLabels(seriesData, renderOptions) : this.makeTotalDataLabels(stackData, renderOptions);
    }
  }, {
    key: "makeGroupTotalDataLabels",
    value: function makeGroupTotalDataLabels(stackSeries, renderOptions) {
      var _this8 = this;

      var dataLabels = [];
      var stackGroupData = stackSeries.stackData;
      var stackGroupIds = Object.keys(stackGroupData);
      stackGroupIds.forEach(function (groupId, groupIndex) {
        var totalDataLabels = _this8.makeTotalDataLabels(stackGroupData[groupId], renderOptions, stackGroupIds.length, groupIndex);

        dataLabels = [].concat(boxStackSeries_toConsumableArray(dataLabels), boxStackSeries_toConsumableArray(totalDataLabels));
      });
      return dataLabels;
    }
  }, {
    key: "makeTotalDataLabels",
    value: function makeTotalDataLabels(stackData, renderOptions) {
      var _this9 = this;

      var stackGroupCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var stackGroupIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var dataLabels = [];
      var min = renderOptions.min,
          max = renderOptions.max,
          seriesDirection = renderOptions.seriesDirection,
          diverging = renderOptions.diverging,
          centerYAxis = renderOptions.centerYAxis;
      var columnWidth = this.getStackColumnWidth(renderOptions, stackGroupCount);
      stackData.forEach(function (data, dataIndex) {
        var total = data.total;

        var seriesPos = _this9.getSeriesPosition(renderOptions, columnWidth, dataIndex, stackGroupIndex, stackGroupCount);

        var ratio = _this9.getStackValueRatio(total, renderOptions);

        var directionKeys = getDirectionKeys(seriesDirection);
        directionKeys.forEach(function (key) {
          var value = total[key];

          if (!value) {
            return;
          }

          var barLength = _this9.makeBarLength(value, {
            min: min,
            max: max,
            ratio: ratio
          });

          var dataPosition = _this9.getStartPosition(barLength, value, renderOptions, diverging && isLeftBottomSide(stackGroupIndex));

          var stackTotal = boxStackSeries_objectSpread({
            type: 'stackTotal',
            value: value,
            name: "totalLabel-".concat(key),
            theme: _this9.theme.dataLabels.stackTotal
          }, _this9.getAdjustedRect(seriesPos, dataPosition, barLength, columnWidth));

          dataLabels.push(_this9.makeTotalDataLabel(stackTotal, centerYAxis));
        });
      });
      return dataLabels;
    }
  }, {
    key: "makeTotalDataLabel",
    value: function makeTotalDataLabel(totalLabel, centerYAxis) {
      return boxStackSeries_objectSpread(boxStackSeries_objectSpread({}, totalLabel), {}, {
        direction: this.getDataLabelDirection(totalLabel, centerYAxis),
        plot: {
          x: 0,
          y: 0,
          size: this.getOffsetSize()
        }
      });
    }
  }, {
    key: "onMousemoveGroupedType",
    value: function onMousemoveGroupedType(responders) {
      var rectModels = this.getRectModelsFromRectResponders(responders);
      this.eventBus.emit('renderHoveredSeries', {
        models: [].concat(boxStackSeries_toConsumableArray(rectModels), boxStackSeries_toConsumableArray(this.getGroupedRect(responders, 'hover'))),
        name: this.name,
        eventDetectType: this.eventDetectType
      });
      this.activatedResponders = rectModels;
    }
  }]);

  return BoxStackSeries;
}(BoxSeries);


;// CONCATENATED MODULE: ./src/component/zeroAxis.ts
function zeroAxis_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { zeroAxis_typeof = function _typeof(obj) { return typeof obj; }; } else { zeroAxis_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return zeroAxis_typeof(obj); }














function zeroAxis_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function zeroAxis_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function zeroAxis_createClass(Constructor, protoProps, staticProps) { if (protoProps) zeroAxis_defineProperties(Constructor.prototype, protoProps); if (staticProps) zeroAxis_defineProperties(Constructor, staticProps); return Constructor; }

function zeroAxis_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) zeroAxis_setPrototypeOf(subClass, superClass); }

function zeroAxis_setPrototypeOf(o, p) { zeroAxis_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return zeroAxis_setPrototypeOf(o, p); }

function zeroAxis_createSuper(Derived) { var hasNativeReflectConstruct = zeroAxis_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = zeroAxis_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = zeroAxis_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return zeroAxis_possibleConstructorReturn(this, result); }; }

function zeroAxis_possibleConstructorReturn(self, call) { if (call && (zeroAxis_typeof(call) === "object" || typeof call === "function")) { return call; } return zeroAxis_assertThisInitialized(self); }

function zeroAxis_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function zeroAxis_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function zeroAxis_getPrototypeOf(o) { zeroAxis_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return zeroAxis_getPrototypeOf(o); }

function zeroAxis_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var ZeroAxis = /*#__PURE__*/function (_Component) {
  zeroAxis_inherits(ZeroAxis, _Component);

  var _super = zeroAxis_createSuper(ZeroAxis);

  function ZeroAxis() {
    var _this;

    zeroAxis_classCallCheck(this, ZeroAxis);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    zeroAxis_defineProperty(zeroAxis_assertThisInitialized(_this), "models", []);

    return _this;
  }

  zeroAxis_createClass(ZeroAxis, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'zeroAxis';
      this.name = 'zeroAxis';
    }
  }, {
    key: "render",
    value: function render(_ref) {
      var layout = _ref.layout,
          axes = _ref.axes,
          series = _ref.series,
          options = _ref.options;
      this.rect = layout.plot;
      var labelAxisOnYAxis = isLabelAxisOnYAxis({
        series: series,
        options: options
      });
      var valueAxisName = labelAxisOnYAxis ? 'xAxis' : 'yAxis';
      var _ref2 = axes[valueAxisName],
          zeroPosition = _ref2.zeroPosition;

      if (isNumber(zeroPosition)) {
        this.models = this.renderZeroModel(zeroPosition, labelAxisOnYAxis);
      }
    }
  }, {
    key: "renderZeroModel",
    value: function renderZeroModel(zeroPosition, vertical) {
      var zeroPixel = crispPixel(0);
      var position = crispPixel(zeroPosition);
      var model;

      if (vertical) {
        model = {
          type: 'line',
          x: position,
          y: zeroPixel,
          x2: position,
          y2: crispPixel(this.rect.height),
          strokeStyle: 'rgba(0, 0, 0, 0.5)'
        };
      } else {
        model = {
          type: 'line',
          x: zeroPixel,
          y: position,
          x2: crispPixel(this.rect.width),
          y2: position,
          strokeStyle: 'rgba(0, 0, 0, 0.5)'
        };
      }

      return [model];
    }
  }]);

  return ZeroAxis;
}(Component);


;// CONCATENATED MODULE: ./src/component/axisUsingCenterY.ts
function axisUsingCenterY_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { axisUsingCenterY_typeof = function _typeof(obj) { return typeof obj; }; } else { axisUsingCenterY_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return axisUsingCenterY_typeof(obj); }

function axisUsingCenterY_toConsumableArray(arr) { return axisUsingCenterY_arrayWithoutHoles(arr) || axisUsingCenterY_iterableToArray(arr) || axisUsingCenterY_unsupportedIterableToArray(arr) || axisUsingCenterY_nonIterableSpread(); }

function axisUsingCenterY_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function axisUsingCenterY_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return axisUsingCenterY_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return axisUsingCenterY_arrayLikeToArray(o, minLen); }

function axisUsingCenterY_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function axisUsingCenterY_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return axisUsingCenterY_arrayLikeToArray(arr); }

function axisUsingCenterY_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function axisUsingCenterY_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function axisUsingCenterY_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { axisUsingCenterY_ownKeys(Object(source), true).forEach(function (key) { axisUsingCenterY_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { axisUsingCenterY_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }






















function axisUsingCenterY_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function axisUsingCenterY_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function axisUsingCenterY_createClass(Constructor, protoProps, staticProps) { if (protoProps) axisUsingCenterY_defineProperties(Constructor.prototype, protoProps); if (staticProps) axisUsingCenterY_defineProperties(Constructor, staticProps); return Constructor; }

function axisUsingCenterY_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) axisUsingCenterY_setPrototypeOf(subClass, superClass); }

function axisUsingCenterY_setPrototypeOf(o, p) { axisUsingCenterY_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return axisUsingCenterY_setPrototypeOf(o, p); }

function axisUsingCenterY_createSuper(Derived) { var hasNativeReflectConstruct = axisUsingCenterY_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = axisUsingCenterY_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = axisUsingCenterY_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return axisUsingCenterY_possibleConstructorReturn(this, result); }; }

function axisUsingCenterY_possibleConstructorReturn(self, call) { if (call && (axisUsingCenterY_typeof(call) === "object" || typeof call === "function")) { return call; } return axisUsingCenterY_assertThisInitialized(self); }

function axisUsingCenterY_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function axisUsingCenterY_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function axisUsingCenterY_getPrototypeOf(o) { axisUsingCenterY_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return axisUsingCenterY_getPrototypeOf(o); }

function axisUsingCenterY_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var AxisUsingCenterY = /*#__PURE__*/function (_Component) {
  axisUsingCenterY_inherits(AxisUsingCenterY, _Component);

  var _super = axisUsingCenterY_createSuper(AxisUsingCenterY);

  function AxisUsingCenterY() {
    var _this;

    axisUsingCenterY_classCallCheck(this, AxisUsingCenterY);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    axisUsingCenterY_defineProperty(axisUsingCenterY_assertThisInitialized(_this), "name", void 0);

    axisUsingCenterY_defineProperty(axisUsingCenterY_assertThisInitialized(_this), "models", {
      label: [],
      tick: [],
      axisLine: []
    });

    axisUsingCenterY_defineProperty(axisUsingCenterY_assertThisInitialized(_this), "drawModels", void 0);

    axisUsingCenterY_defineProperty(axisUsingCenterY_assertThisInitialized(_this), "yAxisComponent", void 0);

    axisUsingCenterY_defineProperty(axisUsingCenterY_assertThisInitialized(_this), "theme", void 0);

    return _this;
  }

  axisUsingCenterY_createClass(AxisUsingCenterY, [{
    key: "initialize",
    value: function initialize(_ref) {
      var name = _ref.name;
      this.type = 'axis';
      this.name = name;
      this.yAxisComponent = name === AxisType.Y;
    }
  }, {
    key: "render",
    value: function render(_ref2) {
      var _this2 = this;

      var layout = _ref2.layout,
          axes = _ref2.axes,
          theme = _ref2.theme;
      var centerYAxis = axes.centerYAxis;

      if (!centerYAxis) {
        return;
      }

      this.theme = getAxisTheme(theme, this.name);
      this.rect = layout[this.name];

      if (this.name === 'yAxis') {
        this.rect = axisUsingCenterY_objectSpread(axisUsingCenterY_objectSpread({}, this.rect), {}, {
          x: centerYAxis.x
        });
      }

      var _ref3 = axes[this.name],
          viewLabels = _ref3.viewLabels,
          tickCount = _ref3.tickCount,
          tickInterval = _ref3.tickInterval,
          needRotateLabel = _ref3.needRotateLabel,
          radian = _ref3.radian,
          offsetY = _ref3.offsetY;
      var renderOptions = {
        tickInterval: tickInterval,
        centerYAxis: centerYAxis,
        needRotateLabel: needRotateLabel,
        radian: radian,
        offsetY: offsetY,
        relativePositions: makeTickPixelPositions(this.axisSize(centerYAxis), tickCount)
      };
      var offsetKey = this.yAxisComponent ? 'y' : 'x';
      var anchorKey = this.yAxisComponent ? 'x' : 'y';
      this.models.label = this.renderLabelModels(viewLabels, offsetKey, anchorKey, renderOptions);
      this.models.tick = this.renderTickModels(offsetKey, anchorKey, renderOptions);
      this.models.axisLine = this.renderAxisLineModel(centerYAxis);

      if (!this.drawModels) {
        this.drawModels = {
          tick: [],
          label: [],
          axisLine: this.models.axisLine
        };
        ['tick', 'label'].forEach(function (type) {
          _this2.drawModels[type] = _this2.models[type].map(function (m) {
            var drawModel = axisUsingCenterY_objectSpread({}, m);

            if (_this2.yAxisComponent) {
              drawModel.y = 0;
            } else {
              drawModel.x = 0;
            }

            return drawModel;
          });
        });
      }
    }
  }, {
    key: "renderAxisLineModel",
    value: function renderAxisLineModel(_ref4) {
      var xAxisHalfSize = _ref4.xAxisHalfSize,
          secondStartX = _ref4.secondStartX;
      var zeroPixel = crispPixel(0);
      var widthPixel = crispPixel(this.rect.width);
      var axisLine;

      if (this.yAxisComponent) {
        var heightPixel = crispPixel(this.rect.height);
        axisLine = [{
          type: 'line',
          x: widthPixel,
          y: zeroPixel,
          x2: widthPixel,
          y2: heightPixel
        }, {
          type: 'line',
          x: zeroPixel,
          y: zeroPixel,
          x2: zeroPixel,
          y2: heightPixel
        }];
      } else {
        axisLine = [{
          type: 'line',
          x: zeroPixel,
          y: zeroPixel,
          x2: crispPixel(xAxisHalfSize),
          y2: zeroPixel
        }, {
          type: 'line',
          x: crispPixel(secondStartX),
          y: zeroPixel,
          x2: widthPixel,
          y2: zeroPixel
        }];
      }

      return axisLine;
    }
  }, {
    key: "renderTickModels",
    value: function renderTickModels(offsetKey, anchorKey, renderOptions) {
      var _this3 = this;

      var tickAnchorPoint = this.yAxisComponent ? crispPixel(this.rect.width) : crispPixel(0);
      var tickInterval = renderOptions.tickInterval,
          secondStartX = renderOptions.centerYAxis.secondStartX,
          relativePositions = renderOptions.relativePositions;
      return relativePositions.reduce(function (positions, position, index) {
        var _model;

        if (index % tickInterval) {
          return positions;
        }

        var model = (_model = {
          type: 'tick',
          isYAxis: _this3.yAxisComponent,
          tickSize: _this3.yAxisComponent ? -5 : 5
        }, axisUsingCenterY_defineProperty(_model, offsetKey, crispPixel(position)), axisUsingCenterY_defineProperty(_model, anchorKey, tickAnchorPoint), _model);

        var addedTickModel = axisUsingCenterY_objectSpread({}, model);

        if (_this3.yAxisComponent) {
          addedTickModel[anchorKey] = crispPixel(0);
          addedTickModel.tickSize = 5;
        } else {
          addedTickModel[offsetKey] = crispPixel(position + secondStartX);
        }

        return [].concat(axisUsingCenterY_toConsumableArray(positions), [model, addedTickModel]);
      }, []);
    }
  }, {
    key: "renderLabelModels",
    value: function renderLabelModels(labels, offsetKey, anchorKey, renderOptions) {
      var _this4 = this;

      var _renderOptions$center = renderOptions.centerYAxis,
          secondStartX = _renderOptions$center.secondStartX,
          yAxisLabelAnchorPoint = _renderOptions$center.yAxisLabelAnchorPoint,
          offsetY = renderOptions.offsetY,
          needRotateLabel = renderOptions.needRotateLabel,
          radian = renderOptions.radian;
      var labelTheme = this.theme.label;
      var font = getTitleFontString(labelTheme);
      var labelAnchorPoint, textAlign, textLabels;

      if (this.yAxisComponent) {
        labelAnchorPoint = crispPixel(yAxisLabelAnchorPoint);
        textAlign = 'center';
        textLabels = labels;
      } else {
        labelAnchorPoint = offsetY;
        textLabels = axisUsingCenterY_toConsumableArray(labels).reverse();
        textAlign = needRotateLabel ? 'left' : 'center';
      }

      var style = ['default', {
        textAlign: textAlign,
        font: font,
        fillStyle: labelTheme.color
      }];
      return textLabels.reduce(function (positions, _ref5, index) {
        var _model2;

        var text = _ref5.text,
            offsetPos = _ref5.offsetPos;
        var model = (_model2 = {
          type: 'label',
          text: text,
          style: style
        }, axisUsingCenterY_defineProperty(_model2, offsetKey, crispPixel(offsetPos) + (_this4.yAxisComponent ? 0 : secondStartX)), axisUsingCenterY_defineProperty(_model2, anchorKey, labelAnchorPoint), axisUsingCenterY_defineProperty(_model2, "radian", radian), _model2);
        var models = [model];

        if (!_this4.yAxisComponent) {
          var addedLabelModel = axisUsingCenterY_objectSpread(axisUsingCenterY_objectSpread({}, model), {}, axisUsingCenterY_defineProperty({
            text: labels[index].text
          }, offsetKey, crispPixel(model[offsetKey] - secondStartX)));

          models.push(addedLabelModel);
        }

        return [].concat(axisUsingCenterY_toConsumableArray(positions), models);
      }, []);
    }
  }, {
    key: "axisSize",
    value: function axisSize(centerYAxis) {
      var size;

      if (this.yAxisComponent) {
        size = this.rect.height;
      } else {
        size = centerYAxis.xAxisHalfSize;
      }

      return size;
    }
  }, {
    key: "beforeDraw",
    value: function beforeDraw(painter) {
      painter.ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
      painter.ctx.lineWidth = 1;
    }
  }]);

  return AxisUsingCenterY;
}(Component);


;// CONCATENATED MODULE: ./src/charts/barChart.ts
function barChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { barChart_typeof = function _typeof(obj) { return typeof obj; }; } else { barChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return barChart_typeof(obj); }


















function barChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function barChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { barChart_ownKeys(Object(source), true).forEach(function (key) { barChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { barChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function barChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function barChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function barChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function barChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) barChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) barChart_defineProperties(Constructor, staticProps); return Constructor; }

function barChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { barChart_get = Reflect.get; } else { barChart_get = function _get(target, property, receiver) { var base = barChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return barChart_get(target, property, receiver || target); }

function barChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = barChart_getPrototypeOf(object); if (object === null) break; } return object; }

function barChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) barChart_setPrototypeOf(subClass, superClass); }

function barChart_setPrototypeOf(o, p) { barChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return barChart_setPrototypeOf(o, p); }

function barChart_createSuper(Derived) { var hasNativeReflectConstruct = barChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = barChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = barChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return barChart_possibleConstructorReturn(this, result); }; }

function barChart_possibleConstructorReturn(self, call) { if (call && (barChart_typeof(call) === "object" || typeof call === "function")) { return call; } return barChart_assertThisInitialized(self); }

function barChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function barChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function barChart_getPrototypeOf(o) { barChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return barChart_getPrototypeOf(o); }






























/**
 * @class
 * @classdesc Bar Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Bar Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {string} props.data.series.colorByCategories - Paint Rect with color based on categories.
 *       @param {Array<number|Array<number>>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Bar Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {number} [props.options.series.barWidth] - Bar width.
 *       @param {boolean} [props.options.series.diverging] - Whether to use diverging chart or not.
 *       @param {Object} [props.options.series.stack] - Option to use the stack chart or, if so, what type of stack to use.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'grouped', 'point' is available.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Bar Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var BarChart = /*#__PURE__*/function (_Chart) {
  barChart_inherits(BarChart, _Chart);

  var _super = barChart_createSuper(BarChart);

  function BarChart(_ref) {
    var el = _ref.el,
        options = _ref.options,
        data = _ref.data;

    barChart_classCallCheck(this, BarChart);

    return _super.call(this, {
      el: el,
      options: options,
      series: {
        bar: data.series
      },
      categories: data.categories,
      modules: [store_stackSeriesData, store_dataRange, store_scale, store_axes, store_plot]
    });
  }

  barChart_createClass(BarChart, [{
    key: "initialize",
    value: function initialize() {
      var _this$store$initStore;

      barChart_get(barChart_getPrototypeOf(BarChart.prototype), "initialize", this).call(this);

      var stackChart = !!((_this$store$initStore = this.store.initStoreState.options.series) !== null && _this$store$initStore !== void 0 && _this$store$initStore.stack);
      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Plot);
      this.componentManager.add(Legend);
      this.componentManager.add(BoxSeries, {
        name: 'bar',
        stackChart: stackChart
      });
      this.componentManager.add(BoxStackSeries, {
        name: 'bar',
        stackChart: stackChart
      });
      this.componentManager.add(ZeroAxis);
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(Axis, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(AxisUsingCenterY, {
        name: 'yAxis'
      });
      this.componentManager.add(AxisUsingCenterY, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(DataLabels);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */

  }, {
    key: "addData",
    value: function addData(data, category) {
      this.animationControlFlag.updating = true;
      this.resetSeries();
      this.store.dispatch('addData', {
        data: data,
        category: category
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number|Array<number>>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          bar: series
        },
        categories: categories
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *   @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only seriesIndex is needed.
     *   @param {number} [seriesInfo.seriesIndex] - Index of series
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', barChart_objectSpread({}, seriesInfo));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return BarChart;
}(Chart);


;// CONCATENATED MODULE: ./src/charts/columnChart.ts
function columnChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { columnChart_typeof = function _typeof(obj) { return typeof obj; }; } else { columnChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return columnChart_typeof(obj); }


















function columnChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function columnChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { columnChart_ownKeys(Object(source), true).forEach(function (key) { columnChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { columnChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function columnChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function columnChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function columnChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function columnChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) columnChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) columnChart_defineProperties(Constructor, staticProps); return Constructor; }

function columnChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { columnChart_get = Reflect.get; } else { columnChart_get = function _get(target, property, receiver) { var base = columnChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return columnChart_get(target, property, receiver || target); }

function columnChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = columnChart_getPrototypeOf(object); if (object === null) break; } return object; }

function columnChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) columnChart_setPrototypeOf(subClass, superClass); }

function columnChart_setPrototypeOf(o, p) { columnChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return columnChart_setPrototypeOf(o, p); }

function columnChart_createSuper(Derived) { var hasNativeReflectConstruct = columnChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = columnChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = columnChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return columnChart_possibleConstructorReturn(this, result); }; }

function columnChart_possibleConstructorReturn(self, call) { if (call && (columnChart_typeof(call) === "object" || typeof call === "function")) { return call; } return columnChart_assertThisInitialized(self); }

function columnChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function columnChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function columnChart_getPrototypeOf(o) { columnChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return columnChart_getPrototypeOf(o); }






























/**
 * @class
 * @classdesc Column Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Column Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {string} props.data.series.colorByCategories - Paint Rect with color based on categories.
 *       @param {Array<number|Array<number>>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Column Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.rangeSelectable=false] - Whether to use range selection feature or not.
 *       @param {number} [props.options.series.barWidth] - Bar width.
 *       @param {boolean} [props.options.series.diverging] - Whether to use diverging chart or not.
 *       @param {Object} [props.options.series.stack] - Option to use the stack chart or, if so, what type of stack to use.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'grouped', 'point' is available.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Bar Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var ColumnChart = /*#__PURE__*/function (_Chart) {
  columnChart_inherits(ColumnChart, _Chart);

  var _super = columnChart_createSuper(ColumnChart);

  function ColumnChart(_ref) {
    var el = _ref.el,
        options = _ref.options,
        data = _ref.data;

    columnChart_classCallCheck(this, ColumnChart);

    return _super.call(this, {
      el: el,
      options: options,
      series: {
        column: data.series
      },
      categories: data.categories,
      modules: [store_stackSeriesData, store_dataRange, store_scale, store_axes, store_plot]
    });
  }

  columnChart_createClass(ColumnChart, [{
    key: "initialize",
    value: function initialize() {
      var _this$store$initStore;

      columnChart_get(columnChart_getPrototypeOf(ColumnChart.prototype), "initialize", this).call(this);

      var stackChart = !!((_this$store$initStore = this.store.initStoreState.options.series) !== null && _this$store$initStore !== void 0 && _this$store$initStore.stack);
      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Plot);
      this.componentManager.add(Legend);
      this.componentManager.add(BoxStackSeries, {
        name: 'column',
        stackChart: stackChart
      });
      this.componentManager.add(BoxSeries, {
        name: 'column',
        stackChart: stackChart
      });
      this.componentManager.add(ZeroAxis);
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(DataLabels);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.componentManager.add(RangeSelection);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array<number|Array<number>>} data - Array of data to be added
     * @param {string} category - Category to be added
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */

  }, {
    key: "addData",
    value: function addData(data, category) {
      this.animationControlFlag.updating = true;
      this.resetSeries();
      this.store.dispatch('addData', {
        data: data,
        category: category
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added
     *   @param {string} data.name - Series name
     *   @param {Array<number|Array<number>>} data.data - Array of data to be added
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          column: series
        },
        categories: categories
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only seriesIndex is needed.
     *      @param {number} [seriesInfo.seriesIndex] - Index of series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', columnChart_objectSpread({}, seriesInfo));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return ColumnChart;
}(Chart);


;// CONCATENATED MODULE: ./src/charts/columnLineChart.ts
function columnLineChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { columnLineChart_typeof = function _typeof(obj) { return typeof obj; }; } else { columnLineChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return columnLineChart_typeof(obj); }

function columnLineChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function columnLineChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { columnLineChart_ownKeys(Object(source), true).forEach(function (key) { columnLineChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { columnLineChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function columnLineChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function columnLineChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function columnLineChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function columnLineChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) columnLineChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) columnLineChart_defineProperties(Constructor, staticProps); return Constructor; }

function columnLineChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { columnLineChart_get = Reflect.get; } else { columnLineChart_get = function _get(target, property, receiver) { var base = columnLineChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return columnLineChart_get(target, property, receiver || target); }

function columnLineChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = columnLineChart_getPrototypeOf(object); if (object === null) break; } return object; }

function columnLineChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) columnLineChart_setPrototypeOf(subClass, superClass); }

function columnLineChart_setPrototypeOf(o, p) { columnLineChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return columnLineChart_setPrototypeOf(o, p); }

function columnLineChart_createSuper(Derived) { var hasNativeReflectConstruct = columnLineChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = columnLineChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = columnLineChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return columnLineChart_possibleConstructorReturn(this, result); }; }

function columnLineChart_possibleConstructorReturn(self, call) { if (call && (columnLineChart_typeof(call) === "object" || typeof call === "function")) { return call; } return columnLineChart_assertThisInitialized(self); }

function columnLineChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function columnLineChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function columnLineChart_getPrototypeOf(o) { columnLineChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return columnLineChart_getPrototypeOf(o); }



















































function hasPointEventType(respondersModel, name) {
  return respondersModel.find(function (_ref) {
    var component = _ref.component;
    return component.name === name && component.eventDetectType === 'point';
  });
}

function hasColumnLineUsingPointEventType(respondersModel) {
  return isExist(hasPointEventType(respondersModel, 'column')) && isExist(hasPointEventType(respondersModel, 'line'));
}
/**
 * @class
 * @classdesc ColumnLine Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making ColumnLine Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {Array<Object>} props.data.series.line - Line series data. Coordinate types data is not possible.
 *       @param {Array<Object>} props.data.series.column - Column series data.
 *   @param {Object} [props.options] - Options for making ColumnLine Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series] - Write common options in the upper depth and separate options to be applied to each chart.
 *       @param {Object} [props.options.series.line] - Options to be applied to the line chart. 'spline', 'showDot', 'dataLabels' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Line Chart guide} on github.
 *       @param {Object} [props.options.series.column] - Options to be applied to the column chart. 'barWidth', 'stack', 'dataLabels' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Column Chart guide} on github.
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.rangeSelectable=false] - Whether to use range selection feature or not.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'near', 'nearest', 'grouped', 'point' is available.
 *       @param {boolean} [props.options.series.shift=false] - Whether to use shift when addData or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.pointOnColumn=false] - Whether to move the start of the chart to the center of the column.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object|Array<Object>} [props.options.yAxis] - If this option is an array type, use the secondary y axis.
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *       @param {Array<Object>} [props.options.plot.lines] - Plot lines information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *       @param {Array<Object>} [props.options.plot.bands] - Plot bands information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Plot guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|ColumnLine Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme. Each theme to be applied to the two charts should be written separately.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object|Array<Object>} [props.options.theme.yAxis] - Y Axis theme. In the case of an arrangement, the first is the main axis and the second is the theme for the secondary axis.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */


var ColumnLineChart = /*#__PURE__*/function (_Chart) {
  columnLineChart_inherits(ColumnLineChart, _Chart);

  var _super = columnLineChart_createSuper(ColumnLineChart);

  function ColumnLineChart(_ref2) {
    var el = _ref2.el,
        options = _ref2.options,
        _ref2$data = _ref2.data,
        series = _ref2$data.series,
        categories = _ref2$data.categories;

    columnLineChart_classCallCheck(this, ColumnLineChart);

    return _super.call(this, {
      el: el,
      options: options,
      series: series,
      categories: categories,
      modules: [store_stackSeriesData, store_dataRange, store_scale, store_axes, store_plot]
    });
  }

  columnLineChart_createClass(ColumnLineChart, [{
    key: "initialize",
    value: function initialize() {
      columnLineChart_get(columnLineChart_getPrototypeOf(ColumnLineChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Plot);
      this.componentManager.add(Legend);
      this.componentManager.add(BoxStackSeries, {
        name: 'column'
      });
      this.componentManager.add(BoxSeries, {
        name: 'column'
      });
      this.componentManager.add(LineSeries);
      this.componentManager.add(ZeroAxis);
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(Axis, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'secondaryYAxis'
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(DataLabels);
      this.componentManager.add(RangeSelection);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, brushes_lineSeries_namespaceObject]);
    }
  }, {
    key: "handleEventForAllResponders",
    value: function handleEventForAllResponders(event, responderModels, delegationMethod, mousePosition) {
      if (hasColumnLineUsingPointEventType(responderModels)) {
        var columnSeries = responderModels.find(function (_ref3) {
          var component = _ref3.component;
          return component.name === 'column';
        });
        columnSeries.component[delegationMethod]({
          mousePosition: mousePosition,
          responders: []
        }, event);
      }
    }
    /**
     * Add data.
     * @param {Array} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @param {string} chartType - Which type of chart to add.
     * @api
     * @example
     * chart.addData([10, 20], '6', 'line');
     */

  }, {
    key: "addData",
    value: function addData(data, category, chartType) {
      this.animationControlFlag.updating = true;
      this.resetSeries();
      this.store.dispatch('addData', {
        data: data,
        category: category,
        chartType: chartType
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     * @param {string} data.name - Series name.
     * @param {Array<number>} data.data - Array of data to be added.
     * @param {Object} dataInfo - Which type of chart to add.
     * @param {Object} dataInfo.chartType - Chart type.
     * @api
     * @example
     * chart.addSeries(
     *   {
     *     name: 'newSeries',
     *     data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     *   },
     *   {
     *     chartType: 'line'
     *   });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data, dataInfo) {
      this.resetSeries();
      this.store.dispatch('addSeries', columnLineChart_objectSpread({
        data: data
      }, dataInfo));
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: {
     *     column: [
     *       {
     *         name: 'A',
     *         data: [1, 2, 3],
     *       }
     *     ],
     *     line: [
     *       {
     *         name: 'B',
     *         data: [4, 5, 6],
     *       }
     *     ]
     *   }
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      this.resetSeries();
      this.store.dispatch('setData', data);
    }
    /**
     * Add plot line.
     * @param {Object} data - Plot info.
     *   @param {string|number} data.value - The value where the plot line will be drawn.
     *   @param {string} data.color - Plot line color.
     *   @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
     * @api
     * @example
     * chart.addPlotLine({
     *   value: 2,
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotLine",
    value: function addPlotLine(data) {
      this.store.dispatch('addPlotLine', {
        data: data
      });
    }
    /**
     * Remove plot line with id.
     * @param {string} id - Id of the plot line to be removed
     * @api
     * @example
     * chart.removePlotLine('plot-1');
     */

  }, {
    key: "removePlotLine",
    value: function removePlotLine(id) {
      this.store.dispatch('removePlotLine', {
        id: id
      });
    }
    /**
     * Add plot band.
     * @param {Object} data - plot info
     *   @param {Array<string|number>} data.range - The range to be drawn
     *   @param {string} data.color - Plot band color
     *   @param {string} [data.id] - Plot id. The value on which the removePlotBand is based
     * @api
     * @example
     * chart.addPlotBand({
     *   value: [2, 4],
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotBand",
    value: function addPlotBand(data) {
      this.store.dispatch('addPlotBand', {
        data: data
      });
    }
    /**
     * Remove plot band with id.
     * @param {string} id - id of the plot band to be removed
     * @api
     * @example
     * chart.removePlotBand('plot-1');
     */

  }, {
    key: "removePlotBand",
    value: function removePlotBand(id) {
      this.store.dispatch('removePlotBand', {
        id: id
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     line: {
     *       showDot: true,
     *     },
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     line: {
     *       showDot: true,
     *     },
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.index - Index of data within series.
     *      @param {string} seriesInfo.chartType - Specify which chart to select.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2, chartType: 'column'});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', columnLineChart_objectSpread({}, seriesInfo));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return ColumnLineChart;
}(Chart);


;// CONCATENATED MODULE: ./src/component/bubbleSeries.ts
function bubbleSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { bubbleSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { bubbleSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return bubbleSeries_typeof(obj); }

function bubbleSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function bubbleSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { bubbleSeries_ownKeys(Object(source), true).forEach(function (key) { bubbleSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { bubbleSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function bubbleSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function bubbleSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function bubbleSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) bubbleSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) bubbleSeries_defineProperties(Constructor, staticProps); return Constructor; }

function bubbleSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) bubbleSeries_setPrototypeOf(subClass, superClass); }

function bubbleSeries_setPrototypeOf(o, p) { bubbleSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return bubbleSeries_setPrototypeOf(o, p); }

function bubbleSeries_createSuper(Derived) { var hasNativeReflectConstruct = bubbleSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = bubbleSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = bubbleSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return bubbleSeries_possibleConstructorReturn(this, result); }; }

function bubbleSeries_possibleConstructorReturn(self, call) { if (call && (bubbleSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return bubbleSeries_assertThisInitialized(self); }

function bubbleSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function bubbleSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function bubbleSeries_getPrototypeOf(o) { bubbleSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return bubbleSeries_getPrototypeOf(o); }

function bubbleSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function bubbleSeries_toConsumableArray(arr) { return bubbleSeries_arrayWithoutHoles(arr) || bubbleSeries_iterableToArray(arr) || bubbleSeries_unsupportedIterableToArray(arr) || bubbleSeries_nonIterableSpread(); }

function bubbleSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function bubbleSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return bubbleSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return bubbleSeries_arrayLikeToArray(o, minLen); }

function bubbleSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function bubbleSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return bubbleSeries_arrayLikeToArray(arr); }

function bubbleSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
































var bubbleSeries_MINIMUM_RADIUS = 0.5;
var MINIMUM_DETECTING_AREA_RADIUS = 1;
function getMaxRadius(bubbleData) {
  return bubbleData.reduce(function (acc, cur) {
    var NonNullData = cur.data.filter(function (datum) {
      return !isNull(datum);
    });
    return Math.max.apply(Math, [acc].concat(bubbleSeries_toConsumableArray(NonNullData.map(function (_ref) {
      var r = _ref.r;
      return r;
    }))));
  }, 0);
}

var BubbleSeries = /*#__PURE__*/function (_Component) {
  bubbleSeries_inherits(BubbleSeries, _Component);

  var _super = bubbleSeries_createSuper(BubbleSeries);

  function BubbleSeries() {
    var _this;

    bubbleSeries_classCallCheck(this, BubbleSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "models", {
      series: []
    });

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "drawModels", void 0);

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "responders", void 0);

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "activatedResponders", []);

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "theme", void 0);

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "rect", void 0);

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "maxRadius", -1);

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "maxValue", -1);

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "selectSeries", function (_ref2) {
      var index = _ref2.index,
          seriesIndex = _ref2.seriesIndex,
          state = _ref2.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var name = state.series.bubble.data[index].name;

      var model = _this.responders.filter(function (_ref3) {
        var dataName = _ref3.name;
        return dataName === name;
      })[seriesIndex];

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      var models = _this.getResponderAppliedTheme([model], 'select');

      _this.eventBus.emit('renderSelectedSeries', {
        models: models,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    bubbleSeries_defineProperty(bubbleSeries_assertThisInitialized(_this), "showTooltip", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex,
          state = info.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var name = state.series.bubble.data[seriesIndex].name;
      var models = [_this.responders.filter(function (_ref4) {
        var dataName = _ref4.name;
        return dataName === name;
      })[index]];

      if (!models.length) {
        return;
      }

      _this.eventBus.emit('renderHoveredSeries', {
        models: models,
        name: _this.name
      });

      _this.activatedResponders = models;

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  bubbleSeries_createClass(BubbleSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'bubble';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      var _this2 = this;

      this.drawModels.series.forEach(function (model, index) {
        model.radius = _this2.models.series[index].radius * delta;
      });
    }
  }, {
    key: "render",
    value: function render(chartState) {
      var layout = chartState.layout,
          series = chartState.series,
          scale = chartState.scale,
          axes = chartState.axes,
          circleLegend = chartState.circleLegend,
          legend = chartState.legend,
          options = chartState.options,
          theme = chartState.theme;
      var plot = layout.plot;

      if (!series.bubble) {
        throw new Error(message.noDataError(this.name));
      }

      var xAxis = axes.xAxis,
          yAxis = axes.yAxis;
      var bubbleData = series.bubble.data;
      this.theme = theme.series.bubble;
      this.rect = plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      var xAxisTickSize = this.rect.width / xAxis.tickCount;
      var yAxisTickSize = this.rect.height / yAxis.tickCount;
      this.maxRadius = circleLegend.radius ? circleLegend.radius : Math.min(xAxisTickSize, yAxisTickSize);
      this.maxValue = getMaxRadius(bubbleData);
      var seriesModel = this.renderBubblePointsModel(bubbleData, scale);
      var tooltipModel = this.makeTooltipModel(bubbleData);
      this.models.series = seriesModel;

      if (!this.drawModels) {
        this.drawModels = deepCopy(this.models);
      }

      this.responders = seriesModel.map(function (m, index) {
        return bubbleSeries_objectSpread(bubbleSeries_objectSpread({}, m), {}, {
          type: 'circle',
          detectionSize: 0,
          radius: m.radius + MINIMUM_DETECTING_AREA_RADIUS,
          color: getRGBA(m.color, 0.85),
          data: tooltipModel[index],
          index: index
        });
      });
    }
  }, {
    key: "renderBubblePointsModel",
    value: function renderBubblePointsModel(seriesRawData, scale) {
      var _this3 = this;

      var xAxisLimit = scale.xAxis.limit;
      var yAxisLimit = scale.yAxis.limit;
      var _this$theme = this.theme,
          borderWidth = _this$theme.borderWidth,
          borderColor = _this$theme.borderColor;
      return seriesRawData.flatMap(function (_ref5, seriesIndex) {
        var data = _ref5.data,
            name = _ref5.name,
            seriesColor = _ref5.color;
        var circleModels = [];
        var active = _this3.activeSeriesMap[name];
        var color = getRGBA(seriesColor, active ? 0.8 : 0.1);
        var nonNullData = data.filter(function (datum) {
          return !isNull(datum);
        });
        nonNullData.forEach(function (datum) {
          var rawXValue = getCoordinateXValue(datum);
          var xValue = utils_isString(rawXValue) ? Number(new Date(rawXValue)) : Number(rawXValue);
          var yValue = getCoordinateYValue(datum);
          var xValueRatio = getValueRatio(xValue, xAxisLimit);
          var yValueRatio = getValueRatio(yValue, yAxisLimit);
          var x = xValueRatio * _this3.rect.width;
          var y = (1 - yValueRatio) * _this3.rect.height;
          var radius = Math.max(bubbleSeries_MINIMUM_RADIUS, datum.r / _this3.maxValue * _this3.maxRadius);
          circleModels.push({
            x: x,
            y: y,
            type: 'circle',
            radius: radius,
            color: color,
            style: ['default'],
            seriesIndex: seriesIndex,
            name: name,
            borderWidth: borderWidth,
            borderColor: borderColor
          });
        });
        return circleModels;
      });
    }
  }, {
    key: "makeTooltipModel",
    value: function makeTooltipModel(circleData) {
      return bubbleSeries_toConsumableArray(circleData).flatMap(function (_ref6) {
        var data = _ref6.data,
            name = _ref6.name,
            color = _ref6.color;
        var tooltipData = [];
        var nonNullData = data.filter(function (datum) {
          return !isNull(datum);
        });
        nonNullData.forEach(function (datum) {
          var r = datum.r,
              label = datum.label;
          tooltipData.push({
            label: "".concat(name, "/").concat(label),
            color: color,
            value: {
              x: getCoordinateXValue(datum),
              y: getCoordinateYValue(datum),
              r: r
            }
          });
        });
        return tooltipData;
      });
    }
  }, {
    key: "getResponderAppliedTheme",
    value: function getResponderAppliedTheme(responders, type) {
      var _this4 = this;

      return responders.map(function (responder) {
        return deepMergedCopy(responder, _this4.theme[type]);
      });
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref7) {
      var responders = _ref7.responders,
          mousePosition = _ref7.mousePosition;
      var closestResponder = getNearestResponder(responders, mousePosition, this.rect);
      var responderWithTheme = this.getResponderAppliedTheme(closestResponder, 'hover');
      this.eventBus.emit('renderHoveredSeries', {
        models: responderWithTheme,
        name: this.name
      });
      this.activatedResponders = closestResponder;
      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "onClick",
    value: function onClick(_ref8) {
      var responders = _ref8.responders,
          mousePosition = _ref8.mousePosition;

      if (this.selectable) {
        var closestResponder = getNearestResponder(responders, mousePosition, this.rect);
        var responderWithTheme = this.getResponderAppliedTheme(closestResponder, 'select');
        this.eventBus.emit('renderSelectedSeries', {
          models: responderWithTheme,
          name: this.name
        });
        this.eventBus.emit('needDraw');
      }
    }
  }]);

  return BubbleSeries;
}(Component);


;// CONCATENATED MODULE: ./src/component/circleLegend.ts
function circleLegend_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { circleLegend_typeof = function _typeof(obj) { return typeof obj; }; } else { circleLegend_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return circleLegend_typeof(obj); }













function circleLegend_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function circleLegend_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function circleLegend_createClass(Constructor, protoProps, staticProps) { if (protoProps) circleLegend_defineProperties(Constructor.prototype, protoProps); if (staticProps) circleLegend_defineProperties(Constructor, staticProps); return Constructor; }

function circleLegend_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) circleLegend_setPrototypeOf(subClass, superClass); }

function circleLegend_setPrototypeOf(o, p) { circleLegend_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return circleLegend_setPrototypeOf(o, p); }

function circleLegend_createSuper(Derived) { var hasNativeReflectConstruct = circleLegend_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = circleLegend_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = circleLegend_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return circleLegend_possibleConstructorReturn(this, result); }; }

function circleLegend_possibleConstructorReturn(self, call) { if (call && (circleLegend_typeof(call) === "object" || typeof call === "function")) { return call; } return circleLegend_assertThisInitialized(self); }

function circleLegend_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function circleLegend_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function circleLegend_getPrototypeOf(o) { circleLegend_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return circleLegend_getPrototypeOf(o); }

function circleLegend_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var CircleLegend = /*#__PURE__*/function (_Component) {
  circleLegend_inherits(CircleLegend, _Component);

  var _super = circleLegend_createSuper(CircleLegend);

  function CircleLegend() {
    var _this;

    circleLegend_classCallCheck(this, CircleLegend);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    circleLegend_defineProperty(circleLegend_assertThisInitialized(_this), "models", {
      circleLegend: []
    });

    return _this;
  }

  circleLegend_createClass(CircleLegend, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'circleLegend';
    }
  }, {
    key: "render",
    value: function render(_ref) {
      var layout = _ref.layout,
          series = _ref.series,
          circleLegend = _ref.circleLegend;

      if (!series.bubble) {
        throw new Error(message.CIRCLE_LEGEND_RENDER_ERROR);
      }

      this.isShow = circleLegend.visible;

      if (!this.isShow) {
        return;
      }

      var bubbleData = series.bubble.data;
      this.rect = layout.circleLegend;
      this.renderCircleLegend(bubbleData, circleLegend);
    }
  }, {
    key: "renderCircleLegend",
    value: function renderCircleLegend(bubbleData, circleLegend) {
      var value = getMaxRadius(bubbleData);
      var radius = circleLegend.radius;
      this.models.circleLegend = [{
        type: 'circleLegend',
        radius: radius,
        value: value,
        x: radius,
        y: this.rect.height - radius
      }];
    }
  }]);

  return CircleLegend;
}(Component);


;// CONCATENATED MODULE: ./src/brushes/circleLegend.ts


function circleLegend(ctx, circleLegendModel) {
  var x = circleLegendModel.x,
      y = circleLegendModel.y,
      radius = circleLegendModel.radius,
      value = circleLegendModel.value;
  var ratioArray = [1, 0.5, 0.25];
  ratioArray.forEach(function (ratio, idx) {
    var circleRadius = ratio * radius;
    var circleY = y + (idx ? (1 - ratio) * radius : 0);
    circle(ctx, {
      type: 'circle',
      x: x,
      y: circleY,
      radius: circleRadius,
      color: '#fff',
      seriesIndex: 0,
      style: ['default', {
        strokeStyle: '#888',
        lineWidth: 1
      }]
    });
    label(ctx, {
      type: 'label',
      x: x,
      y: circleY - circleRadius,
      text: String(value * ratio),
      style: ['default', {
        textAlign: 'center',
        textBaseline: 'bottom'
      }]
    });
  });
}
;// CONCATENATED MODULE: ./src/charts/bubbleChart.ts
function bubbleChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { bubbleChart_typeof = function _typeof(obj) { return typeof obj; }; } else { bubbleChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return bubbleChart_typeof(obj); }


















function bubbleChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function bubbleChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { bubbleChart_ownKeys(Object(source), true).forEach(function (key) { bubbleChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { bubbleChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function bubbleChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function bubbleChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function bubbleChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function bubbleChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) bubbleChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) bubbleChart_defineProperties(Constructor, staticProps); return Constructor; }

function bubbleChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { bubbleChart_get = Reflect.get; } else { bubbleChart_get = function _get(target, property, receiver) { var base = bubbleChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return bubbleChart_get(target, property, receiver || target); }

function bubbleChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = bubbleChart_getPrototypeOf(object); if (object === null) break; } return object; }

function bubbleChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) bubbleChart_setPrototypeOf(subClass, superClass); }

function bubbleChart_setPrototypeOf(o, p) { bubbleChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return bubbleChart_setPrototypeOf(o, p); }

function bubbleChart_createSuper(Derived) { var hasNativeReflectConstruct = bubbleChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = bubbleChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = bubbleChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return bubbleChart_possibleConstructorReturn(this, result); }; }

function bubbleChart_possibleConstructorReturn(self, call) { if (call && (bubbleChart_typeof(call) === "object" || typeof call === "function")) { return call; } return bubbleChart_assertThisInitialized(self); }

function bubbleChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function bubbleChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function bubbleChart_getPrototypeOf(o) { bubbleChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return bubbleChart_getPrototypeOf(o); }


























/**
 * @class
 * @classdesc Bubble Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Bubble Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<Object>} props.data.series.data - Series data. Coordinates x, y values, radius r, and label values are required.
 *   @param {Object} [props.options] - Options for making Bubble Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object} [props.options.yAxis]
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.circleLegend]
 *       @param {boolean} [props.options.circleLegend.visible] - Whether to show circle legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Bubble Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object} [props.options.theme.yAxis] - Y Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var BubbleChart = /*#__PURE__*/function (_Chart) {
  bubbleChart_inherits(BubbleChart, _Chart);

  var _super = bubbleChart_createSuper(BubbleChart);

  function BubbleChart(props) {
    bubbleChart_classCallCheck(this, BubbleChart);

    return _super.call(this, {
      el: props.el,
      options: props.options,
      series: {
        bubble: props.data.series
      },
      modules: [store_dataRange, store_scale, store_axes, store_plot]
    });
  }

  bubbleChart_createClass(BubbleChart, [{
    key: "initialize",
    value: function initialize() {
      bubbleChart_get(bubbleChart_getPrototypeOf(BubbleChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Plot);
      this.componentManager.add(Legend);
      this.componentManager.add(BubbleSeries);
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(CircleLegend);
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, brushes_circleLegend_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array<Object>} data - Array of data to be added.
     * @api
     * @example
     * chart.addData([
     *   {x: 10, y: 20, r: 10, label: 'label1'},
     *   {x: 30, y: 40, r: 10, label: 'label2'},
     * ]);
     */

  }, {
    key: "addData",
    value: function addData(data) {
      this.animationControlFlag.updating = true;
      this.resetSeries();
      this.store.dispatch('addData', {
        data: data
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<Object>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [
     *     {x: 10, y: 20, r: 10, label: 'label1'},
     *     {x: 30, y: 40, r: 10, label: 'label2'},
     *   ],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   series: [
     *     {
     *       name: 'name'
     *       data: [
     *         {x: 10, y: 20, r: 10, label: 'label1'},
     *         {x: 30, y: 40, r: 10, label: 'label2'},
     *       ]
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          bubble: data.series
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.index - Index of data within series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', bubbleChart_objectSpread(bubbleChart_objectSpread({}, seriesInfo), {}, {
        state: this.store.state
      }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return BubbleChart;
}(Chart);


;// CONCATENATED MODULE: ./src/charts/scatterChart.ts
function scatterChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { scatterChart_typeof = function _typeof(obj) { return typeof obj; }; } else { scatterChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return scatterChart_typeof(obj); }

function scatterChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function scatterChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function scatterChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) scatterChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) scatterChart_defineProperties(Constructor, staticProps); return Constructor; }

function scatterChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { scatterChart_get = Reflect.get; } else { scatterChart_get = function _get(target, property, receiver) { var base = scatterChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return scatterChart_get(target, property, receiver || target); }

function scatterChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = scatterChart_getPrototypeOf(object); if (object === null) break; } return object; }

function scatterChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) scatterChart_setPrototypeOf(subClass, superClass); }

function scatterChart_setPrototypeOf(o, p) { scatterChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return scatterChart_setPrototypeOf(o, p); }

function scatterChart_createSuper(Derived) { var hasNativeReflectConstruct = scatterChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = scatterChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = scatterChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return scatterChart_possibleConstructorReturn(this, result); }; }

function scatterChart_possibleConstructorReturn(self, call) { if (call && (scatterChart_typeof(call) === "object" || typeof call === "function")) { return call; } return scatterChart_assertThisInitialized(self); }

function scatterChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function scatterChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function scatterChart_getPrototypeOf(o) { scatterChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return scatterChart_getPrototypeOf(o); }

function scatterChart_toConsumableArray(arr) { return scatterChart_arrayWithoutHoles(arr) || scatterChart_iterableToArray(arr) || scatterChart_unsupportedIterableToArray(arr) || scatterChart_nonIterableSpread(); }

function scatterChart_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function scatterChart_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return scatterChart_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return scatterChart_arrayLikeToArray(o, minLen); }

function scatterChart_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function scatterChart_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return scatterChart_arrayLikeToArray(arr); }

function scatterChart_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function scatterChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function scatterChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { scatterChart_ownKeys(Object(source), true).forEach(function (key) { scatterChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { scatterChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function scatterChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
















































function clearUnnecessaryData(scatterSeries) {
  return scatterSeries.map(function (series) {
    var exist = {};
    return scatterChart_objectSpread(scatterChart_objectSpread({}, series), {}, {
      data: series.data.filter(function (datum) {
        return !isNull(datum);
      }).reduce(function (acc, cur) {
        var x = getCoordinateXValue(cur);
        var y = getCoordinateYValue(cur);
        var key = "".concat(x, "-").concat(y);

        if (!exist[key]) {
          exist[key] = true;
          return [].concat(scatterChart_toConsumableArray(acc), [cur]);
        }

        return acc;
      }, [])
    });
  });
}
/**
 * @class
 * @classdesc Scatter Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Scatter Chart.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<Object|Array<number>>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Scatter Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object} [props.options.yAxis]
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Scattter Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object} [props.options.theme.yAxis] - Y Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */


var ScatterChart = /*#__PURE__*/function (_Chart) {
  scatterChart_inherits(ScatterChart, _Chart);

  var _super = scatterChart_createSuper(ScatterChart);

  function ScatterChart(props) {
    var _props$data;

    scatterChart_classCallCheck(this, ScatterChart);

    return _super.call(this, {
      el: props.el,
      options: props.options,
      series: {
        scatter: clearUnnecessaryData(props.data.series)
      },
      categories: (_props$data = props.data) === null || _props$data === void 0 ? void 0 : _props$data.categories,
      modules: [store_dataRange, store_scale, store_axes, store_plot]
    });
  }

  scatterChart_createClass(ScatterChart, [{
    key: "initialize",
    value: function initialize() {
      scatterChart_get(scatterChart_getPrototypeOf(ScatterChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Plot);
      this.componentManager.add(Legend);
      this.componentManager.add(ScatterSeries);
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, scatterSeries_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array<Object>} data - Array of data to be added.
     * @api
     * @example
     * chart.addData([
     *   {x: 10, y: 20},
     *   {x: 30, y: 40},
     * ]);
     */

  }, {
    key: "addData",
    value: function addData(data) {
      this.animationControlFlag.updating = true;
      this.resetSeries();
      this.store.dispatch('addData', {
        data: data
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [
     *     {x: 10, y: 20},
     *     {x: 30, y: 40},
     *   ],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   series: [
     *     {
     *       name: 'name'
     *       data: [
     *         {x: 10, y: 20},
     *         {x: 30, y: 40},
     *       ]
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          scatter: series
        },
        categories: categories
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.index - Index of data within series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', scatterChart_objectSpread(scatterChart_objectSpread({}, seriesInfo), {}, {
        state: this.store.state
      }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return ScatterChart;
}(Chart);


;// CONCATENATED MODULE: ./src/component/bulletSeries.ts
function bulletSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { bulletSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { bulletSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return bulletSeries_typeof(obj); }

function bulletSeries_slicedToArray(arr, i) { return bulletSeries_arrayWithHoles(arr) || bulletSeries_iterableToArrayLimit(arr, i) || bulletSeries_unsupportedIterableToArray(arr, i) || bulletSeries_nonIterableRest(); }

function bulletSeries_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function bulletSeries_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function bulletSeries_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function bulletSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function bulletSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function bulletSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) bulletSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) bulletSeries_defineProperties(Constructor, staticProps); return Constructor; }

function bulletSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) bulletSeries_setPrototypeOf(subClass, superClass); }

function bulletSeries_setPrototypeOf(o, p) { bulletSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return bulletSeries_setPrototypeOf(o, p); }

function bulletSeries_createSuper(Derived) { var hasNativeReflectConstruct = bulletSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = bulletSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = bulletSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return bulletSeries_possibleConstructorReturn(this, result); }; }

function bulletSeries_possibleConstructorReturn(self, call) { if (call && (bulletSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return bulletSeries_assertThisInitialized(self); }

function bulletSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function bulletSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function bulletSeries_getPrototypeOf(o) { bulletSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return bulletSeries_getPrototypeOf(o); }

function bulletSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function bulletSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { bulletSeries_ownKeys(Object(source), true).forEach(function (key) { bulletSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { bulletSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function bulletSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }























function bulletSeries_toConsumableArray(arr) { return bulletSeries_arrayWithoutHoles(arr) || bulletSeries_iterableToArray(arr) || bulletSeries_unsupportedIterableToArray(arr) || bulletSeries_nonIterableSpread(); }

function bulletSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function bulletSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return bulletSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return bulletSeries_arrayLikeToArray(o, minLen); }

function bulletSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function bulletSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return bulletSeries_arrayLikeToArray(arr); }

function bulletSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }










var DEFAULT_WIDTH_RATIO = 0.6;
var MARKER_LINE_DETECTION_SIZE = 5;

function getRectSize(vertical, barWidth, barLength) {
  return {
    width: vertical ? barWidth : barLength,
    height: vertical ? barLength : barWidth
  };
}

function getStartX(seriesIndex, tickDistance, barWidth) {
  return seriesIndex * tickDistance + (tickDistance - barWidth) / 2;
}

function makeBulletResponderModel(models, tooltipData) {
  var range = models.range,
      marker = models.marker,
      bullet = models.bullet;
  var tooltipRange = tooltipData.range,
      tooltipMarker = tooltipData.marker,
      tooltipBullet = tooltipData.bullet;
  return [].concat(bulletSeries_toConsumableArray(range.map(function (m, index) {
    return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
      data: tooltipRange[index]
    });
  })), bulletSeries_toConsumableArray(bullet.map(function (m, index) {
    return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
      data: tooltipBullet[index]
    });
  })), bulletSeries_toConsumableArray(marker.map(function (m, index) {
    return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
      detectionSize: MARKER_LINE_DETECTION_SIZE,
      data: tooltipMarker[index]
    });
  })));
}

var BulletSeries = /*#__PURE__*/function (_Component) {
  bulletSeries_inherits(BulletSeries, _Component);

  var _super = bulletSeries_createSuper(BulletSeries);

  function BulletSeries() {
    var _this;

    bulletSeries_classCallCheck(this, BulletSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "models", {
      range: [],
      bullet: [],
      marker: []
    });

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "drawModels", void 0);

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "responders", void 0);

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "activatedResponders", []);

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "theme", void 0);

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "eventDetectType", 'point');

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "tooltipRectMap", void 0);

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "vertical", false);

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "basePosition", void 0);

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "selectSeries", function (_ref) {
      var _state$series$bullet;

      var seriesIndex = _ref.seriesIndex,
          state = _ref.state;

      if (!isNumber(seriesIndex)) {
        return;
      }

      var _state$series$bullet$ = (_state$series$bullet = state.series.bullet) === null || _state$series$bullet === void 0 ? void 0 : _state$series$bullet[seriesIndex],
          name = _state$series$bullet$.name;

      var model = _this.filterBulletResponder(_this.responders).filter(function (_ref2) {
        var dataName = _ref2.name;
        return dataName === name;
      });

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: _this.getRespondersWithTheme(model, 'select'),
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    bulletSeries_defineProperty(bulletSeries_assertThisInitialized(_this), "showTooltip", function (_ref3) {
      var _state$series$bullet2;

      var seriesIndex = _ref3.seriesIndex,
          state = _ref3.state;

      if (!isNumber(seriesIndex)) {
        return;
      }

      var _state$series$bullet$2 = (_state$series$bullet2 = state.series.bullet) === null || _state$series$bullet2 === void 0 ? void 0 : _state$series$bullet2[seriesIndex],
          name = _state$series$bullet$2.name;

      var models = _this.filterBulletResponder(_this.responders).filter(function (_ref4) {
        var dataName = _ref4.name;
        return dataName === name;
      });

      if (!models.length) {
        return;
      }

      _this.onMousemove({
        responders: models
      });
    });

    return _this;
  }

  bulletSeries_createClass(BulletSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'bullet';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      if (!this.drawModels) {
        return;
      }

      var clipRect = this.drawModels.clipRect;

      if (!clipRect) {
        return;
      }

      var offsetKey = this.vertical ? 'y' : 'x';
      var key = this.vertical ? 'height' : 'width';
      var current = clipRect[0];
      var target = this.models.clipRect[0];
      var offsetSize = current[key] + (target[key] - current[key]) * delta;
      current[key] = offsetSize;
      current[offsetKey] = Math.max(this.basePosition - offsetSize * this.basePosition / target[key], 0);
    }
  }, {
    key: "render",
    value: function render(state) {
      var _options$series;

      var layout = state.layout,
          axes = state.axes,
          series = state.series,
          scale = state.scale,
          legend = state.legend,
          options = state.options,
          theme = state.theme,
          categories = state.categories;

      if (!series.bullet) {
        throw new Error(message.noDataError(this.name));
      }

      this.setEventDetectType(series, options);
      this.theme = theme.series.bullet;
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      this.vertical = !!(options !== null && options !== void 0 && (_options$series = options.series) !== null && _options$series !== void 0 && _options$series.vertical);
      var labelAxisOnYAxis = isLabelAxisOnYAxis({
        series: series,
        options: options
      });

      var _getAxisName = getAxisName(labelAxisOnYAxis, series),
          labelAxisName = _getAxisName.labelAxisName,
          valueAxisName = _getAxisName.valueAxisName;

      var _getSizeKey = getSizeKey(labelAxisOnYAxis),
          valueSizeKey = _getSizeKey.valueSizeKey;

      var tickDistance = axes[labelAxisName].tickDistance;
      var zeroPosition = axes[valueAxisName].zeroPosition;
      var _scale$valueAxisName$ = scale[valueAxisName].limit,
          min = _scale$valueAxisName$.min,
          max = _scale$valueAxisName$.max;
      var bulletData = series.bullet.data;
      this.basePosition = zeroPosition !== null && zeroPosition !== void 0 ? zeroPosition : 0;

      var renderOptions = bulletSeries_objectSpread({
        ratio: this.rect[valueSizeKey] / (max - min),
        tickDistance: tickDistance,
        zeroPosition: zeroPosition
      }, this.getBulletBarWidths(tickDistance));

      var rangeModels = this.renderRanges(bulletData, renderOptions);
      var bulletModels = this.renderBullet(bulletData, renderOptions);
      var markerModels = this.renderMarkers(bulletData, renderOptions);
      var clipRect = this.renderClipRectArea();
      this.models.clipRect = [clipRect];
      this.models.range = rangeModels;
      this.models.bullet = bulletModels;
      this.models.marker = markerModels;

      if (!this.drawModels) {
        this.drawModels = {
          clipRect: [this.makeInitialClipRectModel(clipRect)],
          range: deepCopyArray(rangeModels),
          bullet: deepCopyArray(bulletModels),
          marker: deepCopyArray(markerModels)
        };
      }

      var models = {
        range: rangeModels,
        bullet: bulletModels,
        marker: markerModels
      };
      var tooltipData = this.makeTooltipModel(models);
      this.tooltipRectMap = this.makeTooltipRectMap(models, tooltipData);
      this.responders = this.getBulletSeriesResponders(models, tooltipData, axes, categories);

      if (getDataLabelsOptions(options, this.name).visible) {
        this.renderDataLabels(this.getDataLabels([].concat(bulletSeries_toConsumableArray(rangeModels), bulletSeries_toConsumableArray(bulletModels), bulletSeries_toConsumableArray(markerModels)), this.vertical, this.rect[valueSizeKey]));
      }
    }
  }, {
    key: "renderClipRectArea",
    value: function renderClipRectArea() {
      return {
        type: 'clipRectArea',
        x: 0,
        y: 0,
        width: this.rect.width,
        height: this.rect.height
      };
    }
  }, {
    key: "makeInitialClipRectModel",
    value: function makeInitialClipRectModel(clipRect) {
      var width = this.vertical ? clipRect.width : 0;
      var height = this.vertical ? 0 : clipRect.height;
      var x = this.vertical ? clipRect.x : 0;
      var y = this.vertical ? 0 : clipRect.y;
      return {
        type: 'clipRectArea',
        width: width,
        height: height,
        x: x,
        y: y
      };
    }
  }, {
    key: "getDataLabels",
    value: function getDataLabels(seriesModels, vertical, size) {
      var dataLabelTheme = this.theme.dataLabels;
      var bulletLabelTheme = omit(dataLabelTheme, 'marker');
      var useSeriesColor = bulletLabelTheme.useSeriesColor,
          color = bulletLabelTheme.color;
      var marker = dataLabelTheme.marker;
      return seriesModels.filter(function (m) {
        return m.type === 'line' || m.modelType !== 'range';
      }).map(function (m) {
        if (m.type === 'line') {
          return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
            x: vertical ? (m.x + m.x2) / 2 : m.x,
            theme: bulletSeries_objectSpread(bulletSeries_objectSpread({}, marker), {}, {
              color: marker.useSeriesColor ? m.strokeStyle : marker.color
            })
          });
        }

        var isValueNegative = isNumber(m.value) && (m === null || m === void 0 ? void 0 : m.value) < 0;
        var direction = vertical ? 'top' : 'right';

        if (isValueNegative) {
          direction = vertical ? 'bottom' : 'left';
        }

        return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
          direction: direction,
          plot: {
            x: 0,
            y: 0,
            size: size
          },
          theme: bulletSeries_objectSpread(bulletSeries_objectSpread({}, bulletLabelTheme), {}, {
            color: useSeriesColor ? m.color : color
          })
        });
      });
    }
  }, {
    key: "setEventDetectType",
    value: function setEventDetectType(series, options) {
      var _options$series2;

      if (options !== null && options !== void 0 && (_options$series2 = options.series) !== null && _options$series2 !== void 0 && _options$series2.eventDetectType) {
        this.eventDetectType = options.series.eventDetectType;
      }
    }
  }, {
    key: "getBulletSeriesResponders",
    value: function getBulletSeriesResponders(models, tooltipData, axes, categories) {
      return this.eventDetectType === 'grouped' ? makeRectResponderModel(this.rect, this.vertical ? axes.xAxis : axes.yAxis, categories, this.vertical) : makeBulletResponderModel(models, tooltipData);
    }
  }, {
    key: "makeTooltipRectMap",
    value: function makeTooltipRectMap(models, tooltipData) {
      var result = {};
      Object.keys(models).forEach(function (seriesType) {
        models[seriesType].forEach(function (m, index) {
          var label = m.name;

          if (!result[label]) {
            result[label] = [];
          }

          var tooltipModel = bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
            data: tooltipData[seriesType][index]
          });

          result[label].push(tooltipModel);
        });
      });
      return result;
    }
  }, {
    key: "getBulletSeriesModelsFromRectResponders",
    value: function getBulletSeriesModelsFromRectResponders(responders) {
      var _this$tooltipRectMap;

      if (!responders.length) {
        return [];
      }

      return (_this$tooltipRectMap = this.tooltipRectMap[responders[0].label]) !== null && _this$tooltipRectMap !== void 0 ? _this$tooltipRectMap : [];
    }
  }, {
    key: "getGroupedRect",
    value: function getGroupedRect(responders, type) {
      var bulletSeriesModels = this.getBulletSeriesModelsFromRectResponders(responders);
      var _ref5 = this.theme[type].groupedRect,
          color = _ref5.color,
          opacity = _ref5.opacity;
      return bulletSeriesModels.length ? responders.map(function (m) {
        return bulletSeries_objectSpread(bulletSeries_objectSpread({}, m), {}, {
          color: getRGBA(color, opacity)
        });
      }) : [];
    }
  }, {
    key: "onMousemoveGroupedType",
    value: function onMousemoveGroupedType(responders) {
      var bulletSeriesModels = this.getBulletSeriesModelsFromRectResponders(responders);
      this.eventBus.emit('renderHoveredSeries', {
        models: [].concat(bulletSeries_toConsumableArray(this.getGroupedRect(responders, 'hover')), bulletSeries_toConsumableArray(this.getRespondersWithTheme(bulletSeriesModels, 'hover'))),
        name: this.name,
        eventDetectType: this.eventDetectType
      });
      this.activatedResponders = bulletSeriesModels;
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref6) {
      var responders = _ref6.responders;

      if (this.eventDetectType === 'grouped') {
        this.onMousemoveGroupedType(responders);
      } else {
        this.eventBus.emit('renderHoveredSeries', {
          models: this.getRespondersWithTheme(responders, 'hover'),
          name: this.name
        });
        this.activatedResponders = responders.length ? [responders[responders.length - 1]] : [];
      }

      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "onClick",
    value: function onClick(_ref7) {
      var responders = _ref7.responders;

      if (this.selectable) {
        var models = this.eventDetectType === 'grouped' ? [].concat(bulletSeries_toConsumableArray(this.getGroupedRect(responders, 'select')), bulletSeries_toConsumableArray(this.getRespondersWithTheme(this.getBulletSeriesModelsFromRectResponders(responders), 'select'))) : this.getRespondersWithTheme(responders, 'select');
        this.eventBus.emit('renderSelectedSeries', {
          models: models,
          name: this.name,
          eventDetectType: this.eventDetectType
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "filterBulletResponder",
    value: function filterBulletResponder(responders) {
      return responders.filter(function (model) {
        return (model === null || model === void 0 ? void 0 : model.modelType) === 'bullet';
      });
    }
  }, {
    key: "renderRanges",
    value: function renderRanges(bulletData, _ref8) {
      var _this2 = this;

      var tickDistance = _ref8.tickDistance,
          ratio = _ref8.ratio,
          zeroPosition = _ref8.zeroPosition,
          rangeWidth = _ref8.rangeWidth;
      var rangeModels = [];
      bulletData.forEach(function (_ref9, seriesIndex) {
        var ranges = _ref9.ranges,
            color = _ref9.color,
            name = _ref9.name;
        (ranges !== null && ranges !== void 0 ? ranges : []).forEach(function (range, rangeIndex) {
          if (!isNull(range)) {
            var _range = bulletSeries_slicedToArray(range, 2),
                start = _range[0],
                end = _range[1];

            var barLength = (end - start) * ratio;
            var rangeStartX = getStartX(seriesIndex, tickDistance, rangeWidth);
            rangeModels.push(bulletSeries_objectSpread(bulletSeries_objectSpread({
              type: 'rect',
              name: name,
              color: _this2.getRangeColor(getRGBA(color, _this2.getSeriesOpacity(name)), rangeIndex, name),
              x: _this2.vertical ? rangeStartX : start * ratio + zeroPosition,
              y: _this2.vertical ? zeroPosition - end * ratio : rangeStartX
            }, getRectSize(_this2.vertical, rangeWidth, barLength)), {}, {
              modelType: 'range',
              seriesColor: color,
              tooltipColor: _this2.getRangeColor(color, rangeIndex, name, true),
              value: range
            }));
          }
        });
      });
      return rangeModels;
    }
  }, {
    key: "renderBullet",
    value: function renderBullet(bulletData, _ref10) {
      var _this3 = this;

      var tickDistance = _ref10.tickDistance,
          ratio = _ref10.ratio,
          zeroPosition = _ref10.zeroPosition,
          bulletWidth = _ref10.bulletWidth;
      var _this$theme = this.theme,
          borderColor = _this$theme.borderColor,
          thickness = _this$theme.borderWidth;
      return bulletData.reduce(function (acc, _ref11, seriesIndex) {
        var data = _ref11.data,
            color = _ref11.color,
            name = _ref11.name;

        if (isNull(data)) {
          return bulletSeries_toConsumableArray(acc);
        }

        var bulletLength = Math.max(Math.abs(data * ratio), 2);
        var bulletStartX = getStartX(seriesIndex, tickDistance, bulletWidth);
        var x = _this3.vertical ? bulletStartX : zeroPosition - (data < 0 ? bulletLength : 0);
        var y = _this3.vertical ? zeroPosition - bulletLength + (data < 0 ? bulletLength : 0) : bulletStartX;

        var bullet = bulletSeries_objectSpread({
          type: 'rect',
          name: name,
          color: getRGBA(color, _this3.getSeriesOpacity(name)),
          x: x,
          y: y,
          thickness: thickness,
          borderColor: borderColor,
          modelType: 'bullet',
          seriesColor: color,
          tooltipColor: color,
          value: data
        }, getRectSize(_this3.vertical, bulletWidth, bulletLength));

        return [].concat(bulletSeries_toConsumableArray(acc), [bullet]);
      }, []);
    }
  }, {
    key: "renderMarkers",
    value: function renderMarkers(bulletData, _ref12) {
      var _this4 = this;

      var tickDistance = _ref12.tickDistance,
          ratio = _ref12.ratio,
          zeroPosition = _ref12.zeroPosition,
          markerWidth = _ref12.markerWidth;
      var markerLineWidth = this.theme.markerLineWidth;
      var markerModels = [];
      bulletData.forEach(function (_ref13, seriesIndex) {
        var markers = _ref13.markers,
            color = _ref13.color,
            name = _ref13.name;
        var markerStartX = getStartX(seriesIndex, tickDistance, markerWidth);
        (markers !== null && markers !== void 0 ? markers : []).forEach(function (marker) {
          if (!isNull(marker)) {
            var dataPosition = marker * ratio;
            var x = _this4.vertical ? markerStartX : dataPosition + zeroPosition;
            var y = _this4.vertical ? zeroPosition - dataPosition : markerStartX;
            markerModels.push({
              type: 'line',
              name: name,
              x: x,
              y: y,
              x2: _this4.vertical ? x + markerWidth : x,
              y2: _this4.vertical ? y : y + markerWidth,
              strokeStyle: getRGBA(color, _this4.getSeriesOpacity(name)),
              lineWidth: markerLineWidth,
              seriesColor: color,
              tooltipColor: color,
              value: marker
            });
          }
        });
      });
      return markerModels;
    }
  }, {
    key: "makeTooltipModel",
    value: function makeTooltipModel(seriesModels) {
      var range = seriesModels.range,
          bullet = seriesModels.bullet,
          marker = seriesModels.marker;
      return {
        range: this.makeTooltipData(range, 'Range'),
        bullet: this.makeTooltipData(bullet, 'Actual'),
        marker: this.makeTooltipData(marker, 'Marker')
      };
    }
  }, {
    key: "makeTooltipData",
    value: function makeTooltipData(data, title) {
      return data.map(function (m) {
        var name = m.name,
            seriesColor = m.seriesColor,
            tooltipColor = m.tooltipColor,
            value = m.value;
        return {
          label: name,
          color: getRGBA(seriesColor, 1),
          value: [{
            title: title,
            value: value,
            color: tooltipColor
          }],
          templateType: 'bullet'
        };
      });
    }
  }, {
    key: "getBulletBarWidths",
    value: function getBulletBarWidths(tickDistance) {
      var _this$theme2 = this.theme,
          barThemeWidth = _this$theme2.barWidth,
          barWidthRatios = _this$theme2.barWidthRatios;
      var rangeRatio = barWidthRatios.rangeRatio,
          bulletRatio = barWidthRatios.bulletRatio,
          markerRatio = barWidthRatios.markerRatio;
      var barWidth = barThemeWidth ? calculateSizeWithPercentString(tickDistance, barThemeWidth) : tickDistance * DEFAULT_WIDTH_RATIO;
      return {
        rangeWidth: barWidth * rangeRatio,
        bulletWidth: barWidth * bulletRatio,
        markerWidth: barWidth * markerRatio
      };
    }
  }, {
    key: "getRangeColor",
    value: function getRangeColor(seriesColor, rangeIndex, seriesName) {
      var ignoreRestSeriesOpacity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var rangeColors = this.theme.rangeColors;
      var hasThemeRangeColor = Array.isArray(rangeColors) && rangeColors[rangeIndex];
      var color = hasThemeRangeColor ? rangeColors[rangeIndex] : seriesColor;
      var opacity = hasThemeRangeColor ? getAlpha(rangeColors[rangeIndex]) : DEFAULT_BULLET_RANGE_OPACITY[rangeIndex];
      return getRGBA(color, opacity * this.getSeriesOpacity(seriesName, ignoreRestSeriesOpacity));
    }
  }, {
    key: "getSeriesOpacity",
    value: function getSeriesOpacity(seriesName) {
      var ignoreRestSeriesOpacity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var _this$theme3 = this.theme,
          select = _this$theme3.select,
          areaOpacity = _this$theme3.areaOpacity;
      var active = this.activeSeriesMap[seriesName];
      var selected = Object.values(this.activeSeriesMap).some(function (elem) {
        return !elem;
      });
      var restOpacity = ignoreRestSeriesOpacity ? areaOpacity : select.restSeries.areaOpacity;
      var selectedOpacity = active ? select.areaOpacity : restOpacity;
      return selected ? selectedOpacity : areaOpacity;
    }
  }, {
    key: "getRespondersWithTheme",
    value: function getRespondersWithTheme(responders, type) {
      var _this5 = this;

      var _this$theme$type = this.theme[type],
          color = _this$theme$type.color,
          borderColor = _this$theme$type.borderColor,
          thickness = _this$theme$type.borderWidth;
      return this.filterBulletResponder(responders).map(function (model) {
        return bulletSeries_objectSpread(bulletSeries_objectSpread({}, model), {}, {
          color: color !== null && color !== void 0 ? color : model.tooltipColor,
          thickness: thickness,
          borderColor: borderColor,
          style: [bulletSeries_objectSpread({}, pick(_this5.theme[type], 'shadowBlur', 'shadowColor', 'shadowOffsetX', 'shadowOffsetY'))]
        });
      });
    }
  }]);

  return BulletSeries;
}(Component);


;// CONCATENATED MODULE: ./src/charts/bulletChart.ts
function bulletChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { bulletChart_typeof = function _typeof(obj) { return typeof obj; }; } else { bulletChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return bulletChart_typeof(obj); }


















function bulletChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function bulletChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { bulletChart_ownKeys(Object(source), true).forEach(function (key) { bulletChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { bulletChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function bulletChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function bulletChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function bulletChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) bulletChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) bulletChart_defineProperties(Constructor, staticProps); return Constructor; }

function bulletChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { bulletChart_get = Reflect.get; } else { bulletChart_get = function _get(target, property, receiver) { var base = bulletChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return bulletChart_get(target, property, receiver || target); }

function bulletChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = bulletChart_getPrototypeOf(object); if (object === null) break; } return object; }

function bulletChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) bulletChart_setPrototypeOf(subClass, superClass); }

function bulletChart_setPrototypeOf(o, p) { bulletChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return bulletChart_setPrototypeOf(o, p); }

function bulletChart_createSuper(Derived) { var hasNativeReflectConstruct = bulletChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = bulletChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = bulletChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return bulletChart_possibleConstructorReturn(this, result); }; }

function bulletChart_possibleConstructorReturn(self, call) { if (call && (bulletChart_typeof(call) === "object" || typeof call === "function")) { return call; } return bulletChart_assertThisInitialized(self); }

function bulletChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function bulletChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function bulletChart_getPrototypeOf(o) { bulletChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return bulletChart_getPrototypeOf(o); }

function bulletChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


























/**
 * @class
 * @classdesc Bullet Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Bullet Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {number} props.data.series.data - Series data.
 *       @param {Array<number>} props.data.series.markers - Series markers. It specifies the marker for comparing.
 *       @param {Array<Array<number>>} props.data.series.ranges - Series ranges. It specifies the range of values that can be compared.
 *   @param {Object} [props.options] - Options for making Bullet Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {number} [props.options.series.vertical] - Whether to use vertical bullet series or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object} [props.options.yAxis]
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Bullets Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object} [props.options.theme.yAxis] - Y Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var BulletChart = /*#__PURE__*/function (_Chart) {
  bulletChart_inherits(BulletChart, _Chart);

  var _super = bulletChart_createSuper(BulletChart);

  function BulletChart(_ref) {
    var _this;

    var el = _ref.el,
        options = _ref.options,
        series = _ref.data.series;

    bulletChart_classCallCheck(this, BulletChart);

    _this = _super.call(this, {
      el: el,
      options: options,
      series: {
        bullet: series
      },
      modules: [store_dataRange, store_scale, store_axes, store_plot]
    });

    bulletChart_defineProperty(bulletChart_assertThisInitialized(_this), "hideTooltip", function () {
      _this.eventBus.emit('hideTooltip');
    });

    return _this;
  }

  bulletChart_createClass(BulletChart, [{
    key: "initialize",
    value: function initialize() {
      bulletChart_get(bulletChart_getPrototypeOf(BulletChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Plot);
      this.componentManager.add(Legend);
      this.componentManager.add(BulletSeries);
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(DataLabels);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject]);
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added
     *   @param {string} data.name - Series name
     *   @param {Array<<Array<number>>} data.data - Array of data to be added
     *   @param {Array<number>} data.markers - Series markers. It specifies the marker for comparing.
     *   @param {Array<Array<number>>} data.ranges - Series ranges. It specifies the range of values that can be compared.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: 20,
     *   markers: [28, 2, 15],
     *   ranges: [
     *     [-1, 10],
     *     [10, 20],
     *     [20, 30],
     *   ],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   series: [
     *     {
     *       name: 'newSeries',
     *       data: 20,
     *       markers: [28, 2, 15],
     *       ranges: [
     *         [-1, 10],
     *         [10, 20],
     *         [20, 30],
     *       ],
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          bullet: data.series
        }
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     * @api
     * @example
     * chart.showTooltip({seriesIndex: 1});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', bulletChart_objectSpread(bulletChart_objectSpread({}, seriesInfo), {}, {
        state: this.store.state
      }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }]);

  return BulletChart;
}(Chart);


;// CONCATENATED MODULE: ./src/store/nestedPieSeriesData.ts
function nestedPieSeriesData_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function nestedPieSeriesData_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { nestedPieSeriesData_ownKeys(Object(source), true).forEach(function (key) { nestedPieSeriesData_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { nestedPieSeriesData_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function nestedPieSeriesData_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }













function findRootName(rawSeries, seriesIndex, parentName) {
  var _rawSeries$pie;

  var item = (_rawSeries$pie = rawSeries.pie) === null || _rawSeries$pie === void 0 ? void 0 : _rawSeries$pie[seriesIndex].data.find(function (_ref) {
    var name = _ref.name;
    return name === parentName;
  });
  return item !== null && item !== void 0 && item.parentName ? findRootName(rawSeries, seriesIndex - 1, item.parentName) : parentName;
}

var nestedPieSeriesData = {
  name: 'seriesData',
  state: function state() {
    return {
      nestedPieSeries: {}
    };
  },
  action: {
    setNestedPieSeriesData: function setNestedPieSeriesData(_ref2) {
      var state = _ref2.state,
          initStoreState = _ref2.initStoreState;
      var theme = state.theme,
          disabledSeries = state.disabledSeries;
      var rawSeries = initStoreState.series;
      var newSeriesData = {};
      var colorMap = {};
      rawSeries.pie.forEach(function (_ref3, seriesIndex) {
        var alias = _ref3.name,
            data = _ref3.data;
        var colors = theme.series.pie[alias].colors;
        var colorList = [];
        var originSeriesData = data.map(function (m, index) {
          var parentName = m.parentName,
              dataName = m.name;
          var color = parentName && seriesIndex ? colorMap[parentName] : colors === null || colors === void 0 ? void 0 : colors[index];
          colorList.push(color);
          colorMap[dataName] = color;
          var rootParentName = parentName && seriesIndex ? findRootName(rawSeries, seriesIndex - 1, parentName) : dataName;
          return nestedPieSeriesData_objectSpread(nestedPieSeriesData_objectSpread({}, m), {}, {
            data: m.data,
            rootParentName: rootParentName,
            color: color
          });
        });
        newSeriesData[alias] = {
          data: originSeriesData.filter(function (_ref4) {
            var rootParentName = _ref4.rootParentName;
            return !disabledSeries.includes(rootParentName);
          }),
          colors: colorList
        };
      });
      state.nestedPieSeries = newSeriesData;
      this.dispatch('updateNestedPieChartLegend');
    }
  },
  observe: {
    updateNestedPieSeriesData: function updateNestedPieSeriesData() {
      this.dispatch('setNestedPieSeriesData');
    }
  }
};
/* harmony default export */ var store_nestedPieSeriesData = (nestedPieSeriesData);
;// CONCATENATED MODULE: ./src/charts/nestedPieChart.ts
function nestedPieChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { nestedPieChart_typeof = function _typeof(obj) { return typeof obj; }; } else { nestedPieChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return nestedPieChart_typeof(obj); }

function nestedPieChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function nestedPieChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { nestedPieChart_ownKeys(Object(source), true).forEach(function (key) { nestedPieChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { nestedPieChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function nestedPieChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



















function nestedPieChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function nestedPieChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function nestedPieChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) nestedPieChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) nestedPieChart_defineProperties(Constructor, staticProps); return Constructor; }

function nestedPieChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { nestedPieChart_get = Reflect.get; } else { nestedPieChart_get = function _get(target, property, receiver) { var base = nestedPieChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return nestedPieChart_get(target, property, receiver || target); }

function nestedPieChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = nestedPieChart_getPrototypeOf(object); if (object === null) break; } return object; }

function nestedPieChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) nestedPieChart_setPrototypeOf(subClass, superClass); }

function nestedPieChart_setPrototypeOf(o, p) { nestedPieChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return nestedPieChart_setPrototypeOf(o, p); }

function nestedPieChart_createSuper(Derived) { var hasNativeReflectConstruct = nestedPieChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = nestedPieChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = nestedPieChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return nestedPieChart_possibleConstructorReturn(this, result); }; }

function nestedPieChart_possibleConstructorReturn(self, call) { if (call && (nestedPieChart_typeof(call) === "object" || typeof call === "function")) { return call; } return nestedPieChart_assertThisInitialized(self); }

function nestedPieChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function nestedPieChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function nestedPieChart_getPrototypeOf(o) { nestedPieChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return nestedPieChart_getPrototypeOf(o); }




















/**
 * @class
 * @classdesc NestedPie Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making NestedPie Chart.
 *     @param {Array<string>} [props.data.categories] - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {number} props.data.series.data - Series data.
 *       @param {string} [props.data.series.parentName] - Value specifying parent data when using group nested pie chart.
 *   @param {Object} [props.options] - Options for making NestedPie Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *       @param {Object} [props.options.series.aliasName] - Chart options are specified based on the alias name. 'radiusRange', 'angleRange', 'clockwise', 'dataLabels' is available. For specific information, refer to the {@link https://github.com/nhn/tui.chart|NestedPie Chart guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|NestedPie Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var NestedPieChart = /*#__PURE__*/function (_Chart) {
  nestedPieChart_inherits(NestedPieChart, _Chart);

  var _super = nestedPieChart_createSuper(NestedPieChart);

  function NestedPieChart(_ref) {
    var el = _ref.el,
        options = _ref.options,
        _ref$data = _ref.data,
        series = _ref$data.series,
        categories = _ref$data.categories;

    nestedPieChart_classCallCheck(this, NestedPieChart);

    return _super.call(this, {
      el: el,
      options: options,
      series: {
        pie: series
      },
      categories: categories,
      modules: [store_nestedPieSeriesData]
    });
  }

  nestedPieChart_createClass(NestedPieChart, [{
    key: "initialize",
    value: function initialize() {
      var _this$store$initStore,
          _this = this;

      nestedPieChart_get(nestedPieChart_getPrototypeOf(NestedPieChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Legend);
      ((_this$store$initStore = this.store.initStoreState.series.pie) !== null && _this$store$initStore !== void 0 ? _this$store$initStore : []).forEach(function (_ref2) {
        var name = _ref2.name;

        _this.componentManager.add(PieSeries, {
          alias: name
        });
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(DataLabels);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, brushes_sector_namespaceObject, dataLabel_namespaceObject]);
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<Object>} data.data - Array of data to be added.
     * @param {Object} dataInfo - Which name of chart to add.
     *   @param {string} dataInfo.name - Chart series name.
     * @api
     * @example
     * chart.addSeries(
     *   {
     *     name: 'newSeries',
     *     data: [
     *       { name: 'A', data: 10 },
     *       { name: 'B', data: 20 },
     *     ],
     *   },
     *   {
     *     name: 'series name'
     *   });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data, dataInfo) {
      this.resetSeries();
      this.store.dispatch('addSeries', nestedPieChart_objectSpread({
        data: data
      }, dataInfo));
      this.componentManager.add(PieSeries, {
        alias: data.name
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set
     * @api
     * @example
     * chart.setData({
     *   categories: ['A', 'B'],
     *   series: [
     *     {
     *       name: 'browsers',
     *       data: [
     *         {
     *           name: 'Chrome',
     *           data: 50,
     *         },
     *         {
     *           name: 'Safari',
     *           data: 20,
     *         },
     *       ]
     *     },
     *     {
     *       name: 'versions',
     *       data: [
     *         {
     *           name: '1',
     *           data: 50,
     *         },
     *         {
     *           name: '2',
     *           data: 20,
     *         },
     *       ]
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var _this$store$initStore2,
          _this2 = this;

      this.componentManager.remove(PieSeries);
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          pie: data.series
        }
      });
      ((_this$store$initStore2 = this.store.initStoreState.series.pie) !== null && _this$store$initStore2 !== void 0 ? _this$store$initStore2 : []).forEach(function (_ref3) {
        var name = _ref3.name;

        _this2.componentManager.add(PieSeries, {
          alias: name
        });
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     alias2: {
     *       radiusRange: [20%, 50%],
     *     },
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     alias1: {
     *       showDot: true,
     *     },
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.alias - alias name.
     * @api
     * @example
     * chart.showTooltip({seriesIndex: 1, alias: 'name'});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', nestedPieChart_objectSpread({}, seriesInfo));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return NestedPieChart;
}(Chart);


;// CONCATENATED MODULE: ./src/component/radarSeries.ts
function radarSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { radarSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { radarSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return radarSeries_typeof(obj); }

function radarSeries_toConsumableArray(arr) { return radarSeries_arrayWithoutHoles(arr) || radarSeries_iterableToArray(arr) || radarSeries_unsupportedIterableToArray(arr) || radarSeries_nonIterableSpread(); }

function radarSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function radarSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return radarSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return radarSeries_arrayLikeToArray(o, minLen); }

function radarSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function radarSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return radarSeries_arrayLikeToArray(arr); }

function radarSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function radarSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function radarSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { radarSeries_ownKeys(Object(source), true).forEach(function (key) { radarSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { radarSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }























function radarSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function radarSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function radarSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) radarSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) radarSeries_defineProperties(Constructor, staticProps); return Constructor; }

function radarSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) radarSeries_setPrototypeOf(subClass, superClass); }

function radarSeries_setPrototypeOf(o, p) { radarSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return radarSeries_setPrototypeOf(o, p); }

function radarSeries_createSuper(Derived) { var hasNativeReflectConstruct = radarSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = radarSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = radarSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return radarSeries_possibleConstructorReturn(this, result); }; }

function radarSeries_possibleConstructorReturn(self, call) { if (call && (radarSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return radarSeries_assertThisInitialized(self); }

function radarSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function radarSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function radarSeries_getPrototypeOf(o) { radarSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return radarSeries_getPrototypeOf(o); }

function radarSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










var NONE_AREA_OPACITY = 0;
var radarSeries_seriesOpacity = {
  INACTIVE: 0.2,
  ACTIVE: 1
};

var RadarSeries = /*#__PURE__*/function (_Component) {
  radarSeries_inherits(RadarSeries, _Component);

  var _super = radarSeries_createSuper(RadarSeries);

  function RadarSeries() {
    var _this;

    radarSeries_classCallCheck(this, RadarSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "models", {
      area: [],
      line: [],
      dot: []
    });

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "drawModels", void 0);

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "responders", void 0);

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "activatedResponders", []);

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "theme", void 0);

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "selectSeries", function (_ref) {
      var index = _ref.index,
          seriesIndex = _ref.seriesIndex,
          state = _ref.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var name = state.series.radar.data[seriesIndex].name;

      var model = _this.responders.filter(function (_ref2) {
        var dataName = _ref2.name;
        return dataName === name;
      })[index];

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: _this.getRespondersWithTheme([model], 'select'),
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    radarSeries_defineProperty(radarSeries_assertThisInitialized(_this), "showTooltip", function (_ref3) {
      var index = _ref3.index,
          seriesIndex = _ref3.seriesIndex,
          state = _ref3.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var name = state.series.radar.data[seriesIndex].name;
      var models = [_this.responders.filter(function (_ref4) {
        var dataName = _ref4.name;
        return dataName === name;
      })[index]];

      if (!models.length) {
        return;
      }

      _this.eventBus.emit('renderHoveredSeries', {
        models: _this.getRespondersWithTheme(models, 'hover'),
        name: _this.name
      });

      _this.activatedResponders = models;

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  radarSeries_createClass(RadarSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'radar';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "render",
    value: function render(state) {
      var _options$series$showA, _options$series, _series$radar, _options$series2, _options$series3;

      var layout = state.layout,
          radialAxes = state.radialAxes,
          series = state.series,
          legend = state.legend,
          options = state.options,
          theme = state.theme,
          scale = state.scale;

      if (!series.radar) {
        throw new Error(message.noDataError(this.name));
      }

      this.theme = theme.series.radar;
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      var categories = state.categories;
      var _ref5 = radialAxes.verticalAxis,
          axisSize = _ref5.axisSize,
          centerX = _ref5.centerX,
          centerY = _ref5.centerY;
      var _ref6 = scale.verticalAxis,
          limit = _ref6.limit,
          stepSize = _ref6.stepSize;
      var labels = makeLabelsFromLimit(limit, stepSize);

      var _getLimitOnAxis = getLimitOnAxis(labels),
          min = _getLimitOnAxis.min,
          max = _getLimitOnAxis.max;

      var renderOptions = {
        categories: categories,
        degree: DEGREE_360 / categories.length,
        centerX: centerX,
        centerY: centerY,
        showArea: (_options$series$showA = options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : _options$series.showArea) !== null && _options$series$showA !== void 0 ? _options$series$showA : false,
        ratio: axisSize / (max - min)
      };
      var radarData = (_series$radar = series.radar) === null || _series$radar === void 0 ? void 0 : _series$radar.data;
      var radarPointsData = this.makeRadarPointsData(radarData, renderOptions);
      var circleModel = this.renderDotModels(radarPointsData);
      this.models.area = options !== null && options !== void 0 && (_options$series2 = options.series) !== null && _options$series2 !== void 0 && _options$series2.showArea ? this.renderAreaModels(radarPointsData) : [];
      this.models.line = this.renderLineModels(radarPointsData);
      this.models.dot = options !== null && options !== void 0 && (_options$series3 = options.series) !== null && _options$series3 !== void 0 && _options$series3.showDot ? circleModel : [];

      if (!this.drawModels) {
        this.drawModels = {
          area: this.initDrawModels('area', centerX, centerY),
          line: this.initDrawModels('line', centerX, centerY),
          dot: this.models.dot.map(function (m) {
            return radarSeries_objectSpread(radarSeries_objectSpread({}, m), {}, {
              x: centerX,
              y: centerY
            });
          })
        };
      }

      var tooltipDataArr = this.makeTooltipModel(circleModel, categories);
      this.responders = circleModel.map(function (m, index) {
        return radarSeries_objectSpread(radarSeries_objectSpread({}, m), {}, {
          data: tooltipDataArr[index],
          color: getRGBA(m.color, 1)
        });
      });
    }
  }, {
    key: "initDrawModels",
    value: function initDrawModels(modelName, centerX, centerY) {
      return this.models[modelName].map(function (m) {
        var _m$distances;

        return radarSeries_objectSpread(radarSeries_objectSpread({}, m), {}, {
          distances: (_m$distances = m.distances) === null || _m$distances === void 0 ? void 0 : _m$distances.map(function () {
            return 0;
          }),
          points: m.points.map(function () {
            return {
              x: centerX,
              y: centerY
            };
          })
        });
      });
    }
  }, {
    key: "makeTooltipModel",
    value: function makeTooltipModel(circleModel, categories) {
      return circleModel.map(function (_ref7) {
        var name = _ref7.name,
            color = _ref7.color,
            value = _ref7.value,
            index = _ref7.index;
        return {
          label: name,
          color: color,
          value: value,
          category: categories[index]
        };
      });
    }
  }, {
    key: "getRespondersWithTheme",
    value: function getRespondersWithTheme(responders, type) {
      var _ref8 = this.theme[type].dot,
          radius = _ref8.radius,
          borderWidth = _ref8.borderWidth,
          borderColor = _ref8.borderColor,
          color = _ref8.color;
      return responders.map(function (responder) {
        var modelColor = color !== null && color !== void 0 ? color : responder.color;
        return radarSeries_objectSpread(radarSeries_objectSpread({}, responder), {}, {
          radius: radius,
          color: modelColor,
          borderColor: borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(modelColor, 0.5),
          borderWidth: borderWidth
        });
      });
    }
  }, {
    key: "onClick",
    value: function onClick(_ref9) {
      var responders = _ref9.responders;

      if (this.selectable) {
        this.eventBus.emit('renderSelectedSeries', {
          models: this.getRespondersWithTheme(responders, 'select'),
          name: this.name
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref10) {
      var responders = _ref10.responders;
      this.eventBus.emit('renderHoveredSeries', {
        models: this.getRespondersWithTheme(responders, 'hover'),
        name: this.name
      });
      this.activatedResponders = responders;
      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "makeRadarPointsData",
    value: function makeRadarPointsData(seriesData, renderOptions) {
      var _this2 = this;

      var centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          degree = renderOptions.degree,
          ratio = renderOptions.ratio,
          showArea = renderOptions.showArea;
      return seriesData.map(function (_ref11) {
        var data = _ref11.data,
            seriesColor = _ref11.color,
            name = _ref11.name;
        var radarPoints = data.reduce(function (acc, value, index) {
          if (isNull(value)) {
            return {
              distances: [].concat(radarSeries_toConsumableArray(acc.distances), [0]),
              linePoints: [].concat(radarSeries_toConsumableArray(acc.linePoints), [null]),
              areaPoints: [].concat(radarSeries_toConsumableArray(acc.areaPoints), [{
                x: centerX,
                y: centerY
              }])
            };
          }

          var distance = value * ratio;
          var point = getRadialPosition(centerX, centerY, distance, calculateDegreeToRadian(degree * index));
          return {
            distances: [].concat(radarSeries_toConsumableArray(acc.distances), [distance]),
            linePoints: [].concat(radarSeries_toConsumableArray(acc.linePoints), [point]),
            areaPoints: [].concat(radarSeries_toConsumableArray(acc.areaPoints), [point])
          };
        }, {
          linePoints: [],
          distances: [],
          areaPoints: []
        });

        if (!isNull(data[0]) && !isNull(data[data.length - 1])) {
          radarPoints.linePoints.push(radarPoints.linePoints[0]);
          radarPoints.areaPoints.push(radarPoints.areaPoints[0]);
        }

        return radarSeries_objectSpread(radarSeries_objectSpread({
          name: name,
          seriesColor: seriesColor,
          data: data
        }, radarPoints), _this2.getSeriesColor(showArea, seriesColor, name));
      });
    }
  }, {
    key: "renderAreaModels",
    value: function renderAreaModels(radarPointsData) {
      return radarPointsData.map(function (_ref12) {
        var distances = _ref12.distances,
            areaPoints = _ref12.areaPoints,
            name = _ref12.name,
            fillColor = _ref12.fillColor,
            seriesColor = _ref12.seriesColor;
        return {
          type: 'areaPoints',
          name: name,
          distances: distances,
          points: areaPoints,
          fillColor: fillColor,
          color: getRGBA(seriesColor, 0),
          lineWidth: 0
        };
      });
    }
  }, {
    key: "renderLineModels",
    value: function renderLineModels(radarPointsData) {
      var _this$theme = this.theme,
          lineWidth = _this$theme.lineWidth,
          dashSegments = _this$theme.dashSegments;
      return radarPointsData.map(function (_ref13) {
        var distances = _ref13.distances,
            linePoints = _ref13.linePoints,
            name = _ref13.name,
            lineColor = _ref13.lineColor;
        return {
          type: 'linePoints',
          lineWidth: lineWidth !== null && lineWidth !== void 0 ? lineWidth : radarDefault.LINE_WIDTH,
          name: name,
          distances: distances,
          points: linePoints,
          color: lineColor,
          dashSegments: dashSegments
        };
      });
    }
  }, {
    key: "renderDotModels",
    value: function renderDotModels(radarPointsData) {
      var _ref14 = this.theme.dot,
          radius = _ref14.radius,
          dotColor = _ref14.color;
      var result = [];
      radarPointsData.forEach(function (_ref15, seriesIndex) {
        var linePoints = _ref15.linePoints,
            lineColor = _ref15.lineColor,
            name = _ref15.name,
            data = _ref15.data;
        return linePoints.slice(0, linePoints.length - 1).forEach(function (point, index) {
          if (!isNull(point)) {
            result.push(radarSeries_objectSpread(radarSeries_objectSpread({
              type: 'circle'
            }, point), {}, {
              radius: radius,
              color: dotColor !== null && dotColor !== void 0 ? dotColor : lineColor,
              style: [{
                strokeStyle: 'rgba(0, 0, 0, 0)'
              }],
              name: name,
              seriesIndex: seriesIndex,
              index: index,
              value: data === null || data === void 0 ? void 0 : data[index]
            }));
          }
        });
      });
      return result;
    }
  }, {
    key: "getSeriesColor",
    value: function getSeriesColor(showArea, seriesColor, name) {
      var active = this.activeSeriesMap[name];
      var _this$theme2 = this.theme,
          select = _this$theme2.select,
          areaOpacity = _this$theme2.areaOpacity;
      var selected = Object.values(this.activeSeriesMap).some(function (elem) {
        return !elem;
      });
      var color = getRGBA(seriesColor, active ? radarSeries_seriesOpacity.ACTIVE : radarSeries_seriesOpacity.INACTIVE);
      var fillOpacity = NONE_AREA_OPACITY;

      if (showArea) {
        var selectedAreaOpacity = active ? select.areaOpacity : select.restSeries.areaOpacity;
        fillOpacity = selected ? selectedAreaOpacity : areaOpacity;
      }

      return {
        lineColor: color,
        fillColor: getRGBA(color, fillOpacity)
      };
    }
  }]);

  return RadarSeries;
}(Component);


;// CONCATENATED MODULE: ./src/component/radialPlot.ts
function radialPlot_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { radialPlot_typeof = function _typeof(obj) { return typeof obj; }; } else { radialPlot_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return radialPlot_typeof(obj); }

function radialPlot_toConsumableArray(arr) { return radialPlot_arrayWithoutHoles(arr) || radialPlot_iterableToArray(arr) || radialPlot_unsupportedIterableToArray(arr) || radialPlot_nonIterableSpread(); }

function radialPlot_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function radialPlot_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return radialPlot_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return radialPlot_arrayLikeToArray(o, minLen); }

function radialPlot_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function radialPlot_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return radialPlot_arrayLikeToArray(arr); }

function radialPlot_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function radialPlot_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function radialPlot_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function radialPlot_createClass(Constructor, protoProps, staticProps) { if (protoProps) radialPlot_defineProperties(Constructor.prototype, protoProps); if (staticProps) radialPlot_defineProperties(Constructor, staticProps); return Constructor; }

function radialPlot_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) radialPlot_setPrototypeOf(subClass, superClass); }

function radialPlot_setPrototypeOf(o, p) { radialPlot_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return radialPlot_setPrototypeOf(o, p); }

function radialPlot_createSuper(Derived) { var hasNativeReflectConstruct = radialPlot_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = radialPlot_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = radialPlot_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return radialPlot_possibleConstructorReturn(this, result); }; }

function radialPlot_possibleConstructorReturn(self, call) { if (call && (radialPlot_typeof(call) === "object" || typeof call === "function")) { return call; } return radialPlot_assertThisInitialized(self); }

function radialPlot_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function radialPlot_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function radialPlot_getPrototypeOf(o) { radialPlot_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return radialPlot_getPrototypeOf(o); }

function radialPlot_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
























function getScaleMaxLimitValue(scale, totalAngle) {
  var max = scale.limit.max,
      stepSize = scale.stepSize;
  return max + (totalAngle < DEGREE_360 ? DEGREE_0 : stepSize);
}

function findCategoryIndex(categories, value) {
  return categories.findIndex(function (category) {
    return category === value;
  });
}

var RadarPlot = /*#__PURE__*/function (_Component) {
  radialPlot_inherits(RadarPlot, _Component);

  var _super = radialPlot_createSuper(RadarPlot);

  function RadarPlot() {
    var _this;

    radialPlot_classCallCheck(this, RadarPlot);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    radialPlot_defineProperty(radialPlot_assertThisInitialized(_this), "models", {
      plot: [],
      line: [],
      band: []
    });

    radialPlot_defineProperty(radialPlot_assertThisInitialized(_this), "circularAxisTheme", void 0);

    return _this;
  }

  radialPlot_createClass(RadarPlot, [{
    key: "initialize",
    value: function initialize(initParam) {
      var _initParam$name;

      this.type = 'plot';
      this.name = (_initParam$name = initParam === null || initParam === void 0 ? void 0 : initParam.name) !== null && _initParam$name !== void 0 ? _initParam$name : 'radialPlot';
    }
  }, {
    key: "render",
    value: function render(state) {
      var _ref;

      var layout = state.layout,
          radialAxes = state.radialAxes,
          options = state.options,
          series = state.series,
          theme = state.theme,
          scale = state.scale;
      this.rect = layout.plot;
      this.circularAxisTheme = theme.circularAxis;
      var categories = (_ref = state.categories) !== null && _ref !== void 0 ? _ref : [];

      if (this.name === 'gauge') {
        var _plot$bands, _plot;

        var bandData = (_plot$bands = options === null || options === void 0 ? void 0 : (_plot = options.plot) === null || _plot === void 0 ? void 0 : _plot.bands) !== null && _plot$bands !== void 0 ? _plot$bands : [];
        var hasCategoryAxis = !isLabelAxisOnYAxis({
          series: series,
          categories: categories
        });
        var renderOptions = this.makeRenderOptionsOnGauge(hasCategoryAxis, radialAxes.circularAxis, categories, scale);
        this.models.band = this.renderBands(bandData, renderOptions, categories);
      } else {
        var _options$plot$type, _options$plot;

        var isRadarChart = !!series.radar;
        var plotType = (_options$plot$type = (_options$plot = options.plot) === null || _options$plot === void 0 ? void 0 : _options$plot.type) !== null && _options$plot$type !== void 0 ? _options$plot$type : isRadarChart ? 'spiderweb' : 'circle';

        var _renderOptions = this.makeRenderOptions(radialAxes, plotType, categories);

        this.models.plot = this.renderPlot(_renderOptions);
        this.models.line = series.radialBar ? this.renderLine(_renderOptions) : [];
      }
    }
  }, {
    key: "makeRenderOptionsOnGauge",
    value: function makeRenderOptionsOnGauge(hasCategoryAxis, circularAxis, categories, scale) {
      var _circularAxis$angle = circularAxis.angle,
          total = _circularAxis$angle.total,
          start = _circularAxis$angle.start,
          outer = circularAxis.radius.outer,
          clockwise = circularAxis.clockwise,
          centerX = circularAxis.centerX,
          centerY = circularAxis.centerY;
      var _ref2 = circularAxis.band,
          bandWidth = _ref2.width,
          bandMargin = _ref2.margin;
      return {
        centerX: centerX,
        centerY: centerY,
        clockwise: clockwise,
        totalAngle: total,
        scaleMaxLimitValue: hasCategoryAxis ? categories.length : getScaleMaxLimitValue(scale.circularAxis, total),
        startAngle: start,
        outerRadius: outer,
        bandWidth: bandWidth,
        bandMargin: bandMargin,
        hasCategoryAxis: hasCategoryAxis
      };
    }
  }, {
    key: "makeRenderOptions",
    value: function makeRenderOptions(radialAxes, type) {
      var categories = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      var _ref3 = radialAxes.verticalAxis,
          centerX = _ref3.centerX,
          centerY = _ref3.centerY,
          _ref3$radius = _ref3.radius,
          ranges = _ref3$radius.ranges,
          inner = _ref3$radius.inner,
          outer = _ref3$radius.outer;
      var _radialAxes$circularA = radialAxes.circularAxis,
          _radialAxes$circularA2 = _radialAxes$circularA.angle,
          central = _radialAxes$circularA2.central,
          total = _radialAxes$circularA2.total,
          start = _radialAxes$circularA2.start,
          end = _radialAxes$circularA2.end,
          drawingStart = _radialAxes$circularA2.drawingStart,
          labels = _radialAxes$circularA.label.labels,
          tickInterval = _radialAxes$circularA.tickInterval,
          clockwise = _radialAxes$circularA.clockwise;
      var usingArcPlot = total !== DEGREE_360;
      var lineCount = labels.length;
      return {
        type: type,
        categories: categories,
        centralAngle: central,
        centerX: centerX,
        centerY: centerY,
        initialRadius: inner,
        radius: outer,
        radiusRanges: ranges,
        lineCount: lineCount,
        tickInterval: tickInterval,
        drawingStartAngle: drawingStart,
        usingArcPlot: usingArcPlot,
        startAngle: start,
        endAngle: end,
        clockwise: clockwise
      };
    }
  }, {
    key: "renderPlot",
    value: function renderPlot(renderOptions) {
      var type = renderOptions.type,
          usingArcPlot = renderOptions.usingArcPlot;

      if (usingArcPlot) {
        return this.makeArc(renderOptions);
      }

      if (type === 'spiderweb') {
        return this.makeSpiderwebPlot(renderOptions);
      }

      return this.makeCirclePlot(renderOptions);
    }
  }, {
    key: "makeSpiderwebPlot",
    value: function makeSpiderwebPlot(renderOptions) {
      var centralAngle = renderOptions.centralAngle,
          centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          categories = renderOptions.categories,
          radiusRanges = renderOptions.radiusRanges;
      var _this$circularAxisThe = this.circularAxisTheme,
          strokeStyle = _this$circularAxisThe.strokeStyle,
          lineWidth = _this$circularAxisThe.lineWidth;
      return radiusRanges.map(function (radius) {
        var points = categories.map(function (_, index) {
          return getRadialPosition(centerX, centerY, radius, calculateDegreeToRadian(centralAngle * index));
        });
        return {
          type: 'polygon',
          color: strokeStyle,
          lineWidth: lineWidth,
          points: points
        };
      });
    }
  }, {
    key: "makeCirclePlot",
    value: function makeCirclePlot(renderOptions) {
      var centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          radiusRanges = renderOptions.radiusRanges;
      var _this$circularAxisThe2 = this.circularAxisTheme,
          strokeStyle = _this$circularAxisThe2.strokeStyle,
          lineWidth = _this$circularAxisThe2.lineWidth;
      return radiusRanges.map(function (radius) {
        return {
          type: 'circle',
          color: 'rgba(0, 0, 0, 0)',
          radius: radius,
          x: centerX,
          y: centerY,
          borderColor: strokeStyle,
          borderWidth: lineWidth
        };
      });
    }
  }, {
    key: "makeArc",
    value: function makeArc(renderOptions) {
      var centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          radiusRanges = renderOptions.radiusRanges,
          startAngle = renderOptions.startAngle,
          endAngle = renderOptions.endAngle,
          clockwise = renderOptions.clockwise;
      var _this$circularAxisThe3 = this.circularAxisTheme,
          strokeStyle = _this$circularAxisThe3.strokeStyle,
          lineWidth = _this$circularAxisThe3.lineWidth;
      return radiusRanges.map(function (radius) {
        return {
          type: 'arc',
          borderWidth: lineWidth,
          borderColor: strokeStyle,
          x: centerX,
          y: centerY,
          angle: {
            start: startAngle,
            end: endAngle
          },
          drawingStartAngle: DEGREE_NEGATIVE_90,
          radius: radius,
          clockwise: clockwise
        };
      });
    }
  }, {
    key: "renderLine",
    value: function renderLine(renderOptions) {
      var centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          initialRadius = renderOptions.initialRadius,
          radius = renderOptions.radius,
          lineCount = renderOptions.lineCount,
          centralAngle = renderOptions.centralAngle,
          tickInterval = renderOptions.tickInterval,
          drawingStartAngle = renderOptions.drawingStartAngle,
          clockwise = renderOptions.clockwise;
      var _this$circularAxisThe4 = this.circularAxisTheme,
          strokeStyle = _this$circularAxisThe4.strokeStyle,
          lineWidth = _this$circularAxisThe4.lineWidth;
      return range(0, lineCount).reduce(function (acc, cur, index) {
        var startDegree = drawingStartAngle + centralAngle * index * (clockwise ? 1 : -1);

        var _getRadialPosition = getRadialPosition(centerX, centerY, initialRadius, calculateDegreeToRadian(startDegree)),
            x = _getRadialPosition.x,
            y = _getRadialPosition.y;

        var _getRadialPosition2 = getRadialPosition(centerX, centerY, radius, calculateDegreeToRadian(startDegree)),
            x2 = _getRadialPosition2.x,
            y2 = _getRadialPosition2.y;

        return index % tickInterval === 0 ? [].concat(radialPlot_toConsumableArray(acc), [{
          type: 'line',
          x: x,
          y: y,
          x2: x2,
          y2: y2,
          strokeStyle: strokeStyle,
          lineWidth: lineWidth
        }]) : acc;
      }, []);
    }
  }, {
    key: "renderBands",
    value: function renderBands(bands, renderOptions, categories) {
      var sectors = [];
      var centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          clockwise = renderOptions.clockwise,
          totalAngle = renderOptions.totalAngle,
          scaleMaxLimitValue = renderOptions.scaleMaxLimitValue,
          startAngle = renderOptions.startAngle,
          outerRadius = renderOptions.outerRadius,
          bandWidth = renderOptions.bandWidth,
          bandMargin = renderOptions.bandMargin,
          hasCategoryAxis = renderOptions.hasCategoryAxis;
      bands.forEach(function (_ref4, index) {
        var rangeData = _ref4.range,
            color = _ref4.color;
        var value = hasCategoryAxis ? findCategoryIndex(categories, rangeData[1].toString()) - findCategoryIndex(categories, rangeData[0].toString()) : Number(rangeData[1]) - Number(rangeData[0]);
        var degree = value / scaleMaxLimitValue * totalAngle * (clockwise ? 1 : -1);
        var validDegree = calculateValidAngle(degree);
        var prevModel = sectors[sectors.length - 1];
        var startDegree = index && prevModel ? prevModel.degree.end : startAngle;
        var endDegree = calculateValidAngle(startDegree + validDegree);
        sectors.push({
          type: 'sector',
          color: color,
          x: centerX,
          y: centerY,
          clockwise: clockwise,
          degree: {
            start: startDegree,
            end: endDegree
          },
          radius: {
            inner: outerRadius + bandMargin,
            outer: outerRadius + bandWidth
          }
        });
      });
      return sectors;
    }
  }]);

  return RadarPlot;
}(Component);


;// CONCATENATED MODULE: ./src/component/radialAxis.ts
function radialAxis_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { radialAxis_typeof = function _typeof(obj) { return typeof obj; }; } else { radialAxis_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return radialAxis_typeof(obj); }

function radialAxis_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function radialAxis_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { radialAxis_ownKeys(Object(source), true).forEach(function (key) { radialAxis_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { radialAxis_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function radialAxis_toConsumableArray(arr) { return radialAxis_arrayWithoutHoles(arr) || radialAxis_iterableToArray(arr) || radialAxis_unsupportedIterableToArray(arr) || radialAxis_nonIterableSpread(); }

function radialAxis_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function radialAxis_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return radialAxis_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return radialAxis_arrayLikeToArray(o, minLen); }

function radialAxis_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function radialAxis_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return radialAxis_arrayLikeToArray(arr); }

function radialAxis_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }





















function radialAxis_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function radialAxis_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function radialAxis_createClass(Constructor, protoProps, staticProps) { if (protoProps) radialAxis_defineProperties(Constructor.prototype, protoProps); if (staticProps) radialAxis_defineProperties(Constructor, staticProps); return Constructor; }

function radialAxis_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) radialAxis_setPrototypeOf(subClass, superClass); }

function radialAxis_setPrototypeOf(o, p) { radialAxis_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return radialAxis_setPrototypeOf(o, p); }

function radialAxis_createSuper(Derived) { var hasNativeReflectConstruct = radialAxis_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = radialAxis_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = radialAxis_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return radialAxis_possibleConstructorReturn(this, result); }; }

function radialAxis_possibleConstructorReturn(self, call) { if (call && (radialAxis_typeof(call) === "object" || typeof call === "function")) { return call; } return radialAxis_assertThisInitialized(self); }

function radialAxis_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function radialAxis_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function radialAxis_getPrototypeOf(o) { radialAxis_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return radialAxis_getPrototypeOf(o); }

function radialAxis_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var radialAxis_RECT_SIZE = 4;
var HALF_TICK = 5;

function hasNeedRender(index, pointOnColumn, labelInterval, innerRadius, outerRadius) {
  return !pointOnColumn && index === 0 ? false : !(index % labelInterval) && (pointOnColumn && innerRadius <= outerRadius || !pointOnColumn && innerRadius < outerRadius);
}

var RadialAxis = /*#__PURE__*/function (_Component) {
  radialAxis_inherits(RadialAxis, _Component);

  var _super = radialAxis_createSuper(RadialAxis);

  function RadialAxis() {
    var _this;

    radialAxis_classCallCheck(this, RadialAxis);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    radialAxis_defineProperty(radialAxis_assertThisInitialized(_this), "models", {
      verticalAxisLabel: [],
      circularAxisLabel: [],
      dot: [],
      line: [],
      tick: []
    });

    radialAxis_defineProperty(radialAxis_assertThisInitialized(_this), "verticalAxisTheme", void 0);

    radialAxis_defineProperty(radialAxis_assertThisInitialized(_this), "circularAxisTheme", void 0);

    return _this;
  }

  radialAxis_createClass(RadialAxis, [{
    key: "initialize",
    value: function initialize(initParam) {
      var _initParam$name;

      this.type = 'axis';
      this.name = (_initParam$name = initParam === null || initParam === void 0 ? void 0 : initParam.name) !== null && _initParam$name !== void 0 ? _initParam$name : 'radial';
    }
  }, {
    key: "render",
    value: function render(_ref) {
      var layout = _ref.layout,
          radialAxes = _ref.radialAxes,
          theme = _ref.theme,
          series = _ref.series;
      this.isShow = !isNoData(series);
      this.rect = layout.plot;

      if (!radialAxes) {
        return;
      }

      this.circularAxisTheme = theme.circularAxis;
      var circularAxis = radialAxes.circularAxis,
          verticalAxis = radialAxes.verticalAxis;

      if (verticalAxis) {
        this.verticalAxisTheme = theme.verticalAxis;
        this.models.verticalAxisLabel = this.renderVerticalAxisLabel(verticalAxis);
      }

      this.models.circularAxisLabel = this.renderCircularAxisLabel(circularAxis);

      if (this.name === 'gauge') {
        this.models.line = this.renderArcLine(circularAxis);
        this.models.tick = this.renderTick(circularAxis);
      } else {
        this.models.dot = this.renderDotModel(circularAxis);
      }
    }
  }, {
    key: "getBubbleShadowStyle",
    value: function getBubbleShadowStyle() {
      var _ref2 = this.verticalAxisTheme.label.textBubble,
          visible = _ref2.visible,
          shadowColor = _ref2.shadowColor,
          shadowOffsetX = _ref2.shadowOffsetX,
          shadowOffsetY = _ref2.shadowOffsetY,
          shadowBlur = _ref2.shadowBlur;
      return visible && shadowColor ? [{
        shadowColor: shadowColor,
        shadowOffsetX: shadowOffsetX,
        shadowOffsetY: shadowOffsetY,
        shadowBlur: shadowBlur
      }] : null;
    }
  }, {
    key: "renderVerticalAxisLabel",
    value: function renderVerticalAxisLabel(verticalAxis) {
      var _this2 = this;

      var _verticalAxis$radius = verticalAxis.radius,
          ranges = _verticalAxis$radius.ranges,
          outer = _verticalAxis$radius.outer,
          _verticalAxis$label = verticalAxis.label,
          labels = _verticalAxis$label.labels,
          interval = _verticalAxis$label.interval,
          maxWidth = _verticalAxis$label.maxWidth,
          maxHeight = _verticalAxis$label.maxHeight,
          margin = _verticalAxis$label.margin,
          align = _verticalAxis$label.align,
          start = verticalAxis.angle.start,
          pointOnColumn = verticalAxis.pointOnColumn,
          centerX = verticalAxis.centerX,
          centerY = verticalAxis.centerY,
          tickDistance = verticalAxis.tickDistance;
      var labelAdjustment = pointOnColumn ? tickDistance / 2 : 0;
      var font = getTitleFontString(this.verticalAxisTheme.label);
      var _ref3 = this.verticalAxisTheme.label.textBubble,
          textBubbleVisible = _ref3.visible,
          backgroundColor = _ref3.backgroundColor,
          borderRadius = _ref3.borderRadius,
          borderColor = _ref3.borderColor,
          borderWidth = _ref3.borderWidth,
          paddingX = _ref3.paddingX,
          paddingY = _ref3.paddingY;
      var labelPaddingX = textBubbleVisible ? paddingX : 0;
      var labelPaddingY = textBubbleVisible ? paddingY : 0;
      var width = maxWidth + labelPaddingX * 2 - margin;
      var height = maxHeight + labelPaddingY * 2;
      var fontColor = this.verticalAxisTheme.label.color;
      return ranges.reduce(function (acc, radius, index) {
        var _getRadialPosition = getRadialPosition(centerX, centerY, radius - labelAdjustment, calculateDegreeToRadian(start)),
            x = _getRadialPosition.x,
            y = _getRadialPosition.y;

        var needRender = hasNeedRender(index, pointOnColumn, interval, radius, outer);
        var posX = x + margin;
        var labelPosX = x + margin + labelPaddingX;

        if (align === 'center') {
          posX = x - margin - width / 2;
          labelPosX = x - margin;
        } else if (includes(['right', 'end'], align)) {
          posX = x - margin - width;
          labelPosX = x - margin - labelPaddingX;
        }

        return needRender ? [].concat(radialAxis_toConsumableArray(acc), [{
          type: 'bubbleLabel',
          rotationPosition: {
            x: x,
            y: y
          },
          radian: calculateDegreeToRadian(start, 0),
          bubble: {
            x: posX,
            y: y - height / 2,
            width: width,
            height: height,
            align: align,
            radius: borderRadius,
            fill: backgroundColor,
            lineWidth: borderWidth,
            strokeStyle: borderColor,
            style: _this2.getBubbleShadowStyle()
          },
          label: {
            text: labels[index],
            x: labelPosX,
            y: y,
            style: [{
              font: font,
              fillStyle: fontColor,
              textAlign: align,
              textBaseline: 'middle'
            }]
          }
        }]) : acc;
      }, []);
    }
  }, {
    key: "renderDotModel",
    value: function renderDotModel(circularAxis) {
      var _circularAxis$angle = circularAxis.angle,
          central = _circularAxis$angle.central,
          drawingStart = _circularAxis$angle.drawingStart,
          _circularAxis$label = circularAxis.label,
          labels = _circularAxis$label.labels,
          interval = _circularAxis$label.interval,
          outer = circularAxis.radius.outer,
          centerX = circularAxis.centerX,
          centerY = circularAxis.centerY,
          clockwise = circularAxis.clockwise;
      var dotColor = this.circularAxisTheme.dotColor;
      return labels.reduce(function (acc, cur, index) {
        var startDegree = drawingStart + central * index * (clockwise ? 1 : -1);

        var _getRadialPosition2 = getRadialPosition(centerX, centerY, outer, calculateDegreeToRadian(calculateValidAngle(startDegree))),
            x = _getRadialPosition2.x,
            y = _getRadialPosition2.y;

        return index % interval === 0 ? [].concat(radialAxis_toConsumableArray(acc), [{
          type: 'rect',
          color: dotColor,
          width: radialAxis_RECT_SIZE,
          height: radialAxis_RECT_SIZE,
          x: x - radialAxis_RECT_SIZE / 2,
          y: y - radialAxis_RECT_SIZE / 2
        }]) : acc;
      }, []);
    }
  }, {
    key: "renderCircularAxisLabel",
    value: function renderCircularAxisLabel(circularAxis) {
      var centerX = circularAxis.centerX,
          centerY = circularAxis.centerY,
          clockwise = circularAxis.clockwise,
          _circularAxis$label2 = circularAxis.label,
          labels = _circularAxis$label2.labels,
          interval = _circularAxis$label2.interval,
          margin = _circularAxis$label2.margin,
          maxHeight = _circularAxis$label2.maxHeight,
          _circularAxis$angle2 = circularAxis.angle,
          drawingStart = _circularAxis$angle2.drawingStart,
          central = _circularAxis$angle2.central,
          outer = circularAxis.radius.outer;
      var radius = outer + (margin + maxHeight / 2) * (this.name === 'gauge' ? -1 : 1);
      var labelTheme = this.circularAxisTheme.label;
      var font = getTitleFontString(labelTheme);
      var degree = central * (clockwise ? 1 : -1);
      return labels.reduce(function (acc, text, index) {
        var startDegree = drawingStart + degree * index;
        var validStartAngle = calculateValidAngle(startDegree);
        return index % interval === 0 ? [].concat(radialAxis_toConsumableArray(acc), [radialAxis_objectSpread({
          type: 'label',
          style: [{
            textAlign: 'center',
            textBaseline: 'middle',
            font: font,
            fillStyle: labelTheme.color
          }],
          text: text
        }, getRadialPosition(centerX, centerY, radius, calculateDegreeToRadian(validStartAngle)))]) : acc;
      }, []);
    }
  }, {
    key: "renderTick",
    value: function renderTick(circularAxis) {
      var centerX = circularAxis.centerX,
          centerY = circularAxis.centerY,
          tickInterval = circularAxis.tickInterval,
          clockwise = circularAxis.clockwise,
          _circularAxis$angle3 = circularAxis.angle,
          central = _circularAxis$angle3.central,
          drawingStart = _circularAxis$angle3.drawingStart,
          labels = circularAxis.label.labels,
          outer = circularAxis.radius.outer;
      var _this$circularAxisThe = this.circularAxisTheme.tick,
          strokeStyle = _this$circularAxisThe.strokeStyle,
          lineWidth = _this$circularAxisThe.lineWidth;
      return labels.reduce(function (acc, cur, index) {
        var startDegree = drawingStart + central * index * (clockwise ? 1 : -1);

        var _getRadialPosition3 = getRadialPosition(centerX, centerY, outer - HALF_TICK, calculateDegreeToRadian(calculateValidAngle(startDegree))),
            x = _getRadialPosition3.x,
            y = _getRadialPosition3.y;

        var _getRadialPosition4 = getRadialPosition(centerX, centerY, outer + HALF_TICK, calculateDegreeToRadian(calculateValidAngle(startDegree))),
            x2 = _getRadialPosition4.x,
            y2 = _getRadialPosition4.y;

        return index % tickInterval === 0 ? [].concat(radialAxis_toConsumableArray(acc), [{
          type: 'line',
          lineWidth: lineWidth,
          strokeStyle: strokeStyle,
          x: x,
          y: y,
          x2: x2,
          y2: y2
        }]) : acc;
      }, []);
    }
  }, {
    key: "renderArcLine",
    value: function renderArcLine(circularAxis) {
      var centerX = circularAxis.centerX,
          centerY = circularAxis.centerY,
          clockwise = circularAxis.clockwise,
          _circularAxis$angle4 = circularAxis.angle,
          start = _circularAxis$angle4.start,
          end = _circularAxis$angle4.end,
          total = _circularAxis$angle4.total,
          outer = circularAxis.radius.outer;
      var _this$circularAxisThe2 = this.circularAxisTheme,
          strokeStyle = _this$circularAxisThe2.strokeStyle,
          lineWidth = _this$circularAxisThe2.lineWidth;
      return total === DEGREE_360 ? [{
        type: 'circle',
        x: centerX,
        y: centerY,
        radius: outer,
        borderWidth: lineWidth,
        borderColor: strokeStyle,
        color: 'rgba(0, 0, 0, 0)'
      }] : [{
        type: 'arc',
        borderWidth: lineWidth,
        borderColor: strokeStyle,
        x: centerX,
        y: centerY,
        angle: {
          start: start,
          end: end
        },
        drawingStartAngle: DEGREE_NEGATIVE_90,
        radius: outer,
        clockwise: clockwise
      }];
    }
  }]);

  return RadialAxis;
}(Component);


;// CONCATENATED MODULE: ./src/charts/radarChart.ts
function radarChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { radarChart_typeof = function _typeof(obj) { return typeof obj; }; } else { radarChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return radarChart_typeof(obj); }


















function radarChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function radarChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { radarChart_ownKeys(Object(source), true).forEach(function (key) { radarChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { radarChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function radarChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function radarChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function radarChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function radarChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) radarChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) radarChart_defineProperties(Constructor, staticProps); return Constructor; }

function radarChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { radarChart_get = Reflect.get; } else { radarChart_get = function _get(target, property, receiver) { var base = radarChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return radarChart_get(target, property, receiver || target); }

function radarChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = radarChart_getPrototypeOf(object); if (object === null) break; } return object; }

function radarChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) radarChart_setPrototypeOf(subClass, superClass); }

function radarChart_setPrototypeOf(o, p) { radarChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return radarChart_setPrototypeOf(o, p); }

function radarChart_createSuper(Derived) { var hasNativeReflectConstruct = radarChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = radarChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = radarChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return radarChart_possibleConstructorReturn(this, result); }; }

function radarChart_possibleConstructorReturn(self, call) { if (call && (radarChart_typeof(call) === "object" || typeof call === "function")) { return call; } return radarChart_assertThisInitialized(self); }

function radarChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function radarChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function radarChart_getPrototypeOf(o) { radarChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return radarChart_getPrototypeOf(o); }
























/**
 * @class
 * @classdesc Radar Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Radar Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<number>} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Radar Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.showDot=false] - Whether to show dot or not.
 *       @param {boolean} [props.options.series.showArea=false] - Whether to fill area or not.
 *     @param {Object} [props.options.circularAxis]
 *       @param {Object} [props.options.circularAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.circularAxis.label] - Option to adjust label interval.
 *     @param {Object} [props.options.verticalAxis]
 *       @param {Object} [props.options.verticalAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.verticalAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.verticalAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.type] - Radar plot type. 'spiderweb', 'circle' is available.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Radar Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.circularAxis] - Circular Axis theme.
 *       @param {Object} [props.options.theme.verticalAxis] - Vertical Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var RadarChart = /*#__PURE__*/function (_Chart) {
  radarChart_inherits(RadarChart, _Chart);

  var _super = radarChart_createSuper(RadarChart);

  function RadarChart(_ref) {
    var el = _ref.el,
        options = _ref.options,
        data = _ref.data;

    radarChart_classCallCheck(this, RadarChart);

    return _super.call(this, {
      el: el,
      options: options,
      series: {
        radar: data.series
      },
      categories: data.categories,
      modules: [store_dataRange, store_scale, radialAxes]
    });
  }

  radarChart_createClass(RadarChart, [{
    key: "initialize",
    value: function initialize() {
      radarChart_get(radarChart_getPrototypeOf(RadarChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Legend);
      this.componentManager.add(RadarPlot);
      this.componentManager.add(RadialAxis);
      this.componentManager.add(RadarSeries);
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, polygon_namespaceObject, axis_namespaceObject, brushes_lineSeries_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array<number>} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData([10, 20], '6');
     */

  }, {
    key: "addData",
    value: function addData(data, category) {
      this.animationControlFlag.updating = true;
      this.resetSeries();
      this.store.dispatch('addData', {
        data: data,
        category: category
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          radar: series
        },
        categories: categories
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.index - Index of data within series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', radarChart_objectSpread(radarChart_objectSpread({}, seriesInfo), {}, {
        state: this.store.state
      }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return RadarChart;
}(Chart);


;// CONCATENATED MODULE: ./src/helpers/squarifier.ts
function squarifier_toConsumableArray(arr) { return squarifier_arrayWithoutHoles(arr) || squarifier_iterableToArray(arr) || squarifier_unsupportedIterableToArray(arr) || squarifier_nonIterableSpread(); }

function squarifier_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function squarifier_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return squarifier_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return squarifier_arrayLikeToArray(o, minLen); }

function squarifier_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function squarifier_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return squarifier_arrayLikeToArray(arr); }

function squarifier_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
















function calculateScale(values, width, height) {
  return width * height / calculator_sum(values);
}

function isVerticalStack(_ref) {
  var height = _ref.height,
      width = _ref.width;
  return height < width;
}

function selectBaseSize(baseBound) {
  return isVerticalStack(baseBound) ? baseBound.height : baseBound.width;
}

function makeBaseData(seriesItems, baseBound) {
  var width = baseBound.width,
      height = baseBound.height;
  var scale = calculateScale(pluck(seriesItems, 'data'), width, height);
  return seriesItems.map(function (seriesItem) {
    return {
      id: seriesItem.id,
      weight: seriesItem.data * scale
    };
  }).sort(function (a, b) {
    return b.weight - a.weight;
  });
}
/**
 * Calculate worst aspect ratio.
 * Referred function worst() in https://www.win.tue.nl/~vanwijk/stm.pdf
 */


function worst(total, min, max, baseSize) {
  var sumSquare = total * total;
  var sizeSquare = baseSize * baseSize;
  return Math.max(sizeSquare * max / sumSquare, sumSquare / (sizeSquare * min));
}

function changedStackDirection(total, weights, baseSize, newWeight) {
  var minWeight = Math.min.apply(Math, squarifier_toConsumableArray(weights));
  var maxWeight = Math.max.apply(Math, squarifier_toConsumableArray(weights));
  var beforeWorst = worst(total, minWeight, maxWeight, baseSize);
  var newWorst = worst(total + newWeight, Math.min(minWeight, newWeight), Math.max(maxWeight, newWeight), baseSize);
  return newWorst >= beforeWorst;
}

function calculateFixedSize(baseSize, total, rows) {
  if (!total) {
    var weights = pluck(rows, 'weight');
    total = calculator_sum(weights);
  }

  return total / baseSize;
}

function addBounds(startPosition, rows, fixedSize, callback) {
  rows.reduce(function (storedPosition, rowDatum) {
    var dynamicSize = rowDatum.weight / fixedSize;
    callback(dynamicSize, storedPosition, rowDatum.id);
    return storedPosition + dynamicSize;
  }, startPosition);
}

function addBound(boundMap, id, rect) {
  boundMap[id] = rect;
}

function addBoundsForVerticalStack(boundMap, rows, baseBound, baseSize, total) {
  var fixedWidth = calculateFixedSize(baseSize, total, rows);
  addBounds(baseBound.y, rows, fixedWidth, function (dynamicHeight, storedTop, id) {
    addBound(boundMap, id, {
      x: baseBound.x,
      y: storedTop,
      width: fixedWidth,
      height: dynamicHeight
    });
  });
  baseBound.x += fixedWidth;
  baseBound.width -= fixedWidth;
}

function addBoundsForHorizontalStack(boundMap, rows, baseBound, baseSize, total) {
  var fixedHeight = calculateFixedSize(baseSize, total, rows);
  addBounds(baseBound.x, rows, fixedHeight, function (dynamicWidth, storedLeft, id) {
    addBound(boundMap, id, {
      x: storedLeft,
      y: baseBound.y,
      width: dynamicWidth,
      height: fixedHeight
    });
  });
  baseBound.y += fixedHeight;
  baseBound.height -= fixedHeight;
}

function getAddingBoundsFunction(baseBound) {
  if (isVerticalStack(baseBound)) {
    return addBoundsForVerticalStack;
  }

  return addBoundsForHorizontalStack;
}

function squarify(layout, seriesItems) {
  var baseBound = layout;
  var baseData = makeBaseData(seriesItems, baseBound);
  var row = [];
  var baseSize, addBoundsFunc;
  var boundMap = {};
  baseData.forEach(function (datum) {
    var weights = pluck(row, 'weight');
    var totalWeight = calculator_sum(weights);

    if (row.length && changedStackDirection(totalWeight, weights, baseSize, datum.weight)) {
      addBoundsFunc(boundMap, row, baseBound, baseSize, totalWeight);
      row = [];
    }

    if (!row.length) {
      baseSize = selectBaseSize(baseBound);
      addBoundsFunc = getAddingBoundsFunction(baseBound);
    }

    row.push(datum);
  });

  if (row.length) {
    addBoundsFunc(boundMap, row, baseBound, baseSize);
  }

  return boundMap;
}
;// CONCATENATED MODULE: ./src/component/treemapSeries.ts
function treemapSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { treemapSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { treemapSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return treemapSeries_typeof(obj); }

function treemapSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function treemapSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { treemapSeries_ownKeys(Object(source), true).forEach(function (key) { treemapSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { treemapSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function treemapSeries_toConsumableArray(arr) { return treemapSeries_arrayWithoutHoles(arr) || treemapSeries_iterableToArray(arr) || treemapSeries_unsupportedIterableToArray(arr) || treemapSeries_nonIterableSpread(); }

function treemapSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function treemapSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return treemapSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return treemapSeries_arrayLikeToArray(o, minLen); }

function treemapSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function treemapSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return treemapSeries_arrayLikeToArray(arr); }

function treemapSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

























function treemapSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function treemapSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function treemapSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) treemapSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) treemapSeries_defineProperties(Constructor, staticProps); return Constructor; }

function treemapSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) treemapSeries_setPrototypeOf(subClass, superClass); }

function treemapSeries_setPrototypeOf(o, p) { treemapSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return treemapSeries_setPrototypeOf(o, p); }

function treemapSeries_createSuper(Derived) { var hasNativeReflectConstruct = treemapSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = treemapSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = treemapSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return treemapSeries_possibleConstructorReturn(this, result); }; }

function treemapSeries_possibleConstructorReturn(self, call) { if (call && (treemapSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return treemapSeries_assertThisInitialized(self); }

function treemapSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function treemapSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function treemapSeries_getPrototypeOf(o) { treemapSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return treemapSeries_getPrototypeOf(o); }

function treemapSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }











var TreemapSeries = /*#__PURE__*/function (_Component) {
  treemapSeries_inherits(TreemapSeries, _Component);

  var _super = treemapSeries_createSuper(TreemapSeries);

  function TreemapSeries() {
    var _this;

    treemapSeries_classCallCheck(this, TreemapSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "models", {
      series: [],
      layer: []
    });

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "responders", void 0);

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "theme", void 0);

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "activatedResponders", []);

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "zoomable", void 0);

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.emitMouseEvent([]);
    });

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "selectSeries", function (_ref) {
      var seriesIndex = _ref.seriesIndex;

      if (!isNumber(seriesIndex)) {
        return;
      }

      var model = _this.responders.find(function (_ref2) {
        var indexes = _ref2.indexes;
        return last(indexes) === seriesIndex;
      });

      if (!model) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      var models = _this.getRespondersWithTheme([model], 'select');

      _this.eventBus.emit('renderSelectedSeries', {
        models: models,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    treemapSeries_defineProperty(treemapSeries_assertThisInitialized(_this), "showTooltip", function (_ref3) {
      var seriesIndex = _ref3.seriesIndex;

      if (!isNumber(seriesIndex)) {
        return;
      }

      var model = _this.responders.find(function (_ref4) {
        var indexes = _ref4.indexes;
        return last(indexes) === seriesIndex;
      });

      if (model) {
        _this.emitMouseEvent([model]);
      }
    });

    return _this;
  }

  treemapSeries_createClass(TreemapSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'treemap';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "getAllChildSeries",
    value: function getAllChildSeries(series, parentId) {
      var _this2 = this;

      var allChildSeries = [];
      series.forEach(function (data) {
        if (data.parentId === parentId) {
          allChildSeries.push(data);

          if (data.hasChild) {
            var res = _this2.getAllChildSeries(series, data.id);

            allChildSeries.push.apply(allChildSeries, treemapSeries_toConsumableArray(res));
          }
        }
      });
      return allChildSeries;
    }
  }, {
    key: "render",
    value: function render(chartState) {
      var _options$series$zooma, _options$series;

      var layout = chartState.layout,
          treemapSeries = chartState.treemapSeries,
          colorValueScale = chartState.colorValueScale,
          options = chartState.options,
          theme = chartState.theme,
          treemapZoomId = chartState.treemapZoomId;

      if (!treemapSeries) {
        throw new Error(message.noDataError(this.name));
      }

      var currentTreemapZoomId = treemapZoomId.cur;
      var series = this.getAllChildSeries(treemapSeries, currentTreemapZoomId);
      this.theme = theme.series.treemap;
      this.rect = layout.plot;
      this.selectable = this.getSelectableOption(options);
      this.models = this.renderTreemapSeries(series, options, colorValueScale, currentTreemapZoomId);
      this.zoomable = (_options$series$zooma = (_options$series = options.series) === null || _options$series === void 0 ? void 0 : _options$series.zoomable) !== null && _options$series$zooma !== void 0 ? _options$series$zooma : false;

      if (getDataLabelsOptions(options, this.name).visible) {
        var _options$series$dataL, _options$series2, _options$series2$data;

        var useTreemapLeaf = (_options$series$dataL = (_options$series2 = options.series) === null || _options$series2 === void 0 ? void 0 : (_options$series2$data = _options$series2.dataLabels) === null || _options$series2$data === void 0 ? void 0 : _options$series2$data.useTreemapLeaf) !== null && _options$series$dataL !== void 0 ? _options$series$dataL : false;
        var dataLabelModel = this.makeDataLabel(useTreemapLeaf, currentTreemapZoomId);
        this.renderDataLabels(dataLabelModel);
      }

      this.responders = this.makeTreemapSeriesResponder(currentTreemapZoomId);
    }
  }, {
    key: "makeTreemapSeriesResponder",
    value: function makeTreemapSeriesResponder(treemapCurrentDepthParentId) {
      var tooltipData = this.makeTooltipData();
      var series = this.models.series;

      if (this.zoomable) {
        series = series.filter(function (_ref5) {
          var parentId = _ref5.parentId;
          return parentId === treemapCurrentDepthParentId;
        });
      }

      return series.map(function (m, idx) {
        return treemapSeries_objectSpread(treemapSeries_objectSpread({}, m), {}, {
          data: tooltipData[idx],
          thickness: boxDefault.HOVER_THICKNESS,
          style: ['shadow']
        });
      });
    }
  }, {
    key: "makeTooltipData",
    value: function makeTooltipData() {
      return this.models.series.map(function (_ref6) {
        var label = _ref6.label,
            data = _ref6.data,
            color = _ref6.color;
        return {
          label: label,
          color: color,
          value: data
        };
      });
    }
  }, {
    key: "makeBoundMap",
    value: function makeBoundMap(series, parentId, layout) {
      var _this3 = this;

      var boundMap = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var seriesItems = series.filter(function (item) {
        return item.parentId === parentId;
      });
      boundMap = treemapSeries_objectSpread(treemapSeries_objectSpread({}, boundMap), squarify(treemapSeries_objectSpread({}, layout), seriesItems));
      seriesItems.forEach(function (seriesItem) {
        boundMap = _this3.makeBoundMap(series, seriesItem.id, boundMap[seriesItem.id], boundMap);
      });
      return boundMap;
    }
  }, {
    key: "makeDataLabel",
    value: function makeDataLabel(useTreemapLeaf, treemapCurrentDepthParentId) {
      var series = useTreemapLeaf ? this.models.series.filter(function (_ref7) {
        var hasChild = _ref7.hasChild;
        return !hasChild;
      }) : this.models.series.filter(function (_ref8) {
        var parentId = _ref8.parentId;
        return parentId === treemapCurrentDepthParentId;
      });
      var dataLabelTheme = this.theme.dataLabels;
      return series.map(function (m) {
        return treemapSeries_objectSpread(treemapSeries_objectSpread({}, m), {}, {
          type: 'treemapSeriesName',
          value: m.label,
          direction: 'left',
          plot: {
            x: 0,
            y: 0,
            size: 0
          },
          theme: treemapSeries_objectSpread(treemapSeries_objectSpread({}, dataLabelTheme), {}, {
            color: dataLabelTheme.useSeriesColor ? m.color : dataLabelTheme.color
          })
        });
      });
    }
  }, {
    key: "getColor",
    value: function getColor(treemapSeries, colors) {
      var indexes = treemapSeries.indexes;
      var colorIdx = first(indexes);
      return colors[colorIdx];
    }
  }, {
    key: "getOpacity",
    value: function getOpacity(treemapSeries) {
      var indexes = treemapSeries.indexes,
          depth = treemapSeries.depth;
      var idx = last(indexes);
      return indexes.length === 1 ? 0 : Number((0.1 * depth + 0.05 * idx).toFixed(2));
    }
  }, {
    key: "renderTreemapSeries",
    value: function renderTreemapSeries(seriesData, options, colorValueScale, treemapCurrentDepthParentId) {
      var _options$series$useCo,
          _options$series3,
          _this4 = this,
          _options$series4;

      var layer = [];
      var boundMap = this.makeBoundMap(seriesData, treemapCurrentDepthParentId, treemapSeries_objectSpread(treemapSeries_objectSpread({}, this.rect), {}, {
        x: 0,
        y: 0
      }));
      var _this$theme = this.theme,
          colors = _this$theme.colors,
          startColor = _this$theme.startColor,
          endColor = _this$theme.endColor,
          borderWidth = _this$theme.borderWidth,
          borderColor = _this$theme.borderColor;
      var startRGB, distances;
      var useColorValue = (_options$series$useCo = (_options$series3 = options.series) === null || _options$series3 === void 0 ? void 0 : _options$series3.useColorValue) !== null && _options$series$useCo !== void 0 ? _options$series$useCo : false;

      if (useColorValue && startColor && endColor) {
        startRGB = hexToRGB(startColor);
        distances = makeDistances(startRGB, hexToRGB(endColor));
      }

      var series = Object.keys(boundMap).map(function (id) {
        var treemapSeries = seriesData.find(function (item) {
          return item.id === id;
        });
        var colorRatio;

        if (useColorValue) {
          colorRatio = getColorRatio(colorValueScale.limit, treemapSeries.colorValue);
        }

        return treemapSeries_objectSpread(treemapSeries_objectSpread(treemapSeries_objectSpread({}, treemapSeries), boundMap[id]), {}, {
          type: 'rect',
          colorRatio: colorRatio,
          color: useColorValue ? getSpectrumColor(colorRatio, distances, startRGB) : _this4.getColor(treemapSeries, colors),
          opacity: useColorValue ? 0 : _this4.getOpacity(treemapSeries),
          thickness: borderWidth,
          borderColor: borderColor
        });
      });

      if (!((_options$series4 = options.series) !== null && _options$series4 !== void 0 && _options$series4.useColorValue)) {
        layer = series.map(function (m) {
          return treemapSeries_objectSpread(treemapSeries_objectSpread({}, m), {}, {
            color: getRGBA('#000000', m.opacity)
          });
        });
      }

      return {
        series: series,
        layer: layer
      };
    }
  }, {
    key: "getRespondersWithTheme",
    value: function getRespondersWithTheme(responders, type) {
      var _this5 = this;

      return responders.map(function (responder) {
        return deepMergedCopy(responder, treemapSeries_objectSpread(treemapSeries_objectSpread({}, _this5.theme[type]), {}, {
          style: ['shadow']
        }));
      });
    }
  }, {
    key: "onClick",
    value: function onClick(_ref9) {
      var responders = _ref9.responders;

      if (responders.length) {
        if (this.zoomable) {
          var _responders$ = responders[0],
              id = _responders$.id,
              hasChild = _responders$.hasChild;

          if (hasChild) {
            this.emitMouseEvent([]);
            this.store.dispatch('setTreemapZoomId', id);
            this.eventBus.emit('resetSelectedSeries');
          } else if (this.selectable) {
            this.eventBus.emit('renderSelectedSeries', {
              models: this.getRespondersWithTheme(responders, 'select'),
              name: this.name
            });
          }
        } else if (this.selectable) {
          var deepestNode = getDeepestNode(responders);
          this.eventBus.emit('renderSelectedSeries', {
            models: this.getRespondersWithTheme(deepestNode, 'select'),
            name: this.name
          });
        }
      }
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref10) {
      var responders = _ref10.responders;
      var deepestNode = getDeepestNode(responders);
      this.activatedResponders = deepestNode;
      this.emitMouseEvent(deepestNode);
    }
  }, {
    key: "emitMouseEvent",
    value: function emitMouseEvent(responders) {
      this.eventBus.emit('renderHoveredSeries', {
        models: this.getRespondersWithTheme(responders, 'hover'),
        name: this.name
      });
      this.eventBus.emit('seriesPointHovered', {
        models: responders,
        name: this.name
      });
      this.eventBus.emit('renderSpectrumTooltip', responders);
      this.eventBus.emit('needDraw');
    }
  }]);

  return TreemapSeries;
}(Component);


;// CONCATENATED MODULE: ./src/component/backButton.ts
function backButton_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { backButton_typeof = function _typeof(obj) { return typeof obj; }; } else { backButton_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return backButton_typeof(obj); }














function backButton_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function backButton_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function backButton_createClass(Constructor, protoProps, staticProps) { if (protoProps) backButton_defineProperties(Constructor.prototype, protoProps); if (staticProps) backButton_defineProperties(Constructor, staticProps); return Constructor; }

function backButton_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) backButton_setPrototypeOf(subClass, superClass); }

function backButton_setPrototypeOf(o, p) { backButton_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return backButton_setPrototypeOf(o, p); }

function backButton_createSuper(Derived) { var hasNativeReflectConstruct = backButton_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = backButton_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = backButton_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return backButton_possibleConstructorReturn(this, result); }; }

function backButton_possibleConstructorReturn(self, call) { if (call && (backButton_typeof(call) === "object" || typeof call === "function")) { return call; } return backButton_assertThisInitialized(self); }

function backButton_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function backButton_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function backButton_getPrototypeOf(o) { backButton_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return backButton_getPrototypeOf(o); }

function backButton_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var BackButton = /*#__PURE__*/function (_Component) {
  backButton_inherits(BackButton, _Component);

  var _super = backButton_createSuper(BackButton);

  function BackButton() {
    var _this;

    backButton_classCallCheck(this, BackButton);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    backButton_defineProperty(backButton_assertThisInitialized(_this), "responders", void 0);

    backButton_defineProperty(backButton_assertThisInitialized(_this), "models", void 0);

    return _this;
  }

  backButton_createClass(BackButton, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'backButton';
      this.name = 'backButton';
    }
  }, {
    key: "onClick",
    value: function onClick(_ref) {
      var responders = _ref.responders;

      if (responders.length) {
        this.store.dispatch('zoomBack');
        this.eventBus.emit('resetSelectedSeries');
      }
    }
  }, {
    key: "render",
    value: function render(_ref2, computed) {
      var options = _ref2.options,
          layout = _ref2.layout;

      if (!isUsingResetButton(options)) {
        return;
      }

      this.rect = layout.resetButton;
      this.isShow = computed.isTreemapSeriesZooming;
      this.models = this.isShow ? [{
        type: 'backButton',
        x: 0,
        y: 0
      }] : [];
      this.responders = this.isShow ? [{
        type: 'rect',
        x: 0,
        y: 0,
        width: BUTTON_RECT_SIZE,
        height: BUTTON_RECT_SIZE
      }] : [];
    }
  }]);

  return BackButton;
}(Component);


;// CONCATENATED MODULE: ./src/charts/treemapChart.ts
function treemapChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { treemapChart_typeof = function _typeof(obj) { return typeof obj; }; } else { treemapChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return treemapChart_typeof(obj); }


















function treemapChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function treemapChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { treemapChart_ownKeys(Object(source), true).forEach(function (key) { treemapChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { treemapChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function treemapChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function treemapChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function treemapChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function treemapChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) treemapChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) treemapChart_defineProperties(Constructor, staticProps); return Constructor; }

function treemapChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { treemapChart_get = Reflect.get; } else { treemapChart_get = function _get(target, property, receiver) { var base = treemapChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return treemapChart_get(target, property, receiver || target); }

function treemapChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = treemapChart_getPrototypeOf(object); if (object === null) break; } return object; }

function treemapChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) treemapChart_setPrototypeOf(subClass, superClass); }

function treemapChart_setPrototypeOf(o, p) { treemapChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return treemapChart_setPrototypeOf(o, p); }

function treemapChart_createSuper(Derived) { var hasNativeReflectConstruct = treemapChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = treemapChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = treemapChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return treemapChart_possibleConstructorReturn(this, result); }; }

function treemapChart_possibleConstructorReturn(self, call) { if (call && (treemapChart_typeof(call) === "object" || typeof call === "function")) { return call; } return treemapChart_assertThisInitialized(self); }

function treemapChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function treemapChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function treemapChart_getPrototypeOf(o) { treemapChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return treemapChart_getPrototypeOf(o); }























/**
 * @class
 * @classdesc Treemap Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Treemap Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.label - Data name.
 *       @param {number} [props.data.series.data] - data value.
 *       @param {number} [props.data.series.colorValue] - color value. If you use the useColorValue option, the color is painted based on this value.
 *       @param {Array<Object>} [props.data.series.children] - Child element value.
 *   @param {Object} [props.options] - Options for making Treemap Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {boolean} [props.options.series.useColorValue] - Whether to use color value or not.
 *       @param {boolean} [props.options.series.zoomable] - Whether to use zoom feature or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {boolean} [props.options.legend.visible=false] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Treemap Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var TreemapChart = /*#__PURE__*/function (_Chart) {
  treemapChart_inherits(TreemapChart, _Chart);

  var _super = treemapChart_createSuper(TreemapChart);

  function TreemapChart(props) {
    treemapChart_classCallCheck(this, TreemapChart);

    return _super.call(this, {
      el: props.el,
      options: props.options,
      series: {
        treemap: props.data.series
      },
      modules: [store_treemapSeriesData, store_colorValueScale]
    });
  }

  treemapChart_createClass(TreemapChart, [{
    key: "initialize",
    value: function initialize() {
      treemapChart_get(treemapChart_getPrototypeOf(TreemapChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(SpectrumLegend);
      this.componentManager.add(TreemapSeries);
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(DataLabels);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(BackButton);
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, dataLabel_namespaceObject, spectrumLegend_namespaceObject, brushes_resetButton_namespaceObject]);
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<Object>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   label: 'Documents',
     *   children: [
     *     {label: 'A', data: 20},
     *     {label: 'B', data: 40},
     *   ],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data, dataInfo) {
      this.resetSeries();
      this.store.dispatch('addTreemapSeries', treemapChart_objectSpread({
        data: data
      }, dataInfo));
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData(
     *   series: [
     *     {
     *       label: 'Documents',
     *       children: [
     *         {label: 'A', data: 20},
     *         {label: 'B', data: 40},
     *       ],
     *     },
     *     {
     *       label: 'Documents',
     *       data: 30,
     *     }
     *   ]
     * );
     */

  }, {
    key: "setData",
    value: function setData(data) {
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          treemap: data.series
        }
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     * @api
     * @example
     * chart.showTooltip({seriesIndex: 1});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', treemapChart_objectSpread(treemapChart_objectSpread({}, seriesInfo), {}, {
        state: this.store.state
      }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return TreemapChart;
}(Chart);


;// CONCATENATED MODULE: ./src/component/boxPlotSeries.ts
function boxPlotSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { boxPlotSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { boxPlotSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return boxPlotSeries_typeof(obj); }

function boxPlotSeries_toConsumableArray(arr) { return boxPlotSeries_arrayWithoutHoles(arr) || boxPlotSeries_iterableToArray(arr) || boxPlotSeries_unsupportedIterableToArray(arr) || boxPlotSeries_nonIterableSpread(); }

function boxPlotSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function boxPlotSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function boxPlotSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return boxPlotSeries_arrayLikeToArray(arr); }

function boxPlotSeries_slicedToArray(arr, i) { return boxPlotSeries_arrayWithHoles(arr) || boxPlotSeries_iterableToArrayLimit(arr, i) || boxPlotSeries_unsupportedIterableToArray(arr, i) || boxPlotSeries_nonIterableRest(); }

function boxPlotSeries_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function boxPlotSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return boxPlotSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return boxPlotSeries_arrayLikeToArray(o, minLen); }

function boxPlotSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function boxPlotSeries_iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function boxPlotSeries_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function boxPlotSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function boxPlotSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { boxPlotSeries_ownKeys(Object(source), true).forEach(function (key) { boxPlotSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { boxPlotSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }























function boxPlotSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function boxPlotSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function boxPlotSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) boxPlotSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) boxPlotSeries_defineProperties(Constructor, staticProps); return Constructor; }

function boxPlotSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) boxPlotSeries_setPrototypeOf(subClass, superClass); }

function boxPlotSeries_setPrototypeOf(o, p) { boxPlotSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return boxPlotSeries_setPrototypeOf(o, p); }

function boxPlotSeries_createSuper(Derived) { var hasNativeReflectConstruct = boxPlotSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = boxPlotSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = boxPlotSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return boxPlotSeries_possibleConstructorReturn(this, result); }; }

function boxPlotSeries_possibleConstructorReturn(self, call) { if (call && (boxPlotSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return boxPlotSeries_assertThisInitialized(self); }

function boxPlotSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function boxPlotSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function boxPlotSeries_getPrototypeOf(o) { boxPlotSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return boxPlotSeries_getPrototypeOf(o); }

function boxPlotSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








var MIN_BAR_WIDTH = 5;

function getPadding(tickDistance, barWidth, seriesLength) {
  return (tickDistance - barWidth * seriesLength) / (seriesLength + 1);
}

function getDefaultColor(defaultColor, color) {
  return color !== null && color !== void 0 ? color : defaultColor;
}

var BoxPlotSeries = /*#__PURE__*/function (_Component) {
  boxPlotSeries_inherits(BoxPlotSeries, _Component);

  var _super = boxPlotSeries_createSuper(BoxPlotSeries);

  function BoxPlotSeries() {
    var _this;

    boxPlotSeries_classCallCheck(this, BoxPlotSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "models", {
      rect: [],
      line: [],
      circle: []
    });

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "drawModels", void 0);

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "responders", void 0);

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "activatedResponders", []);

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "eventDetectType", 'point');

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "tooltipRectMap", void 0);

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "theme", void 0);

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.eventBus.emit('needDraw');
    });

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "selectSeries", function (_ref) {
      var index = _ref.index,
          seriesIndex = _ref.seriesIndex,
          state = _ref.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var name = state.series.boxPlot[seriesIndex].name;

      var models = _this.getRespondersWithTheme(_this.tooltipRectMap["".concat(name, "-").concat(index)], 'select');

      _this.eventBus.emit('renderSelectedSeries', {
        models: models,
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.eventBus.emit('needDraw');
    });

    boxPlotSeries_defineProperty(boxPlotSeries_assertThisInitialized(_this), "showTooltip", function (_ref2) {
      var index = _ref2.index,
          seriesIndex = _ref2.seriesIndex,
          state = _ref2.state;

      if (!isNumber(index) || !isNumber(seriesIndex)) {
        return;
      }

      var name = state.series.boxPlot[seriesIndex].name;

      var models = _this.getRespondersWithTheme(_this.tooltipRectMap["".concat(name, "-").concat(index)], 'hover');

      _this.eventBus.emit('renderHoveredSeries', {
        models: models,
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.activatedResponders = models;

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  boxPlotSeries_createClass(BoxPlotSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'boxPlot';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "render",
    value: function render(state) {
      var _options$series;

      var layout = state.layout,
          axes = state.axes,
          series = state.series,
          scale = state.scale,
          legend = state.legend,
          options = state.options,
          theme = state.theme;

      if (!series.boxPlot) {
        throw new Error(message.noDataError(this.name));
      }

      if (options !== null && options !== void 0 && (_options$series = options.series) !== null && _options$series !== void 0 && _options$series.eventDetectType) {
        this.eventDetectType = options.series.eventDetectType;
      }

      this.theme = theme.series.boxPlot;
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      var categories = state.categories;
      var tickDistance = axes.xAxis.tickDistance;
      var _limit = scale.yAxis.limit,
          min = _limit.min,
          max = _limit.max;
      var boxPlotData = series.boxPlot.data;
      var seriesLength = boxPlotData.length;

      var renderOptions = boxPlotSeries_objectSpread({
        ratio: this.rect.height / (max - min),
        tickDistance: tickDistance
      }, this.getBarWidths(tickDistance, seriesLength));

      var boxPlotModelData = this.makeBoxPlots(boxPlotData, renderOptions);
      var seriesModels = this.renderSeriesModels(boxPlotModelData);
      this.models = seriesModels;

      if (!this.drawModels) {
        this.drawModels = {
          rect: seriesModels.rect.map(function (m) {
            return boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, m), {}, {
              y: m.y + m.height,
              height: 0
            });
          }),
          line: seriesModels.line,
          circle: seriesModels.circle
        };
      }

      var tooltipData = this.makeTooltipModel(boxPlotData, categories);
      this.tooltipRectMap = this.makeTooltipRectMap(boxPlotModelData, tooltipData);
      this.responders = this.eventDetectType === 'grouped' ? this.makeGroupedResponderModel(boxPlotModelData) : this.makeDefaultResponderModel(boxPlotModelData, tooltipData);
    }
  }, {
    key: "makeTooltipRectMap",
    value: function makeTooltipRectMap(boxPlotModelData, tooltipData) {
      var _this2 = this;

      var result = {};
      boxPlotModelData.forEach(function (m, tooltipIndex) {
        if (!isNull(m)) {
          var propName = "".concat(m.name, "-").concat(m.index);

          if (!result[propName]) {
            result[propName] = [];
          }

          result[propName].push(boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, _this2.makeHoveredModel(m)), {}, {
            data: tooltipData[tooltipIndex]
          }));
        }
      });
      return result;
    }
  }, {
    key: "makeGroupedResponderModel",
    value: function makeGroupedResponderModel(boxPlotModelData) {
      var _this3 = this;

      var result = [];
      boxPlotModelData.forEach(function (m) {
        var type = m.type,
            index = m.index,
            name = m.name;
        var propName = "".concat(name, "-").concat(index);

        if (type === 'boxPlot' && !result[propName]) {
          var _ref3 = m,
              boxPlotDetection = _ref3.boxPlotDetection;
          result.push(boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({
            type: 'rect',
            name: propName
          }, boxPlotDetection), {}, {
            y: 0,
            height: _this3.rect.height
          }));
        }
      });
      return result;
    }
  }, {
    key: "makeDefaultResponderModel",
    value: function makeDefaultResponderModel(boxPlotModelData, tooltipDataArr) {
      var _this4 = this;

      return boxPlotModelData.map(function (m, index) {
        return boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, _this4.makeHoveredModel(m)), {}, {
          data: tooltipDataArr[index],
          color: getRGBA(m.color, 1)
        });
      });
    }
  }, {
    key: "makeHoveredModel",
    value: function makeHoveredModel(model) {
      var point = model.type === 'boxPlot' && model.rect ? {
        x: model.rect.x,
        y: model.rect.y
      } : {
        x: model.x,
        y: model.y
      };

      var hoveredModel = boxPlotSeries_objectSpread({}, model);

      if (model.type === 'boxPlot') {
        ['lowerWhisker', 'upperWhisker', 'maximum', 'minimum', 'median'].forEach(function (prop) {
          if (model[prop]) {
            model[prop].detectionSize = 3;
          }
        });
        model.color = getRGBA(hoveredModel.color, 1);
      }

      return boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, hoveredModel), point);
    }
  }, {
    key: "getResponderModelFromMap",
    value: function getResponderModelFromMap(responders) {
      if (!responders.length) {
        return [];
      }

      var propName = responders[0].name;
      return this.tooltipRectMap[propName];
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref4) {
      var responders = _ref4.responders;

      if (this.eventDetectType === 'grouped') {
        var models = this.getResponderModelFromMap(responders);
        this.eventBus.emit('renderHoveredSeries', {
          models: this.getRespondersWithTheme(models, 'select'),
          name: this.name,
          eventDetectType: this.eventDetectType
        });
        this.activatedResponders = models;
      } else {
        this.eventBus.emit('renderHoveredSeries', {
          models: this.getRespondersWithTheme(responders, 'hover'),
          name: this.name,
          eventDetectType: this.eventDetectType
        });
        this.activatedResponders = responders;
      }

      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "onClick",
    value: function onClick(_ref5) {
      var responders = _ref5.responders;

      if (this.selectable) {
        var models;

        if (this.eventDetectType === 'grouped') {
          models = this.getRespondersWithTheme(this.getResponderModelFromMap(responders), 'select');
        } else {
          models = this.getRespondersWithTheme(responders, 'select');
        }

        this.eventBus.emit('renderSelectedSeries', {
          models: models,
          name: this.name,
          eventDetectType: this.eventDetectType
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "renderSeriesModels",
    value: function renderSeriesModels(boxPlots) {
      return boxPlots.reduce(function (acc, cur) {
        var type = cur.type,
            name = cur.name;

        if (type === 'boxPlot') {
          acc.rect.push(boxPlotSeries_objectSpread({
            name: name
          }, cur.rect));
          ['maximum', 'minimum', 'median', 'upperWhisker', 'lowerWhisker'].forEach(function (prop) {
            acc.line.push(boxPlotSeries_objectSpread({
              name: name
            }, cur[prop]));
          });
        } else {
          acc.circle.push(boxPlotSeries_objectSpread({}, cur));
        }

        return acc;
      }, {
        rect: [],
        line: [],
        circle: []
      });
    }
  }, {
    key: "makeBoxPlots",
    value: function makeBoxPlots(seriesData, renderOptions) {
      var _this5 = this;

      var ratio = renderOptions.ratio,
          barWidth = renderOptions.barWidth;
      var boxPlotModels = [];
      var seriesLength = seriesData.length;
      var dot = this.theme.dot;
      seriesData.forEach(function (_ref6, seriesIndex) {
        var outliers = _ref6.outliers,
            data = _ref6.data,
            name = _ref6.name,
            color = _ref6.color;

        var seriesColor = _this5.getSeriesColor(name, color);

        (data !== null && data !== void 0 ? data : []).forEach(function (datum, dataIndex) {
          if (!isNull(datum)) {
            var startX = _this5.getStartX(seriesIndex, dataIndex, renderOptions, seriesLength);

            var rect = _this5.getRect(datum, startX, seriesColor, renderOptions);

            boxPlotModels.push(boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({
              type: 'boxPlot',
              color: seriesColor,
              name: name,
              rect: rect,
              median: _this5.getMedian(datum, startX, seriesColor, renderOptions),
              minimum: _this5.getMinimum(datum, startX, seriesColor, renderOptions),
              maximum: _this5.getMaximum(datum, startX, seriesColor, renderOptions)
            }, _this5.getWhisker(datum, startX, seriesColor, renderOptions, rect)), {}, {
              index: dataIndex,
              boxPlotDetection: {
                x: startX,
                width: barWidth
              }
            }));
          }
        });
        var _ref7 = dot,
            dotColor = _ref7.color,
            radius = _ref7.radius,
            borderColor = _ref7.borderColor,
            borderWidth = _ref7.borderWidth,
            useSeriesColor = _ref7.useSeriesColor;
        (outliers !== null && outliers !== void 0 ? outliers : []).forEach(function (datum) {
          var _datum = boxPlotSeries_slicedToArray(datum, 2),
              dataIndex = _datum[0],
              value = _datum[1];

          var startX = _this5.getStartX(seriesIndex, dataIndex, renderOptions, seriesLength);

          boxPlotModels.push({
            type: 'circle',
            name: name,
            x: startX + barWidth / 2,
            y: _this5.getYPos(value, ratio),
            radius: radius,
            style: [{
              strokeStyle: borderColor !== null && borderColor !== void 0 ? borderColor : seriesColor,
              lineWidth: borderWidth
            }],
            color: useSeriesColor ? seriesColor : dotColor,
            index: dataIndex
          });
        });
      });
      return boxPlotModels;
    }
  }, {
    key: "makeTooltipModel",
    value: function makeTooltipModel(seriesData, categories) {
      var tooltipData = [];
      seriesData.forEach(function (_ref8) {
        var outliers = _ref8.outliers,
            data = _ref8.data,
            name = _ref8.name,
            color = _ref8.color;
        (data !== null && data !== void 0 ? data : []).forEach(function (datum, dataIndex) {
          if (!isNull(datum)) {
            var boxPlotData = boxPlotSeries_toConsumableArray(datum).reverse();

            tooltipData.push({
              label: name,
              color: color,
              value: ['Maximum', 'Upper Quartile', 'Median', 'Lower Quartile', 'Minimum'].reduce(function (acc, title, index) {
                var value = boxPlotData[index];
                return isNull(value) ? acc : [].concat(boxPlotSeries_toConsumableArray(acc), [{
                  title: title,
                  value: value
                }]);
              }, []),
              category: categories[dataIndex],
              templateType: 'boxPlot'
            });
          }
        });
        (outliers !== null && outliers !== void 0 ? outliers : []).forEach(function (datum) {
          if (!isNull(datum)) {
            var _datum2 = boxPlotSeries_slicedToArray(datum, 2),
                dataIndex = _datum2[0],
                dataValue = _datum2[1];

            tooltipData.push({
              label: name,
              color: color,
              value: [{
                title: 'Outlier',
                value: dataValue
              }],
              category: categories[dataIndex],
              templateType: 'boxPlot'
            });
          }
        });
      });
      return tooltipData;
    }
  }, {
    key: "getStartX",
    value: function getStartX(seriesIndex, dataIndex, renderOptions, seriesLength) {
      var tickDistance = renderOptions.tickDistance,
          barWidth = renderOptions.barWidth;
      var padding = getPadding(tickDistance, barWidth, seriesLength);
      return dataIndex * tickDistance + (seriesIndex + 1) * padding + barWidth * seriesIndex;
    }
  }, {
    key: "getYPos",
    value: function getYPos(value, ratio, lineWidth) {
      return isNumber(lineWidth) ? crispPixel(this.rect.height - value * ratio, lineWidth) : this.rect.height - value * ratio;
    }
  }, {
    key: "getBarWidths",
    value: function getBarWidths(tickDistance, seriesLength) {
      var _this$theme = this.theme,
          barThemeWidth = _this$theme.barWidth,
          barWidthRatios = _this$theme.barWidthRatios;
      var barRatio = barWidthRatios.barRatio,
          minMaxBarRatio = barWidthRatios.minMaxBarRatio;
      var defaultBarWidth = Math.max((tickDistance - getBoxTypeSeriesPadding(tickDistance) * (2 + (seriesLength - 1))) / seriesLength, MIN_BAR_WIDTH);
      var barWidth = barThemeWidth ? calculateSizeWithPercentString(tickDistance / seriesLength, barThemeWidth) : defaultBarWidth;
      return {
        barWidth: barWidth * barRatio,
        minMaxBarWidth: barWidth * minMaxBarRatio
      };
    }
  }, {
    key: "getRespondersWithTheme",
    value: function getRespondersWithTheme(responders, type) {
      var _this$theme$type = this.theme[type],
          color = _this$theme$type.color,
          rect = _this$theme$type.rect,
          dot = _this$theme$type.dot,
          line = _this$theme$type.line,
          shadowColor = _this$theme$type.shadowColor,
          shadowOffsetX = _this$theme$type.shadowOffsetX,
          shadowOffsetY = _this$theme$type.shadowOffsetY,
          shadowBlur = _this$theme$type.shadowBlur;
      var _ref9 = line,
          whisker = _ref9.whisker,
          median = _ref9.median,
          maximum = _ref9.maximum,
          minimum = _ref9.minimum;
      var _ref10 = dot,
          dotColor = _ref10.color,
          radius = _ref10.radius,
          borderColor = _ref10.borderColor,
          borderWidth = _ref10.borderWidth,
          useSeriesColor = _ref10.useSeriesColor;
      return responders.map(function (m) {
        var modelType = m.type,
            data = m.data;
        var seriesColor = m.color;
        var model;

        if (modelType === 'circle') {
          seriesColor = data.color;
          model = boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, m), {}, {
            radius: radius,
            color: useSeriesColor ? seriesColor : dotColor,
            style: [{
              strokeStyle: getDefaultColor(seriesColor, borderColor),
              lineWidth: borderWidth
            }]
          });
        } else {
          var _ref11 = m,
              seriesRect = _ref11.rect,
              upperWhisker = _ref11.upperWhisker,
              lowerWhisker = _ref11.lowerWhisker,
              seriesMedian = _ref11.median,
              seriesMaximum = _ref11.maximum,
              seriesMinimum = _ref11.minimum;
          model = boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, m), {}, {
            rect: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, seriesRect), {}, {
              color: color !== null && color !== void 0 ? color : getRGBA(seriesColor, 1),
              thickness: rect.borderWidth,
              borderColor: rect.borderColor,
              style: [{
                shadowColor: shadowColor,
                shadowOffsetX: shadowOffsetX,
                shadowOffsetY: shadowOffsetY,
                shadowBlur: shadowBlur
              }]
            }),
            upperWhisker: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, upperWhisker), {}, {
              strokeStyle: getDefaultColor(seriesColor, whisker.color),
              lineWidth: whisker.lineWidth
            }),
            lowerWhisker: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, lowerWhisker), {}, {
              strokeStyle: getDefaultColor(seriesColor, whisker.color),
              lineWidth: whisker.lineWidth
            }),
            median: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, seriesMedian), {}, {
              strokeStyle: getDefaultColor(seriesColor, median.color),
              lineWidth: median.lineWidth
            }),
            maximum: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, seriesMaximum), {}, {
              strokeStyle: getDefaultColor(seriesColor, maximum.color),
              lineWidth: maximum.lineWidth
            }),
            minimum: boxPlotSeries_objectSpread(boxPlotSeries_objectSpread({}, seriesMinimum), {}, {
              strokeStyle: getDefaultColor(seriesColor, minimum.color),
              lineWidth: minimum.lineWidth
            })
          });
        }

        return model;
      });
    }
  }, {
    key: "getRect",
    value: function getRect(datum, startX, seriesColor, _ref12) {
      var barWidth = _ref12.barWidth,
          ratio = _ref12.ratio;
      var rect = this.theme.rect;

      var _datum3 = boxPlotSeries_slicedToArray(datum, 4),
          lowerQuartile = _datum3[1],
          highQuartile = _datum3[3];

      return {
        type: 'rect',
        x: startX,
        y: this.getYPos(highQuartile, ratio),
        width: barWidth,
        height: (highQuartile - lowerQuartile) * ratio,
        thickness: rect.borderWidth,
        borderColor: rect.borderColor,
        color: seriesColor
      };
    }
  }, {
    key: "getWhisker",
    value: function getWhisker(datum, startX, seriesColor, _ref13, rect) {
      var barWidth = _ref13.barWidth,
          ratio = _ref13.ratio;

      var _datum4 = boxPlotSeries_slicedToArray(datum, 5),
          minimum = _datum4[0],
          maximum = _datum4[4];

      var _ref14 = this.theme.line.whisker,
          lineWidth = _ref14.lineWidth,
          color = _ref14.color;
      var x = crispPixel(startX + barWidth / 2, lineWidth);
      return {
        upperWhisker: {
          type: 'line',
          x: x,
          y: this.getYPos(maximum, ratio, lineWidth),
          x2: x,
          y2: rect.y,
          strokeStyle: color !== null && color !== void 0 ? color : seriesColor,
          lineWidth: lineWidth
        },
        lowerWhisker: {
          type: 'line',
          x: x,
          y: this.getYPos(minimum, ratio, lineWidth),
          x2: x,
          y2: crispPixel(rect.y + rect.height, lineWidth),
          strokeStyle: color !== null && color !== void 0 ? color : seriesColor,
          lineWidth: lineWidth
        }
      };
    }
  }, {
    key: "getMedian",
    value: function getMedian(datum, startX, seriesColor, _ref15) {
      var barWidth = _ref15.barWidth,
          ratio = _ref15.ratio;
      var median = datum[2];
      var _ref16 = this.theme.line.median,
          lineWidth = _ref16.lineWidth,
          color = _ref16.color;
      return {
        type: 'line',
        x: crispPixel(startX, lineWidth),
        y: this.getYPos(median, ratio, lineWidth),
        x2: crispPixel(startX + barWidth, lineWidth),
        y2: this.getYPos(median, ratio, lineWidth),
        strokeStyle: color !== null && color !== void 0 ? color : seriesColor,
        lineWidth: lineWidth
      };
    }
  }, {
    key: "getMinimum",
    value: function getMinimum(datum, startX, seriesColor, _ref17) {
      var barWidth = _ref17.barWidth,
          ratio = _ref17.ratio,
          minMaxBarWidth = _ref17.minMaxBarWidth;
      var minimum = datum[0];
      var _ref18 = this.theme.line.minimum,
          lineWidth = _ref18.lineWidth,
          color = _ref18.color;
      return {
        type: 'line',
        x: crispPixel(startX + (barWidth - minMaxBarWidth) / 2, lineWidth),
        y: this.getYPos(minimum, ratio, lineWidth),
        x2: crispPixel(startX + (barWidth - minMaxBarWidth) / 2 + minMaxBarWidth, lineWidth),
        y2: this.getYPos(minimum, ratio, lineWidth),
        strokeStyle: color !== null && color !== void 0 ? color : seriesColor,
        lineWidth: lineWidth
      };
    }
  }, {
    key: "getMaximum",
    value: function getMaximum(datum, startX, seriesColor, _ref19) {
      var barWidth = _ref19.barWidth,
          ratio = _ref19.ratio,
          minMaxBarWidth = _ref19.minMaxBarWidth;
      var maximum = datum[4];
      var _ref20 = this.theme.line.maximum,
          lineWidth = _ref20.lineWidth,
          color = _ref20.color;
      return {
        type: 'line',
        x: crispPixel(startX + (barWidth - minMaxBarWidth) / 2, lineWidth),
        y: this.getYPos(maximum, ratio, lineWidth),
        x2: crispPixel(startX + (barWidth - minMaxBarWidth) / 2 + minMaxBarWidth, lineWidth),
        y2: this.getYPos(maximum, ratio, lineWidth),
        strokeStyle: color !== null && color !== void 0 ? color : seriesColor,
        lineWidth: lineWidth
      };
    }
  }, {
    key: "getSeriesColor",
    value: function getSeriesColor(seriesName, seriesColor) {
      var _this$theme2 = this.theme,
          select = _this$theme2.select,
          areaOpacity = _this$theme2.areaOpacity;
      var active = this.activeSeriesMap[seriesName];
      var selected = Object.values(this.activeSeriesMap).some(function (elem) {
        return !elem;
      });
      var selectedOpacity = active ? select.areaOpacity : select.restSeries.areaOpacity;
      var opacity = selected ? selectedOpacity : areaOpacity;
      return getRGBA(seriesColor, opacity);
    }
  }]);

  return BoxPlotSeries;
}(Component);


;// CONCATENATED MODULE: ./src/brushes/boxPlot.ts







function boxPlot_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function boxPlot_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { boxPlot_ownKeys(Object(source), true).forEach(function (key) { boxPlot_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { boxPlot_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function boxPlot_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


function boxPlot(ctx, model) {
  var rectModel = model.rect,
      upperWhisker = model.upperWhisker,
      lowerWhisker = model.lowerWhisker,
      median = model.median,
      minimum = model.minimum,
      maximum = model.maximum;

  if (minimum) {
    line(ctx, boxPlot_objectSpread({
      type: 'line'
    }, minimum));
  }

  if (lowerWhisker) {
    line(ctx, boxPlot_objectSpread({
      type: 'line'
    }, lowerWhisker));
  }

  if (rectModel) {
    rect(ctx, boxPlot_objectSpread({
      type: 'rect'
    }, rectModel));
  }

  if (upperWhisker) {
    line(ctx, boxPlot_objectSpread({
      type: 'line'
    }, upperWhisker));
  }

  if (maximum) {
    line(ctx, boxPlot_objectSpread({
      type: 'line'
    }, maximum));
  }

  if (median) {
    line(ctx, boxPlot_objectSpread({
      type: 'line'
    }, median));
  }
}
;// CONCATENATED MODULE: ./src/charts/boxPlotChart.ts
function boxPlotChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { boxPlotChart_typeof = function _typeof(obj) { return typeof obj; }; } else { boxPlotChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return boxPlotChart_typeof(obj); }


















function boxPlotChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function boxPlotChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { boxPlotChart_ownKeys(Object(source), true).forEach(function (key) { boxPlotChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { boxPlotChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function boxPlotChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function boxPlotChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function boxPlotChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function boxPlotChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) boxPlotChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) boxPlotChart_defineProperties(Constructor, staticProps); return Constructor; }

function boxPlotChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { boxPlotChart_get = Reflect.get; } else { boxPlotChart_get = function _get(target, property, receiver) { var base = boxPlotChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return boxPlotChart_get(target, property, receiver || target); }

function boxPlotChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = boxPlotChart_getPrototypeOf(object); if (object === null) break; } return object; }

function boxPlotChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) boxPlotChart_setPrototypeOf(subClass, superClass); }

function boxPlotChart_setPrototypeOf(o, p) { boxPlotChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return boxPlotChart_setPrototypeOf(o, p); }

function boxPlotChart_createSuper(Derived) { var hasNativeReflectConstruct = boxPlotChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = boxPlotChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = boxPlotChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return boxPlotChart_possibleConstructorReturn(this, result); }; }

function boxPlotChart_possibleConstructorReturn(self, call) { if (call && (boxPlotChart_typeof(call) === "object" || typeof call === "function")) { return call; } return boxPlotChart_assertThisInitialized(self); }

function boxPlotChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function boxPlotChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function boxPlotChart_getPrototypeOf(o) { boxPlotChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return boxPlotChart_getPrototypeOf(o); }

























/**
 * @class
 * @classdesc BoxPlot Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making BoxPlot Chart.
 *     @param {Array<string>} props.data.categories - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {Array<Array<number>>} props.data.series.data - Series data.
 *       @param {Array<Array<number>>} props.data.series.outliers - Series outliers data.
 *   @param {Object} [props.options] - Options for making BoxPlot Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'grouped', 'point' is available.
 *     @param {Object} [props.options.xAxis]
 *       @param {string|Object} [props.options.xAxis.title] - Axis title.
 *       @param {boolean} [props.options.xAxis.rotateLabel=true] - Whether to allow axis label rotation.
 *       @param {boolean|Object} [props.options.xAxis.date] - Whether the x axis label is of date type. Format option used for date type. Whether the x axis label is of date type. If use date type, format option used for date type.
 *       @param {Object} [props.options.xAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.xAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.xAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.xAxis.width] - Width of xAxis.
 *       @param {number} [props.options.xAxis.height] - Height of xAxis.
 *     @param {Object} [props.options.yAxis]
 *       @param {string|Object} [props.options.yAxis.title] - Axis title.
 *       @param {Object} [props.options.yAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.yAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.yAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *       @param {number} [props.options.yAxis.width] - Width of yAxis.
 *       @param {number} [props.options.yAxis.height] - Height of yAxis.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {boolean} [props.options.plot.visible] - Whether to show plot line.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|BoxPlot Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.xAxis] - X Axis theme.
 *       @param {Object} [props.options.theme.yAxis] - Y Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.plot] - Plot theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var BoxPlotChart = /*#__PURE__*/function (_Chart) {
  boxPlotChart_inherits(BoxPlotChart, _Chart);

  var _super = boxPlotChart_createSuper(BoxPlotChart);

  function BoxPlotChart(_ref) {
    var el = _ref.el,
        options = _ref.options,
        _ref$data = _ref.data,
        series = _ref$data.series,
        categories = _ref$data.categories;

    boxPlotChart_classCallCheck(this, BoxPlotChart);

    return _super.call(this, {
      el: el,
      options: options,
      series: {
        boxPlot: series
      },
      categories: categories,
      modules: [store_dataRange, store_scale, store_axes, store_plot]
    });
  }

  boxPlotChart_createClass(BoxPlotChart, [{
    key: "initialize",
    value: function initialize() {
      boxPlotChart_get(boxPlotChart_getPrototypeOf(BoxPlotChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Plot);
      this.componentManager.add(Legend);
      this.componentManager.add(BoxPlotSeries);
      this.componentManager.add(Axis, {
        name: 'yAxis'
      });
      this.componentManager.add(Axis, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'xAxis'
      });
      this.componentManager.add(AxisTitle, {
        name: 'yAxis'
      });
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, axis_namespaceObject, boxPlot_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject]);
    }
    /**
     * Add data.
     * @param {Array<<Array<number>>} data - Array of data to be added.
     * @param {string} category - Category to be added.
     * @api
     * @example
     * chart.addData(
        [
           [3000, 4000, 4714, 6000, 7000],
           [3000, 5750, 7571, 8250, 9000],
        ],
        'newCategory'
      );
     */

  }, {
    key: "addData",
    value: function addData(data, category) {
      this.animationControlFlag.updating = true;
      this.resetSeries();
      this.store.dispatch('addData', {
        data: data,
        category: category
      });
    }
    /**
     * add outlier.
     * @param {number} seriesIndex - Index of series.
     * @param {number} outliers - Array of outlier.
     * @api
     * @example
     * chart.addOutlier(1, [[1, 10000], [3, 12000]]);
     */

  }, {
    key: "addOutlier",
    value: function addOutlier(seriesIndex, outliers) {
      this.animationControlFlag.updating = true;
      this.resetSeries();
      this.store.dispatch('addOutlier', {
        seriesIndex: seriesIndex,
        outliers: outliers
      });
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<Array<number>>} data.data - Array of data to be added.
     *   @param {Array<Array<number>>} data.outliers - Series outliers data.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [
     *     [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     *   ],
     *   outliers: [
     *     [0, 14000],
     *     [2, 10000],
     *   ]
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'newSeries',
     *       data: [
     *         [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
     *       ],
     *       outliers: [
     *         [0, 14000],
     *         [2, 10000],
     *       ]
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          boxPlot: series
        },
        categories: categories
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   xAxis: {
     *     title: 'Month',
     *     date: { format: 'yy/MM' },
     *   },
     *   yAxis: {
     *     title: 'Energy (kWh)',
     *   },
     *   series: {
     *     selectable: true,
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     height: 'auto',
     *     title: 'Energy Usage',
     *   },
     *   tooltip: {
     *     formatter: (value) => `${value}kWh`,
     *   },
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.seriesIndex - Index of series.
     *      @param {number} seriesInfo.index - Index of data within series.
     * @api
     * @example
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', boxPlotChart_objectSpread(boxPlotChart_objectSpread({}, seriesInfo), {}, {
        state: this.store.state
      }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return BoxPlotChart;
}(Chart);


;// CONCATENATED MODULE: ./src/component/radialBarSeries.ts
function radialBarSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { radialBarSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { radialBarSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return radialBarSeries_typeof(obj); }

function radialBarSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function radialBarSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { radialBarSeries_ownKeys(Object(source), true).forEach(function (key) { radialBarSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { radialBarSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function radialBarSeries_toConsumableArray(arr) { return radialBarSeries_arrayWithoutHoles(arr) || radialBarSeries_iterableToArray(arr) || radialBarSeries_unsupportedIterableToArray(arr) || radialBarSeries_nonIterableSpread(); }

function radialBarSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function radialBarSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return radialBarSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return radialBarSeries_arrayLikeToArray(o, minLen); }

function radialBarSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function radialBarSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return radialBarSeries_arrayLikeToArray(arr); }

function radialBarSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

























function radialBarSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function radialBarSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function radialBarSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) radialBarSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) radialBarSeries_defineProperties(Constructor, staticProps); return Constructor; }

function radialBarSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) radialBarSeries_setPrototypeOf(subClass, superClass); }

function radialBarSeries_setPrototypeOf(o, p) { radialBarSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return radialBarSeries_setPrototypeOf(o, p); }

function radialBarSeries_createSuper(Derived) { var hasNativeReflectConstruct = radialBarSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = radialBarSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = radialBarSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return radialBarSeries_possibleConstructorReturn(this, result); }; }

function radialBarSeries_possibleConstructorReturn(self, call) { if (call && (radialBarSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return radialBarSeries_assertThisInitialized(self); }

function radialBarSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function radialBarSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function radialBarSeries_getPrototypeOf(o) { radialBarSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return radialBarSeries_getPrototypeOf(o); }

function radialBarSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }












var RadialBarSeries = /*#__PURE__*/function (_Component) {
  radialBarSeries_inherits(RadialBarSeries, _Component);

  var _super = radialBarSeries_createSuper(RadialBarSeries);

  function RadialBarSeries() {
    var _this;

    radialBarSeries_classCallCheck(this, RadialBarSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "models", {});

    radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "drawModels", void 0);

    radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "responders", void 0);

    radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "activatedResponders", []);

    radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "eventDetectType", 'point');

    radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "tooltipSectorMap", void 0);

    radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "theme", void 0);

    radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "circularAxis", void 0);

    radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "selectSeries", function (info) {
      var _this$getResponderMod;

      var index = info.index,
          seriesIndex = info.seriesIndex;
      var isAvailable = isNumber(index) && (_this.eventDetectType === 'grouped' || isNumber(seriesIndex));

      if (!isAvailable) {
        return;
      }

      var models = _this.eventDetectType === 'grouped' ? [].concat(radialBarSeries_toConsumableArray(_this.getGroupedSector([_this.responders[index]], 'select')), radialBarSeries_toConsumableArray(_this.getRadialBarSectorModelsFromResponders([_this.responders[index]]))) : (_this$getResponderMod = _this.getResponderModelsWithTheme([_this.tooltipSectorMap[index][seriesIndex]], 'select')) !== null && _this$getResponderMod !== void 0 ? _this$getResponderMod : [];

      if (!models.length) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: models,
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.eventBus.emit('needDraw');
    });

    radialBarSeries_defineProperty(radialBarSeries_assertThisInitialized(_this), "showTooltip", function (info) {
      var index = info.index,
          seriesIndex = info.seriesIndex;

      if (!isAvailableShowTooltipInfo(info, _this.eventDetectType, 'radialBar')) {
        return;
      }

      var models = _this.eventDetectType === 'grouped' ? _this.getGroupedSector([_this.responders[index]], 'hover') : _this.getResponderModelsWithTheme([_this.tooltipSectorMap[index][seriesIndex]], 'hover');

      if (!models.length) {
        return;
      }

      _this.eventBus.emit('renderHoveredSeries', {
        models: models,
        name: _this.name,
        eventDetectType: _this.eventDetectType
      });

      _this.activatedResponders = _this.eventDetectType === 'grouped' ? _this.tooltipSectorMap[index] : models;

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  radialBarSeries_createClass(RadialBarSeries, [{
    key: "initUpdate",
    value: function initUpdate(delta) {
      var _this2 = this;

      if (!this.drawModels) {
        return;
      }

      var _this$circularAxis$an = this.circularAxis.angle,
          startAngle = _this$circularAxis$an.start,
          totalAngle = _this$circularAxis$an.total;
      var currentDegree;
      Object.keys(this.models).forEach(function (category) {
        var index = _this2.models[category].findIndex(function (_ref) {
          var clockwise = _ref.clockwise,
              _ref$degree = _ref.degree,
              start = _ref$degree.start,
              end = _ref$degree.end;
          currentDegree = clockwise ? startAngle + totalAngle * delta : startAngle - totalAngle * delta;
          return withinRadian(clockwise, start, end, currentDegree);
        });

        _this2.syncEndAngle(index < 0 ? _this2.models[category].length : index, category);

        if (index !== -1) {
          _this2.drawModels[category][index].degree.end = currentDegree;
        }
      });
    }
  }, {
    key: "syncEndAngle",
    value: function syncEndAngle(index, category) {
      if (index < 1) {
        return;
      }

      for (var i = 0; i < index; i += 1) {
        var prevTargetEndDegree = this.models[category][i].degree.end;

        if (this.drawModels[category][i].degree.end !== prevTargetEndDegree) {
          this.drawModels[category][i].degree.end = prevTargetEndDegree;
        }
      }
    }
  }, {
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'radialBar';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "render",
    value: function render(chartState) {
      var _ref2,
          _this3 = this;

      var layout = chartState.layout,
          series = chartState.series,
          legend = chartState.legend,
          options = chartState.options,
          theme = chartState.theme,
          stackSeries = chartState.stackSeries,
          scale = chartState.scale,
          radialAxes = chartState.radialAxes;
      var categories = (_ref2 = chartState.categories) !== null && _ref2 !== void 0 ? _ref2 : [];

      if (!series.radialBar || !stackSeries.radialBar) {
        throw new Error(message.noDataError(this.name));
      }

      this.theme = theme.series.radialBar;
      this.rect = layout.plot;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      this.setEventDetectType(options);
      var initialCategoryMap = categories.reduce(function (acc, category) {
        if (!acc[category]) {
          acc[category] = [];
        }

        return acc;
      }, {});
      var seriesData = series.radialBar.data;
      this.circularAxis = radialAxes.circularAxis;
      var verticalAxisData = radialAxes.verticalAxis;
      var renderOptions = this.makeRenderOptions(verticalAxisData, scale.circularAxis, options === null || options === void 0 ? void 0 : options.series);

      var _this$makeSeriesModel = this.makeSeriesModelData(seriesData, stackSeries.radialBar.stackData, renderOptions, initialCategoryMap),
          categoryMap = _this$makeSeriesModel.categoryMap,
          seriesModels = _this$makeSeriesModel.seriesModels;

      var tooltipData = this.makeTooltipData(seriesModels, categories);
      this.models = categoryMap;

      if (!this.drawModels) {
        this.initDrawModels(categoryMap);
      }

      if (getDataLabelsOptions(options, this.name).visible) {
        var dataLabelData = seriesModels.reduce(function (acc, data) {
          return [].concat(radialBarSeries_toConsumableArray(acc), [radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, data), {}, {
            type: 'sector',
            theme: _this3.theme.dataLabels
          })]);
        }, []);
        this.renderDataLabels(dataLabelData);
      }

      this.tooltipSectorMap = this.makeTooltipSectorMap(seriesModels, tooltipData);
      this.responders = this.makeResponders(verticalAxisData.radius.ranges, seriesModels, renderOptions, categories, tooltipData);
    }
  }, {
    key: "initDrawModels",
    value: function initDrawModels(categoryMap) {
      var _this4 = this;

      this.drawModels = {};
      Object.keys(categoryMap).forEach(function (category) {
        _this4.drawModels[category] = categoryMap[category].map(function (m) {
          return radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, m), {}, {
            degree: radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, m.degree), {}, {
              end: m.degree.start
            })
          });
        });
      });
    }
  }, {
    key: "makeResponders",
    value: function makeResponders(radiusRanges, seriesModels, renderOptions, categories, tooltipData) {
      return this.eventDetectType === 'grouped' ? makeGroupedSectorResponderModel(radiusRanges, renderOptions, categories) : seriesModels.map(function (m, index) {
        return radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, m), {}, {
          data: radialBarSeries_objectSpread({}, tooltipData[index])
        });
      });
    }
  }, {
    key: "makeTooltipSectorMap",
    value: function makeTooltipSectorMap(seriesModels, tooltipData) {
      return seriesModels.reduce(function (acc, cur, index) {
        var categoryIndex = cur.index;

        if (!acc[categoryIndex]) {
          acc[categoryIndex] = [];
        }

        acc[categoryIndex].push(radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, cur), {}, {
          data: radialBarSeries_objectSpread({}, tooltipData[index])
        }));
        return acc;
      }, {});
    }
  }, {
    key: "setEventDetectType",
    value: function setEventDetectType(options) {
      var _options$series;

      if (options !== null && options !== void 0 && (_options$series = options.series) !== null && _options$series !== void 0 && _options$series.eventDetectType) {
        this.eventDetectType = options.series.eventDetectType;
      }
    }
  }, {
    key: "getBarWidth",
    value: function getBarWidth(tickDistance, axisSize) {
      var barWidth = this.theme.barWidth;
      var DEFAULT_PADDING = 5;
      return barWidth ? Math.min(tickDistance, calculateSizeWithPercentString(axisSize, barWidth)) : tickDistance - DEFAULT_PADDING * 2;
    }
  }, {
    key: "makeRenderOptions",
    value: function makeRenderOptions(_ref3, scale, options) {
      var _options$clockwise;

      var axisSize = _ref3.axisSize,
          centerX = _ref3.centerX,
          centerY = _ref3.centerY,
          tickDistance = _ref3.tickDistance,
          ranges = _ref3.radius.ranges,
          _ref3$angle = _ref3.angle,
          start = _ref3$angle.start,
          end = _ref3$angle.end;
      var max = scale.limit.max,
          stepSize = scale.stepSize;
      var clockwise = (_options$clockwise = options === null || options === void 0 ? void 0 : options.clockwise) !== null && _options$clockwise !== void 0 ? _options$clockwise : true;
      var totalAngle = getTotalAngle(clockwise, start, end);
      var barWidth = this.getBarWidth(tickDistance, axisSize);
      var padding = (tickDistance - barWidth) / 2;
      var scaleMaxLimitValue = max + (totalAngle < DEGREE_360 ? DEGREE_0 : stepSize);
      return {
        clockwise: clockwise,
        centerX: centerX,
        centerY: centerY,
        radiusRanges: getRadiusRanges(ranges, padding),
        angleRange: {
          start: start,
          end: end
        },
        totalAngle: totalAngle,
        scaleMaxLimitValue: scaleMaxLimitValue,
        startAngle: start
      };
    }
  }, {
    key: "makeSeriesModelData",
    value: function makeSeriesModelData(seriesData, stackSeriesData, renderOptions, initialCategoryMap) {
      var _this5 = this;

      var clockwise = renderOptions.clockwise,
          centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          radiusRanges = renderOptions.radiusRanges,
          totalAngle = renderOptions.totalAngle,
          scaleMaxLimitValue = renderOptions.scaleMaxLimitValue,
          startAngle = renderOptions.startAngle;
      var defaultStartDegree = startAngle;
      var _this$theme = this.theme,
          lineWidth = _this$theme.lineWidth,
          strokeStyle = _this$theme.strokeStyle;
      var sectorModels = [];
      var categories = Object.keys(initialCategoryMap);
      var categoryMap = deepCopy(initialCategoryMap);
      stackSeriesData.forEach(function (_ref4, categoryIndex) {
        var values = _ref4.values;
        var _radiusRanges$categor = radiusRanges[categoryIndex],
            inner = _radiusRanges$categor.inner,
            outer = _radiusRanges$categor.outer;
        values.forEach(function (value, seriesIndex) {
          if (!isNull(value)) {
            var degree = Math.max(value / scaleMaxLimitValue * totalAngle, 1) * (clockwise ? 1 : -1);
            var prevModel = sectorModels[sectorModels.length - 1];
            var startDegree = seriesIndex && prevModel ? prevModel.degree.end : defaultStartDegree;
            var endDegree = clockwise ? Math.min(startDegree + degree, DEGREE_360) : Math.max(startDegree + degree, DEGREE_0);
            var _ref5 = seriesData[seriesIndex],
                name = _ref5.name,
                seriesColor = _ref5.color;

            var color = _this5.getSeriesColor(name, seriesColor);

            var sectorModel = {
              type: 'sector',
              name: name,
              color: color,
              x: centerX,
              y: centerY,
              degree: {
                start: startDegree,
                end: endDegree
              },
              radius: {
                inner: inner,
                outer: outer
              },
              value: value,
              style: [{
                strokeStyle: strokeStyle
              }],
              lineWidth: lineWidth,
              clockwise: clockwise,
              totalAngle: totalAngle,
              seriesColor: seriesColor,
              seriesIndex: seriesIndex,
              index: categoryIndex,
              drawingStartAngle: DEGREE_NEGATIVE_90
            };
            categoryMap[categories[categoryIndex]].push(sectorModel);
            sectorModels.push(sectorModel);
          }
        });
      });
      return {
        seriesModels: sectorModels,
        categoryMap: categoryMap
      };
    }
  }, {
    key: "getSeriesColor",
    value: function getSeriesColor(name, color) {
      var _this$theme2 = this.theme,
          select = _this$theme2.select,
          areaOpacity = _this$theme2.areaOpacity;
      var active = this.activeSeriesMap[name];
      var selected = Object.values(this.activeSeriesMap).some(function (elem) {
        return !elem;
      });
      return selected ? getRGBA(color, active ? select.areaOpacity : select.restSeries.areaOpacity) : getRGBA(color, areaOpacity);
    }
  }, {
    key: "makeTooltipData",
    value: function makeTooltipData(seriesModels, categories) {
      var tooltipData = [];
      seriesModels.forEach(function (_ref6) {
        var seriesColor = _ref6.seriesColor,
            name = _ref6.name,
            value = _ref6.value,
            index = _ref6.index;

        if (!isNull(value)) {
          tooltipData.push({
            label: name,
            color: seriesColor,
            value: value,
            category: isNumber(index) ? categories[index] : ''
          });
        }
      });
      return tooltipData;
    }
  }, {
    key: "makeTooltipResponder",
    value: function makeTooltipResponder(responders) {
      var _this6 = this;

      var categories = Object.keys(this.models);
      return responders.map(function (responder) {
        return radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, responder), getRadialAnchorPosition(makeAnchorPositionParam('center', _this6.models[categories[responder.index]].find(function (_ref7) {
          var name = _ref7.name;
          return name === responder.name;
        }))));
      });
    }
  }, {
    key: "getRadialBarSectorModelsFromResponders",
    value: function getRadialBarSectorModelsFromResponders(responders) {
      var _this$tooltipSectorMa;

      if (!responders.length) {
        return [];
      }

      return (_this$tooltipSectorMa = this.tooltipSectorMap[responders[0].index]) !== null && _this$tooltipSectorMa !== void 0 ? _this$tooltipSectorMa : [];
    }
  }, {
    key: "getGroupedSector",
    value: function getGroupedSector(responders, type) {
      var RadialBarSectorModels = this.getRadialBarSectorModelsFromResponders(responders);
      var _ref8 = this.theme[type].groupedSector,
          color = _ref8.color,
          opacity = _ref8.opacity;
      return RadialBarSectorModels.length ? responders.map(function (m) {
        return radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, m), {}, {
          color: getRGBA(color, opacity)
        });
      }) : [];
    }
  }, {
    key: "onMousemoveGroupedType",
    value: function onMousemoveGroupedType(responders) {
      var RadialBarSectorModels = this.getRadialBarSectorModelsFromResponders(responders);
      this.eventBus.emit('renderHoveredSeries', {
        models: this.getGroupedSector(responders, 'hover'),
        name: this.name,
        eventDetectType: this.eventDetectType
      });
      this.activatedResponders = RadialBarSectorModels;
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref9) {
      var responders = _ref9.responders;

      if (this.eventDetectType === 'grouped') {
        this.onMousemoveGroupedType(responders);
      } else {
        this.eventBus.emit('renderHoveredSeries', {
          models: this.getResponderModelsWithTheme(responders, 'hover'),
          name: this.name
        });
        this.activatedResponders = this.makeTooltipResponder(responders);
      }

      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name,
        eventDetectType: this.eventDetectType
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "onClick",
    value: function onClick(_ref10) {
      var responders = _ref10.responders;

      if (this.selectable) {
        var models;

        if (this.eventDetectType === 'grouped') {
          models = [].concat(radialBarSeries_toConsumableArray(this.getGroupedSector(responders, 'select')), radialBarSeries_toConsumableArray(this.getRadialBarSectorModelsFromResponders(responders)));
        } else {
          models = this.getResponderModelsWithTheme(responders, 'select');
        }

        this.eventBus.emit('renderSelectedSeries', {
          models: models,
          name: this.name,
          eventDetectType: this.eventDetectType
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "getResponderModelsWithTheme",
    value: function getResponderModelsWithTheme(responders, type) {
      var theme = this.theme[type];
      var lineWidth = theme.lineWidth;
      var isSameLineWidth = this.theme.lineWidth === lineWidth;
      var thickness = isSameLineWidth ? 0 : lineWidth * 0.5;
      return responders.map(function (m) {
        var _theme$color;

        return radialBarSeries_objectSpread(radialBarSeries_objectSpread({}, m), {}, {
          color: (_theme$color = theme === null || theme === void 0 ? void 0 : theme.color) !== null && _theme$color !== void 0 ? _theme$color : m.color,
          lineWidth: lineWidth,
          style: [pick(theme, 'strokeStyle', 'shadowBlur', 'shadowColor', 'shadowOffsetX', 'shadowOffsetY')],
          radius: {
            inner: Math.max(m.radius.inner - thickness, 0),
            outer: m.radius.outer + thickness
          }
        });
      });
    }
  }]);

  return RadialBarSeries;
}(Component);


;// CONCATENATED MODULE: ./src/charts/radialBarChart.ts
function radialBarChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { radialBarChart_typeof = function _typeof(obj) { return typeof obj; }; } else { radialBarChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return radialBarChart_typeof(obj); }


















function radialBarChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function radialBarChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { radialBarChart_ownKeys(Object(source), true).forEach(function (key) { radialBarChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { radialBarChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function radialBarChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function radialBarChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function radialBarChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function radialBarChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) radialBarChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) radialBarChart_defineProperties(Constructor, staticProps); return Constructor; }

function radialBarChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { radialBarChart_get = Reflect.get; } else { radialBarChart_get = function _get(target, property, receiver) { var base = radialBarChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return radialBarChart_get(target, property, receiver || target); }

function radialBarChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = radialBarChart_getPrototypeOf(object); if (object === null) break; } return object; }

function radialBarChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) radialBarChart_setPrototypeOf(subClass, superClass); }

function radialBarChart_setPrototypeOf(o, p) { radialBarChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return radialBarChart_setPrototypeOf(o, p); }

function radialBarChart_createSuper(Derived) { var hasNativeReflectConstruct = radialBarChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = radialBarChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = radialBarChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return radialBarChart_possibleConstructorReturn(this, result); }; }

function radialBarChart_possibleConstructorReturn(self, call) { if (call && (radialBarChart_typeof(call) === "object" || typeof call === "function")) { return call; } return radialBarChart_assertThisInitialized(self); }

function radialBarChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function radialBarChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function radialBarChart_getPrototypeOf(o) { radialBarChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return radialBarChart_getPrototypeOf(o); }


























/**
 * @class
 * @classdesc RadialBar Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making RadialBar Chart.
 *     @param {Array<string>} [props.data.categories] - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {number} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making RadialBar Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {string} [props.options.series.eventDetectType] - Event detect type. 'grouped', 'point' is available.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|DataLabels guide} on github.
 *       @param {Array<number>|Array<string>} [props.options.series.radiusRange] - Specifies the radius of the circle drawn. It is specified by entering a number or percent string value in start and end.
 *       @param {Array<number>} [props.options.series.angleRange] - The range of angles to which the circle will be drawn. It is specified by putting number in start and end.
 *       @param {boolean} [props.options.series.clockwise] - Whether it will be drawn clockwise.
 *     @param {Object} [props.options.circularAxis]
 *       @param {Object} [props.options.circularAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.circularAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.circularAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *     @param {Object} [props.options.verticalAxis]
 *       @param {Object} [props.options.verticalAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.verticalAxis.label] - Option to adjust label interval.
 *     @param {Object} [props.options.legend]
 *       @param {string} [props.options.legend.align] - Legend align. 'top', 'bottom', 'right', 'left' is available.
 *       @param {string} [props.options.legend.showCheckbox] - Whether to show checkbox.
 *       @param {boolean} [props.options.legend.visible] - Whether to show legend.
 *       @param {number} [props.options.legend.width] - Width of legend.
 *       @param {Object} [props.options.legend.item] - `width` and `overflow` options of the legend item. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Legend guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.lang] - Options for changing the text displayed on the chart or i18n languages.
 *       @param {Object} [props.options.lang.noData] - No Data Layer Text.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|RadialBar Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.noData] - No Data Layer Text theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.circularAxis] - Circular Axis theme.
 *       @param {Object} [props.options.theme.verticalAxis] - Vertical Axis theme.
 *       @param {Object} [props.options.theme.legend] - Legend theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 * @extends Chart
 */
var RadialBarChart = /*#__PURE__*/function (_Chart) {
  radialBarChart_inherits(RadialBarChart, _Chart);

  var _super = radialBarChart_createSuper(RadialBarChart);

  function RadialBarChart(_ref) {
    var el = _ref.el,
        options = _ref.options,
        data = _ref.data;

    radialBarChart_classCallCheck(this, RadialBarChart);

    return _super.call(this, {
      el: el,
      options: options,
      series: {
        radialBar: data.series
      },
      categories: data.categories,
      modules: [store_stackSeriesData, store_dataRange, store_scale, radialAxes]
    });
  }

  radialBarChart_createClass(RadialBarChart, [{
    key: "initialize",
    value: function initialize() {
      radialBarChart_get(radialBarChart_getPrototypeOf(RadialBarChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(Legend);
      this.componentManager.add(RadarPlot);
      this.componentManager.add(RadialBarSeries);
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(DataLabels);
      this.componentManager.add(RadialAxis);
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, brushes_sector_namespaceObject, dataLabel_namespaceObject, axis_namespaceObject]);
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 20, 30, 40],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          radialBar: series
        },
        categories: categories
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 500,
     *     title: 'Olympic Medals',
     *   },
     *   series: {
     *     selectable: true
     *   }
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     title: 'Olympic Medals',
     *   },
     *   series: {
     *     eventDetectType: 'grouped'
     *   }
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only index is needed.
     *      @param {number} [seriesInfo.seriesIndex] - Index of series
     * @api
     * @example
     * // eventDetectType is 'grouped'
     * chart.showTooltip({index: 1});
     *
     * // eventDetectType is 'point'
     * chart.showTooltip({index: 1, seriesIndex: 2});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', radialBarChart_objectSpread(radialBarChart_objectSpread({}, seriesInfo), {}, {
        state: this.store.state
      }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
  }]);

  return RadialBarChart;
}(Chart);


;// CONCATENATED MODULE: ./src/store/gaugeAxes.ts
function gaugeAxes_toConsumableArray(arr) { return gaugeAxes_arrayWithoutHoles(arr) || gaugeAxes_iterableToArray(arr) || gaugeAxes_unsupportedIterableToArray(arr) || gaugeAxes_nonIterableSpread(); }

function gaugeAxes_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function gaugeAxes_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return gaugeAxes_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return gaugeAxes_arrayLikeToArray(o, minLen); }

function gaugeAxes_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function gaugeAxes_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return gaugeAxes_arrayLikeToArray(arr); }

function gaugeAxes_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }



















function gaugeAxes_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function gaugeAxes_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { gaugeAxes_ownKeys(Object(source), true).forEach(function (key) { gaugeAxes_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { gaugeAxes_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function gaugeAxes_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








var DEFAULT_LABEL_PADDING = 15;
var RANGE_BAR_MARGIN = 10;
var CLOCK_HAND_MARGIN = 10;
var DATA_LABEL_MARGIN = 30;

function makeSolidData(outerRadius, barWidth, solidOptions) {
  var initialSolidOptions = solidOptions !== null && solidOptions !== void 0 ? solidOptions : false;
  var solidBarWidth = calculateSizeWithPercentString(outerRadius, barWidth);
  var defaultSolidOptions = {
    visible: true,
    radiusRange: {
      inner: outerRadius - solidBarWidth,
      outer: outerRadius
    },
    barWidth: solidBarWidth,
    clockHand: false
  };

  if (!initialSolidOptions) {
    return gaugeAxes_objectSpread(gaugeAxes_objectSpread({}, defaultSolidOptions), {}, {
      visible: false
    });
  }

  return isObject(initialSolidOptions) ? gaugeAxes_objectSpread(gaugeAxes_objectSpread({}, defaultSolidOptions), initialSolidOptions) : defaultSolidOptions;
}

function gaugeAxes_getCircularAxisData(_ref) {
  var _options$series, _options$circularAxis;

  var labels = _ref.labels,
      intervalData = _ref.intervalData,
      circularAxisLabelMargin = _ref.circularAxisLabelMargin,
      circularAxisLabelFont = _ref.circularAxisLabelFont,
      defaultAxisData = _ref.defaultAxisData,
      bandWidth = _ref.bandWidth,
      options = _ref.options,
      solidBarWidth = _ref.solidBarWidth;

  var _getMaxLabelSize = getMaxLabelSize(labels, circularAxisLabelMargin, circularAxisLabelFont),
      maxLabelWidth = _getMaxLabelSize.maxLabelWidth,
      maxLabelHeight = _getMaxLabelSize.maxLabelHeight;

  var totalAngle = defaultAxisData.totalAngle,
      axisSize = defaultAxisData.axisSize,
      centerX = defaultAxisData.centerX,
      centerY = defaultAxisData.centerY,
      startAngle = defaultAxisData.startAngle,
      endAngle = defaultAxisData.endAngle,
      drawingStartAngle = defaultAxisData.drawingStartAngle,
      clockwise = defaultAxisData.clockwise;
  var tickInterval = intervalData.tickInterval,
      labelInterval = intervalData.labelInterval;
  var outerRadius = axisSize - bandWidth - RANGE_BAR_MARGIN;
  var solidBarWidthValue = solidBarWidth !== null && solidBarWidth !== void 0 ? solidBarWidth : outerRadius * 0.1;
  var solidData = makeSolidData(outerRadius - circularAxisLabelMargin - maxLabelHeight - (circularAxisLabelMargin - 5), solidBarWidthValue, options === null || options === void 0 ? void 0 : (_options$series = options.series) === null || _options$series === void 0 ? void 0 : _options$series.solid);
  var centralAngle = totalAngle / (labels.length + (totalAngle < DEGREE_360 ? -1 : DEGREE_0));
  var maxClockHandSize = outerRadius - circularAxisLabelMargin - maxLabelHeight - CLOCK_HAND_MARGIN + (solidData.visible ? -solidData.barWidth - CLOCK_HAND_MARGIN : 0);
  return {
    axisSize: axisSize,
    centerX: centerX,
    centerY: centerY,
    label: {
      labels: labels,
      interval: labelInterval,
      margin: circularAxisLabelMargin,
      maxWidth: maxLabelWidth,
      maxHeight: maxLabelHeight
    },
    radius: {
      inner: 0,
      outer: outerRadius
    },
    angle: {
      start: startAngle,
      end: endAngle,
      total: totalAngle,
      central: centralAngle,
      drawingStart: drawingStartAngle
    },
    band: {
      width: bandWidth,
      margin: RANGE_BAR_MARGIN
    },
    tickInterval: tickInterval,
    clockwise: clockwise,
    maxClockHandSize: maxClockHandSize,
    title: makeTitleOption(options === null || options === void 0 ? void 0 : (_options$circularAxis = options.circularAxis) === null || _options$circularAxis === void 0 ? void 0 : _options$circularAxis.title),
    solidData: solidData
  };
}

function gaugeAxes_makeLabels(options, rawLabels, axisName) {
  var _options$axisName$lab, _options$axisName, _options$axisName$lab2;

  var formatter = (_options$axisName$lab = (_options$axisName = options[axisName]) === null || _options$axisName === void 0 ? void 0 : (_options$axisName$lab2 = _options$axisName.label) === null || _options$axisName$lab2 === void 0 ? void 0 : _options$axisName$lab2.formatter) !== null && _options$axisName$lab !== void 0 ? _options$axisName$lab : function (value) {
    return value;
  };
  return rawLabels.map(function (label, index) {
    return formatter(label, {
      index: index,
      labels: rawLabels,
      axisName: axisName
    });
  });
}

function gaugeAxes_getAxisLabels(isLabelOnVerticalAxis, options, categories, scale) {
  var valueAxisName = isLabelOnVerticalAxis ? RadialAxisType.CIRCULAR : RadialAxisType.VERTICAL;
  var _ref2 = scale[valueAxisName],
      limit = _ref2.limit,
      stepSize = _ref2.stepSize;
  var valueLabels = gaugeAxes_makeLabels(options, makeLabelsFromLimit(limit, stepSize), valueAxisName);
  var categoryLabels = gaugeAxes_makeLabels(options, categories, isLabelOnVerticalAxis ? RadialAxisType.VERTICAL : RadialAxisType.CIRCULAR);
  return isLabelOnVerticalAxis ? valueLabels : categoryLabels;
}

function gaugeAxes_getAxisLabelMargin(options) {
  var _options$circularAxis2, _options$circularAxis3, _options$circularAxis4;

  return (_options$circularAxis2 = options === null || options === void 0 ? void 0 : (_options$circularAxis3 = options.circularAxis) === null || _options$circularAxis3 === void 0 ? void 0 : (_options$circularAxis4 = _options$circularAxis3.label) === null || _options$circularAxis4 === void 0 ? void 0 : _options$circularAxis4.margin) !== null && _options$circularAxis2 !== void 0 ? _options$circularAxis2 : DEFAULT_LABEL_PADDING;
}

function gaugeAxes_hasAxesLayoutChanged(previousAxes, currentAxes) {
  var _previousAxes$label, _previousAxes$label2;

  var prevMaxWidth = previousAxes === null || previousAxes === void 0 ? void 0 : (_previousAxes$label = previousAxes.label) === null || _previousAxes$label === void 0 ? void 0 : _previousAxes$label.maxWidth;
  var prevMaxHeight = previousAxes === null || previousAxes === void 0 ? void 0 : (_previousAxes$label2 = previousAxes.label) === null || _previousAxes$label2 === void 0 ? void 0 : _previousAxes$label2.maxHeight;
  var curMaxWidth = currentAxes.label.maxWidth;
  var curMaxHeight = currentAxes.label.maxHeight;
  return prevMaxHeight !== curMaxHeight || prevMaxWidth !== curMaxWidth;
}

var gaugeAxes_axes = {
  name: 'gaugeAxes',
  state: function state() {
    return {
      radialAxes: {
        circularAxis: {}
      }
    };
  },
  action: {
    setCircularAxisData: function setCircularAxisData(_ref3) {
      var _options$series$dataL, _options$series2, _options$series2$data, _plot, _plot$bands, _bands$barWidth, _theme$plot, _theme$plot$bands, _theme$series$gauge, _theme$series$gauge$s, _state$radialAxes;

      var state = _ref3.state;
      var series = state.series,
          layout = state.layout,
          scale = state.scale;
      var categories = state.categories;
      var plot = layout.plot;
      var isLabelOnVerticalAxis = isLabelAxisOnYAxis({
        series: series,
        categories: categories
      });
      var options = state.options;
      var theme = state.theme;
      var circularAxisLabelFont = getTitleFontString(theme.circularAxis.label);
      var circularAxisLabelMargin = gaugeAxes_getAxisLabelMargin(options);
      var circularAxisLabels = gaugeAxes_getAxisLabels(isLabelOnVerticalAxis, options, categories, scale);

      var _getMaxLabelSize2 = getMaxLabelSize(circularAxisLabels, circularAxisLabelMargin, circularAxisLabelFont),
          maxLabelWidth = _getMaxLabelSize2.maxLabelWidth,
          maxLabelHeight = _getMaxLabelSize2.maxLabelHeight;

      var defaultAxisData = getDefaultRadialAxisData(options, plot, maxLabelWidth, maxLabelHeight, isLabelOnVerticalAxis);
      var dataLabelHeight = getFontHeight(getTitleFontString(theme.series.gauge.dataLabels));
      var dataLabelOffsetY = (_options$series$dataL = options === null || options === void 0 ? void 0 : (_options$series2 = options.series) === null || _options$series2 === void 0 ? void 0 : (_options$series2$data = _options$series2.dataLabels) === null || _options$series2$data === void 0 ? void 0 : _options$series2$data.offsetY) !== null && _options$series$dataL !== void 0 ? _options$series$dataL : DATA_LABEL_MARGIN;

      if (defaultAxisData.isSemiCircular) {
        defaultAxisData.centerY = defaultAxisData.centerY - (dataLabelOffsetY > 0 ? dataLabelOffsetY + dataLabelHeight : 0);
        var diffHeight = defaultAxisData.centerY - defaultAxisData.axisSize;
        defaultAxisData.axisSize += diffHeight < 0 ? diffHeight : 0;
      }

      var defualtBandWidth = options !== null && options !== void 0 && (_plot = options.plot) !== null && _plot !== void 0 && (_plot$bands = _plot.bands) !== null && _plot$bands !== void 0 && _plot$bands.length ? defaultAxisData.axisSize / 2 - RANGE_BAR_MARGIN : 0;
      var bandWidth = (_bands$barWidth = (_theme$plot = theme.plot) === null || _theme$plot === void 0 ? void 0 : (_theme$plot$bands = _theme$plot.bands) === null || _theme$plot$bands === void 0 ? void 0 : _theme$plot$bands.barWidth) !== null && _bands$barWidth !== void 0 ? _bands$barWidth : defualtBandWidth;
      var circularAxisData = gaugeAxes_getCircularAxisData({
        labels: circularAxisLabels,
        intervalData: getInitAxisIntervalData(true, {
          axis: options.circularAxis,
          categories: categories,
          layout: layout
        }),
        defaultAxisData: defaultAxisData,
        circularAxisLabelMargin: circularAxisLabelMargin,
        circularAxisLabelFont: circularAxisLabelFont,
        bandWidth: bandWidth,
        options: options,
        solidBarWidth: (_theme$series$gauge = theme.series.gauge) === null || _theme$series$gauge === void 0 ? void 0 : (_theme$series$gauge$s = _theme$series$gauge.solid) === null || _theme$series$gauge$s === void 0 ? void 0 : _theme$series$gauge$s.barWidth
      });

      if (gaugeAxes_hasAxesLayoutChanged((_state$radialAxes = state.radialAxes) === null || _state$radialAxes === void 0 ? void 0 : _state$radialAxes.circularAxis, circularAxisData)) {
        this.notify(state, 'layout');
      }

      state.radialAxes = {
        circularAxis: circularAxisData
      };
    },
    addGaugePlotBand: function addGaugePlotBand(_ref4, _ref5) {
      var _plot$bands2, _state$options, _state$options$plot;

      var state = _ref4.state;
      var data = _ref5.data;
      var bands = (_plot$bands2 = (_state$options = state.options) === null || _state$options === void 0 ? void 0 : (_state$options$plot = _state$options.plot) === null || _state$options$plot === void 0 ? void 0 : _state$options$plot.bands) !== null && _plot$bands2 !== void 0 ? _plot$bands2 : [];

      if (!isExistPlotId(bands, data)) {
        this.dispatch('updateOptions', {
          options: {
            plot: {
              bands: [].concat(gaugeAxes_toConsumableArray(bands), [data])
            }
          }
        });
      }
    },
    removeGaugePlotBand: function removeGaugePlotBand(_ref6, _ref7) {
      var _plot$bands3, _state$options2, _state$options2$plot;

      var state = _ref6.state;
      var id = _ref7.id;
      var bands = ((_plot$bands3 = (_state$options2 = state.options) === null || _state$options2 === void 0 ? void 0 : (_state$options2$plot = _state$options2.plot) === null || _state$options2$plot === void 0 ? void 0 : _state$options2$plot.bands) !== null && _plot$bands3 !== void 0 ? _plot$bands3 : []).filter(function (_ref8) {
        var bandId = _ref8.id;
        return bandId !== id;
      });
      this.dispatch('updateOptions', {
        options: {
          plot: {
            bands: bands
          }
        }
      });
    }
  },
  observe: {
    updateRadialAxes: function updateRadialAxes() {
      this.dispatch('setCircularAxisData');
    }
  }
};
/* harmony default export */ var gaugeAxes = (gaugeAxes_axes);
;// CONCATENATED MODULE: ./src/component/gaugeSeries.ts
function gaugeSeries_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { gaugeSeries_typeof = function _typeof(obj) { return typeof obj; }; } else { gaugeSeries_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return gaugeSeries_typeof(obj); }

function gaugeSeries_toConsumableArray(arr) { return gaugeSeries_arrayWithoutHoles(arr) || gaugeSeries_iterableToArray(arr) || gaugeSeries_unsupportedIterableToArray(arr) || gaugeSeries_nonIterableSpread(); }

function gaugeSeries_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function gaugeSeries_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return gaugeSeries_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return gaugeSeries_arrayLikeToArray(o, minLen); }

function gaugeSeries_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function gaugeSeries_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return gaugeSeries_arrayLikeToArray(arr); }

function gaugeSeries_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function gaugeSeries_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function gaugeSeries_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { gaugeSeries_ownKeys(Object(source), true).forEach(function (key) { gaugeSeries_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { gaugeSeries_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
























function gaugeSeries_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function gaugeSeries_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function gaugeSeries_createClass(Constructor, protoProps, staticProps) { if (protoProps) gaugeSeries_defineProperties(Constructor.prototype, protoProps); if (staticProps) gaugeSeries_defineProperties(Constructor, staticProps); return Constructor; }

function gaugeSeries_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) gaugeSeries_setPrototypeOf(subClass, superClass); }

function gaugeSeries_setPrototypeOf(o, p) { gaugeSeries_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return gaugeSeries_setPrototypeOf(o, p); }

function gaugeSeries_createSuper(Derived) { var hasNativeReflectConstruct = gaugeSeries_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = gaugeSeries_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = gaugeSeries_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return gaugeSeries_possibleConstructorReturn(this, result); }; }

function gaugeSeries_possibleConstructorReturn(self, call) { if (call && (gaugeSeries_typeof(call) === "object" || typeof call === "function")) { return call; } return gaugeSeries_assertThisInitialized(self); }

function gaugeSeries_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function gaugeSeries_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function gaugeSeries_getPrototypeOf(o) { gaugeSeries_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return gaugeSeries_getPrototypeOf(o); }

function gaugeSeries_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }












var DETECTION_SIZE_MARGIN = 3;

var GaugeSeries = /*#__PURE__*/function (_Component) {
  gaugeSeries_inherits(GaugeSeries, _Component);

  var _super = gaugeSeries_createSuper(GaugeSeries);

  function GaugeSeries() {
    var _this;

    gaugeSeries_classCallCheck(this, GaugeSeries);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "models", {
      clockHand: [],
      solid: [],
      backgroundSolid: []
    });

    gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "drawModels", void 0);

    gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "responders", void 0);

    gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "activatedResponders", []);

    gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "tooltipMap", void 0);

    gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "theme", void 0);

    gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "circularAxis", void 0);

    gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "onMouseoutComponent", function () {
      _this.eventBus.emit('seriesPointHovered', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('renderHoveredSeries', {
        models: [],
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "selectSeries", function (info) {
      var _this$tooltipMap$cloc;

      var index = info.index;

      if (!isNumber(index)) {
        return;
      }

      var model = (_this$tooltipMap$cloc = _this.tooltipMap.clockHand[index]) !== null && _this$tooltipMap$cloc !== void 0 ? _this$tooltipMap$cloc : _this.tooltipMap.solid[index];

      if (!model) {
        return;
      }

      var models = _this.getResponderModelsWithTheme(_this.getResponderModels([model]), 'select');

      if (!models.length) {
        throw new Error(message.SELECT_SERIES_API_INDEX_ERROR);
      }

      _this.eventBus.emit('renderSelectedSeries', {
        models: models,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    gaugeSeries_defineProperty(gaugeSeries_assertThisInitialized(_this), "showTooltip", function (info) {
      var index = info.index;

      var models = _this.getResponderModelsWithTheme([_this.tooltipMap.clockHand[index]], 'hover');

      if (!models.length) {
        return;
      }

      _this.eventBus.emit('renderHoveredSeries', {
        models: models,
        name: _this.name
      });

      _this.activatedResponders = models;

      _this.eventBus.emit('seriesPointHovered', {
        models: _this.activatedResponders,
        name: _this.name
      });

      _this.eventBus.emit('needDraw');
    });

    return _this;
  }

  gaugeSeries_createClass(GaugeSeries, [{
    key: "initialize",
    value: function initialize() {
      this.type = 'series';
      this.name = 'gauge';
      this.eventBus.on('selectSeries', this.selectSeries);
      this.eventBus.on('showTooltip', this.showTooltip);
      this.eventBus.on('hideTooltip', this.onMouseoutComponent);
    }
  }, {
    key: "initUpdate",
    value: function initUpdate(delta) {
      var _this2 = this;

      if (!this.drawModels) {
        return;
      }

      var _this$circularAxis = this.circularAxis,
          _this$circularAxis$an = _this$circularAxis.angle,
          startAngle = _this$circularAxis$an.start,
          totalAngle = _this$circularAxis$an.total,
          clockwise = _this$circularAxis.clockwise;
      var currentDegree = clockwise ? startAngle + totalAngle * delta : startAngle - totalAngle * delta;
      this.models.clockHand.forEach(function (model, index) {
        var x = model.x,
            y = model.y,
            animationDegree = model.animationDegree,
            handSize = model.handSize;

        if (clockwise && animationDegree < currentDegree || !clockwise && animationDegree > currentDegree) {
          _this2.syncEndAngle(index);

          return;
        }

        var _getRadialPosition = getRadialPosition(x, y, handSize, calculateDegreeToRadian(calculateValidAngle(currentDegree))),
            x2 = _getRadialPosition.x,
            y2 = _getRadialPosition.y;

        _this2.drawModels.clockHand[index].x2 = x2;
        _this2.drawModels.clockHand[index].y2 = y2;
      });
      this.models.solid.forEach(function () {
        var index = _this2.models.solid.findIndex(function (_ref) {
          var animationDegree = _ref.animationDegree;
          var _ref2 = animationDegree,
              start = _ref2.start,
              end = _ref2.end;
          return withinRadian(clockwise, start, end, currentDegree);
        });

        _this2.syncSectorEndAngle(index < 0 ? _this2.models.solid.length : index);

        if (index !== -1) {
          _this2.drawModels.solid[index].degree.end = calculateValidAngle(currentDegree);
        }
      });
    }
  }, {
    key: "updateModels",
    value: function updateModels(current, target, delta) {
      var total = this.circularAxis.angle.total;
      Object.keys(current).forEach(function (key) {
        if (!current || !target) {
          return;
        }

        if (key[0] !== '_') {
          if (isNumber(current[key])) {
            current[key] = current[key] + (target[key] - current[key]) * delta;
          } else if (key === 'degree') {
            if (total < DEGREE_360 && current.degree.end < DEGREE_90) {
              current[key].end = DEGREE_360 + current[key].end - (DEGREE_360 - target[key].end + current[key].end) * delta;
            } else {
              current[key].end = current[key].end + (target[key].end - current[key].end) * delta;
            }
          } else {
            current[key] = target[key];
          }
        }
      });
    }
  }, {
    key: "update",
    value: function update(delta) {
      var _this3 = this;

      this.models.clockHand.forEach(function (model, index) {
        _this3.updateModels(_this3.drawModels.clockHand[index], model, delta);
      });
      this.models.solid.forEach(function (model, index) {
        _this3.updateModels(_this3.drawModels.solid[index], model, delta);
      });
    }
  }, {
    key: "syncEndAngle",
    value: function syncEndAngle(index) {
      var model = this.models.clockHand[index];
      var drawModel = this.drawModels.clockHand[index];

      if (model.x2 !== drawModel.x2 || model.y2 !== drawModel.y2) {
        drawModel.x2 = model.x2;
        drawModel.y2 = model.y2;
      }
    }
  }, {
    key: "syncSectorEndAngle",
    value: function syncSectorEndAngle(index) {
      if (!index) {
        return;
      }

      for (var i = 0; i < index; i += 1) {
        var prevTargetEndDegree = this.models.solid[i].degree.end;

        if (this.drawModels.solid[i].degree.end !== prevTargetEndDegree) {
          this.drawModels.solid[i].degree.end = prevTargetEndDegree;
        }
      }
    }
  }, {
    key: "render",
    value: function render(chartState) {
      var _ref3;

      var layout = chartState.layout,
          series = chartState.series,
          legend = chartState.legend,
          options = chartState.options,
          theme = chartState.theme,
          scale = chartState.scale,
          radialAxes = chartState.radialAxes;
      var categories = (_ref3 = chartState.categories) !== null && _ref3 !== void 0 ? _ref3 : [];

      if (!series.gauge) {
        throw new Error(message.noDataError(this.name));
      }

      this.theme = theme.series.gauge;
      this.rect = layout.plot;
      this.circularAxis = radialAxes.circularAxis;
      this.activeSeriesMap = getActiveSeriesMap(legend);
      this.selectable = this.getSelectableOption(options);
      var seriesData = series.gauge.data;
      var hasCategoryAxis = !isLabelAxisOnYAxis({
        series: series,
        categories: categories
      });
      var renderOptions = this.makeRenderOptions(hasCategoryAxis, categories, scale, options === null || options === void 0 ? void 0 : options.series);
      var clockHandModels = this.renderClockHands(seriesData, renderOptions);
      this.models.clockHand = renderOptions.useClockHand ? clockHandModels : [];
      var solidModels = this.renderSolidModels(seriesData, clockHandModels, renderOptions);
      var tooltipData = this.makeTooltipData(clockHandModels);

      if (!this.drawModels) {
        this.initDrawModels();
      }

      if (getDataLabelsOptions(options, this.name).visible) {
        var _clockHandModels$ = clockHandModels[0],
            value = _clockHandModels$.value,
            name = _clockHandModels$.name,
            x = _clockHandModels$.x,
            y = _clockHandModels$.y,
            data = _clockHandModels$.seriesData;
        this.renderDataLabels([{
          type: 'point',
          theme: this.theme.dataLabels,
          value: value,
          name: name,
          x: x,
          y: y + DATA_LABEL_MARGIN,
          data: data
        }]);
      }

      this.tooltipMap = this.makeTooltipMap(tooltipData, renderOptions);
      this.responders = this.getResponders(clockHandModels, solidModels, tooltipData, renderOptions.useClockHand);
    }
  }, {
    key: "renderSolidModels",
    value: function renderSolidModels(seriesData, clockHandModels, renderOptions) {
      var solidModels = [];
      this.models.clockHand = renderOptions.useClockHand ? clockHandModels : [];

      if (renderOptions.solidData.visible) {
        solidModels = this.renderSectors(seriesData, renderOptions);
        this.models.backgroundSolid = this.renderBackgroundSolid(renderOptions);
        this.models.solid = solidModels;
      }

      return solidModels;
    }
  }, {
    key: "initDrawModels",
    value: function initDrawModels() {
      var start = this.circularAxis.angle.start;
      this.drawModels = {
        clockHand: this.models.clockHand.map(function (m) {
          var _getRadialPosition2 = getRadialPosition(m.x, m.y, m.handSize, calculateDegreeToRadian(start)),
              x2 = _getRadialPosition2.x,
              y2 = _getRadialPosition2.y;

          return gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, m), {}, {
            x2: x2,
            y2: y2,
            testDegree: 0
          });
        }),
        backgroundSolid: this.models.backgroundSolid,
        solid: this.models.solid.map(function (m) {
          return gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, m), {}, {
            degree: gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, m.degree), {}, {
              end: m.degree.start
            })
          });
        })
      };
    }
  }, {
    key: "getResponders",
    value: function getResponders(clockHandModels, sectorModels, tooltipData) {
      var useClockHand = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
      var clockHandResponders = !useClockHand ? [] : clockHandModels.map(function (m, index) {
        return gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, m), {}, {
          detectionSize: m.baseLine + DETECTION_SIZE_MARGIN,
          data: gaugeSeries_objectSpread({}, tooltipData[index])
        });
      });
      return sectorModels.length ? [].concat(gaugeSeries_toConsumableArray(sectorModels.map(function (m, index) {
        return gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, m), {}, {
          data: gaugeSeries_objectSpread({}, tooltipData[index])
        });
      })), gaugeSeries_toConsumableArray(clockHandResponders)) : clockHandResponders;
    }
  }, {
    key: "getHandSize",
    value: function getHandSize(size) {
      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var maxClockHandSize = this.circularAxis.maxClockHandSize;

      if (size) {
        return Array.isArray(size) ? calculateSizeWithPercentString(maxClockHandSize, size[index]) : calculateSizeWithPercentString(maxClockHandSize, size);
      }

      return maxClockHandSize;
    }
  }, {
    key: "renderClockHands",
    value: function renderClockHands(seriesData, renderOptions) {
      var _this4 = this;

      var centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          totalAngle = renderOptions.totalAngle,
          clockwise = renderOptions.clockwise,
          scaleMaxLimitValue = renderOptions.scaleMaxLimitValue,
          categories = renderOptions.categories,
          drawingStartAngle = renderOptions.drawingStartAngle;
      var seriesModels = [];
      var _this$theme$clockHand = this.theme.clockHand,
          size = _this$theme$clockHand.size,
          baseLine = _this$theme$clockHand.baseLine,
          clockHandColor = _this$theme$clockHand.color;
      var _this$theme$pin = this.theme.pin,
          radius = _this$theme$pin.radius,
          pinColor = _this$theme$pin.color,
          borderWidth = _this$theme$pin.borderWidth,
          borderColor = _this$theme$pin.borderColor;
      seriesData.forEach(function (_ref4, seriesIndex) {
        var name = _ref4.name,
            data = _ref4.data,
            color = _ref4.color;

        var seriesColor = _this4.getSeriesColor(name, color);

        data.forEach(function (value, index) {
          var val = utils_isString(value) ? categories.findIndex(function (category) {
            return category === value;
          }) : value;
          var degree = drawingStartAngle + val / scaleMaxLimitValue * totalAngle * (clockwise ? 1 : -1);
          var validDegree = calculateValidAngle(degree);

          var handSize = _this4.getHandSize(size, index);

          var _getRadialPosition3 = getRadialPosition(centerX, centerY, handSize, calculateDegreeToRadian(validDegree)),
              x2 = _getRadialPosition3.x,
              y2 = _getRadialPosition3.y;

          seriesModels.push({
            type: 'clockHand',
            color: clockHandColor !== null && clockHandColor !== void 0 ? clockHandColor : seriesColor,
            name: name,
            value: value,
            x: centerX,
            y: centerY,
            x2: x2,
            y2: y2,
            pin: {
              radius: radius,
              color: pinColor !== null && pinColor !== void 0 ? pinColor : seriesColor,
              style: [{
                strokeStyle: borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(seriesColor, 0.1),
                lineWidth: borderWidth ? borderWidth + radius : 0
              }]
            },
            degree: validDegree,
            animationDegree: degree,
            baseLine: baseLine,
            handSize: handSize,
            seriesData: data,
            index: index,
            seriesIndex: seriesIndex
          });
        });
      });
      return seriesModels;
    }
  }, {
    key: "renderBackgroundSolid",
    value: function renderBackgroundSolid(renderOptions) {
      var centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          startAngle = renderOptions.startAngle,
          totalAngle = renderOptions.totalAngle,
          clockwise = renderOptions.clockwise,
          solidData = renderOptions.solidData;
      var _ref5 = this.theme.solid.backgroundSolid,
          color = _ref5.color;
      return [{
        type: 'sector',
        color: color,
        x: centerX,
        y: centerY,
        clockwise: clockwise,
        degree: {
          start: startAngle,
          end: startAngle + totalAngle
        },
        radius: solidData.radiusRange
      }];
    }
  }, {
    key: "renderSectors",
    value: function renderSectors(seriesData, renderOptions) {
      var _this5 = this;

      var sectors = [];
      var centerX = renderOptions.centerX,
          centerY = renderOptions.centerY,
          clockwise = renderOptions.clockwise,
          totalAngle = renderOptions.totalAngle,
          scaleMaxLimitValue = renderOptions.scaleMaxLimitValue,
          startAngle = renderOptions.startAngle,
          categories = renderOptions.categories,
          solidData = renderOptions.solidData;
      var radiusRange = solidData.radiusRange;
      var _ref6 = this.theme.solid,
          lineWidth = _ref6.lineWidth,
          strokeStyle = _ref6.strokeStyle;
      seriesData.forEach(function (_ref7, index) {
        var name = _ref7.name,
            data = _ref7.data,
            color = _ref7.color;

        var seriesColor = _this5.getSeriesColor(name, color);

        var value = data[0];
        var val = utils_isString(value) ? categories.findIndex(function (category) {
          return category === value;
        }) : value;
        var degree = val / scaleMaxLimitValue * totalAngle * (clockwise ? 1 : -1);
        var validDegree = calculateValidAngle(degree);
        var startDegree = startAngle;
        var endDegree = startDegree + degree;
        var animationStartDegree = startAngle;
        var animationEndDegree = animationStartDegree + validDegree;
        sectors.push({
          type: 'sector',
          color: seriesColor,
          x: centerX,
          y: centerY,
          clockwise: clockwise,
          degree: {
            start: startDegree,
            end: endDegree
          },
          radius: radiusRange,
          animationDegree: {
            start: animationStartDegree,
            end: animationEndDegree
          },
          drawingStartAngle: DEGREE_NEGATIVE_90,
          style: [{
            strokeStyle: strokeStyle
          }],
          lineWidth: lineWidth,
          index: index
        });
      });
      return sectors;
    }
  }, {
    key: "makeTooltipMap",
    value: function makeTooltipMap(tooltipData, renderOptions) {
      var _this$models = this.models,
          clockHand = _this$models.clockHand,
          solid = _this$models.solid;
      var useClockHand = renderOptions.useClockHand;
      return tooltipData.reduce(function (acc, data, index) {
        if (useClockHand) {
          acc.clockHand.push(gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, clockHand[index]), {}, {
            detectionSize: clockHand[index].baseLine + 3,
            data: data
          }));
        }

        if (solid[index]) {
          acc.solid.push(gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, solid[index]), {}, {
            data: data
          }));
        }

        return acc;
      }, {
        solid: [],
        clockHand: []
      });
    }
  }, {
    key: "makeRenderOptions",
    value: function makeRenderOptions(hasCategoryAxis, categories, scale, options) {
      var _options$clockwise;

      var _this$circularAxis2 = this.circularAxis,
          centerX = _this$circularAxis2.centerX,
          centerY = _this$circularAxis2.centerY,
          solidData = _this$circularAxis2.solidData,
          _this$circularAxis2$a = _this$circularAxis2.angle,
          start = _this$circularAxis2$a.start,
          end = _this$circularAxis2$a.end,
          drawingStart = _this$circularAxis2$a.drawingStart,
          outer = _this$circularAxis2.radius.outer;
      var solid = this.circularAxis.solidData;
      var clockwise = (_options$clockwise = options === null || options === void 0 ? void 0 : options.clockwise) !== null && _options$clockwise !== void 0 ? _options$clockwise : true;
      var totalAngle = getTotalAngle(clockwise, start, end);
      return {
        clockwise: clockwise,
        centerX: centerX,
        centerY: centerY,
        angleRange: {
          start: start,
          end: end
        },
        totalAngle: totalAngle,
        scaleMaxLimitValue: hasCategoryAxis ? categories.length : getScaleMaxLimitValue(scale.circularAxis, totalAngle),
        startAngle: start,
        categories: categories,
        drawingStartAngle: drawingStart,
        outerRadius: outer,
        useClockHand: solid.visible ? solid.clockHand : true,
        solidData: solidData
      };
    }
  }, {
    key: "getSeriesColor",
    value: function getSeriesColor(name, color) {
      var _this$theme = this.theme,
          select = _this$theme.select,
          areaOpacity = _this$theme.areaOpacity;
      var active = this.activeSeriesMap[name];
      var selected = Object.values(this.activeSeriesMap).some(function (elem) {
        return !elem;
      });
      return selected ? getRGBA(color, active ? select.areaOpacity : select.restSeries.areaOpacity) : getRGBA(color, areaOpacity);
    }
  }, {
    key: "makeTooltipData",
    value: function makeTooltipData(seriesModels) {
      return seriesModels.reduce(function (acc, _ref8) {
        var color = _ref8.color,
            name = _ref8.name,
            value = _ref8.value,
            index = _ref8.index,
            seriesIndex = _ref8.seriesIndex;
        return isNull(value) ? acc : [].concat(gaugeSeries_toConsumableArray(acc), [{
          label: name,
          color: color,
          value: value,
          index: index,
          seriesIndex: seriesIndex
        }]);
      }, []);
    }
  }, {
    key: "onMousemove",
    value: function onMousemove(_ref9) {
      var responders = _ref9.responders;
      this.eventBus.emit('renderHoveredSeries', {
        models: this.getResponderModelsWithTheme(this.getResponderModels(responders), 'hover'),
        name: this.name
      });
      this.activatedResponders = responders.map(function (responder) {
        return gaugeSeries_objectSpread({}, responder);
      });
      this.eventBus.emit('seriesPointHovered', {
        models: this.activatedResponders,
        name: this.name
      });
      this.eventBus.emit('needDraw');
    }
  }, {
    key: "getResponderModels",
    value: function getResponderModels(responders) {
      var _this$tooltipMap = this.tooltipMap,
          clockHand = _this$tooltipMap.clockHand,
          solid = _this$tooltipMap.solid;
      return responders.reduce(function (acc, responder) {
        var index = responder.index;
        var clockHandModel = clockHand[index] ? [clockHand[index]] : [];
        var solidModel = solid[index] ? [solid[index]] : [];
        return [].concat(gaugeSeries_toConsumableArray(acc), clockHandModel, solidModel);
      }, []);
    }
  }, {
    key: "onClick",
    value: function onClick(_ref10) {
      var responders = _ref10.responders;

      if (this.selectable) {
        var models = this.getResponderModelsWithTheme(this.getResponderModels(responders), 'select');
        this.eventBus.emit('renderSelectedSeries', {
          models: models,
          name: this.name
        });
        this.eventBus.emit('needDraw');
      }
    }
  }, {
    key: "getResponderModelsWithSolidTheme",
    value: function getResponderModelsWithSolidTheme(responder, type) {
      var _solidTheme$color;

      var solidTheme = this.theme[type].solid;
      var lineWidth = solidTheme.lineWidth;
      var isSameLineWidth = this.theme.solid === lineWidth;
      var thickness = isSameLineWidth ? 0 : lineWidth * 0.5;
      return gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, responder), {}, {
        color: (_solidTheme$color = solidTheme.color) !== null && _solidTheme$color !== void 0 ? _solidTheme$color : responder.color,
        lineWidth: lineWidth,
        style: [pick(solidTheme, 'strokeStyle', 'shadowBlur', 'shadowColor', 'shadowOffsetX', 'shadowOffsetY')],
        radius: {
          inner: Math.max(responder.radius.inner - thickness, 0),
          outer: responder.radius.outer + thickness
        }
      });
    }
  }, {
    key: "getResponderWithClockHandTheme",
    value: function getResponderWithClockHandTheme(responder, type) {
      var _this$theme$type = this.theme[type],
          clockHand = _this$theme$type.clockHand,
          pin = _this$theme$type.pin;
      var _ref11 = clockHand,
          size = _ref11.size,
          baseLine = _ref11.baseLine,
          clockHandColor = _ref11.color;
      var _ref12 = pin,
          radius = _ref12.radius,
          pinColor = _ref12.color,
          borderWidth = _ref12.borderWidth,
          borderColor = _ref12.borderColor;
      var pinRadius = radius !== null && radius !== void 0 ? radius : responder.pin.radius;
      var pinStyle = [{
        strokeStyle: borderColor !== null && borderColor !== void 0 ? borderColor : getRGBA(responder.pin.style[0].strokeStyle, 0.3),
        lineWidth: borderWidth ? borderWidth + pinRadius : 0
      }];
      return gaugeSeries_objectSpread(gaugeSeries_objectSpread({}, responder), {}, {
        color: clockHandColor !== null && clockHandColor !== void 0 ? clockHandColor : responder.color,
        pin: {
          radius: pinRadius,
          color: pinColor !== null && pinColor !== void 0 ? pinColor : responder.pin.color,
          style: pinStyle
        },
        baseLine: baseLine !== null && baseLine !== void 0 ? baseLine : responder.baseLine,
        handSize: size ? this.getHandSize(size, responder.index) : responder.handSize
      });
    }
  }, {
    key: "getResponderModelsWithTheme",
    value: function getResponderModelsWithTheme(responders, type) {
      var _this6 = this;

      return responders.map(function (m) {
        return (m === null || m === void 0 ? void 0 : m.type) === 'sector' ? _this6.getResponderModelsWithSolidTheme(m, type) : _this6.getResponderWithClockHandTheme(m, type);
      });
    }
  }]);

  return GaugeSeries;
}(Component);


;// CONCATENATED MODULE: ./src/brushes/gauge.ts




function getClockHandPoints(model) {
  var x = model.x,
      y = model.y,
      x2 = model.x2,
      y2 = model.y2,
      degree = model.degree,
      baseLine = model.baseLine;
  var halfBaseLine = baseLine / 2;
  var startPoint, endPoint;

  if (x === x2) {
    startPoint = {
      x: x - halfBaseLine,
      y: y
    };
    endPoint = {
      x: x + halfBaseLine,
      y: y
    };
  } else if (y === y2) {
    startPoint = {
      x: x,
      y: y - halfBaseLine
    };
    endPoint = {
      x: x,
      y: y + halfBaseLine
    };
  } else {
    startPoint = getRadialPosition(x, y, halfBaseLine, calculateDegreeToRadian(calculateValidAngle(degree + DEGREE_90)));
    endPoint = getRadialPosition(x, y, halfBaseLine, calculateDegreeToRadian(calculateValidAngle(degree - DEGREE_90)));
  }

  return [startPoint, {
    x: x2,
    y: y2
  }, endPoint];
}

function clockHand(ctx, model) {
  var color = model.color,
      x = model.x,
      y = model.y,
      _model$pin = model.pin,
      pinColor = _model$pin.color,
      radius = _model$pin.radius,
      style = _model$pin.style;
  circle(ctx, {
    type: 'circle',
    x: x,
    y: y,
    radius: radius,
    color: pinColor,
    style: style
  });
  polygon(ctx, {
    type: 'polygon',
    color: color,
    lineWidth: 1,
    fillColor: color,
    points: getClockHandPoints(model)
  });
}
;// CONCATENATED MODULE: ./src/charts/gaugeChart.ts
function gaugeChart_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { gaugeChart_typeof = function _typeof(obj) { return typeof obj; }; } else { gaugeChart_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return gaugeChart_typeof(obj); }


















function gaugeChart_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function gaugeChart_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { gaugeChart_ownKeys(Object(source), true).forEach(function (key) { gaugeChart_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { gaugeChart_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function gaugeChart_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function gaugeChart_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function gaugeChart_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function gaugeChart_createClass(Constructor, protoProps, staticProps) { if (protoProps) gaugeChart_defineProperties(Constructor.prototype, protoProps); if (staticProps) gaugeChart_defineProperties(Constructor, staticProps); return Constructor; }

function gaugeChart_get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { gaugeChart_get = Reflect.get; } else { gaugeChart_get = function _get(target, property, receiver) { var base = gaugeChart_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return gaugeChart_get(target, property, receiver || target); }

function gaugeChart_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = gaugeChart_getPrototypeOf(object); if (object === null) break; } return object; }

function gaugeChart_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) gaugeChart_setPrototypeOf(subClass, superClass); }

function gaugeChart_setPrototypeOf(o, p) { gaugeChart_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return gaugeChart_setPrototypeOf(o, p); }

function gaugeChart_createSuper(Derived) { var hasNativeReflectConstruct = gaugeChart_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = gaugeChart_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = gaugeChart_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return gaugeChart_possibleConstructorReturn(this, result); }; }

function gaugeChart_possibleConstructorReturn(self, call) { if (call && (gaugeChart_typeof(call) === "object" || typeof call === "function")) { return call; } return gaugeChart_assertThisInitialized(self); }

function gaugeChart_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function gaugeChart_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function gaugeChart_getPrototypeOf(o) { gaugeChart_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return gaugeChart_getPrototypeOf(o); }


























/**
 * @class
 * @classdesc Gauge Chart
 * @param {Object} props
 *   @param {HTMLElement} props.el - The target element to create chart.
 *   @param {Object} props.data - Data for making Gauge Chart.
 *     @param {Array<string>} [props.data.categories] - Categories.
 *     @param {Array<Object>} props.data.series - Series data.
 *       @param {string} props.data.series.name - Series name.
 *       @param {number} props.data.series.data - Series data.
 *   @param {Object} [props.options] - Options for making Gauge Chart.
 *     @param {Object} [props.options.chart]
 *       @param {string|Object} [props.options.chart.title] - Chart title text or options.
 *         @param {string} [props.options.chart.title.text] - Chart title text.
 *         @param {number} [props.options.chart.title.offsetX] - Offset value to move title horizontally.
 *         @param {number} [props.options.chart.title.offsetY] - Offset value to move title vertically.
 *         @param {string} [props.options.chart.title.align] - Chart text align. 'left', 'right', 'center' is available.
 *       @param {boolean|Object} [props.options.chart.animation] - Whether to use animation and duration when rendering the initial chart.
 *       @param {number|string} [props.options.chart.width] - Chart width. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the width of the parent container is followed.
 *       @param {number|string} [props.options.chart.height] - Chart height. 'auto' or if not write, the width of the parent container is followed. 'auto' or if not created, the height of the parent container is followed.
 *     @param {Object} [props.options.series]
 *       @param {boolean} [props.options.series.selectable=false] - Whether to make selectable series or not.
 *       @param {Object} [props.options.series.dataLabels] - Set the visibility, location, and formatting of dataLabel. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Gauge Chart guide} on github.
 *       @param {Array<number>} [props.options.series.angleRange] - The range of angles to which the circle will be drawn. It is specified by putting number in start and end.
 *       @param {boolean} [props.options.series.clockwise] - Whether it will be drawn clockwise.
 *       @param {boolean | Object} [props.options.series.solid] - When this option is set, the radial bar is displayed. It can be used when there is one series data. The default value is 'false'.
 *     @param {Object} [props.options.circularAxis]
 *       @param {string|Object} [props.options.circularAxis.title] - Axis title.
 *       @param {Object} [props.options.circularAxis.tick] - Option to adjust tick interval.
 *       @param {Object} [props.options.circularAxis.label] - Option to adjust label interval.
 *       @param {Object} [props.options.circularAxis.scale] - Option to adjust axis minimum, maximum, step size.
 *     @param {Object} [props.options.plot]
 *       @param {number} [props.options.plot.width] - Width of plot.
 *       @param {number} [props.options.plot.height] - Height of plot.
 *       @param {Array<Object>} [props.options.plot.bands] - Plot bands information. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Gauge Chart guide} on github.
 *     @param {Object} [props.options.exportMenu]
 *       @param {boolean} [props.options.exportMenu.visible] - Whether to show export menu.
 *       @param {string} [props.options.exportMenu.filename] - File name applied when downloading.
 *     @param {Object} [props.options.tooltip]
 *       @param {number} [props.options.tooltip.offsetX] - Offset value to move title horizontally.
 *       @param {number} [props.options.tooltip.offsetY] - Offset value to move title vertically.
 *       @param {Function} [props.options.tooltip.formatter] - Function to format data value.
 *       @param {Function} [props.options.tooltip.template] - Function to create custom template. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Tooltip guide} on github.
 *     @param {Object} [props.options.responsive] - Rules for changing chart options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Responsive guide} on github.
 *       @param {boolean|Object} [props.options.responsive.animation] - Animation duration when the chart is modified.
 *       @param {Array<Object>} [props.options.responsive.rules] - Rules for the Chart to Respond.
 *     @param {Object} [props.options.theme] - Chart theme options. For specific information, refer to the {@link https://github.com/nhn/tui.chart|Gauge Chart guide} on github.
 *       @param {Object} [props.options.theme.chart] - Chart font theme.
 *       @param {Object} [props.options.theme.series] - Series theme.
 *       @param {Object} [props.options.theme.title] - Title theme.
 *       @param {Object} [props.options.theme.circularAxis] - Circular Axis theme.
 *       @param {Object} [props.options.theme.tooltip] - Tooltip theme.
 *       @param {Object} [props.options.theme.exportMenu] - ExportMenu theme.
 *       @param {Object} [props.options.theme.plot] - Plot Theme.
 * @extends Chart
 */
var GaugeChart = /*#__PURE__*/function (_Chart) {
  gaugeChart_inherits(GaugeChart, _Chart);

  var _super = gaugeChart_createSuper(GaugeChart);

  function GaugeChart(_ref) {
    var el = _ref.el,
        options = _ref.options,
        data = _ref.data;

    gaugeChart_classCallCheck(this, GaugeChart);

    return _super.call(this, {
      el: el,
      options: options,
      series: {
        gauge: data.series
      },
      categories: data.categories,
      modules: [store_dataRange, store_scale, gaugeAxes]
    });
  }

  gaugeChart_createClass(GaugeChart, [{
    key: "initialize",
    value: function initialize() {
      gaugeChart_get(gaugeChart_getPrototypeOf(GaugeChart.prototype), "initialize", this).call(this);

      this.componentManager.add(Background);
      this.componentManager.add(Title);
      this.componentManager.add(RadarPlot, {
        name: 'gauge'
      });
      this.componentManager.add(RadialAxis, {
        name: 'gauge'
      });
      this.componentManager.add(AxisTitle, {
        name: 'circularAxis'
      });
      this.componentManager.add(GaugeSeries);
      this.componentManager.add(HoveredSeries);
      this.componentManager.add(SelectedSeries);
      this.componentManager.add(DataLabels);
      this.componentManager.add(ExportMenu, {
        chartEl: this.el
      });
      this.componentManager.add(Tooltip, {
        chartEl: this.el
      });
      this.componentManager.add(NoDataText);
      this.painter.addGroups([basic_namespaceObject, legend_namespaceObject, label_namespaceObject, brushes_exportMenu_namespaceObject, brushes_sector_namespaceObject, dataLabel_namespaceObject, axis_namespaceObject, gauge_namespaceObject]);
    }
    /**
     * Add series.
     * @param {Object} data - Data to be added.
     *   @param {string} data.name - Series name.
     *   @param {Array<number|Array<number>>} data.data - Array of data to be added.
     * @api
     * @example
     * chart.addSeries({
     *   name: 'newSeries',
     *   data: [10, 20],
     * });
     */

  }, {
    key: "addSeries",
    value: function addSeries(data) {
      this.resetSeries();
      this.store.dispatch('addSeries', {
        data: data
      });
    }
    /**
     * Add data.
     * @param {Array} data - Array of data to be added.
     * @param {string} [category] - Category to be added.
     * @api
     * @example
     * // without categories
     * chart.addData([10], '6');
     *
     * // with categories
     * chart.addData([10], '6');
     */

  }, {
    key: "addData",
    value: function addData(data, category) {
      this.resetSeries();
      this.animationControlFlag.updating = true;
      this.store.dispatch('addData', {
        data: data,
        category: category
      });
    }
    /**
     * Convert the chart data to new data.
     * @param {Object} data - Data to be set.
     * @api
     * @example
     * chart.setData({
     *   categories: ['1', '2', '3'],
     *   series: [
     *     {
     *       name: 'new series',
     *       data: [1, 2, 3],
     *     },
     *     {
     *       name: 'new series2',
     *       data: [4, 5, 6],
     *     }
     *   ]
     * });
     */

  }, {
    key: "setData",
    value: function setData(data) {
      var categories = data.categories,
          series = data.series;
      this.resetSeries();
      this.store.dispatch('setData', {
        series: {
          gauge: series
        },
        categories: categories
      });
    }
    /**
     * Hide series data label.
     * @api
     * @example
     * chart.hideSeriesDataLabel();
     */

  }, {
    key: "hideSeriesDataLabel",
    value: function hideSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: false
            }
          }
        }
      });
    }
    /**
     * Show series data label.
     * @api
     * @example
     * chart.showSeriesDataLabel();
     */

  }, {
    key: "showSeriesDataLabel",
    value: function showSeriesDataLabel() {
      this.store.dispatch('updateOptions', {
        options: {
          series: {
            dataLabels: {
              visible: true
            }
          }
        }
      });
    }
    /**
     * Convert the chart options to new options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.setOptions({
     *   chart: {
     *     width: 500,
     *     height: 500,
     *     title: 'Olympic Medals',
     *   },
     *   series: {
     *     selectable: true
     *   }
     * });
     */

  }, {
    key: "setOptions",
    value: function setOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('initOptions', options);
    }
    /**
     * Update chart options.
     * @param {Object} options - Chart options.
     * @api
     * @example
     * chart.updateOptions({
     *   chart: {
     *     title: 'Olympic Medals',
     *   }
     * });
     */

  }, {
    key: "updateOptions",
    value: function updateOptions(options) {
      this.resetSeries();
      this.dispatchOptionsEvent('updateOptions', options);
    }
    /**
     * Show tooltip.
     * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
     *      @param {number} seriesInfo.index - Index of data within series.
     * @api
     * @example
     * chart.showTooltip({index: 1});
     */

  }, {
    key: "showTooltip",
    value: function showTooltip(seriesInfo) {
      this.eventBus.emit('showTooltip', gaugeChart_objectSpread(gaugeChart_objectSpread({}, seriesInfo), {}, {
        state: this.store.state
      }));
    }
    /**
     * Hide tooltip.
     * @api
     * @example
     * chart.hideTooltip();
     */

  }, {
    key: "hideTooltip",
    value: function hideTooltip() {
      this.eventBus.emit('hideTooltip');
    }
    /**
     * Add plot band.
     * @param {Object} data - Plot info.
     *   @param {Array<string|number>} data.range - The range to be drawn.
     *   @param {string} data.color - Plot band color.
     *   @param {string} [data.id] - Plot id. The value on which the removePlotBand is based.
     * @api
     * @example
     * chart.addPlotBand({
     *   range: [10, 20],
     *   color: '#00ff22',
     *   id: 'plot-1',
     * });
     */

  }, {
    key: "addPlotBand",
    value: function addPlotBand(data) {
      this.store.dispatch('addGaugePlotBand', {
        data: data
      });
    }
    /**
     * Remove plot band with id.
     * @param {string} id - id of the plot band to be removed
     * @api
     * @example
     * chart.removePlotBand('plot-1');
     */

  }, {
    key: "removePlotBand",
    value: function removePlotBand(id) {
      this.store.dispatch('removeGaugePlotBand', {
        id: id
      });
    }
  }]);

  return GaugeChart;
}(Chart);


;// CONCATENATED MODULE: ./src/index.ts
function src_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function src_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




















var src_Chart = function Chart() {
  src_classCallCheck(this, Chart);
};

src_defineProperty(src_Chart, "lineChart", function (props) {
  return new LineChart(props);
});

src_defineProperty(src_Chart, "areaChart", function (props) {
  return new AreaChart(props);
});

src_defineProperty(src_Chart, "barChart", function (props) {
  return new BarChart(props);
});

src_defineProperty(src_Chart, "boxPlotChart", function (props) {
  return new BoxPlotChart(props);
});

src_defineProperty(src_Chart, "columnChart", function (props) {
  return new ColumnChart(props);
});

src_defineProperty(src_Chart, "pieChart", function (props) {
  return new PieChart(props);
});

src_defineProperty(src_Chart, "heatmapChart", function (props) {
  return new HeatmapChart(props);
});

src_defineProperty(src_Chart, "bubbleChart", function (props) {
  return new BubbleChart(props);
});

src_defineProperty(src_Chart, "scatterChart", function (props) {
  return new ScatterChart(props);
});

src_defineProperty(src_Chart, "bulletChart", function (props) {
  return new BulletChart(props);
});

src_defineProperty(src_Chart, "radarChart", function (props) {
  return new RadarChart(props);
});

src_defineProperty(src_Chart, "treemapChart", function (props) {
  return new TreemapChart(props);
});

src_defineProperty(src_Chart, "nestedPieChart", function (props) {
  return new NestedPieChart(props);
});

src_defineProperty(src_Chart, "lineAreaChart", function (props) {
  return new LineAreaChart(props);
});

src_defineProperty(src_Chart, "lineScatterChart", function (props) {
  return new LineScatterChart(props);
});

src_defineProperty(src_Chart, "columnLineChart", function (props) {
  return new ColumnLineChart(props);
});

src_defineProperty(src_Chart, "radialBarChart", function (props) {
  return new RadialBarChart(props);
});

src_defineProperty(src_Chart, "gaugeChart", function (props) {
  return new GaugeChart(props);
});



}();
__nested_webpack_exports__ = __nested_webpack_exports__.default;
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@toast-ui/editor-plugin-chart/dist/toastui-editor-plugin-chart.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@toast-ui/editor-plugin-chart/dist/toastui-editor-plugin-chart.js ***!
  \****************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ "./node_modules/process/browser.js");
/*!
 * TOAST UI Editor : Chart Plugin
 * @version 3.0.1 | Wed Jul 07 2021
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(/*! @toast-ui/chart */ "./node_modules/@toast-ui/chart/dist/toastui-chart.js"));
	else {}
})(self, function(__WEBPACK_EXTERNAL_MODULE__203__) {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 72:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4');
    }
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1)
        validLen = len;
    var placeHoldersLen = validLen === len
        ? 0
        : 4 - (validLen % 4);
    return [validLen, placeHoldersLen];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0
        ? validLen - 4
        : validLen;
    var i;
    for (i = 0; i < len; i += 4) {
        tmp =
            (revLookup[b64.charCodeAt(i)] << 18) |
                (revLookup[b64.charCodeAt(i + 1)] << 12) |
                (revLookup[b64.charCodeAt(i + 2)] << 6) |
                revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = (tmp >> 16) & 0xFF;
        arr[curByte++] = (tmp >> 8) & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp =
            (revLookup[b64.charCodeAt(i)] << 2) |
                (revLookup[b64.charCodeAt(i + 1)] >> 4);
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp =
            (revLookup[b64.charCodeAt(i)] << 10) |
                (revLookup[b64.charCodeAt(i + 1)] << 4) |
                (revLookup[b64.charCodeAt(i + 2)] >> 2);
        arr[curByte++] = (tmp >> 8) & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] +
        lookup[num >> 12 & 0x3F] +
        lookup[num >> 6 & 0x3F] +
        lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
        tmp =
            ((uint8[i] << 16) & 0xFF0000) +
                ((uint8[i + 1] << 8) & 0xFF00) +
                (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join('');
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3
    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
    }
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] +
            lookup[(tmp << 4) & 0x3F] +
            '==');
    }
    else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] +
            lookup[(tmp >> 4) & 0x3F] +
            lookup[(tmp << 2) & 0x3F] +
            '=');
    }
    return parts.join('');
}


/***/ }),

/***/ 636:
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_5355__) {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

var base64 = __nested_webpack_require_5355__(72);
var ieee754 = __nested_webpack_require_5355__(74);
var customInspectSymbol = (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
    console.error('This browser lacks typed array (Uint8Array) support which is required by ' +
        '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        var arr = new Uint8Array(1);
        var proto = { foo: function () { return 42; } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    }
    catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function () {
        if (!Buffer.isBuffer(this))
            return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function () {
        if (!Buffer.isBuffer(this))
            return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    // Return an augmented `Uint8Array` instance
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */
function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
            throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192; // not used by this implementation
function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') {
        return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
    }
    if (value == null) {
        throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
            'or Array-like Object. Received type ' + (typeof value));
    }
    if (isInstance(value, ArrayBuffer) ||
        (value && isInstance(value.buffer, ArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== 'undefined' &&
        (isInstance(value, SharedArrayBuffer) ||
            (value && isInstance(value.buffer, SharedArrayBuffer)))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === 'number') {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
        return Buffer.from(valueOf, encodingOrOffset, length);
    }
    var b = fromObject(value);
    if (b)
        return b;
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
        typeof value[Symbol.toPrimitive] === 'function') {
        return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    }
    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
        'or Array-like Object. Received type ' + (typeof value));
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be of type number');
    }
    else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
        return createBuffer(size);
    }
    if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpreted as a start offset.
        return typeof encoding === 'string'
            ? createBuffer(size).fill(fill, encoding)
            : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
    }
    if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
    }
    var length = byteLength(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        buf = buf.slice(0, actual);
    }
    return buf;
}
function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for (var i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
    }
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        var copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
    }
    var buf;
    if (byteOffset === undefined && length === undefined) {
        buf = new Uint8Array(array);
    }
    else if (length === undefined) {
        buf = new Uint8Array(array, byteOffset);
    }
    else {
        buf = new Uint8Array(array, byteOffset, length);
    }
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0;
        var buf = createBuffer(len);
        if (buf.length === 0) {
            return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
            return createBuffer(0);
        }
        return fromArrayLike(obj);
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
    }
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
            'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
    }
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) { // eslint-disable-line eqeqeq
        length = 0;
    }
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true &&
        b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array))
        a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array))
        b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b)
        return 0;
    var x = a.length;
    var y = b.length;
    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
        }
    }
    if (x < y)
        return -1;
    if (y < x)
        return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
        return Buffer.alloc(0);
    }
    var i;
    if (length === undefined) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
            length += list[i].length;
        }
    }
    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
        var buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                Buffer.from(buf).copy(buffer, pos);
            }
            else {
                Uint8Array.prototype.set.call(buffer, buf, pos);
            }
        }
        else if (!Buffer.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
        }
        else {
            buf.copy(buffer, pos);
        }
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) {
        return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
    }
    if (typeof string !== 'string') {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
            'Received type ' + typeof string);
    }
    var len = string.length;
    var mustMatch = (arguments.length > 2 && arguments[2] === true);
    if (!mustMatch && len === 0)
        return 0;
    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
        switch (encoding) {
            case 'ascii':
            case 'latin1':
            case 'binary':
                return len;
            case 'utf8':
            case 'utf-8':
                return utf8ToBytes(string).length;
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
                return len * 2;
            case 'hex':
                return len >>> 1;
            case 'base64':
                return base64ToBytes(string).length;
            default:
                if (loweredCase) {
                    return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
                }
                encoding = ('' + encoding).toLowerCase();
                loweredCase = true;
        }
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    var loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
        start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
        return '';
    }
    if (end === undefined || end > this.length) {
        end = this.length;
    }
    if (end <= 0) {
        return '';
    }
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
        return '';
    }
    if (!encoding)
        encoding = 'utf8';
    while (true) {
        switch (encoding) {
            case 'hex':
                return hexSlice(this, start, end);
            case 'utf8':
            case 'utf-8':
                return utf8Slice(this, start, end);
            case 'ascii':
                return asciiSlice(this, start, end);
            case 'latin1':
            case 'binary':
                return latin1Slice(this, start, end);
            case 'base64':
                return base64Slice(this, start, end);
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
                return utf16leSlice(this, start, end);
            default:
                if (loweredCase)
                    throw new TypeError('Unknown encoding: ' + encoding);
                encoding = (encoding + '').toLowerCase();
                loweredCase = true;
        }
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits');
    }
    for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
    }
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits');
    }
    for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits');
    }
    for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0)
        return '';
    if (arguments.length === 0)
        return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b))
        throw new TypeError('Argument must be a Buffer');
    if (this === b)
        return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max)
        str += ' ... ';
    return '<Buffer ' + str + '>';
};
if (customInspectSymbol) {
    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
}
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
    }
    if (!Buffer.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' +
            'Received type ' + (typeof target));
    }
    if (start === undefined) {
        start = 0;
    }
    if (end === undefined) {
        end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
        thisStart = 0;
    }
    if (thisEnd === undefined) {
        thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index');
    }
    if (thisStart >= thisEnd && start >= end) {
        return 0;
    }
    if (thisStart >= thisEnd) {
        return -1;
    }
    if (start >= end) {
        return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
        return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
        }
    }
    if (x < y)
        return -1;
    if (y < x)
        return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0)
        return -1;
    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
    }
    else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
    }
    else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset; // Coerce to Number.
    if (numberIsNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : (buffer.length - 1);
    }
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir)
            return -1;
        else
            byteOffset = buffer.length - 1;
    }
    else if (byteOffset < 0) {
        if (dir)
            byteOffset = 0;
        else
            return -1;
    }
    // Normalize val
    if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
    }
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
            return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    }
    else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]
        if (typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) {
                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            }
            else {
                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
            encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) {
                return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) {
            return buf[i];
        }
        else {
            return buf.readUInt16BE(i * indexSize);
        }
    }
    var i;
    if (dir) {
        var foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                if (foundIndex === -1)
                    foundIndex = i;
                if (i - foundIndex + 1 === valLength)
                    return foundIndex * indexSize;
            }
            else {
                if (foundIndex !== -1)
                    i -= i - foundIndex;
                foundIndex = -1;
            }
        }
    }
    else {
        if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
            var found = true;
            for (var j = 0; j < valLength; j++) {
                if (read(arr, i + j) !== read(val, j)) {
                    found = false;
                    break;
                }
            }
            if (found)
                return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
        length = remaining;
    }
    else {
        length = Number(length);
        if (length > remaining) {
            length = remaining;
        }
    }
    var strLen = string.length;
    if (length > strLen / 2) {
        length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
            return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
        // Buffer#write(string, encoding)
    }
    else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
        // Buffer#write(string, offset[, length][, encoding])
    }
    else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined)
                encoding = 'utf8';
        }
        else {
            encoding = length;
            length = undefined;
        }
    }
    else {
        throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    }
    var remaining = this.length - offset;
    if (length === undefined || length > remaining)
        length = remaining;
    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds');
    }
    if (!encoding)
        encoding = 'utf8';
    var loweredCase = false;
    for (;;) {
        switch (encoding) {
            case 'hex':
                return hexWrite(this, string, offset, length);
            case 'utf8':
            case 'utf-8':
                return utf8Write(this, string, offset, length);
            case 'ascii':
            case 'latin1':
            case 'binary':
                return asciiWrite(this, string, offset, length);
            case 'base64':
                // Warning: maxLength not taken into account in base64Write
                return base64Write(this, string, offset, length);
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
                return ucs2Write(this, string, offset, length);
            default:
                if (loweredCase)
                    throw new TypeError('Unknown encoding: ' + encoding);
                encoding = ('' + encoding).toLowerCase();
                loweredCase = true;
        }
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
    }
    else {
        return base64.fromByteArray(buf.slice(start, end));
    }
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while (i < end) {
        var firstByte = buf[i];
        var codePoint = null;
        var bytesPerSequence = (firstByte > 0xEF)
            ? 4
            : (firstByte > 0xDF)
                ? 3
                : (firstByte > 0xBF)
                    ? 2
                    : 1;
        if (i + bytesPerSequence <= end) {
            var secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
                case 1:
                    if (firstByte < 0x80) {
                        codePoint = firstByte;
                    }
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                        if (tempCodePoint > 0x7F) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                            codePoint = tempCodePoint;
                        }
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        }
        else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
    }
    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
}
function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret;
}
function latin1Slice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
    }
    return ret;
}
function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
        start = 0;
    if (!end || end < 0 || end > len)
        end = len;
    var out = '';
    for (var i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
    }
    return out;
}
function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for (var i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
    }
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0)
            start = 0;
    }
    else if (start > len) {
        start = len;
    }
    if (end < 0) {
        end += len;
        if (end < 0)
            end = 0;
    }
    else if (end > len) {
        end = len;
    }
    if (end < start)
        end = start;
    var newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset(offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0)
        throw new RangeError('offset is not uint');
    if (offset + ext > length)
        throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE =
    Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
        offset = offset >>> 0;
        byteLength = byteLength >>> 0;
        if (!noAssert)
            checkOffset(offset, byteLength, this.length);
        var val = this[offset];
        var mul = 1;
        var i = 0;
        while (++i < byteLength && (mul *= 0x100)) {
            val += this[offset + i] * mul;
        }
        return val;
    };
Buffer.prototype.readUintBE =
    Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
        offset = offset >>> 0;
        byteLength = byteLength >>> 0;
        if (!noAssert) {
            checkOffset(offset, byteLength, this.length);
        }
        var val = this[offset + --byteLength];
        var mul = 1;
        while (byteLength > 0 && (mul *= 0x100)) {
            val += this[offset + --byteLength] * mul;
        }
        return val;
    };
Buffer.prototype.readUint8 =
    Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
            checkOffset(offset, 1, this.length);
        return this[offset];
    };
Buffer.prototype.readUint16LE =
    Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
            checkOffset(offset, 2, this.length);
        return this[offset] | (this[offset + 1] << 8);
    };
Buffer.prototype.readUint16BE =
    Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
            checkOffset(offset, 2, this.length);
        return (this[offset] << 8) | this[offset + 1];
    };
Buffer.prototype.readUint32LE =
    Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
            checkOffset(offset, 4, this.length);
        return ((this[offset]) |
            (this[offset + 1] << 8) |
            (this[offset + 2] << 16)) +
            (this[offset + 3] * 0x1000000);
    };
Buffer.prototype.readUint32BE =
    Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
            checkOffset(offset, 4, this.length);
        return (this[offset] * 0x1000000) +
            ((this[offset + 1] << 16) |
                (this[offset + 2] << 8) |
                this[offset + 3]);
    };
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert)
        checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul;
    }
    mul *= 0x80;
    if (val >= mul)
        val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert)
        checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul;
    }
    mul *= 0x80;
    if (val >= mul)
        val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
        checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80))
        return (this[offset]);
    return ((0xff - this[offset] + 1) * -1);
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
        checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
        checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
        checkOffset(offset, 4, this.length);
    return (this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24);
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
        checkOffset(offset, 4, this.length);
    return (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        (this[offset + 3]);
};
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
        checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
        checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
        checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
        checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
        throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE =
    Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength = byteLength >>> 0;
        if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength) - 1;
            checkInt(this, value, offset, byteLength, maxBytes, 0);
        }
        var mul = 1;
        var i = 0;
        this[offset] = value & 0xFF;
        while (++i < byteLength && (mul *= 0x100)) {
            this[offset + i] = (value / mul) & 0xFF;
        }
        return offset + byteLength;
    };
Buffer.prototype.writeUintBE =
    Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength = byteLength >>> 0;
        if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength) - 1;
            checkInt(this, value, offset, byteLength, maxBytes, 0);
        }
        var i = byteLength - 1;
        var mul = 1;
        this[offset + i] = value & 0xFF;
        while (--i >= 0 && (mul *= 0x100)) {
            this[offset + i] = (value / mul) & 0xFF;
        }
        return offset + byteLength;
    };
Buffer.prototype.writeUint8 =
    Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
            checkInt(this, value, offset, 1, 0xff, 0);
        this[offset] = (value & 0xff);
        return offset + 1;
    };
Buffer.prototype.writeUint16LE =
    Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
            checkInt(this, value, offset, 2, 0xffff, 0);
        this[offset] = (value & 0xff);
        this[offset + 1] = (value >>> 8);
        return offset + 2;
    };
Buffer.prototype.writeUint16BE =
    Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
            checkInt(this, value, offset, 2, 0xffff, 0);
        this[offset] = (value >>> 8);
        this[offset + 1] = (value & 0xff);
        return offset + 2;
    };
Buffer.prototype.writeUint32LE =
    Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
            checkInt(this, value, offset, 4, 0xffffffff, 0);
        this[offset + 3] = (value >>> 24);
        this[offset + 2] = (value >>> 16);
        this[offset + 1] = (value >>> 8);
        this[offset] = (value & 0xff);
        return offset + 4;
    };
Buffer.prototype.writeUint32BE =
    Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
            checkInt(this, value, offset, 4, 0xffffffff, 0);
        this[offset] = (value >>> 24);
        this[offset + 1] = (value >>> 16);
        this[offset + 2] = (value >>> 8);
        this[offset + 3] = (value & 0xff);
        return offset + 4;
    };
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, (8 * byteLength) - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        var limit = Math.pow(2, (8 * byteLength) - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
        checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (value < 0)
        value = 0xff + value + 1;
    this[offset] = (value & 0xff);
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
        checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
        checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
        checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
    this[offset + 2] = (value >>> 16);
    this[offset + 3] = (value >>> 24);
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
        checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0)
        value = 0xffffffff + value + 1;
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
    return offset + 4;
};
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
        throw new RangeError('Index out of range');
    if (offset < 0)
        throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target))
        throw new TypeError('argument should be a Buffer');
    if (!start)
        start = 0;
    if (!end && end !== 0)
        end = this.length;
    if (targetStart >= target.length)
        targetStart = target.length;
    if (!targetStart)
        targetStart = 0;
    if (end > 0 && end < start)
        end = start;
    // Copy 0 bytes; we're done
    if (end === start)
        return 0;
    if (target.length === 0 || this.length === 0)
        return 0;
    // Fatal error conditions
    if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds');
    }
    if (start < 0 || start >= this.length)
        throw new RangeError('Index out of range');
    if (end < 0)
        throw new RangeError('sourceEnd out of bounds');
    // Are we oob?
    if (end > this.length)
        end = this.length;
    if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
    }
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
        // Use built-in when available, missing from IE11
        this.copyWithin(targetStart, start, end);
    }
    else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
        if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
        }
        else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
            throw new TypeError('encoding must be a string');
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
            throw new TypeError('Unknown encoding: ' + encoding);
        }
        if (val.length === 1) {
            var code = val.charCodeAt(0);
            if ((encoding === 'utf8' && code < 128) ||
                encoding === 'latin1') {
                // Fast path: If `val` fits into a single byte, use that numeric value.
                val = code;
            }
        }
    }
    else if (typeof val === 'number') {
        val = val & 255;
    }
    else if (typeof val === 'boolean') {
        val = Number(val);
    }
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index');
    }
    if (end <= start) {
        return this;
    }
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val)
        val = 0;
    var i;
    if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
            this[i] = val;
        }
    }
    else {
        var bytes = Buffer.isBuffer(val)
            ? val
            : Buffer.from(val, encoding);
        var len = bytes.length;
        if (len === 0) {
            throw new TypeError('The value "' + val +
                '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
        }
    }
    return this;
};
// HELPER FUNCTIONS
// ================
var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2)
        return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
        str = str + '=';
    }
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1)
                        bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1)
                        bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1)
                    bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        }
        else if (leadSurrogate) {
            // valid bmp char, but last char was a lead
            if ((units -= 3) > -1)
                bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0)
                break;
            bytes.push(codePoint);
        }
        else if (codePoint < 0x800) {
            if ((units -= 2) < 0)
                break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        }
        else if (codePoint < 0x10000) {
            if ((units -= 3) < 0)
                break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        }
        else if (codePoint < 0x110000) {
            if ((units -= 4) < 0)
                break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        }
        else {
            throw new Error('Invalid code point');
        }
    }
    return bytes;
}
function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray;
}
function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
            break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length))
            break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type ||
        (obj != null && obj.constructor != null && obj.constructor.name != null &&
            obj.constructor.name === type.name);
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj; // eslint-disable-line no-self-compare
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
    var alphabet = '0123456789abcdef';
    var table = new Array(256);
    for (var i = 0; i < 16; ++i) {
        var i16 = i * 16;
        for (var j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
        }
    }
    return table;
})();


/***/ }),

/***/ 722:
/***/ (function(module) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function'
    ? R.apply
    : function ReflectApply(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
    };
var ReflectOwnKeys;
if (R && typeof R.ownKeys === 'function') {
    ReflectOwnKeys = R.ownKeys;
}
else if (Object.getOwnPropertySymbols) {
    ReflectOwnKeys = function ReflectOwnKeys(target) {
        return Object.getOwnPropertyNames(target)
            .concat(Object.getOwnPropertySymbols(target));
    };
}
else {
    ReflectOwnKeys = function ReflectOwnKeys(target) {
        return Object.getOwnPropertyNames(target);
    };
}
function ProcessEmitWarning(warning) {
    if (console && console.warn)
        console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
    return value !== value;
};
function EventEmitter() {
    EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;
// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;
function checkListener(listener) {
    if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
    }
}
Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function () {
        return defaultMaxListeners;
    },
    set: function (arg) {
        if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
        }
        defaultMaxListeners = arg;
    }
});
EventEmitter.init = function () {
    if (this._events === undefined ||
        this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
};
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
    }
    this._maxListeners = n;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined)
        return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
    var args = [];
    for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
    var doError = (type === 'error');
    var events = this._events;
    if (events !== undefined)
        doError = (doError && events.error === undefined);
    else if (!doError)
        return false;
    // If there is no 'error' event listener then throw.
    if (doError) {
        var er;
        if (args.length > 0)
            er = args[0];
        if (er instanceof Error) {
            // Note: The comments on the `throw` lines are intentional, they show
            // up in Node's output if this results in an unhandled exception.
            throw er; // Unhandled 'error' event
        }
        // At least give some kind of context to the user
        var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
        err.context = er;
        throw err; // Unhandled 'error' event
    }
    var handler = events[type];
    if (handler === undefined)
        return false;
    if (typeof handler === 'function') {
        ReflectApply(handler, this, args);
    }
    else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
            ReflectApply(listeners[i], this, args);
    }
    return true;
};
function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    }
    else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener !== undefined) {
            target.emit('newListener', type, listener.listener ? listener.listener : listener);
            // Re-assign `events` because a newListener handler could have caused the
            // this._events to be assigned to a new object
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
    }
    else {
        if (typeof existing === 'function') {
            // Adding the second element, need to change to array.
            existing = events[type] =
                prepend ? [listener, existing] : [existing, listener];
            // If we've already got an array, just append.
        }
        else if (prepend) {
            existing.unshift(listener);
        }
        else {
            existing.push(listener);
        }
        // Check for listener leak
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            // No error code for this since it is a Warning
            // eslint-disable-next-line no-restricted-syntax
            var w = new Error('Possible EventEmitter memory leak detected. ' +
                existing.length + ' ' + String(type) + ' listeners ' +
                'added. Use emitter.setMaxListeners() to ' +
                'increase limit');
            w.name = 'MaxListenersExceededWarning';
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
    };
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
            return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type, listener) {
    var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
    var wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
    };
// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === undefined)
            return this;
        list = events[type];
        if (list === undefined)
            return this;
        if (list === listener || list.listener === listener) {
            if (--this._eventsCount === 0)
                this._events = Object.create(null);
            else {
                delete events[type];
                if (events.removeListener)
                    this.emit('removeListener', type, list.listener || listener);
            }
        }
        else if (typeof list !== 'function') {
            position = -1;
            for (i = list.length - 1; i >= 0; i--) {
                if (list[i] === listener || list[i].listener === listener) {
                    originalListener = list[i].listener;
                    position = i;
                    break;
                }
            }
            if (position < 0)
                return this;
            if (position === 0)
                list.shift();
            else {
                spliceOne(list, position);
            }
            if (list.length === 1)
                events[type] = list[0];
            if (events.removeListener !== undefined)
                this.emit('removeListener', type, originalListener || listener);
        }
        return this;
    };
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (events === undefined)
            return this;
        // not listening for removeListener, no need to emit
        if (events.removeListener === undefined) {
            if (arguments.length === 0) {
                this._events = Object.create(null);
                this._eventsCount = 0;
            }
            else if (events[type] !== undefined) {
                if (--this._eventsCount === 0)
                    this._events = Object.create(null);
                else
                    delete events[type];
            }
            return this;
        }
        // emit removeListener for all listeners on all events
        if (arguments.length === 0) {
            var keys = Object.keys(events);
            var key;
            for (i = 0; i < keys.length; ++i) {
                key = keys[i];
                if (key === 'removeListener')
                    continue;
                this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = Object.create(null);
            this._eventsCount = 0;
            return this;
        }
        listeners = events[type];
        if (typeof listeners === 'function') {
            this.removeListener(type, listeners);
        }
        else if (listeners !== undefined) {
            // LIFO order
            for (i = listeners.length - 1; i >= 0; i--) {
                this.removeListener(type, listeners[i]);
            }
        }
        return this;
    };
function _listeners(target, type, unwrap) {
    var events = target._events;
    if (events === undefined)
        return [];
    var evlistener = events[type];
    if (evlistener === undefined)
        return [];
    if (typeof evlistener === 'function')
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
    return unwrap ?
        unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
};
EventEmitter.listenerCount = function (emitter, type) {
    if (typeof emitter.listenerCount === 'function') {
        return emitter.listenerCount(type);
    }
    else {
        return listenerCount.call(emitter, type);
    }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
    var events = this._events;
    if (events !== undefined) {
        var evlistener = events[type];
        if (typeof evlistener === 'function') {
            return 1;
        }
        else if (evlistener !== undefined) {
            return evlistener.length;
        }
    }
    return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
    var copy = new Array(n);
    for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
    return copy;
}
function spliceOne(list, index) {
    for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
    list.pop();
}
function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
    }
    return ret;
}
function once(emitter, name) {
    return new Promise(function (resolve, reject) {
        function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
        }
        function resolver() {
            if (typeof emitter.removeListener === 'function') {
                emitter.removeListener('error', errorListener);
            }
            resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== 'error') {
            addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
    });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === 'function') {
        eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
    }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === 'function') {
        if (flags.once) {
            emitter.once(name, listener);
        }
        else {
            emitter.on(name, listener);
        }
    }
    else if (typeof emitter.addEventListener === 'function') {
        // EventTarget does not have `error` event semantics like Node
        // EventEmitters, we do not listen for `error` events here.
        emitter.addEventListener(name, function wrapListener(arg) {
            // IE does not have builtin `{ once: true }` support so we
            // have to do it manually.
            if (flags.once) {
                emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
        });
    }
    else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
    }
}


/***/ }),

/***/ 74:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = (nBytes * 8) - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) { }
    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) { }
    if (e === 0) {
        e = 1 - eBias;
    }
    else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity);
    }
    else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = (nBytes * 8) - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    }
    else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) {
            value += rt / c;
        }
        else {
            value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        }
        else if (e + eBias >= 1) {
            m = ((value * c) - 1) * Math.pow(2, mLen);
            e = e + eBias;
        }
        else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) { }
    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) { }
    buffer[offset + i - d] |= s * 128;
};


/***/ }),

/***/ 409:
/***/ (function(module) {

"use strict";

if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
        }
    };
}
else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function () { };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
        }
    };
}


/***/ }),

/***/ 983:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_81205__) {

"use strict";

module.exports = __nested_webpack_require_81205__(983);


/***/ }),

/***/ 50:
/***/ (function(module) {

"use strict";

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }
var codes = {};
function createErrorType(code, message, Base) {
    if (!Base) {
        Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
        if (typeof message === 'string') {
            return message;
        }
        else {
            return message(arg1, arg2, arg3);
        }
    }
    var NodeError = 
    /*#__PURE__*/
    function (_Base) {
        _inheritsLoose(NodeError, _Base);
        function NodeError(arg1, arg2, arg3) {
            return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError;
    }(Base);
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js
function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function (i) {
            return String(i);
        });
        if (len > 2) {
            return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
        }
        else if (len === 2) {
            return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        }
        else {
            return "of ".concat(thing, " ").concat(expected[0]);
        }
    }
    else {
        return "of ".concat(thing, " ").concat(String(expected));
    }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith
function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) {
        this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes
function includes(str, search, start) {
    if (typeof start !== 'number') {
        start = 0;
    }
    if (start + search.length > str.length) {
        return false;
    }
    else {
        return str.indexOf(search, start) !== -1;
    }
}
createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
    // determiner: 'must be' or 'must not be'
    var determiner;
    if (typeof expected === 'string' && startsWith(expected, 'not ')) {
        determiner = 'must not be';
        expected = expected.replace(/^not /, '');
    }
    else {
        determiner = 'must be';
    }
    var msg;
    if (endsWith(name, ' argument')) {
        // For cases like 'first argument'
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
    }
    else {
        var type = includes(name, '.') ? 'property' : 'argument';
        msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
    }
    msg += ". Received type ".concat(typeof actual);
    return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
    return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
    return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
    return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.q = codes;


/***/ }),

/***/ 298:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_85848__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) {
        keys.push(key);
    }
    return keys;
};
/*</replacement>*/
module.exports = Duplex;
var Readable = __nested_webpack_require_85848__(58);
var Writable = __nested_webpack_require_85848__(880);
__nested_webpack_require_85848__(409)(Duplex, Readable);
{
    // Allow the keys array to be GC'ed.
    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
        var method = keys[v];
        if (!Duplex.prototype[method])
            Duplex.prototype[method] = Writable.prototype[method];
    }
}
function Duplex(options) {
    if (!(this instanceof Duplex))
        return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
        if (options.readable === false)
            this.readable = false;
        if (options.writable === false)
            this.writable = false;
        if (options.allowHalfOpen === false) {
            this.allowHalfOpen = false;
            this.once('end', onend);
        }
    }
}
Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
}); // the no-half-open enforcer
function onend() {
    // If the writable side ended, then we're ok.
    if (this._writableState.ended)
        return; // no more data can be written.
    // But allow more writes to happen in this tick.
    process.nextTick(onEndNT, this);
}
function onEndNT(self) {
    self.end();
}
Object.defineProperty(Duplex.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined || this._writableState === undefined) {
            return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (this._readableState === undefined || this._writableState === undefined) {
            return;
        } // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
    }
});


/***/ }),

/***/ 4:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_90564__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;
var Transform = __nested_webpack_require_90564__(969);
__nested_webpack_require_90564__(409)(PassThrough, Transform);
function PassThrough(options) {
    if (!(this instanceof PassThrough))
        return new PassThrough(options);
    Transform.call(this, options);
}
PassThrough.prototype._transform = function (chunk, encoding, cb) {
    cb(null, chunk);
};


/***/ }),

/***/ 58:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_92301__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;
/*<replacement>*/
var Duplex;
/*</replacement>*/
Readable.ReadableState = ReadableState;
/*<replacement>*/
var EE = __nested_webpack_require_92301__(722).EventEmitter;
var EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
};
/*</replacement>*/
/*<replacement>*/
var Stream = __nested_webpack_require_92301__(786);
/*</replacement>*/
var Buffer = __nested_webpack_require_92301__(636).Buffer;
var OurUint8Array = __nested_webpack_require_92301__.g.Uint8Array || function () { };
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/
var debugUtil = __nested_webpack_require_92301__(602);
var debug;
if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog('stream');
}
else {
    debug = function debug() { };
}
/*</replacement>*/
var BufferList = __nested_webpack_require_92301__(346);
var destroyImpl = __nested_webpack_require_92301__(974);
var _require = __nested_webpack_require_92301__(754), getHighWaterMark = _require.getHighWaterMark;
var _require$codes = __nested_webpack_require_92301__(50)/* .codes */ .q, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.
var StringDecoder;
var createReadableStreamAsyncIterator;
var from;
__nested_webpack_require_92301__(409)(Readable, Stream);
var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === 'function')
        return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
    else
        emitter._events[event] = [fn, emitter._events[event]];
}
function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || __nested_webpack_require_92301__(298);
    options = options || {}; // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.
    if (typeof isDuplex !== 'boolean')
        isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away
    this.objectMode = !!options.objectMode;
    if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"
    this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.
    this.sync = true; // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true; // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')
    this.autoDestroy = !!options.autoDestroy; // has it been destroyed
    this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s
    this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
        if (!StringDecoder)
            StringDecoder = __nested_webpack_require_92301__(183)/* .StringDecoder */ .s;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
    }
}
function Readable(options) {
    Duplex = Duplex || __nested_webpack_require_92301__(298);
    if (!(this instanceof Readable))
        return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
    // the ReadableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex); // legacy
    this.readable = true;
    if (options) {
        if (typeof options.read === 'function')
            this._read = options.read;
        if (typeof options.destroy === 'function')
            this._destroy = options.destroy;
    }
    Stream.call(this);
}
Object.defineProperty(Readable.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._readableState === undefined) {
            return false;
        }
        return this._readableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._readableState) {
            return;
        } // backward compatibility, the user is explicitly
        // managing destroyed
        this._readableState.destroyed = value;
    }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
    cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
        if (typeof chunk === 'string') {
            encoding = encoding || state.defaultEncoding;
            if (encoding !== state.encoding) {
                chunk = Buffer.from(chunk, encoding);
                encoding = '';
            }
            skipChunkCheck = true;
        }
    }
    else {
        skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
    return readableAddChunk(this, chunk, null, true, false);
};
function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug('readableAddChunk', chunk);
    var state = stream._readableState;
    if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
    }
    else {
        var er;
        if (!skipChunkCheck)
            er = chunkInvalid(state, chunk);
        if (er) {
            errorOrDestroy(stream, er);
        }
        else if (state.objectMode || chunk && chunk.length > 0) {
            if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
                chunk = _uint8ArrayToBuffer(chunk);
            }
            if (addToFront) {
                if (state.endEmitted)
                    errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
                else
                    addChunk(stream, state, chunk, true);
            }
            else if (state.ended) {
                errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
            }
            else if (state.destroyed) {
                return false;
            }
            else {
                state.reading = false;
                if (state.decoder && !encoding) {
                    chunk = state.decoder.write(chunk);
                    if (state.objectMode || chunk.length !== 0)
                        addChunk(stream, state, chunk, false);
                    else
                        maybeReadMore(stream, state);
                }
                else {
                    addChunk(stream, state, chunk, false);
                }
            }
        }
        else if (!addToFront) {
            state.reading = false;
            maybeReadMore(stream, state);
        }
    } // We can push more data if we are below the highWaterMark.
    // Also, if we have no data yet, we can stand some more bytes.
    // This is to work around cases where hwm=0, such as the repl.
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}
function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit('data', chunk);
    }
    else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
            state.buffer.unshift(chunk);
        else
            state.buffer.push(chunk);
        if (state.needReadable)
            emitReadable(stream);
    }
    maybeReadMore(stream, state);
}
function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
    }
    return er;
}
Readable.prototype.isPaused = function () {
    return this._readableState.flowing === false;
}; // backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
    if (!StringDecoder)
        StringDecoder = __nested_webpack_require_92301__(183)/* .StringDecoder */ .s;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8
    this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:
    var p = this._readableState.buffer.head;
    var content = '';
    while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== '')
        this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
}; // Don't raise the hwm > 1GB
var MAX_HWM = 0x40000000;
function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
        // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
        n = MAX_HWM;
    }
    else {
        // Get the next highest power of 2 to prevent increasing hwm excessively in
        // tiny amounts
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
    }
    return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
        return 0;
    if (state.objectMode)
        return 1;
    if (n !== n) {
        // Only flow one buffer at a time
        if (state.flowing && state.length)
            return state.buffer.head.data.length;
        else
            return state.length;
    } // If we're asking for more than the current hwm, then raise the hwm.
    if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
        return n; // Don't have enough
    if (!state.ended) {
        state.needReadable = true;
        return 0;
    }
    return state.length;
} // you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
    debug('read', n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
        state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug('read: emitReadable', state.length, state.ended);
        if (state.length === 0 && state.ended)
            endReadable(this);
        else
            emitReadable(this);
        return null;
    }
    n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.
    if (n === 0 && state.ended) {
        if (state.length === 0)
            endReadable(this);
        return null;
    } // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.
    var doRead = state.needReadable;
    debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some
    if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug('length less than watermark', doRead);
    } // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.
    if (state.ended || state.reading) {
        doRead = false;
        debug('reading or ended', doRead);
    }
    else if (doRead) {
        debug('do read');
        state.reading = true;
        state.sync = true; // if the length is currently zero, then we *need* a readable event.
        if (state.length === 0)
            state.needReadable = true; // call internal read method
        this._read(state.highWaterMark);
        state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
        // and we need to re-evaluate how much data we can return to the user.
        if (!state.reading)
            n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
        ret = fromList(n, state);
    else
        ret = null;
    if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
    }
    else {
        state.length -= n;
        state.awaitDrain = 0;
    }
    if (state.length === 0) {
        // If we have nothing in the buffer, then we want to know
        // as soon as we *do* get something into the buffer.
        if (!state.ended)
            state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.
        if (nOrig !== n && state.ended)
            endReadable(this);
    }
    if (ret !== null)
        this.emit('data', ret);
    return ret;
};
function onEofChunk(stream, state) {
    debug('onEofChunk');
    if (state.ended)
        return;
    if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
            state.buffer.push(chunk);
            state.length += state.objectMode ? 1 : chunk.length;
        }
    }
    state.ended = true;
    if (state.sync) {
        // if we are sync, wait until next tick to emit the data.
        // Otherwise we risk emitting data in the flow()
        // the readable code triggers during a read() call
        emitReadable(stream);
    }
    else {
        // emit 'readable' now to make sure it gets picked up.
        state.needReadable = false;
        if (!state.emittedReadable) {
            state.emittedReadable = true;
            emitReadable_(stream);
        }
    }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
    var state = stream._readableState;
    debug('emitReadable', state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
        debug('emitReadable', state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
    }
}
function emitReadable_(stream) {
    var state = stream._readableState;
    debug('emitReadable_', state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
        stream.emit('readable');
        state.emittedReadable = false;
    } // The stream needs another readable event if
    // 1. It is not flowing, as the flow mechanism will take
    //    care of it.
    // 2. It is not ended.
    // 3. It is below the highWaterMark, so we can schedule
    //    another readable later.
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
    if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
    }
}
function maybeReadMore_(stream, state) {
    // Attempt to read more data if we should.
    //
    // The conditions for reading more data are (one of):
    // - Not enough data buffered (state.length < state.highWaterMark). The loop
    //   is responsible for filling the buffer with enough data if such data
    //   is available. If highWaterMark is 0 and we are not in the flowing mode
    //   we should _not_ attempt to buffer any extra data. We'll get more data
    //   when the stream consumer calls read() instead.
    // - No data in the buffer, and the stream is in flowing mode. In this mode
    //   the loop below is responsible for ensuring read() is called. Failing to
    //   call read here would abort the flow and there's no other mechanism for
    //   continuing the flow if the stream consumer has just subscribed to the
    //   'data' event.
    //
    // In addition to the above conditions to keep reading data, the following
    // conditions prevent the data from being read:
    // - The stream has ended (state.ended).
    // - There is already a pending 'read' operation (state.reading). This is a
    //   case where the the stream has called the implementation defined _read()
    //   method, but they are processing the call asynchronously and have _not_
    //   called push() with new data. In this case we skip performing more
    //   read()s. The execution ends in this method again after the _read() ends
    //   up calling push() with more data.
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug('maybeReadMore read 0');
        stream.read(0);
        if (len === state.length) // didn't get any data, stop spinning.
            break;
    }
    state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};
Readable.prototype.pipe = function (dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
        case 0:
            state.pipes = dest;
            break;
        case 1:
            state.pipes = [state.pipes, dest];
            break;
        default:
            state.pipes.push(dest);
            break;
    }
    state.pipesCount += 1;
    debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
        process.nextTick(endFn);
    else
        src.once('end', endFn);
    dest.on('unpipe', onunpipe);
    function onunpipe(readable, unpipeInfo) {
        debug('onunpipe');
        if (readable === src) {
            if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
                unpipeInfo.hasUnpiped = true;
                cleanup();
            }
        }
    }
    function onend() {
        debug('onend');
        dest.end();
    } // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.
    var ondrain = pipeOnDrain(src);
    dest.on('drain', ondrain);
    var cleanedUp = false;
    function cleanup() {
        debug('cleanup'); // cleanup event handlers once the pipe is broken
        dest.removeListener('close', onclose);
        dest.removeListener('finish', onfinish);
        dest.removeListener('drain', ondrain);
        dest.removeListener('error', onerror);
        dest.removeListener('unpipe', onunpipe);
        src.removeListener('end', onend);
        src.removeListener('end', unpipe);
        src.removeListener('data', ondata);
        cleanedUp = true; // if the reader is waiting for a drain event from this
        // specific writer, then it would cause it to never start
        // flowing again.
        // So, if this is awaiting a drain, then we just call it now.
        // If we don't know, then assume that we are waiting for one.
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
            ondrain();
    }
    src.on('data', ondata);
    function ondata(chunk) {
        debug('ondata');
        var ret = dest.write(chunk);
        debug('dest.write', ret);
        if (ret === false) {
            // If the user unpiped during `dest.write()`, it is possible
            // to get stuck in a permanently paused state if that write
            // also returned false.
            // => Check whether `dest` is still a piping destination.
            if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
                debug('false write response, pause', state.awaitDrain);
                state.awaitDrain++;
            }
            src.pause();
        }
    } // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.
    function onerror(er) {
        debug('onerror', er);
        unpipe();
        dest.removeListener('error', onerror);
        if (EElistenerCount(dest, 'error') === 0)
            errorOrDestroy(dest, er);
    } // Make sure our error handler is attached before userland ones.
    prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.
    function onclose() {
        dest.removeListener('finish', onfinish);
        unpipe();
    }
    dest.once('close', onclose);
    function onfinish() {
        debug('onfinish');
        dest.removeListener('close', onclose);
        unpipe();
    }
    dest.once('finish', onfinish);
    function unpipe() {
        debug('unpipe');
        src.unpipe(dest);
    } // tell the dest that it's being piped to
    dest.emit('pipe', src); // start the flow if it hasn't been started already.
    if (!state.flowing) {
        debug('pipe resume');
        src.resume();
    }
    return dest;
};
function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug('pipeOnDrain', state.awaitDrain);
        if (state.awaitDrain)
            state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
            state.flowing = true;
            flow(src);
        }
    };
}
Readable.prototype.unpipe = function (dest) {
    var state = this._readableState;
    var unpipeInfo = {
        hasUnpiped: false
    }; // if we're not piping anywhere, then do nothing.
    if (state.pipesCount === 0)
        return this; // just one destination.  most common case.
    if (state.pipesCount === 1) {
        // passed in one, but it's not the right one.
        if (dest && dest !== state.pipes)
            return this;
        if (!dest)
            dest = state.pipes; // got a match.
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
            dest.emit('unpipe', this, unpipeInfo);
        return this;
    } // slow case. multiple pipe destinations.
    if (!dest) {
        // remove all.
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
            dests[i].emit('unpipe', this, {
                hasUnpiped: false
            });
        }
        return this;
    } // try to find the right one.
    var index = indexOf(state.pipes, dest);
    if (index === -1)
        return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
    dest.emit('unpipe', this, unpipeInfo);
    return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === 'data') {
        // update readableListening so that resume() may be a no-op
        // a few lines down. This is needed to support once('readable').
        state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused
        if (state.flowing !== false)
            this.resume();
    }
    else if (ev === 'readable') {
        if (!state.endEmitted && !state.readableListening) {
            state.readableListening = state.needReadable = true;
            state.flowing = false;
            state.emittedReadable = false;
            debug('on readable', state.length, state.reading);
            if (state.length) {
                emitReadable(this);
            }
            else if (!state.reading) {
                process.nextTick(nReadingNextTick, this);
            }
        }
    }
    return res;
};
Readable.prototype.addListener = Readable.prototype.on;
Readable.prototype.removeListener = function (ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === 'readable') {
        // We need to check if there is someone still listening to
        // readable and reset the state. However this needs to happen
        // after readable has been emitted but before I/O (nextTick) to
        // support once('readable', fn) cycles. This means that calling
        // resume within the same tick will have no
        // effect.
        process.nextTick(updateReadableListening, this);
    }
    return res;
};
Readable.prototype.removeAllListeners = function (ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === 'readable' || ev === undefined) {
        // We need to check if there is someone still listening to
        // readable and reset the state. However this needs to happen
        // after readable has been emitted but before I/O (nextTick) to
        // support once('readable', fn) cycles. This means that calling
        // resume within the same tick will have no
        // effect.
        process.nextTick(updateReadableListening, this);
    }
    return res;
};
function updateReadableListening(self) {
    var state = self._readableState;
    state.readableListening = self.listenerCount('readable') > 0;
    if (state.resumeScheduled && !state.paused) {
        // flowing needs to be set to true now, otherwise
        // the upcoming resume will not flow.
        state.flowing = true; // crude way to check if we should resume
    }
    else if (self.listenerCount('data') > 0) {
        self.resume();
    }
}
function nReadingNextTick(self) {
    debug('readable nexttick read 0');
    self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
    var state = this._readableState;
    if (!state.flowing) {
        debug('resume'); // we flow only if there is no one listening
        // for readable, but we still have to call
        // resume()
        state.flowing = !state.readableListening;
        resume(this, state);
    }
    state.paused = false;
    return this;
};
function resume(stream, state) {
    if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
    }
}
function resume_(stream, state) {
    debug('resume', state.reading);
    if (!state.reading) {
        stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit('resume');
    flow(stream);
    if (state.flowing && !state.reading)
        stream.read(0);
}
Readable.prototype.pause = function () {
    debug('call pause flowing=%j', this._readableState.flowing);
    if (this._readableState.flowing !== false) {
        debug('pause');
        this._readableState.flowing = false;
        this.emit('pause');
    }
    this._readableState.paused = true;
    return this;
};
function flow(stream) {
    var state = stream._readableState;
    debug('flow', state.flowing);
    while (state.flowing && stream.read() !== null) {
        ;
    }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on('end', function () {
        debug('wrapped end');
        if (state.decoder && !state.ended) {
            var chunk = state.decoder.end();
            if (chunk && chunk.length)
                _this.push(chunk);
        }
        _this.push(null);
    });
    stream.on('data', function (chunk) {
        debug('wrapped data');
        if (state.decoder)
            chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode
        if (state.objectMode && (chunk === null || chunk === undefined))
            return;
        else if (!state.objectMode && (!chunk || !chunk.length))
            return;
        var ret = _this.push(chunk);
        if (!ret) {
            paused = true;
            stream.pause();
        }
    }); // proxy all the other methods.
    // important when wrapping filters and duplexes.
    for (var i in stream) {
        if (this[i] === undefined && typeof stream[i] === 'function') {
            this[i] = function methodWrap(method) {
                return function methodWrapReturnFunction() {
                    return stream[method].apply(stream, arguments);
                };
            }(i);
        }
    } // proxy certain important events.
    for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    } // when we try to consume some more bytes, simply unpause the
    // underlying stream.
    this._read = function (n) {
        debug('wrapped _read', n);
        if (paused) {
            paused = false;
            stream.resume();
        }
    };
    return this;
};
if (typeof Symbol === 'function') {
    Readable.prototype[Symbol.asyncIterator] = function () {
        if (createReadableStreamAsyncIterator === undefined) {
            createReadableStreamAsyncIterator = __nested_webpack_require_92301__(262);
        }
        return createReadableStreamAsyncIterator(this);
    };
}
Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.highWaterMark;
    }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState && this._readableState.buffer;
    }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.flowing;
    },
    set: function set(state) {
        if (this._readableState) {
            this._readableState.flowing = state;
        }
    }
}); // exposed for testing purposes only.
Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._readableState.length;
    }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
    // nothing buffered
    if (state.length === 0)
        return null;
    var ret;
    if (state.objectMode)
        ret = state.buffer.shift();
    else if (!n || n >= state.length) {
        // read it all, truncate the list
        if (state.decoder)
            ret = state.buffer.join('');
        else if (state.buffer.length === 1)
            ret = state.buffer.first();
        else
            ret = state.buffer.concat(state.length);
        state.buffer.clear();
    }
    else {
        // read part of list
        ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
}
function endReadable(stream) {
    var state = stream._readableState;
    debug('endReadable', state.endEmitted);
    if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
    }
}
function endReadableNT(state, stream) {
    debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.
    if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
        if (state.autoDestroy) {
            // In case of duplex streams we need a way to detect
            // if the writable side is ready for autoDestroy as well
            var wState = stream._writableState;
            if (!wState || wState.autoDestroy && wState.finished) {
                stream.destroy();
            }
        }
    }
}
if (typeof Symbol === 'function') {
    Readable.from = function (iterable, opts) {
        if (from === undefined) {
            from = __nested_webpack_require_92301__(260);
        }
        return from(Readable, iterable, opts);
    };
}
function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
            return i;
    }
    return -1;
}


/***/ }),

/***/ 969:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_131321__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;
var _require$codes = __nested_webpack_require_131321__(50)/* .codes */ .q, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
var Duplex = __nested_webpack_require_131321__(298);
__nested_webpack_require_131321__(409)(Transform, Duplex);
function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
        return this.emit('error', new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null) // single equals check for both `null` and `undefined`
        this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
    }
}
function Transform(options) {
    if (!(this instanceof Transform))
        return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
    }; // start out asking for a readable event once data is transformed.
    this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.
    this._readableState.sync = false;
    if (options) {
        if (typeof options.transform === 'function')
            this._transform = options.transform;
        if (typeof options.flush === 'function')
            this._flush = options.flush;
    } // When the writable side finishes, then flush out anything remaining.
    this.on('prefinish', prefinish);
}
function prefinish() {
    var _this = this;
    if (typeof this._flush === 'function' && !this._readableState.destroyed) {
        this._flush(function (er, data) {
            done(_this, er, data);
        });
    }
    else {
        done(this, null, null);
    }
}
Transform.prototype.push = function (chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};
Transform.prototype._write = function (chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
            this._read(rs.highWaterMark);
    }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    }
    else {
        // mark that we need a transform, so that any data that comes in
        // will get processed, now that we've asked for it.
        ts.needTransform = true;
    }
};
Transform.prototype._destroy = function (err, cb) {
    Duplex.prototype._destroy.call(this, err, function (err2) {
        cb(err2);
    });
};
function done(stream, er, data) {
    if (er)
        return stream.emit('error', er);
    if (data != null) // single equals check for both `null` and `undefined`
        stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided
    if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
}


/***/ }),

/***/ 880:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_139612__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;
/* <replacement> */
function WriteReq(chunk, encoding, cb) {
    this.chunk = chunk;
    this.encoding = encoding;
    this.callback = cb;
    this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function () {
        onCorkedFinish(_this, state);
    };
}
/* </replacement> */
/*<replacement>*/
var Duplex;
/*</replacement>*/
Writable.WritableState = WritableState;
/*<replacement>*/
var internalUtil = {
    deprecate: __nested_webpack_require_139612__(485)
};
/*</replacement>*/
/*<replacement>*/
var Stream = __nested_webpack_require_139612__(786);
/*</replacement>*/
var Buffer = __nested_webpack_require_139612__(636).Buffer;
var OurUint8Array = __nested_webpack_require_139612__.g.Uint8Array || function () { };
function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
}
function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
var destroyImpl = __nested_webpack_require_139612__(974);
var _require = __nested_webpack_require_139612__(754), getHighWaterMark = _require.getHighWaterMark;
var _require$codes = __nested_webpack_require_139612__(50)/* .codes */ .q, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
var errorOrDestroy = destroyImpl.errorOrDestroy;
__nested_webpack_require_139612__(409)(Writable, Stream);
function nop() { }
function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || __nested_webpack_require_139612__(298);
    options = options || {}; // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream,
    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
    if (typeof isDuplex !== 'boolean')
        isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
    // contains buffers or objects.
    this.objectMode = !!options.objectMode;
    if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()
    this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called
    this.finalCalled = false; // drain event flag.
    this.needDrain = false; // at the start of calling end()
    this.ending = false; // when end() has been called, and returned
    this.ended = false; // when 'finish' is emitted
    this.finished = false; // has it been destroyed
    this.destroyed = false; // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.
    this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.
    this.length = 0; // a flag to see when we're in the middle of a write.
    this.writing = false; // when true all writes will be buffered until .uncork() call
    this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.
    this.sync = true; // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.
    this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)
    this.onwrite = function (er) {
        onwrite(stream, er);
    }; // the callback that the user supplies to write(chunk,encoding,cb)
    this.writecb = null; // the amount that is being written when _write is called.
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted
    this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams
    this.prefinished = false; // True if the error was already emitted and should not be thrown again
    this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.
    this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')
    this.autoDestroy = !!options.autoDestroy; // count buffered requests
    this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two
    this.corkedRequestsFree = new CorkedRequest(this);
}
WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
        out.push(current);
        current = current.next;
    }
    return out;
};
(function () {
    try {
        Object.defineProperty(WritableState.prototype, 'buffer', {
            get: internalUtil.deprecate(function writableStateBufferGetter() {
                return this.getBuffer();
            }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
        });
    }
    catch (_) { }
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
            if (realHasInstance.call(this, object))
                return true;
            if (this !== Writable)
                return false;
            return object && object._writableState instanceof WritableState;
        }
    });
}
else {
    realHasInstance = function realHasInstance(object) {
        return object instanceof this;
    };
}
function Writable(options) {
    Duplex = Duplex || __nested_webpack_require_139612__(298); // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.
    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the WritableState constructor, at least with V8 6.5
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex); // legacy.
    this.writable = true;
    if (options) {
        if (typeof options.write === 'function')
            this._write = options.write;
        if (typeof options.writev === 'function')
            this._writev = options.writev;
        if (typeof options.destroy === 'function')
            this._destroy = options.destroy;
        if (typeof options.final === 'function')
            this._final = options.final;
    }
    Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};
function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
    }
    else if (typeof chunk !== 'string' && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
    }
    if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
    }
    return true;
}
Writable.prototype.write = function (chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
    }
    if (isBuf)
        encoding = 'buffer';
    else if (!encoding)
        encoding = state.defaultEncoding;
    if (typeof cb !== 'function')
        cb = nop;
    if (state.ending)
        writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
};
Writable.prototype.cork = function () {
    this._writableState.corked++;
};
Writable.prototype.uncork = function () {
    var state = this._writableState;
    if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
            clearBuffer(this, state);
    }
};
Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === 'string')
        encoding = encoding.toLowerCase();
    if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
};
Object.defineProperty(Writable.prototype, 'writableBuffer', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState && this._writableState.getBuffer();
    }
});
function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
        chunk = Buffer.from(chunk, encoding);
    }
    return chunk;
}
Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.highWaterMark;
    }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
            isBuf = true;
            encoding = 'buffer';
            chunk = newChunk;
        }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.
    if (!ret)
        state.needDrain = true;
    if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
            chunk: chunk,
            encoding: encoding,
            isBuf: isBuf,
            callback: cb,
            next: null
        };
        if (last) {
            last.next = state.lastBufferedRequest;
        }
        else {
            state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
    }
    else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
}
function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED('write'));
    else if (writev)
        stream._writev(chunk, state.onwrite);
    else
        stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
}
function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
        // defer the callback if we are being called synchronously
        // to avoid piling up things on the stack
        process.nextTick(cb, er); // this can emit finish, and it will always happen
        // after error
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
    }
    else {
        // the caller expect this to happen before if
        // it is async
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er); // this can emit finish, but finish must
        // always follow error
        finishMaybe(stream, state);
    }
}
function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
}
function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== 'function')
        throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er)
        onwriteError(stream, state, sync, er, cb);
    else {
        // Check if we're actually ready to finish, but don't emit yet
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
            clearBuffer(stream, state);
        }
        if (sync) {
            process.nextTick(afterWrite, stream, state, finished, cb);
        }
        else {
            afterWrite(stream, state, finished, cb);
        }
    }
}
function afterWrite(stream, state, finished, cb) {
    if (!finished)
        onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit('drain');
    }
} // if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
        // Fast case, write everything using _writev()
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
            buffer[count] = entry;
            if (!entry.isBuf)
                allBuffers = false;
            entry = entry.next;
            count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
        // as the hot path ends with doWrite
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
            state.corkedRequestsFree = holder.next;
            holder.next = null;
        }
        else {
            state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
    }
    else {
        // Slow case, write chunks one-by-one
        while (entry) {
            var chunk = entry.chunk;
            var encoding = entry.encoding;
            var cb = entry.callback;
            var len = state.objectMode ? 1 : chunk.length;
            doWrite(stream, state, false, len, chunk, encoding, cb);
            entry = entry.next;
            state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
            // it means that we need to wait until it does.
            // also, that means that the chunk and cb are currently
            // being processed, so move the buffer counter past them.
            if (state.writing) {
                break;
            }
        }
        if (entry === null)
            state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
}
Writable.prototype._write = function (chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};
Writable.prototype._writev = null;
Writable.prototype.end = function (chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === 'function') {
        cb = chunk;
        chunk = null;
        encoding = null;
    }
    else if (typeof encoding === 'function') {
        cb = encoding;
        encoding = null;
    }
    if (chunk !== null && chunk !== undefined)
        this.write(chunk, encoding); // .end() fully uncorks
    if (state.corked) {
        state.corked = 1;
        this.uncork();
    } // ignore unnecessary end() calls.
    if (!state.ending)
        endWritable(this, state, cb);
    return this;
};
Object.defineProperty(Writable.prototype, 'writableLength', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        return this._writableState.length;
    }
});
function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
    stream._final(function (err) {
        state.pendingcb--;
        if (err) {
            errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit('prefinish');
        finishMaybe(stream, state);
    });
}
function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === 'function' && !state.destroyed) {
            state.pendingcb++;
            state.finalCalled = true;
            process.nextTick(callFinal, stream, state);
        }
        else {
            state.prefinished = true;
            stream.emit('prefinish');
        }
    }
}
function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
            state.finished = true;
            stream.emit('finish');
            if (state.autoDestroy) {
                // In case of duplex streams we need a way to detect
                // if the readable side is ready for autoDestroy as well
                var rState = stream._readableState;
                if (!rState || rState.autoDestroy && rState.endEmitted) {
                    stream.destroy();
                }
            }
        }
    }
    return need;
}
function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
        if (state.finished)
            process.nextTick(cb);
        else
            stream.once('finish', cb);
    }
    state.ended = true;
    stream.writable = false;
}
function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
    } // reuse the free corkReq.
    state.corkedRequestsFree.next = corkReq;
}
Object.defineProperty(Writable.prototype, 'destroyed', {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
        if (this._writableState === undefined) {
            return false;
        }
        return this._writableState.destroyed;
    },
    set: function set(value) {
        // we ignore the value if the stream
        // has not been initialized yet
        if (!this._writableState) {
            return;
        } // backward compatibility, the user is explicitly
        // managing destroyed
        this._writableState.destroyed = value;
    }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
    cb(err);
};


/***/ }),

/***/ 262:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_163015__) {

"use strict";

var _Object$setPrototypeO;
function _defineProperty(obj, key, value) { if (key in obj) {
    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
}
else {
    obj[key] = value;
} return obj; }
var finished = __nested_webpack_require_163015__(678);
var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');
function createIterResult(value, done) {
    return {
        value: value,
        done: done
    };
}
function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
        var data = iter[kStream].read(); // we defer if data is null
        // we can be expecting either 'end' or
        // 'error'
        if (data !== null) {
            iter[kLastPromise] = null;
            iter[kLastResolve] = null;
            iter[kLastReject] = null;
            resolve(createIterResult(data, false));
        }
    }
}
function onReadable(iter) {
    // we wait for the next tick, because it might
    // emit an error with process.nextTick
    process.nextTick(readAndResolve, iter);
}
function wrapForNext(lastPromise, iter) {
    return function (resolve, reject) {
        lastPromise.then(function () {
            if (iter[kEnded]) {
                resolve(createIterResult(undefined, true));
                return;
            }
            iter[kHandlePromise](resolve, reject);
        }, reject);
    };
}
var AsyncIteratorPrototype = Object.getPrototypeOf(function () { });
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
        return this[kStream];
    },
    next: function next() {
        var _this = this;
        // if we have detected an error in the meanwhile
        // reject straight away
        var error = this[kError];
        if (error !== null) {
            return Promise.reject(error);
        }
        if (this[kEnded]) {
            return Promise.resolve(createIterResult(undefined, true));
        }
        if (this[kStream].destroyed) {
            // We need to defer via nextTick because if .destroy(err) is
            // called, the error will be emitted via nextTick, and
            // we cannot guarantee that there is no error lingering around
            // waiting to be emitted.
            return new Promise(function (resolve, reject) {
                process.nextTick(function () {
                    if (_this[kError]) {
                        reject(_this[kError]);
                    }
                    else {
                        resolve(createIterResult(undefined, true));
                    }
                });
            });
        } // if we have multiple next() calls
        // we will wait for the previous Promise to finish
        // this logic is optimized to support for await loops,
        // where next() is only called once at a time
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
            promise = new Promise(wrapForNext(lastPromise, this));
        }
        else {
            // fast path needed to support multiple this.push()
            // without triggering the next() queue
            var data = this[kStream].read();
            if (data !== null) {
                return Promise.resolve(createIterResult(data, false));
            }
            promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
    }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
    return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    // destroy(err, cb) is a private API
    // we can guarantee we have that here, because we control the
    // Readable class this is attached to
    return new Promise(function (resolve, reject) {
        _this2[kStream].destroy(null, function (err) {
            if (err) {
                reject(err);
                return;
            }
            resolve(createIterResult(undefined, true));
        });
    });
}), _Object$setPrototypeO), AsyncIteratorPrototype);
var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
    }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve, reject) {
            var data = iterator[kStream].read();
            if (data) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                resolve(createIterResult(data, false));
            }
            else {
                iterator[kLastResolve] = resolve;
                iterator[kLastReject] = reject;
            }
        },
        writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function (err) {
        if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
            var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
            // returned by next() and store the error
            if (reject !== null) {
                iterator[kLastPromise] = null;
                iterator[kLastResolve] = null;
                iterator[kLastReject] = null;
                reject(err);
            }
            iterator[kError] = err;
            return;
        }
        var resolve = iterator[kLastResolve];
        if (resolve !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve(createIterResult(undefined, true));
        }
        iterator[kEnded] = true;
    });
    stream.on('readable', onReadable.bind(null, iterator));
    return iterator;
};
module.exports = createReadableStreamAsyncIterator;


/***/ }),

/***/ 346:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_169781__) {

"use strict";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
        symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; });
    keys.push.apply(keys, symbols);
} return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); });
    }
    else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    }
    else {
        ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); });
    }
} return target; }
function _defineProperty(obj, key, value) { if (key in obj) {
    Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
}
else {
    obj[key] = value;
} return obj; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
} }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
        descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
} }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps)
    _defineProperties(Constructor.prototype, protoProps); if (staticProps)
    _defineProperties(Constructor, staticProps); return Constructor; }
var _require = __nested_webpack_require_169781__(636), Buffer = _require.Buffer;
var _require2 = __nested_webpack_require_169781__(854), inspect = _require2.inspect;
var custom = inspect && inspect.custom || 'inspect';
function copyBuffer(src, target, offset) {
    Buffer.prototype.copy.call(src, target, offset);
}
module.exports =
    /*#__PURE__*/
    function () {
        function BufferList() {
            _classCallCheck(this, BufferList);
            this.head = null;
            this.tail = null;
            this.length = 0;
        }
        _createClass(BufferList, [{
                key: "push",
                value: function push(v) {
                    var entry = {
                        data: v,
                        next: null
                    };
                    if (this.length > 0)
                        this.tail.next = entry;
                    else
                        this.head = entry;
                    this.tail = entry;
                    ++this.length;
                }
            }, {
                key: "unshift",
                value: function unshift(v) {
                    var entry = {
                        data: v,
                        next: this.head
                    };
                    if (this.length === 0)
                        this.tail = entry;
                    this.head = entry;
                    ++this.length;
                }
            }, {
                key: "shift",
                value: function shift() {
                    if (this.length === 0)
                        return;
                    var ret = this.head.data;
                    if (this.length === 1)
                        this.head = this.tail = null;
                    else
                        this.head = this.head.next;
                    --this.length;
                    return ret;
                }
            }, {
                key: "clear",
                value: function clear() {
                    this.head = this.tail = null;
                    this.length = 0;
                }
            }, {
                key: "join",
                value: function join(s) {
                    if (this.length === 0)
                        return '';
                    var p = this.head;
                    var ret = '' + p.data;
                    while (p = p.next) {
                        ret += s + p.data;
                    }
                    return ret;
                }
            }, {
                key: "concat",
                value: function concat(n) {
                    if (this.length === 0)
                        return Buffer.alloc(0);
                    var ret = Buffer.allocUnsafe(n >>> 0);
                    var p = this.head;
                    var i = 0;
                    while (p) {
                        copyBuffer(p.data, ret, i);
                        i += p.data.length;
                        p = p.next;
                    }
                    return ret;
                } // Consumes a specified amount of bytes or characters from the buffered data.
            }, {
                key: "consume",
                value: function consume(n, hasStrings) {
                    var ret;
                    if (n < this.head.data.length) {
                        // `slice` is the same for buffers and strings.
                        ret = this.head.data.slice(0, n);
                        this.head.data = this.head.data.slice(n);
                    }
                    else if (n === this.head.data.length) {
                        // First chunk is a perfect match.
                        ret = this.shift();
                    }
                    else {
                        // Result spans more than one buffer.
                        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
                    }
                    return ret;
                }
            }, {
                key: "first",
                value: function first() {
                    return this.head.data;
                } // Consumes a specified amount of characters from the buffered data.
            }, {
                key: "_getString",
                value: function _getString(n) {
                    var p = this.head;
                    var c = 1;
                    var ret = p.data;
                    n -= ret.length;
                    while (p = p.next) {
                        var str = p.data;
                        var nb = n > str.length ? str.length : n;
                        if (nb === str.length)
                            ret += str;
                        else
                            ret += str.slice(0, n);
                        n -= nb;
                        if (n === 0) {
                            if (nb === str.length) {
                                ++c;
                                if (p.next)
                                    this.head = p.next;
                                else
                                    this.head = this.tail = null;
                            }
                            else {
                                this.head = p;
                                p.data = str.slice(nb);
                            }
                            break;
                        }
                        ++c;
                    }
                    this.length -= c;
                    return ret;
                } // Consumes a specified amount of bytes from the buffered data.
            }, {
                key: "_getBuffer",
                value: function _getBuffer(n) {
                    var ret = Buffer.allocUnsafe(n);
                    var p = this.head;
                    var c = 1;
                    p.data.copy(ret);
                    n -= p.data.length;
                    while (p = p.next) {
                        var buf = p.data;
                        var nb = n > buf.length ? buf.length : n;
                        buf.copy(ret, ret.length - n, 0, nb);
                        n -= nb;
                        if (n === 0) {
                            if (nb === buf.length) {
                                ++c;
                                if (p.next)
                                    this.head = p.next;
                                else
                                    this.head = this.tail = null;
                            }
                            else {
                                this.head = p;
                                p.data = buf.slice(nb);
                            }
                            break;
                        }
                        ++c;
                    }
                    this.length -= c;
                    return ret;
                } // Make sure the linked list only shows the minimal necessary information.
            }, {
                key: custom,
                value: function value(_, options) {
                    return inspect(this, _objectSpread({}, options, {
                        // Only inspect one level.
                        depth: 0,
                        // It should not recurse.
                        customInspect: false
                    }));
                }
            }]);
        return BufferList;
    }();


/***/ }),

/***/ 974:
/***/ (function(module) {

"use strict";
 // undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
        if (cb) {
            cb(err);
        }
        else if (err) {
            if (!this._writableState) {
                process.nextTick(emitErrorNT, this, err);
            }
            else if (!this._writableState.errorEmitted) {
                this._writableState.errorEmitted = true;
                process.nextTick(emitErrorNT, this, err);
            }
        }
        return this;
    } // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks
    if (this._readableState) {
        this._readableState.destroyed = true;
    } // if this is a duplex stream mark the writable part as destroyed as well
    if (this._writableState) {
        this._writableState.destroyed = true;
    }
    this._destroy(err || null, function (err) {
        if (!cb && err) {
            if (!_this._writableState) {
                process.nextTick(emitErrorAndCloseNT, _this, err);
            }
            else if (!_this._writableState.errorEmitted) {
                _this._writableState.errorEmitted = true;
                process.nextTick(emitErrorAndCloseNT, _this, err);
            }
            else {
                process.nextTick(emitCloseNT, _this);
            }
        }
        else if (cb) {
            process.nextTick(emitCloseNT, _this);
            cb(err);
        }
        else {
            process.nextTick(emitCloseNT, _this);
        }
    });
    return this;
}
function emitErrorAndCloseNT(self, err) {
    emitErrorNT(self, err);
    emitCloseNT(self);
}
function emitCloseNT(self) {
    if (self._writableState && !self._writableState.emitClose)
        return;
    if (self._readableState && !self._readableState.emitClose)
        return;
    self.emit('close');
}
function undestroy() {
    if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
    }
    if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
    }
}
function emitErrorNT(self, err) {
    self.emit('error', err);
}
function errorOrDestroy(stream, err) {
    // We have tests that rely on errors being emitted
    // in the same tick, so changing this is semver major.
    // For now when you opt-in to autoDestroy we allow
    // the error to be emitted nextTick. In a future
    // semver major update we should change the default to this.
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
    else
        stream.emit('error', err);
}
module.exports = {
    destroy: destroy,
    undestroy: undestroy,
    errorOrDestroy: errorOrDestroy
};


/***/ }),

/***/ 678:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_182647__) {

"use strict";
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).

var ERR_STREAM_PREMATURE_CLOSE = __nested_webpack_require_182647__(50)/* .codes.ERR_STREAM_PREMATURE_CLOSE */ .q.ERR_STREAM_PREMATURE_CLOSE;
function once(callback) {
    var called = false;
    return function () {
        if (called)
            return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }
        callback.apply(this, args);
    };
}
function noop() { }
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === 'function';
}
function eos(stream, opts, callback) {
    if (typeof opts === 'function')
        return eos(stream, null, opts);
    if (!opts)
        opts = {};
    callback = once(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish() {
        if (!stream.writable)
            onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish() {
        writable = false;
        writableEnded = true;
        if (!readable)
            callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend() {
        readable = false;
        readableEnded = true;
        if (!writable)
            callback.call(stream);
    };
    var onerror = function onerror(err) {
        callback.call(stream, err);
    };
    var onclose = function onclose() {
        var err;
        if (readable && !readableEnded) {
            if (!stream._readableState || !stream._readableState.ended)
                err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
            if (!stream._writableState || !stream._writableState.ended)
                err = new ERR_STREAM_PREMATURE_CLOSE();
            return callback.call(stream, err);
        }
    };
    var onrequest = function onrequest() {
        stream.req.on('finish', onfinish);
    };
    if (isRequest(stream)) {
        stream.on('complete', onfinish);
        stream.on('abort', onclose);
        if (stream.req)
            onrequest();
        else
            stream.on('request', onrequest);
    }
    else if (writable && !stream._writableState) {
        // legacy streams
        stream.on('end', onlegacyfinish);
        stream.on('close', onlegacyfinish);
    }
    stream.on('end', onend);
    stream.on('finish', onfinish);
    if (opts.error !== false)
        stream.on('error', onerror);
    stream.on('close', onclose);
    return function () {
        stream.removeListener('complete', onfinish);
        stream.removeListener('abort', onclose);
        stream.removeListener('request', onrequest);
        if (stream.req)
            stream.req.removeListener('finish', onfinish);
        stream.removeListener('end', onlegacyfinish);
        stream.removeListener('close', onlegacyfinish);
        stream.removeListener('finish', onfinish);
        stream.removeListener('end', onend);
        stream.removeListener('error', onerror);
        stream.removeListener('close', onclose);
    };
}
module.exports = eos;


/***/ }),

/***/ 260:
/***/ (function(module) {

"use strict";

module.exports = function () {
    throw new Error('Readable.from is not available in the browser');
};


/***/ }),

/***/ 732:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_186420__) {

"use strict";
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).

var eos;
function once(callback) {
    var called = false;
    return function () {
        if (called)
            return;
        called = true;
        callback.apply(void 0, arguments);
    };
}
var _require$codes = __nested_webpack_require_186420__(50)/* .codes */ .q, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
function noop(err) {
    // Rethrow the error if it exists to avoid swallowing it
    if (err)
        throw err;
}
function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === 'function';
}
function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on('close', function () {
        closed = true;
    });
    if (eos === undefined)
        eos = __nested_webpack_require_186420__(678);
    eos(stream, {
        readable: reading,
        writable: writing
    }, function (err) {
        if (err)
            return callback(err);
        closed = true;
        callback();
    });
    var destroyed = false;
    return function (err) {
        if (closed)
            return;
        if (destroyed)
            return;
        destroyed = true; // request.destroy just do .end - .abort is what we want
        if (isRequest(stream))
            return stream.abort();
        if (typeof stream.destroy === 'function')
            return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED('pipe'));
    };
}
function call(fn) {
    fn();
}
function pipe(from, to) {
    return from.pipe(to);
}
function popCallback(streams) {
    if (!streams.length)
        return noop;
    if (typeof streams[streams.length - 1] !== 'function')
        return noop;
    return streams.pop();
}
function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0]))
        streams = streams[0];
    if (streams.length < 2) {
        throw new ERR_MISSING_ARGS('streams');
    }
    var error;
    var destroys = streams.map(function (stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function (err) {
            if (!error)
                error = err;
            if (err)
                destroys.forEach(call);
            if (reading)
                return;
            destroys.forEach(call);
            callback(error);
        });
    });
    return streams.reduce(pipe);
}
module.exports = pipeline;


/***/ }),

/***/ 754:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_189267__) {

"use strict";

var ERR_INVALID_OPT_VALUE = __nested_webpack_require_189267__(50)/* .codes.ERR_INVALID_OPT_VALUE */ .q.ERR_INVALID_OPT_VALUE;
function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}
function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
            var name = isDuplex ? duplexKey : 'highWaterMark';
            throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
    } // Default value
    return state.objectMode ? 16 : 16 * 1024;
}
module.exports = {
    getHighWaterMark: getHighWaterMark
};


/***/ }),

/***/ 786:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_190172__) {

"use strict";

module.exports = __nested_webpack_require_190172__(722).EventEmitter;


/***/ }),

/***/ 769:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_190341__) {

"use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Stream;
var EE = __nested_webpack_require_190341__(722).EventEmitter;
var inherits = __nested_webpack_require_190341__(409);
inherits(Stream, EE);
Stream.Readable = __nested_webpack_require_190341__(58);
Stream.Writable = __nested_webpack_require_190341__(880);
Stream.Duplex = __nested_webpack_require_190341__(298);
Stream.Transform = __nested_webpack_require_190341__(969);
Stream.PassThrough = __nested_webpack_require_190341__(4);
Stream.finished = __nested_webpack_require_190341__(678);
Stream.pipeline = __nested_webpack_require_190341__(732);
// Backwards-compat with node 0.4.x
Stream.Stream = Stream;
// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.
function Stream() {
    EE.call(this);
}
Stream.prototype.pipe = function (dest, options) {
    var source = this;
    function ondata(chunk) {
        if (dest.writable) {
            if (false === dest.write(chunk) && source.pause) {
                source.pause();
            }
        }
    }
    source.on('data', ondata);
    function ondrain() {
        if (source.readable && source.resume) {
            source.resume();
        }
    }
    dest.on('drain', ondrain);
    // If the 'end' option is not supplied, dest.end() will be called when
    // source gets the 'end' or 'close' events.  Only dest.end() once.
    if (!dest._isStdio && (!options || options.end !== false)) {
        source.on('end', onend);
        source.on('close', onclose);
    }
    var didOnEnd = false;
    function onend() {
        if (didOnEnd)
            return;
        didOnEnd = true;
        dest.end();
    }
    function onclose() {
        if (didOnEnd)
            return;
        didOnEnd = true;
        if (typeof dest.destroy === 'function')
            dest.destroy();
    }
    // don't leave dangling pipes when there are errors.
    function onerror(er) {
        cleanup();
        if (EE.listenerCount(this, 'error') === 0) {
            throw er; // Unhandled stream error in pipe.
        }
    }
    source.on('error', onerror);
    dest.on('error', onerror);
    // remove all the event listeners that were added.
    function cleanup() {
        source.removeListener('data', ondata);
        dest.removeListener('drain', ondrain);
        source.removeListener('end', onend);
        source.removeListener('close', onclose);
        source.removeListener('error', onerror);
        dest.removeListener('error', onerror);
        source.removeListener('end', cleanup);
        source.removeListener('close', cleanup);
        dest.removeListener('close', cleanup);
    }
    source.on('end', cleanup);
    source.on('close', cleanup);
    dest.on('close', cleanup);
    dest.emit('pipe', source);
    // Allow for unix-like usage: A.pipe(B).pipe(C)
    return dest;
};


/***/ }),

/***/ 183:
/***/ (function(__unused_webpack_module, exports, __nested_webpack_require_194303__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/
var Buffer = __nested_webpack_require_194303__(805).Buffer;
/*</replacement>*/
var isEncoding = Buffer.isEncoding || function (encoding) {
    encoding = '' + encoding;
    switch (encoding && encoding.toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
        case 'raw':
            return true;
        default:
            return false;
    }
};
function _normalizeEncoding(enc) {
    if (!enc)
        return 'utf8';
    var retried;
    while (true) {
        switch (enc) {
            case 'utf8':
            case 'utf-8':
                return 'utf8';
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
                return 'utf16le';
            case 'latin1':
            case 'binary':
                return 'latin1';
            case 'base64':
            case 'ascii':
            case 'hex':
                return enc;
            default:
                if (retried)
                    return; // undefined
                enc = ('' + enc).toLowerCase();
                retried = true;
        }
    }
}
;
// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error('Unknown encoding: ' + enc);
    return nenc || enc;
}
// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.s = StringDecoder;
function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
        case 'utf16le':
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
        case 'utf8':
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
        case 'base64':
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
        default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer.allocUnsafe(nb);
}
StringDecoder.prototype.write = function (buf) {
    if (buf.length === 0)
        return '';
    var r;
    var i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined)
            return '';
        i = this.lastNeed;
        this.lastNeed = 0;
    }
    else {
        i = 0;
    }
    if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || '';
};
StringDecoder.prototype.end = utf8End;
// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;
// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
};
// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
    if (byte <= 0x7F)
        return 0;
    else if (byte >> 5 === 0x06)
        return 2;
    else if (byte >> 4 === 0x0E)
        return 3;
    else if (byte >> 3 === 0x1E)
        return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
}
// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i)
        return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0)
            self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2)
        return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0)
            self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2)
        return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2)
                nb = 0;
            else
                self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return '\ufffd';
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return '\ufffd';
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
                self.lastNeed = 2;
                return '\ufffd';
            }
        }
    }
}
// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined)
        return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed)
        return buf.toString('utf8', i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString('utf8', i, end);
}
// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed)
        return r + '\ufffd';
    return r;
}
// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
        var r = buf.toString('utf16le', i);
        if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 0xD800 && c <= 0xDBFF) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
            }
        }
        return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString('utf16le', i, buf.length - 1);
}
// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString('utf16le', 0, end);
    }
    return r;
}
function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0)
        return buf.toString('base64', i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
    }
    else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString('base64', i, buf.length - n);
}
function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed)
        return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
    return r;
}
// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : '';
}


/***/ }),

/***/ 805:
/***/ (function(module, exports, __nested_webpack_require_204821__) {

"use strict";

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = __nested_webpack_require_204821__(636);
var Buffer = buffer.Buffer;
// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
    for (var key in src) {
        dst[key] = src[key];
    }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer;
}
else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
}
SafeBuffer.prototype = Object.create(Buffer.prototype);
// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function (arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
        throw new TypeError('Argument must not be a number');
    }
    return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    var buf = Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === 'string') {
            buf.fill(fill, encoding);
        }
        else {
            buf.fill(fill);
        }
    }
    else {
        buf.fill(0);
    }
    return buf;
};
SafeBuffer.allocUnsafe = function (size) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function (size) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    return buffer.SlowBuffer(size);
};


/***/ }),

/***/ 863:
/***/ (function(module, exports, __nested_webpack_require_206715__) {

"use strict";

exports.__esModule = true;
exports.default = void 0;
var _forEachArray = _interopRequireDefault(__nested_webpack_require_206715__(695));
var _forEachOwnProperties = _interopRequireDefault(__nested_webpack_require_206715__(175));
var _extend = _interopRequireDefault(__nested_webpack_require_206715__(867));
var _isArray = _interopRequireDefault(__nested_webpack_require_206715__(383));
var _isEmpty = _interopRequireDefault(__nested_webpack_require_206715__(440));
var _isFunction = _interopRequireDefault(__nested_webpack_require_206715__(494));
var _isNull = _interopRequireDefault(__nested_webpack_require_206715__(948));
var _isObject = _interopRequireDefault(__nested_webpack_require_206715__(873));
var _isUndefined = _interopRequireDefault(__nested_webpack_require_206715__(895));
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    };
}
function encodePairs(key, value) {
    return encodeURIComponent(key) + "=" + encodeURIComponent((0, _isNull["default"])(value) || (0, _isUndefined["default"])(value) ? '' : value);
}
function serializeParams(key, value, serializedList) {
    if ((0, _isArray["default"])(value)) {
        (0, _forEachArray["default"])(value, function (arrVal, index) {
            serializeParams(key + "[" + ((0, _isObject["default"])(arrVal) ? index : '') + "]", arrVal, serializedList);
        });
    }
    else if ((0, _isObject["default"])(value)) {
        (0, _forEachOwnProperties["default"])(value, function (objValue, objKey) {
            serializeParams(key + "[" + objKey + "]", objValue, serializedList);
        });
    }
    else {
        serializedList.push(encodePairs(key, value));
    }
}
function serialize(params) {
    if (!params || (0, _isEmpty["default"])(params)) {
        return '';
    }
    var serializedList = [];
    (0, _forEachOwnProperties["default"])(params, function (value, key) {
        serializeParams(key, value, serializedList);
    });
    return serializedList.join('&');
}
var getDefaultOptions = function getDefaultOptions() {
    return {
        baseURL: '',
        headers: {
            common: {},
            get: {},
            post: {},
            put: {},
            "delete": {},
            patch: {},
            options: {},
            head: {}
        },
        serializer: serialize
    };
};
var HTTP_PROTOCOL_REGEXP = /^(http|https):\/\//i;
function combineURL(baseURL, url) {
    if (HTTP_PROTOCOL_REGEXP.test(url)) {
        return url;
    }
    if (baseURL.slice(-1) === '/' && url.slice(0, 1) === '/') {
        url = url.slice(1);
    }
    return baseURL + url;
}
function getComputedOptions(defaultOptions, customOptions) {
    var baseURL = defaultOptions.baseURL, defaultHeaders = defaultOptions.headers, defaultSerializer = defaultOptions.serializer, defaultBeforeRequest = defaultOptions.beforeRequest, defaultSuccess = defaultOptions.success, defaultError = defaultOptions.error, defaultComplete = defaultOptions.complete;
    var url = customOptions.url, contentType = customOptions.contentType, method = customOptions.method, params = customOptions.params, headers = customOptions.headers, serializer = customOptions.serializer, beforeRequest = customOptions.beforeRequest, success = customOptions.success, error = customOptions.error, complete = customOptions.complete, withCredentials = customOptions.withCredentials, mimeType = customOptions.mimeType;
    var options = {
        url: combineURL(baseURL, url),
        method: method,
        params: params,
        headers: (0, _extend["default"])(defaultHeaders.common, defaultHeaders[method.toLowerCase()], headers),
        serializer: serializer || defaultSerializer || serialize,
        beforeRequest: [defaultBeforeRequest, beforeRequest],
        success: [defaultSuccess, success],
        error: [defaultError, error],
        complete: [defaultComplete, complete],
        withCredentials: withCredentials,
        mimeType: mimeType
    };
    options.contentType = contentType || options.headers['Content-Type'];
    delete options.headers['Content-Type'];
    return options;
}
function validateStatus(status) {
    return status >= 200 && status < 300;
}
function hasRequestBody(method) {
    return /^(?:POST|PUT|PATCH)$/.test(method.toUpperCase());
}
function executeCallback(callback, param) {
    if ((0, _isArray["default"])(callback)) {
        (0, _forEachArray["default"])(callback, function (fn) {
            return executeCallback(fn, param);
        });
    }
    else if ((0, _isFunction["default"])(callback)) {
        callback(param);
    }
}
function parseHeaders(text) {
    var headers = {};
    (0, _forEachArray["default"])(text.split('\r\n'), function (header) {
        var _header$split = header.split(': '), key = _header$split[0], value = _header$split[1];
        if (key !== '' && !(0, _isUndefined["default"])(value)) {
            headers[key] = value;
        }
    });
    return headers;
}
function parseJSONData(data) {
    var result = '';
    try {
        result = JSON.parse(data);
    }
    catch (_) {
        result = data;
    }
    return result;
}
var REQUEST_DONE = 4;
function handleReadyStateChange(xhr, options) {
    var readyState = xhr.readyState;
    if (readyState != REQUEST_DONE) {
        return;
    }
    var status = xhr.status, statusText = xhr.statusText, responseText = xhr.responseText;
    var success = options.success, resolve = options.resolve, error = options.error, reject = options.reject, complete = options.complete;
    if (validateStatus(status)) {
        var contentType = xhr.getResponseHeader('Content-Type');
        var data = responseText;
        if (contentType && contentType.indexOf('application/json') > -1) {
            data = parseJSONData(data);
        }
        executeCallback([success, resolve], {
            status: status,
            statusText: statusText,
            data: data,
            headers: parseHeaders(xhr.getAllResponseHeaders())
        });
    }
    else {
        executeCallback([error, reject], {
            status: status,
            statusText: statusText
        });
    }
    executeCallback(complete, {
        status: status,
        statusText: statusText
    });
}
var QS_DELIM_REGEXP = /\?/;
function open(xhr, options) {
    var url = options.url, method = options.method, serializer = options.serializer, params = options.params;
    var requestUrl = url;
    if (!hasRequestBody(method) && params) {
        var qs = (QS_DELIM_REGEXP.test(url) ? '&' : '?') + serializer(params);
        requestUrl = "" + url + qs;
    }
    xhr.open(method, requestUrl);
}
function applyConfig(xhr, options) {
    var method = options.method, contentType = options.contentType, mimeType = options.mimeType, headers = options.headers, _options$withCredenti = options.withCredentials, withCredentials = _options$withCredenti === void 0 ? false : _options$withCredenti;
    if (withCredentials) {
        xhr.withCredentials = withCredentials;
    }
    if (mimeType) {
        xhr.overrideMimeType(mimeType);
    }
    (0, _forEachOwnProperties["default"])(headers, function (value, header) {
        if (!(0, _isObject["default"])(value)) {
            xhr.setRequestHeader(header, value);
        }
    });
    if (hasRequestBody(method)) {
        xhr.setRequestHeader('Content-Type', contentType + "; charset=UTF-8");
    }
    xhr.setRequestHeader('x-requested-with', 'XMLHttpRequest');
}
var ENCODED_SPACE_REGEXP = /%20/g;
function send(xhr, options) {
    var method = options.method, serializer = options.serializer, beforeRequest = options.beforeRequest, _options$params = options.params, params = _options$params === void 0 ? {} : _options$params, _options$contentType = options.contentType, contentType = _options$contentType === void 0 ? 'application/x-www-form-urlencoded' : _options$contentType;
    var body = null;
    if (hasRequestBody(method)) {
        body = contentType.indexOf('application/x-www-form-urlencoded') > -1 ? serializer(params).replace(ENCODED_SPACE_REGEXP, '+') : JSON.stringify(params);
    }
    xhr.onreadystatechange = function () {
        return handleReadyStateChange(xhr, options);
    };
    executeCallback(beforeRequest, xhr);
    xhr.send(body);
}
function ajax(options) {
    var xhr = new XMLHttpRequest();
    var request = function request(opts) {
        return (0, _forEachArray["default"])([open, applyConfig, send], function (fn) {
            return fn(xhr, opts);
        });
    };
    options = getComputedOptions(ajax.defaults, options);
    if (typeof Promise !== 'undefined') {
        return new Promise(function (resolve, reject) {
            request((0, _extend["default"])(options, {
                resolve: resolve,
                reject: reject
            }));
        });
    }
    request(options);
    return null;
}
ajax.defaults = getDefaultOptions();
ajax._reset = function () {
    ajax.defaults = getDefaultOptions();
};
ajax._request = function (url, method, options) {
    if (options === void 0) {
        options = {};
    }
    return ajax((0, _extend["default"])(options, {
        url: url,
        method: method
    }));
};
(0, _forEachArray["default"])(['get', 'post', 'put', 'delete', 'patch', 'options', 'head'], function (type) {
    ajax[type] = function (url, options) {
        return ajax._request(url, type.toUpperCase(), options);
    };
});
var _default = ajax;
exports.default = _default;
module.exports = exports["default"];


/***/ }),

/***/ 187:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_216191__) {

"use strict";
/* eslint-disable complexity */
/**
 * @fileoverview Returns the first index at which a given element can be found in the array.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */

var isArray = __nested_webpack_require_216191__(383);
/**
 * @module array
 */
/**
 * Returns the first index at which a given element can be found in the array
 * from start index(default 0), or -1 if it is not present.
 * It compares searchElement to elements of the Array using strict equality
 * (the same method used by the ===, or triple-equals, operator).
 * @param {*} searchElement Element to locate in the array
 * @param {Array} array Array that will be traversed.
 * @param {number} startIndex Start index in array for searching (default 0)
 * @returns {number} the First index at which a given element, or -1 if it is not present
 * @memberof module:array
 * @example
 * var inArray = require('tui-code-snippet/array/inArray'); // node, commonjs
 *
 * var arr = ['one', 'two', 'three', 'four'];
 * var idx1 = inArray('one', arr, 3); // -1
 * var idx2 = inArray('one', arr); // 0
 */
function inArray(searchElement, array, startIndex) {
    var i;
    var length;
    startIndex = startIndex || 0;
    if (!isArray(array)) {
        return -1;
    }
    if (Array.prototype.indexOf) {
        return Array.prototype.indexOf.call(array, searchElement, startIndex);
    }
    length = array.length;
    for (i = startIndex; startIndex >= 0 && i < length; i += 1) {
        if (array[i] === searchElement) {
            return i;
        }
    }
    return -1;
}
module.exports = inArray;


/***/ }),

/***/ 695:
/***/ (function(module) {

"use strict";
/**
 * @fileoverview Execute the provided callback once for each element present in the array(or Array-like object) in ascending order.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */

/**
 * Execute the provided callback once for each element present
 * in the array(or Array-like object) in ascending order.
 * If the callback function returns false, the loop will be stopped.
 * Callback function(iteratee) is invoked with three arguments:
 *  1) The value of the element
 *  2) The index of the element
 *  3) The array(or Array-like object) being traversed
 * @param {Array|Arguments|NodeList} arr The array(or Array-like object) that will be traversed
 * @param {function} iteratee Callback function
 * @param {Object} [context] Context(this) of callback function
 * @memberof module:collection
 * @example
 * var forEachArray = require('tui-code-snippet/collection/forEachArray'); // node, commonjs
 *
 * var sum = 0;
 *
 * forEachArray([1,2,3], function(value){
 *     sum += value;
 * });
 * alert(sum); // 6
 */
function forEachArray(arr, iteratee, context) {
    var index = 0;
    var len = arr.length;
    context = context || null;
    for (; index < len; index += 1) {
        if (iteratee.call(context, arr[index], index, arr) === false) {
            break;
        }
    }
}
module.exports = forEachArray;


/***/ }),

/***/ 175:
/***/ (function(module) {

"use strict";
/**
 * @fileoverview Execute the provided callback once for each property of object which actually exist.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */

/**
 * Execute the provided callback once for each property of object which actually exist.
 * If the callback function returns false, the loop will be stopped.
 * Callback function(iteratee) is invoked with three arguments:
 *  1) The value of the property
 *  2) The name of the property
 *  3) The object being traversed
 * @param {Object} obj The object that will be traversed
 * @param {function} iteratee  Callback function
 * @param {Object} [context] Context(this) of callback function
 * @memberof module:collection
 * @example
 * var forEachOwnProperties = require('tui-code-snippet/collection/forEachOwnProperties'); // node, commonjs
 *
 * var sum = 0;
 *
 * forEachOwnProperties({a:1,b:2,c:3}, function(value){
 *     sum += value;
 * });
 * alert(sum); // 6
 */
function forEachOwnProperties(obj, iteratee, context) {
    var key;
    context = context || null;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) {
            if (iteratee.call(context, obj[key], key, obj) === false) {
                break;
            }
        }
    }
}
module.exports = forEachOwnProperties;


/***/ }),

/***/ 867:
/***/ (function(module) {

"use strict";
/**
 * @fileoverview Extend the target object from other objects.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */

/**
 * @module object
 */
/**
 * Extend the target object from other objects.
 * @param {object} target - Object that will be extended
 * @param {...object} objects - Objects as sources
 * @returns {object} Extended object
 * @memberof module:object
 */
function extend(target, objects) {
    var hasOwnProp = Object.prototype.hasOwnProperty;
    var source, prop, i, len;
    for (i = 1, len = arguments.length; i < len; i += 1) {
        source = arguments[i];
        for (prop in source) {
            if (hasOwnProp.call(source, prop)) {
                target[prop] = source[prop];
            }
        }
    }
    return target;
}
module.exports = extend;


/***/ }),

/***/ 947:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_221478__) {

"use strict";
/**
 * @fileoverview Check whether the given variable is an arguments object or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */

var isExisty = __nested_webpack_require_221478__(325);
/**
 * @module type
 */
/**
 * Check whether the given variable is an arguments object or not.
 * If the given variable is an arguments object, return true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is arguments?
 * @memberof module:type
 */
function isArguments(obj) {
    var result = isExisty(obj) &&
        ((Object.prototype.toString.call(obj) === '[object Arguments]') || !!obj.callee);
    return result;
}
module.exports = isArguments;


/***/ }),

/***/ 383:
/***/ (function(module) {

"use strict";
/**
 * @fileoverview Check whether the given variable is an instance of Array or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */

/**
 * Check whether the given variable is an instance of Array or not.
 * If the given variable is an instance of Array, return true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is array instance?
 * @memberof module:type
 */
function isArray(obj) {
    return obj instanceof Array;
}
module.exports = isArray;


/***/ }),

/***/ 440:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_222788__) {

"use strict";
/* eslint-disable complexity */
/**
 * @fileoverview Check whether the given variable is empty(null, undefined, or empty array, empty object) or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */

var isString = __nested_webpack_require_222788__(994);
var isExisty = __nested_webpack_require_222788__(325);
var isArray = __nested_webpack_require_222788__(383);
var isArguments = __nested_webpack_require_222788__(947);
var isObject = __nested_webpack_require_222788__(873);
var isFunction = __nested_webpack_require_222788__(494);
/**
 * Check whether given argument is empty string
 * @param {*} obj - Target for checking
 * @returns {boolean} whether given argument is empty string
 * @private
 */
function _isEmptyString(obj) {
    return isString(obj) && obj === '';
}
/**
 * Check whether given argument has own property
 * @param {Object} obj - Target for checking
 * @returns {boolean} - whether given argument has own property
 * @private
 */
function _hasOwnProperty(obj) {
    var key;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) {
            return true;
        }
    }
    return false;
}
/**
 * Check whether the given variable is empty(null, undefined, or empty array, empty object) or not.
 *  If the given variables is empty, return true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is empty?
 * @memberof module:type
 */
function isEmpty(obj) {
    if (!isExisty(obj) || _isEmptyString(obj)) {
        return true;
    }
    if (isArray(obj) || isArguments(obj)) {
        return obj.length === 0;
    }
    if (isObject(obj) && !isFunction(obj)) {
        return !_hasOwnProperty(obj);
    }
    return true;
}
module.exports = isEmpty;


/***/ }),

/***/ 325:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_224523__) {

"use strict";
/**
 * @fileoverview Check whether the given variable is existing or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */

var isUndefined = __nested_webpack_require_224523__(895);
var isNull = __nested_webpack_require_224523__(948);
/**
 * Check whether the given variable is existing or not.
 * If the given variable is not null and not undefined, returns true.
 * @param {*} param - Target for checking
 * @returns {boolean} Is existy?
 * @memberof module:type
 * @example
 * var isExisty = require('tui-code-snippet/type/isExisty'); // node, commonjs
 *
 * isExisty(''); //true
 * isExisty(0); //true
 * isExisty([]); //true
 * isExisty({}); //true
 * isExisty(null); //false
 * isExisty(undefined); //false
*/
function isExisty(param) {
    return !isUndefined(param) && !isNull(param);
}
module.exports = isExisty;


/***/ }),

/***/ 494:
/***/ (function(module) {

"use strict";
/**
 * @fileoverview Check whether the given variable is a function or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */

/**
 * Check whether the given variable is a function or not.
 * If the given variable is a function, return true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is function?
 * @memberof module:type
 */
function isFunction(obj) {
    return obj instanceof Function;
}
module.exports = isFunction;


/***/ }),

/***/ 948:
/***/ (function(module) {

"use strict";
/**
 * @fileoverview Check whether the given variable is null or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */

/**
 * Check whether the given variable is null or not.
 * If the given variable(arguments[0]) is null, returns true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is null?
 * @memberof module:type
 */
function isNull(obj) {
    return obj === null;
}
module.exports = isNull;


/***/ }),

/***/ 873:
/***/ (function(module) {

"use strict";
/**
 * @fileoverview Check whether the given variable is an object or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */

/**
 * Check whether the given variable is an object or not.
 * If the given variable is an object, return true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is object?
 * @memberof module:type
 */
function isObject(obj) {
    return obj === Object(obj);
}
module.exports = isObject;


/***/ }),

/***/ 994:
/***/ (function(module) {

"use strict";
/**
 * @fileoverview Check whether the given variable is a string or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */

/**
 * Check whether the given variable is a string or not.
 * If the given variable is a string, return true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is string?
 * @memberof module:type
 */
function isString(obj) {
    return typeof obj === 'string' || obj instanceof String;
}
module.exports = isString;


/***/ }),

/***/ 895:
/***/ (function(module) {

"use strict";
/**
 * @fileoverview Check whether the given variable is undefined or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */

/**
 * Check whether the given variable is undefined or not.
 * If the given variable is undefined, returns true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is undefined?
 * @memberof module:type
 */
function isUndefined(obj) {
    return obj === undefined; // eslint-disable-line no-undefined
}
module.exports = isUndefined;


/***/ }),

/***/ 485:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_228032__) {

"use strict";

/**
 * Module exports.
 */
module.exports = deprecate;
/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */
function deprecate(fn, msg) {
    if (config('noDeprecation')) {
        return fn;
    }
    var warned = false;
    function deprecated() {
        if (!warned) {
            if (config('throwDeprecation')) {
                throw new Error(msg);
            }
            else if (config('traceDeprecation')) {
                console.trace(msg);
            }
            else {
                console.warn(msg);
            }
            warned = true;
        }
        return fn.apply(this, arguments);
    }
    return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */
function config(name) {
    // accessing global.localStorage can trigger a DOMException in sandboxed iframes
    try {
        if (!__nested_webpack_require_228032__.g.localStorage)
            return false;
    }
    catch (_) {
        return false;
    }
    var val = __nested_webpack_require_228032__.g.localStorage[name];
    if (null == val)
        return false;
    return String(val).toLowerCase() === 'true';
}


/***/ }),

/***/ 203:
/***/ (function(module) {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__203__;

/***/ }),

/***/ 854:
/***/ (function() {

/* (ignored) */

/***/ }),

/***/ 602:
/***/ (function() {

/* (ignored) */

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_230323__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_230323__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__nested_webpack_require_230323__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__nested_webpack_require_230323__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__nested_webpack_require_230323__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__nested_webpack_require_230323__.o(definition, key) && !__nested_webpack_require_230323__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__nested_webpack_require_230323__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__nested_webpack_require_230323__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/************************************************************************/
var __nested_webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";

// EXPORTS
__nested_webpack_require_230323__.d(__nested_webpack_exports__, {
  "default": function() { return /* binding */ chartPlugin; }
});

// UNUSED EXPORTS: detectDelimiter, parse, parseToChartData, parseToChartOption, setDefaultOptions

// EXTERNAL MODULE: external {"commonjs":"@toast-ui/chart","commonjs2":"@toast-ui/chart","amd":"@toast-ui/chart","root":["toastui","Chart"]}
var chart_root_toastui_Chart_ = __nested_webpack_require_230323__(203);
var chart_root_toastui_Chart_default = /*#__PURE__*/__nested_webpack_require_230323__.n(chart_root_toastui_Chart_);
// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isString.js
var isString = __nested_webpack_require_230323__(994);
var isString_default = /*#__PURE__*/__nested_webpack_require_230323__.n(isString);
// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isUndefined.js
var isUndefined = __nested_webpack_require_230323__(895);
var isUndefined_default = /*#__PURE__*/__nested_webpack_require_230323__.n(isUndefined);
// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/array/inArray.js
var inArray = __nested_webpack_require_230323__(187);
var inArray_default = /*#__PURE__*/__nested_webpack_require_230323__.n(inArray);
// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/object/extend.js
var extend = __nested_webpack_require_230323__(867);
var extend_default = /*#__PURE__*/__nested_webpack_require_230323__.n(extend);
// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/ajax/index.js
var ajax = __nested_webpack_require_230323__(863);
var ajax_default = /*#__PURE__*/__nested_webpack_require_230323__.n(ajax);
;// CONCATENATED MODULE: ./src/csv.js
/* eslint-disable */
/*
 CSV-JS - A Comma-Separated Values parser for JS

 Built to rfc4180 standard, with options for adjusting strictness:
    - optional carriage returns for non-microsoft sources
    - automatically type-cast numeric an boolean values
    - relaxed mode which: ignores blank lines, ignores gargabe following quoted tokens, does not enforce a consistent record length

 Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 Author Greg Kindel (twitter @gkindel), 2014
 */
/**
 * @modifier NHN FE Development Lab <dl_javascript@nhn.com>
 */

/**
 * @name CSV
 * @namespace
 * @ignore
 */
// implemented as a singleton because JS is single threaded
var CSV = {};
CSV.RELAXED = false;
CSV.IGNORE_RECORD_LENGTH = false;
CSV.IGNORE_QUOTES = false;
CSV.LINE_FEED_OK = true;
CSV.CARRIAGE_RETURN_OK = true;
CSV.DETECT_TYPES = true;
CSV.IGNORE_QUOTE_WHITESPACE = true;
CSV.DEBUG = false;
CSV.COLUMN_SEPARATOR = ',';
CSV.ERROR_EOF = 'UNEXPECTED_END_OF_FILE';
CSV.ERROR_CHAR = 'UNEXPECTED_CHARACTER';
CSV.ERROR_EOL = 'UNEXPECTED_END_OF_RECORD';
CSV.WARN_SPACE = 'UNEXPECTED_WHITESPACE'; // not per spec, but helps debugging
var QUOTE = '"', CR = '\r', LF = '\n', SPACE = ' ', TAB = '\t';
// states
var PRE_TOKEN = 0, MID_TOKEN = 1, POST_TOKEN = 2, POST_RECORD = 4;
/**
 * @name CSV.parse
 * @function
 * @description rfc4180 standard csv parse
 * with options for strictness and data type conversion
 * By default, will automatically type-cast numeric an boolean values.
 * @param {String} str A CSV string
 * @return {Array} An array records, each of which is an array of scalar values.
 * @example
 * // simple
 * var rows = CSV.parse("one,two,three\nfour,five,six")
 * // rows equals [["one","two","three"],["four","five","six"]]
 * @example
 * // Though not a jQuery plugin, it is recommended to use with the $.ajax pipe() method:
 * $.get("csv.txt")
 *    .pipe( CSV.parse )
 *    .done( function(rows) {
 *        for( var i =0; i < rows.length; i++){
 *            console.log(rows[i])
 *        }
 *  });
 * @see http://www.ietf.org/rfc/rfc4180.txt
 */
CSV.parse = function (str) {
    var result = (CSV.result = []);
    CSV.COLUMN_SEPARATOR =
        CSV.COLUMN_SEPARATOR instanceof RegExp
            ? new RegExp('^' + CSV.COLUMN_SEPARATOR.source)
            : CSV.COLUMN_SEPARATOR;
    CSV.offset = 0;
    CSV.str = str;
    CSV.record_begin();
    CSV.debug('parse()', str);
    var c;
    while (1) {
        // pull char
        c = str[CSV.offset++];
        CSV.debug('c', c);
        // detect eof
        if (c == null) {
            if (CSV.escaped) {
                CSV.error(CSV.ERROR_EOF);
            }
            if (CSV.record) {
                CSV.token_end();
                CSV.record_end();
            }
            CSV.debug('...bail', c, CSV.state, CSV.record);
            CSV.reset();
            break;
        }
        if (CSV.record == null) {
            // if relaxed mode, ignore blank lines
            if (CSV.RELAXED && (c == LF || (c == CR && str[CSV.offset + 1] == LF))) {
                continue;
            }
            CSV.record_begin();
        }
        // pre-token: look for start of escape sequence
        if (CSV.state == PRE_TOKEN) {
            if ((c === SPACE || c === TAB) && CSV.next_nonspace() == QUOTE) {
                if (CSV.RELAXED || CSV.IGNORE_QUOTE_WHITESPACE) {
                    continue;
                }
                else {
                    // not technically an error, but ambiguous and hard to debug otherwise
                    CSV.warn(CSV.WARN_SPACE);
                }
            }
            if (c == QUOTE && !CSV.IGNORE_QUOTES) {
                CSV.debug('...escaped start', c);
                CSV.escaped = true;
                CSV.state = MID_TOKEN;
                continue;
            }
            CSV.state = MID_TOKEN;
        }
        // mid-token and escaped, look for sequences and end quote
        if (CSV.state == MID_TOKEN && CSV.escaped) {
            if (c == QUOTE) {
                if (str[CSV.offset] == QUOTE) {
                    CSV.debug('...escaped quote', c);
                    CSV.token += QUOTE;
                    CSV.offset++;
                }
                else {
                    CSV.debug('...escaped end', c);
                    CSV.escaped = false;
                    CSV.state = POST_TOKEN;
                }
            }
            else {
                CSV.token += c;
                CSV.debug('...escaped add', c, CSV.token);
            }
            continue;
        }
        // fall-through: mid-token or post-token, not escaped
        if (c == CR) {
            if (str[CSV.offset] == LF)
                CSV.offset++;
            else if (!CSV.CARRIAGE_RETURN_OK)
                CSV.error(CSV.ERROR_CHAR);
            CSV.token_end();
            CSV.record_end();
        }
        else if (c == LF) {
            if (!(CSV.LINE_FEED_OK || CSV.RELAXED))
                CSV.error(CSV.ERROR_CHAR);
            CSV.token_end();
            CSV.record_end();
        }
        else if (CSV.test_regex_separator(str) || CSV.COLUMN_SEPARATOR == c) {
            CSV.token_end();
        }
        else if (CSV.state == MID_TOKEN) {
            CSV.token += c;
            CSV.debug('...add', c, CSV.token);
        }
        else if (c === SPACE || c === TAB) {
            if (!CSV.IGNORE_QUOTE_WHITESPACE)
                CSV.error(CSV.WARN_SPACE);
        }
        else if (!CSV.RELAXED) {
            CSV.error(CSV.ERROR_CHAR);
        }
    }
    return result;
};
/**
 * @name CSV.stream
 * @function
 * @description stream a CSV file
 * @example
 * node -e "c=require('CSV-JS');require('fs').createReadStream('csv.txt').pipe(c.stream()).pipe(c.stream.json()).pipe(process.stdout)"
 * @ignore
 */
CSV.stream = function () {
    var stream = __nested_webpack_require_230323__(769);
    var s = new stream.Transform({ objectMode: true });
    s.EOL = '\n';
    s.prior = '';
    s.emitter = (function (s) {
        return function (e) {
            s.push(CSV.parse(e + s.EOL));
        };
    })(s);
    s._transform = function (chunk, encoding, done) {
        var lines = this.prior == ''
            ? chunk.toString().split(this.EOL)
            : (this.prior + chunk.toString()).split(this.EOL);
        this.prior = lines.pop();
        lines.forEach(this.emitter);
        done();
    };
    s._flush = function (done) {
        if (this.prior != '') {
            this.emitter(this.prior);
            this.prior = '';
        }
        done();
    };
    return s;
};
CSV.test_regex_separator = function (str) {
    if (!(CSV.COLUMN_SEPARATOR instanceof RegExp)) {
        return false;
    }
    var match;
    str = str.slice(CSV.offset - 1);
    match = CSV.COLUMN_SEPARATOR.exec(str);
    if (match) {
        CSV.offset += match[0].length - 1;
    }
    return match !== null;
};
CSV.stream.json = function () {
    var os = __nested_webpack_require_230323__(983);
    var stream = __nested_webpack_require_230323__(769);
    var s = new streamTransform({ objectMode: true });
    s._transform = function (chunk, encoding, done) {
        s.push(JSON.stringify(chunk.toString()) + os.EOL);
        done();
    };
    return s;
};
CSV.reset = function () {
    CSV.state = null;
    CSV.token = null;
    CSV.escaped = null;
    CSV.record = null;
    CSV.offset = null;
    CSV.result = null;
    CSV.str = null;
};
CSV.next_nonspace = function () {
    var i = CSV.offset;
    var c;
    while (i < CSV.str.length) {
        c = CSV.str[i++];
        if (!(c == SPACE || c === TAB)) {
            return c;
        }
    }
    return null;
};
CSV.record_begin = function () {
    CSV.escaped = false;
    CSV.record = [];
    CSV.token_begin();
    CSV.debug('record_begin');
};
CSV.record_end = function () {
    CSV.state = POST_RECORD;
    if (!(CSV.IGNORE_RECORD_LENGTH || CSV.RELAXED) &&
        CSV.result.length > 0 &&
        CSV.record.length != CSV.result[0].length) {
        CSV.error(CSV.ERROR_EOL);
    }
    CSV.result.push(CSV.record);
    CSV.debug('record end', CSV.record);
    CSV.record = null;
};
CSV.resolve_type = function (token) {
    if (token.match(/^[-+]?[0-9]+(\.[0-9]+)?([eE][-+]?[0-9]+)?$/)) {
        token = parseFloat(token);
    }
    else if (token.match(/^(true|false)$/i)) {
        token = Boolean(token.match(/true/i));
    }
    else if (token === 'undefined') {
        token = undefined;
    }
    else if (token === 'null') {
        token = null;
    }
    return token;
};
CSV.token_begin = function () {
    CSV.state = PRE_TOKEN;
    // considered using array, but http://www.sitepen.com/blog/2008/05/09/string-performance-an-analysis/
    CSV.token = '';
};
CSV.token_end = function () {
    if (CSV.DETECT_TYPES) {
        CSV.token = CSV.resolve_type(CSV.token);
    }
    CSV.record.push(CSV.token);
    CSV.debug('token end', CSV.token);
    CSV.token_begin();
};
CSV.debug = function () {
    if (CSV.DEBUG)
        console.log(arguments);
};
CSV.dump = function (msg) {
    return [
        msg,
        'at char',
        CSV.offset,
        ':',
        CSV.str
            .substr(CSV.offset - 50, 50)
            .replace(/\r/gm, '\\r')
            .replace(/\n/gm, '\\n')
            .replace(/\t/gm, '\\t')
    ].join(' ');
};
CSV.error = function (err) {
    var msg = CSV.dump(err);
    CSV.reset();
    throw msg;
};
CSV.warn = function (err) {
    if (!CSV.DEBUG) {
        return;
    }
    var msg = CSV.dump(err);
    try {
        console.warn(msg);
        return;
    }
    catch (e) { }
    try {
        console.log(msg);
    }
    catch (e) { }
};
/* harmony default export */ var csv = (CSV);

;// CONCATENATED MODULE: ./src/util.ts
function trimKeepingTabs(text) {
    return text.replace(/(^(\s*[\n\r])+)|([\n\r]+\s*$)/g, '');
}
function isNumeric(text) {
    var mayBeNum = Number(text);
    return !isNaN(mayBeNum) && isFinite(mayBeNum);
}
function clamp(value, min, max) {
    var _a;
    if (min > max) {
        _a = [min, max], max = _a[0], min = _a[1];
    }
    return Math.max(min, Math.min(value, max));
}

;// CONCATENATED MODULE: ./src/index.ts
var __assign = ( false) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};





// @ts-ignore



// csv configuration
csv.IGNORE_QUOTE_WHITESPACE = false;
csv.IGNORE_RECORD_LENGTH = true;
csv.DETECT_TYPES = false;
var reEOL = /[\n\r]/;
var reGroupByDelimiter = /([^:]+)?:?(.*)/;
var DEFAULT_DELIMITER = /\s+/;
var DELIMITERS = [',', '\t'];
var MINIMUM_DELIM_CNT = 2;
var SUPPORTED_CHART_TYPES = ['bar', 'column', 'line', 'area', 'pie'];
var CATEGORY_CHART_TYPES = ['line', 'area'];
var DEFAULT_DIMENSION_OPTIONS = {
    minWidth: 0,
    maxWidth: Infinity,
    minHeight: 0,
    maxHeight: Infinity,
    height: 'auto',
    width: 'auto',
};
var RESERVED_KEYS = ['type', 'url'];
var chart = {
    bar: (chart_root_toastui_Chart_default()).barChart,
    column: (chart_root_toastui_Chart_default()).columnChart,
    area: (chart_root_toastui_Chart_default()).areaChart,
    line: (chart_root_toastui_Chart_default()).lineChart,
    pie: (chart_root_toastui_Chart_default()).pieChart,
};
var chartMap = {};
function parse(text, callback) {
    var _a;
    text = trimKeepingTabs(text);
    var _b = text.split(/\n{2,}/), firstTexts = _b[0], secondTexts = _b[1];
    var urlOptions = parseToChartOption(firstTexts);
    var url = (_a = urlOptions === null || urlOptions === void 0 ? void 0 : urlOptions.editorChart) === null || _a === void 0 ? void 0 : _a.url;
    // if first text is `options` and has `url` option, fetch data from url
    if (isString_default()(url)) {
        // url option provided
        // fetch data from url
        var success = function (_a) {
            var data = _a.data;
            callback({ data: parseToChartData(data), options: parseToChartOption(firstTexts) });
        };
        var error = function () { return callback(); };
        ajax_default().get(url, { success: success, error: error });
    }
    else {
        var data = parseToChartData(firstTexts);
        var options = parseToChartOption(secondTexts);
        callback({ data: data, options: options });
    }
}
function detectDelimiter(text) {
    var delimiter = DEFAULT_DELIMITER;
    var delimCnt = 0;
    text = trimKeepingTabs(text);
    DELIMITERS.forEach(function (delim) {
        var matched = text.match(new RegExp(delim, 'g'));
        if ((matched === null || matched === void 0 ? void 0 : matched.length) > Math.max(MINIMUM_DELIM_CNT, delimCnt)) {
            delimiter = delim;
            delimCnt = matched.length;
        }
    });
    return delimiter;
}
function parseToChartData(text, delimiter) {
    // trim all heading/trailing blank lines
    text = trimKeepingTabs(text);
    // @ts-ignore
    csv.COLUMN_SEPARATOR = delimiter || detectDelimiter(text);
    var dsv = csv.parse(text);
    // trim all values in 2D array
    dsv = dsv.map(function (arr) { return arr.map(function (val) { return val.trim(); }); });
    // test a first row for legends. ['anything', '1', '2', '3'] === false, ['anything', 't1', '2', 't3'] === true
    var hasLegends = dsv[0]
        .filter(function (_, i) { return i > 0; })
        .reduce(function (hasNaN, item) { return hasNaN || !isNumeric(item); }, false);
    var legends = hasLegends ? dsv.shift() : [];
    // test a first column for categories
    var hasCategories = dsv.slice(1).reduce(function (hasNaN, row) { return hasNaN || !isNumeric(row[0]); }, false);
    var categories = hasCategories ? dsv.map(function (arr) { return arr.shift(); }) : [];
    if (hasCategories) {
        legends.shift();
    }
    // transpose dsv, parse number
    // [['1','2','3']    [[1,4,7]
    //  ['4','5','6'] =>  [2,5,8]
    //  ['7','8','9']]    [3,6,9]]
    var tdsv = dsv[0].map(function (_, i) { return dsv.map(function (x) { return parseFloat(x[i]); }); });
    // make series
    var series = tdsv.map(function (data, i) {
        return hasLegends
            ? {
                name: legends[i],
                data: data,
            }
            : {
                data: data,
            };
    });
    return { categories: categories, series: series };
}
function createOptionKeys(keyString) {
    var keys = keyString.trim().split('.');
    var topKey = keys[0];
    if (inArray_default()(topKey, RESERVED_KEYS) >= 0) {
        // reserved keys for chart plugin option
        keys.unshift('editorChart');
    }
    else if (keys.length === 1) {
        // short names for `chart`
        keys.unshift('chart');
    }
    else if (topKey === 'x' || topKey === 'y') {
        // short-handed keys
        keys[0] = topKey + "Axis";
    }
    return keys;
}
function parseToChartOption(text) {
    var options = {};
    if (!isUndefined_default()(text)) {
        var lineTexts = text.split(reEOL);
        lineTexts.forEach(function (lineText) {
            var matched = lineText.match(reGroupByDelimiter);
            if (matched) {
                // keyString can be nested object keys
                // ex) key1.key2.key3: value
                // eslint-disable-next-line prefer-const
                var keyString = matched[1], value_1 = matched[2];
                if (value_1) {
                    try {
                        value_1 = JSON.parse(value_1.trim());
                    }
                    catch (e) {
                        value_1 = value_1.trim();
                    }
                    var keys_1 = createOptionKeys(keyString);
                    var refOptions_1 = options;
                    keys_1.forEach(function (key, index) {
                        refOptions_1[key] = refOptions_1[key] || (keys_1.length - 1 === index ? value_1 : {});
                        // should change the ref option object to assign nested property
                        refOptions_1 = refOptions_1[key];
                    });
                }
            }
        });
    }
    return options;
}
function getAdjustedDimension(size, containerWidth) {
    return size === 'auto' ? containerWidth : size;
}
function getChartDimension(chartOptions, pluginOptions, chartContainer) {
    var dimensionOptions = extend_default()(__assign({}, DEFAULT_DIMENSION_OPTIONS), pluginOptions);
    var maxWidth = dimensionOptions.maxWidth, minWidth = dimensionOptions.minWidth, maxHeight = dimensionOptions.maxHeight, minHeight = dimensionOptions.minHeight;
    // if no width or height specified, set width and height to container width
    var containerWidth = chartContainer.getBoundingClientRect().width;
    var _a = chartOptions.chart, _b = _a.width, width = _b === void 0 ? dimensionOptions.width : _b, _c = _a.height, height = _c === void 0 ? dimensionOptions.height : _c;
    width = getAdjustedDimension(width, containerWidth);
    height = getAdjustedDimension(height, containerWidth);
    return {
        width: clamp(width, minWidth, maxWidth),
        height: clamp(height, minHeight, maxHeight),
    };
}
function setDefaultOptions(chartOptions, pluginOptions, chartContainer) {
    chartOptions = extend_default()({
        editorChart: {},
        chart: {},
        exportMenu: {},
    }, chartOptions);
    var _a = getChartDimension(chartOptions, pluginOptions, chartContainer), width = _a.width, height = _a.height;
    chartOptions.chart.width = width;
    chartOptions.chart.height = height;
    // default chart type
    chartOptions.editorChart.type = chartOptions.editorChart.type || 'column';
    // default visibility of export menu
    chartOptions.exportMenu.visible = !!chartOptions.exportMenu.visible;
    return chartOptions;
}
function destroyChart() {
    Object.keys(chartMap).forEach(function (id) {
        var container = document.querySelector("[data-chart-id=" + id + "]");
        if (!container) {
            chartMap[id].destroy();
            delete chartMap[id];
        }
    });
}
function renderChart(id, text, usageStatistics, pluginOptions) {
    // should draw the chart after rendering container element
    var chartContainer = document.querySelector("[data-chart-id=" + id + "]");
    destroyChart();
    if (chartContainer) {
        try {
            parse(text, function (parsedInfo) {
                var _a = parsedInfo || {}, data = _a.data, options = _a.options;
                var chartOptions = setDefaultOptions(options, pluginOptions, chartContainer);
                var chartType = chartOptions.editorChart.type;
                if (!data ||
                    (CATEGORY_CHART_TYPES.indexOf(chartType) > -1 &&
                        data.categories.length !== data.series[0].data.length)) {
                    chartContainer.innerHTML = 'invalid chart data';
                }
                else if (SUPPORTED_CHART_TYPES.indexOf(chartType) < 0) {
                    chartContainer.innerHTML = "invalid chart type. type: bar, column, line, area, pie";
                }
                else {
                    var toastuiChart = chart[chartType];
                    chartOptions.usageStatistics = usageStatistics;
                    // @ts-ignore
                    chartMap[id] = toastuiChart({ el: chartContainer, data: data, options: chartOptions });
                }
            });
        }
        catch (e) {
            chartContainer.innerHTML = 'invalid chart data';
        }
    }
}
function generateId() {
    return "chart-" + Math.random().toString(36).substr(2, 10);
}
/**
 * Chart plugin
 * @param {Object} context - plugin context for communicating with editor
 * @param {Object} options - chart options
 * @param {number} [options.minWidth=0] - minimum width
 * @param {number} [options.minHeight=0] - minimum height
 * @param {number} [options.maxWidth=Infinity] - maximum width
 * @param {number} [options.maxHeight=Infinity] - maximum height
 * @param {number|string} [options.width='auto'] - default width
 * @param {number|string} [options.height='auto'] - default height
 */
function chartPlugin(_a, options) {
    var _b = _a.usageStatistics, usageStatistics = _b === void 0 ? true : _b;
    return {
        toHTMLRenderers: {
            chart: function (node) {
                var id = generateId();
                setTimeout(function () {
                    renderChart(id, node.literal, usageStatistics, options);
                });
                return [
                    {
                        type: 'openTag',
                        tagName: 'div',
                        outerNewLine: true,
                        attributes: { 'data-chart-id': id },
                    },
                    { type: 'closeTag', tagName: 'div', outerNewLine: true },
                ];
            },
        },
    };
}

}();
__nested_webpack_exports__ = __nested_webpack_exports__.default;
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@toast-ui/editor-plugin-code-syntax-highlight/dist/toastui-editor-plugin-code-syntax-highlight.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@toast-ui/editor-plugin-code-syntax-highlight/dist/toastui-editor-plugin-code-syntax-highlight.js ***!
  \************************************************************************************************************************/
/***/ ((module) => {

/*!
 * TOAST UI Editor : Code Syntax Highlight Plugin
 * @version 3.1.0 | Fri Aug 05 2022
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 928:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_342__) {

/* eslint-disable complexity */
/**
 * @fileoverview Returns the first index at which a given element can be found in the array.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isArray = __nested_webpack_require_342__(322);

/**
 * @module array
 */

/**
 * Returns the first index at which a given element can be found in the array
 * from start index(default 0), or -1 if it is not present.
 * It compares searchElement to elements of the Array using strict equality
 * (the same method used by the ===, or triple-equals, operator).
 * @param {*} searchElement Element to locate in the array
 * @param {Array} array Array that will be traversed.
 * @param {number} startIndex Start index in array for searching (default 0)
 * @returns {number} the First index at which a given element, or -1 if it is not present
 * @memberof module:array
 * @example
 * // ES6
 * import inArray from 'tui-code-snippet/array/inArray';
 * 
 * // CommonJS
 * const inArray = require('tui-code-snippet/array/inArray');
 *
 * const arr = ['one', 'two', 'three', 'four'];
 * const idx1 = inArray('one', arr, 3); // -1
 * const idx2 = inArray('one', arr); // 0
 */
function inArray(searchElement, array, startIndex) {
  var i;
  var length;
  startIndex = startIndex || 0;

  if (!isArray(array)) {
    return -1;
  }

  if (Array.prototype.indexOf) {
    return Array.prototype.indexOf.call(array, searchElement, startIndex);
  }

  length = array.length;
  for (i = startIndex; startIndex >= 0 && i < length; i += 1) {
    if (array[i] === searchElement) {
      return i;
    }
  }

  return -1;
}

module.exports = inArray;


/***/ }),

/***/ 690:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_2057__) {

/**
 * @fileoverview Execute the provided callback once for each property of object(or element of array) which actually exist.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isArray = __nested_webpack_require_2057__(322);
var forEachArray = __nested_webpack_require_2057__(893);
var forEachOwnProperties = __nested_webpack_require_2057__(956);

/**
 * @module collection
 */

/**
 * Execute the provided callback once for each property of object(or element of array) which actually exist.
 * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of example).
 * If the callback function returns false, the loop will be stopped.
 * Callback function(iteratee) is invoked with three arguments:
 *  1) The value of the property(or The value of the element)
 *  2) The name of the property(or The index of the element)
 *  3) The object being traversed
 * @param {Object} obj The object that will be traversed
 * @param {function} iteratee Callback function
 * @param {Object} [context] Context(this) of callback function
 * @memberof module:collection
 * @example
 * // ES6
 * import forEach from 'tui-code-snippet/collection/forEach'; 
 * 
 * // CommonJS
 * const forEach = require('tui-code-snippet/collection/forEach'); 
 *
 * let sum = 0;
 *
 * forEach([1,2,3], function(value){
 *   sum += value;
 * });
 * alert(sum); // 6
 *
 * // In case of Array-like object
 * const array = Array.prototype.slice.call(arrayLike); // change to array
 * forEach(array, function(value){
 *   sum += value;
 * });
 */
function forEach(obj, iteratee, context) {
  if (isArray(obj)) {
    forEachArray(obj, iteratee, context);
  } else {
    forEachOwnProperties(obj, iteratee, context);
  }
}

module.exports = forEach;


/***/ }),

/***/ 893:
/***/ (function(module) {

/**
 * @fileoverview Execute the provided callback once for each element present in the array(or Array-like object) in ascending order.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Execute the provided callback once for each element present
 * in the array(or Array-like object) in ascending order.
 * If the callback function returns false, the loop will be stopped.
 * Callback function(iteratee) is invoked with three arguments:
 *  1) The value of the element
 *  2) The index of the element
 *  3) The array(or Array-like object) being traversed
 * @param {Array|Arguments|NodeList} arr The array(or Array-like object) that will be traversed
 * @param {function} iteratee Callback function
 * @param {Object} [context] Context(this) of callback function
 * @memberof module:collection
 * @example
 * // ES6
 * import forEachArray from 'tui-code-snippet/collection/forEachArray';
 * 
 * // CommonJS
 * const forEachArray = require('tui-code-snippet/collection/forEachArray'); 
 *
 * let sum = 0;
 *
 * forEachArray([1,2,3], function(value){
 *   sum += value;
 * });
 * alert(sum); // 6
 */
function forEachArray(arr, iteratee, context) {
  var index = 0;
  var len = arr.length;

  context = context || null;

  for (; index < len; index += 1) {
    if (iteratee.call(context, arr[index], index, arr) === false) {
      break;
    }
  }
}

module.exports = forEachArray;


/***/ }),

/***/ 956:
/***/ (function(module) {

/**
 * @fileoverview Execute the provided callback once for each property of object which actually exist.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Execute the provided callback once for each property of object which actually exist.
 * If the callback function returns false, the loop will be stopped.
 * Callback function(iteratee) is invoked with three arguments:
 *  1) The value of the property
 *  2) The name of the property
 *  3) The object being traversed
 * @param {Object} obj The object that will be traversed
 * @param {function} iteratee  Callback function
 * @param {Object} [context] Context(this) of callback function
 * @memberof module:collection
 * @example
 * // ES6
 * import forEachOwnProperties from 'tui-code-snippet/collection/forEachOwnProperties';
 * 
 * // CommonJS
 * const forEachOwnProperties = require('tui-code-snippet/collection/forEachOwnProperties'); 
 *
 * let sum = 0;
 *
 * forEachOwnProperties({a:1,b:2,c:3}, function(value){
 *   sum += value;
 * });
 * alert(sum); // 6
 */
function forEachOwnProperties(obj, iteratee, context) {
  var key;

  context = context || null;

  for (key in obj) {
    if (obj.hasOwnProperty(key)) {
      if (iteratee.call(context, obj[key], key, obj) === false) {
        break;
      }
    }
  }
}

module.exports = forEachOwnProperties;


/***/ }),

/***/ 990:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_6738__) {

/**
 * @fileoverview Transform the Array-like object to Array.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var forEachArray = __nested_webpack_require_6738__(893);

/**
 * Transform the Array-like object to Array.
 * In low IE (below 8), Array.prototype.slice.call is not perfect. So, try-catch statement is used.
 * @param {*} arrayLike Array-like object
 * @returns {Array} Array
 * @memberof module:collection
 * @example
 * // ES6
 * import toArray from 'tui-code-snippet/collection/toArray'; 
 * 
 * // CommonJS
 * const toArray = require('tui-code-snippet/collection/toArray'); 
 *
 * const arrayLike = {
 *   0: 'one',
 *   1: 'two',
 *   2: 'three',
 *   3: 'four',
 *   length: 4
 * };
 * const result = toArray(arrayLike);
 *
 * alert(result instanceof Array); // true
 * alert(result); // one,two,three,four
 */
function toArray(arrayLike) {
  var arr;
  try {
    arr = Array.prototype.slice.call(arrayLike);
  } catch (e) {
    arr = [];
    forEachArray(arrayLike, function(value) {
      arr.push(value);
    });
  }

  return arr;
}

module.exports = toArray;


/***/ }),

/***/ 24:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_7920__) {

/**
 * @fileoverview Set className value
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isArray = __nested_webpack_require_7920__(322);
var isUndefined = __nested_webpack_require_7920__(929);

/**
 * Set className value
 * @param {(HTMLElement|SVGElement)} element - target element
 * @param {(string|string[])} cssClass - class names
 * @private
 */
function setClassName(element, cssClass) {
  cssClass = isArray(cssClass) ? cssClass.join(' ') : cssClass;

  cssClass = cssClass.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

  if (isUndefined(element.className.baseVal)) {
    element.className = cssClass;

    return;
  }

  element.className.baseVal = cssClass;
}

module.exports = setClassName;


/***/ }),

/***/ 204:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_8723__) {

/**
 * @fileoverview Add css class to element
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var forEach = __nested_webpack_require_8723__(690);
var inArray = __nested_webpack_require_8723__(928);
var getClass = __nested_webpack_require_8723__(902);
var setClassName = __nested_webpack_require_8723__(24);

/**
 * domUtil module
 * @module domUtil
 */

/**
 * Add css class to element
 * @param {(HTMLElement|SVGElement)} element - target element
 * @param {...string} cssClass - css classes to add
 * @memberof module:domUtil
 */
function addClass(element) {
  var cssClass = Array.prototype.slice.call(arguments, 1);
  var classList = element.classList;
  var newClass = [];
  var origin;

  if (classList) {
    forEach(cssClass, function(name) {
      element.classList.add(name);
    });

    return;
  }

  origin = getClass(element);

  if (origin) {
    cssClass = [].concat(origin.split(/\s+/), cssClass);
  }

  forEach(cssClass, function(cls) {
    if (inArray(cls, newClass) < 0) {
      newClass.push(cls);
    }
  });

  setClassName(element, newClass);
}

module.exports = addClass;


/***/ }),

/***/ 522:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_9889__) {

/**
 * @fileoverview Setting element style
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isString = __nested_webpack_require_9889__(758);
var forEach = __nested_webpack_require_9889__(690);

/**
 * Setting element style
 * @param {(HTMLElement|SVGElement)} element - element to setting style
 * @param {(string|object)} key - style prop name or {prop: value} pair object
 * @param {string} [value] - style value
 * @memberof module:domUtil
 */
function css(element, key, value) {
  var style = element.style;

  if (isString(key)) {
    style[key] = value;

    return;
  }

  forEach(key, function(v, k) {
    style[k] = v;
  });
}

module.exports = css;


/***/ }),

/***/ 902:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_10642__) {

/**
 * @fileoverview Get HTML element's design classes.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isUndefined = __nested_webpack_require_10642__(929);

/**
 * Get HTML element's design classes.
 * @param {(HTMLElement|SVGElement)} element target element
 * @returns {string} element css class name
 * @memberof module:domUtil
 */
function getClass(element) {
  if (!element || !element.className) {
    return '';
  }

  if (isUndefined(element.className.baseVal)) {
    return element.className;
  }

  return element.className.baseVal;
}

module.exports = getClass;


/***/ }),

/***/ 714:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_11322__) {

/**
 * @fileoverview Check element has specific css class
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var inArray = __nested_webpack_require_11322__(928);
var getClass = __nested_webpack_require_11322__(902);

/**
 * Check element has specific css class
 * @param {(HTMLElement|SVGElement)} element - target element
 * @param {string} cssClass - css class
 * @returns {boolean}
 * @memberof module:domUtil
 */
function hasClass(element, cssClass) {
  var origin;

  if (element.classList) {
    return element.classList.contains(cssClass);
  }

  origin = getClass(element).split(/\s+/);

  return inArray(cssClass, origin) > -1;
}

module.exports = hasClass;


/***/ }),

/***/ 462:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_12075__) {

/**
 * @fileoverview Remove css class from element
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var forEachArray = __nested_webpack_require_12075__(893);
var inArray = __nested_webpack_require_12075__(928);
var getClass = __nested_webpack_require_12075__(902);
var setClassName = __nested_webpack_require_12075__(24);

/**
 * Remove css class from element
 * @param {(HTMLElement|SVGElement)} element - target element
 * @param {...string} cssClass - css classes to remove
 * @memberof module:domUtil
 */
function removeClass(element) {
  var cssClass = Array.prototype.slice.call(arguments, 1);
  var classList = element.classList;
  var origin, newClass;

  if (classList) {
    forEachArray(cssClass, function(name) {
      classList.remove(name);
    });

    return;
  }

  origin = getClass(element).split(/\s+/);
  newClass = [];
  forEachArray(origin, function(name) {
    if (inArray(name, cssClass) < 0) {
      newClass.push(name);
    }
  });

  setClassName(element, newClass);
}

module.exports = removeClass;


/***/ }),

/***/ 322:
/***/ (function(module) {

/**
 * @fileoverview Check whether the given variable is an instance of Array or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check whether the given variable is an instance of Array or not.
 * If the given variable is an instance of Array, return true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is array instance?
 * @memberof module:type
 */
function isArray(obj) {
  return obj instanceof Array;
}

module.exports = isArray;


/***/ }),

/***/ 294:
/***/ (function(module) {

/**
 * @fileoverview Check whether the given variable is a function or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check whether the given variable is a function or not.
 * If the given variable is a function, return true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is function?
 * @memberof module:type
 */
function isFunction(obj) {
  return obj instanceof Function;
}

module.exports = isFunction;


/***/ }),

/***/ 758:
/***/ (function(module) {

/**
 * @fileoverview Check whether the given variable is a string or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check whether the given variable is a string or not.
 * If the given variable is a string, return true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is string?
 * @memberof module:type
 */
function isString(obj) {
  return typeof obj === 'string' || obj instanceof String;
}

module.exports = isString;


/***/ }),

/***/ 929:
/***/ (function(module) {

/**
 * @fileoverview Check whether the given variable is undefined or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check whether the given variable is undefined or not.
 * If the given variable is undefined, returns true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is undefined?
 * @memberof module:type
 */
function isUndefined(obj) {
  return obj === undefined; // eslint-disable-line no-undefined
}

module.exports = isUndefined;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_15409__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_15409__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__nested_webpack_require_15409__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__nested_webpack_require_15409__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__nested_webpack_require_15409__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__nested_webpack_require_15409__.o(definition, key) && !__nested_webpack_require_15409__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__nested_webpack_require_15409__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/************************************************************************/
var __nested_webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
!function() {

// EXPORTS
__nested_webpack_require_15409__.d(__nested_webpack_exports__, {
  "default": function() { return /* binding */ src; }
});

// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isFunction.js
var isFunction = __nested_webpack_require_15409__(294);
var isFunction_default = /*#__PURE__*/__nested_webpack_require_15409__.n(isFunction);
;// CONCATENATED MODULE: ./src/renderers/toHTMLRenderers.ts
var BACKTICK_COUNT = 3;
function getHTMLRenderers(prism) {
    return {
        codeBlock: function (node) {
            var _a = node, fenceLength = _a.fenceLength, info = _a.info;
            var infoWords = info ? info.split(/\s+/) : [];
            var preClasses = [];
            var codeAttrs = {};
            if (fenceLength > BACKTICK_COUNT) {
                codeAttrs['data-backticks'] = fenceLength;
            }
            var content = node.literal;
            if (infoWords.length && infoWords[0].length) {
                var lang = infoWords[0];
                preClasses.push("lang-" + lang);
                codeAttrs['data-language'] = lang;
                var registeredLang = prism.languages[lang];
                if (registeredLang) {
                    content = prism.highlight(node.literal, registeredLang, lang);
                }
            }
            return [
                { type: 'openTag', tagName: 'pre', classNames: preClasses },
                { type: 'openTag', tagName: 'code', attributes: codeAttrs },
                { type: 'html', content: content },
                { type: 'closeTag', tagName: 'code' },
                { type: 'closeTag', tagName: 'pre' },
            ];
        },
    };
}

// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isString.js
var isString = __nested_webpack_require_15409__(758);
var isString_default = /*#__PURE__*/__nested_webpack_require_15409__.n(isString);
;// CONCATENATED MODULE: ./src/utils/common.ts
function flatten(arr) {
    return arr.reduce(function (a, b) { return a.concat(Array.isArray(b) ? flatten(b) : b); }, []);
}

;// CONCATENATED MODULE: ./src/plugins/codeSyntaxHighlighting.ts
var __spreadArray = ( false) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};


var NODE_TYPE = 'codeBlock';
function findCodeBlocks(doc) {
    var descendants = [];
    doc.descendants(function (node, pos) {
        if (node.isBlock && node.type.name === NODE_TYPE) {
            descendants.push({ node: node, pos: pos });
        }
    });
    return descendants;
}
function parseTokens(tokens, classNames) {
    if (classNames === void 0) { classNames = []; }
    if (isString_default()(tokens)) {
        return [{ text: tokens, classes: classNames }];
    }
    return tokens.map(function (token) {
        var _a = token, type = _a.type, alias = _a.alias;
        var typeClassNames = [];
        var aliasClassNames = [];
        if (type) {
            typeClassNames = ['token', type];
        }
        if (alias) {
            aliasClassNames = isString_default()(alias) ? [alias] : alias;
        }
        var classes = __spreadArray(__spreadArray(__spreadArray([], classNames), typeClassNames), aliasClassNames);
        return isString_default()(token)
            ? {
                text: token,
                classes: classes,
            }
            : parseTokens(token.content, classes);
    });
}
function getDecorations(doc, context, prism) {
    var pmView = context.pmView;
    var decorations = [];
    var codeBlocks = findCodeBlocks(doc);
    codeBlocks.forEach(function (_a) {
        var pos = _a.pos, node = _a.node;
        var language = node.attrs.language;
        var registeredLang = prism.languages[language];
        var prismTokens = registeredLang ? prism.tokenize(node.textContent, registeredLang) : [];
        var nodeInfos = flatten(parseTokens(prismTokens));
        var startPos = pos + 1;
        nodeInfos.forEach(function (_a) {
            var text = _a.text, classes = _a.classes;
            var from = startPos;
            var to = from + text.length;
            startPos = to;
            var classNames = classes.join(' ');
            var decoration = pmView.Decoration.inline(from, to, {
                class: classNames,
            });
            if (classNames.length) {
                decorations.push(decoration);
            }
        });
    });
    return pmView.DecorationSet.create(doc, decorations);
}
function codeSyntaxHighlighting(context, prism) {
    return new context.pmState.Plugin({
        state: {
            init: function (_, _a) {
                var doc = _a.doc;
                return getDecorations(doc, context, prism);
            },
            apply: function (tr, set) {
                if (!tr.docChanged) {
                    return set.map(tr.mapping, tr.doc);
                }
                return getDecorations(tr.doc, context, prism);
            },
        },
        props: {
            decorations: function (state) {
                return this.getState(state);
            },
        },
    });
}

// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/addClass.js
var addClass = __nested_webpack_require_15409__(204);
var addClass_default = /*#__PURE__*/__nested_webpack_require_15409__.n(addClass);
;// CONCATENATED MODULE: ./src/utils/dom.ts
function stringToNumber(value) {
    return parseInt(value, 10);
}
function isPositionInBox(style, offsetX, offsetY) {
    var left = stringToNumber(style.left);
    var top = stringToNumber(style.top);
    var width = stringToNumber(style.width) +
        stringToNumber(style.paddingLeft) +
        stringToNumber(style.paddingRight);
    var height = stringToNumber(style.height) +
        stringToNumber(style.paddingTop) +
        stringToNumber(style.paddingBottom);
    return offsetX >= left && offsetX <= left + width && offsetY >= top && offsetY <= top + height;
}
function removeNode(node) {
    if (node.parentNode) {
        node.parentNode.removeChild(node);
    }
}
var CLS_PREFIX = 'toastui-editor-';
function cls() {
    var names = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        names[_i] = arguments[_i];
    }
    return names.map(function (className) { return "" + CLS_PREFIX + className; }).join(' ');
}

// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/css.js
var css = __nested_webpack_require_15409__(522);
var css_default = /*#__PURE__*/__nested_webpack_require_15409__.n(css);
// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/removeClass.js
var removeClass = __nested_webpack_require_15409__(462);
var removeClass_default = /*#__PURE__*/__nested_webpack_require_15409__.n(removeClass);
// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/hasClass.js
var hasClass = __nested_webpack_require_15409__(714);
var hasClass_default = /*#__PURE__*/__nested_webpack_require_15409__.n(hasClass);
// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/collection/toArray.js
var toArray = __nested_webpack_require_15409__(990);
var toArray_default = /*#__PURE__*/__nested_webpack_require_15409__.n(toArray);
// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/array/inArray.js
var inArray = __nested_webpack_require_15409__(928);
var inArray_default = /*#__PURE__*/__nested_webpack_require_15409__.n(inArray);
;// CONCATENATED MODULE: ./src/nodeViews/languageSelectBox.ts







var WRAPPER_CLASS_NAME = 'code-block-language';
var INPUT_CLASS_NANE = 'code-block-language-input';
var LIST_CLASS_NAME = 'code-block-language-list';
var LANG_ATTR = 'data-language';
var CODE_BLOCK_PADDING = 10;
function getButtonsHTML(languages) {
    return languages
        .map(function (language) { return "<button type=\"button\" data-language=\"" + language + "\">" + language + "</button>"; })
        .join('');
}
var LanguageSelectBox = /** @class */ (function () {
    function LanguageSelectBox(rootEl, eventEmitter, languages) {
        var _this = this;
        this.buttons = [];
        this.prevStoredLanguage = '';
        this.onSelectToggleButton = function (ev) {
            var target = ev.target;
            var style = getComputedStyle(target, ':after');
            var offsetX = ev.offsetX, offsetY = ev.offsetY;
            if (isPositionInBox(style, offsetX, offsetY)) {
                ev.preventDefault();
                _this.toggleFocus();
            }
        };
        this.onSelectLanguageButtons = function (ev) {
            var target = ev.target;
            var language = target.getAttribute(LANG_ATTR);
            if (language) {
                _this.selectLanguage(language);
            }
        };
        this.handleKeydown = function (ev) {
            var key = ev.key;
            if (key === 'ArrowUp') {
                _this.selectPrevLanguage();
                ev.preventDefault();
            }
            else if (key === 'ArrowDown') {
                _this.selectNextLanguage();
                ev.preventDefault();
            }
            else if (key === 'Enter' || key === 'Tab') {
                _this.storeInputLanguage();
                ev.preventDefault();
            }
            else {
                _this.hideList();
            }
        };
        this.showLangugaeSelectBox = function (_a, language) {
            var top = _a.top, right = _a.right;
            if (language) {
                _this.setLanguage(language);
            }
            _this.show();
            var width = _this.input.parentElement.getBoundingClientRect().width;
            css_default()(_this.wrapper, {
                top: top + CODE_BLOCK_PADDING + "px",
                left: right - width - CODE_BLOCK_PADDING + "px",
            });
            _this.toggleFocus();
        };
        this.rootEl = rootEl;
        this.eventEmitter = eventEmitter;
        this.languages = languages;
        this.createElement();
        this.bindDOMEvent();
        this.bindEvent();
    }
    LanguageSelectBox.prototype.createElement = function () {
        this.wrapper = document.createElement('div');
        addClass_default()(this.wrapper, cls(WRAPPER_CLASS_NAME));
        this.createInputElement();
        this.createLanguageListElement();
        this.rootEl.appendChild(this.wrapper);
        this.hide();
    };
    LanguageSelectBox.prototype.createInputElement = function () {
        var wrapper = document.createElement('span');
        addClass_default()(wrapper, cls(INPUT_CLASS_NANE));
        var input = document.createElement('input');
        input.type = 'text';
        input.setAttribute('maxlength', '20');
        this.input = input;
        wrapper.appendChild(this.input);
        this.wrapper.appendChild(wrapper);
    };
    LanguageSelectBox.prototype.createLanguageListElement = function () {
        this.list = document.createElement('div');
        addClass_default()(this.list, cls(LIST_CLASS_NAME));
        var buttonsContainer = document.createElement('div');
        addClass_default()(buttonsContainer, 'buttons');
        buttonsContainer.innerHTML = getButtonsHTML(this.languages);
        this.buttons = toArray_default()(buttonsContainer.children);
        this.list.appendChild(buttonsContainer);
        this.wrapper.appendChild(this.list);
        this.activateButtonByIndex(0);
        this.hideList();
    };
    LanguageSelectBox.prototype.bindDOMEvent = function () {
        var _this = this;
        this.wrapper.addEventListener('mousedown', this.onSelectToggleButton);
        this.input.addEventListener('keydown', this.handleKeydown);
        this.input.addEventListener('focus', function () { return _this.activateSelectBox(); });
        this.input.addEventListener('blur', function () { return _this.inactivateSelectBox(); });
        this.list.addEventListener('mousedown', this.onSelectLanguageButtons);
    };
    LanguageSelectBox.prototype.bindEvent = function () {
        this.eventEmitter.listen('showCodeBlockLanguages', this.showLangugaeSelectBox);
    };
    LanguageSelectBox.prototype.activateSelectBox = function () {
        addClass_default()(this.wrapper, 'active');
        css_default()(this.list, { display: 'block' });
    };
    LanguageSelectBox.prototype.inactivateSelectBox = function () {
        this.input.value = this.prevStoredLanguage;
        removeClass_default()(this.wrapper, 'active');
        this.hideList();
    };
    LanguageSelectBox.prototype.toggleFocus = function () {
        if (hasClass_default()(this.wrapper, 'active')) {
            this.input.blur();
        }
        else {
            this.input.focus();
        }
    };
    LanguageSelectBox.prototype.storeInputLanguage = function () {
        var selectedLanguage = this.input.value;
        this.setLanguage(selectedLanguage);
        this.hideList();
        this.eventEmitter.emit('selectLanguage', selectedLanguage);
    };
    LanguageSelectBox.prototype.activateButtonByIndex = function (index) {
        if (this.currentButton) {
            removeClass_default()(this.currentButton, 'active');
        }
        if (this.buttons.length) {
            this.currentButton = this.buttons[index];
            this.input.value = this.currentButton.getAttribute(LANG_ATTR);
            addClass_default()(this.currentButton, 'active');
            this.currentButton.scrollIntoView();
        }
    };
    LanguageSelectBox.prototype.selectLanguage = function (selectedLanguage) {
        this.input.value = selectedLanguage;
        this.storeInputLanguage();
    };
    LanguageSelectBox.prototype.selectPrevLanguage = function () {
        var index = inArray_default()(this.currentButton, this.buttons) - 1;
        if (index < 0) {
            index = this.buttons.length - 1;
        }
        this.activateButtonByIndex(index);
    };
    LanguageSelectBox.prototype.selectNextLanguage = function () {
        var index = inArray_default()(this.currentButton, this.buttons) + 1;
        if (index >= this.buttons.length) {
            index = 0;
        }
        this.activateButtonByIndex(index);
    };
    LanguageSelectBox.prototype.hideList = function () {
        css_default()(this.list, { display: 'none' });
    };
    LanguageSelectBox.prototype.show = function () {
        css_default()(this.wrapper, { display: 'inline-block' });
    };
    LanguageSelectBox.prototype.hide = function () {
        css_default()(this.wrapper, { display: 'none' });
    };
    LanguageSelectBox.prototype.setLanguage = function (language) {
        this.prevStoredLanguage = language;
        this.input.value = language;
        var item = this.buttons.filter(function (button) { return button.getAttribute(LANG_ATTR) === language; });
        if (item.length) {
            var index = inArray_default()(item[0], this.buttons);
            this.activateButtonByIndex(index);
        }
    };
    LanguageSelectBox.prototype.destroy = function () {
        removeNode(this.wrapper);
        this.eventEmitter.removeEventHandler('showCodeBlockLanguages', this.showLangugaeSelectBox);
    };
    return LanguageSelectBox;
}());


;// CONCATENATED MODULE: ./src/nodeViews/codeSyntaxHighlightView.ts
var __assign = ( false) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};




var codeSyntaxHighlightView_WRAPPER_CLASS_NAME = 'ww-code-block-highlighting';
function getCustomAttrs(attrs) {
    var htmlAttrs = attrs.htmlAttrs, classNames = attrs.classNames;
    return __assign(__assign({}, htmlAttrs), { class: classNames ? classNames.join(' ') : null });
}
var CodeSyntaxHighlightView = /** @class */ (function () {
    // eslint-disable-next-line max-params
    function CodeSyntaxHighlightView(node, view, getPos, eventEmitter, languages) {
        var _this = this;
        this.node = node;
        this.view = view;
        this.getPos = getPos;
        this.eventEmitter = eventEmitter;
        this.languages = languages;
        this.contentDOM = null;
        this.languageSelectBox = null;
        this.onSelectLanguage = function (language) {
            if (_this.languageEditing) {
                _this.changeLanguage(language);
            }
        };
        this.onClickEditingButton = function (ev) {
            var target = ev.target;
            var style = getComputedStyle(target, ':after');
            // judge to click pseudo element with background image for IE11
            if (style.backgroundImage !== 'none' && isFunction_default()(_this.getPos)) {
                var pos = _this.view.coordsAtPos(_this.getPos());
                _this.openLanguageSelectBox(pos);
            }
        };
        this.finishLanguageEditing = function () {
            if (_this.languageEditing) {
                _this.reset();
            }
        };
        this.node = node;
        this.view = view;
        this.getPos = getPos;
        this.eventEmitter = eventEmitter;
        this.languageEditing = false;
        this.languages = languages;
        this.createElement();
        this.bindDOMEvent();
        this.bindEvent();
    }
    CodeSyntaxHighlightView.prototype.createElement = function () {
        var language = this.node.attrs.language;
        var wrapper = document.createElement('div');
        wrapper.setAttribute('data-language', language || 'text');
        addClass_default()(wrapper, cls(codeSyntaxHighlightView_WRAPPER_CLASS_NAME));
        var pre = this.createCodeBlockElement();
        var code = pre.firstChild;
        if (language) {
            addClass_default()(pre, "language-" + language);
            addClass_default()(code, "language-" + language);
        }
        wrapper.appendChild(pre);
        this.dom = wrapper;
        this.contentDOM = code;
    };
    CodeSyntaxHighlightView.prototype.createCodeBlockElement = function () {
        var pre = document.createElement('pre');
        var code = document.createElement('code');
        var language = this.node.attrs.language;
        var attrs = getCustomAttrs(this.node.attrs);
        if (language) {
            code.setAttribute('data-language', language);
        }
        Object.keys(attrs).forEach(function (attrName) {
            if (attrs[attrName]) {
                pre.setAttribute(attrName, attrs[attrName]);
            }
        });
        pre.appendChild(code);
        return pre;
    };
    CodeSyntaxHighlightView.prototype.bindDOMEvent = function () {
        if (this.dom) {
            this.dom.addEventListener('click', this.onClickEditingButton);
            this.view.dom.addEventListener('mousedown', this.finishLanguageEditing);
            window.addEventListener('resize', this.finishLanguageEditing);
        }
    };
    CodeSyntaxHighlightView.prototype.bindEvent = function () {
        this.eventEmitter.listen('selectLanguage', this.onSelectLanguage);
        this.eventEmitter.listen('scroll', this.finishLanguageEditing);
        this.eventEmitter.listen('finishLanguageEditing', this.finishLanguageEditing);
    };
    CodeSyntaxHighlightView.prototype.openLanguageSelectBox = function (pos) {
        this.languageSelectBox = new LanguageSelectBox(this.view.dom.parentElement, this.eventEmitter, this.languages);
        this.eventEmitter.emit('showCodeBlockLanguages', pos, this.node.attrs.language);
        this.languageEditing = true;
    };
    CodeSyntaxHighlightView.prototype.changeLanguage = function (language) {
        if (isFunction_default()(this.getPos)) {
            this.reset();
            var pos = this.getPos();
            var tr = this.view.state.tr;
            tr.setNodeMarkup(pos, null, { language: language });
            this.view.dispatch(tr);
        }
    };
    CodeSyntaxHighlightView.prototype.reset = function () {
        if (this.languageSelectBox) {
            this.languageSelectBox.destroy();
            this.languageSelectBox = null;
        }
        this.languageEditing = false;
    };
    CodeSyntaxHighlightView.prototype.stopEvent = function () {
        return true;
    };
    CodeSyntaxHighlightView.prototype.update = function (node) {
        if (!node.sameMarkup(this.node)) {
            return false;
        }
        this.node = node;
        return true;
    };
    CodeSyntaxHighlightView.prototype.destroy = function () {
        this.reset();
        if (this.dom) {
            this.dom.removeEventListener('click', this.onClickEditingButton);
            this.view.dom.removeEventListener('mousedown', this.finishLanguageEditing);
            window.removeEventListener('resize', this.finishLanguageEditing);
        }
        this.eventEmitter.removeEventHandler('selectLanguage', this.onSelectLanguage);
        this.eventEmitter.removeEventHandler('scroll', this.finishLanguageEditing);
        this.eventEmitter.removeEventHandler('finishLanguageEditing', this.finishLanguageEditing);
    };
    return CodeSyntaxHighlightView;
}());
function createCodeSyntaxHighlightView(languages) {
    return function (node, view, getPos, emitter) {
        return new CodeSyntaxHighlightView(node, view, getPos, emitter, languages);
    };
}

;// CONCATENATED MODULE: ./src/plugin.ts




function codeSyntaxHighlightPlugin(context, options) {
    if (options) {
        var eventEmitter = context.eventEmitter;
        var prism_1 = options.highlighter;
        eventEmitter.addEventType('showCodeBlockLanguages');
        eventEmitter.addEventType('selectLanguage');
        eventEmitter.addEventType('finishLanguageEditing');
        var languages_1 = prism_1.languages;
        var registerdlanguages = Object.keys(languages_1).filter(function (language) { return !isFunction_default()(languages_1[language]); });
        return {
            toHTMLRenderers: getHTMLRenderers(prism_1),
            wysiwygPlugins: [function () { return codeSyntaxHighlighting(context, prism_1); }],
            wysiwygNodeViews: {
                codeBlock: createCodeSyntaxHighlightView(registerdlanguages),
            },
        };
    }
    return {};
}

;// CONCATENATED MODULE: ./src/index.ts


// Prevent to highlight all code elements automatically.
// @link https://prismjs.com/docs/Prism.html#.manual
// eslint-disable-next-line no-undefined
if (typeof window !== undefined) {
    window.Prism = window.Prism || {};
    window.Prism.manual = true;
}
/* harmony default export */ var src = (codeSyntaxHighlightPlugin);

}();
module.exports = __nested_webpack_exports__["default"];
/******/ })()
;

/***/ }),

/***/ "./node_modules/@toast-ui/editor-plugin-color-syntax/dist/toastui-editor-plugin-color-syntax.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@toast-ui/editor-plugin-color-syntax/dist/toastui-editor-plugin-color-syntax.js ***!
  \******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * TOAST UI Editor : Color Syntax Plugin
 * @version 3.1.0 | Fri Aug 05 2022
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(/*! tui-color-picker */ "./node_modules/tui-color-picker/dist/tui-color-picker.js"));
	else {}
})(self, function(__WEBPACK_EXTERNAL_MODULE__858__) {
return /******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 858:
/***/ (function(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__858__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_1298__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_1298__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__nested_webpack_require_1298__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__nested_webpack_require_1298__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__nested_webpack_require_1298__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__nested_webpack_require_1298__.o(definition, key) && !__nested_webpack_require_1298__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__nested_webpack_require_1298__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/************************************************************************/
var __nested_webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
!function() {

// EXPORTS
__nested_webpack_require_1298__.d(__nested_webpack_exports__, {
  "default": function() { return /* binding */ colorSyntaxPlugin; }
});

// EXTERNAL MODULE: external {"commonjs":"tui-color-picker","commonjs2":"tui-color-picker","amd":"tui-color-picker","root":["tui","colorPicker"]}
var external_commonjs_tui_color_picker_commonjs2_tui_color_picker_amd_tui_color_picker_root_tui_colorPicker_ = __nested_webpack_require_1298__(858);
var external_commonjs_tui_color_picker_commonjs2_tui_color_picker_amd_tui_color_picker_root_tui_colorPicker_default = /*#__PURE__*/__nested_webpack_require_1298__.n(external_commonjs_tui_color_picker_commonjs2_tui_color_picker_amd_tui_color_picker_root_tui_colorPicker_);
;// CONCATENATED MODULE: ./src/i18n/langs.ts
function addLangs(i18n) {
    i18n.setLanguage('ar', {
        'Text color': ' ',
    });
    i18n.setLanguage(['cs', 'cs-CZ'], {
        'Text color': 'Barva textu',
    });
    i18n.setLanguage(['de', 'de-DE'], {
        'Text color': 'Textfarbe',
    });
    i18n.setLanguage(['en', 'en-US'], {
        'Text color': 'Text color',
    });
    i18n.setLanguage(['es', 'es-ES'], {
        'Text color': 'Color del texto',
    });
    i18n.setLanguage(['fi', 'fi-FI'], {
        'Text color': 'Tekstin vri',
    });
    i18n.setLanguage(['fr', 'fr-FR'], {
        'Text color': 'Couleur du texte',
    });
    i18n.setLanguage(['gl', 'gl-ES'], {
        'Text color': 'Cor do texto',
    });
    i18n.setLanguage(['hr', 'hr-HR'], {
        'Text color': 'Boja teksta',
    });
    i18n.setLanguage(['it', 'it-IT'], {
        'Text color': 'Colore del testo',
    });
    i18n.setLanguage(['ja', 'ja-JP'], {
        'Text color': '',
    });
    i18n.setLanguage(['ko', 'ko-KR'], {
        'Text color': ' ',
    });
    i18n.setLanguage(['nb', 'nb-NO'], {
        'Text color': 'Tekstfarge',
    });
    i18n.setLanguage(['nl', 'nl-NL'], {
        'Text color': 'Tekstkleur',
    });
    i18n.setLanguage(['pl', 'pl-PL'], {
        'Text color': 'Kolor tekstu',
    });
    i18n.setLanguage(['pt', 'pt-BR'], {
        'Text color': 'Cor do texto',
    });
    i18n.setLanguage(['ru', 'ru-RU'], {
        'Text color': ' ',
    });
    i18n.setLanguage(['sv', 'sv-SE'], {
        'Text color': 'Textfrg',
    });
    i18n.setLanguage(['tr', 'tr-TR'], {
        'Text color': 'Metin rengi',
    });
    i18n.setLanguage(['uk', 'uk-UA'], {
        'Text color': ' ',
    });
    i18n.setLanguage('zh-CN', {
        'Text color': '',
    });
    i18n.setLanguage('zh-TW', {
        'Text color': '',
    });
}

;// CONCATENATED MODULE: ./src/utils/dom.ts
function hasClass(element, className) {
    return element.classList.contains(className);
}
function findParentByClassName(el, className) {
    var currentEl = el;
    while (currentEl && !hasClass(currentEl, className)) {
        currentEl = currentEl.parentElement;
    }
    return currentEl;
}
function removeProseMirrorHackNodes(html) {
    var reProseMirrorImage = /<img class="ProseMirror-separator" alt="">/g;
    var reProseMirrorTrailingBreak = / class="ProseMirror-trailingBreak"/g;
    var resultHTML = html;
    resultHTML = resultHTML.replace(reProseMirrorImage, '');
    resultHTML = resultHTML.replace(reProseMirrorTrailingBreak, '');
    return resultHTML;
}

;// CONCATENATED MODULE: ./src/index.ts




var PREFIX = 'toastui-editor-';
function createApplyButton(text) {
    var button = document.createElement('button');
    button.setAttribute('type', 'button');
    button.textContent = text;
    return button;
}
function createToolbarItemOption(colorPickerContainer, i18n) {
    return {
        name: 'color',
        tooltip: i18n.get('Text color'),
        className: PREFIX + "toolbar-icons color",
        popup: {
            className: PREFIX + "popup-color",
            body: colorPickerContainer,
            style: { width: 'auto' },
        },
    };
}
function createSelection(tr, selection, SelectionClass, openTag, closeTag) {
    var mapping = tr.mapping, doc = tr.doc;
    var from = selection.from, to = selection.to, empty = selection.empty;
    var mappedFrom = mapping.map(from) + openTag.length;
    var mappedTo = mapping.map(to) - closeTag.length;
    return empty
        ? SelectionClass.create(doc, mappedTo, mappedTo)
        : SelectionClass.create(doc, mappedFrom, mappedTo);
}
function getCurrentEditorEl(colorPickerEl, containerClassName) {
    var editorDefaultEl = findParentByClassName(colorPickerEl, PREFIX + "defaultUI");
    return editorDefaultEl.querySelector("." + containerClassName + " .ProseMirror");
}
var containerClassName;
var currentEditorEl;
// @TODO: add custom syntax for plugin
/**
 * Color syntax plugin
 * @param {Object} context - plugin context for communicating with editor
 * @param {Object} options - options for plugin
 * @param {Array.<string>} [options.preset] - preset for color palette (ex: ['#181818', '#292929'])
 * @param {boolean} [options.useCustomSyntax=false] - whether use custom syntax or not
 */
function colorSyntaxPlugin(context, options) {
    if (options === void 0) { options = {}; }
    var eventEmitter = context.eventEmitter, i18n = context.i18n, _a = context.usageStatistics, usageStatistics = _a === void 0 ? true : _a, pmState = context.pmState;
    var preset = options.preset;
    var container = document.createElement('div');
    var colorPickerOption = { container: container, usageStatistics: usageStatistics };
    addLangs(i18n);
    if (preset) {
        colorPickerOption.preset = preset;
    }
    var colorPicker = external_commonjs_tui_color_picker_commonjs2_tui_color_picker_amd_tui_color_picker_root_tui_colorPicker_default().create(colorPickerOption);
    var button = createApplyButton(i18n.get('OK'));
    eventEmitter.listen('focus', function (editType) {
        containerClassName = "" + PREFIX + (editType === 'markdown' ? 'md' : 'ww') + "-container";
    });
    container.addEventListener('click', function (ev) {
        if (ev.target.getAttribute('type') === 'button') {
            var selectedColor = colorPicker.getColor();
            currentEditorEl = getCurrentEditorEl(container, containerClassName);
            eventEmitter.emit('command', 'color', { selectedColor: selectedColor });
            eventEmitter.emit('closePopup');
            // force the current editor to focus for preventing to lose focus
            currentEditorEl.focus();
        }
    });
    colorPicker.slider.toggle(true);
    container.appendChild(button);
    var toolbarItem = createToolbarItemOption(container, i18n);
    return {
        markdownCommands: {
            color: function (_a, _b, dispatch) {
                var selectedColor = _a.selectedColor;
                var tr = _b.tr, selection = _b.selection, schema = _b.schema;
                if (selectedColor) {
                    var slice = selection.content();
                    var textContent = slice.content.textBetween(0, slice.content.size, '\n');
                    var openTag = "<span style=\"color: " + selectedColor + "\">";
                    var closeTag = "</span>";
                    var colored = "" + openTag + textContent + closeTag;
                    tr.replaceSelectionWith(schema.text(colored)).setSelection(createSelection(tr, selection, pmState.TextSelection, openTag, closeTag));
                    dispatch(tr);
                    return true;
                }
                return false;
            },
        },
        wysiwygCommands: {
            color: function (_a, _b, dispatch) {
                var selectedColor = _a.selectedColor;
                var tr = _b.tr, selection = _b.selection, schema = _b.schema;
                if (selectedColor) {
                    var from = selection.from, to = selection.to;
                    var attrs = { htmlAttrs: { style: "color: " + selectedColor } };
                    var mark = schema.marks.span.create(attrs);
                    tr.addMark(from, to, mark);
                    dispatch(tr);
                    return true;
                }
                return false;
            },
        },
        toolbarItems: [
            {
                groupIndex: 0,
                itemIndex: 3,
                item: toolbarItem,
            },
        ],
        toHTMLRenderers: {
            htmlInline: {
                span: function (node, _a) {
                    var entering = _a.entering;
                    return entering
                        ? { type: 'openTag', tagName: 'span', attributes: node.attrs }
                        : { type: 'closeTag', tagName: 'span' };
                },
            },
        },
    };
}

}();
__nested_webpack_exports__ = __nested_webpack_exports__["default"];
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@toast-ui/editor-plugin-table-merged-cell/dist/toastui-editor-plugin-table-merged-cell.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@toast-ui/editor-plugin-table-merged-cell/dist/toastui-editor-plugin-table-merged-cell.js ***!
  \****************************************************************************************************************/
/***/ ((module) => {

/*!
 * TOAST UI Editor : Table Merged Cell Plugin
 * @version 3.1.0 | Fri Aug 05 2022
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 893:
/***/ (function(module) {

/**
 * @fileoverview Execute the provided callback once for each element present in the array(or Array-like object) in ascending order.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Execute the provided callback once for each element present
 * in the array(or Array-like object) in ascending order.
 * If the callback function returns false, the loop will be stopped.
 * Callback function(iteratee) is invoked with three arguments:
 *  1) The value of the element
 *  2) The index of the element
 *  3) The array(or Array-like object) being traversed
 * @param {Array|Arguments|NodeList} arr The array(or Array-like object) that will be traversed
 * @param {function} iteratee Callback function
 * @param {Object} [context] Context(this) of callback function
 * @memberof module:collection
 * @example
 * // ES6
 * import forEachArray from 'tui-code-snippet/collection/forEachArray';
 * 
 * // CommonJS
 * const forEachArray = require('tui-code-snippet/collection/forEachArray'); 
 *
 * let sum = 0;
 *
 * forEachArray([1,2,3], function(value){
 *   sum += value;
 * });
 * alert(sum); // 6
 */
function forEachArray(arr, iteratee, context) {
  var index = 0;
  var len = arr.length;

  context = context || null;

  for (; index < len; index += 1) {
    if (iteratee.call(context, arr[index], index, arr) === false) {
      break;
    }
  }
}

module.exports = forEachArray;


/***/ }),

/***/ 990:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_1792__) {

/**
 * @fileoverview Transform the Array-like object to Array.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var forEachArray = __nested_webpack_require_1792__(893);

/**
 * Transform the Array-like object to Array.
 * In low IE (below 8), Array.prototype.slice.call is not perfect. So, try-catch statement is used.
 * @param {*} arrayLike Array-like object
 * @returns {Array} Array
 * @memberof module:collection
 * @example
 * // ES6
 * import toArray from 'tui-code-snippet/collection/toArray'; 
 * 
 * // CommonJS
 * const toArray = require('tui-code-snippet/collection/toArray'); 
 *
 * const arrayLike = {
 *   0: 'one',
 *   1: 'two',
 *   2: 'three',
 *   3: 'four',
 *   length: 4
 * };
 * const result = toArray(arrayLike);
 *
 * alert(result instanceof Array); // true
 * alert(result); // one,two,three,four
 */
function toArray(arrayLike) {
  var arr;
  try {
    arr = Array.prototype.slice.call(arrayLike);
  } catch (e) {
    arr = [];
    forEachArray(arrayLike, function(value) {
      arr.push(value);
    });
  }

  return arr;
}

module.exports = toArray;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_3132__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_3132__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__nested_webpack_require_3132__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__nested_webpack_require_3132__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__nested_webpack_require_3132__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__nested_webpack_require_3132__.o(definition, key) && !__nested_webpack_require_3132__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__nested_webpack_require_3132__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/************************************************************************/
var __nested_webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
!function() {

// EXPORTS
__nested_webpack_require_3132__.d(__nested_webpack_exports__, {
  "default": function() { return /* binding */ tableMergedCellPlugin; }
});

;// CONCATENATED MODULE: ./src/markdown/parser.ts
function getSpanInfo(content, type, oppositeType) {
    var reSpan = new RegExp("^((?:" + oppositeType + "=[0-9]+:)?)" + type + "=([0-9]+):(.*)");
    var parsed = reSpan.exec(content);
    var spanCount = 1;
    if (parsed) {
        spanCount = parseInt(parsed[2], 10);
        content = parsed[1] + parsed[3];
    }
    return [spanCount, content];
}
function extendTableCellIndexWithRowspanMap(node, parent, rowspan) {
    var prevRow = parent.prev;
    if (prevRow) {
        var columnLen = parent.parent.parent.columns.length;
        // increment the index when prev row has the rowspan count.
        for (var i = node.startIdx; i < columnLen; i += 1) {
            var prevRowspanCount = prevRow.rowspanMap[i];
            if (prevRowspanCount && prevRowspanCount > 1) {
                parent.rowspanMap[i] = prevRowspanCount - 1;
                if (i <= node.endIdx) {
                    node.startIdx += 1;
                    node.endIdx += 1;
                }
            }
        }
    }
    if (rowspan > 1) {
        var startIdx = node.startIdx, endIdx = node.endIdx;
        for (var i = startIdx; i <= endIdx; i += 1) {
            parent.rowspanMap[i] = rowspan;
        }
    }
}
var markdownParsers = {
    // @ts-expect-error
    tableRow: function (node, _a) {
        var entering = _a.entering;
        if (entering) {
            node.rowspanMap = {};
            if (node.prev && !node.firstChild) {
                var prevRowspanMap_1 = node.prev.rowspanMap;
                Object.keys(prevRowspanMap_1).forEach(function (key) {
                    if (prevRowspanMap_1[key] > 1) {
                        node.rowspanMap[key] = prevRowspanMap_1[key] - 1;
                    }
                });
            }
        }
    },
    // @ts-expect-error
    tableCell: function (node, _a) {
        var _b, _c;
        var entering = _a.entering;
        var parent = node.parent, prev = node.prev, stringContent = node.stringContent;
        if (entering) {
            var attrs = {};
            var content = stringContent;
            var _d = [1, 1], colspan = _d[0], rowspan = _d[1];
            _b = getSpanInfo(content, '@cols', '@rows'), colspan = _b[0], content = _b[1];
            _c = getSpanInfo(content, '@rows', '@cols'), rowspan = _c[0], content = _c[1];
            node.stringContent = content;
            if (prev) {
                node.startIdx = prev.endIdx + 1;
                node.endIdx = node.startIdx;
            }
            if (colspan > 1) {
                attrs.colspan = colspan;
                node.endIdx += colspan - 1;
            }
            if (rowspan > 1) {
                attrs.rowspan = rowspan;
            }
            node.attrs = attrs;
            extendTableCellIndexWithRowspanMap(node, parent, rowspan);
            var tablePart = parent.parent;
            if (tablePart.type === 'tableBody' && node.endIdx >= tablePart.parent.columns.length) {
                node.ignored = true;
            }
        }
    },
};

;// CONCATENATED MODULE: ./src/markdown/renderer.ts
var __assign = ( false) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var toHTMLRenderers = {
    // @ts-ignore
    tableRow: function (node, _a) {
        var entering = _a.entering, origin = _a.origin;
        if (entering) {
            return origin();
        }
        var result = [];
        if (node.lastChild) {
            var columnLen = node.parent.parent.columns.length;
            var lastColIdx = node.lastChild.endIdx;
            for (var i = lastColIdx + 1; i < columnLen; i += 1) {
                if (!node.prev || !node.prev.rowspanMap[i] || node.prev.rowspanMap[i] <= 1) {
                    result.push({
                        type: 'openTag',
                        tagName: 'td',
                        outerNewLine: true,
                    }, {
                        type: 'closeTag',
                        tagName: 'td',
                        outerNewLine: true,
                    });
                }
            }
        }
        result.push({
            type: 'closeTag',
            tagName: 'tr',
            outerNewLine: true,
        });
        return result;
    },
    // @ts-ignore
    tableCell: function (node, _a) {
        var entering = _a.entering, origin = _a.origin;
        var result = origin();
        if (node.ignored) {
            return result;
        }
        if (entering) {
            var attributes = __assign({}, node.attrs);
            result.attributes = __assign(__assign({}, result.attributes), attributes);
        }
        return result;
    },
};

;// CONCATENATED MODULE: ./src/wysiwyg/renderer.ts
var DELIM_LENGH = 3;
function repeat(text, count) {
    var result = '';
    for (var i = 0; i < count; i += 1) {
        result += text;
    }
    return result;
}
function createTableHeadDelim(textContent, columnAlign) {
    var textLen = textContent.length;
    var leftDelim = '';
    var rightDelim = '';
    if (columnAlign === 'left') {
        leftDelim = ':';
        textLen -= 1;
    }
    else if (columnAlign === 'right') {
        rightDelim = ':';
        textLen -= 1;
    }
    else if (columnAlign === 'center') {
        leftDelim = ':';
        rightDelim = ':';
        textLen -= 2;
    }
    return "" + leftDelim + repeat('-', Math.max(textLen, DELIM_LENGH)) + rightDelim;
}
function createDelim(node) {
    var _a = node.attrs, rowspan = _a.rowspan, colspan = _a.colspan;
    var spanInfo = '';
    if (rowspan) {
        spanInfo = "@rows=" + rowspan + ":";
    }
    if (colspan) {
        spanInfo = "@cols=" + colspan + ":" + spanInfo;
    }
    return { delim: "| " + spanInfo };
}
var toMarkdownRenderers = {
    tableHead: function (nodeInfo) {
        var row = nodeInfo.node.firstChild;
        var delim = '';
        if (row) {
            row.forEach(function (_a) {
                var textContent = _a.textContent, attrs = _a.attrs;
                var headDelim = createTableHeadDelim(textContent, attrs.align);
                delim += "| " + headDelim + " ";
                if (attrs.colspan) {
                    for (var i = 0; i < attrs.colspan - 1; i += 1) {
                        delim += "| " + headDelim + " ";
                    }
                }
            });
        }
        return { delim: delim };
    },
    tableHeadCell: function (nodeInfo) {
        return createDelim(nodeInfo.node);
    },
    tableBodyCell: function (nodeInfo) {
        return createDelim(nodeInfo.node);
    },
};

;// CONCATENATED MODULE: ./src/i18n/langs.ts
function addLangs(i18n) {
    i18n.setLanguage(['ko', 'ko-KR'], {
        'Merge cells': ' ',
        'Split cells': ' ',
        'Cannot change part of merged cell': '     .',
        'Cannot paste row merged cells into the table header': '       .',
    });
    i18n.setLanguage(['en', 'en-US'], {
        'Merge cells': 'Merge cells',
        'Split cells': 'Split cells',
        'Cannot change part of merged cell': 'Cannot change part of merged cell.',
        'Cannot paste row merged cells into the table header': 'Cannot paste row merged cells into the table header.',
    });
    i18n.setLanguage(['es', 'es-ES'], {
        'Merge cells': 'Combinar celdas',
        'Split cells': 'Separar celdas',
        'Cannot change part of merged cell': 'No se puede cambiar parte de una celda combinada.',
        'Cannot paste row merged cells into the table header': 'No se pueden pegar celdas combinadas en el encabezado de tabla.',
    });
    i18n.setLanguage(['ja', 'ja-JP'], {
        'Merge cells': '',
        'Split cells': '',
        'Cannot change part of merged cell': '',
        'Cannot paste row merged cells into the table header': '',
    });
    i18n.setLanguage(['nl', 'nl-NL'], {
        'Merge cells': 'Cellen samenvoegen',
        'Split cells': 'Samengevoegde cellen ongedaan maken',
        'Cannot change part of merged cell': 'Kan geen deel uit van een samengevoegde cel veranderen.',
        'Cannot paste row merged cells into the table header': 'Kan geen rij met samengevoegde cellen in de koptekst plakken.',
    });
    i18n.setLanguage('zh-CN', {
        'Merge cells': '',
        'Split cells': '',
        'Cannot change part of merged cell': '',
        'Cannot paste row merged cells into the table header': '',
    });
    i18n.setLanguage(['de', 'de-DE'], {
        'Merge cells': 'Zellen zusammenfhren',
        'Split cells': 'Zusammenfhren rckgngig machen',
        'Cannot change part of merged cell': 'Der Teil der verbundenen Zelle kann nicht gendert werden.',
        'Cannot paste row merged cells into the table header': 'Die Zeile der verbundenen Zellen kann nicht in die Kopfzeile eingefgt werden.',
    });
    i18n.setLanguage(['ru', 'ru-RU'], {
        'Merge cells': ' ',
        'Split cells': ' ',
        'Cannot change part of merged cell': '      .',
        'Cannot paste row merged cells into the table header': '        .',
    });
    i18n.setLanguage(['fr', 'fr-FR'], {
        'Merge cells': 'Fusionner les cellules',
        'Split cells': 'Sparer les cellules',
        'Cannot change part of merged cell': 'Impossible de modifier une partie de la cellule fusionne.',
        'Cannot paste row merged cells into the table header': "Impossible de coller les cellules fusionnes dans l'en-tte du tableau.",
    });
    i18n.setLanguage(['uk', 'uk-UA'], {
        'Merge cells': "' ",
        'Split cells': "' ",
        'Cannot change part of merged cell': '      .',
        'Cannot paste row merged cells into the table header': "    '    .",
    });
    i18n.setLanguage(['tr', 'tr-TR'], {
        'Merge cells': 'Hcreleri birletir',
        'Split cells': 'Hcreleri ayr',
        'Cannot change part of merged cell': 'Birletirilmi hcrelerin bir ksm deitirelemez.',
        'Cannot paste row merged cells into the table header': 'Satrda birletirilmi hcreler stun balna yaptrlamaz',
    });
    i18n.setLanguage(['fi', 'fi-FI'], {
        'Merge cells': 'Yhdist solut',
        'Split cells': 'Jaa solut',
        'Cannot change part of merged cell': 'Yhdistettyjen solujen osaa ei voi muuttaa',
        'Cannot paste row merged cells into the table header': 'Soluja ei voi yhdist taulukon otsikkoriviin',
    });
    i18n.setLanguage(['cs', 'cs-CZ'], {
        'Merge cells': 'Spojit buky',
        'Split cells': 'Rozpojit buky',
        'Cannot change part of merged cell': 'Nelze mnit st spojen buky',
        'Cannot paste row merged cells into the table header': 'Nelze vkldat spojen buky do zhlav tabulky',
    });
    i18n.setLanguage('ar', {
        'Merge cells': ' ',
        'Split cells': '  ',
        'Cannot change part of merged cell': '      ',
        'Cannot paste row merged cells into the table header': '          ',
    });
    i18n.setLanguage(['pl', 'pl-PL'], {
        'Merge cells': 'Scal komrki',
        'Split cells': 'Rozcz komrki',
        'Cannot change part of merged cell': 'Nie mona zmieni czci scalonej komrki.',
        'Cannot paste row merged cells into the table header': 'Nie mona wklei komrek o scalonym rzdzie w nagwek tabeli.',
    });
    i18n.setLanguage('zh-TW', {
        'Merge cells': '',
        'Split cells': '',
        'Cannot change part of merged cell': '',
        'Cannot paste row merged cells into the table header': '',
    });
    i18n.setLanguage(['gl', 'gl-ES'], {
        'Merge cells': 'Combinar celas',
        'Split cells': 'Separar celas',
        'Cannot change part of merged cell': 'Non se pode cambiar parte dunha cela combinada',
        'Cannot paste row merged cells into the table header': 'Non se poden pegar celas no encabezado da tboa',
    });
    i18n.setLanguage(['sv', 'sv-SE'], {
        'Merge cells': 'Sammanfoga celler',
        'Split cells': 'Dela celler',
        'Cannot change part of merged cell': 'Ej mjligt att ndra en del av en sammanfogad cell',
        'Cannot paste row merged cells into the table header': 'Ej mjligt att klistra in rad-sammanfogade celler i tabellens huvud',
    });
    i18n.setLanguage(['it', 'it-IT'], {
        'Merge cells': 'Unisci celle',
        'Split cells': 'Separa celle',
        'Cannot change part of merged cell': 'Non  possibile modificare parte di una cella unita',
        'Cannot paste row merged cells into the table header': "Non  possibile incollare celle unite per riga nell'intestazione della tabella",
    });
    i18n.setLanguage(['nb', 'nb-NO'], {
        'Merge cells': 'Sl sammen celler',
        'Split cells': 'Separer celler',
        'Cannot change part of merged cell': 'Kan ikke endre deler av sammensltte celler',
        'Cannot paste row merged cells into the table header': 'Kan ikke lime inn rad med sammensltte celler',
    });
    i18n.setLanguage(['hr', 'hr-HR'], {
        'Merge cells': 'Spoji elije',
        'Split cells': 'Odspoji elije',
        'Cannot change part of merged cell': 'Ne mogu mijenjati dio spojene elije.',
        'Cannot paste row merged cells into the table header': 'Ne mogu zaljepiti redak spojenih elija u zaglavlje tablice',
    });
}

;// CONCATENATED MODULE: ./src/wysiwyg/tableOffsetMapMixin.ts
var tableOffsetMapMixin_assign = ( false) || function () {
    tableOffsetMapMixin_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return tableOffsetMapMixin_assign.apply(this, arguments);
};
var offsetMapMixin = {
    extendedRowspan: function (rowIdx, colIdx) {
        var rowspanInfo = this.rowInfo[rowIdx].rowspanMap[colIdx];
        return !!rowspanInfo && rowspanInfo.startSpanIdx !== rowIdx;
    },
    extendedColspan: function (rowIdx, colIdx) {
        var colspanInfo = this.rowInfo[rowIdx].colspanMap[colIdx];
        return !!colspanInfo && colspanInfo.startSpanIdx !== colIdx;
    },
    getRowspanCount: function (rowIdx, colIdx) {
        var rowspanInfo = this.rowInfo[rowIdx].rowspanMap[colIdx];
        return rowspanInfo ? rowspanInfo.count : 0;
    },
    getColspanCount: function (rowIdx, colIdx) {
        var colspanInfo = this.rowInfo[rowIdx].colspanMap[colIdx];
        return colspanInfo ? colspanInfo.count : 0;
    },
    decreaseColspanCount: function (rowIdx, colIdx) {
        var colspanInfo = this.rowInfo[rowIdx].colspanMap[colIdx];
        var startColspanInfo = this.rowInfo[rowIdx].colspanMap[colspanInfo.startSpanIdx];
        startColspanInfo.count -= 1;
        return startColspanInfo.count;
    },
    decreaseRowspanCount: function (rowIdx, colIdx) {
        var rowspanInfo = this.rowInfo[rowIdx].rowspanMap[colIdx];
        var startRowspanInfo = this.rowInfo[rowspanInfo.startSpanIdx].rowspanMap[colIdx];
        startRowspanInfo.count -= 1;
        return startRowspanInfo.count;
    },
    getColspanStartInfo: function (rowIdx, colIdx) {
        var colspanMap = this.rowInfo[rowIdx].colspanMap;
        var colspanInfo = colspanMap[colIdx];
        if (colspanInfo) {
            var startSpanIdx = colspanInfo.startSpanIdx;
            var cellInfo = this.rowInfo[rowIdx][startSpanIdx];
            return {
                node: this.table.nodeAt(cellInfo.offset - this.tableStartOffset),
                pos: cellInfo.offset,
                startSpanIdx: startSpanIdx,
                count: colspanMap[startSpanIdx].count,
            };
        }
        return null;
    },
    getRowspanStartInfo: function (rowIdx, colIdx) {
        var rowspanMap = this.rowInfo[rowIdx].rowspanMap;
        var rowspanInfo = rowspanMap[colIdx];
        if (rowspanInfo) {
            var startSpanIdx = rowspanInfo.startSpanIdx;
            var cellInfo = this.rowInfo[startSpanIdx][colIdx];
            return {
                node: this.table.nodeAt(cellInfo.offset - this.tableStartOffset),
                pos: cellInfo.offset,
                startSpanIdx: startSpanIdx,
                count: this.rowInfo[startSpanIdx].rowspanMap[colIdx].count,
            };
        }
        return null;
    },
    getSpannedOffsets: function (selectionInfo) {
        var startRowIdx = selectionInfo.startRowIdx, startColIdx = selectionInfo.startColIdx, endRowIdx = selectionInfo.endRowIdx, endColIdx = selectionInfo.endColIdx;
        for (var rowIdx = endRowIdx; rowIdx >= startRowIdx; rowIdx -= 1) {
            if (this.rowInfo[rowIdx]) {
                var _a = this.rowInfo[rowIdx], rowspanMap = _a.rowspanMap, colspanMap = _a.colspanMap;
                for (var colIdx = endColIdx; colIdx >= startColIdx; colIdx -= 1) {
                    var rowspanInfo = rowspanMap[colIdx];
                    var colspanInfo = colspanMap[colIdx];
                    if (rowspanInfo) {
                        startRowIdx = Math.min(startRowIdx, rowspanInfo.startSpanIdx);
                    }
                    if (colspanInfo) {
                        startColIdx = Math.min(startColIdx, colspanInfo.startSpanIdx);
                    }
                }
            }
        }
        for (var rowIdx = startRowIdx; rowIdx <= endRowIdx; rowIdx += 1) {
            if (this.rowInfo[rowIdx]) {
                var _b = this.rowInfo[rowIdx], rowspanMap = _b.rowspanMap, colspanMap = _b.colspanMap;
                for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {
                    var rowspanInfo = rowspanMap[colIdx];
                    var colspanInfo = colspanMap[colIdx];
                    if (rowspanInfo) {
                        endRowIdx = Math.max(endRowIdx, rowIdx + rowspanInfo.count - 1);
                    }
                    if (colspanInfo) {
                        endColIdx = Math.max(endColIdx, colIdx + colspanInfo.count - 1);
                    }
                }
            }
        }
        return { startRowIdx: startRowIdx, startColIdx: startColIdx, endRowIdx: endRowIdx, endColIdx: endColIdx };
    },
};
function extendPrevRowspan(prevRowInfo, rowInfo) {
    var rowspanMap = rowInfo.rowspanMap, colspanMap = rowInfo.colspanMap;
    var prevRowspanMap = prevRowInfo.rowspanMap, prevColspanMap = prevRowInfo.colspanMap;
    Object.keys(prevRowspanMap).forEach(function (key) {
        var colIdx = Number(key);
        var prevRowspanInfo = prevRowspanMap[colIdx];
        if ((prevRowspanInfo === null || prevRowspanInfo === void 0 ? void 0 : prevRowspanInfo.count) > 1) {
            var prevColspanInfo = prevColspanMap[colIdx];
            var count = prevRowspanInfo.count, startSpanIdx = prevRowspanInfo.startSpanIdx;
            rowspanMap[colIdx] = { count: count - 1, startSpanIdx: startSpanIdx };
            colspanMap[colIdx] = prevColspanInfo;
            rowInfo[colIdx] = tableOffsetMapMixin_assign(tableOffsetMapMixin_assign({}, prevRowInfo[colIdx]), { extended: true });
            rowInfo.length += 1;
        }
    });
}
function extendPrevColspan(rowspan, colspan, rowIdx, colIdx, rowInfo) {
    var rowspanMap = rowInfo.rowspanMap, colspanMap = rowInfo.colspanMap;
    for (var i = 1; i < colspan; i += 1) {
        colspanMap[colIdx + i] = { count: colspan - i, startSpanIdx: colIdx };
        if (rowspan > 1) {
            rowspanMap[colIdx + i] = { count: rowspan, startSpanIdx: rowIdx };
        }
        rowInfo[colIdx + i] = tableOffsetMapMixin_assign({}, rowInfo[colIdx]);
        rowInfo.length += 1;
    }
}
var createOffsetMapMixin = function (headOrBody, startOffset, startFromBody) {
    if (startFromBody === void 0) { startFromBody = false; }
    var cellInfoMatrix = [];
    var beInBody = headOrBody.type.name === 'tableBody';
    headOrBody.forEach(function (row, rowOffset, rowIdx) {
        // get row index based on table(not table head or table body)
        var rowIdxInWholeTable = beInBody && !startFromBody ? rowIdx + 1 : rowIdx;
        var prevRowInfo = cellInfoMatrix[rowIdx - 1];
        var rowInfo = { rowspanMap: {}, colspanMap: {}, length: 0 };
        if (prevRowInfo) {
            extendPrevRowspan(prevRowInfo, rowInfo);
        }
        row.forEach(function (_a, cellOffset) {
            var _b, _c;
            var nodeSize = _a.nodeSize, attrs = _a.attrs;
            var colspan = (_b = attrs.colspan) !== null && _b !== void 0 ? _b : 1;
            var rowspan = (_c = attrs.rowspan) !== null && _c !== void 0 ? _c : 1;
            var colIdx = 0;
            while (rowInfo[colIdx]) {
                colIdx += 1;
            }
            rowInfo[colIdx] = {
                // 2 is the sum of the front and back positions of the tag
                offset: startOffset + rowOffset + cellOffset + 2,
                nodeSize: nodeSize,
            };
            rowInfo.length += 1;
            if (rowspan > 1) {
                rowInfo.rowspanMap[colIdx] = { count: rowspan, startSpanIdx: rowIdxInWholeTable };
            }
            if (colspan > 1) {
                rowInfo.colspanMap[colIdx] = { count: colspan, startSpanIdx: colIdx };
                extendPrevColspan(rowspan, colspan, rowIdxInWholeTable, colIdx, rowInfo);
            }
        });
        cellInfoMatrix.push(rowInfo);
    });
    return cellInfoMatrix;
};

// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/collection/toArray.js
var toArray = __nested_webpack_require_3132__(990);
var toArray_default = /*#__PURE__*/__nested_webpack_require_3132__.n(toArray);
;// CONCATENATED MODULE: ./src/wysiwyg/contextMenu.ts

var TABLE_CELL_SELECT_CLASS = '.toastui-editor-cell-selected';
function hasSpanAttr(tableCell) {
    return (Number(tableCell.getAttribute('colspan')) > 1 || Number(tableCell.getAttribute('rowspan')) > 1);
}
function hasSpanningCell(headOrBody) {
    return toArray_default()(headOrBody.querySelectorAll(TABLE_CELL_SELECT_CLASS)).some(hasSpanAttr);
}
function isCellSelected(headOrBody) {
    return !!headOrBody.querySelectorAll(TABLE_CELL_SELECT_CLASS).length;
}
function createMergedTableContextMenu(context, tableCell) {
    var i18n = context.i18n, eventEmitter = context.eventEmitter;
    var headOrBody = tableCell.parentElement.parentElement;
    var mergedTableContextMenu = [];
    if (isCellSelected(headOrBody)) {
        mergedTableContextMenu.push({
            label: i18n.get('Merge cells'),
            onClick: function () { return eventEmitter.emit('command', 'mergeCells'); },
            className: 'merge-cells',
        });
    }
    if (hasSpanAttr(tableCell) || hasSpanningCell(headOrBody)) {
        mergedTableContextMenu.push({
            label: i18n.get('Split cells'),
            onClick: function () { return eventEmitter.emit('command', 'splitCells'); },
            className: 'split-cells',
        });
    }
    return mergedTableContextMenu;
}
function addMergedTableContextMenu(context) {
    context.eventEmitter.listen('contextmenu', function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var _a = args[0], menuGroups = _a.menuGroups, tableCell = _a.tableCell;
        var mergedTableContextMenu = createMergedTableContextMenu(context, tableCell);
        if (mergedTableContextMenu.length) {
            // add merged table context menu on third group
            menuGroups.splice(2, 0, mergedTableContextMenu);
        }
    });
}

;// CONCATENATED MODULE: ./src/wysiwyg/util.ts
var util_assign = ( false) || function () {
    util_assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return util_assign.apply(this, arguments);
};
function findNodeBy(pos, condition) {
    var depth = pos.depth;
    while (depth >= 0) {
        var node = pos.node(depth);
        if (condition(node, depth)) {
            return {
                node: node,
                depth: depth,
                offset: depth > 0 ? pos.before(depth) : 0,
            };
        }
        depth -= 1;
    }
    return null;
}
function findCell(pos) {
    return findNodeBy(pos, function (_a) {
        var type = _a.type;
        return type.name === 'tableHeadCell' || type.name === 'tableBodyCell';
    });
}
function getResolvedSelection(selection, context) {
    if (selection instanceof context.pmState.TextSelection) {
        var $anchor = selection.$anchor;
        var foundCell = findCell($anchor);
        if (foundCell) {
            var anchor = $anchor.node(0).resolve($anchor.before(foundCell.depth));
            return { anchor: anchor, head: anchor };
        }
    }
    var _a = selection, startCell = _a.startCell, endCell = _a.endCell;
    return { anchor: startCell, head: endCell };
}
function getRowAndColumnCount(_a) {
    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx;
    return { rowCount: endRowIdx - startRowIdx + 1, columnCount: endColIdx - startColIdx + 1 };
}
function setAttrs(cell, attrs) {
    return util_assign(util_assign({}, cell.attrs), attrs);
}
function getCellSelectionClass(selection) {
    var proto = Object.getPrototypeOf(selection);
    return proto.constructor;
}
function createDummyCells(columnCount, rowIdx, schema, attrs) {
    if (attrs === void 0) { attrs = null; }
    var _a = schema.nodes, tableHeadCell = _a.tableHeadCell, tableBodyCell = _a.tableBodyCell, paragraph = _a.paragraph;
    var cell = rowIdx === 0 ? tableHeadCell : tableBodyCell;
    var cells = [];
    for (var index = 0; index < columnCount; index += 1) {
        cells.push(cell.create(attrs, paragraph.create()));
    }
    return cells;
}

;// CONCATENATED MODULE: ./src/wysiwyg/command/mergeCells.ts

function createMergeCellsCommand(context, OffsetMap) {
    var FragmentClass = context.pmModel.Fragment;
    var mergeCells = function (_, state, dispatch) {
        var selection = state.selection, tr = state.tr;
        var _a = getResolvedSelection(selection, context), anchor = _a.anchor, head = _a.head;
        // @ts-ignore
        // judge cell selection
        if (!anchor || !head || !selection.isCellSelection) {
            return false;
        }
        var map = OffsetMap.create(anchor);
        var CellSelection = getCellSelectionClass(selection);
        var totalRowCount = map.totalRowCount, totalColumnCount = map.totalColumnCount;
        var selectionInfo = map.getRectOffsets(anchor, head);
        var _b = getRowAndColumnCount(selectionInfo), rowCount = _b.rowCount, columnCount = _b.columnCount;
        var startRowIdx = selectionInfo.startRowIdx, startColIdx = selectionInfo.startColIdx, endRowIdx = selectionInfo.endRowIdx, endColIdx = selectionInfo.endColIdx;
        var allSelected = rowCount >= totalRowCount - 1 && columnCount === totalColumnCount;
        var hasTableHead = startRowIdx === 0 && endRowIdx > startRowIdx;
        if (allSelected || hasTableHead) {
            return false;
        }
        var fragment = FragmentClass.empty;
        for (var rowIdx = startRowIdx; rowIdx <= endRowIdx; rowIdx += 1) {
            for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {
                // set first cell content
                if (rowIdx === startRowIdx && colIdx === startColIdx) {
                    fragment = appendFragment(rowIdx, colIdx, fragment, map);
                    // set each cell content and delete the cell for spanning
                }
                else if (!map.extendedRowspan(rowIdx, colIdx) && !map.extendedColspan(rowIdx, colIdx)) {
                    var _c = map.getCellInfo(rowIdx, colIdx), offset = _c.offset, nodeSize = _c.nodeSize;
                    var from = tr.mapping.map(offset);
                    var to = from + nodeSize;
                    fragment = appendFragment(rowIdx, colIdx, fragment, map);
                    tr.delete(from, to);
                }
            }
        }
        var _d = map.getNodeAndPos(startRowIdx, startColIdx), node = _d.node, pos = _d.pos;
        // set rowspan, colspan to first root cell
        setSpanToRootCell(tr, fragment, {
            startNode: node,
            startPos: pos,
            rowCount: rowCount,
            columnCount: columnCount,
        });
        tr.setSelection(new CellSelection(tr.doc.resolve(pos)));
        dispatch(tr);
        return true;
    };
    return mergeCells;
}
function setSpanToRootCell(tr, fragment, rangeInfo) {
    var startNode = rangeInfo.startNode, startPos = rangeInfo.startPos, rowCount = rangeInfo.rowCount, columnCount = rangeInfo.columnCount;
    tr.setNodeMarkup(startPos, null, setAttrs(startNode, { colspan: columnCount, rowspan: rowCount }));
    if (fragment.size) {
        // add 1 for text start offset(not node start offset)
        tr.replaceWith(startPos + 1, startPos + startNode.content.size, fragment);
    }
}
function appendFragment(rowIdx, colIdx, fragment, map) {
    var targetFragment = map.getNodeAndPos(rowIdx, colIdx).node.content;
    // prevent to add empty string
    return targetFragment.size > 2 ? fragment.append(targetFragment) : fragment;
}

;// CONCATENATED MODULE: ./src/wysiwyg/command/splitCells.ts

function getColspanEndIdx(rowIdx, colIdx, map) {
    var endColIdx = colIdx;
    if (!map.extendedRowspan(rowIdx, colIdx) && map.extendedColspan(rowIdx, colIdx)) {
        var _a = map.getColspanStartInfo(rowIdx, colIdx), startSpanIdx = _a.startSpanIdx, count = _a.count;
        endColIdx = startSpanIdx + count;
    }
    return endColIdx;
}
function judgeInsertToNextRow(map, mappedPos, rowIdx, colIdx) {
    var totalColumnCount = map.totalColumnCount;
    return (map.extendedRowspan(rowIdx, colIdx) &&
        map.extendedRowspan(rowIdx, totalColumnCount - 1) &&
        mappedPos === map.posAt(rowIdx, totalColumnCount - 1));
}
function createSplitCellsCommand(context, OffsetMap) {
    var splitCells = function (_, state, dispatch, view) {
        var selection = state.selection, tr = state.tr;
        var _a = getResolvedSelection(selection, context), anchor = _a.anchor, head = _a.head;
        if (!anchor || !head) {
            return false;
        }
        var map = OffsetMap.create(anchor);
        var selectionInfo = map.getRectOffsets(anchor, head);
        var startRowIdx = selectionInfo.startRowIdx, startColIdx = selectionInfo.startColIdx, endRowIdx = selectionInfo.endRowIdx, endColIdx = selectionInfo.endColIdx;
        var lastCellPos = -1;
        for (var rowIdx = startRowIdx; rowIdx <= endRowIdx; rowIdx += 1) {
            for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {
                if (map.extendedRowspan(rowIdx, colIdx) || map.extendedColspan(rowIdx, colIdx)) {
                    // insert empty cell in spanning cell position
                    var node = map.getNodeAndPos(rowIdx, colIdx).node;
                    var colspanEndIdx = getColspanEndIdx(rowIdx, colIdx, map);
                    var mappedPos = map.posAt(rowIdx, colspanEndIdx);
                    var pos = tr.mapping.map(mappedPos);
                    // add 2(tr end, open tag length) to insert the cell on the next row
                    // in case that all next cells are spanning on the current row
                    if (judgeInsertToNextRow(map, mappedPos, rowIdx, colspanEndIdx)) {
                        pos += 2;
                    }
                    // get the last cell position for cell selection after splitting cells
                    lastCellPos = Math.max(pos, lastCellPos);
                    tr.insert(pos, node.type.createAndFill(setAttrs(node, { colspan: null, rowspan: null })));
                }
                else {
                    // remove colspan, rowspan of the root spanning cell
                    var _b = map.getNodeAndPos(rowIdx, colIdx), node = _b.node, pos = _b.pos;
                    // get the last cell position for cell selection after splitting cells
                    lastCellPos = Math.max(tr.mapping.map(pos), lastCellPos);
                    tr.setNodeMarkup(tr.mapping.map(pos), null, setAttrs(node, { colspan: null, rowspan: null }));
                }
            }
        }
        dispatch(tr);
        setCellSelection(view, selection, OffsetMap, map.tableStartOffset, selectionInfo);
        return true;
    };
    return splitCells;
}
function setCellSelection(view, selection, OffsetMap, tableStartPos, selectionInfo) {
    // @ts-ignore
    // judge cell selection
    if (selection.isCellSelection) {
        var tr = view.state.tr;
        var CellSelection = getCellSelectionClass(selection);
        var startRowIdx = selectionInfo.startRowIdx, startColIdx = selectionInfo.startColIdx, endRowIdx = selectionInfo.endRowIdx, endColIdx = selectionInfo.endColIdx;
        // get changed cell offsets
        var map = OffsetMap.create(tr.doc.resolve(tableStartPos));
        var startOffset = map.getCellInfo(startRowIdx, startColIdx).offset;
        var endOffset = map.getCellInfo(endRowIdx, endColIdx).offset;
        tr.setSelection(new CellSelection(tr.doc.resolve(startOffset), tr.doc.resolve(endOffset)));
        view.dispatch(tr);
    }
}

;// CONCATENATED MODULE: ./src/wysiwyg/command/removeColumn.ts

function createRemoveColumnCommand(context, OffsetMap) {
    var removeColumn = function (_, state, dispatch) {
        var selection = state.selection, tr = state.tr;
        var _a = getResolvedSelection(selection, context), anchor = _a.anchor, head = _a.head;
        if (!anchor || !head) {
            return false;
        }
        var map = OffsetMap.create(anchor);
        var selectionInfo = map.getRectOffsets(anchor, head);
        var totalColumnCount = map.totalColumnCount, totalRowCount = map.totalRowCount;
        var columnCount = getRowAndColumnCount(selectionInfo).columnCount;
        var selectedAllColumn = columnCount === totalColumnCount;
        if (selectedAllColumn) {
            return false;
        }
        var startColIdx = selectionInfo.startColIdx, endColIdx = selectionInfo.endColIdx;
        var mapStart = tr.mapping.maps.length;
        for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {
            for (var colIdx = endColIdx; colIdx >= startColIdx; colIdx -= 1) {
                var _b = map.getCellInfo(rowIdx, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;
                var colspanInfo = map.getColspanStartInfo(rowIdx, colIdx);
                if (!map.extendedRowspan(rowIdx, colIdx)) {
                    // decrease colspan count inside the col-spanning cell
                    if ((colspanInfo === null || colspanInfo === void 0 ? void 0 : colspanInfo.count) > 1) {
                        var _c = map.getColspanStartInfo(rowIdx, colIdx), node = _c.node, pos = _c.pos;
                        var colspan = map.decreaseColspanCount(rowIdx, colIdx);
                        var attrs = setAttrs(node, { colspan: colspan > 1 ? colspan : null });
                        tr.setNodeMarkup(tr.mapping.slice(mapStart).map(pos), null, attrs);
                    }
                    else {
                        var from = tr.mapping.slice(mapStart).map(offset);
                        var to = from + nodeSize;
                        tr.delete(from, to);
                    }
                }
            }
        }
        dispatch(tr);
        return true;
    };
    return removeColumn;
}

;// CONCATENATED MODULE: ./src/wysiwyg/command/removeRow.ts

function getRowRanges(map, rowIdx) {
    var totalColumnCount = map.totalColumnCount;
    var from = Number.MAX_VALUE;
    var to = 0;
    for (var colIdx = 0; colIdx < totalColumnCount; colIdx += 1) {
        if (!map.extendedRowspan(rowIdx, colIdx)) {
            var _a = map.getCellInfo(rowIdx, colIdx), offset = _a.offset, nodeSize = _a.nodeSize;
            from = Math.min(from, offset);
            to = Math.max(to, offset + nodeSize);
        }
    }
    return { from: from, to: to };
}
function createRemoveRowCommand(context, OffsetMap) {
    var removeRow = function (_, state, dispatch) {
        var selection = state.selection, tr = state.tr;
        var _a = getResolvedSelection(selection, context), anchor = _a.anchor, head = _a.head;
        if (anchor && head) {
            var map = OffsetMap.create(anchor);
            var totalRowCount = map.totalRowCount, totalColumnCount = map.totalColumnCount;
            var selectionInfo = map.getRectOffsets(anchor, head);
            var rowCount = getRowAndColumnCount(selectionInfo).rowCount;
            var startRowIdx = selectionInfo.startRowIdx, endRowIdx = selectionInfo.endRowIdx;
            var selectedThead = startRowIdx === 0;
            var selectedAllTbodyRow = rowCount === totalRowCount - 1;
            if (selectedAllTbodyRow || selectedThead) {
                return false;
            }
            for (var rowIdx = endRowIdx; rowIdx >= startRowIdx; rowIdx -= 1) {
                var mapStart = tr.mapping.maps.length;
                var _b = getRowRanges(map, rowIdx), from = _b.from, to = _b.to;
                // delete table row
                tr.delete(from - 1, to + 1);
                for (var colIdx = 0; colIdx < totalColumnCount; colIdx += 1) {
                    var rowspanInfo = map.getRowspanStartInfo(rowIdx, colIdx);
                    if ((rowspanInfo === null || rowspanInfo === void 0 ? void 0 : rowspanInfo.count) > 1 && !map.extendedColspan(rowIdx, colIdx)) {
                        // decrease rowspan count inside the row-spanning cell
                        // eslint-disable-next-line max-depth
                        if (map.extendedRowspan(rowIdx, colIdx)) {
                            var _c = map.getRowspanStartInfo(rowIdx, colIdx), node = _c.node, pos = _c.pos;
                            var rowspan = map.decreaseRowspanCount(rowIdx, colIdx);
                            var attrs = setAttrs(node, { rowspan: rowspan > 1 ? rowspan : null });
                            tr.setNodeMarkup(tr.mapping.slice(mapStart).map(pos), null, attrs);
                            // the row-spanning cell should be moved down
                        }
                        else if (!map.extendedRowspan(rowIdx, colIdx)) {
                            var _d = map.getRowspanStartInfo(rowIdx, colIdx), node = _d.node, count = _d.count;
                            var attrs = setAttrs(node, { rowspan: count > 2 ? count - 1 : null });
                            var copiedCell = node.type.create(attrs, node.content);
                            tr.insert(tr.mapping.slice(mapStart).map(map.posAt(rowIdx + 1, colIdx)), copiedCell);
                        }
                    }
                }
                map = OffsetMap.create(tr.doc.resolve(map.tableStartOffset));
            }
            dispatch(tr);
            return true;
        }
        return false;
    };
    return removeRow;
}

;// CONCATENATED MODULE: ./src/wysiwyg/command/direction.ts
// eslint-disable-next-line no-shadow
var Direction;
(function (Direction) {
    Direction["LEFT"] = "left";
    Direction["RIGHT"] = "right";
    Direction["UP"] = "up";
    Direction["DOWN"] = "down";
})(Direction || (Direction = {}));

;// CONCATENATED MODULE: ./src/wysiwyg/command/addRow.ts


function getTargetRowInfo(direction, map, selectionInfo) {
    var targetRowIdx;
    var judgeToExtendRowspan;
    var insertColIdx;
    var nodeSize;
    if (direction === Direction.UP) {
        targetRowIdx = selectionInfo.startRowIdx;
        judgeToExtendRowspan = function (colIdx) { return map.extendedRowspan(targetRowIdx, colIdx); };
        insertColIdx = 0;
        nodeSize = -1;
    }
    else {
        targetRowIdx = selectionInfo.endRowIdx;
        judgeToExtendRowspan = function (colIdx) { return map.getRowspanCount(targetRowIdx, colIdx) > 1; };
        insertColIdx = map.totalColumnCount - 1;
        nodeSize = !map.extendedRowspan(targetRowIdx, insertColIdx)
            ? map.getCellInfo(targetRowIdx, insertColIdx).nodeSize + 1
            : 2;
    }
    return { targetRowIdx: targetRowIdx, judgeToExtendRowspan: judgeToExtendRowspan, insertColIdx: insertColIdx, nodeSize: nodeSize };
}
function createAddRowCommand(context, OffsetMap, direction) {
    var addRow = function (_, state, dispatch) {
        var selection = state.selection, schema = state.schema, tr = state.tr;
        var _a = getResolvedSelection(selection, context), anchor = _a.anchor, head = _a.head;
        if (!anchor || !head) {
            return false;
        }
        var map = OffsetMap.create(anchor);
        var totalColumnCount = map.totalColumnCount;
        var selectionInfo = map.getRectOffsets(anchor, head);
        var rowCount = getRowAndColumnCount(selectionInfo).rowCount;
        var _b = getTargetRowInfo(direction, map, selectionInfo), targetRowIdx = _b.targetRowIdx, judgeToExtendRowspan = _b.judgeToExtendRowspan, insertColIdx = _b.insertColIdx, nodeSize = _b.nodeSize;
        var selectedThead = targetRowIdx === 0;
        if (selectedThead) {
            return false;
        }
        var rows = [];
        var from = tr.mapping.map(map.posAt(targetRowIdx, insertColIdx)) + nodeSize;
        var cells = [];
        for (var colIdx = 0; colIdx < totalColumnCount; colIdx += 1) {
            // increase rowspan count inside the row-spanning cell
            if (judgeToExtendRowspan(colIdx)) {
                var _c = map.getRowspanStartInfo(targetRowIdx, colIdx), node = _c.node, pos = _c.pos;
                var attrs = setAttrs(node, { rowspan: node.attrs.rowspan + rowCount });
                tr.setNodeMarkup(tr.mapping.map(pos), null, attrs);
            }
            else {
                cells = cells.concat(createDummyCells(1, targetRowIdx, schema));
            }
        }
        for (var i = 0; i < rowCount; i += 1) {
            rows.push(schema.nodes.tableRow.create(null, cells));
        }
        dispatch(tr.insert(from, rows));
        return true;
    };
    return addRow;
}

;// CONCATENATED MODULE: ./src/wysiwyg/command/addColumn.ts


function getTargetColInfo(direction, map, selectionInfo) {
    var targetColIdx;
    var judgeToExtendColspan;
    var insertColIdx;
    if (direction === Direction.LEFT) {
        targetColIdx = selectionInfo.startColIdx;
        judgeToExtendColspan = function (rowIdx) { return map.extendedColspan(rowIdx, targetColIdx); };
        insertColIdx = targetColIdx;
    }
    else {
        targetColIdx = selectionInfo.endColIdx;
        judgeToExtendColspan = function (rowIdx) { return map.getColspanCount(rowIdx, targetColIdx) > 1; };
        insertColIdx = targetColIdx + 1;
    }
    return { targetColIdx: targetColIdx, judgeToExtendColspan: judgeToExtendColspan, insertColIdx: insertColIdx };
}
function createAddColumnCommand(context, OffsetMap, direction) {
    var addColumn = function (_, state, dispatch) {
        var selection = state.selection, tr = state.tr, schema = state.schema;
        var _a = getResolvedSelection(selection, context), anchor = _a.anchor, head = _a.head;
        if (!anchor || !head) {
            return false;
        }
        var map = OffsetMap.create(anchor);
        var selectionInfo = map.getRectOffsets(anchor, head);
        var _b = getTargetColInfo(direction, map, selectionInfo), targetColIdx = _b.targetColIdx, judgeToExtendColspan = _b.judgeToExtendColspan, insertColIdx = _b.insertColIdx;
        var columnCount = getRowAndColumnCount(selectionInfo).columnCount;
        var totalRowCount = map.totalRowCount;
        for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {
            // increase colspan count inside the col-spanning cell
            if (judgeToExtendColspan(rowIdx)) {
                var _c = map.getColspanStartInfo(rowIdx, targetColIdx), node = _c.node, pos = _c.pos;
                var attrs = setAttrs(node, { colspan: node.attrs.colspan + columnCount });
                tr.setNodeMarkup(tr.mapping.map(pos), null, attrs);
            }
            else {
                var cells = createDummyCells(columnCount, rowIdx, schema);
                tr.insert(tr.mapping.map(map.posAt(rowIdx, insertColIdx)), cells);
            }
        }
        dispatch(tr);
        return true;
    };
    return addColumn;
}

;// CONCATENATED MODULE: ./src/wysiwyg/commandFactory.ts







function createCommands(context, OffsetMap) {
    return {
        mergeCells: createMergeCellsCommand(context, OffsetMap),
        splitCells: createSplitCellsCommand(context, OffsetMap),
        addRowToUp: createAddRowCommand(context, OffsetMap, Direction.UP),
        addRowToDown: createAddRowCommand(context, OffsetMap, Direction.DOWN),
        removeRow: createRemoveRowCommand(context, OffsetMap),
        addColumnToLeft: createAddColumnCommand(context, OffsetMap, Direction.LEFT),
        addColumnToRight: createAddColumnCommand(context, OffsetMap, Direction.RIGHT),
        removeColumn: createRemoveColumnCommand(context, OffsetMap),
    };
}

;// CONCATENATED MODULE: ./src/index.ts








function tableMergedCellPlugin(context) {
    var i18n = context.i18n, eventEmitter = context.eventEmitter;
    var TableOffsetMap = eventEmitter.emitReduce('mixinTableOffsetMapPrototype', offsetMapMixin, createOffsetMapMixin);
    addLangs(i18n);
    addMergedTableContextMenu(context);
    return {
        toHTMLRenderers: toHTMLRenderers,
        markdownParsers: markdownParsers,
        toMarkdownRenderers: toMarkdownRenderers,
        wysiwygCommands: createCommands(context, TableOffsetMap),
    };
}

}();
module.exports = __nested_webpack_exports__["default"];
/******/ })()
;

/***/ }),

/***/ "./node_modules/@toast-ui/editor-plugin-uml/dist/toastui-editor-plugin-uml.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@toast-ui/editor-plugin-uml/dist/toastui-editor-plugin-uml.js ***!
  \************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * TOAST UI Editor : UML Plugin
 * @version 3.0.1 | Wed Jul 07 2021
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(/*! plantuml-encoder */ "./node_modules/plantuml-encoder/browser-index.js"));
	else {}
})(self, function(__WEBPACK_EXTERNAL_MODULE__94__) {
return /******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 94:
/***/ (function(module) {

module.exports = __WEBPACK_EXTERNAL_MODULE__94__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_1278__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_1278__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__nested_webpack_require_1278__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__nested_webpack_require_1278__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__nested_webpack_require_1278__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__nested_webpack_require_1278__.o(definition, key) && !__nested_webpack_require_1278__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__nested_webpack_require_1278__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/************************************************************************/
var __nested_webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
!function() {
/* harmony export */ __nested_webpack_require_1278__.d(__nested_webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ umlPlugin; }
/* harmony export */ });
/* harmony import */ var plantuml_encoder__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_1278__(94);
/* harmony import */ var plantuml_encoder__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_1278__.n(plantuml_encoder__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @fileoverview Implements uml plugin
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */

var DEFAULT_RENDERER_URL = '//www.plantuml.com/plantuml/png/';
function createUMLTokens(text, rendererURL) {
    var renderedHTML;
    try {
        if (!(plantuml_encoder__WEBPACK_IMPORTED_MODULE_0___default())) {
            throw new Error('plantuml-encoder dependency required');
        }
        renderedHTML = "<img src=\"" + rendererURL + plantuml_encoder__WEBPACK_IMPORTED_MODULE_0___default().encode(text) + "\" />";
    }
    catch (err) {
        renderedHTML = "Error occurred on encoding uml: " + err.message;
    }
    return [
        { type: 'openTag', tagName: 'div', outerNewLine: true },
        { type: 'html', content: renderedHTML },
        { type: 'closeTag', tagName: 'div', outerNewLine: true },
    ];
}
/**
 * UML plugin
 * @param {Object} context - plugin context for communicating with editor
 * @param {Object} options - options for plugin
 * @param {string} [options.rendererURL] - url of plant uml renderer
 */
function umlPlugin(_, options) {
    if (options === void 0) { options = {}; }
    var _a = options.rendererURL, rendererURL = _a === void 0 ? DEFAULT_RENDERER_URL : _a;
    return {
        toHTMLRenderers: {
            uml: function (node) {
                return createUMLTokens(node.literal, rendererURL);
            },
            plantUml: function (node) {
                return createUMLTokens(node.literal, rendererURL);
            },
        },
    };
}

}();
__nested_webpack_exports__ = __nested_webpack_exports__.default;
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/@toast-ui/editor/dist/toastui-editor.js":
/*!**************************************************************!*\
  !*** ./node_modules/@toast-ui/editor/dist/toastui-editor.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * @toast-ui/editor
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(/*! prosemirror-commands */ "./node_modules/prosemirror-commands/dist/index.cjs"), __webpack_require__(/*! prosemirror-history */ "./node_modules/prosemirror-history/dist/index.cjs"), __webpack_require__(/*! prosemirror-inputrules */ "./node_modules/prosemirror-inputrules/dist/index.cjs"), __webpack_require__(/*! prosemirror-keymap */ "./node_modules/prosemirror-keymap/dist/index.cjs"), __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.cjs"), __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs"), __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.cjs"), __webpack_require__(/*! prosemirror-view */ "./node_modules/prosemirror-view/dist/index.cjs"));
	else {}
})(self, function(__WEBPACK_EXTERNAL_MODULE__695__, __WEBPACK_EXTERNAL_MODULE__412__, __WEBPACK_EXTERNAL_MODULE__479__, __WEBPACK_EXTERNAL_MODULE__481__, __WEBPACK_EXTERNAL_MODULE__43__, __WEBPACK_EXTERNAL_MODULE__814__, __WEBPACK_EXTERNAL_MODULE__785__, __WEBPACK_EXTERNAL_MODULE__311__) {
return /******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 368:
/***/ (function(module) {

/*! @license DOMPurify 2.3.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.3/LICENSE */

(function (global, factory) {
    true ? module.exports = factory() :
  0;
}(this, function () { 'use strict';

  function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

  var hasOwnProperty = Object.hasOwnProperty,
      setPrototypeOf = Object.setPrototypeOf,
      isFrozen = Object.isFrozen,
      getPrototypeOf = Object.getPrototypeOf,
      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
  var freeze = Object.freeze,
      seal = Object.seal,
      create = Object.create; // eslint-disable-line import/no-mutable-exports

  var _ref = typeof Reflect !== 'undefined' && Reflect,
      apply = _ref.apply,
      construct = _ref.construct;

  if (!apply) {
    apply = function apply(fun, thisValue, args) {
      return fun.apply(thisValue, args);
    };
  }

  if (!freeze) {
    freeze = function freeze(x) {
      return x;
    };
  }

  if (!seal) {
    seal = function seal(x) {
      return x;
    };
  }

  if (!construct) {
    construct = function construct(Func, args) {
      return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();
    };
  }

  var arrayForEach = unapply(Array.prototype.forEach);
  var arrayPop = unapply(Array.prototype.pop);
  var arrayPush = unapply(Array.prototype.push);

  var stringToLowerCase = unapply(String.prototype.toLowerCase);
  var stringMatch = unapply(String.prototype.match);
  var stringReplace = unapply(String.prototype.replace);
  var stringIndexOf = unapply(String.prototype.indexOf);
  var stringTrim = unapply(String.prototype.trim);

  var regExpTest = unapply(RegExp.prototype.test);

  var typeErrorCreate = unconstruct(TypeError);

  function unapply(func) {
    return function (thisArg) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return apply(func, thisArg, args);
    };
  }

  function unconstruct(func) {
    return function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return construct(func, args);
    };
  }

  /* Add properties to a lookup table */
  function addToSet(set, array) {
    if (setPrototypeOf) {
      // Make 'in' and truthy checks like Boolean(set.constructor)
      // independent of any properties defined on Object.prototype.
      // Prevent prototype setters from intercepting set as a this value.
      setPrototypeOf(set, null);
    }

    var l = array.length;
    while (l--) {
      var element = array[l];
      if (typeof element === 'string') {
        var lcElement = stringToLowerCase(element);
        if (lcElement !== element) {
          // Config presets (e.g. tags.js, attrs.js) are immutable.
          if (!isFrozen(array)) {
            array[l] = lcElement;
          }

          element = lcElement;
        }
      }

      set[element] = true;
    }

    return set;
  }

  /* Shallow clone an object */
  function clone(object) {
    var newObject = create(null);

    var property = void 0;
    for (property in object) {
      if (apply(hasOwnProperty, object, [property])) {
        newObject[property] = object[property];
      }
    }

    return newObject;
  }

  /* IE10 doesn't support __lookupGetter__ so lets'
   * simulate it. It also automatically checks
   * if the prop is function or getter and behaves
   * accordingly. */
  function lookupGetter(object, prop) {
    while (object !== null) {
      var desc = getOwnPropertyDescriptor(object, prop);
      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }

        if (typeof desc.value === 'function') {
          return unapply(desc.value);
        }
      }

      object = getPrototypeOf(object);
    }

    function fallbackValue(element) {
      console.warn('fallback value for', element);
      return null;
    }

    return fallbackValue;
  }

  var html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);

  // SVG
  var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);

  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);

  // List of SVG elements that are disallowed by default.
  // We still need to know them so that we can do namespace
  // checks properly in case one wants to add them to
  // allow-list.
  var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'feimage', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);

  var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);

  // Similarly to SVG, we want to know all MathML elements,
  // even those that we disallow by default.
  var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);

  var text = freeze(['#text']);

  var html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'slot']);

  var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);

  var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);

  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

  // eslint-disable-next-line unicorn/better-regex
  var MUSTACHE_EXPR = seal(/\{\{[\s\S]*|[\s\S]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
  var ERB_EXPR = seal(/<%[\s\S]*|[\s\S]*%>/gm);
  var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/); // eslint-disable-line no-useless-escape
  var ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
  );
  var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  var ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
  );

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

  function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

  var getGlobal = function getGlobal() {
    return typeof window === 'undefined' ? null : window;
  };

  /**
   * Creates a no-op policy for internal use only.
   * Don't export this function outside this module!
   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.
   * @param {Document} document The document object (to determine policy name suffix)
   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types
   * are not supported).
   */
  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {
    if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
      return null;
    }

    // Allow the callers to control the unique policy name
    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
    // Policy creation with duplicate names throws in Trusted Types.
    var suffix = null;
    var ATTR_NAME = 'data-tt-policy-suffix';
    if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {
      suffix = document.currentScript.getAttribute(ATTR_NAME);
    }

    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');

    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML: function createHTML(html$$1) {
          return html$$1;
        }
      });
    } catch (_) {
      // Policy creation failed (most likely another DOMPurify script has
      // already run). Skip creating the policy, as this will only cause errors
      // if TT are enforced.
      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
      return null;
    }
  };

  function createDOMPurify() {
    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();

    var DOMPurify = function DOMPurify(root) {
      return createDOMPurify(root);
    };

    /**
     * Version label, exposed for easier checks
     * if DOMPurify is up to date or not
     */
    DOMPurify.version = '2.3.3';

    /**
     * Array of elements that DOMPurify removed during sanitation.
     * Empty if nothing was removed.
     */
    DOMPurify.removed = [];

    if (!window || !window.document || window.document.nodeType !== 9) {
      // Not running in a browser, provide a factory function
      // so that you can pass your own Window
      DOMPurify.isSupported = false;

      return DOMPurify;
    }

    var originalDocument = window.document;

    var document = window.document;
    var DocumentFragment = window.DocumentFragment,
        HTMLTemplateElement = window.HTMLTemplateElement,
        Node = window.Node,
        Element = window.Element,
        NodeFilter = window.NodeFilter,
        _window$NamedNodeMap = window.NamedNodeMap,
        NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,
        Text = window.Text,
        Comment = window.Comment,
        DOMParser = window.DOMParser,
        trustedTypes = window.trustedTypes;


    var ElementPrototype = Element.prototype;

    var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
    var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
    var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
    var getParentNode = lookupGetter(ElementPrototype, 'parentNode');

    // As per issue #47, the web-components registry is inherited by a
    // new document created via createHTMLDocument. As per the spec
    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
    // a new empty registry is used when creating a template contents owner
    // document, so we use that as our parent document to ensure nothing
    // is inherited.
    if (typeof HTMLTemplateElement === 'function') {
      var template = document.createElement('template');
      if (template.content && template.content.ownerDocument) {
        document = template.content.ownerDocument;
      }
    }

    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
    var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';

    var _document = document,
        implementation = _document.implementation,
        createNodeIterator = _document.createNodeIterator,
        createDocumentFragment = _document.createDocumentFragment,
        getElementsByTagName = _document.getElementsByTagName;
    var importNode = originalDocument.importNode;


    var documentMode = {};
    try {
      documentMode = clone(document).documentMode ? document.documentMode : {};
    } catch (_) {}

    var hooks = {};

    /**
     * Expose whether this browser supports running the full DOMPurify.
     */
    DOMPurify.isSupported = typeof getParentNode === 'function' && implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;

    var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,
        ERB_EXPR$$1 = ERB_EXPR,
        DATA_ATTR$$1 = DATA_ATTR,
        ARIA_ATTR$$1 = ARIA_ATTR,
        IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,
        ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;
    var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;

    /**
     * We consider the elements and attributes below to be safe. Ideally
     * don't add any new ones but feel free to remove unwanted ones.
     */

    /* allowed element names */

    var ALLOWED_TAGS = null;
    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));

    /* Allowed attribute names */
    var ALLOWED_ATTR = null;
    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));

    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
    var FORBID_TAGS = null;

    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
    var FORBID_ATTR = null;

    /* Decide if ARIA attributes are okay */
    var ALLOW_ARIA_ATTR = true;

    /* Decide if custom data attributes are okay */
    var ALLOW_DATA_ATTR = true;

    /* Decide if unknown protocols are okay */
    var ALLOW_UNKNOWN_PROTOCOLS = false;

    /* Output should be safe for common template engines.
     * This means, DOMPurify removes data attributes, mustaches and ERB
     */
    var SAFE_FOR_TEMPLATES = false;

    /* Decide if document with <html>... should be returned */
    var WHOLE_DOCUMENT = false;

    /* Track whether config is already set on this instance of DOMPurify. */
    var SET_CONFIG = false;

    /* Decide if all elements (e.g. style, script) must be children of
     * document.body. By default, browsers might move them to document.head */
    var FORCE_BODY = false;

    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
     * string (or a TrustedHTML object if Trusted Types are supported).
     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
     */
    var RETURN_DOM = false;

    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
     * string  (or a TrustedHTML object if Trusted Types are supported) */
    var RETURN_DOM_FRAGMENT = false;

    /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM
     * `Node` is imported into the current `Document`. If this flag is not enabled the
     * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by
     * DOMPurify.
     *
     * This defaults to `true` starting DOMPurify 2.2.0. Note that setting it to `false`
     * might cause XSS from attacks hidden in closed shadowroots in case the browser
     * supports Declarative Shadow: DOM https://web.dev/declarative-shadow-dom/
     */
    var RETURN_DOM_IMPORT = true;

    /* Try to return a Trusted Type object instead of a string, return a string in
     * case Trusted Types are not supported  */
    var RETURN_TRUSTED_TYPE = false;

    /* Output should be free from DOM clobbering attacks? */
    var SANITIZE_DOM = true;

    /* Keep element content when removing element? */
    var KEEP_CONTENT = true;

    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
     * of importing it into a new Document and returning a sanitized copy */
    var IN_PLACE = false;

    /* Allow usage of profiles like html, svg and mathMl */
    var USE_PROFILES = {};

    /* Tags to ignore content of when KEEP_CONTENT is true */
    var FORBID_CONTENTS = null;
    var DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);

    /* Tags that are safe for data: URIs */
    var DATA_URI_TAGS = null;
    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);

    /* Attributes safe for values like "javascript:" */
    var URI_SAFE_ATTRIBUTES = null;
    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);

    var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
    /* Document namespace */
    var NAMESPACE = HTML_NAMESPACE;
    var IS_EMPTY_INPUT = false;

    /* Parsing of strict XHTML documents */
    var PARSER_MEDIA_TYPE = void 0;
    var SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
    var DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
    var transformCaseFunc = void 0;

    /* Keep a reference to config to pass to hooks */
    var CONFIG = null;

    /* Ideally, do not touch anything below this line */
    /* ______________________________________________ */

    var formElement = document.createElement('form');

    /**
     * _parseConfig
     *
     * @param  {Object} cfg optional config literal
     */
    // eslint-disable-next-line complexity
    var _parseConfig = function _parseConfig(cfg) {
      if (CONFIG && CONFIG === cfg) {
        return;
      }

      /* Shield configuration object from tampering */
      if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {
        cfg = {};
      }

      /* Shield configuration object from prototype pollution */
      cfg = clone(cfg);

      /* Set configuration parameters */
      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;
      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS) : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};
      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};
      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
      RETURN_DOM = cfg.RETURN_DOM || false; // Default false
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
      RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false; // Default true
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
      FORCE_BODY = cfg.FORCE_BODY || false; // Default false
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
      IN_PLACE = cfg.IN_PLACE || false; // Default false
      IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;

      PARSER_MEDIA_TYPE =
      // eslint-disable-next-line unicorn/prefer-includes
      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;

      // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
      transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? function (x) {
        return x;
      } : stringToLowerCase;

      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }

      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }

      /* Parse profile info */
      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));
        ALLOWED_ATTR = [];
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html);
          addToSet(ALLOWED_ATTR, html$1);
        }

        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg);
          addToSet(ALLOWED_ATTR, svg$1);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg$1);
          addToSet(ALLOWED_ATTR, xml);
        }

        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl);
          addToSet(ALLOWED_ATTR, mathMl$1);
          addToSet(ALLOWED_ATTR, xml);
        }
      }

      /* Merge configuration parameters */
      if (cfg.ADD_TAGS) {
        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
          ALLOWED_TAGS = clone(ALLOWED_TAGS);
        }

        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);
      }

      if (cfg.ADD_ATTR) {
        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
          ALLOWED_ATTR = clone(ALLOWED_ATTR);
        }

        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);
      }

      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);
      }

      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone(FORBID_CONTENTS);
        }

        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS);
      }

      /* Add #text in case KEEP_CONTENT is set to true */
      if (KEEP_CONTENT) {
        ALLOWED_TAGS['#text'] = true;
      }

      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
      }

      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ['tbody']);
        delete FORBID_TAGS.tbody;
      }

      // Prevent further manipulation of configuration.
      // Not available in IE8, Safari 5, etc.
      if (freeze) {
        freeze(cfg);
      }

      CONFIG = cfg;
    };

    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);

    var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);

    /* Keep track of all possible SVG and MathML tags
     * so that we can perform the namespace checks
     * correctly. */
    var ALL_SVG_TAGS = addToSet({}, svg);
    addToSet(ALL_SVG_TAGS, svgFilters);
    addToSet(ALL_SVG_TAGS, svgDisallowed);

    var ALL_MATHML_TAGS = addToSet({}, mathMl);
    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);

    /**
     *
     *
     * @param  {Element} element a DOM element whose namespace is being checked
     * @returns {boolean} Return false if the element has a
     *  namespace that a spec-compliant parser would never
     *  return. Return true otherwise.
     */
    var _checkValidNamespace = function _checkValidNamespace(element) {
      var parent = getParentNode(element);

      // In JSDOM, if we're inside shadow DOM, then parentNode
      // can be null. We just simulate parent in this case.
      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: HTML_NAMESPACE,
          tagName: 'template'
        };
      }

      var tagName = stringToLowerCase(element.tagName);
      var parentTagName = stringToLowerCase(parent.tagName);

      if (element.namespaceURI === SVG_NAMESPACE) {
        // The only way to switch from HTML namespace to SVG
        // is via <svg>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'svg';
        }

        // The only way to switch from MathML to SVG is via
        // svg if parent is either <annotation-xml> or MathML
        // text integration points.
        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        }

        // We only allow elements that are defined in SVG
        // spec. All others are disallowed in SVG namespace.
        return Boolean(ALL_SVG_TAGS[tagName]);
      }

      if (element.namespaceURI === MATHML_NAMESPACE) {
        // The only way to switch from HTML namespace to MathML
        // is via <math>. If it happens via any other tag, then
        // it should be killed.
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === 'math';
        }

        // The only way to switch from SVG to MathML is via
        // <math> and HTML integration points
        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
        }

        // We only allow elements that are defined in MathML
        // spec. All others are disallowed in MathML namespace.
        return Boolean(ALL_MATHML_TAGS[tagName]);
      }

      if (element.namespaceURI === HTML_NAMESPACE) {
        // The only way to switch from SVG to HTML is via
        // HTML integration points, and from MathML to HTML
        // is via MathML text integration points
        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }

        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }

        // Certain elements are allowed in both SVG and HTML
        // namespace. We need to specify them explicitly
        // so that they don't get erronously deleted from
        // HTML namespace.
        var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']);

        // We disallow tags that are specific for MathML
        // or SVG and should never appear in HTML namespace
        return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);
      }

      // The code should never reach this place (this means
      // that the element somehow got namespace that is not
      // HTML, SVG or MathML). Return false just in case.
      return false;
    };

    /**
     * _forceRemove
     *
     * @param  {Node} node a DOM node
     */
    var _forceRemove = function _forceRemove(node) {
      arrayPush(DOMPurify.removed, { element: node });
      try {
        // eslint-disable-next-line unicorn/prefer-dom-node-remove
        node.parentNode.removeChild(node);
      } catch (_) {
        try {
          node.outerHTML = emptyHTML;
        } catch (_) {
          node.remove();
        }
      }
    };

    /**
     * _removeAttribute
     *
     * @param  {String} name an Attribute name
     * @param  {Node} node a DOM node
     */
    var _removeAttribute = function _removeAttribute(name, node) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: node.getAttributeNode(name),
          from: node
        });
      } catch (_) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: node
        });
      }

      node.removeAttribute(name);

      // We void attribute values for unremovable "is"" attributes
      if (name === 'is' && !ALLOWED_ATTR[name]) {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(node);
          } catch (_) {}
        } else {
          try {
            node.setAttribute(name, '');
          } catch (_) {}
        }
      }
    };

    /**
     * _initDocument
     *
     * @param  {String} dirty a string of dirty markup
     * @return {Document} a DOM, filled with the dirty markup
     */
    var _initDocument = function _initDocument(dirty) {
      /* Create a HTML document */
      var doc = void 0;
      var leadingWhitespace = void 0;

      if (FORCE_BODY) {
        dirty = '<remove></remove>' + dirty;
      } else {
        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
        var matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }

      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml') {
        // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
        dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
      }

      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      /*
       * Use the DOMParser API by default, fallback later if needs be
       * DOMParser not work for svg when has multiple root element.
       */
      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
        } catch (_) {}
      }

      /* Use createHTMLDocument in case DOMParser is not available */
      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, 'template', null);
        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? '' : dirtyPayload;
        } catch (_) {
          // Syntax error if dirtyPayload is invalid xml
        }
      }

      var body = doc.body || doc.documentElement;

      if (dirty && leadingWhitespace) {
        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
      }

      /* Work on whole document or just its body */
      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
      }

      return WHOLE_DOCUMENT ? doc.documentElement : body;
    };

    /**
     * _createIterator
     *
     * @param  {Document} root document/fragment to create iterator for
     * @return {Iterator} iterator instance
     */
    var _createIterator = function _createIterator(root) {
      return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);
    };

    /**
     * _isClobbered
     *
     * @param  {Node} elm element to check for clobbering attacks
     * @return {Boolean} true if clobbered, false if safe
     */
    var _isClobbered = function _isClobbered(elm) {
      if (elm instanceof Text || elm instanceof Comment) {
        return false;
      }

      if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function') {
        return true;
      }

      return false;
    };

    /**
     * _isNode
     *
     * @param  {Node} obj object to check whether it's a DOM node
     * @return {Boolean} true is object is a DOM node
     */
    var _isNode = function _isNode(object) {
      return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';
    };

    /**
     * _executeHook
     * Execute user configurable hooks
     *
     * @param  {String} entryPoint  Name of the hook's entry point
     * @param  {Node} currentNode node to work on with the hook
     * @param  {Object} data additional hook parameters
     */
    var _executeHook = function _executeHook(entryPoint, currentNode, data) {
      if (!hooks[entryPoint]) {
        return;
      }

      arrayForEach(hooks[entryPoint], function (hook) {
        hook.call(DOMPurify, currentNode, data, CONFIG);
      });
    };

    /**
     * _sanitizeElements
     *
     * @protect nodeName
     * @protect textContent
     * @protect removeChild
     *
     * @param   {Node} currentNode to check for permission to exist
     * @return  {Boolean} true if node was killed, false if left alive
     */
    var _sanitizeElements = function _sanitizeElements(currentNode) {
      var content = void 0;

      /* Execute a hook if present */
      _executeHook('beforeSanitizeElements', currentNode, null);

      /* Check if element is clobbered or can clobber */
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Check if tagname contains Unicode */
      if (stringMatch(currentNode.nodeName, /[\u0080-\uFFFF]/)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Now let's check the element's type and name */
      var tagName = transformCaseFunc(currentNode.nodeName);

      /* Execute a hook if present */
      _executeHook('uponSanitizeElement', currentNode, {
        tagName: tagName,
        allowedTags: ALLOWED_TAGS
      });

      /* Detect mXSS attempts abusing namespace confusion */
      if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Mitigate a problem with templates inside select */
      if (tagName === 'select' && regExpTest(/<template/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Remove element if anything forbids its presence */
      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
        /* Keep content except for bad-listed elements */
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          var parentNode = getParentNode(currentNode) || currentNode.parentNode;
          var childNodes = getChildNodes(currentNode) || currentNode.childNodes;

          if (childNodes && parentNode) {
            var childCount = childNodes.length;

            for (var i = childCount - 1; i >= 0; --i) {
              parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
            }
          }
        }

        _forceRemove(currentNode);
        return true;
      }

      /* Check whether element has a valid namespace */
      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }

      if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }

      /* Sanitize element content to be template-safe */
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
        /* Get the element's text content */
        content = currentNode.textContent;
        content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');
        content = stringReplace(content, ERB_EXPR$$1, ' ');
        if (currentNode.textContent !== content) {
          arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });
          currentNode.textContent = content;
        }
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeElements', currentNode, null);

      return false;
    };

    /**
     * _isValidAttribute
     *
     * @param  {string} lcTag Lowercase tag name of containing element.
     * @param  {string} lcName Lowercase attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if `value` is valid, otherwise false.
     */
    // eslint-disable-next-line complexity
    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
      /* Make sure attribute cannot clobber */
      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
        return false;
      }

      /* Allow valid data-* attributes: At least one character after "-"
          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
          We don't need to check the value; it's always URI safe. */
      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        return false;

        /* Check value is safe. First, is attr inert? If so, is safe */
      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {
        return false;
      }

      return true;
    };

    /**
     * _sanitizeAttributes
     *
     * @protect attributes
     * @protect nodeName
     * @protect removeAttribute
     * @protect setAttribute
     *
     * @param  {Node} currentNode to sanitize
     */
    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
      var attr = void 0;
      var value = void 0;
      var lcName = void 0;
      var l = void 0;
      /* Execute a hook if present */
      _executeHook('beforeSanitizeAttributes', currentNode, null);

      var attributes = currentNode.attributes;

      /* Check if we have attributes; if not we might have a text node */

      if (!attributes) {
        return;
      }

      var hookEvent = {
        attrName: '',
        attrValue: '',
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR
      };
      l = attributes.length;

      /* Go backwards over all attributes; safely remove bad ones */
      while (l--) {
        attr = attributes[l];
        var _attr = attr,
            name = _attr.name,
            namespaceURI = _attr.namespaceURI;

        value = stringTrim(attr.value);
        lcName = transformCaseFunc(name);

        /* Execute a hook if present */
        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);
        value = hookEvent.attrValue;
        /* Did the hooks approve of the attribute? */
        if (hookEvent.forceKeepAttr) {
          continue;
        }

        /* Remove attribute */
        _removeAttribute(name, currentNode);

        /* Did the hooks approve of the attribute? */
        if (!hookEvent.keepAttr) {
          continue;
        }

        /* Work around a security issue in jQuery 3.0 */
        if (regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }

        /* Sanitize attribute content to be template-safe */
        if (SAFE_FOR_TEMPLATES) {
          value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');
          value = stringReplace(value, ERB_EXPR$$1, ' ');
        }

        /* Is `value` valid for this attribute? */
        var lcTag = transformCaseFunc(currentNode.nodeName);
        if (!_isValidAttribute(lcTag, lcName, value)) {
          continue;
        }

        /* Handle invalid data-* attribute set by try-catching it */
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
            currentNode.setAttribute(name, value);
          }

          arrayPop(DOMPurify.removed);
        } catch (_) {}
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeAttributes', currentNode, null);
    };

    /**
     * _sanitizeShadowDOM
     *
     * @param  {DocumentFragment} fragment to iterate over recursively
     */
    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
      var shadowNode = void 0;
      var shadowIterator = _createIterator(fragment);

      /* Execute a hook if present */
      _executeHook('beforeSanitizeShadowDOM', fragment, null);

      while (shadowNode = shadowIterator.nextNode()) {
        /* Execute a hook if present */
        _executeHook('uponSanitizeShadowNode', shadowNode, null);

        /* Sanitize tags and elements */
        if (_sanitizeElements(shadowNode)) {
          continue;
        }

        /* Deep shadow DOM detected */
        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(shadowNode.content);
        }

        /* Check attributes, sanitize if necessary */
        _sanitizeAttributes(shadowNode);
      }

      /* Execute a hook if present */
      _executeHook('afterSanitizeShadowDOM', fragment, null);
    };

    /**
     * Sanitize
     * Public method providing core sanitation functionality
     *
     * @param {String|Node} dirty string or DOM node
     * @param {Object} configuration object
     */
    // eslint-disable-next-line complexity
    DOMPurify.sanitize = function (dirty, cfg) {
      var body = void 0;
      var importedNode = void 0;
      var currentNode = void 0;
      var oldNode = void 0;
      var returnNode = void 0;
      /* Make sure we have a string to sanitize.
        DO NOT return early, as this will return the wrong type if
        the user has requested a DOM object rather than a string */
      IS_EMPTY_INPUT = !dirty;
      if (IS_EMPTY_INPUT) {
        dirty = '<!-->';
      }

      /* Stringify, in case dirty is an object */
      if (typeof dirty !== 'string' && !_isNode(dirty)) {
        // eslint-disable-next-line no-negated-condition
        if (typeof dirty.toString !== 'function') {
          throw typeErrorCreate('toString is not a function');
        } else {
          dirty = dirty.toString();
          if (typeof dirty !== 'string') {
            throw typeErrorCreate('dirty is not a string, aborting');
          }
        }
      }

      /* Check we can run. Otherwise fall back or ignore */
      if (!DOMPurify.isSupported) {
        if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {
          if (typeof dirty === 'string') {
            return window.toStaticHTML(dirty);
          }

          if (_isNode(dirty)) {
            return window.toStaticHTML(dirty.outerHTML);
          }
        }

        return dirty;
      }

      /* Assign config vars */
      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }

      /* Clean up removed elements */
      DOMPurify.removed = [];

      /* Check if dirty is correctly typed for IN_PLACE */
      if (typeof dirty === 'string') {
        IN_PLACE = false;
      }

      if (IN_PLACE) ; else if (dirty instanceof Node) {
        /* If dirty is a DOM element, append to an empty document to avoid
           elements being stripped by the parser */
        body = _initDocument('<!---->');
        importedNode = body.ownerDocument.importNode(dirty, true);
        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {
          /* Node is already a body, use as is */
          body = importedNode;
        } else if (importedNode.nodeName === 'HTML') {
          body = importedNode;
        } else {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          body.appendChild(importedNode);
        }
      } else {
        /* Exit directly if we have nothing to do */
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
        // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf('<') === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }

        /* Initialize the document to work on */
        body = _initDocument(dirty);

        /* Check we have a DOM node from the data */
        if (!body) {
          return RETURN_DOM ? null : emptyHTML;
        }
      }

      /* Remove first element node (ours) if FORCE_BODY is set */
      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }

      /* Get node iterator */
      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);

      /* Now start iterating over the created document */
      while (currentNode = nodeIterator.nextNode()) {
        /* Fix IE's strange behavior with manipulated textNodes #89 */
        if (currentNode.nodeType === 3 && currentNode === oldNode) {
          continue;
        }

        /* Sanitize tags and elements */
        if (_sanitizeElements(currentNode)) {
          continue;
        }

        /* Shadow DOM detected, sanitize it */
        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }

        /* Check attributes, sanitize if necessary */
        _sanitizeAttributes(currentNode);

        oldNode = currentNode;
      }

      oldNode = null;

      /* If we sanitized `dirty` in-place, return it. */
      if (IN_PLACE) {
        return dirty;
      }

      /* Return sanitized string or DOM */
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);

          while (body.firstChild) {
            // eslint-disable-next-line unicorn/prefer-dom-node-append
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }

        if (RETURN_DOM_IMPORT) {
          /*
            AdoptNode() is not used because internal state is not reset
            (e.g. the past names map of a HTMLFormElement), this is safe
            in theory but we would rather not risk another attack vector.
            The state that is cloned by importNode() is explicitly defined
            by the specs.
          */
          returnNode = importNode.call(originalDocument, returnNode, true);
        }

        return returnNode;
      }

      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;

      /* Sanitize final string template-safe */
      if (SAFE_FOR_TEMPLATES) {
        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');
        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');
      }

      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };

    /**
     * Public method to set the configuration once
     * setConfig
     *
     * @param {Object} cfg configuration object
     */
    DOMPurify.setConfig = function (cfg) {
      _parseConfig(cfg);
      SET_CONFIG = true;
    };

    /**
     * Public method to remove the configuration
     * clearConfig
     *
     */
    DOMPurify.clearConfig = function () {
      CONFIG = null;
      SET_CONFIG = false;
    };

    /**
     * Public method to check if an attribute value is valid.
     * Uses last set config, if any. Otherwise, uses config defaults.
     * isValidAttribute
     *
     * @param  {string} tag Tag name of containing element.
     * @param  {string} attr Attribute name.
     * @param  {string} value Attribute value.
     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.
     */
    DOMPurify.isValidAttribute = function (tag, attr, value) {
      /* Initialize shared config vars if necessary. */
      if (!CONFIG) {
        _parseConfig({});
      }

      var lcTag = transformCaseFunc(tag);
      var lcName = transformCaseFunc(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };

    /**
     * AddHook
     * Public method to add DOMPurify hooks
     *
     * @param {String} entryPoint entry point for the hook to add
     * @param {Function} hookFunction function to execute
     */
    DOMPurify.addHook = function (entryPoint, hookFunction) {
      if (typeof hookFunction !== 'function') {
        return;
      }

      hooks[entryPoint] = hooks[entryPoint] || [];
      arrayPush(hooks[entryPoint], hookFunction);
    };

    /**
     * RemoveHook
     * Public method to remove a DOMPurify hook at a given entryPoint
     * (pops it from the stack of hooks if more are present)
     *
     * @param {String} entryPoint entry point for the hook to remove
     */
    DOMPurify.removeHook = function (entryPoint) {
      if (hooks[entryPoint]) {
        arrayPop(hooks[entryPoint]);
      }
    };

    /**
     * RemoveHooks
     * Public method to remove all DOMPurify hooks at a given entryPoint
     *
     * @param  {String} entryPoint entry point for the hooks to remove
     */
    DOMPurify.removeHooks = function (entryPoint) {
      if (hooks[entryPoint]) {
        hooks[entryPoint] = [];
      }
    };

    /**
     * RemoveAllHooks
     * Public method to remove all DOMPurify hooks
     *
     */
    DOMPurify.removeAllHooks = function () {
      hooks = {};
    };

    return DOMPurify;
  }

  var purify = createDOMPurify();

  return purify;

}));
//# sourceMappingURL=purify.js.map


/***/ }),

/***/ 928:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_57532__) {

"use strict";
/* eslint-disable complexity */
/**
 * @fileoverview Returns the first index at which a given element can be found in the array.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isArray = __nested_webpack_require_57532__(322);

/**
 * @module array
 */

/**
 * Returns the first index at which a given element can be found in the array
 * from start index(default 0), or -1 if it is not present.
 * It compares searchElement to elements of the Array using strict equality
 * (the same method used by the ===, or triple-equals, operator).
 * @param {*} searchElement Element to locate in the array
 * @param {Array} array Array that will be traversed.
 * @param {number} startIndex Start index in array for searching (default 0)
 * @returns {number} the First index at which a given element, or -1 if it is not present
 * @memberof module:array
 * @example
 * // ES6
 * import inArray from 'tui-code-snippet/array/inArray';
 * 
 * // CommonJS
 * const inArray = require('tui-code-snippet/array/inArray');
 *
 * const arr = ['one', 'two', 'three', 'four'];
 * const idx1 = inArray('one', arr, 3); // -1
 * const idx2 = inArray('one', arr); // 0
 */
function inArray(searchElement, array, startIndex) {
  var i;
  var length;
  startIndex = startIndex || 0;

  if (!isArray(array)) {
    return -1;
  }

  if (Array.prototype.indexOf) {
    return Array.prototype.indexOf.call(array, searchElement, startIndex);
  }

  length = array.length;
  for (i = startIndex; startIndex >= 0 && i < length; i += 1) {
    if (array[i] === searchElement) {
      return i;
    }
  }

  return -1;
}

module.exports = inArray;


/***/ }),

/***/ 690:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_59261__) {

"use strict";
/**
 * @fileoverview Execute the provided callback once for each property of object(or element of array) which actually exist.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isArray = __nested_webpack_require_59261__(322);
var forEachArray = __nested_webpack_require_59261__(893);
var forEachOwnProperties = __nested_webpack_require_59261__(956);

/**
 * @module collection
 */

/**
 * Execute the provided callback once for each property of object(or element of array) which actually exist.
 * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of example).
 * If the callback function returns false, the loop will be stopped.
 * Callback function(iteratee) is invoked with three arguments:
 *  1) The value of the property(or The value of the element)
 *  2) The name of the property(or The index of the element)
 *  3) The object being traversed
 * @param {Object} obj The object that will be traversed
 * @param {function} iteratee Callback function
 * @param {Object} [context] Context(this) of callback function
 * @memberof module:collection
 * @example
 * // ES6
 * import forEach from 'tui-code-snippet/collection/forEach'; 
 * 
 * // CommonJS
 * const forEach = require('tui-code-snippet/collection/forEach'); 
 *
 * let sum = 0;
 *
 * forEach([1,2,3], function(value){
 *   sum += value;
 * });
 * alert(sum); // 6
 *
 * // In case of Array-like object
 * const array = Array.prototype.slice.call(arrayLike); // change to array
 * forEach(array, function(value){
 *   sum += value;
 * });
 */
function forEach(obj, iteratee, context) {
  if (isArray(obj)) {
    forEachArray(obj, iteratee, context);
  } else {
    forEachOwnProperties(obj, iteratee, context);
  }
}

module.exports = forEach;


/***/ }),

/***/ 893:
/***/ (function(module) {

"use strict";
/**
 * @fileoverview Execute the provided callback once for each element present in the array(or Array-like object) in ascending order.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Execute the provided callback once for each element present
 * in the array(or Array-like object) in ascending order.
 * If the callback function returns false, the loop will be stopped.
 * Callback function(iteratee) is invoked with three arguments:
 *  1) The value of the element
 *  2) The index of the element
 *  3) The array(or Array-like object) being traversed
 * @param {Array|Arguments|NodeList} arr The array(or Array-like object) that will be traversed
 * @param {function} iteratee Callback function
 * @param {Object} [context] Context(this) of callback function
 * @memberof module:collection
 * @example
 * // ES6
 * import forEachArray from 'tui-code-snippet/collection/forEachArray';
 * 
 * // CommonJS
 * const forEachArray = require('tui-code-snippet/collection/forEachArray'); 
 *
 * let sum = 0;
 *
 * forEachArray([1,2,3], function(value){
 *   sum += value;
 * });
 * alert(sum); // 6
 */
function forEachArray(arr, iteratee, context) {
  var index = 0;
  var len = arr.length;

  context = context || null;

  for (; index < len; index += 1) {
    if (iteratee.call(context, arr[index], index, arr) === false) {
      break;
    }
  }
}

module.exports = forEachArray;


/***/ }),

/***/ 956:
/***/ (function(module) {

"use strict";
/**
 * @fileoverview Execute the provided callback once for each property of object which actually exist.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Execute the provided callback once for each property of object which actually exist.
 * If the callback function returns false, the loop will be stopped.
 * Callback function(iteratee) is invoked with three arguments:
 *  1) The value of the property
 *  2) The name of the property
 *  3) The object being traversed
 * @param {Object} obj The object that will be traversed
 * @param {function} iteratee  Callback function
 * @param {Object} [context] Context(this) of callback function
 * @memberof module:collection
 * @example
 * // ES6
 * import forEachOwnProperties from 'tui-code-snippet/collection/forEachOwnProperties';
 * 
 * // CommonJS
 * const forEachOwnProperties = require('tui-code-snippet/collection/forEachOwnProperties'); 
 *
 * let sum = 0;
 *
 * forEachOwnProperties({a:1,b:2,c:3}, function(value){
 *   sum += value;
 * });
 * alert(sum); // 6
 */
function forEachOwnProperties(obj, iteratee, context) {
  var key;

  context = context || null;

  for (key in obj) {
    if (obj.hasOwnProperty(key)) {
      if (iteratee.call(context, obj[key], key, obj) === false) {
        break;
      }
    }
  }
}

module.exports = forEachOwnProperties;


/***/ }),

/***/ 990:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_63984__) {

"use strict";
/**
 * @fileoverview Transform the Array-like object to Array.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var forEachArray = __nested_webpack_require_63984__(893);

/**
 * Transform the Array-like object to Array.
 * In low IE (below 8), Array.prototype.slice.call is not perfect. So, try-catch statement is used.
 * @param {*} arrayLike Array-like object
 * @returns {Array} Array
 * @memberof module:collection
 * @example
 * // ES6
 * import toArray from 'tui-code-snippet/collection/toArray'; 
 * 
 * // CommonJS
 * const toArray = require('tui-code-snippet/collection/toArray'); 
 *
 * const arrayLike = {
 *   0: 'one',
 *   1: 'two',
 *   2: 'three',
 *   3: 'four',
 *   length: 4
 * };
 * const result = toArray(arrayLike);
 *
 * alert(result instanceof Array); // true
 * alert(result); // one,two,three,four
 */
function toArray(arrayLike) {
  var arr;
  try {
    arr = Array.prototype.slice.call(arrayLike);
  } catch (e) {
    arr = [];
    forEachArray(arrayLike, function(value) {
      arr.push(value);
    });
  }

  return arr;
}

module.exports = toArray;


/***/ }),

/***/ 755:
/***/ (function(module) {

"use strict";
/**
 * @fileoverview Get event collection for specific HTML element
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var EVENT_KEY = '_feEventKey';

/**
 * Get event collection for specific HTML element
 * @param {HTMLElement} element - HTML element
 * @param {string} type - event type
 * @returns {array}
 * @private
 */
function safeEvent(element, type) {
  var events = element[EVENT_KEY];
  var handlers;

  if (!events) {
    events = element[EVENT_KEY] = {};
  }

  handlers = events[type];
  if (!handlers) {
    handlers = events[type] = [];
  }

  return handlers;
}

module.exports = safeEvent;


/***/ }),

/***/ 349:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_65868__) {

"use strict";
/**
 * @fileoverview Unbind DOM events
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isString = __nested_webpack_require_65868__(758);
var forEach = __nested_webpack_require_65868__(690);

var safeEvent = __nested_webpack_require_65868__(755);

/**
 * Unbind DOM events
 * If a handler function is not passed, remove all events of that type.
 * @param {HTMLElement} element - element to unbind events
 * @param {(string|object)} types - Space splitted events names or eventName:handler object
 * @param {function} [handler] - handler function
 * @memberof module:domEvent
 * @example
 * // Following the example of domEvent#on
 * 
 * // Unbind one event from an element.
 * off(div, 'click', toggle);
 * 
 * // Unbind multiple events with a same handler from multiple elements at once.
 * // Use event names splitted by a space.
 * off(element, 'mouseenter mouseleave', changeColor);
 * 
 * // Unbind multiple events with different handlers from an element at once.
 * // Use an object which of key is an event name and value is a handler function.
 * off(div, {
 *   keydown: highlight,
 *   keyup: dehighlight
 * });
 * 
 * // Unbind events without handlers.
 * off(div, 'drag');
 */
function off(element, types, handler) {
  if (isString(types)) {
    forEach(types.split(/\s+/g), function(type) {
      unbindEvent(element, type, handler);
    });

    return;
  }

  forEach(types, function(func, type) {
    unbindEvent(element, type, func);
  });
}

/**
 * Unbind DOM events
 * If a handler function is not passed, remove all events of that type.
 * @param {HTMLElement} element - element to unbind events
 * @param {string} type - events name
 * @param {function} [handler] - handler function
 * @private
 */
function unbindEvent(element, type, handler) {
  var events = safeEvent(element, type);
  var index;

  if (!handler) {
    forEach(events, function(item) {
      removeHandler(element, type, item.wrappedHandler);
    });
    events.splice(0, events.length);
  } else {
    forEach(events, function(item, idx) {
      if (handler === item.handler) {
        removeHandler(element, type, item.wrappedHandler);
        index = idx;

        return false;
      }

      return true;
    });
    events.splice(index, 1);
  }
}

/**
 * Remove an event handler
 * @param {HTMLElement} element - An element to remove an event
 * @param {string} type - event type
 * @param {function} handler - event handler
 * @private
 */
function removeHandler(element, type, handler) {
  if ('removeEventListener' in element) {
    element.removeEventListener(type, handler);
  } else if ('detachEvent' in element) {
    element.detachEvent('on' + type, handler);
  }
}

module.exports = off;


/***/ }),

/***/ 348:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_68655__) {

"use strict";
/**
 * @fileoverview Bind DOM events
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isString = __nested_webpack_require_68655__(758);
var forEach = __nested_webpack_require_68655__(690);

var safeEvent = __nested_webpack_require_68655__(755);

/**
 * Bind DOM events.
 * @param {HTMLElement} element - element to bind events
 * @param {(string|object)} types - Space splitted events names or eventName:handler object
 * @param {(function|object)} handler - handler function or context for handler method
 * @param {object} [context] context - context for handler method.
 * @memberof module:domEvent
 * @example
 * const div = document.querySelector('div');
 * 
 * // Bind one event to an element.
 * on(div, 'click', toggle);
 * 
 * // Bind multiple events with a same handler to multiple elements at once.
 * // Use event names splitted by a space.
 * on(div, 'mouseenter mouseleave', changeColor);
 * 
 * // Bind multiple events with different handlers to an element at once.
 * // Use an object which of key is an event name and value is a handler function.
 * on(div, {
 *   keydown: highlight,
 *   keyup: dehighlight
 * });
 * 
 * // Set a context for handler method.
 * const name = 'global';
 * const repository = {name: 'CodeSnippet'};
 * on(div, 'drag', function() {
 *   console.log(this.name);
 * }, repository);
 * // Result when you drag a div: "CodeSnippet"
 */
function on(element, types, handler, context) {
  if (isString(types)) {
    forEach(types.split(/\s+/g), function(type) {
      bindEvent(element, type, handler, context);
    });

    return;
  }

  forEach(types, function(func, type) {
    bindEvent(element, type, func, handler);
  });
}

/**
 * Bind DOM events
 * @param {HTMLElement} element - element to bind events
 * @param {string} type - events name
 * @param {function} handler - handler function or context for handler method
 * @param {object} [context] context - context for handler method.
 * @private
 */
function bindEvent(element, type, handler, context) {
  /**
     * Event handler
     * @param {Event} e - event object
     */
  function eventHandler(e) {
    handler.call(context || element, e || window.event);
  }

  if ('addEventListener' in element) {
    element.addEventListener(type, eventHandler);
  } else if ('attachEvent' in element) {
    element.attachEvent('on' + type, eventHandler);
  }
  memorizeHandler(element, type, handler, eventHandler);
}

/**
 * Memorize DOM event handler for unbinding.
 * @param {HTMLElement} element - element to bind events
 * @param {string} type - events name
 * @param {function} handler - handler function that user passed at on() use
 * @param {function} wrappedHandler - handler function that wrapped by domevent for implementing some features
 * @private
 */
function memorizeHandler(element, type, handler, wrappedHandler) {
  var events = safeEvent(element, type);
  var existInEvents = false;

  forEach(events, function(obj) {
    if (obj.handler === handler) {
      existInEvents = true;

      return false;
    }

    return true;
  });

  if (!existInEvents) {
    events.push({
      handler: handler,
      wrappedHandler: wrappedHandler
    });
  }
}

module.exports = on;


/***/ }),

/***/ 24:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_71938__) {

"use strict";
/**
 * @fileoverview Set className value
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isArray = __nested_webpack_require_71938__(322);
var isUndefined = __nested_webpack_require_71938__(929);

/**
 * Set className value
 * @param {(HTMLElement|SVGElement)} element - target element
 * @param {(string|string[])} cssClass - class names
 * @private
 */
function setClassName(element, cssClass) {
  cssClass = isArray(cssClass) ? cssClass.join(' ') : cssClass;

  cssClass = cssClass.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

  if (isUndefined(element.className.baseVal)) {
    element.className = cssClass;

    return;
  }

  element.className.baseVal = cssClass;
}

module.exports = setClassName;


/***/ }),

/***/ 204:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_72755__) {

"use strict";
/**
 * @fileoverview Add css class to element
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var forEach = __nested_webpack_require_72755__(690);
var inArray = __nested_webpack_require_72755__(928);
var getClass = __nested_webpack_require_72755__(902);
var setClassName = __nested_webpack_require_72755__(24);

/**
 * domUtil module
 * @module domUtil
 */

/**
 * Add css class to element
 * @param {(HTMLElement|SVGElement)} element - target element
 * @param {...string} cssClass - css classes to add
 * @memberof module:domUtil
 */
function addClass(element) {
  var cssClass = Array.prototype.slice.call(arguments, 1);
  var classList = element.classList;
  var newClass = [];
  var origin;

  if (classList) {
    forEach(cssClass, function(name) {
      element.classList.add(name);
    });

    return;
  }

  origin = getClass(element);

  if (origin) {
    cssClass = [].concat(origin.split(/\s+/), cssClass);
  }

  forEach(cssClass, function(cls) {
    if (inArray(cls, newClass) < 0) {
      newClass.push(cls);
    }
  });

  setClassName(element, newClass);
}

module.exports = addClass;


/***/ }),

/***/ 522:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_73935__) {

"use strict";
/**
 * @fileoverview Setting element style
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isString = __nested_webpack_require_73935__(758);
var forEach = __nested_webpack_require_73935__(690);

/**
 * Setting element style
 * @param {(HTMLElement|SVGElement)} element - element to setting style
 * @param {(string|object)} key - style prop name or {prop: value} pair object
 * @param {string} [value] - style value
 * @memberof module:domUtil
 */
function css(element, key, value) {
  var style = element.style;

  if (isString(key)) {
    style[key] = value;

    return;
  }

  forEach(key, function(v, k) {
    style[k] = v;
  });
}

module.exports = css;


/***/ }),

/***/ 902:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_74702__) {

"use strict";
/**
 * @fileoverview Get HTML element's design classes.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isUndefined = __nested_webpack_require_74702__(929);

/**
 * Get HTML element's design classes.
 * @param {(HTMLElement|SVGElement)} element target element
 * @returns {string} element css class name
 * @memberof module:domUtil
 */
function getClass(element) {
  if (!element || !element.className) {
    return '';
  }

  if (isUndefined(element.className.baseVal)) {
    return element.className;
  }

  return element.className.baseVal;
}

module.exports = getClass;


/***/ }),

/***/ 714:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_75396__) {

"use strict";
/**
 * @fileoverview Check element has specific css class
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var inArray = __nested_webpack_require_75396__(928);
var getClass = __nested_webpack_require_75396__(902);

/**
 * Check element has specific css class
 * @param {(HTMLElement|SVGElement)} element - target element
 * @param {string} cssClass - css class
 * @returns {boolean}
 * @memberof module:domUtil
 */
function hasClass(element, cssClass) {
  var origin;

  if (element.classList) {
    return element.classList.contains(cssClass);
  }

  origin = getClass(element).split(/\s+/);

  return inArray(cssClass, origin) > -1;
}

module.exports = hasClass;


/***/ }),

/***/ 471:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_76163__) {

"use strict";
/**
 * @fileoverview Check element match selector
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var inArray = __nested_webpack_require_76163__(928);
var toArray = __nested_webpack_require_76163__(990);

var elProto = Element.prototype;
var matchSelector = elProto.matches ||
    elProto.webkitMatchesSelector ||
    elProto.mozMatchesSelector ||
    elProto.msMatchesSelector ||
    function(selector) {
      var doc = this.document || this.ownerDocument;

      return inArray(this, toArray(doc.querySelectorAll(selector))) > -1;
    };

/**
 * Check element match selector
 * @param {HTMLElement} element - element to check
 * @param {string} selector - selector to check
 * @returns {boolean} is selector matched to element?
 * @memberof module:domUtil
 */
function matches(element, selector) {
  return matchSelector.call(element, selector);
}

module.exports = matches;


/***/ }),

/***/ 462:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_77144__) {

"use strict";
/**
 * @fileoverview Remove css class from element
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var forEachArray = __nested_webpack_require_77144__(893);
var inArray = __nested_webpack_require_77144__(928);
var getClass = __nested_webpack_require_77144__(902);
var setClassName = __nested_webpack_require_77144__(24);

/**
 * Remove css class from element
 * @param {(HTMLElement|SVGElement)} element - target element
 * @param {...string} cssClass - css classes to remove
 * @memberof module:domUtil
 */
function removeClass(element) {
  var cssClass = Array.prototype.slice.call(arguments, 1);
  var classList = element.classList;
  var origin, newClass;

  if (classList) {
    forEachArray(cssClass, function(name) {
      classList.remove(name);
    });

    return;
  }

  origin = getClass(element).split(/\s+/);
  newClass = [];
  forEachArray(origin, function(name) {
    if (inArray(name, cssClass) < 0) {
      newClass.push(name);
    }
  });

  setClassName(element, newClass);
}

module.exports = removeClass;


/***/ }),

/***/ 969:
/***/ (function(module) {

"use strict";
/**
 * @fileoverview Extend the target object from other objects.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * @module object
 */

/**
 * Extend the target object from other objects.
 * @param {object} target - Object that will be extended
 * @param {...object} objects - Objects as sources
 * @returns {object} Extended object
 * @memberof module:object
 */
function extend(target, objects) { // eslint-disable-line no-unused-vars
  var hasOwnProp = Object.prototype.hasOwnProperty;
  var source, prop, i, len;

  for (i = 1, len = arguments.length; i < len; i += 1) {
    source = arguments[i];
    for (prop in source) {
      if (hasOwnProp.call(source, prop)) {
        target[prop] = source[prop];
      }
    }
  }

  return target;
}

module.exports = extend;


/***/ }),

/***/ 254:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_79108__) {

"use strict";
/**
 * @fileoverview Request image ping.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var forEachOwnProperties = __nested_webpack_require_79108__(956);

/**
 * @module request
 */

/**
 * Request image ping.
 * @param {String} url url for ping request
 * @param {Object} trackingInfo infos for make query string
 * @returns {HTMLElement}
 * @memberof module:request
 * @example
 * // ES6
 * import imagePing from 'tui-code-snippet/request/imagePing';
 * 
 * // CommonJS
 * const imagePing = require('tui-code-snippet/request/imagePing');
 *
 * imagePing('https://www.google-analytics.com/collect', {
 *   v: 1,
 *   t: 'event',
 *   tid: 'trackingid',
 *   cid: 'cid',
 *   dp: 'dp',
 *   dh: 'dh'
 * });
 */
function imagePing(url, trackingInfo) {
  var trackingElement = document.createElement('img');
  var queryString = '';
  forEachOwnProperties(trackingInfo, function(value, key) {
    queryString += '&' + key + '=' + value;
  });
  queryString = queryString.substring(1);

  trackingElement.src = url + '?' + queryString;

  trackingElement.style.display = 'none';
  document.body.appendChild(trackingElement);
  document.body.removeChild(trackingElement);

  return trackingElement;
}

module.exports = imagePing;


/***/ }),

/***/ 391:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_80450__) {

"use strict";
/**
 * @fileoverview Send hostname on DOMContentLoaded.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isUndefined = __nested_webpack_require_80450__(929);
var imagePing = __nested_webpack_require_80450__(254);

var ms7days = 7 * 24 * 60 * 60 * 1000;

/**
 * Check if the date has passed 7 days
 * @param {number} date - milliseconds
 * @returns {boolean}
 * @private
 */
function isExpired(date) {
  var now = new Date().getTime();

  return now - date > ms7days;
}

/**
 * Send hostname on DOMContentLoaded.
 * To prevent hostname set tui.usageStatistics to false.
 * @param {string} appName - application name
 * @param {string} trackingId - GA tracking ID
 * @ignore
 */
function sendHostname(appName, trackingId) {
  var url = 'https://www.google-analytics.com/collect';
  var hostname = location.hostname;
  var hitType = 'event';
  var eventCategory = 'use';
  var applicationKeyForStorage = 'TOAST UI ' + appName + ' for ' + hostname + ': Statistics';
  var date = window.localStorage.getItem(applicationKeyForStorage);

  // skip if the flag is defined and is set to false explicitly
  if (!isUndefined(window.tui) && window.tui.usageStatistics === false) {
    return;
  }

  // skip if not pass seven days old
  if (date && !isExpired(date)) {
    return;
  }

  window.localStorage.setItem(applicationKeyForStorage, new Date().getTime());

  setTimeout(function() {
    if (document.readyState === 'interactive' || document.readyState === 'complete') {
      imagePing(url, {
        v: 1,
        t: hitType,
        tid: trackingId,
        cid: hostname,
        dp: hostname,
        dh: appName,
        el: appName,
        ec: eventCategory
      });
    }
  }, 1000);
}

module.exports = sendHostname;


/***/ }),

/***/ 516:
/***/ (function(module) {

"use strict";
/**
 * @fileoverview Creates a debounced function that delays invoking fn until after delay milliseconds has elapsed since the last time the debouced function was invoked.
 * @author NHN FE Development Lab <dl_javascript.nhn.com>
 */



/**
 * @module tricks
 */

/**
 * Creates a debounced function that delays invoking fn until after delay milliseconds has elapsed
 * since the last time the debouced function was invoked.
 * @param {function} fn The function to debounce.
 * @param {number} [delay=0] The number of milliseconds to delay
 * @returns {function} debounced function.
 * @memberof module:tricks
 * @example
 * // ES6
 * import debounce from 'tui-code-snippet/tricks/debounce';
 * 
 * // CommonJS
 * const debounce = require('tui-code-snippet/tricks/debounce');
 *
 * function someMethodToInvokeDebounced() {}
 *
 * const debounced = debounce(someMethodToInvokeDebounced, 300);
 *
 * // invoke repeatedly
 * debounced();
 * debounced();
 * debounced();
 * debounced();
 * debounced();
 * debounced();    // last invoke of debounced()
 *
 * // invoke someMethodToInvokeDebounced() after 300 milliseconds.
 */
function debounce(fn, delay) {
  var timer, args;

  /* istanbul ignore next */
  delay = delay || 0;

  function debounced() { // eslint-disable-line require-jsdoc
    args = Array.prototype.slice.call(arguments);

    window.clearTimeout(timer);
    timer = window.setTimeout(function() {
      fn.apply(null, args);
    }, delay);
  }

  return debounced;
}

module.exports = debounce;


/***/ }),

/***/ 423:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_83856__) {

"use strict";
/**
 * @fileoverview Creates a throttled function that only invokes fn at most once per every interval milliseconds.
 * @author NHN FE Development Lab <dl_javascript.nhn.com>
 */



var debounce = __nested_webpack_require_83856__(516);

/**
 * Creates a throttled function that only invokes fn at most once per every interval milliseconds.
 * You can use this throttle short time repeatedly invoking functions. (e.g MouseMove, Resize ...)
 * if you need reuse throttled method. you must remove slugs (e.g. flag variable) related with throttling.
 * @param {function} fn function to throttle
 * @param {number} [interval=0] the number of milliseconds to throttle invocations to.
 * @returns {function} throttled function
 * @memberof module:tricks
 * @example
 * // ES6
 * import throttle from 'tui-code-snippet/tricks/throttle';
 * 
 * // CommonJS
 * const throttle = require('tui-code-snippet/tricks/throttle');
 *
 * function someMethodToInvokeThrottled() {}
 *
 * const throttled = throttle(someMethodToInvokeThrottled, 300);
 *
 * // invoke repeatedly
 * throttled();    // invoke (leading)
 * throttled();
 * throttled();    // invoke (near 300 milliseconds)
 * throttled();
 * throttled();
 * throttled();    // invoke (near 600 milliseconds)
 * // ...
 * // invoke (trailing)
 *
 * // if you need reuse throttled method. then invoke reset()
 * throttled.reset();
 */
function throttle(fn, interval) {
  var base;
  var isLeading = true;
  var tick = function(_args) {
    fn.apply(null, _args);
    base = null;
  };
  var debounced, stamp, args;

  /* istanbul ignore next */
  interval = interval || 0;

  debounced = debounce(tick, interval);

  function throttled() { // eslint-disable-line require-jsdoc
    args = Array.prototype.slice.call(arguments);

    if (isLeading) {
      tick(args);
      isLeading = false;

      return;
    }

    stamp = Number(new Date());

    base = base || stamp;

    // pass array directly because `debounce()`, `tick()` are already use
    // `apply()` method to invoke developer's `fn` handler.
    //
    // also, this `debounced` line invoked every time for implements
    // `trailing` features.
    debounced(args);

    if ((stamp - base) >= interval) {
      tick(args);
    }
  }

  function reset() { // eslint-disable-line require-jsdoc
    isLeading = true;
    base = null;
  }

  throttled.reset = reset;

  return throttled;
}

module.exports = throttle;


/***/ }),

/***/ 322:
/***/ (function(module) {

"use strict";
/**
 * @fileoverview Check whether the given variable is an instance of Array or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check whether the given variable is an instance of Array or not.
 * If the given variable is an instance of Array, return true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is array instance?
 * @memberof module:type
 */
function isArray(obj) {
  return obj instanceof Array;
}

module.exports = isArray;


/***/ }),

/***/ 326:
/***/ (function(module) {

"use strict";
/**
 * @fileoverview Check whether the given variable is a string or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check whether the given variable is a boolean or not.
 *  If the given variable is a boolean, return true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is boolean?
 * @memberof module:type
 */
function isBoolean(obj) {
  return typeof obj === 'boolean' || obj instanceof Boolean;
}

module.exports = isBoolean;


/***/ }),

/***/ 65:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_87458__) {

"use strict";
/**
 * @fileoverview Check whether the given variable is existing or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isUndefined = __nested_webpack_require_87458__(929);
var isNull = __nested_webpack_require_87458__(934);

/**
 * Check whether the given variable is existing or not.
 * If the given variable is not null and not undefined, returns true.
 * @param {*} param - Target for checking
 * @returns {boolean} Is existy?
 * @memberof module:type
 * @example
 * // ES6
 * import isExisty from 'tui-code-snippet/type/isExisty');
 * 
 * // CommonJS
 * const isExisty = require('tui-code-snippet/type/isExisty');
 *
 * isExisty(''); //true
 * isExisty(0); //true
 * isExisty([]); //true
 * isExisty({}); //true
 * isExisty(null); //false
 * isExisty(undefined); //false
*/
function isExisty(param) {
  return !isUndefined(param) && !isNull(param);
}

module.exports = isExisty;


/***/ }),

/***/ 404:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_88451__) {

"use strict";
/**
 * @fileoverview Check whether the given variable is falsy or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isTruthy = __nested_webpack_require_88451__(790);

/**
 * Check whether the given variable is falsy or not.
 * If the given variable is null or undefined or false, returns true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is falsy?
 * @memberof module:type
 */
function isFalsy(obj) {
  return !isTruthy(obj);
}

module.exports = isFalsy;


/***/ }),

/***/ 294:
/***/ (function(module) {

"use strict";
/**
 * @fileoverview Check whether the given variable is a function or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check whether the given variable is a function or not.
 * If the given variable is a function, return true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is function?
 * @memberof module:type
 */
function isFunction(obj) {
  return obj instanceof Function;
}

module.exports = isFunction;


/***/ }),

/***/ 934:
/***/ (function(module) {

"use strict";
/**
 * @fileoverview Check whether the given variable is null or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check whether the given variable is null or not.
 * If the given variable(arguments[0]) is null, returns true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is null?
 * @memberof module:type
 */
function isNull(obj) {
  return obj === null;
}

module.exports = isNull;


/***/ }),

/***/ 321:
/***/ (function(module) {

"use strict";
/**
 * @fileoverview Check whether the given variable is a number or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check whether the given variable is a number or not.
 * If the given variable is a number, return true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is number?
 * @memberof module:type
 */
function isNumber(obj) {
  return typeof obj === 'number' || obj instanceof Number;
}

module.exports = isNumber;


/***/ }),

/***/ 73:
/***/ (function(module) {

"use strict";
/**
 * @fileoverview Check whether the given variable is an object or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check whether the given variable is an object or not.
 * If the given variable is an object, return true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is object?
 * @memberof module:type
 */
function isObject(obj) {
  return obj === Object(obj);
}

module.exports = isObject;


/***/ }),

/***/ 758:
/***/ (function(module) {

"use strict";
/**
 * @fileoverview Check whether the given variable is a string or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check whether the given variable is a string or not.
 * If the given variable is a string, return true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is string?
 * @memberof module:type
 */
function isString(obj) {
  return typeof obj === 'string' || obj instanceof String;
}

module.exports = isString;


/***/ }),

/***/ 790:
/***/ (function(module, __unused_webpack_exports, __nested_webpack_require_91623__) {

"use strict";
/**
 * @fileoverview Check whether the given variable is truthy or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isExisty = __nested_webpack_require_91623__(65);

/**
 * Check whether the given variable is truthy or not.
 * If the given variable is not null or not undefined or not false, returns true.
 * (It regards 0 as true)
 * @param {*} obj - Target for checking
 * @returns {boolean} Is truthy?
 * @memberof module:type
 */
function isTruthy(obj) {
  return isExisty(obj) && obj !== false;
}

module.exports = isTruthy;


/***/ }),

/***/ 929:
/***/ (function(module) {

"use strict";
/**
 * @fileoverview Check whether the given variable is undefined or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check whether the given variable is undefined or not.
 * If the given variable is undefined, returns true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is undefined?
 * @memberof module:type
 */
function isUndefined(obj) {
  return obj === undefined; // eslint-disable-line no-undefined
}

module.exports = isUndefined;


/***/ }),

/***/ 695:
/***/ (function(module) {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__695__;

/***/ }),

/***/ 412:
/***/ (function(module) {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__412__;

/***/ }),

/***/ 479:
/***/ (function(module) {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__479__;

/***/ }),

/***/ 481:
/***/ (function(module) {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__481__;

/***/ }),

/***/ 43:
/***/ (function(module) {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__43__;

/***/ }),

/***/ 814:
/***/ (function(module) {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__814__;

/***/ }),

/***/ 785:
/***/ (function(module) {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__785__;

/***/ }),

/***/ 311:
/***/ (function(module) {

"use strict";
module.exports = __WEBPACK_EXTERNAL_MODULE__311__;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __nested_webpack_require_93901__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_93901__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__nested_webpack_require_93901__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__nested_webpack_require_93901__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__nested_webpack_require_93901__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__nested_webpack_require_93901__.o(definition, key) && !__nested_webpack_require_93901__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__nested_webpack_require_93901__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__nested_webpack_require_93901__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/************************************************************************/
var __nested_webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";

// EXPORTS
__nested_webpack_require_93901__.d(__nested_webpack_exports__, {
  "default": function() { return /* binding */ src; }
});

// UNUSED EXPORTS: Editor, EditorCore

;// CONCATENATED MODULE: ../../node_modules/tslib/tslib.es6.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

// EXTERNAL MODULE: external {"commonjs":"prosemirror-model","commonjs2":"prosemirror-model","amd":"prosemirror-model"}
var external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_ = __nested_webpack_require_93901__(43);
// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/collection/forEachOwnProperties.js
var forEachOwnProperties = __nested_webpack_require_93901__(956);
var forEachOwnProperties_default = /*#__PURE__*/__nested_webpack_require_93901__.n(forEachOwnProperties);
// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/object/extend.js
var extend = __nested_webpack_require_93901__(969);
var extend_default = /*#__PURE__*/__nested_webpack_require_93901__.n(extend);
// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/css.js
var css = __nested_webpack_require_93901__(522);
var css_default = /*#__PURE__*/__nested_webpack_require_93901__.n(css);
// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/addClass.js
var addClass = __nested_webpack_require_93901__(204);
var addClass_default = /*#__PURE__*/__nested_webpack_require_93901__.n(addClass);
// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/removeClass.js
var removeClass = __nested_webpack_require_93901__(462);
var removeClass_default = /*#__PURE__*/__nested_webpack_require_93901__.n(removeClass);
// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isString.js
var type_isString = __nested_webpack_require_93901__(758);
var isString_default = /*#__PURE__*/__nested_webpack_require_93901__.n(type_isString);
// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isNumber.js
var isNumber = __nested_webpack_require_93901__(321);
var isNumber_default = /*#__PURE__*/__nested_webpack_require_93901__.n(isNumber);
// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isUndefined.js
var isUndefined = __nested_webpack_require_93901__(929);
var isUndefined_default = /*#__PURE__*/__nested_webpack_require_93901__.n(isUndefined);
// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isNull.js
var isNull = __nested_webpack_require_93901__(934);
var isNull_default = /*#__PURE__*/__nested_webpack_require_93901__.n(isNull);
// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/request/sendHostname.js
var sendHostname = __nested_webpack_require_93901__(391);
var sendHostname_default = /*#__PURE__*/__nested_webpack_require_93901__.n(sendHostname);
;// CONCATENATED MODULE: ./src/utils/common.ts





var isMac = /Mac/.test(navigator.platform);
var reSpaceMoreThanOne = /[\u0020]+/g;
var reEscapeChars = /[>(){}[\]+-.!#|]/g;
var reEscapeHTML = /<([a-zA-Z_][a-zA-Z0-9\-._]*)(\s|[^\\>])*\/?>|<(\/)([a-zA-Z_][a-zA-Z0-9\-._]*)\s*\/?>|<!--[^-]+-->|<([a-zA-Z_][a-zA-Z0-9\-.:/]*)>/g;
var reEscapeBackSlash = /\\[!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~\\]/g;
var reEscapePairedChars = /[*_~`]/g;
var reMdImageSyntax = /!\[.*\]\(.*\)/g;
var reEscapedCharInLinkSyntax = /[[\]]/g;
var reEscapeBackSlashInSentence = /(?:^|[^\\])\\(?!\\)/g;
var XMLSPECIAL = '[&<>"]';
var reXmlSpecial = new RegExp(XMLSPECIAL, 'g');
function replaceUnsafeChar(char) {
    switch (char) {
        case '&':
            return '&amp;';
        case '<':
            return '&lt;';
        case '>':
            return '&gt;';
        case '"':
            return '&quot;';
        default:
            return char;
    }
}
function escapeXml(text) {
    if (reXmlSpecial.test(text)) {
        return text.replace(reXmlSpecial, replaceUnsafeChar);
    }
    return text;
}
function sendHostName() {
    sendHostname_default()('editor', 'UA-129966929-1');
}
function common_includes(arr, targetItem) {
    return arr.indexOf(targetItem) !== -1;
}
var availableLinkAttributes = ['rel', 'target', 'hreflang', 'type'];
var reMarkdownTextToEscapeMap = {
    codeblock: /(^ {4}[^\n]+\n*)+/,
    thematicBreak: /^ *((\* *){3,}|(- *){3,} *|(_ *){3,}) */,
    atxHeading: /^(#{1,6}) +[\s\S]+/,
    seTextheading: /^([^\n]+)\n *(=|-){2,} */,
    blockquote: /^( *>[^\n]+.*)+/,
    list: /^ *(\*+|-+|\d+\.) [\s\S]+/,
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? */,
    link: /!?\[.*\]\(.*\)/,
    reflink: /!?\[.*\]\s*\[([^\]]*)\]/,
    verticalBar: /\u007C/,
    fencedCodeblock: /^((`|~){3,})/,
};
function sanitizeLinkAttribute(attribute) {
    if (!attribute) {
        return null;
    }
    var linkAttributes = {};
    availableLinkAttributes.forEach(function (key) {
        if (!isUndefined_default()(attribute[key])) {
            linkAttributes[key] = attribute[key];
        }
    });
    return linkAttributes;
}
function repeat(text, count) {
    var result = '';
    for (var i = 0; i < count; i += 1) {
        result += text;
    }
    return result;
}
function isNeedEscapeText(text) {
    var needEscape = false;
    forEachOwnProperties_default()(reMarkdownTextToEscapeMap, function (reMarkdownTextToEscape) {
        if (reMarkdownTextToEscape.test(text)) {
            needEscape = true;
        }
        return !needEscape;
    });
    return needEscape;
}
function escapeTextForLink(text) {
    var imageSyntaxRanges = [];
    var result = reMdImageSyntax.exec(text);
    while (result) {
        imageSyntaxRanges.push([result.index, result.index + result[0].length]);
        result = reMdImageSyntax.exec(text);
    }
    return text.replace(reEscapedCharInLinkSyntax, function (matched, offset) {
        var isDelimiter = imageSyntaxRanges.some(function (range) { return offset > range[0] && offset < range[1]; });
        return isDelimiter ? matched : "\\" + matched;
    });
}
function common_escape(text) {
    var aheadReplacer = function (matched) { return "\\" + matched; };
    var behindReplacer = function (matched) { return matched + "\\"; };
    var escapedText = text.replace(reSpaceMoreThanOne, ' ');
    if (reEscapeBackSlash.test(escapedText)) {
        escapedText = escapedText.replace(reEscapeBackSlash, aheadReplacer);
    }
    if (reEscapeBackSlashInSentence.test(escapedText)) {
        escapedText = escapedText.replace(reEscapeBackSlashInSentence, behindReplacer);
    }
    escapedText = escapedText.replace(reEscapePairedChars, aheadReplacer);
    if (reEscapeHTML.test(escapedText)) {
        escapedText = escapedText.replace(reEscapeHTML, aheadReplacer);
    }
    if (isNeedEscapeText(escapedText)) {
        escapedText = escapedText.replace(reEscapeChars, aheadReplacer);
    }
    return escapedText;
}
function quote(text) {
    var result;
    if (text.indexOf('"') === -1) {
        result = '""';
    }
    else {
        result = text.indexOf("'") === -1 ? "''" : '()';
    }
    return result[0] + text + result[1];
}
function isNil(value) {
    return isNull_default()(value) || isUndefined_default()(value);
}
function shallowEqual(o1, o2) {
    if (o1 === null && o1 === o2) {
        return true;
    }
    if (typeof o1 !== 'object' || typeof o2 !== 'object' || isNil(o1) || isNil(o2)) {
        return o1 === o2;
    }
    for (var key in o1) {
        if (o1[key] !== o2[key]) {
            return false;
        }
    }
    for (var key in o2) {
        if (!(key in o1)) {
            return false;
        }
    }
    return true;
}
function last(arr) {
    return arr[arr.length - 1];
}
function between(value, min, max) {
    return value >= min && value <= max;
}
function isObject(obj) {
    return typeof obj === 'object' && obj !== null;
}
function deepMergedCopy(targetObj, obj) {
    var resultObj = __assign({}, targetObj);
    if (targetObj && obj) {
        Object.keys(obj).forEach(function (prop) {
            if (isObject(resultObj[prop])) {
                if (Array.isArray(obj[prop])) {
                    resultObj[prop] = deepCopyArray(obj[prop]);
                }
                else if (resultObj.hasOwnProperty(prop)) {
                    resultObj[prop] = deepMergedCopy(resultObj[prop], obj[prop]);
                }
                else {
                    resultObj[prop] = deepCopy(obj[prop]);
                }
            }
            else {
                resultObj[prop] = obj[prop];
            }
        });
    }
    return resultObj;
}
function deepCopyArray(items) {
    return items.map(function (item) {
        if (isObject(item)) {
            return Array.isArray(item) ? deepCopyArray(item) : deepCopy(item);
        }
        return item;
    });
}
function deepCopy(obj) {
    var keys = Object.keys(obj);
    if (!keys.length) {
        return obj;
    }
    return keys.reduce(function (acc, prop) {
        if (isObject(obj[prop])) {
            acc[prop] = Array.isArray(obj[prop]) ? deepCopyArray(obj[prop]) : deepCopy(obj[prop]);
        }
        else {
            acc[prop] = obj[prop];
        }
        return acc;
    }, {});
}
function common_assign(targetObj, obj) {
    if (obj === void 0) { obj = {}; }
    Object.keys(obj).forEach(function (prop) {
        if (targetObj.hasOwnProperty(prop) && typeof targetObj[prop] === 'object') {
            if (Array.isArray(obj[prop])) {
                targetObj[prop] = obj[prop];
            }
            else {
                common_assign(targetObj[prop], obj[prop]);
            }
        }
        else {
            targetObj[prop] = obj[prop];
        }
    });
    return targetObj;
}
function getSortedNumPair(valueA, valueB) {
    return valueA > valueB ? [valueB, valueA] : [valueA, valueB];
}

// EXTERNAL MODULE: external {"commonjs":"prosemirror-view","commonjs2":"prosemirror-view","amd":"prosemirror-view"}
var external_commonjs_prosemirror_view_commonjs2_prosemirror_view_amd_prosemirror_view_ = __nested_webpack_require_93901__(311);
// EXTERNAL MODULE: external {"commonjs":"prosemirror-transform","commonjs2":"prosemirror-transform","amd":"prosemirror-transform"}
var external_commonjs_prosemirror_transform_commonjs2_prosemirror_transform_amd_prosemirror_transform_ = __nested_webpack_require_93901__(785);
// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/collection/toArray.js
var collection_toArray = __nested_webpack_require_93901__(990);
var toArray_default = /*#__PURE__*/__nested_webpack_require_93901__.n(collection_toArray);
// EXTERNAL MODULE: external {"commonjs":"prosemirror-state","commonjs2":"prosemirror-state","amd":"prosemirror-state"}
var external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_ = __nested_webpack_require_93901__(814);
// EXTERNAL MODULE: external {"commonjs":"prosemirror-keymap","commonjs2":"prosemirror-keymap","amd":"prosemirror-keymap"}
var external_commonjs_prosemirror_keymap_commonjs2_prosemirror_keymap_amd_prosemirror_keymap_ = __nested_webpack_require_93901__(481);
// EXTERNAL MODULE: external {"commonjs":"prosemirror-commands","commonjs2":"prosemirror-commands","amd":"prosemirror-commands"}
var external_commonjs_prosemirror_commands_commonjs2_prosemirror_commands_amd_prosemirror_commands_ = __nested_webpack_require_93901__(695);
// EXTERNAL MODULE: external {"commonjs":"prosemirror-inputrules","commonjs2":"prosemirror-inputrules","amd":"prosemirror-inputrules"}
var external_commonjs_prosemirror_inputrules_commonjs2_prosemirror_inputrules_amd_prosemirror_inputrules_ = __nested_webpack_require_93901__(479);
// EXTERNAL MODULE: external {"commonjs":"prosemirror-history","commonjs2":"prosemirror-history","amd":"prosemirror-history"}
var external_commonjs_prosemirror_history_commonjs2_prosemirror_history_amd_prosemirror_history_ = __nested_webpack_require_93901__(412);
;// CONCATENATED MODULE: ./src/helper/manipulation.ts



function createParagraph(schema, content) {
    var paragraph = schema.nodes.paragraph;
    if (!content) {
        return paragraph.createAndFill();
    }
    return paragraph.create(null, isString_default()(content) ? schema.text(content) : content);
}
function createTextNode(schema, text, marks) {
    return schema.text(text, marks);
}
function createTextSelection(tr, from, to) {
    if (to === void 0) { to = from; }
    var contentSize = tr.doc.content.size;
    var size = contentSize > 0 ? contentSize - 1 : 1;
    return external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.TextSelection.create(tr.doc, Math.min(from, size), Math.min(to, size));
}
function addParagraph(tr, _a, schema) {
    var pos = _a.pos;
    tr.replaceWith(pos, pos, createParagraph(schema));
    return tr.setSelection(createTextSelection(tr, pos + 1));
}
function replaceTextNode(_a) {
    var state = _a.state, from = _a.from, startIndex = _a.startIndex, endIndex = _a.endIndex, createText = _a.createText;
    var tr = state.tr, doc = state.doc, schema = state.schema;
    for (var i = startIndex; i <= endIndex; i += 1) {
        var _b = doc.child(i), nodeSize = _b.nodeSize, textContent = _b.textContent, content = _b.content;
        var text = createText(textContent);
        var node = text ? createTextNode(schema, text) : external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.empty;
        var mappedFrom = tr.mapping.map(from);
        var mappedTo = mappedFrom + content.size;
        tr.replaceWith(mappedFrom, mappedTo, node);
        from += nodeSize;
    }
    return tr;
}
function splitAndExtendBlock(tr, pos, text, node) {
    var textLen = text.length;
    tr.split(pos)
        .delete(pos - textLen, pos)
        .insert(tr.mapping.map(pos), node)
        .setSelection(createTextSelection(tr, tr.mapping.map(pos) - textLen));
}

;// CONCATENATED MODULE: ./src/utils/markdown.ts

function hasSpecificTypeAncestor(mdNode) {
    var types = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        types[_i - 1] = arguments[_i];
    }
    while (mdNode && mdNode.parent && mdNode.parent.type !== 'document') {
        if (includes(types, mdNode.parent.type)) {
            return true;
        }
        mdNode = mdNode.parent;
    }
    return false;
}
function getMdStartLine(mdNode) {
    return mdNode.sourcepos[0][0];
}
function getMdEndLine(mdNode) {
    return mdNode.sourcepos[1][0];
}
function getMdStartCh(mdNode) {
    return mdNode.sourcepos[0][1];
}
function getMdEndCh(mdNode) {
    return mdNode.sourcepos[1][1];
}
function isMultiLineNode(mdNode) {
    var type = mdNode.type;
    return type === 'codeBlock' || type === 'paragraph';
}
function isHTMLNode(mdNode) {
    var type = mdNode.type;
    return type === 'htmlBlock' || type === 'htmlInline';
}
function isStyledInlineNode(mdNode) {
    var type = mdNode.type;
    return (type === 'strike' ||
        type === 'strong' ||
        type === 'emph' ||
        type === 'code' ||
        type === 'link' ||
        type === 'image');
}
function isCodeBlockNode(mdNode) {
    return mdNode && mdNode.type === 'codeBlock';
}
function isCustomBlockNode(mdNode) {
    return mdNode && mdNode.type === 'customBlock';
}
function isListNode(mdNode) {
    return mdNode && (mdNode.type === 'item' || mdNode.type === 'list');
}
function isOrderedListNode(mdNode) {
    return isListNode(mdNode) && mdNode.listData.type === 'ordered';
}
function isBulletListNode(mdNode) {
    return isListNode(mdNode) && mdNode.listData.type !== 'ordered';
}
function isTableCellNode(mdNode) {
    return mdNode && (mdNode.type === 'tableCell' || mdNode.type === 'tableDelimCell');
}
function isInlineNode(mdNode) {
    switch (mdNode.type) {
        case 'code':
        case 'text':
        case 'emph':
        case 'strong':
        case 'strike':
        case 'link':
        case 'image':
        case 'htmlInline':
        case 'linebreak':
        case 'softbreak':
        case 'customInline':
            return true;
        default:
            return false;
    }
}
function findClosestNode(mdNode, condition, includeSelf) {
    if (includeSelf === void 0) { includeSelf = true; }
    mdNode = includeSelf ? mdNode : mdNode.parent;
    while (mdNode && mdNode.type !== 'document') {
        if (condition(mdNode)) {
            return mdNode;
        }
        mdNode = mdNode.parent;
    }
    return null;
}
function traverseParentNodes(mdNode, iteratee, includeSelf) {
    if (includeSelf === void 0) { includeSelf = true; }
    mdNode = includeSelf ? mdNode : mdNode.parent;
    while (mdNode && mdNode.type !== 'document') {
        iteratee(mdNode);
        mdNode = mdNode.parent;
    }
}
function addOffsetPos(originPos, offset) {
    return [originPos[0], originPos[1] + offset];
}
function setOffsetPos(originPos, newOffset) {
    return [originPos[0], newOffset];
}
function getInlineMarkdownText(mdNode) {
    var text = mdNode.firstChild.literal;
    switch (mdNode.type) {
        case 'emph':
            return "*" + text + "*";
        case 'strong':
            return "**" + text + "**";
        case 'strike':
            return "~~" + text + "~~";
        case 'code':
            return "`" + text + "`";
        case 'link':
        case 'image':
            /* eslint-disable no-case-declarations */
            var _a = mdNode, destination = _a.destination, title = _a.title;
            var delim = mdNode.type === 'link' ? '' : '!';
            return delim + "[" + text + "](" + destination + (title ? " \"" + title + "\"" : '') + ")";
        default:
            return null;
    }
}
function isContainer(node) {
    switch (node.type) {
        case 'document':
        case 'blockQuote':
        case 'list':
        case 'item':
        case 'paragraph':
        case 'heading':
        case 'emph':
        case 'strong':
        case 'strike':
        case 'link':
        case 'image':
        case 'table':
        case 'tableHead':
        case 'tableBody':
        case 'tableRow':
        case 'tableCell':
        case 'tableDelimRow':
        case 'customInline':
            return true;
        default:
            return false;
    }
}
function getChildrenText(node) {
    var buffer = [];
    var walker = node.walker();
    var event = null;
    while ((event = walker.next())) {
        var childNode = event.node;
        if (childNode.type === 'text') {
            buffer.push(childNode.literal);
        }
    }
    return buffer.join('');
}

;// CONCATENATED MODULE: ./src/widget/rules.ts

var widgetRules = [];
var widgetRuleMap = {};
var reWidgetPrefix = /\$\$widget\d+\s/;
function unwrapWidgetSyntax(text) {
    var index = text.search(reWidgetPrefix);
    if (index !== -1) {
        var rest = text.substring(index);
        var replaced = rest.replace(reWidgetPrefix, '').replace('$$', '');
        text = text.substring(0, index);
        text += unwrapWidgetSyntax(replaced);
    }
    return text;
}
function createWidgetContent(info, text) {
    return "$$" + info + " " + text + "$$";
}
function widgetToDOM(info, text) {
    var _a = widgetRuleMap[info], rule = _a.rule, toDOM = _a.toDOM;
    var matches = unwrapWidgetSyntax(text).match(rule);
    if (matches) {
        text = matches[0];
    }
    return toDOM(text);
}
function getWidgetRules() {
    return widgetRules;
}
function setWidgetRules(rules) {
    widgetRules = rules;
    widgetRules.forEach(function (rule, index) {
        widgetRuleMap["widget" + index] = rule;
    });
}
function mergeNodes(nodes, text, schema, ruleIndex) {
    return nodes.concat(createNodesWithWidget(text, schema, ruleIndex));
}
/**
 * create nodes with plain text and replace text matched to the widget rules with the widget node
 * For example, in case the text and widget rules as below
 *
 * text: $test plain text #test
 * widget rules: [{ rule: /$.+/ }, { rule: /#.+/ }]
 *
 * The creating node process is recursive and is as follows.
 *
 * in first widget rule(/$.+/)
 *  $test -> widget node
 *  plain text -> match with next widget rule
 *  #test -> match with next widget rule
 *
 * in second widget rule(/#.+/)
 *  plain text -> text node(no rule for matching)
 *  #test -> widget node
 */
function createNodesWithWidget(text, schema, ruleIndex) {
    if (ruleIndex === void 0) { ruleIndex = 0; }
    var nodes = [];
    var rule = (widgetRules[ruleIndex] || {}).rule;
    var nextRuleIndex = ruleIndex + 1;
    text = unwrapWidgetSyntax(text);
    if (rule && rule.test(text)) {
        var index = void 0;
        while ((index = text.search(rule)) !== -1) {
            var prev = text.substring(0, index);
            // get widget node on first splitted text using next widget rule
            if (prev) {
                nodes = mergeNodes(nodes, prev, schema, nextRuleIndex);
            }
            // build widget node using current widget rule
            text = text.substring(index);
            var literal = text.match(rule)[0];
            var info = "widget" + ruleIndex;
            nodes.push(schema.nodes.widget.create({ info: info }, schema.text(createWidgetContent(info, literal))));
            text = text.substring(literal.length);
        }
        // get widget node on last splitted text using next widget rule
        if (text) {
            nodes = mergeNodes(nodes, text, schema, nextRuleIndex);
        }
    }
    else if (text) {
        nodes =
            ruleIndex < widgetRules.length - 1
                ? mergeNodes(nodes, text, schema, nextRuleIndex)
                : [schema.text(text)];
    }
    return nodes;
}
function getWidgetContent(widgetNode) {
    var event;
    var text = '';
    var walker = widgetNode.walker();
    while ((event = walker.next())) {
        var node = event.node, entering = event.entering;
        if (entering) {
            if (node !== widgetNode && node.type !== 'text') {
                text += getInlineMarkdownText(node);
                // skip the children
                walker.resumeAt(widgetNode, false);
                walker.next();
            }
            else if (node.type === 'text') {
                text += node.literal;
            }
        }
    }
    return text;
}

;// CONCATENATED MODULE: ./src/commands/defaultCommands.ts


function getDefaultCommands() {
    return {
        deleteSelection: function () { return external_commonjs_prosemirror_commands_commonjs2_prosemirror_commands_amd_prosemirror_commands_.deleteSelection; },
        selectAll: function () { return external_commonjs_prosemirror_commands_commonjs2_prosemirror_commands_amd_prosemirror_commands_.selectAll; },
        undo: function () { return external_commonjs_prosemirror_history_commonjs2_prosemirror_history_amd_prosemirror_history_.undo; },
        redo: function () { return external_commonjs_prosemirror_history_commonjs2_prosemirror_history_amd_prosemirror_history_.redo; },
    };
}

;// CONCATENATED MODULE: ./src/plugins/placeholder.ts



function placeholder(options) {
    return new external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Plugin({
        props: {
            decorations: function (state) {
                var doc = state.doc;
                if (options.text &&
                    doc.childCount === 1 &&
                    doc.firstChild.isTextblock &&
                    doc.firstChild.content.size === 0) {
                    var placeHolder = document.createElement('span');
                    addClass_default()(placeHolder, 'placeholder');
                    if (options.className) {
                        addClass_default()(placeHolder, options.className);
                    }
                    placeHolder.textContent = options.text;
                    return external_commonjs_prosemirror_view_commonjs2_prosemirror_view_amd_prosemirror_view_.DecorationSet.create(doc, [external_commonjs_prosemirror_view_commonjs2_prosemirror_view_amd_prosemirror_view_.Decoration.widget(1, placeHolder)]);
                }
                return null;
            },
        },
    });
}

// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isArray.js
var isArray = __nested_webpack_require_93901__(322);
var isArray_default = /*#__PURE__*/__nested_webpack_require_93901__.n(isArray);
// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/hasClass.js
var hasClass = __nested_webpack_require_93901__(714);
var hasClass_default = /*#__PURE__*/__nested_webpack_require_93901__.n(hasClass);
// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domUtil/matches.js
var matches = __nested_webpack_require_93901__(471);
var matches_default = /*#__PURE__*/__nested_webpack_require_93901__.n(matches);
;// CONCATENATED MODULE: ./src/utils/constants.ts
var TAG_NAME = '[A-Za-z][A-Za-z0-9-]*';
var ATTRIBUTE_NAME = '[a-zA-Z_:][a-zA-Z0-9:._-]*';
var UNQUOTED_VALUE = '[^"\'=<>`\\x00-\\x20]+';
var SINGLE_QUOTED_VALUE = "'[^']*'";
var DOUBLE_QUOTED_VALUE = '"[^"]*"';
var ATTRIBUTE_VALUE = "(?:" + UNQUOTED_VALUE + "|" + SINGLE_QUOTED_VALUE + "|" + DOUBLE_QUOTED_VALUE + ")";
var ATTRIBUTE_VALUE_SPEC = "" + '(?:\\s*=\\s*' + ATTRIBUTE_VALUE + ")";
var ATTRIBUTE = "" + '(?:\\s+' + ATTRIBUTE_NAME + ATTRIBUTE_VALUE_SPEC + "?)";
var OPEN_TAG = "<(" + TAG_NAME + ")(" + ATTRIBUTE + ")*\\s*/?>";
var CLOSE_TAG = "</(" + TAG_NAME + ")\\s*[>]";
var HTML_TAG = "(?:" + OPEN_TAG + "|" + CLOSE_TAG + ")";
var reHTMLTag = new RegExp("^" + HTML_TAG, 'i');
var reBR = /<br\s*\/*>/i;
var reHTMLComment = /<! ---->|<!--(?:-?[^>-])(?:-?[^-])*-->/;
var ALTERNATIVE_TAG_FOR_BR = '</p><p>';

;// CONCATENATED MODULE: ./src/utils/dom.ts










function isPositionInBox(style, offsetX, offsetY) {
    var left = parseInt(style.left, 10);
    var top = parseInt(style.top, 10);
    var width = parseInt(style.width, 10) + parseInt(style.paddingLeft, 10) + parseInt(style.paddingRight, 10);
    var height = parseInt(style.height, 10) + parseInt(style.paddingTop, 10) + parseInt(style.paddingBottom, 10);
    return offsetX >= left && offsetX <= left + width && offsetY >= top && offsetY <= top + height;
}
var CLS_PREFIX = 'toastui-editor-';
function cls() {
    var names = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        names[_i] = arguments[_i];
    }
    var result = [];
    for (var _a = 0, names_1 = names; _a < names_1.length; _a++) {
        var name = names_1[_a];
        var className = void 0;
        if (Array.isArray(name)) {
            className = name[0] ? name[1] : null;
        }
        else {
            className = name;
        }
        if (className) {
            result.push("" + CLS_PREFIX + className);
        }
    }
    return result.join(' ');
}
function clsWithMdPrefix() {
    var names = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        names[_i] = arguments[_i];
    }
    return names.map(function (className) { return CLS_PREFIX + "md-" + className; }).join(' ');
}
function isTextNode(node) {
    return (node === null || node === void 0 ? void 0 : node.nodeType) === Node.TEXT_NODE;
}
function isElemNode(node) {
    return node && node.nodeType === Node.ELEMENT_NODE;
}
function findNodes(element, selector) {
    var nodeList = toArray_default()(element.querySelectorAll(selector));
    if (nodeList.length) {
        return nodeList;
    }
    return [];
}
function appendNodes(node, nodesToAppend) {
    nodesToAppend = isArray_default()(nodesToAppend) ? toArray_default()(nodesToAppend) : [nodesToAppend];
    nodesToAppend.forEach(function (nodeToAppend) {
        node.appendChild(nodeToAppend);
    });
}
function insertBeforeNode(insertedNode, node) {
    if (node.parentNode) {
        node.parentNode.insertBefore(insertedNode, node);
    }
}
function removeNode(node) {
    if (node.parentNode) {
        node.parentNode.removeChild(node);
    }
}
function unwrapNode(node) {
    var result = [];
    while (node.firstChild) {
        result.push(node.firstChild);
        if (node.parentNode) {
            node.parentNode.insertBefore(node.firstChild, node);
        }
    }
    removeNode(node);
    return result;
}
function toggleClass(element, className, state) {
    if (isUndefined_default()(state)) {
        state = !hasClass_default()(element, className);
    }
    var toggleFn = state ? (addClass_default()) : (removeClass_default());
    toggleFn(element, className);
}
function createElementWith(contents, target) {
    var container = document.createElement('div');
    if (isString_default()(contents)) {
        container.innerHTML = contents;
    }
    else {
        container.appendChild(contents);
    }
    var firstChild = container.firstChild;
    if (target) {
        target.appendChild(firstChild);
    }
    return firstChild;
}
function getOuterWidth(el) {
    var computed = window.getComputedStyle(el);
    return (['margin-left', 'margin-right'].reduce(function (acc, type) { return acc + parseInt(computed.getPropertyValue(type), 10); }, 0) + el.offsetWidth);
}
function closest(node, found) {
    var condition;
    if (isString_default()(found)) {
        condition = function (target) { return matches_default()(target, found); };
    }
    else {
        condition = function (target) { return target === found; };
    }
    while (node && node !== document) {
        if (isElemNode(node) && condition(node)) {
            return node;
        }
        node = node.parentNode;
    }
    return null;
}
function getTotalOffset(el, root) {
    var offsetTop = 0;
    var offsetLeft = 0;
    while (el && el !== root) {
        var top = el.offsetTop, left = el.offsetLeft, offsetParent = el.offsetParent;
        offsetTop += top;
        offsetLeft += left;
        if (offsetParent === root.offsetParent) {
            break;
        }
        el = el.offsetParent;
    }
    return { offsetTop: offsetTop, offsetLeft: offsetLeft };
}
function finalizeHtml(html, needHtmlText) {
    var result;
    if (needHtmlText) {
        result = html.innerHTML;
    }
    else {
        var frag = document.createDocumentFragment();
        var childNodes = toArray(html.childNodes);
        var length = childNodes.length;
        for (var i = 0; i < length; i += 1) {
            frag.appendChild(childNodes[i]);
        }
        result = frag;
    }
    return result;
}
function empty(node) {
    while (node.firstChild) {
        node.removeChild(node.firstChild);
    }
}
function appendNode(node, appended) {
    if (isString(appended)) {
        node.insertAdjacentHTML('beforeend', appended);
    }
    else {
        var nodes = appended.length
            ? toArray(appended)
            : [appended];
        for (var i = 0, len = nodes.length; i < len; i += 1) {
            node.appendChild(nodes[i]);
        }
    }
}
function prependNode(node, appended) {
    if (isString(appended)) {
        node.insertAdjacentHTML('afterbegin', appended);
    }
    else {
        var nodes = appended.length
            ? toArray(appended)
            : [appended];
        for (var i = nodes.length - 1, len = 0; i >= len; i -= 1) {
            node.insertBefore(nodes[i], node.firstChild);
        }
    }
}
function setAttributes(attributes, element) {
    Object.keys(attributes).forEach(function (attrName) {
        if (isNil(attributes[attrName])) {
            element.removeAttribute(attrName);
        }
        else {
            element.setAttribute(attrName, attributes[attrName]);
        }
    });
}
function replaceBRWithEmptyBlock(html) {
    // remove br in paragraph to compatible with markdown
    var replacedHTML = html.replace(/<p><br\s*\/*><\/p>/gi, '<p></p>');
    var reHTMLTag = new RegExp(HTML_TAG, 'ig');
    var htmlTagMatched = replacedHTML.match(reHTMLTag);
    htmlTagMatched === null || htmlTagMatched === void 0 ? void 0 : htmlTagMatched.forEach(function (htmlTag, index) {
        if (reBR.test(htmlTag)) {
            var alternativeTag = ALTERNATIVE_TAG_FOR_BR;
            if (index) {
                var prevTag = htmlTagMatched[index - 1];
                var openTagMatched = prevTag.match(OPEN_TAG);
                if (openTagMatched && !/br/i.test(openTagMatched[1])) {
                    var tagName = openTagMatched[1];
                    alternativeTag = "</" + tagName + "><" + tagName + ">";
                }
            }
            replacedHTML = replacedHTML.replace(reBR, alternativeTag);
        }
    });
    return replacedHTML;
}
function removeProseMirrorHackNodes(html) {
    var reProseMirrorImage = /<img class="ProseMirror-separator" alt="">/g;
    var reProseMirrorTrailingBreak = / class="ProseMirror-trailingBreak"/g;
    var resultHTML = html;
    resultHTML = resultHTML.replace(reProseMirrorImage, '');
    resultHTML = resultHTML.replace(reProseMirrorTrailingBreak, '');
    return resultHTML;
}

;// CONCATENATED MODULE: ./src/plugins/popupWidget.ts



var pluginKey = new external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.PluginKey('widget');
var MARGIN = 5;
var PopupWidget = /** @class */ (function () {
    function PopupWidget(view, eventEmitter) {
        var _this = this;
        this.popup = null;
        this.removeWidget = function () {
            if (_this.popup) {
                _this.rootEl.removeChild(_this.popup);
                _this.popup = null;
            }
        };
        this.rootEl = view.dom.parentElement;
        this.eventEmitter = eventEmitter;
        this.eventEmitter.listen('blur', this.removeWidget);
        this.eventEmitter.listen('loadUI', function () {
            _this.rootEl = closest(view.dom.parentElement, "." + cls('defaultUI'));
        });
        this.eventEmitter.listen('removePopupWidget', this.removeWidget);
    }
    PopupWidget.prototype.update = function (view) {
        var widget = pluginKey.getState(view.state);
        this.removeWidget();
        if (widget) {
            var node = widget.node, style = widget.style;
            var _a = view.coordsAtPos(widget.pos), top = _a.top, left = _a.left, bottom = _a.bottom;
            var height = bottom - top;
            var rect = this.rootEl.getBoundingClientRect();
            var relTopPos = top - rect.top;
            css_default()(node, { opacity: '0' });
            this.rootEl.appendChild(node);
            css_default()(node, {
                position: 'absolute',
                left: left - rect.left + MARGIN + "px",
                top: (style === 'bottom' ? relTopPos + height - MARGIN : relTopPos - height) + "px",
                opacity: '1',
            });
            this.popup = node;
            view.focus();
        }
    };
    PopupWidget.prototype.destroy = function () {
        this.eventEmitter.removeEventHandler('blur', this.removeWidget);
    };
    return PopupWidget;
}());
function addWidget(eventEmitter) {
    return new external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Plugin({
        key: pluginKey,
        state: {
            init: function () {
                return null;
            },
            apply: function (tr) {
                return tr.getMeta('widget');
            },
        },
        view: function (editorView) {
            return new PopupWidget(editorView, eventEmitter);
        },
    });
}

// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/collection/forEachArray.js
var forEachArray = __nested_webpack_require_93901__(893);
var forEachArray_default = /*#__PURE__*/__nested_webpack_require_93901__.n(forEachArray);
;// CONCATENATED MODULE: ./src/helper/image.ts

function addDefaultImageBlobHook(eventEmitter) {
    eventEmitter.listen('addImageBlobHook', function (blob, callback) {
        var reader = new FileReader();
        reader.onload = function (_a) {
            var target = _a.target;
            return callback(target.result);
        };
        reader.readAsDataURL(blob);
    });
}
function emitImageBlobHook(eventEmitter, blob, type) {
    var hook = function (imageUrl, altText) {
        eventEmitter.emit('command', 'addImage', {
            imageUrl: imageUrl,
            altText: altText || blob.name || 'image',
        });
    };
    eventEmitter.emit('addImageBlobHook', blob, hook, type);
}
function pasteImageOnly(items) {
    var images = toArray_default()(items).filter(function (_a) {
        var type = _a.type;
        return type.indexOf('image') !== -1;
    });
    if (images.length === 1) {
        var item = images[0];
        if (item) {
            return item.getAsFile();
        }
    }
    return null;
}

;// CONCATENATED MODULE: ./src/plugins/dropImage.ts



function dropImage(_a) {
    var eventEmitter = _a.eventEmitter;
    return new external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Plugin({
        props: {
            handleDOMEvents: {
                drop: function (_, ev) {
                    var _a;
                    var items = (_a = ev.dataTransfer) === null || _a === void 0 ? void 0 : _a.files;
                    if (items) {
                        forEachArray_default()(items, function (item) {
                            if (item.type.indexOf('image') !== -1) {
                                ev.preventDefault();
                                ev.stopPropagation();
                                emitImageBlobHook(eventEmitter, item, ev.type);
                                return false;
                            }
                            return true;
                        });
                    }
                    return true;
                },
            },
        },
    });
}

;// CONCATENATED MODULE: ./src/spec/node.ts
var node_Node = /** @class */ (function () {
    function Node() {
    }
    Object.defineProperty(Node.prototype, "type", {
        get: function () {
            return 'node';
        },
        enumerable: false,
        configurable: true
    });
    Node.prototype.setContext = function (context) {
        this.context = context;
    };
    return Node;
}());
/* harmony default export */ var node = (node_Node);

;// CONCATENATED MODULE: ./src/widget/widgetNode.ts



function widgetNodeView(pmNode) {
    var dom = document.createElement('span');
    var node = widgetToDOM(pmNode.attrs.info, pmNode.textContent);
    dom.className = 'tui-widget';
    dom.appendChild(node);
    return { dom: dom };
}
function isWidgetNode(pmNode) {
    return pmNode.type.name === 'widget';
}
var Widget = /** @class */ (function (_super) {
    __extends(Widget, _super);
    function Widget() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Widget.prototype, "name", {
        get: function () {
            return 'widget';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Widget.prototype, "schema", {
        get: function () {
            return {
                attrs: {
                    info: { default: null },
                },
                group: 'inline',
                inline: true,
                content: 'text*',
                selectable: false,
                atom: true,
                toDOM: function () {
                    return ['span', { class: 'tui-widget' }, 0];
                },
                parseDOM: [
                    {
                        tag: 'span.tui-widget',
                        getAttrs: function (dom) {
                            var text = dom.textContent;
                            var _a = text.match(/\$\$(widget\d+)/), info = _a[1];
                            return { info: info };
                        },
                    },
                ],
            };
        },
        enumerable: false,
        configurable: true
    });
    return Widget;
}(node));


;// CONCATENATED MODULE: ./src/base.ts
















var EditorBase = /** @class */ (function () {
    function EditorBase(eventEmitter) {
        this.timer = null;
        this.el = document.createElement('div');
        this.el.className = 'toastui-editor';
        this.eventEmitter = eventEmitter;
        this.placeholder = { text: '' };
    }
    EditorBase.prototype.createState = function () {
        return external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.EditorState.create({
            schema: this.schema,
            plugins: this.createPlugins(),
        });
    };
    EditorBase.prototype.initEvent = function () {
        var _a = this, eventEmitter = _a.eventEmitter, view = _a.view, editorType = _a.editorType;
        view.dom.addEventListener('focus', function () { return eventEmitter.emit('focus', editorType); });
        view.dom.addEventListener('blur', function () { return eventEmitter.emit('blur', editorType); });
    };
    EditorBase.prototype.emitChangeEvent = function (tr) {
        this.eventEmitter.emit('caretChange', this.editorType);
        if (tr.docChanged) {
            this.eventEmitter.emit('change', this.editorType);
        }
    };
    Object.defineProperty(EditorBase.prototype, "defaultPlugins", {
        get: function () {
            var rules = this.createInputRules();
            var plugins = __spreadArray(__spreadArray([], this.keymaps), [
                (0,external_commonjs_prosemirror_keymap_commonjs2_prosemirror_keymap_amd_prosemirror_keymap_.keymap)(__assign({ 'Shift-Enter': external_commonjs_prosemirror_commands_commonjs2_prosemirror_commands_amd_prosemirror_commands_.baseKeymap.Enter }, external_commonjs_prosemirror_commands_commonjs2_prosemirror_commands_amd_prosemirror_commands_.baseKeymap)),
                (0,external_commonjs_prosemirror_history_commonjs2_prosemirror_history_amd_prosemirror_history_.history)(),
                placeholder(this.placeholder),
                addWidget(this.eventEmitter),
                dropImage(this.context),
            ]);
            return rules ? plugins.concat(rules) : plugins;
        },
        enumerable: false,
        configurable: true
    });
    EditorBase.prototype.createInputRules = function () {
        var widgetRules = getWidgetRules();
        var rules = widgetRules.map(function (_a) {
            var rule = _a.rule;
            return new external_commonjs_prosemirror_inputrules_commonjs2_prosemirror_inputrules_amd_prosemirror_inputrules_.InputRule(rule, function (state, match, start, end) {
                var schema = state.schema, tr = state.tr, doc = state.doc;
                var allMatched = match.input.match(new RegExp(rule, 'g'));
                var pos = doc.resolve(start);
                var parent = pos.parent;
                var count = 0;
                if (isWidgetNode(parent)) {
                    parent = pos.node(pos.depth - 1);
                }
                parent.forEach(function (child) { return isWidgetNode(child) && (count += 1); });
                // replace the content only if the count of matched rules in whole text is greater than current widget node count
                if (allMatched.length > count) {
                    var content = last(allMatched);
                    var nodes = createNodesWithWidget(content, schema);
                    // adjust start position based on widget content
                    return tr.replaceWith(end - content.length + 1, end, nodes);
                }
                return null;
            });
        });
        return rules.length ? (0,external_commonjs_prosemirror_inputrules_commonjs2_prosemirror_inputrules_amd_prosemirror_inputrules_.inputRules)({ rules: rules }) : null;
    };
    EditorBase.prototype.clearTimer = function () {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
    };
    EditorBase.prototype.createSchema = function () {
        return new external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Schema({
            nodes: this.specs.nodes,
            marks: this.specs.marks,
        });
    };
    EditorBase.prototype.createKeymaps = function (useCommandShortcut) {
        var _a = getDefaultCommands(), undo = _a.undo, redo = _a.redo;
        var allKeymaps = this.specs.keymaps(useCommandShortcut);
        var historyKeymap = {
            'Mod-z': undo(),
            'Shift-Mod-z': redo(),
        };
        return useCommandShortcut ? allKeymaps.concat((0,external_commonjs_prosemirror_keymap_commonjs2_prosemirror_keymap_amd_prosemirror_keymap_.keymap)(historyKeymap)) : allKeymaps;
    };
    EditorBase.prototype.createCommands = function () {
        return this.specs.commands(this.view);
    };
    EditorBase.prototype.createPluginProps = function () {
        var _this = this;
        return this.extraPlugins.map(function (plugin) { return plugin(_this.eventEmitter); });
    };
    EditorBase.prototype.focus = function () {
        var _this = this;
        this.clearTimer();
        // prevent the error for IE11
        this.timer = setTimeout(function () {
            _this.view.focus();
            _this.view.dispatch(_this.view.state.tr.scrollIntoView());
        });
    };
    EditorBase.prototype.blur = function () {
        this.view.dom.blur();
    };
    EditorBase.prototype.destroy = function () {
        var _this = this;
        this.clearTimer();
        this.view.destroy();
        Object.keys(this).forEach(function (prop) {
            delete _this[prop];
        });
    };
    EditorBase.prototype.moveCursorToStart = function (focus) {
        var tr = this.view.state.tr;
        this.view.dispatch(tr.setSelection(createTextSelection(tr, 1)).scrollIntoView());
        if (focus) {
            this.focus();
        }
    };
    EditorBase.prototype.moveCursorToEnd = function (focus) {
        var tr = this.view.state.tr;
        this.view.dispatch(tr.setSelection(createTextSelection(tr, tr.doc.content.size - 1)).scrollIntoView());
        if (focus) {
            this.focus();
        }
    };
    EditorBase.prototype.setScrollTop = function (top) {
        this.view.dom.scrollTop = top;
    };
    EditorBase.prototype.getScrollTop = function () {
        return this.view.dom.scrollTop;
    };
    EditorBase.prototype.setPlaceholder = function (text) {
        this.placeholder.text = text;
        this.view.dispatch(this.view.state.tr.scrollIntoView());
    };
    EditorBase.prototype.setHeight = function (height) {
        css_default()(this.el, { height: height + "px" });
    };
    EditorBase.prototype.setMinHeight = function (minHeight) {
        css_default()(this.el, { minHeight: minHeight + "px" });
    };
    EditorBase.prototype.getElement = function () {
        return this.el;
    };
    return EditorBase;
}());
/* harmony default export */ var base = (EditorBase);

// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isFunction.js
var isFunction = __nested_webpack_require_93901__(294);
var isFunction_default = /*#__PURE__*/__nested_webpack_require_93901__.n(isFunction);
;// CONCATENATED MODULE: ./src/spec/specManager.ts





var defaultCommandShortcuts = [
    'Enter',
    'Shift-Enter',
    'Mod-Enter',
    'Tab',
    'Shift-Tab',
    'Delete',
    'Backspace',
    'Mod-Delete',
    'Mod-Backspace',
    'ArrowUp',
    'ArrowDown',
    'ArrowLeft',
    'ArrowRight',
    'Mod-d',
    'Mod-D',
    'Alt-ArrowUp',
    'Alt-ArrowDown',
];
function execCommand(view, command, payload) {
    view.focus();
    return command(payload)(view.state, view.dispatch, view);
}
var SpecManager = /** @class */ (function () {
    function SpecManager(specs) {
        this.specs = specs;
    }
    Object.defineProperty(SpecManager.prototype, "nodes", {
        get: function () {
            return this.specs
                .filter(function (spec) { return spec.type === 'node'; })
                .reduce(function (nodes, _a) {
                var _b;
                var name = _a.name, schema = _a.schema;
                return __assign(__assign({}, nodes), (_b = {}, _b[name] = schema, _b));
            }, {});
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SpecManager.prototype, "marks", {
        get: function () {
            return this.specs
                .filter(function (spec) { return spec.type === 'mark'; })
                .reduce(function (marks, _a) {
                var _b;
                var name = _a.name, schema = _a.schema;
                return __assign(__assign({}, marks), (_b = {}, _b[name] = schema, _b));
            }, {});
        },
        enumerable: false,
        configurable: true
    });
    SpecManager.prototype.commands = function (view, addedCommands) {
        var specCommands = this.specs
            .filter(function (_a) {
            var commands = _a.commands;
            return commands;
        })
            .reduce(function (allCommands, spec) {
            var commands = {};
            var specCommand = spec.commands();
            if (isFunction_default()(specCommand)) {
                commands[spec.name] = function (payload) { return execCommand(view, specCommand, payload); };
            }
            else {
                Object.keys(specCommand).forEach(function (name) {
                    commands[name] = function (payload) { return execCommand(view, specCommand[name], payload); };
                });
            }
            return __assign(__assign({}, allCommands), commands);
        }, {});
        var defaultCommands = getDefaultCommands();
        Object.keys(defaultCommands).forEach(function (name) {
            specCommands[name] = function (payload) { return execCommand(view, defaultCommands[name], payload); };
        });
        if (addedCommands) {
            Object.keys(addedCommands).forEach(function (name) {
                specCommands[name] = function (payload) { return execCommand(view, addedCommands[name], payload); };
            });
        }
        return specCommands;
    };
    SpecManager.prototype.keymaps = function (useCommandShortcut) {
        var specKeymaps = this.specs.filter(function (spec) { return spec.keymaps; }).map(function (spec) { return spec.keymaps(); });
        return specKeymaps.map(function (keys) {
            if (!useCommandShortcut) {
                Object.keys(keys).forEach(function (key) {
                    if (!common_includes(defaultCommandShortcuts, key)) {
                        delete keys[key];
                    }
                });
            }
            return (0,external_commonjs_prosemirror_keymap_commonjs2_prosemirror_keymap_amd_prosemirror_keymap_.keymap)(keys);
        });
    };
    SpecManager.prototype.setContext = function (context) {
        this.specs.forEach(function (spec) {
            spec.setContext(context);
        });
    };
    return SpecManager;
}());
/* harmony default export */ var specManager = (SpecManager);

;// CONCATENATED MODULE: ./src/markdown/helper/pos.ts


function resolveSelectionPos(selection) {
    var from = selection.from, to = selection.to;
    if (selection instanceof external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.AllSelection) {
        return [from + 1, to - 1];
    }
    return [from, to];
}
function getMdLine(resolvedPos) {
    return resolvedPos.index(0) + 1;
}
function getWidgetNodePos(node, chPos, direction) {
    if (direction === void 0) { direction = 1; }
    var additionalPos = 0;
    node.forEach(function (child, pos) {
        // add or subtract widget node tag
        if (isWidgetNode(child) && pos + 2 < chPos) {
            additionalPos += 2 * direction;
        }
    });
    return additionalPos;
}
function getEditorToMdPos(doc, from, to) {
    if (to === void 0) { to = from; }
    var collapsed = from === to;
    var startResolvedPos = doc.resolve(from);
    var startLine = getMdLine(startResolvedPos);
    var endLine = startLine;
    var startOffset = startResolvedPos.start(1);
    var endOffset = startOffset;
    if (!collapsed) {
        // prevent the end offset from pointing to the root document position
        var endResolvedPos = doc.resolve(to === doc.content.size ? to - 1 : to);
        endOffset = endResolvedPos.start(1);
        endLine = getMdLine(endResolvedPos);
        // To resolve the end offset excluding document tag size
        if (endResolvedPos.pos === doc.content.size) {
            to = doc.content.size - 2;
        }
    }
    var startCh = Math.max(from - startOffset + 1, 1);
    var endCh = Math.max(to - endOffset + 1, 1);
    return [
        [startLine, startCh + getWidgetNodePos(doc.child(startLine - 1), startCh, -1)],
        [endLine, endCh + getWidgetNodePos(doc.child(endLine - 1), endCh, -1)],
    ];
}
function getStartPosListPerLine(doc, endIndex) {
    var startPosListPerLine = [];
    for (var i = 0, pos = 0; i < endIndex; i += 1) {
        var child = doc.child(i);
        startPosListPerLine[i] = pos;
        pos += child.nodeSize;
    }
    return startPosListPerLine;
}
function getMdToEditorPos(doc, startPos, endPos) {
    var startPosListPerLine = getStartPosListPerLine(doc, endPos[0]);
    var startIndex = startPos[0] - 1;
    var endIndex = endPos[0] - 1;
    var startNode = doc.child(startIndex);
    var endNode = doc.child(endIndex);
    // calculate the position corresponding to the line
    var from = startPosListPerLine[startIndex];
    var to = startPosListPerLine[endIndex];
    // calculate the position corresponding to the character offset of the line
    from += startPos[1] + getWidgetNodePos(startNode, startPos[1] - 1);
    to += endPos[1] + getWidgetNodePos(endNode, endPos[1] - 1);
    return [from, Math.min(to, doc.content.size)];
}
function getRangeInfo(selection) {
    var $from = selection.$from, $to = selection.$to;
    var from = selection.from, to = selection.to;
    var doc = $from.doc;
    if (selection instanceof external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.AllSelection) {
        $from = doc.resolve(from + 1);
        $to = doc.resolve(to - 1);
    }
    if ($from.depth === 0) {
        $from = doc.resolve(from - 1);
        $to = $from;
    }
    return {
        startFromOffset: $from.start(1),
        endFromOffset: $to.start(1),
        startToOffset: $from.end(1),
        endToOffset: $to.end(1),
        startIndex: $from.index(0),
        endIndex: $to.index(0),
        from: $from.pos,
        to: $to.pos,
    };
}
function getNodeContentOffsetRange(doc, targetIndex) {
    var startOffset = 1;
    var endOffset = 1;
    for (var i = 0, offset = 0; i < doc.childCount; i += 1) {
        var nodeSize = doc.child(i).nodeSize;
        // calculate content start, end offset(not node offset)
        startOffset = offset + 1;
        endOffset = offset + nodeSize - 1;
        if (i === targetIndex) {
            break;
        }
        offset += nodeSize;
    }
    return { startOffset: startOffset, endOffset: endOffset };
}

;// CONCATENATED MODULE: ./src/markdown/plugins/helper/markInfo.ts



var HEADING = 'heading';
var BLOCK_QUOTE = 'blockQuote';
var LIST_ITEM = 'listItem';
var TABLE = 'table';
var TABLE_CELL = 'tableCell';
var CODE_BLOCK = 'codeBlock';
var THEMATIC_BREAK = 'thematicBreak';
var LINK = 'link';
var CODE = 'code';
var META = 'meta';
var DELIM = 'delimiter';
var TASK_DELIM = 'taskDelimiter';
var TEXT = 'markedText';
var HTML = 'html';
var CUSTOM_BLOCK = 'customBlock';
var delimSize = {
    strong: 2,
    emph: 1,
    strike: 2,
};
function markInfo(start, end, type, attrs) {
    return { start: start, end: end, spec: { type: type, attrs: attrs } };
}
function heading(_a, start, end) {
    var level = _a.level, headingType = _a.headingType;
    var marks = [markInfo(start, end, HEADING, { level: level })];
    if (headingType === 'atx') {
        marks.push(markInfo(start, addOffsetPos(start, level), DELIM));
    }
    else {
        marks.push(markInfo(setOffsetPos(end, 0), end, HEADING, { seText: true }));
    }
    return marks;
}
function emphasisAndStrikethrough(_a, start, end) {
    var type = _a.type;
    var startDelimPos = addOffsetPos(start, delimSize[type]);
    var endDelimPos = addOffsetPos(end, -delimSize[type]);
    return [
        markInfo(startDelimPos, endDelimPos, type),
        markInfo(start, startDelimPos, DELIM),
        markInfo(endDelimPos, end, DELIM),
    ];
}
function markLink(start, end, linkTextStart, lastChildCh) {
    return [
        markInfo(start, end, LINK),
        markInfo(setOffsetPos(start, linkTextStart[1] + 1), setOffsetPos(end, lastChildCh), LINK, {
            desc: true,
        }),
        markInfo(setOffsetPos(end, lastChildCh + 2), addOffsetPos(end, -1), LINK, { url: true }),
    ];
}
function markInfo_image(_a, start, end) {
    var lastChild = _a.lastChild;
    var lastChildCh = lastChild ? getMdEndCh(lastChild) + 1 : 3; // 3: length of '![]'
    var linkTextEnd = addOffsetPos(start, 1);
    return __spreadArray([markInfo(start, linkTextEnd, META)], markLink(start, end, linkTextEnd, lastChildCh));
}
function markInfo_link(_a, start, end) {
    var lastChild = _a.lastChild, extendedAutolink = _a.extendedAutolink;
    var lastChildCh = lastChild ? getMdEndCh(lastChild) + 1 : 2; // 2: length of '[]'
    return extendedAutolink
        ? [markInfo(start, end, LINK, { desc: true })]
        : markLink(start, end, start, lastChildCh);
}
function code(_a, start, end) {
    var tickCount = _a.tickCount;
    var openDelimEnd = addOffsetPos(start, tickCount);
    var closeDelimStart = addOffsetPos(end, -tickCount);
    return [
        markInfo(start, end, CODE),
        markInfo(start, openDelimEnd, CODE, { start: true }),
        markInfo(openDelimEnd, closeDelimStart, CODE, { marked: true }),
        markInfo(closeDelimStart, end, CODE, { end: true }),
    ];
}
function lineBackground(parent, start, end, prefix) {
    var defaultBackground = {
        start: start,
        end: end,
        spec: {
            attrs: { className: prefix + "-line-background", codeStart: start[0], codeEnd: end[0] },
        },
        lineBackground: true,
    };
    return parent.type !== 'item' && parent.type !== 'blockQuote'
        ? [
            __assign(__assign({}, defaultBackground), { end: start, spec: { attrs: { className: prefix + "-line-background start" } } }),
            __assign(__assign({}, defaultBackground), { start: [Math.min(start[0] + 1, end[0]), start[1]] }),
        ]
        : null;
}
function codeBlock(node, start, end, endLine) {
    var fenceOffset = node.fenceOffset, fenceLength = node.fenceLength, fenceChar = node.fenceChar, info = node.info, infoPadding = node.infoPadding, parent = node.parent;
    var fenceEnd = fenceOffset + fenceLength;
    var marks = [markInfo(setOffsetPos(start, 1), end, CODE_BLOCK)];
    if (fenceChar) {
        marks.push(markInfo(start, addOffsetPos(start, fenceEnd), DELIM));
    }
    if (info) {
        marks.push(markInfo(addOffsetPos(start, fenceLength), addOffsetPos(start, fenceLength + infoPadding + info.length), META));
    }
    var codeBlockEnd = "^(\\s{0,4})(" + fenceChar + "{" + fenceLength + ",})";
    var reCodeBlockEnd = new RegExp(codeBlockEnd);
    if (reCodeBlockEnd.test(endLine)) {
        marks.push(markInfo(setOffsetPos(end, 1), end, DELIM));
    }
    var lineBackgroundMarkInfo = lineBackground(parent, start, end, 'code-block');
    return lineBackgroundMarkInfo ? marks.concat(lineBackgroundMarkInfo) : marks;
}
function customBlock(node, start, end) {
    var _a = node, offset = _a.offset, syntaxLength = _a.syntaxLength, info = _a.info, parent = _a.parent;
    var syntaxEnd = offset + syntaxLength;
    var marks = [markInfo(setOffsetPos(start, 1), end, CUSTOM_BLOCK)];
    marks.push(markInfo(start, addOffsetPos(start, syntaxEnd), DELIM));
    if (info) {
        marks.push(markInfo(addOffsetPos(start, syntaxEnd), addOffsetPos(start, syntaxLength + info.length), META));
    }
    marks.push(markInfo(setOffsetPos(end, 1), end, DELIM));
    var lineBackgroundMarkInfo = lineBackground(parent, start, end, 'custom-block');
    return lineBackgroundMarkInfo ? marks.concat(lineBackgroundMarkInfo) : marks;
}
function markListItemChildren(node, markType) {
    var marks = [];
    while (node) {
        var type = node.type;
        if (type === 'paragraph' || type === 'codeBlock') {
            marks.push(markInfo([getMdStartLine(node), getMdStartCh(node) - 1], [getMdEndLine(node), getMdEndCh(node) + 1], markType));
        }
        node = node.next;
    }
    return marks;
}
function markParagraphInBlockQuote(node) {
    var marks = [];
    while (node) {
        marks.push(markInfo([getMdStartLine(node), getMdStartCh(node)], [getMdEndLine(node), getMdEndCh(node) + 1], TEXT));
        node = node.next;
    }
    return marks;
}
function blockQuote(node, start, end) {
    var marks = node.parent && node.parent.type !== 'blockQuote' ? [markInfo(start, end, BLOCK_QUOTE)] : [];
    if (node.firstChild) {
        var childMarks = [];
        if (node.firstChild.type === 'paragraph') {
            childMarks = markParagraphInBlockQuote(node.firstChild.firstChild);
        }
        else if (node.firstChild.type === 'list') {
            childMarks = markListItemChildren(node.firstChild, TEXT);
        }
        marks = __spreadArray(__spreadArray([], marks), childMarks);
    }
    return marks;
}
function getSpecOfListItemStyle(node) {
    var depth = 0;
    while (node.parent.parent && node.parent.parent.type === 'item') {
        node = node.parent.parent;
        depth += 1;
    }
    var attrs = [{ odd: true }, { even: true }][depth % 2];
    return [LIST_ITEM, __assign(__assign({}, attrs), { listStyle: true })];
}
function item(node, start) {
    var _a = node.listData, padding = _a.padding, task = _a.task;
    var spec = getSpecOfListItemStyle(node);
    var marks = [markInfo.apply(void 0, __spreadArray([start, addOffsetPos(start, padding)], spec))];
    if (task) {
        marks.push(markInfo(addOffsetPos(start, padding), addOffsetPos(start, padding + 3), TASK_DELIM));
        marks.push(markInfo(addOffsetPos(start, padding + 1), addOffsetPos(start, padding + 2), META));
    }
    return marks.concat(markListItemChildren(node.firstChild, TEXT));
}
var markNodeFuncMap = {
    heading: heading,
    strong: emphasisAndStrikethrough,
    emph: emphasisAndStrikethrough,
    strike: emphasisAndStrikethrough,
    link: markInfo_link,
    image: markInfo_image,
    code: code,
    codeBlock: codeBlock,
    blockQuote: blockQuote,
    item: item,
    customBlock: customBlock,
};
var simpleMarkClassNameMap = {
    thematicBreak: THEMATIC_BREAK,
    table: TABLE,
    tableCell: TABLE_CELL,
    htmlInline: HTML,
};
function getMarkInfo(node, start, end, endLine) {
    var type = node.type;
    if (isFunction_default()(markNodeFuncMap[type])) {
        // @ts-ignore
        return markNodeFuncMap[type](node, start, end, endLine);
    }
    if (simpleMarkClassNameMap[type]) {
        return [markInfo(start, end, simpleMarkClassNameMap[type])];
    }
    return null;
}

;// CONCATENATED MODULE: ./src/markdown/plugins/syntaxHighlight.ts





var removingBackgroundIndexMap = {};
function syntaxHighlight(_a) {
    var schema = _a.schema, toastMark = _a.toastMark;
    return new external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Plugin({
        appendTransaction: function (transactions, _, newState) {
            var tr = transactions[0];
            var newTr = newState.tr;
            if (tr.docChanged) {
                var markInfo_1 = [];
                var editResult = tr.getMeta('editResult');
                editResult.forEach(function (result) {
                    var nodes = result.nodes, removedNodeRange = result.removedNodeRange;
                    if (nodes.length) {
                        markInfo_1 = markInfo_1.concat(getMarkForRemoving(newTr, nodes));
                        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
                            var parent = nodes_1[_i];
                            var walker = parent.walker();
                            var event = walker.next();
                            while (event) {
                                var node = event.node, entering = event.entering;
                                if (entering) {
                                    markInfo_1 = markInfo_1.concat(getMarkForAdding(node, toastMark));
                                }
                                event = walker.next();
                            }
                        }
                    }
                    else if (removedNodeRange) {
                        var maxIndex = newTr.doc.childCount - 1;
                        var _a = removedNodeRange.line, startLine = _a[0], endLine = _a[1];
                        var startIndex = Math.min(startLine, maxIndex);
                        var endIndex = Math.min(endLine, maxIndex);
                        // cache the index to remove code block, custom block background when there are no adding nodes
                        for (var i = startIndex; i <= endIndex; i += 1) {
                            removingBackgroundIndexMap[i] = true;
                        }
                    }
                });
                appendMarkTr(newTr, schema, markInfo_1);
            }
            return newTr.setMeta('widget', tr.getMeta('widget'));
        },
    });
}
function isDifferentBlock(doc, index, attrs) {
    return Object.keys(attrs).some(function (name) { return attrs[name] !== doc.child(index).attrs[name]; });
}
function addLineBackground(tr, doc, paragraph, blockPosInfo, attrs) {
    if (attrs === void 0) { attrs = {}; }
    var startIndex = blockPosInfo.startIndex, endIndex = blockPosInfo.endIndex, from = blockPosInfo.from, to = blockPosInfo.to;
    var shouldChangeBlockType = false;
    for (var i = startIndex; i <= endIndex; i += 1) {
        // prevent to remove background of the node that need to have background
        delete removingBackgroundIndexMap[i];
        shouldChangeBlockType = isDifferentBlock(doc, i, attrs);
    }
    if (shouldChangeBlockType) {
        tr.setBlockType(from, to, paragraph, attrs);
    }
}
function appendMarkTr(tr, schema, marks) {
    var doc = tr.doc;
    var paragraph = schema.nodes.paragraph;
    // get start position per line for lazy calculation
    var startPosListPerLine = getStartPosListPerLine(doc, doc.childCount);
    marks.forEach(function (_a) {
        var start = _a.start, end = _a.end, spec = _a.spec, lineBackground = _a.lineBackground;
        var startIndex = Math.min(start[0], doc.childCount) - 1;
        var endIndex = Math.min(end[0], doc.childCount) - 1;
        var startNode = doc.child(startIndex);
        var endNode = doc.child(endIndex);
        // calculate the position corresponding to the line
        var from = startPosListPerLine[startIndex];
        var to = startPosListPerLine[endIndex];
        // calculate the position corresponding to the character offset of the line
        from += start[1] + getWidgetNodePos(startNode, start[1] - 1);
        to += end[1] + getWidgetNodePos(endNode, end[1] - 1);
        if (spec) {
            if (lineBackground) {
                var posInfo = { from: from, to: to, startIndex: startIndex, endIndex: endIndex };
                addLineBackground(tr, doc, paragraph, posInfo, spec.attrs);
            }
            else {
                tr.addMark(from, to, schema.mark(spec.type, spec.attrs));
            }
        }
        else {
            tr.removeMark(from, to);
        }
    });
    removeBlockBackground(tr, startPosListPerLine, paragraph);
}
function removeBlockBackground(tr, startPosListPerLine, paragraph) {
    Object.keys(removingBackgroundIndexMap).forEach(function (index) {
        var startIndex = Number(index);
        // get the end position of the current line with the next node start position.
        var endIndex = Math.min(Number(index) + 1, tr.doc.childCount - 1);
        var from = startPosListPerLine[startIndex];
        // subtract '1' for getting end position of the line
        var to = startPosListPerLine[endIndex] - 1;
        if (startIndex === endIndex) {
            to += 2;
        }
        tr.setBlockType(from, to, paragraph);
    });
}
function cacheIndexToRemoveBackground(doc, start, end) {
    var skipLines = [];
    removingBackgroundIndexMap = {};
    for (var i = start[0] - 1; i < end[0]; i += 1) {
        var node = doc.child(i);
        var codeEnd = node.attrs.codeEnd;
        var codeStart = node.attrs.codeStart;
        if (codeStart && codeEnd && !common_includes(skipLines, codeStart)) {
            skipLines.push(codeStart);
            codeEnd = Math.min(codeEnd, doc.childCount);
            // should subtract '1' to markdown line position
            // because markdown parser has '1'(not zero) as the start number
            var startIndex = codeStart - 1;
            var endIndex = end[0];
            for (var index = startIndex; index < endIndex; index += 1) {
                removingBackgroundIndexMap[index] = true;
            }
        }
    }
}
function getMarkForRemoving(_a, nodes) {
    var doc = _a.doc;
    var start = nodes[0].sourcepos[0];
    var _b = last(nodes).sourcepos, end = _b[1];
    var startPos = [start[0], start[1]];
    var endPos = [end[0], end[1] + 1];
    var marks = [];
    cacheIndexToRemoveBackground(doc, start, end);
    marks.push({ start: startPos, end: endPos });
    return marks;
}
function getMarkForAdding(node, toastMark) {
    var lineTexts = toastMark.getLineTexts();
    var startPos = [getMdStartLine(node), getMdStartCh(node)];
    var endPos = [getMdEndLine(node), getMdEndCh(node) + 1];
    var markInfo = getMarkInfo(node, startPos, endPos, lineTexts[endPos[0] - 1]);
    return markInfo !== null && markInfo !== void 0 ? markInfo : [];
}

;// CONCATENATED MODULE: ./src/markdown/plugins/previewHighlight.ts



var defaultToolbarStateKeys = [
    'taskList',
    'orderedList',
    'bulletList',
    'table',
    'strong',
    'emph',
    'strike',
    'heading',
    'thematicBreak',
    'blockQuote',
    'code',
    'codeBlock',
    'indent',
    'outdent',
];
function getToolbarStateType(mdNode) {
    var type = mdNode.type;
    if (isListNode(mdNode)) {
        if (mdNode.listData.task) {
            return 'taskList';
        }
        return mdNode.listData.type === 'ordered' ? 'orderedList' : 'bulletList';
    }
    if (type.indexOf('table') !== -1) {
        return 'table';
    }
    if (!common_includes(defaultToolbarStateKeys, type)) {
        return null;
    }
    return type;
}
function getToolbarState(targetNode) {
    var toolbarState = {
        indent: { active: false, disabled: true },
        outdent: { active: false, disabled: true },
    };
    var listEnabled = true;
    traverseParentNodes(targetNode, function (mdNode) {
        var type = getToolbarStateType(mdNode);
        if (!type) {
            return;
        }
        if (type === 'bulletList' || type === 'orderedList') {
            // to apply the nearlist list state in the nested list
            if (listEnabled) {
                toolbarState[type] = { active: true };
                toolbarState.indent.disabled = false;
                toolbarState.outdent.disabled = false;
                listEnabled = false;
            }
        }
        else {
            toolbarState[type] = { active: true };
        }
    });
    return toolbarState;
}
function previewHighlight(_a) {
    var toastMark = _a.toastMark, eventEmitter = _a.eventEmitter;
    return new external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Plugin({
        view: function () {
            return {
                update: function (view, prevState) {
                    var state = view.state;
                    var doc = state.doc, selection = state.selection;
                    if (prevState && prevState.doc.eq(doc) && prevState.selection.eq(selection)) {
                        return;
                    }
                    var from = selection.from;
                    var startChOffset = state.doc.resolve(from).start();
                    var line = state.doc.content.findIndex(from).index + 1;
                    var ch = from - startChOffset;
                    if (from === startChOffset) {
                        ch += 1;
                    }
                    var cursorPos = [line, ch];
                    var mdNode = toastMark.findNodeAtPosition(cursorPos);
                    var toolbarState = getToolbarState(mdNode);
                    eventEmitter.emit('changeToolbarState', {
                        cursorPos: cursorPos,
                        mdNode: mdNode,
                        toolbarState: toolbarState,
                    });
                    eventEmitter.emit('setFocusedNode', mdNode);
                },
            };
        },
    });
}

;// CONCATENATED MODULE: ./src/markdown/nodes/doc.ts


var Doc = /** @class */ (function (_super) {
    __extends(Doc, _super);
    function Doc() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Doc.prototype, "name", {
        get: function () {
            return 'doc';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Doc.prototype, "schema", {
        get: function () {
            return {
                content: 'block+',
            };
        },
        enumerable: false,
        configurable: true
    });
    return Doc;
}(node));


;// CONCATENATED MODULE: ./src/spec/mark.ts
var Mark = /** @class */ (function () {
    function Mark() {
    }
    Object.defineProperty(Mark.prototype, "type", {
        get: function () {
            return 'mark';
        },
        enumerable: false,
        configurable: true
    });
    Mark.prototype.setContext = function (context) {
        this.context = context;
    };
    return Mark;
}());
/* harmony default export */ var mark = (Mark);

;// CONCATENATED MODULE: ./src/markdown/helper/query.ts
function getTextByMdLine(doc, mdLine) {
    return getTextContent(doc, mdLine - 1);
}
function getTextContent(doc, index) {
    return doc.child(index).textContent;
}

;// CONCATENATED MODULE: ./src/markdown/marks/blockQuote.ts






var reBlockQuote = /^\s*> ?/;
var BlockQuote = /** @class */ (function (_super) {
    __extends(BlockQuote, _super);
    function BlockQuote() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(BlockQuote.prototype, "name", {
        get: function () {
            return 'blockQuote';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BlockQuote.prototype, "schema", {
        get: function () {
            return {
                toDOM: function () {
                    return ['span', { class: clsWithMdPrefix('block-quote') }, 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    BlockQuote.prototype.createBlockQuoteText = function (text, isBlockQuote) {
        return isBlockQuote ? text.replace(reBlockQuote, '').trim() : "> " + text.trim();
    };
    BlockQuote.prototype.extendBlockQuote = function () {
        var _this = this;
        return function (_a, dispatch) {
            var selection = _a.selection, doc = _a.doc, tr = _a.tr, schema = _a.schema;
            var _b = getRangeInfo(selection), endFromOffset = _b.endFromOffset, endToOffset = _b.endToOffset, endIndex = _b.endIndex, to = _b.to;
            var textContent = getTextContent(doc, endIndex);
            var isBlockQuote = reBlockQuote.test(textContent);
            if (isBlockQuote && to > endFromOffset && selection.empty) {
                var isEmpty = !textContent.replace(reBlockQuote, '').trim();
                if (isEmpty) {
                    tr.deleteRange(endFromOffset, endToOffset).split(tr.mapping.map(endToOffset));
                }
                else {
                    var slicedText = textContent.slice(to - endFromOffset).trim();
                    var node = createTextNode(schema, _this.createBlockQuoteText(slicedText));
                    splitAndExtendBlock(tr, endToOffset, slicedText, node);
                }
                dispatch(tr);
                return true;
            }
            return false;
        };
    };
    BlockQuote.prototype.commands = function () {
        var _this = this;
        return function () { return function (state, dispatch) {
            var selection = state.selection, doc = state.doc;
            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;
            var isBlockQuote = reBlockQuote.test(getTextContent(doc, startIndex));
            var tr = replaceTextNode({
                state: state,
                startIndex: startIndex,
                endIndex: endIndex,
                from: startFromOffset,
                createText: function (textContent) { return _this.createBlockQuoteText(textContent, isBlockQuote); },
            });
            dispatch(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset))));
            return true;
        }; };
    };
    BlockQuote.prototype.keymaps = function () {
        var blockQuoteCommand = this.commands()();
        return {
            'alt-q': blockQuoteCommand,
            'alt-Q': blockQuoteCommand,
            Enter: this.extendBlockQuote(),
        };
    };
    return BlockQuote;
}(mark));


;// CONCATENATED MODULE: ./src/markdown/helper/list.ts




var reList = /(^\s*)([-*+] |[\d]+\. )/;
var reOrderedList = /(^\s*)([\d])+\.( \[[ xX]])? /;
var reOrderedListGroup = /^(\s*)((\d+)([.)]\s(?:\[(?:x|\s)\]\s)?))(.*)/;
var reCanBeTaskList = /(^\s*)([-*+]|[\d]+\.)( \[[ xX]])? /;
var reBulletListGroup = /^(\s*)([-*+]+(\s(?:\[(?:x|\s)\]\s)?))(.*)/;
var reTaskList = /(^\s*)([-*+] |[\d]+\. )(\[[ xX]] )/;
var reBulletTaskList = /(^\s*)([-*+])( \[[ xX]]) /;
function getListType(text) {
    return reOrderedList.test(text) ? 'ordered' : 'bullet';
}
function getListDepth(mdNode) {
    var depth = 0;
    while (mdNode && mdNode.type !== 'document') {
        if (mdNode.type === 'list') {
            depth += 1;
        }
        mdNode = mdNode.parent;
    }
    return depth;
}
function findSameDepthList(toastMark, currentLine, depth, backward) {
    var lineTexts = toastMark.getLineTexts();
    var lineLen = lineTexts.length;
    var result = [];
    var line = currentLine;
    while (backward ? line < lineLen : line > 1) {
        line = backward ? line + 1 : line - 1;
        var mdNode = toastMark.findFirstNodeAtLine(line);
        var currentListDepth = getListDepth(mdNode);
        if (currentListDepth === depth) {
            result.push({ line: line, depth: depth, mdNode: mdNode });
        }
        else if (currentListDepth < depth) {
            break;
        }
    }
    return result;
}
function getSameDepthItems(_a) {
    var toastMark = _a.toastMark, mdNode = _a.mdNode, line = _a.line;
    var depth = getListDepth(mdNode);
    var forwardList = findSameDepthList(toastMark, line, depth, false).reverse();
    var backwardList = findSameDepthList(toastMark, line, depth, true);
    return forwardList.concat([{ line: line, depth: depth, mdNode: mdNode }]).concat(backwardList);
}
function textToBullet(text) {
    if (!reList.test(text)) {
        return "* " + text;
    }
    var type = getListType(text);
    if (type === 'bullet' && reCanBeTaskList.test(text)) {
        text = text.replace(reBulletTaskList, '$1$2 ');
    }
    else if (type === 'ordered') {
        text = text.replace(reOrderedList, '$1* ');
    }
    return text;
}
function textToOrdered(text, ordinalNum) {
    if (!reList.test(text)) {
        return ordinalNum + ". " + text;
    }
    var type = getListType(text);
    if (type === 'bullet' || (type === 'ordered' && reCanBeTaskList.test(text))) {
        text = text.replace(reCanBeTaskList, "$1" + ordinalNum + ". ");
    }
    else if (type === 'ordered') {
        // eslint-disable-next-line prefer-destructuring
        var start = reOrderedListGroup.exec(text)[3];
        if (Number(start) !== ordinalNum) {
            text = text.replace(reOrderedList, "$1" + ordinalNum + ". ");
        }
    }
    return text;
}
function getChangedInfo(doc, sameDepthItems, type, start) {
    if (start === void 0) { start = 0; }
    var firstIndex = Number.MAX_VALUE;
    var lastIndex = 0;
    var changedResults = sameDepthItems.map(function (_a, index) {
        var line = _a.line;
        firstIndex = Math.min(line - 1, firstIndex);
        lastIndex = Math.max(line - 1, lastIndex);
        var text = getTextByMdLine(doc, line);
        text = type === 'bullet' ? textToBullet(text) : textToOrdered(text, index + 1 + start);
        return { text: text, line: line };
    });
    return { changedResults: changedResults, firstIndex: firstIndex, lastIndex: lastIndex };
}
function getBulletOrOrdered(type, context) {
    var sameDepthListInfo = getSameDepthItems(context);
    return getChangedInfo(context.doc, sameDepthListInfo, type);
}
var otherListToList = {
    bullet: function (context) {
        return getBulletOrOrdered('bullet', context);
    },
    ordered: function (context) {
        return getBulletOrOrdered('ordered', context);
    },
    task: function (_a) {
        var mdNode = _a.mdNode, doc = _a.doc, line = _a.line;
        var text = getTextByMdLine(doc, line);
        if (mdNode.listData.task) {
            text = text.replace(reTaskList, '$1$2');
        }
        else if (isListNode(mdNode)) {
            text = text.replace(reList, '$1$2[ ] ');
        }
        return { changedResults: [{ text: text, line: line }] };
    },
};
var otherNodeToList = {
    bullet: function (_a) {
        var doc = _a.doc, line = _a.line;
        var lineText = getTextByMdLine(doc, line);
        var changedResults = [{ text: "* " + lineText, line: line }];
        return { changedResults: changedResults };
    },
    ordered: function (_a) {
        var toastMark = _a.toastMark, doc = _a.doc, line = _a.line, startLine = _a.startLine;
        var lineText = getTextByMdLine(doc, line);
        var firstOrderedListNum = 1;
        var firstOrderedListLine = startLine;
        var skipped = 0;
        for (var i = startLine - 1; i > 0; i -= 1) {
            var mdNode = toastMark.findFirstNodeAtLine(i);
            var text = getTextByMdLine(doc, i);
            var canBeListNode = text && !!findClosestNode(mdNode, function (targetNode) { return isListNode(targetNode); });
            var searchResult = reOrderedListGroup.exec(getTextByMdLine(doc, i));
            if (!searchResult && !canBeListNode) {
                break;
            }
            if (!searchResult && canBeListNode) {
                skipped += 1;
                continue;
            }
            var _b = searchResult, indent = _b[1], start = _b[3];
            // basis on one depth list
            if (!indent) {
                firstOrderedListNum = Number(start);
                firstOrderedListLine = i;
                break;
            }
        }
        var ordinalNum = firstOrderedListNum + line - firstOrderedListLine - skipped;
        var changedResults = [{ text: ordinalNum + ". " + lineText, line: line }];
        return { changedResults: changedResults };
    },
    task: function (_a) {
        var doc = _a.doc, line = _a.line;
        var lineText = getTextByMdLine(doc, line);
        var changedResults = [{ text: "* [ ] " + lineText, line: line }];
        return { changedResults: changedResults };
    },
};
var extendList = {
    bullet: function (_a) {
        var line = _a.line, doc = _a.doc;
        var lineText = getTextByMdLine(doc, line);
        var _b = reBulletListGroup.exec(lineText), indent = _b[1], delimiter = _b[2];
        return { listSyntax: "" + indent + delimiter };
    },
    ordered: function (_a) {
        var toastMark = _a.toastMark, line = _a.line, mdNode = _a.mdNode, doc = _a.doc;
        var depth = getListDepth(mdNode);
        var lineText = getTextByMdLine(doc, line);
        var _b = reOrderedListGroup.exec(lineText), indent = _b[1], start = _b[3], delimiter = _b[4];
        var ordinalNum = Number(start) + 1;
        var listSyntax = "" + indent + ordinalNum + delimiter;
        var backwardList = findSameDepthList(toastMark, line, depth, true);
        var filteredList = backwardList.filter(function (info) {
            var searchResult = reOrderedListGroup.exec(getTextByMdLine(doc, info.line));
            return (searchResult &&
                searchResult[1].length === indent.length &&
                !!findClosestNode(info.mdNode, function (targetNode) { return isOrderedListNode(targetNode); }));
        });
        return __assign({ listSyntax: listSyntax }, getChangedInfo(doc, filteredList, 'ordered', ordinalNum));
    },
};
function getReorderedListInfo(doc, schema, line, ordinalNum, prevIndentLength) {
    var nodes = [];
    var lineText = getTextByMdLine(doc, line);
    var searchResult = reOrderedListGroup.exec(lineText);
    while (searchResult) {
        var indent = searchResult[1], delimiter = searchResult[4], text = searchResult[5];
        var indentLength = indent.length;
        if (indentLength === prevIndentLength) {
            nodes.push(createTextNode(schema, "" + indent + ordinalNum + delimiter + text));
            ordinalNum += 1;
            line += 1;
        }
        else if (indentLength > prevIndentLength) {
            var nestedListInfo = getReorderedListInfo(doc, schema, line, 1, indentLength);
            line = nestedListInfo.line;
            nodes = nodes.concat(nestedListInfo.nodes);
        }
        if (indentLength < prevIndentLength || line > doc.childCount) {
            break;
        }
        lineText = getTextByMdLine(doc, line);
        searchResult = reOrderedListGroup.exec(lineText);
    }
    return { nodes: nodes, line: line };
}

;// CONCATENATED MODULE: ./src/markdown/nodes/paragraph.ts










var reStartSpace = /(^\s{1,4})(.*)/;
function isBlockUnit(from, to, text) {
    return from < to || reList.test(text) || reBlockQuote.test(text);
}
function isInTableCellNode(doc, schema, selection) {
    var $pos = selection.$from;
    if ($pos.depth === 0) {
        $pos = doc.resolve($pos.pos - 1);
    }
    var node = $pos.node(1);
    var startOffset = $pos.start(1);
    var contentSize = node.content.size;
    return (node.rangeHasMark(0, contentSize, schema.marks.table) &&
        $pos.pos - startOffset !== contentSize &&
        $pos.pos !== startOffset);
}
function createSelection(tr, posInfo) {
    var from = posInfo.from, to = posInfo.to;
    if (posInfo.type === 'indent') {
        var softTabLen = 4;
        from += softTabLen;
        to += (posInfo.lineLen + 1) * softTabLen;
    }
    else {
        var spaceLenList = posInfo.spaceLenList;
        from -= spaceLenList[0];
        for (var i = 0; i < spaceLenList.length; i += 1) {
            to -= spaceLenList[i];
        }
    }
    return createTextSelection(tr, from, to);
}
var Paragraph = /** @class */ (function (_super) {
    __extends(Paragraph, _super);
    function Paragraph() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Paragraph.prototype, "name", {
        get: function () {
            return 'paragraph';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Paragraph.prototype, "schema", {
        get: function () {
            return {
                content: 'inline*',
                attrs: {
                    className: { default: null },
                    codeStart: { default: null },
                    codeEnd: { default: null },
                },
                selectable: false,
                group: 'block',
                parseDOM: [{ tag: 'div' }],
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    return attrs.className
                        ? ['div', { class: clsWithMdPrefix(attrs.className) }, 0]
                        : ['div', 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    Paragraph.prototype.reorderList = function (startLine, endLine) {
        var _a = this.context, view = _a.view, toastMark = _a.toastMark, schema = _a.schema;
        var _b = view.state, tr = _b.tr, selection = _b.selection, doc = _b.doc;
        var mdNode = toastMark.findFirstNodeAtLine(startLine);
        var topListNode = mdNode;
        while (mdNode && !isBulletListNode(mdNode) && mdNode.parent.type !== 'document') {
            mdNode = mdNode.parent;
            if (isOrderedListNode(mdNode)) {
                topListNode = mdNode;
                break;
            }
        }
        if (topListNode) {
            startLine = topListNode.sourcepos[0][0];
        }
        var _c = reOrderedListGroup.exec(getTextByMdLine(doc, startLine)), indent = _c[1], start = _c[3];
        var indentLen = indent.length;
        var _d = getReorderedListInfo(doc, schema, startLine, Number(start), indentLen), line = _d.line, nodes = _d.nodes;
        endLine = Math.max(endLine, line - 1);
        var startOffset = getNodeContentOffsetRange(doc, startLine - 1).startOffset;
        for (var i = startLine - 1; i <= endLine - 1; i += 1) {
            var _e = doc.child(i), nodeSize = _e.nodeSize, content = _e.content;
            var mappedFrom = tr.mapping.map(startOffset);
            var mappedTo = mappedFrom + content.size;
            tr.replaceWith(mappedFrom, mappedTo, nodes[i - startLine + 1]);
            startOffset += nodeSize;
        }
        var newSelection = createTextSelection(tr, selection.from, selection.to);
        view.dispatch(tr.setSelection(newSelection));
    };
    Paragraph.prototype.indent = function (tabKey) {
        var _this = this;
        if (tabKey === void 0) { tabKey = false; }
        return function () { return function (state, dispatch) {
            var schema = state.schema, selection = state.selection, doc = state.doc;
            var _a = getRangeInfo(selection), from = _a.from, to = _a.to, startFromOffset = _a.startFromOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;
            if (tabKey && isInTableCellNode(doc, schema, selection)) {
                return false;
            }
            var startLineText = getTextContent(doc, startIndex);
            if ((tabKey && isBlockUnit(from, to, startLineText)) ||
                (!tabKey && reList.test(startLineText))) {
                var tr = replaceTextNode({
                    state: state,
                    from: startFromOffset,
                    startIndex: startIndex,
                    endIndex: endIndex,
                    createText: function (textContent) { return "    " + textContent; },
                });
                var posInfo = {
                    type: 'indent',
                    from: from,
                    to: to,
                    lineLen: endIndex - startIndex,
                };
                dispatch(tr.setSelection(createSelection(tr, posInfo)));
                if (reOrderedListGroup.test(startLineText)) {
                    _this.reorderList(startIndex + 1, endIndex + 1);
                }
            }
            else if (tabKey) {
                dispatch(state.tr.insert(to, createTextNode(schema, '    ')));
            }
            return true;
        }; };
    };
    Paragraph.prototype.outdent = function (tabKey) {
        var _this = this;
        if (tabKey === void 0) { tabKey = false; }
        return function () { return function (state, dispatch) {
            var selection = state.selection, doc = state.doc, schema = state.schema;
            var _a = getRangeInfo(selection), from = _a.from, to = _a.to, startFromOffset = _a.startFromOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;
            if (tabKey && isInTableCellNode(doc, schema, selection)) {
                return false;
            }
            var startLineText = getTextContent(doc, startIndex);
            if ((tabKey && isBlockUnit(from, to, startLineText)) ||
                (!tabKey && reList.test(startLineText))) {
                var spaceLenList_1 = [];
                var tr = replaceTextNode({
                    state: state,
                    from: startFromOffset,
                    startIndex: startIndex,
                    endIndex: endIndex,
                    createText: function (textContent) {
                        var searchResult = reStartSpace.exec(textContent);
                        spaceLenList_1.push(searchResult ? searchResult[1].length : 0);
                        return textContent.replace(reStartSpace, '$2');
                    },
                });
                var posInfo = { type: 'outdent', from: from, to: to, spaceLenList: spaceLenList_1 };
                dispatch(tr.setSelection(createSelection(tr, posInfo)));
                if (reOrderedListGroup.test(startLineText)) {
                    _this.reorderList(startIndex + 1, endIndex + 1);
                }
            }
            else if (tabKey) {
                var startText = startLineText.slice(0, to - startFromOffset);
                var startTextWithoutSpace = startText.replace(/\s{1,4}$/, '');
                var deletStart = to - (startText.length - startTextWithoutSpace.length);
                dispatch(state.tr.delete(deletStart, to));
            }
            return true;
        }; };
    };
    Paragraph.prototype.deleteLines = function () {
        var _this = this;
        return function (state, dispatch) {
            var view = _this.context.view;
            var _a = getRangeInfo(state.selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset;
            var deleteRange = function () {
                dispatch(state.tr.deleteRange(startFromOffset, endToOffset));
                return true;
            };
            return (0,external_commonjs_prosemirror_commands_commonjs2_prosemirror_commands_amd_prosemirror_commands_.chainCommands)(deleteRange, external_commonjs_prosemirror_commands_commonjs2_prosemirror_commands_amd_prosemirror_commands_.joinForward)(state, dispatch, view);
        };
    };
    Paragraph.prototype.moveDown = function () {
        return function (state, dispatch) {
            var doc = state.doc, tr = state.tr, selection = state.selection, schema = state.schema;
            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, endIndex = _a.endIndex;
            if (endIndex < doc.content.childCount - 1) {
                var _b = doc.child(endIndex + 1), nodeSize = _b.nodeSize, textContent = _b.textContent;
                tr.delete(endToOffset, endToOffset + nodeSize)
                    .split(startFromOffset)
                    // subtract 2(start, end tag length) to insert prev line
                    .insert(tr.mapping.map(startFromOffset) - 2, createTextNode(schema, textContent));
                dispatch(tr);
                return true;
            }
            return false;
        };
    };
    Paragraph.prototype.moveUp = function () {
        return function (state, dispatch) {
            var tr = state.tr, doc = state.doc, selection = state.selection, schema = state.schema;
            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, startIndex = _a.startIndex;
            if (startIndex > 0) {
                var _b = doc.child(startIndex - 1), nodeSize = _b.nodeSize, textContent = _b.textContent;
                tr.delete(startFromOffset - nodeSize, startFromOffset)
                    .split(tr.mapping.map(endToOffset))
                    .insert(tr.mapping.map(endToOffset), createTextNode(schema, textContent));
                dispatch(tr);
                return true;
            }
            return false;
        };
    };
    Paragraph.prototype.commands = function () {
        return {
            indent: this.indent(),
            outdent: this.outdent(),
        };
    };
    Paragraph.prototype.keymaps = function () {
        return {
            Tab: this.indent(true)(),
            'Shift-Tab': this.outdent(true)(),
            'Mod-d': this.deleteLines(),
            'Mod-D': this.deleteLines(),
            'Alt-ArrowUp': this.moveUp(),
            'Alt-ArrowDown': this.moveDown(),
        };
    };
    return Paragraph;
}(node));


;// CONCATENATED MODULE: ./src/markdown/nodes/text.ts


var Text = /** @class */ (function (_super) {
    __extends(Text, _super);
    function Text() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Text.prototype, "name", {
        get: function () {
            return 'text';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Text.prototype, "schema", {
        get: function () {
            return {
                group: 'inline',
            };
        },
        enumerable: false,
        configurable: true
    });
    return Text;
}(node));


;// CONCATENATED MODULE: ./src/markdown/marks/heading.ts





var reHeading = /^#{1,6}\s/;
var Heading = /** @class */ (function (_super) {
    __extends(Heading, _super);
    function Heading() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Heading.prototype, "name", {
        get: function () {
            return 'heading';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Heading.prototype, "schema", {
        get: function () {
            return {
                attrs: {
                    level: { default: 1 },
                    seText: { default: false },
                },
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    var level = attrs.level, seText = attrs.seText;
                    var classNames = "heading|heading" + level;
                    if (seText) {
                        classNames += '|delimiter|setext';
                    }
                    return ['span', { class: clsWithMdPrefix.apply(void 0, classNames.split('|')) }, 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    Heading.prototype.createHeadingText = function (level, text, curHeadingSyntax) {
        var textContent = text.replace(curHeadingSyntax, '').trim();
        var headingText = '';
        while (level > 0) {
            headingText += '#';
            level -= 1;
        }
        return headingText + " " + textContent;
    };
    Heading.prototype.commands = function () {
        var _this = this;
        return function (payload) { return function (state, dispatch) {
            var level = payload.level;
            var _a = getRangeInfo(state.selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset, startIndex = _a.startIndex, endIndex = _a.endIndex;
            var tr = replaceTextNode({
                state: state,
                from: startFromOffset,
                startIndex: startIndex,
                endIndex: endIndex,
                createText: function (textContent) {
                    var matchedHeading = textContent.match(reHeading);
                    var curHeadingSyntax = matchedHeading ? matchedHeading[0] : '';
                    return _this.createHeadingText(level, textContent, curHeadingSyntax);
                },
            });
            dispatch(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset))));
            return true;
        }; };
    };
    return Heading;
}(mark));


;// CONCATENATED MODULE: ./src/markdown/marks/codeBlock.ts







var fencedCodeBlockSyntax = '```';
var CodeBlock = /** @class */ (function (_super) {
    __extends(CodeBlock, _super);
    function CodeBlock() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(CodeBlock.prototype, "name", {
        get: function () {
            return 'codeBlock';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CodeBlock.prototype, "schema", {
        get: function () {
            return {
                toDOM: function () {
                    return ['span', { class: clsWithMdPrefix('code-block') }, 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    CodeBlock.prototype.commands = function () {
        return function () { return function (state, dispatch) {
            var selection = state.selection, schema = state.schema, tr = state.tr;
            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset;
            var fencedNode = createTextNode(schema, fencedCodeBlockSyntax);
            // add fenced start block
            tr.insert(startFromOffset, fencedNode).split(startFromOffset + fencedCodeBlockSyntax.length);
            // add fenced end block
            tr.split(tr.mapping.map(endToOffset)).insert(tr.mapping.map(endToOffset), fencedNode);
            dispatch(tr.setSelection(
            // subtract fenced syntax length and open, close tag(2)
            createTextSelection(tr, tr.mapping.map(endToOffset) - (fencedCodeBlockSyntax.length + 2))));
            return true;
        }; };
    };
    CodeBlock.prototype.keepIndentation = function () {
        var _this = this;
        return function (_a, dispatch) {
            var selection = _a.selection, tr = _a.tr, doc = _a.doc, schema = _a.schema;
            var toastMark = _this.context.toastMark;
            var _b = getRangeInfo(selection), startFromOffset = _b.startFromOffset, endToOffset = _b.endToOffset, endIndex = _b.endIndex, from = _b.from, to = _b.to;
            var textContent = getTextContent(doc, endIndex);
            if (from === to && textContent.trim()) {
                var matched = textContent.match(/^\s+/);
                var mdNode = toastMark.findFirstNodeAtLine(endIndex + 1);
                if (isCodeBlockNode(mdNode) && matched) {
                    var spaces = matched[0];
                    var slicedText = textContent.slice(to - startFromOffset);
                    var node = createTextNode(schema, spaces + slicedText);
                    splitAndExtendBlock(tr, endToOffset, slicedText, node);
                    dispatch(tr);
                    return true;
                }
            }
            return false;
        };
    };
    CodeBlock.prototype.keymaps = function () {
        var codeBlockCommand = this.commands()();
        return {
            'Shift-Mod-p': codeBlockCommand,
            'Shift-Mod-P': codeBlockCommand,
            Enter: this.keepIndentation(),
        };
    };
    return CodeBlock;
}(mark));


;// CONCATENATED MODULE: ./src/markdown/marks/table.ts







var reEmptyTable = /\||\s/g;
function createTableHeader(columnCount) {
    return [createTableRow(columnCount), createTableRow(columnCount, true)];
}
function createTableBody(columnCount, rowCount) {
    var bodyRows = [];
    for (var i = 0; i < rowCount; i += 1) {
        bodyRows.push(createTableRow(columnCount));
    }
    return bodyRows;
}
function createTableRow(columnCount, delim) {
    var row = '|';
    for (var i = 0; i < columnCount; i += 1) {
        row += delim ? ' --- |' : '  |';
    }
    return row;
}
function createTargetTypes(moveNext) {
    return moveNext
        ? { type: 'next', parentType: 'tableHead', childType: 'firstChild' }
        : { type: 'prev', parentType: 'tableBody', childType: 'lastChild' };
}
var Table = /** @class */ (function (_super) {
    __extends(Table, _super);
    function Table() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Table.prototype, "name", {
        get: function () {
            return 'table';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Table.prototype, "schema", {
        get: function () {
            return {
                toDOM: function () {
                    return ['span', { class: clsWithMdPrefix('table') }, 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    Table.prototype.extendTable = function () {
        var _this = this;
        return function (_a, dispatch) {
            var selection = _a.selection, doc = _a.doc, tr = _a.tr, schema = _a.schema;
            if (!selection.empty) {
                return false;
            }
            var _b = getRangeInfo(selection), endFromOffset = _b.endFromOffset, endToOffset = _b.endToOffset, endIndex = _b.endIndex, to = _b.to;
            var textContent = getTextContent(doc, endIndex);
            // should add `1` to line for the markdown parser
            // because markdown parser has `1`(not zero) as the start number
            var mdPos = [endIndex + 1, to - endFromOffset + 1];
            var mdNode = _this.context.toastMark.findNodeAtPosition(mdPos);
            var cellNode = findClosestNode(mdNode, function (node) {
                return isTableCellNode(node) &&
                    (node.parent.type === 'tableDelimRow' || node.parent.parent.type === 'tableBody');
            });
            if (cellNode) {
                var isEmpty = !textContent.replace(reEmptyTable, '').trim();
                var parent = cellNode.parent;
                var columnCount = parent.parent.parent.columns.length;
                var row = createTableRow(columnCount);
                if (isEmpty) {
                    tr.deleteRange(endFromOffset, endToOffset).split(tr.mapping.map(endToOffset));
                }
                else {
                    tr
                        .split(endToOffset)
                        .insert(tr.mapping.map(endToOffset), createTextNode(schema, row))
                        // should subtract `2` to selection end position considering ` |` text
                        .setSelection(createTextSelection(tr, tr.mapping.map(endToOffset) - 2));
                }
                dispatch(tr);
                return true;
            }
            return false;
        };
    };
    Table.prototype.moveTableCell = function (moveNext) {
        var _this = this;
        return function (_a, dispatch) {
            var selection = _a.selection, tr = _a.tr;
            var _b = getRangeInfo(selection), endFromOffset = _b.endFromOffset, endIndex = _b.endIndex, to = _b.to;
            var mdPos = [endIndex + 1, to - endFromOffset];
            var mdNode = _this.context.toastMark.findNodeAtPosition(mdPos);
            var cellNode = findClosestNode(mdNode, function (node) { return isTableCellNode(node); });
            if (cellNode) {
                var parent = cellNode.parent;
                var _c = createTargetTypes(moveNext), type = _c.type, parentType = _c.parentType, childType = _c.childType;
                var chOffset = getMdEndCh(cellNode);
                if (cellNode[type]) {
                    chOffset = getMdEndCh(cellNode[type]) - 1;
                }
                else {
                    var row = !parent[type] && parent.parent.type === parentType
                        ? parent.parent[type][childType]
                        : parent[type];
                    if (type === 'next') {
                        // if there is next row, the base offset would be end position of the next row's first child.
                        // Otherwise, the base offset is zero.
                        var baseOffset = row ? getMdEndCh(row[childType]) : 0;
                        // calculate tag(open, close) position('2') for selection
                        chOffset += baseOffset + 2;
                    }
                    else if (type === 'prev') {
                        // if there is prev row, the target position would be '-4' for calculating ' |' characters and tag(open, close)
                        // Otherwise, the target position is zero.
                        chOffset = row ? -4 : 0;
                    }
                }
                dispatch(tr.setSelection(createTextSelection(tr, endFromOffset + chOffset)));
                return true;
            }
            return false;
        };
    };
    Table.prototype.addTable = function () {
        return function (payload) { return function (_a, dispatch) {
            var selection = _a.selection, tr = _a.tr, schema = _a.schema;
            var _b = payload, columnCount = _b.columnCount, rowCount = _b.rowCount;
            var endToOffset = getRangeInfo(selection).endToOffset;
            var headerRows = createTableHeader(columnCount);
            var bodyRows = createTableBody(columnCount, rowCount - 1);
            var rows = __spreadArray(__spreadArray([], headerRows), bodyRows);
            rows.forEach(function (row) {
                tr.split(tr.mapping.map(endToOffset)).insert(tr.mapping.map(endToOffset), createTextNode(schema, row));
            });
            // should add `4` to selection position considering `| ` text and start block tag length
            dispatch(tr.setSelection(createTextSelection(tr, endToOffset + 4)));
            return true;
        }; };
    };
    Table.prototype.commands = function () {
        return { addTable: this.addTable() };
    };
    Table.prototype.keymaps = function () {
        return {
            Enter: this.extendTable(),
            Tab: this.moveTableCell(true),
            'Shift-Tab': this.moveTableCell(false),
        };
    };
    return Table;
}(mark));


;// CONCATENATED MODULE: ./src/markdown/marks/thematicBreak.ts





var thematicBreakSyntax = '***';
var ThematicBreak = /** @class */ (function (_super) {
    __extends(ThematicBreak, _super);
    function ThematicBreak() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ThematicBreak.prototype, "name", {
        get: function () {
            return 'thematicBreak';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ThematicBreak.prototype, "schema", {
        get: function () {
            return {
                toDOM: function () {
                    return ['span', { class: clsWithMdPrefix('thematic-break') }, 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    ThematicBreak.prototype.hr = function () {
        return function () { return function (state, dispatch) {
            var selection = state.selection, schema = state.schema, tr = state.tr;
            var _a = getRangeInfo(selection), from = _a.from, to = _a.to, endToOffset = _a.endToOffset;
            var node = createTextNode(schema, thematicBreakSyntax);
            tr
                .split(from)
                .replaceWith(tr.mapping.map(from), tr.mapping.map(to), node)
                .split(tr.mapping.map(to)).setSelection(createTextSelection(tr, tr.mapping.map(endToOffset)));
            dispatch(tr);
            return true;
        }; };
    };
    ThematicBreak.prototype.commands = function () {
        return { hr: this.hr() };
    };
    ThematicBreak.prototype.keymaps = function () {
        var lineCommand = this.hr()();
        return { 'Mod-l': lineCommand, 'Mod-L': lineCommand };
    };
    return ThematicBreak;
}(mark));


;// CONCATENATED MODULE: ./src/markdown/marks/listItem.ts









function cannotBeListNode(_a, line) {
    var type = _a.type, sourcepos = _a.sourcepos;
    // eslint-disable-next-line prefer-destructuring
    var startLine = sourcepos[0][0];
    return line <= startLine && (type === 'codeBlock' || type === 'heading' || type.match('table'));
}
var ListItem = /** @class */ (function (_super) {
    __extends(ListItem, _super);
    function ListItem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ListItem.prototype, "name", {
        get: function () {
            return 'listItem';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ListItem.prototype, "schema", {
        get: function () {
            return {
                attrs: {
                    odd: { default: false },
                    even: { default: false },
                    listStyle: { default: false },
                },
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    var odd = attrs.odd, even = attrs.even, listStyle = attrs.listStyle;
                    var classNames = 'list-item';
                    if (listStyle) {
                        classNames += '|list-item-style';
                    }
                    if (odd) {
                        classNames += '|list-item-odd';
                    }
                    if (even) {
                        classNames += '|list-item-even';
                    }
                    return ['span', { class: clsWithMdPrefix.apply(void 0, classNames.split('|')) }, 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    ListItem.prototype.extendList = function () {
        var _this = this;
        return function (_a, dispatch) {
            var selection = _a.selection, doc = _a.doc, schema = _a.schema, tr = _a.tr;
            var toastMark = _this.context.toastMark;
            var _b = getRangeInfo(selection), to = _b.to, startFromOffset = _b.startFromOffset, endFromOffset = _b.endFromOffset, endIndex = _b.endIndex, endToOffset = _b.endToOffset;
            var textContent = getTextContent(doc, endIndex);
            var isList = reList.test(textContent);
            if (!isList || selection.from === startFromOffset || !selection.empty) {
                return false;
            }
            var isEmpty = !textContent.replace(reCanBeTaskList, '').trim();
            if (isEmpty) {
                tr.deleteRange(endFromOffset, endToOffset).split(tr.mapping.map(endToOffset));
            }
            else {
                var commandType = getListType(textContent);
                // should add `1` to line for the markdown parser
                // because markdown parser has `1`(not zero) as the start number
                var mdNode = toastMark.findFirstNodeAtLine(endIndex + 1);
                var slicedText = textContent.slice(to - endFromOffset);
                var context = { toastMark: toastMark, mdNode: mdNode, doc: doc, line: endIndex + 1 };
                var _c = extendList[commandType](context), listSyntax = _c.listSyntax, changedResults = _c.changedResults;
                // change ordinal number of backward ordered list
                if (changedResults === null || changedResults === void 0 ? void 0 : changedResults.length) {
                    // split the block
                    tr.split(to);
                    // set first ordered list info
                    changedResults.unshift({ text: listSyntax + slicedText, line: endIndex + 1 });
                    _this.changeToListPerLine(tr, changedResults, {
                        from: to,
                        // don't subtract 1 because the line has increased through 'split' command.
                        startLine: changedResults[0].line,
                        endLine: last(changedResults).line,
                    });
                    var pos = tr.mapping.map(endToOffset) - slicedText.length;
                    tr.setSelection(createTextSelection(tr, pos));
                }
                else {
                    var node = createTextNode(schema, listSyntax + slicedText);
                    splitAndExtendBlock(tr, endToOffset, slicedText, node);
                }
            }
            dispatch(tr);
            return true;
        };
    };
    ListItem.prototype.toList = function (commandType) {
        var _this = this;
        return function () { return function (_a, dispatch) {
            var doc = _a.doc, tr = _a.tr, selection = _a.selection;
            var toastMark = _this.context.toastMark;
            var rangeInfo = getRangeInfo(selection);
            // should add `1` to line for the markdown parser
            // because markdown parser has `1`(not zero) as the start number
            var startLine = rangeInfo.startIndex + 1;
            var endLine = rangeInfo.endIndex + 1;
            var endToOffset = rangeInfo.endToOffset;
            var skipLines = [];
            for (var line = startLine; line <= endLine; line += 1) {
                var mdNode = toastMark.findFirstNodeAtLine(line);
                if (mdNode && cannotBeListNode(mdNode, line)) {
                    break;
                }
                // to skip unnecessary processing
                if (skipLines.indexOf(line) !== -1) {
                    continue;
                }
                var context = { toastMark: toastMark, mdNode: mdNode, doc: doc, line: line, startLine: startLine };
                var changedResults = (isListNode(mdNode)
                    ? otherListToList[commandType](context)
                    : otherNodeToList[commandType](context)).changedResults;
                var endOffset = _this.changeToListPerLine(tr, changedResults, {
                    from: getNodeContentOffsetRange(doc, changedResults[0].line - 1).startOffset,
                    startLine: changedResults[0].line,
                    endLine: last(changedResults).line,
                    indexDiff: 1,
                });
                endToOffset = Math.max(endOffset, endToOffset);
                if (changedResults) {
                    skipLines = skipLines.concat(changedResults.map(function (info) { return info.line; }));
                }
            }
            dispatch(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset))));
            return true;
        }; };
    };
    ListItem.prototype.changeToListPerLine = function (tr, changedResults, _a) {
        var from = _a.from, startLine = _a.startLine, endLine = _a.endLine, _b = _a.indexDiff, indexDiff = _b === void 0 ? 0 : _b;
        var maxEndOffset = 0;
        var _loop_1 = function (i) {
            var _c = tr.doc.child(i), nodeSize = _c.nodeSize, content = _c.content;
            var mappedFrom = tr.mapping.map(from);
            var mappedTo = mappedFrom + content.size;
            var changedResult = changedResults.filter(function (result) { return result.line - indexDiff === i; })[0];
            if (changedResult) {
                tr.replaceWith(mappedFrom, mappedTo, createTextNode(this_1.context.schema, changedResult.text));
                maxEndOffset = Math.max(maxEndOffset, from + content.size);
            }
            from += nodeSize;
        };
        var this_1 = this;
        for (var i = startLine - indexDiff; i <= endLine - indexDiff; i += 1) {
            _loop_1(i);
        }
        return maxEndOffset;
    };
    ListItem.prototype.toggleTask = function () {
        var _this = this;
        return function (_a, dispatch) {
            var selection = _a.selection, tr = _a.tr, doc = _a.doc, schema = _a.schema;
            var toastMark = _this.context.toastMark;
            var _b = getRangeInfo(selection), startIndex = _b.startIndex, endIndex = _b.endIndex;
            var newTr = null;
            for (var i = startIndex; i <= endIndex; i += 1) {
                var mdNode = toastMark.findFirstNodeAtLine(i + 1);
                if (isListNode(mdNode) && mdNode.listData.task) {
                    var _c = mdNode.listData, checked = _c.checked, padding = _c.padding;
                    var stateChar = checked ? ' ' : 'x';
                    var mdPos = mdNode.sourcepos[0];
                    var startOffset = getNodeContentOffsetRange(doc, mdPos[0] - 1).startOffset;
                    startOffset += mdPos[1] + padding;
                    newTr = tr.replaceWith(startOffset, startOffset + 1, schema.text(stateChar));
                }
            }
            if (newTr) {
                dispatch(newTr);
                return true;
            }
            return false;
        };
    };
    ListItem.prototype.commands = function () {
        return {
            bulletList: this.toList('bullet'),
            orderedList: this.toList('ordered'),
            taskList: this.toList('task'),
        };
    };
    ListItem.prototype.keymaps = function () {
        var bulletCommand = this.toList('bullet')();
        var orderedCommand = this.toList('ordered')();
        var taskCommand = this.toList('task')();
        var togleTaskCommand = this.toggleTask();
        return {
            'Mod-u': bulletCommand,
            'Mod-U': bulletCommand,
            'Mod-o': orderedCommand,
            'Mod-O': orderedCommand,
            'alt-t': taskCommand,
            'alt-T': taskCommand,
            'Shift-Ctrl-x': togleTaskCommand,
            'Shift-Ctrl-X': togleTaskCommand,
            Enter: this.extendList(),
        };
    };
    return ListItem;
}(mark));


;// CONCATENATED MODULE: ./src/markdown/helper/mdCommand.ts



function toggleMark(condition, syntax) {
    return function () { return function (_a, dispatch) {
        var tr = _a.tr, selection = _a.selection;
        var conditionFn = !isFunction_default()(condition)
            ? function (text) { return condition.test(text); }
            : condition;
        var syntaxLen = syntax.length;
        var doc = tr.doc;
        var _b = resolveSelectionPos(selection), from = _b[0], to = _b[1];
        var prevPos = Math.max(from - syntaxLen, 1);
        var nextPos = Math.min(to + syntaxLen, doc.content.size - 1);
        var slice = selection.content();
        var textContent = slice.content.textBetween(0, slice.content.size, '\n');
        var prevText = doc.textBetween(prevPos, from, '\n');
        var nextText = doc.textBetween(to, nextPos, '\n');
        textContent = "" + prevText + textContent + nextText;
        if (prevText && nextText && conditionFn(textContent)) {
            tr.delete(nextPos - syntaxLen, nextPos).delete(prevPos, prevPos + syntaxLen);
        }
        else {
            tr.insertText(syntax, to).insertText(syntax, from);
            var newSelection = selection.empty
                ? createTextSelection(tr, from + syntaxLen)
                : createTextSelection(tr, from + syntaxLen, to + syntaxLen);
            tr.setSelection(newSelection);
        }
        dispatch(tr);
        return true;
    }; };
}

;// CONCATENATED MODULE: ./src/markdown/marks/strong.ts




var reStrong = /^(\*{2}|_{2}).*([\s\S]*)\1$/m;
var strongSyntax = '**';
var Strong = /** @class */ (function (_super) {
    __extends(Strong, _super);
    function Strong() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Strong.prototype, "name", {
        get: function () {
            return 'strong';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Strong.prototype, "schema", {
        get: function () {
            return {
                toDOM: function () {
                    return ['span', { class: clsWithMdPrefix('strong') }, 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    Strong.prototype.bold = function () {
        return toggleMark(reStrong, strongSyntax);
    };
    Strong.prototype.commands = function () {
        return { bold: this.bold() };
    };
    Strong.prototype.keymaps = function () {
        var boldCommand = this.bold()();
        return { 'Mod-b': boldCommand, 'Mod-B': boldCommand };
    };
    return Strong;
}(mark));


;// CONCATENATED MODULE: ./src/markdown/marks/strike.ts




var reStrike = /^(~{2}).*([\s\S]*)\1$/m;
var strikeSyntax = '~~';
var Strike = /** @class */ (function (_super) {
    __extends(Strike, _super);
    function Strike() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Strike.prototype, "name", {
        get: function () {
            return 'strike';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Strike.prototype, "schema", {
        get: function () {
            return {
                toDOM: function () {
                    return ['span', { class: clsWithMdPrefix('strike') }, 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    Strike.prototype.commands = function () {
        return toggleMark(reStrike, strikeSyntax);
    };
    Strike.prototype.keymaps = function () {
        var strikeCommand = this.commands()();
        return { 'Mod-s': strikeCommand, 'Mod-S': strikeCommand };
    };
    return Strike;
}(mark));


;// CONCATENATED MODULE: ./src/markdown/marks/emph.ts




var reEmph = /^(\*|_).*([\s\S]*)\1$/m;
var emphSyntax = '*';
var Emph = /** @class */ (function (_super) {
    __extends(Emph, _super);
    function Emph() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Emph.prototype, "name", {
        get: function () {
            return 'emph';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Emph.prototype, "schema", {
        get: function () {
            return {
                toDOM: function () {
                    return ['span', { class: clsWithMdPrefix('emph') }, 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    Emph.prototype.italic = function () {
        return toggleMark(reEmph, emphSyntax);
    };
    Emph.prototype.commands = function () {
        return { italic: this.italic() };
    };
    Emph.prototype.keymaps = function () {
        var italicCommand = this.italic()();
        return { 'Mod-i': italicCommand, 'Mod-I': italicCommand };
    };
    return Emph;
}(mark));


;// CONCATENATED MODULE: ./src/markdown/marks/code.ts




var reCode = /^(`).*([\s\S]*)\1$/m;
var codeSyntax = '`';
var Code = /** @class */ (function (_super) {
    __extends(Code, _super);
    function Code() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Code.prototype, "name", {
        get: function () {
            return 'code';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Code.prototype, "schema", {
        get: function () {
            return {
                attrs: {
                    start: { default: false },
                    end: { default: false },
                    marked: { default: false },
                },
                toDOM: function (mark) {
                    var _a = mark.attrs, start = _a.start, end = _a.end, marked = _a.marked;
                    var classNames = 'code';
                    if (start) {
                        classNames += '|delimiter|start';
                    }
                    if (end) {
                        classNames += '|delimiter|end';
                    }
                    if (marked) {
                        classNames += '|marked-text';
                    }
                    return ['span', { class: clsWithMdPrefix.apply(void 0, classNames.split('|')) }, 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    Code.prototype.commands = function () {
        return toggleMark(reCode, codeSyntax);
    };
    Code.prototype.keymaps = function () {
        var codeCommand = this.commands()();
        return { 'Shift-Mod-c': codeCommand, 'Shift-Mod-C': codeCommand };
    };
    return Code;
}(mark));


;// CONCATENATED MODULE: ./src/markdown/marks/link.ts






var Link = /** @class */ (function (_super) {
    __extends(Link, _super);
    function Link() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Link.prototype, "name", {
        get: function () {
            return 'link';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Link.prototype, "schema", {
        get: function () {
            return {
                attrs: {
                    url: { default: false },
                    desc: { default: false },
                },
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    var url = attrs.url, desc = attrs.desc;
                    var classNames = 'link';
                    if (url) {
                        classNames += '|link-url|marked-text';
                    }
                    if (desc) {
                        classNames += '|link-desc|marked-text';
                    }
                    return ['span', { class: clsWithMdPrefix.apply(void 0, classNames.split('|')) }, 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    Link.prototype.addLinkOrImage = function (commandType) {
        return function (payload) { return function (_a, dispatch) {
            var selection = _a.selection, tr = _a.tr, schema = _a.schema;
            var _b = resolveSelectionPos(selection), from = _b[0], to = _b[1];
            var _c = payload, linkText = _c.linkText, altText = _c.altText, linkUrl = _c.linkUrl, imageUrl = _c.imageUrl;
            var text = linkText;
            var url = linkUrl;
            var syntax = '';
            if (commandType === 'image') {
                text = altText;
                url = imageUrl;
                syntax = '!';
            }
            text = escapeTextForLink(text);
            syntax += "[" + text + "](" + url + ")";
            dispatch(tr.replaceWith(from, to, createTextNode(schema, syntax)));
            return true;
        }; };
    };
    Link.prototype.commands = function () {
        return {
            addImage: this.addLinkOrImage('image'),
            addLink: this.addLinkOrImage('link'),
        };
    };
    return Link;
}(mark));


;// CONCATENATED MODULE: ./src/markdown/marks/simpleMark.ts



var TaskDelimiter = /** @class */ (function (_super) {
    __extends(TaskDelimiter, _super);
    function TaskDelimiter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(TaskDelimiter.prototype, "name", {
        get: function () {
            return 'taskDelimiter';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TaskDelimiter.prototype, "schema", {
        get: function () {
            return {
                toDOM: function () {
                    return ['span', { class: clsWithMdPrefix('delimiter', 'list-item') }, 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    return TaskDelimiter;
}(mark));

var Delimiter = /** @class */ (function (_super) {
    __extends(Delimiter, _super);
    function Delimiter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Delimiter.prototype, "name", {
        get: function () {
            return 'delimiter';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Delimiter.prototype, "schema", {
        get: function () {
            return {
                toDOM: function () {
                    return ['span', { class: clsWithMdPrefix('delimiter') }, 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    return Delimiter;
}(mark));

var Meta = /** @class */ (function (_super) {
    __extends(Meta, _super);
    function Meta() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Meta.prototype, "name", {
        get: function () {
            return 'meta';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Meta.prototype, "schema", {
        get: function () {
            return {
                toDOM: function () {
                    return ['span', { class: clsWithMdPrefix('meta') }, 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    return Meta;
}(mark));

var MarkedText = /** @class */ (function (_super) {
    __extends(MarkedText, _super);
    function MarkedText() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(MarkedText.prototype, "name", {
        get: function () {
            return 'markedText';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MarkedText.prototype, "schema", {
        get: function () {
            return {
                toDOM: function () {
                    return ['span', { class: clsWithMdPrefix('marked-text') }, 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    return MarkedText;
}(mark));

var TableCell = /** @class */ (function (_super) {
    __extends(TableCell, _super);
    function TableCell() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(TableCell.prototype, "name", {
        get: function () {
            return 'tableCell';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TableCell.prototype, "schema", {
        get: function () {
            return {
                toDOM: function () {
                    return ['span', { class: clsWithMdPrefix('table-cell') }, 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    return TableCell;
}(mark));


;// CONCATENATED MODULE: ./src/markdown/marks/html.ts



var Html = /** @class */ (function (_super) {
    __extends(Html, _super);
    function Html() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Html.prototype, "name", {
        get: function () {
            return 'html';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Html.prototype, "schema", {
        get: function () {
            return {
                toDOM: function () {
                    return ['span', { class: clsWithMdPrefix('html') }, 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    return Html;
}(mark));


;// CONCATENATED MODULE: ./src/markdown/marks/customBlock.ts





var customBlockSyntax = '$$';
var CustomBlock = /** @class */ (function (_super) {
    __extends(CustomBlock, _super);
    function CustomBlock() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(CustomBlock.prototype, "name", {
        get: function () {
            return 'customBlock';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CustomBlock.prototype, "schema", {
        get: function () {
            return {
                toDOM: function () {
                    return ['span', { class: clsWithMdPrefix('custom-block') }, 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    CustomBlock.prototype.commands = function () {
        return function (payload) { return function (state, dispatch) {
            var selection = state.selection, schema = state.schema, tr = state.tr;
            var _a = getRangeInfo(selection), startFromOffset = _a.startFromOffset, endToOffset = _a.endToOffset;
            if (!(payload === null || payload === void 0 ? void 0 : payload.info)) {
                return false;
            }
            var customBlock = "" + customBlockSyntax + payload.info;
            var startNode = createTextNode(schema, customBlock);
            var endNode = createTextNode(schema, customBlockSyntax);
            tr.insert(startFromOffset, startNode).split(startFromOffset + customBlock.length);
            tr.split(tr.mapping.map(endToOffset)).insert(tr.mapping.map(endToOffset), endNode);
            dispatch(tr.setSelection(createTextSelection(tr, tr.mapping.map(endToOffset) - (customBlockSyntax.length + 2))));
            return true;
        }; };
    };
    return CustomBlock;
}(mark));


;// CONCATENATED MODULE: ./src/markdown/plugins/smartTask.ts



var reTaskMarkerKey = /x|backspace/i;
var reTaskMarker = /^\[(\s*)(x?)(\s*)\](?:\s+)/i;
function smartTask(_a) {
    var schema = _a.schema, toastMark = _a.toastMark;
    return new external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Plugin({
        props: {
            handleDOMEvents: {
                keyup: function (view, ev) {
                    var _a;
                    var _b = view.state, doc = _b.doc, tr = _b.tr, selection = _b.selection;
                    if (selection.empty && reTaskMarkerKey.test(ev.key)) {
                        var _c = getRangeInfo(selection), startIndex = _c.startIndex, startFromOffset = _c.startFromOffset, from = _c.from;
                        // should add `1` to line for the markdown parser
                        // because markdown parser has `1`(not zero) as the start number
                        var mdPos = [startIndex + 1, from - startFromOffset + 1];
                        var mdNode = toastMark.findNodeAtPosition(mdPos);
                        var paraNode = findClosestNode(mdNode, function (node) { var _a; return node.type === 'paragraph' && ((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === 'item'; });
                        if ((_a = paraNode === null || paraNode === void 0 ? void 0 : paraNode.firstChild) === null || _a === void 0 ? void 0 : _a.literal) {
                            var firstChild = paraNode.firstChild;
                            var matched = firstChild.literal.match(reTaskMarker);
                            if (matched) {
                                var startMdPos = firstChild.sourcepos[0];
                                var startSpaces = matched[1], stateChar = matched[2], lastSpaces = matched[3];
                                var spaces = startSpaces.length + lastSpaces.length;
                                var startOffset = getNodeContentOffsetRange(doc, startMdPos[0] - 1).startOffset;
                                var startPos = startMdPos[1] + startOffset;
                                if (stateChar) {
                                    var addedPos = spaces ? spaces + 1 : 0;
                                    tr.replaceWith(startPos, addedPos + startPos, schema.text(stateChar));
                                    view.dispatch(tr);
                                }
                                else if (!spaces) {
                                    tr.insertText(' ', startPos);
                                    view.dispatch(tr);
                                }
                            }
                        }
                    }
                    return false;
                },
            },
        },
    });
}

;// CONCATENATED MODULE: ./src/markdown/mdEditor.ts

































var EVENT_TYPE = 'cut';
var reLineEnding = /\r\n|\n|\r/;
var MdEditor = /** @class */ (function (_super) {
    __extends(MdEditor, _super);
    function MdEditor(eventEmitter, options) {
        var _this = _super.call(this, eventEmitter) || this;
        var toastMark = options.toastMark, _a = options.useCommandShortcut, useCommandShortcut = _a === void 0 ? true : _a, _b = options.mdPlugins, mdPlugins = _b === void 0 ? [] : _b;
        _this.editorType = 'markdown';
        _this.el.classList.add('md-mode');
        _this.toastMark = toastMark;
        _this.extraPlugins = mdPlugins;
        _this.specs = _this.createSpecs();
        _this.schema = _this.createSchema();
        _this.context = _this.createContext();
        _this.keymaps = _this.createKeymaps(useCommandShortcut);
        _this.view = _this.createView();
        _this.commands = _this.createCommands();
        _this.specs.setContext(__assign(__assign({}, _this.context), { view: _this.view }));
        _this.createClipboard();
        // To prevent unnecessary focus setting during initial rendering
        _this.eventEmitter.listen('changePreviewTabWrite', function (isMarkdownTabMounted) {
            return _this.toggleActive(true, isMarkdownTabMounted);
        });
        _this.eventEmitter.listen('changePreviewTabPreview', function () { return _this.toggleActive(false); });
        _this.initEvent();
        return _this;
    }
    MdEditor.prototype.toggleActive = function (active, isMarkdownTabMounted) {
        toggleClass(this.el, 'active', active);
        if (active) {
            if (!isMarkdownTabMounted) {
                this.focus();
            }
        }
        else {
            this.blur();
        }
    };
    MdEditor.prototype.createClipboard = function () {
        var _this = this;
        this.clipboard = document.createElement('textarea');
        this.clipboard.className = cls('pseudo-clipboard');
        this.clipboard.addEventListener('paste', function (ev) {
            var clipboardData = ev.clipboardData || window.clipboardData;
            var items = clipboardData && clipboardData.items;
            if (items) {
                var containRtfItem = toArray_default()(items).some(function (item) { return item.kind === 'string' && item.type === 'text/rtf'; });
                // if it contains rtf, it's most likely copy paste from office -> no image
                if (!containRtfItem) {
                    var imageBlob = pasteImageOnly(items);
                    if (imageBlob) {
                        ev.preventDefault();
                        emitImageBlobHook(_this.eventEmitter, imageBlob, ev.type);
                    }
                }
            }
        });
        // process the pasted data in input event for IE11
        this.clipboard.addEventListener('input', function (ev) {
            var text = ev.target.value;
            _this.replaceSelection(text);
            ev.preventDefault();
            ev.target.value = '';
        });
        this.el.insertBefore(this.clipboard, this.view.dom);
    };
    MdEditor.prototype.createContext = function () {
        return {
            toastMark: this.toastMark,
            schema: this.schema,
            eventEmitter: this.eventEmitter,
        };
    };
    MdEditor.prototype.createSpecs = function () {
        return new specManager([
            new Doc(),
            new Paragraph(),
            new Widget(),
            new Text(),
            new Heading(),
            new BlockQuote(),
            new CodeBlock(),
            new CustomBlock(),
            new Table(),
            new TableCell(),
            new ThematicBreak(),
            new ListItem(),
            new Strong(),
            new Strike(),
            new Emph(),
            new Code(),
            new Link(),
            new Delimiter(),
            new TaskDelimiter(),
            new MarkedText(),
            new Meta(),
            new Html(),
        ]);
    };
    MdEditor.prototype.createPlugins = function () {
        return __spreadArray([
            syntaxHighlight(this.context),
            previewHighlight(this.context),
            smartTask(this.context)
        ], this.createPluginProps()).concat(this.defaultPlugins);
    };
    MdEditor.prototype.createView = function () {
        var _this = this;
        return new external_commonjs_prosemirror_view_commonjs2_prosemirror_view_amd_prosemirror_view_.EditorView(this.el, {
            state: this.createState(),
            dispatchTransaction: function (tr) {
                _this.updateMarkdown(tr);
                var state = _this.view.state.applyTransaction(tr).state;
                _this.view.updateState(state);
                _this.emitChangeEvent(tr);
            },
            handleKeyDown: function (_, ev) {
                if ((ev.metaKey || ev.ctrlKey) && ev.key.toUpperCase() === 'V') {
                    _this.clipboard.focus();
                }
                _this.eventEmitter.emit('keydown', _this.editorType, ev);
                return false;
            },
            handleDOMEvents: {
                copy: function (_, ev) { return _this.captureCopy(ev); },
                cut: function (_, ev) { return _this.captureCopy(ev, EVENT_TYPE); },
                scroll: function () {
                    _this.eventEmitter.emit('scroll', 'editor');
                    return true;
                },
                keyup: function (_, ev) {
                    _this.eventEmitter.emit('keyup', _this.editorType, ev);
                    return false;
                },
            },
            nodeViews: {
                widget: widgetNodeView,
            },
        });
    };
    MdEditor.prototype.createCommands = function () {
        return this.specs.commands(this.view);
    };
    MdEditor.prototype.captureCopy = function (ev, type) {
        ev.preventDefault();
        var _a = this.view.state, selection = _a.selection, tr = _a.tr;
        if (selection.empty) {
            return true;
        }
        var text = this.getChanged(selection.content());
        if (ev.clipboardData) {
            ev.clipboardData.setData('text/plain', text);
        }
        else {
            window.clipboardData.setData('Text', text);
        }
        if (type === EVENT_TYPE) {
            this.view.dispatch(tr.deleteSelection().scrollIntoView().setMeta('uiEvent', EVENT_TYPE));
        }
        return true;
    };
    MdEditor.prototype.updateMarkdown = function (tr) {
        var _this = this;
        if (tr.docChanged) {
            tr.steps.forEach(function (step, index) {
                if (step.slice && !(step instanceof external_commonjs_prosemirror_transform_commonjs2_prosemirror_transform_amd_prosemirror_transform_.ReplaceAroundStep)) {
                    var doc = tr.docs[index];
                    var _a = [step.from, step.to], from = _a[0], to = _a[1];
                    var _b = getEditorToMdPos(doc, from, to), startPos = _b[0], endPos = _b[1];
                    var changed = _this.getChanged(step.slice);
                    if (startPos[0] === endPos[0] && startPos[1] === endPos[1] && changed === '') {
                        changed = '\n';
                    }
                    var editResult = _this.toastMark.editMarkdown(startPos, endPos, changed);
                    _this.eventEmitter.emit('updatePreview', editResult);
                    tr.setMeta('editResult', editResult).scrollIntoView();
                }
            });
        }
    };
    MdEditor.prototype.getChanged = function (slice) {
        var changed = '';
        var from = 0;
        var to = slice.content.size;
        slice.content.nodesBetween(from, to, function (node, pos) {
            if (node.isText) {
                changed += node.text.slice(Math.max(from, pos) - pos, to - pos);
            }
            else if (node.isBlock && pos > 0) {
                changed += '\n';
            }
        });
        return changed;
    };
    MdEditor.prototype.setSelection = function (start, end) {
        if (end === void 0) { end = start; }
        var tr = this.view.state.tr;
        var _a = getMdToEditorPos(tr.doc, start, end), from = _a[0], to = _a[1];
        this.view.dispatch(tr.setSelection(createTextSelection(tr, from, to)).scrollIntoView());
    };
    MdEditor.prototype.replaceSelection = function (text, start, end) {
        var newTr;
        var _a = this.view.state, tr = _a.tr, schema = _a.schema, doc = _a.doc;
        var lineTexts = text.split(reLineEnding);
        var nodes = lineTexts.map(function (lineText) {
            return createParagraph(schema, createNodesWithWidget(lineText, schema));
        });
        var slice = new external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Slice(external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.from(nodes), 1, 1);
        this.focus();
        if (start && end) {
            var _b = getMdToEditorPos(doc, start, end), from = _b[0], to = _b[1];
            newTr = tr.replaceRange(from, to, slice);
        }
        else {
            newTr = tr.replaceSelection(slice);
        }
        this.view.dispatch(newTr.scrollIntoView());
    };
    MdEditor.prototype.deleteSelection = function (start, end) {
        var newTr;
        var _a = this.view.state, tr = _a.tr, doc = _a.doc;
        if (start && end) {
            var _b = getMdToEditorPos(doc, start, end), from = _b[0], to = _b[1];
            newTr = tr.deleteRange(from, to);
        }
        else {
            newTr = tr.deleteSelection();
        }
        this.view.dispatch(newTr.scrollIntoView());
    };
    MdEditor.prototype.getSelectedText = function (start, end) {
        var _a = this.view.state, doc = _a.doc, selection = _a.selection;
        var from = selection.from, to = selection.to;
        if (start && end) {
            var pos = getMdToEditorPos(doc, start, end);
            from = pos[0];
            to = pos[1];
        }
        return doc.textBetween(from, to, '\n');
    };
    MdEditor.prototype.getSelection = function () {
        var _a = this.view.state.selection, from = _a.from, to = _a.to;
        return getEditorToMdPos(this.view.state.tr.doc, from, to);
    };
    MdEditor.prototype.setMarkdown = function (markdown, cursorToEnd) {
        if (cursorToEnd === void 0) { cursorToEnd = true; }
        var lineTexts = markdown.split(reLineEnding);
        var _a = this.view.state, tr = _a.tr, doc = _a.doc, schema = _a.schema;
        var nodes = lineTexts.map(function (lineText) {
            return createParagraph(schema, createNodesWithWidget(lineText, schema));
        });
        this.view.dispatch(tr.replaceWith(0, doc.content.size, nodes));
        if (cursorToEnd) {
            this.moveCursorToEnd(true);
        }
    };
    MdEditor.prototype.addWidget = function (node, style, mdPos) {
        var _a = this.view.state, tr = _a.tr, doc = _a.doc, selection = _a.selection;
        var pos = mdPos ? getMdToEditorPos(doc, mdPos, mdPos)[0] : selection.to;
        this.view.dispatch(tr.setMeta('widget', { pos: pos, node: node, style: style }));
    };
    MdEditor.prototype.replaceWithWidget = function (start, end, text) {
        var _a = this.view.state, tr = _a.tr, schema = _a.schema, doc = _a.doc;
        var pos = getMdToEditorPos(doc, start, end);
        var nodes = createNodesWithWidget(text, schema);
        this.view.dispatch(tr.replaceWith(pos[0], pos[1], nodes));
    };
    MdEditor.prototype.getRangeInfoOfNode = function (pos) {
        var _a = this.view.state, doc = _a.doc, selection = _a.selection;
        var mdPos = pos || getEditorToMdPos(doc, selection.from)[0];
        var mdNode = this.toastMark.findNodeAtPosition(mdPos);
        if (mdNode.type === 'text' && mdNode.parent.type !== 'paragraph') {
            mdNode = mdNode.parent;
        }
        // add 1 sync for prosemirror position
        mdNode.sourcepos[1][1] += 1;
        return { range: mdNode.sourcepos, type: mdNode.type };
    };
    MdEditor.prototype.getMarkdown = function () {
        return this.toastMark
            .getLineTexts()
            .map(function (lineText) { return unwrapWidgetSyntax(lineText); })
            .join('\n');
    };
    MdEditor.prototype.getToastMark = function () {
        return this.toastMark;
    };
    return MdEditor;
}(base));
/* harmony default export */ var mdEditor = (MdEditor);

// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domEvent/off.js
var off = __nested_webpack_require_93901__(349);
var off_default = /*#__PURE__*/__nested_webpack_require_93901__.n(off);
// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/domEvent/on.js
var on = __nested_webpack_require_93901__(348);
var on_default = /*#__PURE__*/__nested_webpack_require_93901__.n(on);
;// CONCATENATED MODULE: ../../libs/toastmark/dist/esm/index.js
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */
var esm_extendStatics = function (d, b) {
    esm_extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b)
            if (Object.prototype.hasOwnProperty.call(b, p))
                d[p] = b[p]; };
    return esm_extendStatics(d, b);
};
function esm_extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    esm_extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var esm_assign = function () {
    esm_assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
        }
        return t;
    };
    return esm_assign.apply(this, arguments);
};
function esm_spreadArray(to, from, pack) {
    if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar)
                    ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
    return to.concat(ar || Array.prototype.slice.call(from));
}
var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __nested_webpack_require_93901__.g !== 'undefined' ? __nested_webpack_require_93901__.g : typeof self !== 'undefined' ? self : {};
var encodeCache = {};
// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
    var i, ch, cache = encodeCache[exclude];
    if (cache) {
        return cache;
    }
    cache = encodeCache[exclude] = [];
    for (i = 0; i < 128; i++) {
        ch = String.fromCharCode(i);
        if (/^[0-9a-z]$/i.test(ch)) {
            // always allow unencoded alphanumeric characters
            cache.push(ch);
        }
        else {
            cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
        }
    }
    for (i = 0; i < exclude.length; i++) {
        cache[exclude.charCodeAt(i)] = exclude[i];
    }
    return cache;
}
// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode$1(string, exclude, keepEscaped) {
    var i, l, code, nextCode, cache, result = '';
    if (typeof exclude !== 'string') {
        // encode(string, keepEscaped)
        keepEscaped = exclude;
        exclude = encode$1.defaultChars;
    }
    if (typeof keepEscaped === 'undefined') {
        keepEscaped = true;
    }
    cache = getEncodeCache(exclude);
    for (i = 0, l = string.length; i < l; i++) {
        code = string.charCodeAt(i);
        if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
            if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
                result += string.slice(i, i + 3);
                i += 2;
                continue;
            }
        }
        if (code < 128) {
            result += cache[code];
            continue;
        }
        if (code >= 0xD800 && code <= 0xDFFF) {
            if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
                nextCode = string.charCodeAt(i + 1);
                if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
                    result += encodeURIComponent(string[i] + string[i + 1]);
                    i++;
                    continue;
                }
            }
            result += '%EF%BF%BD';
            continue;
        }
        result += encodeURIComponent(string[i]);
    }
    return result;
}
encode$1.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode$1.componentChars = "-_.!~*'()";
var encode_1 = encode$1;
var lib = {};
var decode = {};
var Aacute$1 = "";
var aacute$1 = "";
var Abreve = "";
var abreve = "";
var ac = "";
var acd = "";
var acE = "";
var Acirc$1 = "";
var acirc$1 = "";
var acute$1 = "";
var Acy = "";
var acy = "";
var AElig$1 = "";
var aelig$1 = "";
var af = "";
var Afr = "";
var afr = "";
var Agrave$1 = "";
var agrave$1 = "";
var alefsym = "";
var aleph = "";
var Alpha = "";
var alpha = "";
var Amacr = "";
var amacr = "";
var amalg = "";
var amp$2 = "&";
var AMP$1 = "&";
var andand = "";
var And = "";
var and = "";
var andd = "";
var andslope = "";
var andv = "";
var ang = "";
var ange = "";
var angle = "";
var angmsdaa = "";
var angmsdab = "";
var angmsdac = "";
var angmsdad = "";
var angmsdae = "";
var angmsdaf = "";
var angmsdag = "";
var angmsdah = "";
var angmsd = "";
var angrt = "";
var angrtvb = "";
var angrtvbd = "";
var angsph = "";
var angst = "";
var angzarr = "";
var Aogon = "";
var aogon = "";
var Aopf = "";
var aopf = "";
var apacir = "";
var ap = "";
var apE = "";
var ape = "";
var apid = "";
var apos$1 = "'";
var ApplyFunction = "";
var approx = "";
var approxeq = "";
var Aring$1 = "";
var aring$1 = "";
var Ascr = "";
var ascr = "";
var Assign = "";
var ast = "*";
var asymp = "";
var asympeq = "";
var Atilde$1 = "";
var atilde$1 = "";
var Auml$1 = "";
var auml$1 = "";
var awconint = "";
var awint = "";
var backcong = "";
var backepsilon = "";
var backprime = "";
var backsim = "";
var backsimeq = "";
var Backslash = "";
var Barv = "";
var barvee = "";
var barwed = "";
var Barwed = "";
var barwedge = "";
var bbrk = "";
var bbrktbrk = "";
var bcong = "";
var Bcy = "";
var bcy = "";
var bdquo = "";
var becaus = "";
var because = "";
var Because = "";
var bemptyv = "";
var bepsi = "";
var bernou = "";
var Bernoullis = "";
var Beta = "";
var beta = "";
var beth = "";
var esm_between = "";
var Bfr = "";
var bfr = "";
var bigcap = "";
var bigcirc = "";
var bigcup = "";
var bigodot = "";
var bigoplus = "";
var bigotimes = "";
var bigsqcup = "";
var bigstar = "";
var bigtriangledown = "";
var bigtriangleup = "";
var biguplus = "";
var bigvee = "";
var bigwedge = "";
var bkarow = "";
var blacklozenge = "";
var blacksquare = "";
var blacktriangle = "";
var blacktriangledown = "";
var blacktriangleleft = "";
var blacktriangleright = "";
var blank = "";
var blk12 = "";
var blk14 = "";
var blk34 = "";
var block = "";
var bne = "=";
var bnequiv = "";
var bNot = "";
var bnot = "";
var Bopf = "";
var bopf = "";
var bot = "";
var bottom = "";
var bowtie = "";
var boxbox = "";
var boxdl = "";
var boxdL = "";
var boxDl = "";
var boxDL = "";
var boxdr = "";
var boxdR = "";
var boxDr = "";
var boxDR = "";
var boxh = "";
var boxH = "";
var boxhd = "";
var boxHd = "";
var boxhD = "";
var boxHD = "";
var boxhu = "";
var boxHu = "";
var boxhU = "";
var boxHU = "";
var boxminus = "";
var boxplus = "";
var boxtimes = "";
var boxul = "";
var boxuL = "";
var boxUl = "";
var boxUL = "";
var boxur = "";
var boxuR = "";
var boxUr = "";
var boxUR = "";
var boxv = "";
var boxV = "";
var boxvh = "";
var boxvH = "";
var boxVh = "";
var boxVH = "";
var boxvl = "";
var boxvL = "";
var boxVl = "";
var boxVL = "";
var boxvr = "";
var boxvR = "";
var boxVr = "";
var boxVR = "";
var bprime = "";
var breve = "";
var Breve = "";
var brvbar$1 = "";
var bscr = "";
var Bscr = "";
var bsemi = "";
var bsim = "";
var bsime = "";
var bsolb = "";
var bsol = "\\";
var bsolhsub = "";
var bull = "";
var bullet = "";
var bump = "";
var bumpE = "";
var bumpe = "";
var Bumpeq = "";
var bumpeq = "";
var Cacute = "";
var cacute = "";
var capand = "";
var capbrcup = "";
var capcap = "";
var cap = "";
var Cap = "";
var capcup = "";
var capdot = "";
var CapitalDifferentialD = "";
var caps = "";
var caret = "";
var caron = "";
var Cayleys = "";
var ccaps = "";
var Ccaron = "";
var ccaron = "";
var Ccedil$1 = "";
var ccedil$1 = "";
var Ccirc = "";
var ccirc = "";
var Cconint = "";
var ccups = "";
var ccupssm = "";
var Cdot = "";
var cdot = "";
var cedil$1 = "";
var Cedilla = "";
var cemptyv = "";
var cent$1 = "";
var centerdot = "";
var CenterDot = "";
var cfr = "";
var Cfr = "";
var CHcy = "";
var chcy = "";
var check = "";
var checkmark = "";
var Chi = "";
var chi = "";
var circ = "";
var circeq = "";
var circlearrowleft = "";
var circlearrowright = "";
var circledast = "";
var circledcirc = "";
var circleddash = "";
var CircleDot = "";
var circledR = "";
var circledS = "";
var CircleMinus = "";
var CirclePlus = "";
var CircleTimes = "";
var cir = "";
var cirE = "";
var cire = "";
var cirfnint = "";
var cirmid = "";
var cirscir = "";
var ClockwiseContourIntegral = "";
var CloseCurlyDoubleQuote = "";
var CloseCurlyQuote = "";
var clubs = "";
var clubsuit = "";
var colon = ":";
var Colon = "";
var Colone = "";
var colone = "";
var coloneq = "";
var comma = ",";
var commat = "@";
var comp = "";
var compfn = "";
var complement = "";
var complexes = "";
var cong = "";
var congdot = "";
var Congruent = "";
var conint = "";
var Conint = "";
var ContourIntegral = "";
var copf = "";
var Copf = "";
var coprod = "";
var Coproduct = "";
var copy$1 = "";
var COPY$1 = "";
var copysr = "";
var CounterClockwiseContourIntegral = "";
var crarr = "";
var cross = "";
var Cross = "";
var Cscr = "";
var cscr = "";
var csub = "";
var csube = "";
var csup = "";
var csupe = "";
var ctdot = "";
var cudarrl = "";
var cudarrr = "";
var cuepr = "";
var cuesc = "";
var cularr = "";
var cularrp = "";
var cupbrcap = "";
var cupcap = "";
var CupCap = "";
var cup = "";
var Cup = "";
var cupcup = "";
var cupdot = "";
var cupor = "";
var cups = "";
var curarr = "";
var curarrm = "";
var curlyeqprec = "";
var curlyeqsucc = "";
var curlyvee = "";
var curlywedge = "";
var curren$1 = "";
var curvearrowleft = "";
var curvearrowright = "";
var cuvee = "";
var cuwed = "";
var cwconint = "";
var cwint = "";
var cylcty = "";
var dagger = "";
var Dagger = "";
var daleth = "";
var darr = "";
var Darr = "";
var dArr = "";
var dash = "";
var Dashv = "";
var dashv = "";
var dbkarow = "";
var dblac = "";
var Dcaron = "";
var dcaron = "";
var Dcy = "";
var dcy = "";
var ddagger = "";
var ddarr = "";
var DD = "";
var dd = "";
var DDotrahd = "";
var ddotseq = "";
var deg$1 = "";
var Del = "";
var Delta = "";
var delta = "";
var demptyv = "";
var dfisht = "";
var Dfr = "";
var dfr = "";
var dHar = "";
var dharl = "";
var dharr = "";
var DiacriticalAcute = "";
var DiacriticalDot = "";
var DiacriticalDoubleAcute = "";
var DiacriticalGrave = "`";
var DiacriticalTilde = "";
var diam = "";
var diamond = "";
var Diamond = "";
var diamondsuit = "";
var diams = "";
var die = "";
var DifferentialD = "";
var digamma = "";
var disin = "";
var div = "";
var divide$1 = "";
var divideontimes = "";
var divonx = "";
var DJcy = "";
var djcy = "";
var dlcorn = "";
var dlcrop = "";
var dollar = "$";
var Dopf = "";
var dopf = "";
var Dot = "";
var dot = "";
var DotDot = "";
var doteq = "";
var doteqdot = "";
var DotEqual = "";
var dotminus = "";
var dotplus = "";
var dotsquare = "";
var doublebarwedge = "";
var DoubleContourIntegral = "";
var DoubleDot = "";
var DoubleDownArrow = "";
var DoubleLeftArrow = "";
var DoubleLeftRightArrow = "";
var DoubleLeftTee = "";
var DoubleLongLeftArrow = "";
var DoubleLongLeftRightArrow = "";
var DoubleLongRightArrow = "";
var DoubleRightArrow = "";
var DoubleRightTee = "";
var DoubleUpArrow = "";
var DoubleUpDownArrow = "";
var DoubleVerticalBar = "";
var DownArrowBar = "";
var downarrow = "";
var DownArrow = "";
var Downarrow = "";
var DownArrowUpArrow = "";
var DownBreve = "";
var downdownarrows = "";
var downharpoonleft = "";
var downharpoonright = "";
var DownLeftRightVector = "";
var DownLeftTeeVector = "";
var DownLeftVectorBar = "";
var DownLeftVector = "";
var DownRightTeeVector = "";
var DownRightVectorBar = "";
var DownRightVector = "";
var DownTeeArrow = "";
var DownTee = "";
var drbkarow = "";
var drcorn = "";
var drcrop = "";
var Dscr = "";
var dscr = "";
var DScy = "";
var dscy = "";
var dsol = "";
var Dstrok = "";
var dstrok = "";
var dtdot = "";
var dtri = "";
var dtrif = "";
var duarr = "";
var duhar = "";
var dwangle = "";
var DZcy = "";
var dzcy = "";
var dzigrarr = "";
var Eacute$1 = "";
var eacute$1 = "";
var easter = "";
var Ecaron = "";
var ecaron = "";
var Ecirc$1 = "";
var ecirc$1 = "";
var ecir = "";
var ecolon = "";
var Ecy = "";
var ecy = "";
var eDDot = "";
var Edot = "";
var edot = "";
var eDot = "";
var ee = "";
var efDot = "";
var Efr = "";
var efr = "";
var eg = "";
var Egrave$1 = "";
var egrave$1 = "";
var egs = "";
var egsdot = "";
var el = "";
var esm_Element = "";
var elinters = "";
var ell = "";
var els = "";
var elsdot = "";
var Emacr = "";
var emacr = "";
var esm_empty = "";
var emptyset = "";
var EmptySmallSquare = "";
var emptyv = "";
var EmptyVerySmallSquare = "";
var emsp13 = "";
var emsp14 = "";
var emsp = "";
var ENG = "";
var eng = "";
var ensp = "";
var Eogon = "";
var eogon = "";
var Eopf = "";
var eopf = "";
var epar = "";
var eparsl = "";
var eplus = "";
var epsi = "";
var Epsilon = "";
var epsilon = "";
var epsiv = "";
var eqcirc = "";
var eqcolon = "";
var eqsim = "";
var eqslantgtr = "";
var eqslantless = "";
var Equal = "";
var equals = "=";
var EqualTilde = "";
var equest = "";
var Equilibrium = "";
var equiv = "";
var equivDD = "";
var eqvparsl = "";
var erarr = "";
var erDot = "";
var escr = "";
var Escr = "";
var esdot = "";
var Esim = "";
var esim = "";
var Eta = "";
var eta = "";
var ETH$1 = "";
var eth$1 = "";
var Euml$1 = "";
var euml$1 = "";
var euro = "";
var excl = "!";
var exist = "";
var Exists = "";
var expectation = "";
var exponentiale = "";
var ExponentialE = "";
var fallingdotseq = "";
var Fcy = "";
var fcy = "";
var female = "";
var ffilig = "";
var fflig = "";
var ffllig = "";
var Ffr = "";
var ffr = "";
var filig = "";
var FilledSmallSquare = "";
var FilledVerySmallSquare = "";
var fjlig = "fj";
var flat = "";
var fllig = "";
var fltns = "";
var fnof = "";
var Fopf = "";
var fopf = "";
var forall = "";
var ForAll = "";
var fork = "";
var forkv = "";
var Fouriertrf = "";
var fpartint = "";
var frac12$1 = "";
var frac13 = "";
var frac14$1 = "";
var frac15 = "";
var frac16 = "";
var frac18 = "";
var frac23 = "";
var frac25 = "";
var frac34$1 = "";
var frac35 = "";
var frac38 = "";
var frac45 = "";
var frac56 = "";
var frac58 = "";
var frac78 = "";
var frasl = "";
var frown = "";
var fscr = "";
var Fscr = "";
var gacute = "";
var Gamma = "";
var gamma = "";
var Gammad = "";
var gammad = "";
var gap = "";
var Gbreve = "";
var gbreve = "";
var Gcedil = "";
var Gcirc = "";
var gcirc = "";
var Gcy = "";
var gcy = "";
var Gdot = "";
var gdot = "";
var ge = "";
var gE = "";
var gEl = "";
var gel = "";
var geq = "";
var geqq = "";
var geqslant = "";
var gescc = "";
var ges = "";
var gesdot = "";
var gesdoto = "";
var gesdotol = "";
var gesl = "";
var gesles = "";
var Gfr = "";
var gfr = "";
var gg = "";
var Gg = "";
var ggg = "";
var gimel = "";
var GJcy = "";
var gjcy = "";
var gla = "";
var gl = "";
var glE = "";
var glj = "";
var gnap = "";
var gnapprox = "";
var gne = "";
var gnE = "";
var gneq = "";
var gneqq = "";
var gnsim = "";
var Gopf = "";
var gopf = "";
var grave = "`";
var GreaterEqual = "";
var GreaterEqualLess = "";
var GreaterFullEqual = "";
var GreaterGreater = "";
var GreaterLess = "";
var GreaterSlantEqual = "";
var GreaterTilde = "";
var Gscr = "";
var gscr = "";
var gsim = "";
var gsime = "";
var gsiml = "";
var gtcc = "";
var gtcir = "";
var gt$2 = ">";
var GT$1 = ">";
var Gt = "";
var gtdot = "";
var gtlPar = "";
var gtquest = "";
var gtrapprox = "";
var gtrarr = "";
var gtrdot = "";
var gtreqless = "";
var gtreqqless = "";
var gtrless = "";
var gtrsim = "";
var gvertneqq = "";
var gvnE = "";
var Hacek = "";
var hairsp = "";
var half = "";
var hamilt = "";
var HARDcy = "";
var hardcy = "";
var harrcir = "";
var harr = "";
var hArr = "";
var harrw = "";
var Hat = "^";
var hbar = "";
var Hcirc = "";
var hcirc = "";
var hearts = "";
var heartsuit = "";
var hellip = "";
var hercon = "";
var hfr = "";
var Hfr = "";
var HilbertSpace = "";
var hksearow = "";
var hkswarow = "";
var hoarr = "";
var homtht = "";
var hookleftarrow = "";
var hookrightarrow = "";
var hopf = "";
var Hopf = "";
var horbar = "";
var HorizontalLine = "";
var hscr = "";
var Hscr = "";
var hslash = "";
var Hstrok = "";
var hstrok = "";
var HumpDownHump = "";
var HumpEqual = "";
var hybull = "";
var hyphen = "";
var Iacute$1 = "";
var iacute$1 = "";
var ic = "";
var Icirc$1 = "";
var icirc$1 = "";
var Icy = "";
var icy = "";
var Idot = "";
var IEcy = "";
var iecy = "";
var iexcl$1 = "";
var iff = "";
var ifr = "";
var Ifr = "";
var Igrave$1 = "";
var igrave$1 = "";
var ii = "";
var iiiint = "";
var iiint = "";
var iinfin = "";
var iiota = "";
var IJlig = "";
var ijlig = "";
var Imacr = "";
var imacr = "";
var esm_image = "";
var ImaginaryI = "";
var imagline = "";
var imagpart = "";
var imath = "";
var Im = "";
var imof = "";
var imped = "";
var Implies = "";
var incare = "";
var infin = "";
var infintie = "";
var inodot = "";
var intcal = "";
var esm_int = "";
var Int = "";
var integers = "";
var Integral = "";
var intercal = "";
var Intersection = "";
var intlarhk = "";
var intprod = "";
var InvisibleComma = "";
var InvisibleTimes = "";
var IOcy = "";
var iocy = "";
var Iogon = "";
var iogon = "";
var Iopf = "";
var iopf = "";
var Iota = "";
var iota = "";
var iprod = "";
var iquest$1 = "";
var iscr = "";
var Iscr = "";
var isin = "";
var isindot = "";
var isinE = "";
var isins = "";
var isinsv = "";
var isinv = "";
var it = "";
var Itilde = "";
var itilde = "";
var Iukcy = "";
var iukcy = "";
var Iuml$1 = "";
var iuml$1 = "";
var Jcirc = "";
var jcirc = "";
var Jcy = "";
var jcy = "";
var Jfr = "";
var jfr = "";
var jmath = "";
var Jopf = "";
var jopf = "";
var Jscr = "";
var jscr = "";
var Jsercy = "";
var jsercy = "";
var Jukcy = "";
var jukcy = "";
var Kappa = "";
var kappa = "";
var kappav = "";
var Kcedil = "";
var kcedil = "";
var Kcy = "";
var kcy = "";
var Kfr = "";
var kfr = "";
var kgreen = "";
var KHcy = "";
var khcy = "";
var KJcy = "";
var kjcy = "";
var Kopf = "";
var kopf = "";
var Kscr = "";
var kscr = "";
var lAarr = "";
var Lacute = "";
var lacute = "";
var laemptyv = "";
var lagran = "";
var Lambda = "";
var lambda = "";
var lang = "";
var Lang = "";
var langd = "";
var langle = "";
var lap = "";
var Laplacetrf = "";
var laquo$1 = "";
var larrb = "";
var larrbfs = "";
var larr = "";
var Larr = "";
var lArr = "";
var larrfs = "";
var larrhk = "";
var larrlp = "";
var larrpl = "";
var larrsim = "";
var larrtl = "";
var latail = "";
var lAtail = "";
var lat = "";
var late = "";
var lates = "";
var lbarr = "";
var lBarr = "";
var lbbrk = "";
var lbrace = "{";
var lbrack = "[";
var lbrke = "";
var lbrksld = "";
var lbrkslu = "";
var Lcaron = "";
var lcaron = "";
var Lcedil = "";
var lcedil = "";
var lceil = "";
var lcub = "{";
var Lcy = "";
var lcy = "";
var ldca = "";
var ldquo = "";
var ldquor = "";
var ldrdhar = "";
var ldrushar = "";
var ldsh = "";
var le = "";
var lE = "";
var LeftAngleBracket = "";
var LeftArrowBar = "";
var leftarrow = "";
var LeftArrow = "";
var Leftarrow = "";
var LeftArrowRightArrow = "";
var leftarrowtail = "";
var LeftCeiling = "";
var LeftDoubleBracket = "";
var LeftDownTeeVector = "";
var LeftDownVectorBar = "";
var LeftDownVector = "";
var LeftFloor = "";
var leftharpoondown = "";
var leftharpoonup = "";
var leftleftarrows = "";
var leftrightarrow = "";
var LeftRightArrow = "";
var Leftrightarrow = "";
var leftrightarrows = "";
var leftrightharpoons = "";
var leftrightsquigarrow = "";
var LeftRightVector = "";
var LeftTeeArrow = "";
var LeftTee = "";
var LeftTeeVector = "";
var leftthreetimes = "";
var LeftTriangleBar = "";
var LeftTriangle = "";
var LeftTriangleEqual = "";
var LeftUpDownVector = "";
var LeftUpTeeVector = "";
var LeftUpVectorBar = "";
var LeftUpVector = "";
var LeftVectorBar = "";
var LeftVector = "";
var lEg = "";
var leg = "";
var leq = "";
var leqq = "";
var leqslant = "";
var lescc = "";
var les = "";
var lesdot = "";
var lesdoto = "";
var lesdotor = "";
var lesg = "";
var lesges = "";
var lessapprox = "";
var lessdot = "";
var lesseqgtr = "";
var lesseqqgtr = "";
var LessEqualGreater = "";
var LessFullEqual = "";
var LessGreater = "";
var lessgtr = "";
var LessLess = "";
var lesssim = "";
var LessSlantEqual = "";
var LessTilde = "";
var lfisht = "";
var lfloor = "";
var Lfr = "";
var lfr = "";
var lg = "";
var lgE = "";
var lHar = "";
var lhard = "";
var lharu = "";
var lharul = "";
var lhblk = "";
var LJcy = "";
var ljcy = "";
var llarr = "";
var ll = "";
var Ll = "";
var llcorner = "";
var Lleftarrow = "";
var llhard = "";
var lltri = "";
var Lmidot = "";
var lmidot = "";
var lmoustache = "";
var lmoust = "";
var lnap = "";
var lnapprox = "";
var lne = "";
var lnE = "";
var lneq = "";
var lneqq = "";
var lnsim = "";
var loang = "";
var loarr = "";
var lobrk = "";
var longleftarrow = "";
var LongLeftArrow = "";
var Longleftarrow = "";
var longleftrightarrow = "";
var LongLeftRightArrow = "";
var Longleftrightarrow = "";
var longmapsto = "";
var longrightarrow = "";
var LongRightArrow = "";
var Longrightarrow = "";
var looparrowleft = "";
var looparrowright = "";
var lopar = "";
var Lopf = "";
var lopf = "";
var loplus = "";
var lotimes = "";
var lowast = "";
var lowbar = "_";
var LowerLeftArrow = "";
var LowerRightArrow = "";
var loz = "";
var lozenge = "";
var lozf = "";
var lpar = "(";
var lparlt = "";
var lrarr = "";
var lrcorner = "";
var lrhar = "";
var lrhard = "";
var lrm = "";
var lrtri = "";
var lsaquo = "";
var lscr = "";
var Lscr = "";
var lsh = "";
var Lsh = "";
var lsim = "";
var lsime = "";
var lsimg = "";
var lsqb = "[";
var lsquo = "";
var lsquor = "";
var Lstrok = "";
var lstrok = "";
var ltcc = "";
var ltcir = "";
var lt$2 = "<";
var LT$1 = "<";
var Lt = "";
var ltdot = "";
var lthree = "";
var ltimes = "";
var ltlarr = "";
var ltquest = "";
var ltri = "";
var ltrie = "";
var ltrif = "";
var ltrPar = "";
var lurdshar = "";
var luruhar = "";
var lvertneqq = "";
var lvnE = "";
var macr$1 = "";
var male = "";
var malt = "";
var maltese = "";
var map = "";
var mapsto = "";
var mapstodown = "";
var mapstoleft = "";
var mapstoup = "";
var marker = "";
var mcomma = "";
var Mcy = "";
var mcy = "";
var mdash = "";
var mDDot = "";
var measuredangle = "";
var MediumSpace = "";
var Mellintrf = "";
var Mfr = "";
var mfr = "";
var mho = "";
var micro$1 = "";
var midast = "*";
var midcir = "";
var mid = "";
var middot$1 = "";
var minusb = "";
var minus = "";
var minusd = "";
var minusdu = "";
var MinusPlus = "";
var mlcp = "";
var mldr = "";
var mnplus = "";
var models = "";
var Mopf = "";
var mopf = "";
var mp = "";
var mscr = "";
var Mscr = "";
var mstpos = "";
var Mu = "";
var mu = "";
var multimap = "";
var mumap = "";
var nabla = "";
var Nacute = "";
var nacute = "";
var nang = "";
var nap = "";
var napE = "";
var napid = "";
var napos = "";
var napprox = "";
var natural = "";
var naturals = "";
var natur = "";
var nbsp$1 = "";
var nbump = "";
var nbumpe = "";
var ncap = "";
var Ncaron = "";
var ncaron = "";
var Ncedil = "";
var ncedil = "";
var ncong = "";
var ncongdot = "";
var ncup = "";
var Ncy = "";
var ncy = "";
var ndash = "";
var nearhk = "";
var nearr = "";
var neArr = "";
var nearrow = "";
var ne = "";
var nedot = "";
var NegativeMediumSpace = "";
var NegativeThickSpace = "";
var NegativeThinSpace = "";
var NegativeVeryThinSpace = "";
var nequiv = "";
var nesear = "";
var nesim = "";
var NestedGreaterGreater = "";
var NestedLessLess = "";
var NewLine = "\n";
var nexist = "";
var nexists = "";
var Nfr = "";
var nfr = "";
var ngE = "";
var nge = "";
var ngeq = "";
var ngeqq = "";
var ngeqslant = "";
var nges = "";
var nGg = "";
var ngsim = "";
var nGt = "";
var ngt = "";
var ngtr = "";
var nGtv = "";
var nharr = "";
var nhArr = "";
var nhpar = "";
var ni = "";
var nis = "";
var nisd = "";
var niv = "";
var NJcy = "";
var njcy = "";
var nlarr = "";
var nlArr = "";
var nldr = "";
var nlE = "";
var nle = "";
var nleftarrow = "";
var nLeftarrow = "";
var nleftrightarrow = "";
var nLeftrightarrow = "";
var nleq = "";
var nleqq = "";
var nleqslant = "";
var nles = "";
var nless = "";
var nLl = "";
var nlsim = "";
var nLt = "";
var nlt = "";
var nltri = "";
var nltrie = "";
var nLtv = "";
var nmid = "";
var NoBreak = "";
var NonBreakingSpace = "";
var nopf = "";
var Nopf = "";
var Not = "";
var not$1 = "";
var NotCongruent = "";
var NotCupCap = "";
var NotDoubleVerticalBar = "";
var NotElement = "";
var NotEqual = "";
var NotEqualTilde = "";
var NotExists = "";
var NotGreater = "";
var NotGreaterEqual = "";
var NotGreaterFullEqual = "";
var NotGreaterGreater = "";
var NotGreaterLess = "";
var NotGreaterSlantEqual = "";
var NotGreaterTilde = "";
var NotHumpDownHump = "";
var NotHumpEqual = "";
var notin = "";
var notindot = "";
var notinE = "";
var notinva = "";
var notinvb = "";
var notinvc = "";
var NotLeftTriangleBar = "";
var NotLeftTriangle = "";
var NotLeftTriangleEqual = "";
var NotLess = "";
var NotLessEqual = "";
var NotLessGreater = "";
var NotLessLess = "";
var NotLessSlantEqual = "";
var NotLessTilde = "";
var NotNestedGreaterGreater = "";
var NotNestedLessLess = "";
var notni = "";
var notniva = "";
var notnivb = "";
var notnivc = "";
var NotPrecedes = "";
var NotPrecedesEqual = "";
var NotPrecedesSlantEqual = "";
var NotReverseElement = "";
var NotRightTriangleBar = "";
var NotRightTriangle = "";
var NotRightTriangleEqual = "";
var NotSquareSubset = "";
var NotSquareSubsetEqual = "";
var NotSquareSuperset = "";
var NotSquareSupersetEqual = "";
var NotSubset = "";
var NotSubsetEqual = "";
var NotSucceeds = "";
var NotSucceedsEqual = "";
var NotSucceedsSlantEqual = "";
var NotSucceedsTilde = "";
var NotSuperset = "";
var NotSupersetEqual = "";
var NotTilde = "";
var NotTildeEqual = "";
var NotTildeFullEqual = "";
var NotTildeTilde = "";
var NotVerticalBar = "";
var nparallel = "";
var npar = "";
var nparsl = "";
var npart = "";
var npolint = "";
var npr = "";
var nprcue = "";
var nprec = "";
var npreceq = "";
var npre = "";
var nrarrc = "";
var nrarr = "";
var nrArr = "";
var nrarrw = "";
var nrightarrow = "";
var nRightarrow = "";
var nrtri = "";
var nrtrie = "";
var nsc = "";
var nsccue = "";
var nsce = "";
var Nscr = "";
var nscr = "";
var nshortmid = "";
var nshortparallel = "";
var nsim = "";
var nsime = "";
var nsimeq = "";
var nsmid = "";
var nspar = "";
var nsqsube = "";
var nsqsupe = "";
var nsub = "";
var nsubE = "";
var nsube = "";
var nsubset = "";
var nsubseteq = "";
var nsubseteqq = "";
var nsucc = "";
var nsucceq = "";
var nsup = "";
var nsupE = "";
var nsupe = "";
var nsupset = "";
var nsupseteq = "";
var nsupseteqq = "";
var ntgl = "";
var Ntilde$1 = "";
var ntilde$1 = "";
var ntlg = "";
var ntriangleleft = "";
var ntrianglelefteq = "";
var ntriangleright = "";
var ntrianglerighteq = "";
var Nu = "";
var nu = "";
var num = "#";
var numero = "";
var numsp = "";
var nvap = "";
var nvdash = "";
var nvDash = "";
var nVdash = "";
var nVDash = "";
var nvge = "";
var nvgt = ">";
var nvHarr = "";
var nvinfin = "";
var nvlArr = "";
var nvle = "";
var nvlt = "<";
var nvltrie = "";
var nvrArr = "";
var nvrtrie = "";
var nvsim = "";
var nwarhk = "";
var nwarr = "";
var nwArr = "";
var nwarrow = "";
var nwnear = "";
var Oacute$1 = "";
var oacute$1 = "";
var oast = "";
var Ocirc$1 = "";
var ocirc$1 = "";
var ocir = "";
var Ocy = "";
var ocy = "";
var odash = "";
var Odblac = "";
var odblac = "";
var odiv = "";
var odot = "";
var odsold = "";
var OElig = "";
var oelig = "";
var ofcir = "";
var Ofr = "";
var ofr = "";
var ogon = "";
var Ograve$1 = "";
var ograve$1 = "";
var ogt = "";
var ohbar = "";
var ohm = "";
var oint = "";
var olarr = "";
var olcir = "";
var olcross = "";
var oline = "";
var olt = "";
var Omacr = "";
var omacr = "";
var Omega = "";
var omega = "";
var Omicron = "";
var omicron = "";
var omid = "";
var ominus = "";
var Oopf = "";
var oopf = "";
var opar = "";
var OpenCurlyDoubleQuote = "";
var OpenCurlyQuote = "";
var operp = "";
var oplus = "";
var orarr = "";
var Or = "";
var or = "";
var ord = "";
var order = "";
var orderof = "";
var ordf$1 = "";
var ordm$1 = "";
var origof = "";
var oror = "";
var orslope = "";
var orv = "";
var oS = "";
var Oscr = "";
var oscr = "";
var Oslash$1 = "";
var oslash$1 = "";
var osol = "";
var Otilde$1 = "";
var otilde$1 = "";
var otimesas = "";
var Otimes = "";
var otimes = "";
var Ouml$1 = "";
var ouml$1 = "";
var ovbar = "";
var OverBar = "";
var OverBrace = "";
var OverBracket = "";
var OverParenthesis = "";
var para$1 = "";
var parallel = "";
var par = "";
var parsim = "";
var parsl = "";
var part = "";
var PartialD = "";
var Pcy = "";
var pcy = "";
var percnt = "%";
var period = ".";
var permil = "";
var perp = "";
var pertenk = "";
var Pfr = "";
var pfr = "";
var Phi = "";
var phi = "";
var phiv = "";
var phmmat = "";
var phone = "";
var Pi = "";
var pi = "";
var pitchfork = "";
var piv = "";
var planck = "";
var planckh = "";
var plankv = "";
var plusacir = "";
var plusb = "";
var pluscir = "";
var plus = "+";
var plusdo = "";
var plusdu = "";
var pluse = "";
var PlusMinus = "";
var plusmn$1 = "";
var plussim = "";
var plustwo = "";
var pm = "";
var Poincareplane = "";
var pointint = "";
var popf = "";
var Popf = "";
var pound$1 = "";
var prap = "";
var Pr = "";
var pr = "";
var prcue = "";
var precapprox = "";
var prec = "";
var preccurlyeq = "";
var Precedes = "";
var PrecedesEqual = "";
var PrecedesSlantEqual = "";
var PrecedesTilde = "";
var preceq = "";
var precnapprox = "";
var precneqq = "";
var precnsim = "";
var pre = "";
var prE = "";
var precsim = "";
var prime = "";
var Prime = "";
var primes = "";
var prnap = "";
var prnE = "";
var prnsim = "";
var prod = "";
var Product = "";
var profalar = "";
var profline = "";
var profsurf = "";
var prop = "";
var Proportional = "";
var Proportion = "";
var propto = "";
var prsim = "";
var prurel = "";
var Pscr = "";
var pscr = "";
var Psi = "";
var psi = "";
var puncsp = "";
var Qfr = "";
var qfr = "";
var qint = "";
var qopf = "";
var Qopf = "";
var qprime = "";
var Qscr = "";
var qscr = "";
var quaternions = "";
var quatint = "";
var quest = "?";
var questeq = "";
var quot$2 = "\"";
var QUOT$1 = "\"";
var rAarr = "";
var race = "";
var Racute = "";
var racute = "";
var radic = "";
var raemptyv = "";
var rang = "";
var Rang = "";
var rangd = "";
var range = "";
var rangle = "";
var raquo$1 = "";
var rarrap = "";
var rarrb = "";
var rarrbfs = "";
var rarrc = "";
var rarr = "";
var Rarr = "";
var rArr = "";
var rarrfs = "";
var rarrhk = "";
var rarrlp = "";
var rarrpl = "";
var rarrsim = "";
var Rarrtl = "";
var rarrtl = "";
var rarrw = "";
var ratail = "";
var rAtail = "";
var ratio = "";
var rationals = "";
var rbarr = "";
var rBarr = "";
var RBarr = "";
var rbbrk = "";
var rbrace = "}";
var rbrack = "]";
var rbrke = "";
var rbrksld = "";
var rbrkslu = "";
var Rcaron = "";
var rcaron = "";
var Rcedil = "";
var rcedil = "";
var rceil = "";
var rcub = "}";
var Rcy = "";
var rcy = "";
var rdca = "";
var rdldhar = "";
var rdquo = "";
var rdquor = "";
var rdsh = "";
var real = "";
var realine = "";
var realpart = "";
var reals = "";
var Re = "";
var rect = "";
var reg$1 = "";
var REG$1 = "";
var ReverseElement = "";
var ReverseEquilibrium = "";
var ReverseUpEquilibrium = "";
var rfisht = "";
var rfloor = "";
var rfr = "";
var Rfr = "";
var rHar = "";
var rhard = "";
var rharu = "";
var rharul = "";
var Rho = "";
var rho = "";
var rhov = "";
var RightAngleBracket = "";
var RightArrowBar = "";
var rightarrow = "";
var RightArrow = "";
var Rightarrow = "";
var RightArrowLeftArrow = "";
var rightarrowtail = "";
var RightCeiling = "";
var RightDoubleBracket = "";
var RightDownTeeVector = "";
var RightDownVectorBar = "";
var RightDownVector = "";
var RightFloor = "";
var rightharpoondown = "";
var rightharpoonup = "";
var rightleftarrows = "";
var rightleftharpoons = "";
var rightrightarrows = "";
var rightsquigarrow = "";
var RightTeeArrow = "";
var RightTee = "";
var RightTeeVector = "";
var rightthreetimes = "";
var RightTriangleBar = "";
var RightTriangle = "";
var RightTriangleEqual = "";
var RightUpDownVector = "";
var RightUpTeeVector = "";
var RightUpVectorBar = "";
var RightUpVector = "";
var RightVectorBar = "";
var RightVector = "";
var ring = "";
var risingdotseq = "";
var rlarr = "";
var rlhar = "";
var rlm = "";
var rmoustache = "";
var rmoust = "";
var rnmid = "";
var roang = "";
var roarr = "";
var robrk = "";
var ropar = "";
var ropf = "";
var Ropf = "";
var roplus = "";
var rotimes = "";
var RoundImplies = "";
var rpar = ")";
var rpargt = "";
var rppolint = "";
var rrarr = "";
var Rrightarrow = "";
var rsaquo = "";
var rscr = "";
var Rscr = "";
var rsh = "";
var Rsh = "";
var rsqb = "]";
var rsquo = "";
var rsquor = "";
var rthree = "";
var rtimes = "";
var rtri = "";
var rtrie = "";
var rtrif = "";
var rtriltri = "";
var RuleDelayed = "";
var ruluhar = "";
var rx = "";
var Sacute = "";
var sacute = "";
var sbquo = "";
var scap = "";
var Scaron = "";
var scaron = "";
var Sc = "";
var sc = "";
var sccue = "";
var sce = "";
var scE = "";
var Scedil = "";
var scedil = "";
var Scirc = "";
var scirc = "";
var scnap = "";
var scnE = "";
var scnsim = "";
var scpolint = "";
var scsim = "";
var Scy = "";
var scy = "";
var sdotb = "";
var sdot = "";
var sdote = "";
var searhk = "";
var searr = "";
var seArr = "";
var searrow = "";
var sect$1 = "";
var semi = ";";
var seswar = "";
var setminus = "";
var setmn = "";
var sext = "";
var Sfr = "";
var sfr = "";
var sfrown = "";
var sharp = "";
var SHCHcy = "";
var shchcy = "";
var SHcy = "";
var shcy = "";
var ShortDownArrow = "";
var ShortLeftArrow = "";
var shortmid = "";
var shortparallel = "";
var ShortRightArrow = "";
var ShortUpArrow = "";
var shy$1 = "";
var Sigma = "";
var sigma = "";
var sigmaf = "";
var sigmav = "";
var sim = "";
var simdot = "";
var sime = "";
var simeq = "";
var simg = "";
var simgE = "";
var siml = "";
var simlE = "";
var simne = "";
var simplus = "";
var simrarr = "";
var slarr = "";
var SmallCircle = "";
var smallsetminus = "";
var smashp = "";
var smeparsl = "";
var smid = "";
var smile = "";
var smt = "";
var smte = "";
var smtes = "";
var SOFTcy = "";
var softcy = "";
var solbar = "";
var solb = "";
var sol = "/";
var Sopf = "";
var sopf = "";
var spades = "";
var spadesuit = "";
var spar = "";
var sqcap = "";
var sqcaps = "";
var sqcup = "";
var sqcups = "";
var Sqrt = "";
var sqsub = "";
var sqsube = "";
var sqsubset = "";
var sqsubseteq = "";
var sqsup = "";
var sqsupe = "";
var sqsupset = "";
var sqsupseteq = "";
var square = "";
var Square = "";
var SquareIntersection = "";
var SquareSubset = "";
var SquareSubsetEqual = "";
var SquareSuperset = "";
var SquareSupersetEqual = "";
var SquareUnion = "";
var squarf = "";
var squ = "";
var squf = "";
var srarr = "";
var Sscr = "";
var sscr = "";
var ssetmn = "";
var ssmile = "";
var sstarf = "";
var Star = "";
var star = "";
var starf = "";
var straightepsilon = "";
var straightphi = "";
var strns = "";
var sub = "";
var Sub = "";
var subdot = "";
var subE = "";
var sube = "";
var subedot = "";
var submult = "";
var subnE = "";
var subne = "";
var subplus = "";
var subrarr = "";
var subset = "";
var Subset = "";
var subseteq = "";
var subseteqq = "";
var SubsetEqual = "";
var subsetneq = "";
var subsetneqq = "";
var subsim = "";
var subsub = "";
var subsup = "";
var succapprox = "";
var succ = "";
var succcurlyeq = "";
var Succeeds = "";
var SucceedsEqual = "";
var SucceedsSlantEqual = "";
var SucceedsTilde = "";
var succeq = "";
var succnapprox = "";
var succneqq = "";
var succnsim = "";
var succsim = "";
var SuchThat = "";
var sum = "";
var Sum = "";
var sung = "";
var sup1$1 = "";
var sup2$1 = "";
var sup3$1 = "";
var sup = "";
var Sup = "";
var supdot = "";
var supdsub = "";
var supE = "";
var supe = "";
var supedot = "";
var Superset = "";
var SupersetEqual = "";
var suphsol = "";
var suphsub = "";
var suplarr = "";
var supmult = "";
var supnE = "";
var supne = "";
var supplus = "";
var supset = "";
var Supset = "";
var supseteq = "";
var supseteqq = "";
var supsetneq = "";
var supsetneqq = "";
var supsim = "";
var supsub = "";
var supsup = "";
var swarhk = "";
var swarr = "";
var swArr = "";
var swarrow = "";
var swnwar = "";
var szlig$1 = "";
var Tab = "\t";
var target = "";
var Tau = "";
var tau = "";
var tbrk = "";
var Tcaron = "";
var tcaron = "";
var Tcedil = "";
var tcedil = "";
var Tcy = "";
var tcy = "";
var tdot = "";
var telrec = "";
var Tfr = "";
var tfr = "";
var there4 = "";
var therefore = "";
var Therefore = "";
var Theta = "";
var theta = "";
var thetasym = "";
var thetav = "";
var thickapprox = "";
var thicksim = "";
var ThickSpace = "";
var ThinSpace = "";
var thinsp = "";
var thkap = "";
var thksim = "";
var THORN$1 = "";
var thorn$1 = "";
var tilde = "";
var Tilde = "";
var TildeEqual = "";
var TildeFullEqual = "";
var TildeTilde = "";
var timesbar = "";
var timesb = "";
var times$1 = "";
var timesd = "";
var tint = "";
var toea = "";
var topbot = "";
var topcir = "";
var esm_top = "";
var Topf = "";
var topf = "";
var topfork = "";
var tosa = "";
var tprime = "";
var trade = "";
var TRADE = "";
var triangle = "";
var triangledown = "";
var triangleleft = "";
var trianglelefteq = "";
var triangleq = "";
var triangleright = "";
var trianglerighteq = "";
var tridot = "";
var trie = "";
var triminus = "";
var TripleDot = "";
var triplus = "";
var trisb = "";
var tritime = "";
var trpezium = "";
var Tscr = "";
var tscr = "";
var TScy = "";
var tscy = "";
var TSHcy = "";
var tshcy = "";
var Tstrok = "";
var tstrok = "";
var twixt = "";
var twoheadleftarrow = "";
var twoheadrightarrow = "";
var Uacute$1 = "";
var uacute$1 = "";
var uarr = "";
var Uarr = "";
var uArr = "";
var Uarrocir = "";
var Ubrcy = "";
var ubrcy = "";
var Ubreve = "";
var ubreve = "";
var Ucirc$1 = "";
var ucirc$1 = "";
var Ucy = "";
var ucy = "";
var udarr = "";
var Udblac = "";
var udblac = "";
var udhar = "";
var ufisht = "";
var Ufr = "";
var ufr = "";
var Ugrave$1 = "";
var ugrave$1 = "";
var uHar = "";
var uharl = "";
var uharr = "";
var uhblk = "";
var ulcorn = "";
var ulcorner = "";
var ulcrop = "";
var ultri = "";
var Umacr = "";
var umacr = "";
var uml$1 = "";
var UnderBar = "_";
var UnderBrace = "";
var UnderBracket = "";
var UnderParenthesis = "";
var Union = "";
var UnionPlus = "";
var Uogon = "";
var uogon = "";
var Uopf = "";
var uopf = "";
var UpArrowBar = "";
var uparrow = "";
var UpArrow = "";
var Uparrow = "";
var UpArrowDownArrow = "";
var updownarrow = "";
var UpDownArrow = "";
var Updownarrow = "";
var UpEquilibrium = "";
var upharpoonleft = "";
var upharpoonright = "";
var uplus = "";
var UpperLeftArrow = "";
var UpperRightArrow = "";
var upsi = "";
var Upsi = "";
var upsih = "";
var Upsilon = "";
var upsilon = "";
var UpTeeArrow = "";
var UpTee = "";
var upuparrows = "";
var urcorn = "";
var urcorner = "";
var urcrop = "";
var Uring = "";
var uring = "";
var urtri = "";
var Uscr = "";
var uscr = "";
var utdot = "";
var Utilde = "";
var utilde = "";
var utri = "";
var utrif = "";
var uuarr = "";
var Uuml$1 = "";
var uuml$1 = "";
var uwangle = "";
var vangrt = "";
var varepsilon = "";
var varkappa = "";
var varnothing = "";
var varphi = "";
var varpi = "";
var varpropto = "";
var varr = "";
var vArr = "";
var varrho = "";
var varsigma = "";
var varsubsetneq = "";
var varsubsetneqq = "";
var varsupsetneq = "";
var varsupsetneqq = "";
var vartheta = "";
var vartriangleleft = "";
var vartriangleright = "";
var vBar = "";
var Vbar = "";
var vBarv = "";
var Vcy = "";
var vcy = "";
var vdash = "";
var vDash = "";
var Vdash = "";
var VDash = "";
var Vdashl = "";
var veebar = "";
var vee = "";
var Vee = "";
var veeeq = "";
var vellip = "";
var verbar = "|";
var Verbar = "";
var vert = "|";
var Vert = "";
var VerticalBar = "";
var VerticalLine = "|";
var VerticalSeparator = "";
var VerticalTilde = "";
var VeryThinSpace = "";
var Vfr = "";
var vfr = "";
var vltri = "";
var vnsub = "";
var vnsup = "";
var Vopf = "";
var vopf = "";
var vprop = "";
var vrtri = "";
var Vscr = "";
var vscr = "";
var vsubnE = "";
var vsubne = "";
var vsupnE = "";
var vsupne = "";
var Vvdash = "";
var vzigzag = "";
var Wcirc = "";
var wcirc = "";
var wedbar = "";
var wedge = "";
var Wedge = "";
var wedgeq = "";
var weierp = "";
var Wfr = "";
var wfr = "";
var Wopf = "";
var wopf = "";
var wp = "";
var wr = "";
var wreath = "";
var Wscr = "";
var wscr = "";
var xcap = "";
var xcirc = "";
var xcup = "";
var xdtri = "";
var Xfr = "";
var xfr = "";
var xharr = "";
var xhArr = "";
var Xi = "";
var xi = "";
var xlarr = "";
var xlArr = "";
var xmap = "";
var xnis = "";
var xodot = "";
var Xopf = "";
var xopf = "";
var xoplus = "";
var xotime = "";
var xrarr = "";
var xrArr = "";
var Xscr = "";
var xscr = "";
var xsqcup = "";
var xuplus = "";
var xutri = "";
var xvee = "";
var xwedge = "";
var Yacute$1 = "";
var yacute$1 = "";
var YAcy = "";
var yacy = "";
var Ycirc = "";
var ycirc = "";
var Ycy = "";
var ycy = "";
var yen$1 = "";
var Yfr = "";
var yfr = "";
var YIcy = "";
var yicy = "";
var Yopf = "";
var yopf = "";
var Yscr = "";
var yscr = "";
var YUcy = "";
var yucy = "";
var yuml$1 = "";
var Yuml = "";
var Zacute = "";
var zacute = "";
var Zcaron = "";
var zcaron = "";
var Zcy = "";
var zcy = "";
var Zdot = "";
var zdot = "";
var zeetrf = "";
var ZeroWidthSpace = "";
var Zeta = "";
var zeta = "";
var zfr = "";
var Zfr = "";
var ZHcy = "";
var zhcy = "";
var zigrarr = "";
var zopf = "";
var Zopf = "";
var Zscr = "";
var zscr = "";
var zwj = "";
var zwnj = "";
var require$$1$1 = {
    Aacute: Aacute$1,
    aacute: aacute$1,
    Abreve: Abreve,
    abreve: abreve,
    ac: ac,
    acd: acd,
    acE: acE,
    Acirc: Acirc$1,
    acirc: acirc$1,
    acute: acute$1,
    Acy: Acy,
    acy: acy,
    AElig: AElig$1,
    aelig: aelig$1,
    af: af,
    Afr: Afr,
    afr: afr,
    Agrave: Agrave$1,
    agrave: agrave$1,
    alefsym: alefsym,
    aleph: aleph,
    Alpha: Alpha,
    alpha: alpha,
    Amacr: Amacr,
    amacr: amacr,
    amalg: amalg,
    amp: amp$2,
    AMP: AMP$1,
    andand: andand,
    And: And,
    and: and,
    andd: andd,
    andslope: andslope,
    andv: andv,
    ang: ang,
    ange: ange,
    angle: angle,
    angmsdaa: angmsdaa,
    angmsdab: angmsdab,
    angmsdac: angmsdac,
    angmsdad: angmsdad,
    angmsdae: angmsdae,
    angmsdaf: angmsdaf,
    angmsdag: angmsdag,
    angmsdah: angmsdah,
    angmsd: angmsd,
    angrt: angrt,
    angrtvb: angrtvb,
    angrtvbd: angrtvbd,
    angsph: angsph,
    angst: angst,
    angzarr: angzarr,
    Aogon: Aogon,
    aogon: aogon,
    Aopf: Aopf,
    aopf: aopf,
    apacir: apacir,
    ap: ap,
    apE: apE,
    ape: ape,
    apid: apid,
    apos: apos$1,
    ApplyFunction: ApplyFunction,
    approx: approx,
    approxeq: approxeq,
    Aring: Aring$1,
    aring: aring$1,
    Ascr: Ascr,
    ascr: ascr,
    Assign: Assign,
    ast: ast,
    asymp: asymp,
    asympeq: asympeq,
    Atilde: Atilde$1,
    atilde: atilde$1,
    Auml: Auml$1,
    auml: auml$1,
    awconint: awconint,
    awint: awint,
    backcong: backcong,
    backepsilon: backepsilon,
    backprime: backprime,
    backsim: backsim,
    backsimeq: backsimeq,
    Backslash: Backslash,
    Barv: Barv,
    barvee: barvee,
    barwed: barwed,
    Barwed: Barwed,
    barwedge: barwedge,
    bbrk: bbrk,
    bbrktbrk: bbrktbrk,
    bcong: bcong,
    Bcy: Bcy,
    bcy: bcy,
    bdquo: bdquo,
    becaus: becaus,
    because: because,
    Because: Because,
    bemptyv: bemptyv,
    bepsi: bepsi,
    bernou: bernou,
    Bernoullis: Bernoullis,
    Beta: Beta,
    beta: beta,
    beth: beth,
    between: esm_between,
    Bfr: Bfr,
    bfr: bfr,
    bigcap: bigcap,
    bigcirc: bigcirc,
    bigcup: bigcup,
    bigodot: bigodot,
    bigoplus: bigoplus,
    bigotimes: bigotimes,
    bigsqcup: bigsqcup,
    bigstar: bigstar,
    bigtriangledown: bigtriangledown,
    bigtriangleup: bigtriangleup,
    biguplus: biguplus,
    bigvee: bigvee,
    bigwedge: bigwedge,
    bkarow: bkarow,
    blacklozenge: blacklozenge,
    blacksquare: blacksquare,
    blacktriangle: blacktriangle,
    blacktriangledown: blacktriangledown,
    blacktriangleleft: blacktriangleleft,
    blacktriangleright: blacktriangleright,
    blank: blank,
    blk12: blk12,
    blk14: blk14,
    blk34: blk34,
    block: block,
    bne: bne,
    bnequiv: bnequiv,
    bNot: bNot,
    bnot: bnot,
    Bopf: Bopf,
    bopf: bopf,
    bot: bot,
    bottom: bottom,
    bowtie: bowtie,
    boxbox: boxbox,
    boxdl: boxdl,
    boxdL: boxdL,
    boxDl: boxDl,
    boxDL: boxDL,
    boxdr: boxdr,
    boxdR: boxdR,
    boxDr: boxDr,
    boxDR: boxDR,
    boxh: boxh,
    boxH: boxH,
    boxhd: boxhd,
    boxHd: boxHd,
    boxhD: boxhD,
    boxHD: boxHD,
    boxhu: boxhu,
    boxHu: boxHu,
    boxhU: boxhU,
    boxHU: boxHU,
    boxminus: boxminus,
    boxplus: boxplus,
    boxtimes: boxtimes,
    boxul: boxul,
    boxuL: boxuL,
    boxUl: boxUl,
    boxUL: boxUL,
    boxur: boxur,
    boxuR: boxuR,
    boxUr: boxUr,
    boxUR: boxUR,
    boxv: boxv,
    boxV: boxV,
    boxvh: boxvh,
    boxvH: boxvH,
    boxVh: boxVh,
    boxVH: boxVH,
    boxvl: boxvl,
    boxvL: boxvL,
    boxVl: boxVl,
    boxVL: boxVL,
    boxvr: boxvr,
    boxvR: boxvR,
    boxVr: boxVr,
    boxVR: boxVR,
    bprime: bprime,
    breve: breve,
    Breve: Breve,
    brvbar: brvbar$1,
    bscr: bscr,
    Bscr: Bscr,
    bsemi: bsemi,
    bsim: bsim,
    bsime: bsime,
    bsolb: bsolb,
    bsol: bsol,
    bsolhsub: bsolhsub,
    bull: bull,
    bullet: bullet,
    bump: bump,
    bumpE: bumpE,
    bumpe: bumpe,
    Bumpeq: Bumpeq,
    bumpeq: bumpeq,
    Cacute: Cacute,
    cacute: cacute,
    capand: capand,
    capbrcup: capbrcup,
    capcap: capcap,
    cap: cap,
    Cap: Cap,
    capcup: capcup,
    capdot: capdot,
    CapitalDifferentialD: CapitalDifferentialD,
    caps: caps,
    caret: caret,
    caron: caron,
    Cayleys: Cayleys,
    ccaps: ccaps,
    Ccaron: Ccaron,
    ccaron: ccaron,
    Ccedil: Ccedil$1,
    ccedil: ccedil$1,
    Ccirc: Ccirc,
    ccirc: ccirc,
    Cconint: Cconint,
    ccups: ccups,
    ccupssm: ccupssm,
    Cdot: Cdot,
    cdot: cdot,
    cedil: cedil$1,
    Cedilla: Cedilla,
    cemptyv: cemptyv,
    cent: cent$1,
    centerdot: centerdot,
    CenterDot: CenterDot,
    cfr: cfr,
    Cfr: Cfr,
    CHcy: CHcy,
    chcy: chcy,
    check: check,
    checkmark: checkmark,
    Chi: Chi,
    chi: chi,
    circ: circ,
    circeq: circeq,
    circlearrowleft: circlearrowleft,
    circlearrowright: circlearrowright,
    circledast: circledast,
    circledcirc: circledcirc,
    circleddash: circleddash,
    CircleDot: CircleDot,
    circledR: circledR,
    circledS: circledS,
    CircleMinus: CircleMinus,
    CirclePlus: CirclePlus,
    CircleTimes: CircleTimes,
    cir: cir,
    cirE: cirE,
    cire: cire,
    cirfnint: cirfnint,
    cirmid: cirmid,
    cirscir: cirscir,
    ClockwiseContourIntegral: ClockwiseContourIntegral,
    CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
    CloseCurlyQuote: CloseCurlyQuote,
    clubs: clubs,
    clubsuit: clubsuit,
    colon: colon,
    Colon: Colon,
    Colone: Colone,
    colone: colone,
    coloneq: coloneq,
    comma: comma,
    commat: commat,
    comp: comp,
    compfn: compfn,
    complement: complement,
    complexes: complexes,
    cong: cong,
    congdot: congdot,
    Congruent: Congruent,
    conint: conint,
    Conint: Conint,
    ContourIntegral: ContourIntegral,
    copf: copf,
    Copf: Copf,
    coprod: coprod,
    Coproduct: Coproduct,
    copy: copy$1,
    COPY: COPY$1,
    copysr: copysr,
    CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
    crarr: crarr,
    cross: cross,
    Cross: Cross,
    Cscr: Cscr,
    cscr: cscr,
    csub: csub,
    csube: csube,
    csup: csup,
    csupe: csupe,
    ctdot: ctdot,
    cudarrl: cudarrl,
    cudarrr: cudarrr,
    cuepr: cuepr,
    cuesc: cuesc,
    cularr: cularr,
    cularrp: cularrp,
    cupbrcap: cupbrcap,
    cupcap: cupcap,
    CupCap: CupCap,
    cup: cup,
    Cup: Cup,
    cupcup: cupcup,
    cupdot: cupdot,
    cupor: cupor,
    cups: cups,
    curarr: curarr,
    curarrm: curarrm,
    curlyeqprec: curlyeqprec,
    curlyeqsucc: curlyeqsucc,
    curlyvee: curlyvee,
    curlywedge: curlywedge,
    curren: curren$1,
    curvearrowleft: curvearrowleft,
    curvearrowright: curvearrowright,
    cuvee: cuvee,
    cuwed: cuwed,
    cwconint: cwconint,
    cwint: cwint,
    cylcty: cylcty,
    dagger: dagger,
    Dagger: Dagger,
    daleth: daleth,
    darr: darr,
    Darr: Darr,
    dArr: dArr,
    dash: dash,
    Dashv: Dashv,
    dashv: dashv,
    dbkarow: dbkarow,
    dblac: dblac,
    Dcaron: Dcaron,
    dcaron: dcaron,
    Dcy: Dcy,
    dcy: dcy,
    ddagger: ddagger,
    ddarr: ddarr,
    DD: DD,
    dd: dd,
    DDotrahd: DDotrahd,
    ddotseq: ddotseq,
    deg: deg$1,
    Del: Del,
    Delta: Delta,
    delta: delta,
    demptyv: demptyv,
    dfisht: dfisht,
    Dfr: Dfr,
    dfr: dfr,
    dHar: dHar,
    dharl: dharl,
    dharr: dharr,
    DiacriticalAcute: DiacriticalAcute,
    DiacriticalDot: DiacriticalDot,
    DiacriticalDoubleAcute: DiacriticalDoubleAcute,
    DiacriticalGrave: DiacriticalGrave,
    DiacriticalTilde: DiacriticalTilde,
    diam: diam,
    diamond: diamond,
    Diamond: Diamond,
    diamondsuit: diamondsuit,
    diams: diams,
    die: die,
    DifferentialD: DifferentialD,
    digamma: digamma,
    disin: disin,
    div: div,
    divide: divide$1,
    divideontimes: divideontimes,
    divonx: divonx,
    DJcy: DJcy,
    djcy: djcy,
    dlcorn: dlcorn,
    dlcrop: dlcrop,
    dollar: dollar,
    Dopf: Dopf,
    dopf: dopf,
    Dot: Dot,
    dot: dot,
    DotDot: DotDot,
    doteq: doteq,
    doteqdot: doteqdot,
    DotEqual: DotEqual,
    dotminus: dotminus,
    dotplus: dotplus,
    dotsquare: dotsquare,
    doublebarwedge: doublebarwedge,
    DoubleContourIntegral: DoubleContourIntegral,
    DoubleDot: DoubleDot,
    DoubleDownArrow: DoubleDownArrow,
    DoubleLeftArrow: DoubleLeftArrow,
    DoubleLeftRightArrow: DoubleLeftRightArrow,
    DoubleLeftTee: DoubleLeftTee,
    DoubleLongLeftArrow: DoubleLongLeftArrow,
    DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
    DoubleLongRightArrow: DoubleLongRightArrow,
    DoubleRightArrow: DoubleRightArrow,
    DoubleRightTee: DoubleRightTee,
    DoubleUpArrow: DoubleUpArrow,
    DoubleUpDownArrow: DoubleUpDownArrow,
    DoubleVerticalBar: DoubleVerticalBar,
    DownArrowBar: DownArrowBar,
    downarrow: downarrow,
    DownArrow: DownArrow,
    Downarrow: Downarrow,
    DownArrowUpArrow: DownArrowUpArrow,
    DownBreve: DownBreve,
    downdownarrows: downdownarrows,
    downharpoonleft: downharpoonleft,
    downharpoonright: downharpoonright,
    DownLeftRightVector: DownLeftRightVector,
    DownLeftTeeVector: DownLeftTeeVector,
    DownLeftVectorBar: DownLeftVectorBar,
    DownLeftVector: DownLeftVector,
    DownRightTeeVector: DownRightTeeVector,
    DownRightVectorBar: DownRightVectorBar,
    DownRightVector: DownRightVector,
    DownTeeArrow: DownTeeArrow,
    DownTee: DownTee,
    drbkarow: drbkarow,
    drcorn: drcorn,
    drcrop: drcrop,
    Dscr: Dscr,
    dscr: dscr,
    DScy: DScy,
    dscy: dscy,
    dsol: dsol,
    Dstrok: Dstrok,
    dstrok: dstrok,
    dtdot: dtdot,
    dtri: dtri,
    dtrif: dtrif,
    duarr: duarr,
    duhar: duhar,
    dwangle: dwangle,
    DZcy: DZcy,
    dzcy: dzcy,
    dzigrarr: dzigrarr,
    Eacute: Eacute$1,
    eacute: eacute$1,
    easter: easter,
    Ecaron: Ecaron,
    ecaron: ecaron,
    Ecirc: Ecirc$1,
    ecirc: ecirc$1,
    ecir: ecir,
    ecolon: ecolon,
    Ecy: Ecy,
    ecy: ecy,
    eDDot: eDDot,
    Edot: Edot,
    edot: edot,
    eDot: eDot,
    ee: ee,
    efDot: efDot,
    Efr: Efr,
    efr: efr,
    eg: eg,
    Egrave: Egrave$1,
    egrave: egrave$1,
    egs: egs,
    egsdot: egsdot,
    el: el,
    Element: esm_Element,
    elinters: elinters,
    ell: ell,
    els: els,
    elsdot: elsdot,
    Emacr: Emacr,
    emacr: emacr,
    empty: esm_empty,
    emptyset: emptyset,
    EmptySmallSquare: EmptySmallSquare,
    emptyv: emptyv,
    EmptyVerySmallSquare: EmptyVerySmallSquare,
    emsp13: emsp13,
    emsp14: emsp14,
    emsp: emsp,
    ENG: ENG,
    eng: eng,
    ensp: ensp,
    Eogon: Eogon,
    eogon: eogon,
    Eopf: Eopf,
    eopf: eopf,
    epar: epar,
    eparsl: eparsl,
    eplus: eplus,
    epsi: epsi,
    Epsilon: Epsilon,
    epsilon: epsilon,
    epsiv: epsiv,
    eqcirc: eqcirc,
    eqcolon: eqcolon,
    eqsim: eqsim,
    eqslantgtr: eqslantgtr,
    eqslantless: eqslantless,
    Equal: Equal,
    equals: equals,
    EqualTilde: EqualTilde,
    equest: equest,
    Equilibrium: Equilibrium,
    equiv: equiv,
    equivDD: equivDD,
    eqvparsl: eqvparsl,
    erarr: erarr,
    erDot: erDot,
    escr: escr,
    Escr: Escr,
    esdot: esdot,
    Esim: Esim,
    esim: esim,
    Eta: Eta,
    eta: eta,
    ETH: ETH$1,
    eth: eth$1,
    Euml: Euml$1,
    euml: euml$1,
    euro: euro,
    excl: excl,
    exist: exist,
    Exists: Exists,
    expectation: expectation,
    exponentiale: exponentiale,
    ExponentialE: ExponentialE,
    fallingdotseq: fallingdotseq,
    Fcy: Fcy,
    fcy: fcy,
    female: female,
    ffilig: ffilig,
    fflig: fflig,
    ffllig: ffllig,
    Ffr: Ffr,
    ffr: ffr,
    filig: filig,
    FilledSmallSquare: FilledSmallSquare,
    FilledVerySmallSquare: FilledVerySmallSquare,
    fjlig: fjlig,
    flat: flat,
    fllig: fllig,
    fltns: fltns,
    fnof: fnof,
    Fopf: Fopf,
    fopf: fopf,
    forall: forall,
    ForAll: ForAll,
    fork: fork,
    forkv: forkv,
    Fouriertrf: Fouriertrf,
    fpartint: fpartint,
    frac12: frac12$1,
    frac13: frac13,
    frac14: frac14$1,
    frac15: frac15,
    frac16: frac16,
    frac18: frac18,
    frac23: frac23,
    frac25: frac25,
    frac34: frac34$1,
    frac35: frac35,
    frac38: frac38,
    frac45: frac45,
    frac56: frac56,
    frac58: frac58,
    frac78: frac78,
    frasl: frasl,
    frown: frown,
    fscr: fscr,
    Fscr: Fscr,
    gacute: gacute,
    Gamma: Gamma,
    gamma: gamma,
    Gammad: Gammad,
    gammad: gammad,
    gap: gap,
    Gbreve: Gbreve,
    gbreve: gbreve,
    Gcedil: Gcedil,
    Gcirc: Gcirc,
    gcirc: gcirc,
    Gcy: Gcy,
    gcy: gcy,
    Gdot: Gdot,
    gdot: gdot,
    ge: ge,
    gE: gE,
    gEl: gEl,
    gel: gel,
    geq: geq,
    geqq: geqq,
    geqslant: geqslant,
    gescc: gescc,
    ges: ges,
    gesdot: gesdot,
    gesdoto: gesdoto,
    gesdotol: gesdotol,
    gesl: gesl,
    gesles: gesles,
    Gfr: Gfr,
    gfr: gfr,
    gg: gg,
    Gg: Gg,
    ggg: ggg,
    gimel: gimel,
    GJcy: GJcy,
    gjcy: gjcy,
    gla: gla,
    gl: gl,
    glE: glE,
    glj: glj,
    gnap: gnap,
    gnapprox: gnapprox,
    gne: gne,
    gnE: gnE,
    gneq: gneq,
    gneqq: gneqq,
    gnsim: gnsim,
    Gopf: Gopf,
    gopf: gopf,
    grave: grave,
    GreaterEqual: GreaterEqual,
    GreaterEqualLess: GreaterEqualLess,
    GreaterFullEqual: GreaterFullEqual,
    GreaterGreater: GreaterGreater,
    GreaterLess: GreaterLess,
    GreaterSlantEqual: GreaterSlantEqual,
    GreaterTilde: GreaterTilde,
    Gscr: Gscr,
    gscr: gscr,
    gsim: gsim,
    gsime: gsime,
    gsiml: gsiml,
    gtcc: gtcc,
    gtcir: gtcir,
    gt: gt$2,
    GT: GT$1,
    Gt: Gt,
    gtdot: gtdot,
    gtlPar: gtlPar,
    gtquest: gtquest,
    gtrapprox: gtrapprox,
    gtrarr: gtrarr,
    gtrdot: gtrdot,
    gtreqless: gtreqless,
    gtreqqless: gtreqqless,
    gtrless: gtrless,
    gtrsim: gtrsim,
    gvertneqq: gvertneqq,
    gvnE: gvnE,
    Hacek: Hacek,
    hairsp: hairsp,
    half: half,
    hamilt: hamilt,
    HARDcy: HARDcy,
    hardcy: hardcy,
    harrcir: harrcir,
    harr: harr,
    hArr: hArr,
    harrw: harrw,
    Hat: Hat,
    hbar: hbar,
    Hcirc: Hcirc,
    hcirc: hcirc,
    hearts: hearts,
    heartsuit: heartsuit,
    hellip: hellip,
    hercon: hercon,
    hfr: hfr,
    Hfr: Hfr,
    HilbertSpace: HilbertSpace,
    hksearow: hksearow,
    hkswarow: hkswarow,
    hoarr: hoarr,
    homtht: homtht,
    hookleftarrow: hookleftarrow,
    hookrightarrow: hookrightarrow,
    hopf: hopf,
    Hopf: Hopf,
    horbar: horbar,
    HorizontalLine: HorizontalLine,
    hscr: hscr,
    Hscr: Hscr,
    hslash: hslash,
    Hstrok: Hstrok,
    hstrok: hstrok,
    HumpDownHump: HumpDownHump,
    HumpEqual: HumpEqual,
    hybull: hybull,
    hyphen: hyphen,
    Iacute: Iacute$1,
    iacute: iacute$1,
    ic: ic,
    Icirc: Icirc$1,
    icirc: icirc$1,
    Icy: Icy,
    icy: icy,
    Idot: Idot,
    IEcy: IEcy,
    iecy: iecy,
    iexcl: iexcl$1,
    iff: iff,
    ifr: ifr,
    Ifr: Ifr,
    Igrave: Igrave$1,
    igrave: igrave$1,
    ii: ii,
    iiiint: iiiint,
    iiint: iiint,
    iinfin: iinfin,
    iiota: iiota,
    IJlig: IJlig,
    ijlig: ijlig,
    Imacr: Imacr,
    imacr: imacr,
    image: esm_image,
    ImaginaryI: ImaginaryI,
    imagline: imagline,
    imagpart: imagpart,
    imath: imath,
    Im: Im,
    imof: imof,
    imped: imped,
    Implies: Implies,
    incare: incare,
    "in": "",
    infin: infin,
    infintie: infintie,
    inodot: inodot,
    intcal: intcal,
    int: esm_int,
    Int: Int,
    integers: integers,
    Integral: Integral,
    intercal: intercal,
    Intersection: Intersection,
    intlarhk: intlarhk,
    intprod: intprod,
    InvisibleComma: InvisibleComma,
    InvisibleTimes: InvisibleTimes,
    IOcy: IOcy,
    iocy: iocy,
    Iogon: Iogon,
    iogon: iogon,
    Iopf: Iopf,
    iopf: iopf,
    Iota: Iota,
    iota: iota,
    iprod: iprod,
    iquest: iquest$1,
    iscr: iscr,
    Iscr: Iscr,
    isin: isin,
    isindot: isindot,
    isinE: isinE,
    isins: isins,
    isinsv: isinsv,
    isinv: isinv,
    it: it,
    Itilde: Itilde,
    itilde: itilde,
    Iukcy: Iukcy,
    iukcy: iukcy,
    Iuml: Iuml$1,
    iuml: iuml$1,
    Jcirc: Jcirc,
    jcirc: jcirc,
    Jcy: Jcy,
    jcy: jcy,
    Jfr: Jfr,
    jfr: jfr,
    jmath: jmath,
    Jopf: Jopf,
    jopf: jopf,
    Jscr: Jscr,
    jscr: jscr,
    Jsercy: Jsercy,
    jsercy: jsercy,
    Jukcy: Jukcy,
    jukcy: jukcy,
    Kappa: Kappa,
    kappa: kappa,
    kappav: kappav,
    Kcedil: Kcedil,
    kcedil: kcedil,
    Kcy: Kcy,
    kcy: kcy,
    Kfr: Kfr,
    kfr: kfr,
    kgreen: kgreen,
    KHcy: KHcy,
    khcy: khcy,
    KJcy: KJcy,
    kjcy: kjcy,
    Kopf: Kopf,
    kopf: kopf,
    Kscr: Kscr,
    kscr: kscr,
    lAarr: lAarr,
    Lacute: Lacute,
    lacute: lacute,
    laemptyv: laemptyv,
    lagran: lagran,
    Lambda: Lambda,
    lambda: lambda,
    lang: lang,
    Lang: Lang,
    langd: langd,
    langle: langle,
    lap: lap,
    Laplacetrf: Laplacetrf,
    laquo: laquo$1,
    larrb: larrb,
    larrbfs: larrbfs,
    larr: larr,
    Larr: Larr,
    lArr: lArr,
    larrfs: larrfs,
    larrhk: larrhk,
    larrlp: larrlp,
    larrpl: larrpl,
    larrsim: larrsim,
    larrtl: larrtl,
    latail: latail,
    lAtail: lAtail,
    lat: lat,
    late: late,
    lates: lates,
    lbarr: lbarr,
    lBarr: lBarr,
    lbbrk: lbbrk,
    lbrace: lbrace,
    lbrack: lbrack,
    lbrke: lbrke,
    lbrksld: lbrksld,
    lbrkslu: lbrkslu,
    Lcaron: Lcaron,
    lcaron: lcaron,
    Lcedil: Lcedil,
    lcedil: lcedil,
    lceil: lceil,
    lcub: lcub,
    Lcy: Lcy,
    lcy: lcy,
    ldca: ldca,
    ldquo: ldquo,
    ldquor: ldquor,
    ldrdhar: ldrdhar,
    ldrushar: ldrushar,
    ldsh: ldsh,
    le: le,
    lE: lE,
    LeftAngleBracket: LeftAngleBracket,
    LeftArrowBar: LeftArrowBar,
    leftarrow: leftarrow,
    LeftArrow: LeftArrow,
    Leftarrow: Leftarrow,
    LeftArrowRightArrow: LeftArrowRightArrow,
    leftarrowtail: leftarrowtail,
    LeftCeiling: LeftCeiling,
    LeftDoubleBracket: LeftDoubleBracket,
    LeftDownTeeVector: LeftDownTeeVector,
    LeftDownVectorBar: LeftDownVectorBar,
    LeftDownVector: LeftDownVector,
    LeftFloor: LeftFloor,
    leftharpoondown: leftharpoondown,
    leftharpoonup: leftharpoonup,
    leftleftarrows: leftleftarrows,
    leftrightarrow: leftrightarrow,
    LeftRightArrow: LeftRightArrow,
    Leftrightarrow: Leftrightarrow,
    leftrightarrows: leftrightarrows,
    leftrightharpoons: leftrightharpoons,
    leftrightsquigarrow: leftrightsquigarrow,
    LeftRightVector: LeftRightVector,
    LeftTeeArrow: LeftTeeArrow,
    LeftTee: LeftTee,
    LeftTeeVector: LeftTeeVector,
    leftthreetimes: leftthreetimes,
    LeftTriangleBar: LeftTriangleBar,
    LeftTriangle: LeftTriangle,
    LeftTriangleEqual: LeftTriangleEqual,
    LeftUpDownVector: LeftUpDownVector,
    LeftUpTeeVector: LeftUpTeeVector,
    LeftUpVectorBar: LeftUpVectorBar,
    LeftUpVector: LeftUpVector,
    LeftVectorBar: LeftVectorBar,
    LeftVector: LeftVector,
    lEg: lEg,
    leg: leg,
    leq: leq,
    leqq: leqq,
    leqslant: leqslant,
    lescc: lescc,
    les: les,
    lesdot: lesdot,
    lesdoto: lesdoto,
    lesdotor: lesdotor,
    lesg: lesg,
    lesges: lesges,
    lessapprox: lessapprox,
    lessdot: lessdot,
    lesseqgtr: lesseqgtr,
    lesseqqgtr: lesseqqgtr,
    LessEqualGreater: LessEqualGreater,
    LessFullEqual: LessFullEqual,
    LessGreater: LessGreater,
    lessgtr: lessgtr,
    LessLess: LessLess,
    lesssim: lesssim,
    LessSlantEqual: LessSlantEqual,
    LessTilde: LessTilde,
    lfisht: lfisht,
    lfloor: lfloor,
    Lfr: Lfr,
    lfr: lfr,
    lg: lg,
    lgE: lgE,
    lHar: lHar,
    lhard: lhard,
    lharu: lharu,
    lharul: lharul,
    lhblk: lhblk,
    LJcy: LJcy,
    ljcy: ljcy,
    llarr: llarr,
    ll: ll,
    Ll: Ll,
    llcorner: llcorner,
    Lleftarrow: Lleftarrow,
    llhard: llhard,
    lltri: lltri,
    Lmidot: Lmidot,
    lmidot: lmidot,
    lmoustache: lmoustache,
    lmoust: lmoust,
    lnap: lnap,
    lnapprox: lnapprox,
    lne: lne,
    lnE: lnE,
    lneq: lneq,
    lneqq: lneqq,
    lnsim: lnsim,
    loang: loang,
    loarr: loarr,
    lobrk: lobrk,
    longleftarrow: longleftarrow,
    LongLeftArrow: LongLeftArrow,
    Longleftarrow: Longleftarrow,
    longleftrightarrow: longleftrightarrow,
    LongLeftRightArrow: LongLeftRightArrow,
    Longleftrightarrow: Longleftrightarrow,
    longmapsto: longmapsto,
    longrightarrow: longrightarrow,
    LongRightArrow: LongRightArrow,
    Longrightarrow: Longrightarrow,
    looparrowleft: looparrowleft,
    looparrowright: looparrowright,
    lopar: lopar,
    Lopf: Lopf,
    lopf: lopf,
    loplus: loplus,
    lotimes: lotimes,
    lowast: lowast,
    lowbar: lowbar,
    LowerLeftArrow: LowerLeftArrow,
    LowerRightArrow: LowerRightArrow,
    loz: loz,
    lozenge: lozenge,
    lozf: lozf,
    lpar: lpar,
    lparlt: lparlt,
    lrarr: lrarr,
    lrcorner: lrcorner,
    lrhar: lrhar,
    lrhard: lrhard,
    lrm: lrm,
    lrtri: lrtri,
    lsaquo: lsaquo,
    lscr: lscr,
    Lscr: Lscr,
    lsh: lsh,
    Lsh: Lsh,
    lsim: lsim,
    lsime: lsime,
    lsimg: lsimg,
    lsqb: lsqb,
    lsquo: lsquo,
    lsquor: lsquor,
    Lstrok: Lstrok,
    lstrok: lstrok,
    ltcc: ltcc,
    ltcir: ltcir,
    lt: lt$2,
    LT: LT$1,
    Lt: Lt,
    ltdot: ltdot,
    lthree: lthree,
    ltimes: ltimes,
    ltlarr: ltlarr,
    ltquest: ltquest,
    ltri: ltri,
    ltrie: ltrie,
    ltrif: ltrif,
    ltrPar: ltrPar,
    lurdshar: lurdshar,
    luruhar: luruhar,
    lvertneqq: lvertneqq,
    lvnE: lvnE,
    macr: macr$1,
    male: male,
    malt: malt,
    maltese: maltese,
    "Map": "",
    map: map,
    mapsto: mapsto,
    mapstodown: mapstodown,
    mapstoleft: mapstoleft,
    mapstoup: mapstoup,
    marker: marker,
    mcomma: mcomma,
    Mcy: Mcy,
    mcy: mcy,
    mdash: mdash,
    mDDot: mDDot,
    measuredangle: measuredangle,
    MediumSpace: MediumSpace,
    Mellintrf: Mellintrf,
    Mfr: Mfr,
    mfr: mfr,
    mho: mho,
    micro: micro$1,
    midast: midast,
    midcir: midcir,
    mid: mid,
    middot: middot$1,
    minusb: minusb,
    minus: minus,
    minusd: minusd,
    minusdu: minusdu,
    MinusPlus: MinusPlus,
    mlcp: mlcp,
    mldr: mldr,
    mnplus: mnplus,
    models: models,
    Mopf: Mopf,
    mopf: mopf,
    mp: mp,
    mscr: mscr,
    Mscr: Mscr,
    mstpos: mstpos,
    Mu: Mu,
    mu: mu,
    multimap: multimap,
    mumap: mumap,
    nabla: nabla,
    Nacute: Nacute,
    nacute: nacute,
    nang: nang,
    nap: nap,
    napE: napE,
    napid: napid,
    napos: napos,
    napprox: napprox,
    natural: natural,
    naturals: naturals,
    natur: natur,
    nbsp: nbsp$1,
    nbump: nbump,
    nbumpe: nbumpe,
    ncap: ncap,
    Ncaron: Ncaron,
    ncaron: ncaron,
    Ncedil: Ncedil,
    ncedil: ncedil,
    ncong: ncong,
    ncongdot: ncongdot,
    ncup: ncup,
    Ncy: Ncy,
    ncy: ncy,
    ndash: ndash,
    nearhk: nearhk,
    nearr: nearr,
    neArr: neArr,
    nearrow: nearrow,
    ne: ne,
    nedot: nedot,
    NegativeMediumSpace: NegativeMediumSpace,
    NegativeThickSpace: NegativeThickSpace,
    NegativeThinSpace: NegativeThinSpace,
    NegativeVeryThinSpace: NegativeVeryThinSpace,
    nequiv: nequiv,
    nesear: nesear,
    nesim: nesim,
    NestedGreaterGreater: NestedGreaterGreater,
    NestedLessLess: NestedLessLess,
    NewLine: NewLine,
    nexist: nexist,
    nexists: nexists,
    Nfr: Nfr,
    nfr: nfr,
    ngE: ngE,
    nge: nge,
    ngeq: ngeq,
    ngeqq: ngeqq,
    ngeqslant: ngeqslant,
    nges: nges,
    nGg: nGg,
    ngsim: ngsim,
    nGt: nGt,
    ngt: ngt,
    ngtr: ngtr,
    nGtv: nGtv,
    nharr: nharr,
    nhArr: nhArr,
    nhpar: nhpar,
    ni: ni,
    nis: nis,
    nisd: nisd,
    niv: niv,
    NJcy: NJcy,
    njcy: njcy,
    nlarr: nlarr,
    nlArr: nlArr,
    nldr: nldr,
    nlE: nlE,
    nle: nle,
    nleftarrow: nleftarrow,
    nLeftarrow: nLeftarrow,
    nleftrightarrow: nleftrightarrow,
    nLeftrightarrow: nLeftrightarrow,
    nleq: nleq,
    nleqq: nleqq,
    nleqslant: nleqslant,
    nles: nles,
    nless: nless,
    nLl: nLl,
    nlsim: nlsim,
    nLt: nLt,
    nlt: nlt,
    nltri: nltri,
    nltrie: nltrie,
    nLtv: nLtv,
    nmid: nmid,
    NoBreak: NoBreak,
    NonBreakingSpace: NonBreakingSpace,
    nopf: nopf,
    Nopf: Nopf,
    Not: Not,
    not: not$1,
    NotCongruent: NotCongruent,
    NotCupCap: NotCupCap,
    NotDoubleVerticalBar: NotDoubleVerticalBar,
    NotElement: NotElement,
    NotEqual: NotEqual,
    NotEqualTilde: NotEqualTilde,
    NotExists: NotExists,
    NotGreater: NotGreater,
    NotGreaterEqual: NotGreaterEqual,
    NotGreaterFullEqual: NotGreaterFullEqual,
    NotGreaterGreater: NotGreaterGreater,
    NotGreaterLess: NotGreaterLess,
    NotGreaterSlantEqual: NotGreaterSlantEqual,
    NotGreaterTilde: NotGreaterTilde,
    NotHumpDownHump: NotHumpDownHump,
    NotHumpEqual: NotHumpEqual,
    notin: notin,
    notindot: notindot,
    notinE: notinE,
    notinva: notinva,
    notinvb: notinvb,
    notinvc: notinvc,
    NotLeftTriangleBar: NotLeftTriangleBar,
    NotLeftTriangle: NotLeftTriangle,
    NotLeftTriangleEqual: NotLeftTriangleEqual,
    NotLess: NotLess,
    NotLessEqual: NotLessEqual,
    NotLessGreater: NotLessGreater,
    NotLessLess: NotLessLess,
    NotLessSlantEqual: NotLessSlantEqual,
    NotLessTilde: NotLessTilde,
    NotNestedGreaterGreater: NotNestedGreaterGreater,
    NotNestedLessLess: NotNestedLessLess,
    notni: notni,
    notniva: notniva,
    notnivb: notnivb,
    notnivc: notnivc,
    NotPrecedes: NotPrecedes,
    NotPrecedesEqual: NotPrecedesEqual,
    NotPrecedesSlantEqual: NotPrecedesSlantEqual,
    NotReverseElement: NotReverseElement,
    NotRightTriangleBar: NotRightTriangleBar,
    NotRightTriangle: NotRightTriangle,
    NotRightTriangleEqual: NotRightTriangleEqual,
    NotSquareSubset: NotSquareSubset,
    NotSquareSubsetEqual: NotSquareSubsetEqual,
    NotSquareSuperset: NotSquareSuperset,
    NotSquareSupersetEqual: NotSquareSupersetEqual,
    NotSubset: NotSubset,
    NotSubsetEqual: NotSubsetEqual,
    NotSucceeds: NotSucceeds,
    NotSucceedsEqual: NotSucceedsEqual,
    NotSucceedsSlantEqual: NotSucceedsSlantEqual,
    NotSucceedsTilde: NotSucceedsTilde,
    NotSuperset: NotSuperset,
    NotSupersetEqual: NotSupersetEqual,
    NotTilde: NotTilde,
    NotTildeEqual: NotTildeEqual,
    NotTildeFullEqual: NotTildeFullEqual,
    NotTildeTilde: NotTildeTilde,
    NotVerticalBar: NotVerticalBar,
    nparallel: nparallel,
    npar: npar,
    nparsl: nparsl,
    npart: npart,
    npolint: npolint,
    npr: npr,
    nprcue: nprcue,
    nprec: nprec,
    npreceq: npreceq,
    npre: npre,
    nrarrc: nrarrc,
    nrarr: nrarr,
    nrArr: nrArr,
    nrarrw: nrarrw,
    nrightarrow: nrightarrow,
    nRightarrow: nRightarrow,
    nrtri: nrtri,
    nrtrie: nrtrie,
    nsc: nsc,
    nsccue: nsccue,
    nsce: nsce,
    Nscr: Nscr,
    nscr: nscr,
    nshortmid: nshortmid,
    nshortparallel: nshortparallel,
    nsim: nsim,
    nsime: nsime,
    nsimeq: nsimeq,
    nsmid: nsmid,
    nspar: nspar,
    nsqsube: nsqsube,
    nsqsupe: nsqsupe,
    nsub: nsub,
    nsubE: nsubE,
    nsube: nsube,
    nsubset: nsubset,
    nsubseteq: nsubseteq,
    nsubseteqq: nsubseteqq,
    nsucc: nsucc,
    nsucceq: nsucceq,
    nsup: nsup,
    nsupE: nsupE,
    nsupe: nsupe,
    nsupset: nsupset,
    nsupseteq: nsupseteq,
    nsupseteqq: nsupseteqq,
    ntgl: ntgl,
    Ntilde: Ntilde$1,
    ntilde: ntilde$1,
    ntlg: ntlg,
    ntriangleleft: ntriangleleft,
    ntrianglelefteq: ntrianglelefteq,
    ntriangleright: ntriangleright,
    ntrianglerighteq: ntrianglerighteq,
    Nu: Nu,
    nu: nu,
    num: num,
    numero: numero,
    numsp: numsp,
    nvap: nvap,
    nvdash: nvdash,
    nvDash: nvDash,
    nVdash: nVdash,
    nVDash: nVDash,
    nvge: nvge,
    nvgt: nvgt,
    nvHarr: nvHarr,
    nvinfin: nvinfin,
    nvlArr: nvlArr,
    nvle: nvle,
    nvlt: nvlt,
    nvltrie: nvltrie,
    nvrArr: nvrArr,
    nvrtrie: nvrtrie,
    nvsim: nvsim,
    nwarhk: nwarhk,
    nwarr: nwarr,
    nwArr: nwArr,
    nwarrow: nwarrow,
    nwnear: nwnear,
    Oacute: Oacute$1,
    oacute: oacute$1,
    oast: oast,
    Ocirc: Ocirc$1,
    ocirc: ocirc$1,
    ocir: ocir,
    Ocy: Ocy,
    ocy: ocy,
    odash: odash,
    Odblac: Odblac,
    odblac: odblac,
    odiv: odiv,
    odot: odot,
    odsold: odsold,
    OElig: OElig,
    oelig: oelig,
    ofcir: ofcir,
    Ofr: Ofr,
    ofr: ofr,
    ogon: ogon,
    Ograve: Ograve$1,
    ograve: ograve$1,
    ogt: ogt,
    ohbar: ohbar,
    ohm: ohm,
    oint: oint,
    olarr: olarr,
    olcir: olcir,
    olcross: olcross,
    oline: oline,
    olt: olt,
    Omacr: Omacr,
    omacr: omacr,
    Omega: Omega,
    omega: omega,
    Omicron: Omicron,
    omicron: omicron,
    omid: omid,
    ominus: ominus,
    Oopf: Oopf,
    oopf: oopf,
    opar: opar,
    OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
    OpenCurlyQuote: OpenCurlyQuote,
    operp: operp,
    oplus: oplus,
    orarr: orarr,
    Or: Or,
    or: or,
    ord: ord,
    order: order,
    orderof: orderof,
    ordf: ordf$1,
    ordm: ordm$1,
    origof: origof,
    oror: oror,
    orslope: orslope,
    orv: orv,
    oS: oS,
    Oscr: Oscr,
    oscr: oscr,
    Oslash: Oslash$1,
    oslash: oslash$1,
    osol: osol,
    Otilde: Otilde$1,
    otilde: otilde$1,
    otimesas: otimesas,
    Otimes: Otimes,
    otimes: otimes,
    Ouml: Ouml$1,
    ouml: ouml$1,
    ovbar: ovbar,
    OverBar: OverBar,
    OverBrace: OverBrace,
    OverBracket: OverBracket,
    OverParenthesis: OverParenthesis,
    para: para$1,
    parallel: parallel,
    par: par,
    parsim: parsim,
    parsl: parsl,
    part: part,
    PartialD: PartialD,
    Pcy: Pcy,
    pcy: pcy,
    percnt: percnt,
    period: period,
    permil: permil,
    perp: perp,
    pertenk: pertenk,
    Pfr: Pfr,
    pfr: pfr,
    Phi: Phi,
    phi: phi,
    phiv: phiv,
    phmmat: phmmat,
    phone: phone,
    Pi: Pi,
    pi: pi,
    pitchfork: pitchfork,
    piv: piv,
    planck: planck,
    planckh: planckh,
    plankv: plankv,
    plusacir: plusacir,
    plusb: plusb,
    pluscir: pluscir,
    plus: plus,
    plusdo: plusdo,
    plusdu: plusdu,
    pluse: pluse,
    PlusMinus: PlusMinus,
    plusmn: plusmn$1,
    plussim: plussim,
    plustwo: plustwo,
    pm: pm,
    Poincareplane: Poincareplane,
    pointint: pointint,
    popf: popf,
    Popf: Popf,
    pound: pound$1,
    prap: prap,
    Pr: Pr,
    pr: pr,
    prcue: prcue,
    precapprox: precapprox,
    prec: prec,
    preccurlyeq: preccurlyeq,
    Precedes: Precedes,
    PrecedesEqual: PrecedesEqual,
    PrecedesSlantEqual: PrecedesSlantEqual,
    PrecedesTilde: PrecedesTilde,
    preceq: preceq,
    precnapprox: precnapprox,
    precneqq: precneqq,
    precnsim: precnsim,
    pre: pre,
    prE: prE,
    precsim: precsim,
    prime: prime,
    Prime: Prime,
    primes: primes,
    prnap: prnap,
    prnE: prnE,
    prnsim: prnsim,
    prod: prod,
    Product: Product,
    profalar: profalar,
    profline: profline,
    profsurf: profsurf,
    prop: prop,
    Proportional: Proportional,
    Proportion: Proportion,
    propto: propto,
    prsim: prsim,
    prurel: prurel,
    Pscr: Pscr,
    pscr: pscr,
    Psi: Psi,
    psi: psi,
    puncsp: puncsp,
    Qfr: Qfr,
    qfr: qfr,
    qint: qint,
    qopf: qopf,
    Qopf: Qopf,
    qprime: qprime,
    Qscr: Qscr,
    qscr: qscr,
    quaternions: quaternions,
    quatint: quatint,
    quest: quest,
    questeq: questeq,
    quot: quot$2,
    QUOT: QUOT$1,
    rAarr: rAarr,
    race: race,
    Racute: Racute,
    racute: racute,
    radic: radic,
    raemptyv: raemptyv,
    rang: rang,
    Rang: Rang,
    rangd: rangd,
    range: range,
    rangle: rangle,
    raquo: raquo$1,
    rarrap: rarrap,
    rarrb: rarrb,
    rarrbfs: rarrbfs,
    rarrc: rarrc,
    rarr: rarr,
    Rarr: Rarr,
    rArr: rArr,
    rarrfs: rarrfs,
    rarrhk: rarrhk,
    rarrlp: rarrlp,
    rarrpl: rarrpl,
    rarrsim: rarrsim,
    Rarrtl: Rarrtl,
    rarrtl: rarrtl,
    rarrw: rarrw,
    ratail: ratail,
    rAtail: rAtail,
    ratio: ratio,
    rationals: rationals,
    rbarr: rbarr,
    rBarr: rBarr,
    RBarr: RBarr,
    rbbrk: rbbrk,
    rbrace: rbrace,
    rbrack: rbrack,
    rbrke: rbrke,
    rbrksld: rbrksld,
    rbrkslu: rbrkslu,
    Rcaron: Rcaron,
    rcaron: rcaron,
    Rcedil: Rcedil,
    rcedil: rcedil,
    rceil: rceil,
    rcub: rcub,
    Rcy: Rcy,
    rcy: rcy,
    rdca: rdca,
    rdldhar: rdldhar,
    rdquo: rdquo,
    rdquor: rdquor,
    rdsh: rdsh,
    real: real,
    realine: realine,
    realpart: realpart,
    reals: reals,
    Re: Re,
    rect: rect,
    reg: reg$1,
    REG: REG$1,
    ReverseElement: ReverseElement,
    ReverseEquilibrium: ReverseEquilibrium,
    ReverseUpEquilibrium: ReverseUpEquilibrium,
    rfisht: rfisht,
    rfloor: rfloor,
    rfr: rfr,
    Rfr: Rfr,
    rHar: rHar,
    rhard: rhard,
    rharu: rharu,
    rharul: rharul,
    Rho: Rho,
    rho: rho,
    rhov: rhov,
    RightAngleBracket: RightAngleBracket,
    RightArrowBar: RightArrowBar,
    rightarrow: rightarrow,
    RightArrow: RightArrow,
    Rightarrow: Rightarrow,
    RightArrowLeftArrow: RightArrowLeftArrow,
    rightarrowtail: rightarrowtail,
    RightCeiling: RightCeiling,
    RightDoubleBracket: RightDoubleBracket,
    RightDownTeeVector: RightDownTeeVector,
    RightDownVectorBar: RightDownVectorBar,
    RightDownVector: RightDownVector,
    RightFloor: RightFloor,
    rightharpoondown: rightharpoondown,
    rightharpoonup: rightharpoonup,
    rightleftarrows: rightleftarrows,
    rightleftharpoons: rightleftharpoons,
    rightrightarrows: rightrightarrows,
    rightsquigarrow: rightsquigarrow,
    RightTeeArrow: RightTeeArrow,
    RightTee: RightTee,
    RightTeeVector: RightTeeVector,
    rightthreetimes: rightthreetimes,
    RightTriangleBar: RightTriangleBar,
    RightTriangle: RightTriangle,
    RightTriangleEqual: RightTriangleEqual,
    RightUpDownVector: RightUpDownVector,
    RightUpTeeVector: RightUpTeeVector,
    RightUpVectorBar: RightUpVectorBar,
    RightUpVector: RightUpVector,
    RightVectorBar: RightVectorBar,
    RightVector: RightVector,
    ring: ring,
    risingdotseq: risingdotseq,
    rlarr: rlarr,
    rlhar: rlhar,
    rlm: rlm,
    rmoustache: rmoustache,
    rmoust: rmoust,
    rnmid: rnmid,
    roang: roang,
    roarr: roarr,
    robrk: robrk,
    ropar: ropar,
    ropf: ropf,
    Ropf: Ropf,
    roplus: roplus,
    rotimes: rotimes,
    RoundImplies: RoundImplies,
    rpar: rpar,
    rpargt: rpargt,
    rppolint: rppolint,
    rrarr: rrarr,
    Rrightarrow: Rrightarrow,
    rsaquo: rsaquo,
    rscr: rscr,
    Rscr: Rscr,
    rsh: rsh,
    Rsh: Rsh,
    rsqb: rsqb,
    rsquo: rsquo,
    rsquor: rsquor,
    rthree: rthree,
    rtimes: rtimes,
    rtri: rtri,
    rtrie: rtrie,
    rtrif: rtrif,
    rtriltri: rtriltri,
    RuleDelayed: RuleDelayed,
    ruluhar: ruluhar,
    rx: rx,
    Sacute: Sacute,
    sacute: sacute,
    sbquo: sbquo,
    scap: scap,
    Scaron: Scaron,
    scaron: scaron,
    Sc: Sc,
    sc: sc,
    sccue: sccue,
    sce: sce,
    scE: scE,
    Scedil: Scedil,
    scedil: scedil,
    Scirc: Scirc,
    scirc: scirc,
    scnap: scnap,
    scnE: scnE,
    scnsim: scnsim,
    scpolint: scpolint,
    scsim: scsim,
    Scy: Scy,
    scy: scy,
    sdotb: sdotb,
    sdot: sdot,
    sdote: sdote,
    searhk: searhk,
    searr: searr,
    seArr: seArr,
    searrow: searrow,
    sect: sect$1,
    semi: semi,
    seswar: seswar,
    setminus: setminus,
    setmn: setmn,
    sext: sext,
    Sfr: Sfr,
    sfr: sfr,
    sfrown: sfrown,
    sharp: sharp,
    SHCHcy: SHCHcy,
    shchcy: shchcy,
    SHcy: SHcy,
    shcy: shcy,
    ShortDownArrow: ShortDownArrow,
    ShortLeftArrow: ShortLeftArrow,
    shortmid: shortmid,
    shortparallel: shortparallel,
    ShortRightArrow: ShortRightArrow,
    ShortUpArrow: ShortUpArrow,
    shy: shy$1,
    Sigma: Sigma,
    sigma: sigma,
    sigmaf: sigmaf,
    sigmav: sigmav,
    sim: sim,
    simdot: simdot,
    sime: sime,
    simeq: simeq,
    simg: simg,
    simgE: simgE,
    siml: siml,
    simlE: simlE,
    simne: simne,
    simplus: simplus,
    simrarr: simrarr,
    slarr: slarr,
    SmallCircle: SmallCircle,
    smallsetminus: smallsetminus,
    smashp: smashp,
    smeparsl: smeparsl,
    smid: smid,
    smile: smile,
    smt: smt,
    smte: smte,
    smtes: smtes,
    SOFTcy: SOFTcy,
    softcy: softcy,
    solbar: solbar,
    solb: solb,
    sol: sol,
    Sopf: Sopf,
    sopf: sopf,
    spades: spades,
    spadesuit: spadesuit,
    spar: spar,
    sqcap: sqcap,
    sqcaps: sqcaps,
    sqcup: sqcup,
    sqcups: sqcups,
    Sqrt: Sqrt,
    sqsub: sqsub,
    sqsube: sqsube,
    sqsubset: sqsubset,
    sqsubseteq: sqsubseteq,
    sqsup: sqsup,
    sqsupe: sqsupe,
    sqsupset: sqsupset,
    sqsupseteq: sqsupseteq,
    square: square,
    Square: Square,
    SquareIntersection: SquareIntersection,
    SquareSubset: SquareSubset,
    SquareSubsetEqual: SquareSubsetEqual,
    SquareSuperset: SquareSuperset,
    SquareSupersetEqual: SquareSupersetEqual,
    SquareUnion: SquareUnion,
    squarf: squarf,
    squ: squ,
    squf: squf,
    srarr: srarr,
    Sscr: Sscr,
    sscr: sscr,
    ssetmn: ssetmn,
    ssmile: ssmile,
    sstarf: sstarf,
    Star: Star,
    star: star,
    starf: starf,
    straightepsilon: straightepsilon,
    straightphi: straightphi,
    strns: strns,
    sub: sub,
    Sub: Sub,
    subdot: subdot,
    subE: subE,
    sube: sube,
    subedot: subedot,
    submult: submult,
    subnE: subnE,
    subne: subne,
    subplus: subplus,
    subrarr: subrarr,
    subset: subset,
    Subset: Subset,
    subseteq: subseteq,
    subseteqq: subseteqq,
    SubsetEqual: SubsetEqual,
    subsetneq: subsetneq,
    subsetneqq: subsetneqq,
    subsim: subsim,
    subsub: subsub,
    subsup: subsup,
    succapprox: succapprox,
    succ: succ,
    succcurlyeq: succcurlyeq,
    Succeeds: Succeeds,
    SucceedsEqual: SucceedsEqual,
    SucceedsSlantEqual: SucceedsSlantEqual,
    SucceedsTilde: SucceedsTilde,
    succeq: succeq,
    succnapprox: succnapprox,
    succneqq: succneqq,
    succnsim: succnsim,
    succsim: succsim,
    SuchThat: SuchThat,
    sum: sum,
    Sum: Sum,
    sung: sung,
    sup1: sup1$1,
    sup2: sup2$1,
    sup3: sup3$1,
    sup: sup,
    Sup: Sup,
    supdot: supdot,
    supdsub: supdsub,
    supE: supE,
    supe: supe,
    supedot: supedot,
    Superset: Superset,
    SupersetEqual: SupersetEqual,
    suphsol: suphsol,
    suphsub: suphsub,
    suplarr: suplarr,
    supmult: supmult,
    supnE: supnE,
    supne: supne,
    supplus: supplus,
    supset: supset,
    Supset: Supset,
    supseteq: supseteq,
    supseteqq: supseteqq,
    supsetneq: supsetneq,
    supsetneqq: supsetneqq,
    supsim: supsim,
    supsub: supsub,
    supsup: supsup,
    swarhk: swarhk,
    swarr: swarr,
    swArr: swArr,
    swarrow: swarrow,
    swnwar: swnwar,
    szlig: szlig$1,
    Tab: Tab,
    target: target,
    Tau: Tau,
    tau: tau,
    tbrk: tbrk,
    Tcaron: Tcaron,
    tcaron: tcaron,
    Tcedil: Tcedil,
    tcedil: tcedil,
    Tcy: Tcy,
    tcy: tcy,
    tdot: tdot,
    telrec: telrec,
    Tfr: Tfr,
    tfr: tfr,
    there4: there4,
    therefore: therefore,
    Therefore: Therefore,
    Theta: Theta,
    theta: theta,
    thetasym: thetasym,
    thetav: thetav,
    thickapprox: thickapprox,
    thicksim: thicksim,
    ThickSpace: ThickSpace,
    ThinSpace: ThinSpace,
    thinsp: thinsp,
    thkap: thkap,
    thksim: thksim,
    THORN: THORN$1,
    thorn: thorn$1,
    tilde: tilde,
    Tilde: Tilde,
    TildeEqual: TildeEqual,
    TildeFullEqual: TildeFullEqual,
    TildeTilde: TildeTilde,
    timesbar: timesbar,
    timesb: timesb,
    times: times$1,
    timesd: timesd,
    tint: tint,
    toea: toea,
    topbot: topbot,
    topcir: topcir,
    top: esm_top,
    Topf: Topf,
    topf: topf,
    topfork: topfork,
    tosa: tosa,
    tprime: tprime,
    trade: trade,
    TRADE: TRADE,
    triangle: triangle,
    triangledown: triangledown,
    triangleleft: triangleleft,
    trianglelefteq: trianglelefteq,
    triangleq: triangleq,
    triangleright: triangleright,
    trianglerighteq: trianglerighteq,
    tridot: tridot,
    trie: trie,
    triminus: triminus,
    TripleDot: TripleDot,
    triplus: triplus,
    trisb: trisb,
    tritime: tritime,
    trpezium: trpezium,
    Tscr: Tscr,
    tscr: tscr,
    TScy: TScy,
    tscy: tscy,
    TSHcy: TSHcy,
    tshcy: tshcy,
    Tstrok: Tstrok,
    tstrok: tstrok,
    twixt: twixt,
    twoheadleftarrow: twoheadleftarrow,
    twoheadrightarrow: twoheadrightarrow,
    Uacute: Uacute$1,
    uacute: uacute$1,
    uarr: uarr,
    Uarr: Uarr,
    uArr: uArr,
    Uarrocir: Uarrocir,
    Ubrcy: Ubrcy,
    ubrcy: ubrcy,
    Ubreve: Ubreve,
    ubreve: ubreve,
    Ucirc: Ucirc$1,
    ucirc: ucirc$1,
    Ucy: Ucy,
    ucy: ucy,
    udarr: udarr,
    Udblac: Udblac,
    udblac: udblac,
    udhar: udhar,
    ufisht: ufisht,
    Ufr: Ufr,
    ufr: ufr,
    Ugrave: Ugrave$1,
    ugrave: ugrave$1,
    uHar: uHar,
    uharl: uharl,
    uharr: uharr,
    uhblk: uhblk,
    ulcorn: ulcorn,
    ulcorner: ulcorner,
    ulcrop: ulcrop,
    ultri: ultri,
    Umacr: Umacr,
    umacr: umacr,
    uml: uml$1,
    UnderBar: UnderBar,
    UnderBrace: UnderBrace,
    UnderBracket: UnderBracket,
    UnderParenthesis: UnderParenthesis,
    Union: Union,
    UnionPlus: UnionPlus,
    Uogon: Uogon,
    uogon: uogon,
    Uopf: Uopf,
    uopf: uopf,
    UpArrowBar: UpArrowBar,
    uparrow: uparrow,
    UpArrow: UpArrow,
    Uparrow: Uparrow,
    UpArrowDownArrow: UpArrowDownArrow,
    updownarrow: updownarrow,
    UpDownArrow: UpDownArrow,
    Updownarrow: Updownarrow,
    UpEquilibrium: UpEquilibrium,
    upharpoonleft: upharpoonleft,
    upharpoonright: upharpoonright,
    uplus: uplus,
    UpperLeftArrow: UpperLeftArrow,
    UpperRightArrow: UpperRightArrow,
    upsi: upsi,
    Upsi: Upsi,
    upsih: upsih,
    Upsilon: Upsilon,
    upsilon: upsilon,
    UpTeeArrow: UpTeeArrow,
    UpTee: UpTee,
    upuparrows: upuparrows,
    urcorn: urcorn,
    urcorner: urcorner,
    urcrop: urcrop,
    Uring: Uring,
    uring: uring,
    urtri: urtri,
    Uscr: Uscr,
    uscr: uscr,
    utdot: utdot,
    Utilde: Utilde,
    utilde: utilde,
    utri: utri,
    utrif: utrif,
    uuarr: uuarr,
    Uuml: Uuml$1,
    uuml: uuml$1,
    uwangle: uwangle,
    vangrt: vangrt,
    varepsilon: varepsilon,
    varkappa: varkappa,
    varnothing: varnothing,
    varphi: varphi,
    varpi: varpi,
    varpropto: varpropto,
    varr: varr,
    vArr: vArr,
    varrho: varrho,
    varsigma: varsigma,
    varsubsetneq: varsubsetneq,
    varsubsetneqq: varsubsetneqq,
    varsupsetneq: varsupsetneq,
    varsupsetneqq: varsupsetneqq,
    vartheta: vartheta,
    vartriangleleft: vartriangleleft,
    vartriangleright: vartriangleright,
    vBar: vBar,
    Vbar: Vbar,
    vBarv: vBarv,
    Vcy: Vcy,
    vcy: vcy,
    vdash: vdash,
    vDash: vDash,
    Vdash: Vdash,
    VDash: VDash,
    Vdashl: Vdashl,
    veebar: veebar,
    vee: vee,
    Vee: Vee,
    veeeq: veeeq,
    vellip: vellip,
    verbar: verbar,
    Verbar: Verbar,
    vert: vert,
    Vert: Vert,
    VerticalBar: VerticalBar,
    VerticalLine: VerticalLine,
    VerticalSeparator: VerticalSeparator,
    VerticalTilde: VerticalTilde,
    VeryThinSpace: VeryThinSpace,
    Vfr: Vfr,
    vfr: vfr,
    vltri: vltri,
    vnsub: vnsub,
    vnsup: vnsup,
    Vopf: Vopf,
    vopf: vopf,
    vprop: vprop,
    vrtri: vrtri,
    Vscr: Vscr,
    vscr: vscr,
    vsubnE: vsubnE,
    vsubne: vsubne,
    vsupnE: vsupnE,
    vsupne: vsupne,
    Vvdash: Vvdash,
    vzigzag: vzigzag,
    Wcirc: Wcirc,
    wcirc: wcirc,
    wedbar: wedbar,
    wedge: wedge,
    Wedge: Wedge,
    wedgeq: wedgeq,
    weierp: weierp,
    Wfr: Wfr,
    wfr: wfr,
    Wopf: Wopf,
    wopf: wopf,
    wp: wp,
    wr: wr,
    wreath: wreath,
    Wscr: Wscr,
    wscr: wscr,
    xcap: xcap,
    xcirc: xcirc,
    xcup: xcup,
    xdtri: xdtri,
    Xfr: Xfr,
    xfr: xfr,
    xharr: xharr,
    xhArr: xhArr,
    Xi: Xi,
    xi: xi,
    xlarr: xlarr,
    xlArr: xlArr,
    xmap: xmap,
    xnis: xnis,
    xodot: xodot,
    Xopf: Xopf,
    xopf: xopf,
    xoplus: xoplus,
    xotime: xotime,
    xrarr: xrarr,
    xrArr: xrArr,
    Xscr: Xscr,
    xscr: xscr,
    xsqcup: xsqcup,
    xuplus: xuplus,
    xutri: xutri,
    xvee: xvee,
    xwedge: xwedge,
    Yacute: Yacute$1,
    yacute: yacute$1,
    YAcy: YAcy,
    yacy: yacy,
    Ycirc: Ycirc,
    ycirc: ycirc,
    Ycy: Ycy,
    ycy: ycy,
    yen: yen$1,
    Yfr: Yfr,
    yfr: yfr,
    YIcy: YIcy,
    yicy: yicy,
    Yopf: Yopf,
    yopf: yopf,
    Yscr: Yscr,
    yscr: yscr,
    YUcy: YUcy,
    yucy: yucy,
    yuml: yuml$1,
    Yuml: Yuml,
    Zacute: Zacute,
    zacute: zacute,
    Zcaron: Zcaron,
    zcaron: zcaron,
    Zcy: Zcy,
    zcy: zcy,
    Zdot: Zdot,
    zdot: zdot,
    zeetrf: zeetrf,
    ZeroWidthSpace: ZeroWidthSpace,
    Zeta: Zeta,
    zeta: zeta,
    zfr: zfr,
    Zfr: Zfr,
    ZHcy: ZHcy,
    zhcy: zhcy,
    zigrarr: zigrarr,
    zopf: zopf,
    Zopf: Zopf,
    Zscr: Zscr,
    zscr: zscr,
    zwj: zwj,
    zwnj: zwnj
};
var Aacute = "";
var aacute = "";
var Acirc = "";
var acirc = "";
var acute = "";
var AElig = "";
var aelig = "";
var Agrave = "";
var agrave = "";
var amp$1 = "&";
var AMP = "&";
var Aring = "";
var aring = "";
var Atilde = "";
var atilde = "";
var Auml = "";
var auml = "";
var brvbar = "";
var Ccedil = "";
var ccedil = "";
var cedil = "";
var cent = "";
var copy = "";
var COPY = "";
var curren = "";
var deg = "";
var divide = "";
var Eacute = "";
var eacute = "";
var Ecirc = "";
var ecirc = "";
var Egrave = "";
var egrave = "";
var ETH = "";
var eth = "";
var Euml = "";
var euml = "";
var frac12 = "";
var frac14 = "";
var frac34 = "";
var gt$1 = ">";
var GT = ">";
var Iacute = "";
var iacute = "";
var Icirc = "";
var icirc = "";
var iexcl = "";
var Igrave = "";
var igrave = "";
var iquest = "";
var Iuml = "";
var iuml = "";
var laquo = "";
var lt$1 = "<";
var LT = "<";
var macr = "";
var micro = "";
var middot = "";
var nbsp = "";
var not = "";
var Ntilde = "";
var ntilde = "";
var Oacute = "";
var oacute = "";
var Ocirc = "";
var ocirc = "";
var Ograve = "";
var ograve = "";
var ordf = "";
var ordm = "";
var Oslash = "";
var oslash = "";
var Otilde = "";
var otilde = "";
var Ouml = "";
var ouml = "";
var para = "";
var plusmn = "";
var pound = "";
var quot$1 = "\"";
var QUOT = "\"";
var raquo = "";
var reg = "";
var REG = "";
var sect = "";
var shy = "";
var sup1 = "";
var sup2 = "";
var sup3 = "";
var szlig = "";
var THORN = "";
var thorn = "";
var times = "";
var Uacute = "";
var uacute = "";
var Ucirc = "";
var ucirc = "";
var Ugrave = "";
var ugrave = "";
var uml = "";
var Uuml = "";
var uuml = "";
var Yacute = "";
var yacute = "";
var yen = "";
var yuml = "";
var require$$1 = {
    Aacute: Aacute,
    aacute: aacute,
    Acirc: Acirc,
    acirc: acirc,
    acute: acute,
    AElig: AElig,
    aelig: aelig,
    Agrave: Agrave,
    agrave: agrave,
    amp: amp$1,
    AMP: AMP,
    Aring: Aring,
    aring: aring,
    Atilde: Atilde,
    atilde: atilde,
    Auml: Auml,
    auml: auml,
    brvbar: brvbar,
    Ccedil: Ccedil,
    ccedil: ccedil,
    cedil: cedil,
    cent: cent,
    copy: copy,
    COPY: COPY,
    curren: curren,
    deg: deg,
    divide: divide,
    Eacute: Eacute,
    eacute: eacute,
    Ecirc: Ecirc,
    ecirc: ecirc,
    Egrave: Egrave,
    egrave: egrave,
    ETH: ETH,
    eth: eth,
    Euml: Euml,
    euml: euml,
    frac12: frac12,
    frac14: frac14,
    frac34: frac34,
    gt: gt$1,
    GT: GT,
    Iacute: Iacute,
    iacute: iacute,
    Icirc: Icirc,
    icirc: icirc,
    iexcl: iexcl,
    Igrave: Igrave,
    igrave: igrave,
    iquest: iquest,
    Iuml: Iuml,
    iuml: iuml,
    laquo: laquo,
    lt: lt$1,
    LT: LT,
    macr: macr,
    micro: micro,
    middot: middot,
    nbsp: nbsp,
    not: not,
    Ntilde: Ntilde,
    ntilde: ntilde,
    Oacute: Oacute,
    oacute: oacute,
    Ocirc: Ocirc,
    ocirc: ocirc,
    Ograve: Ograve,
    ograve: ograve,
    ordf: ordf,
    ordm: ordm,
    Oslash: Oslash,
    oslash: oslash,
    Otilde: Otilde,
    otilde: otilde,
    Ouml: Ouml,
    ouml: ouml,
    para: para,
    plusmn: plusmn,
    pound: pound,
    quot: quot$1,
    QUOT: QUOT,
    raquo: raquo,
    reg: reg,
    REG: REG,
    sect: sect,
    shy: shy,
    sup1: sup1,
    sup2: sup2,
    sup3: sup3,
    szlig: szlig,
    THORN: THORN,
    thorn: thorn,
    times: times,
    Uacute: Uacute,
    uacute: uacute,
    Ucirc: Ucirc,
    ucirc: ucirc,
    Ugrave: Ugrave,
    ugrave: ugrave,
    uml: uml,
    Uuml: Uuml,
    uuml: uuml,
    Yacute: Yacute,
    yacute: yacute,
    yen: yen,
    yuml: yuml
};
var amp = "&";
var apos = "'";
var gt = ">";
var lt = "<";
var quot = "\"";
var require$$0$1 = {
    amp: amp,
    apos: apos,
    gt: gt,
    lt: lt,
    quot: quot
};
var decode_codepoint = {};
var require$$0 = {
    "0": 65533,
    "128": 8364,
    "130": 8218,
    "131": 402,
    "132": 8222,
    "133": 8230,
    "134": 8224,
    "135": 8225,
    "136": 710,
    "137": 8240,
    "138": 352,
    "139": 8249,
    "140": 338,
    "142": 381,
    "145": 8216,
    "146": 8217,
    "147": 8220,
    "148": 8221,
    "149": 8226,
    "150": 8211,
    "151": 8212,
    "152": 732,
    "153": 8482,
    "154": 353,
    "155": 8250,
    "156": 339,
    "158": 382,
    "159": 376
};
var __importDefault$2 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(decode_codepoint, "__esModule", { value: true });
var decode_json_1 = __importDefault$2(require$$0);
// Adapted from https://github.com/mathiasbynens/he/blob/master/src/he.js#L94-L119
var fromCodePoint$2 = 
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.fromCodePoint ||
    function (codePoint) {
        var output = "";
        if (codePoint > 0xffff) {
            codePoint -= 0x10000;
            output += String.fromCharCode(((codePoint >>> 10) & 0x3ff) | 0xd800);
            codePoint = 0xdc00 | (codePoint & 0x3ff);
        }
        output += String.fromCharCode(codePoint);
        return output;
    };
function decodeCodePoint(codePoint) {
    if ((codePoint >= 0xd800 && codePoint <= 0xdfff) || codePoint > 0x10ffff) {
        return "\uFFFD";
    }
    if (codePoint in decode_json_1.default) {
        codePoint = decode_json_1.default[codePoint];
    }
    return fromCodePoint$2(codePoint);
}
decode_codepoint.default = decodeCodePoint;
var __importDefault$1 = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(decode, "__esModule", { value: true });
decode.decodeHTML = decode.decodeHTMLStrict = decode.decodeXML = void 0;
var entities_json_1$1 = __importDefault$1(require$$1$1);
var legacy_json_1 = __importDefault$1(require$$1);
var xml_json_1$1 = __importDefault$1(require$$0$1);
var decode_codepoint_1 = __importDefault$1(decode_codepoint);
var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
decode.decodeXML = getStrictDecoder(xml_json_1$1.default);
decode.decodeHTMLStrict = getStrictDecoder(entities_json_1$1.default);
function getStrictDecoder(map) {
    var replace = getReplacer(map);
    return function (str) { return String(str).replace(strictEntityRe, replace); };
}
var sorter = function (a, b) { return (a < b ? 1 : -1); };
decode.decodeHTML = (function () {
    var legacy = Object.keys(legacy_json_1.default).sort(sorter);
    var keys = Object.keys(entities_json_1$1.default).sort(sorter);
    for (var i = 0, j = 0; i < keys.length; i++) {
        if (legacy[j] === keys[i]) {
            keys[i] += ";?";
            j++;
        }
        else {
            keys[i] += ";";
        }
    }
    var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
    var replace = getReplacer(entities_json_1$1.default);
    function replacer(str) {
        if (str.substr(-1) !== ";")
            str += ";";
        return replace(str);
    }
    // TODO consider creating a merged map
    return function (str) { return String(str).replace(re, replacer); };
})();
function getReplacer(map) {
    return function replace(str) {
        if (str.charAt(1) === "#") {
            var secondChar = str.charAt(2);
            if (secondChar === "X" || secondChar === "x") {
                return decode_codepoint_1.default(parseInt(str.substr(3), 16));
            }
            return decode_codepoint_1.default(parseInt(str.substr(2), 10));
        }
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        return map[str.slice(1, -1)] || str;
    };
}
var encode = {};
var esm_importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(encode, "__esModule", { value: true });
encode.escapeUTF8 = encode.escape = encode.encodeNonAsciiHTML = encode.encodeHTML = encode.encodeXML = void 0;
var xml_json_1 = esm_importDefault(require$$0$1);
var inverseXML = getInverseObj(xml_json_1.default);
var xmlReplacer = getInverseReplacer(inverseXML);
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using XML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
encode.encodeXML = getASCIIEncoder(inverseXML);
var entities_json_1 = esm_importDefault(require$$1$1);
var inverseHTML = getInverseObj(entities_json_1.default);
var htmlReplacer = getInverseReplacer(inverseHTML);
/**
 * Encodes all entities and non-ASCII characters in the input.
 *
 * This includes characters that are valid ASCII characters in HTML documents.
 * For example `#` will be encoded as `&num;`. To get a more compact output,
 * consider using the `encodeNonAsciiHTML` function.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
encode.encodeHTML = getInverse(inverseHTML, htmlReplacer);
/**
 * Encodes all non-ASCII characters, as well as characters not valid in HTML
 * documents using HTML entities.
 *
 * If a character has no equivalent entity, a
 * numeric hexadecimal reference (eg. `&#xfc;`) will be used.
 */
encode.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
function getInverseObj(obj) {
    return Object.keys(obj)
        .sort()
        .reduce(function (inverse, name) {
        inverse[obj[name]] = "&" + name + ";";
        return inverse;
    }, {});
}
function getInverseReplacer(inverse) {
    var single = [];
    var multiple = [];
    for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
        var k = _a[_i];
        if (k.length === 1) {
            // Add value to single array
            single.push("\\" + k);
        }
        else {
            // Add value to multiple array
            multiple.push(k);
        }
    }
    // Add ranges to single characters.
    single.sort();
    for (var start = 0; start < single.length - 1; start++) {
        // Find the end of a run of characters
        var end = start;
        while (end < single.length - 1 &&
            single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
            end += 1;
        }
        var count = 1 + end - start;
        // We want to replace at least three characters
        if (count < 3)
            continue;
        single.splice(start, count, single[start] + "-" + single[end]);
    }
    multiple.unshift("[" + single.join("") + "]");
    return new RegExp(multiple.join("|"), "g");
}
// /[^\0-\x7F]/gu
var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
var getCodePoint = 
// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
String.prototype.codePointAt != null
    ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        function (str) { return str.codePointAt(0); }
    : // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        function (c) {
            return (c.charCodeAt(0) - 0xd800) * 0x400 +
                c.charCodeAt(1) -
                0xdc00 +
                0x10000;
        };
function singleCharReplacer(c) {
    return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0))
        .toString(16)
        .toUpperCase() + ";";
}
function getInverse(inverse, re) {
    return function (data) {
        return data
            .replace(re, function (name) { return inverse[name]; })
            .replace(reNonASCII, singleCharReplacer);
    };
}
var esm_reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
/**
 * Encodes all non-ASCII characters, as well as characters not valid in XML
 * documents using numeric hexadecimal reference (eg. `&#xfc;`).
 *
 * Have a look at `escapeUTF8` if you want a more concise output at the expense
 * of reduced transportability.
 *
 * @param data String to escape.
 */
function esm_escape(data) {
    return data.replace(esm_reEscapeChars, singleCharReplacer);
}
encode.escape = esm_escape;
/**
 * Encodes all characters not valid in XML documents using numeric hexadecimal
 * reference (eg. `&#xfc;`).
 *
 * Note that the output will be character-set dependent.
 *
 * @param data String to escape.
 */
function escapeUTF8(data) {
    return data.replace(xmlReplacer, singleCharReplacer);
}
encode.escapeUTF8 = escapeUTF8;
function getASCIIEncoder(obj) {
    return function (data) {
        return data.replace(esm_reEscapeChars, function (c) { return obj[c] || singleCharReplacer(c); });
    };
}
(function (exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeXMLStrict = exports.decodeHTML5Strict = exports.decodeHTML4Strict = exports.decodeHTML5 = exports.decodeHTML4 = exports.decodeHTMLStrict = exports.decodeHTML = exports.decodeXML = exports.encodeHTML5 = exports.encodeHTML4 = exports.escapeUTF8 = exports.escape = exports.encodeNonAsciiHTML = exports.encodeHTML = exports.encodeXML = exports.encode = exports.decodeStrict = exports.decode = void 0;
    var decode_1 = decode;
    var encode_1 = encode;
    /**
     * Decodes a string with entities.
     *
     * @param data String to decode.
     * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
     * @deprecated Use `decodeXML` or `decodeHTML` directly.
     */
    function decode$1(data, level) {
        return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
    }
    exports.decode = decode$1;
    /**
     * Decodes a string with entities. Does not allow missing trailing semicolons for entities.
     *
     * @param data String to decode.
     * @param level Optional level to decode at. 0 = XML, 1 = HTML. Default is 0.
     * @deprecated Use `decodeHTMLStrict` or `decodeXML` directly.
     */
    function decodeStrict(data, level) {
        return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
    }
    exports.decodeStrict = decodeStrict;
    /**
     * Encodes a string with entities.
     *
     * @param data String to encode.
     * @param level Optional level to encode at. 0 = XML, 1 = HTML. Default is 0.
     * @deprecated Use `encodeHTML`, `encodeXML` or `encodeNonAsciiHTML` directly.
     */
    function encode$1(data, level) {
        return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
    }
    exports.encode = encode$1;
    var encode_2 = encode;
    Object.defineProperty(exports, "encodeXML", { enumerable: true, get: function () { return encode_2.encodeXML; } });
    Object.defineProperty(exports, "encodeHTML", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
    Object.defineProperty(exports, "encodeNonAsciiHTML", { enumerable: true, get: function () { return encode_2.encodeNonAsciiHTML; } });
    Object.defineProperty(exports, "escape", { enumerable: true, get: function () { return encode_2.escape; } });
    Object.defineProperty(exports, "escapeUTF8", { enumerable: true, get: function () { return encode_2.escapeUTF8; } });
    // Legacy aliases (deprecated)
    Object.defineProperty(exports, "encodeHTML4", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
    Object.defineProperty(exports, "encodeHTML5", { enumerable: true, get: function () { return encode_2.encodeHTML; } });
    var decode_2 = decode;
    Object.defineProperty(exports, "decodeXML", { enumerable: true, get: function () { return decode_2.decodeXML; } });
    Object.defineProperty(exports, "decodeHTML", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
    Object.defineProperty(exports, "decodeHTMLStrict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
    // Legacy aliases (deprecated)
    Object.defineProperty(exports, "decodeHTML4", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
    Object.defineProperty(exports, "decodeHTML5", { enumerable: true, get: function () { return decode_2.decodeHTML; } });
    Object.defineProperty(exports, "decodeHTML4Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
    Object.defineProperty(exports, "decodeHTML5Strict", { enumerable: true, get: function () { return decode_2.decodeHTMLStrict; } });
    Object.defineProperty(exports, "decodeXMLStrict", { enumerable: true, get: function () { return decode_2.decodeXML; } });
}(lib));
var ENTITY = '&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});';
var C_BACKSLASH$1 = 92;
var reBackslashOrAmp = /[\\&]/;
var ESCAPABLE = '[!"#$%&\'()*+,./:;<=>?@[\\\\\\]^_`{|}~-]';
var reEntityOrEscapedChar = new RegExp("\\\\" + ESCAPABLE + "|" + ENTITY, 'gi');
var esm_XMLSPECIAL = '[&<>"]';
var esm_reXmlSpecial = new RegExp(esm_XMLSPECIAL, 'g');
var unescapeChar = function (s) {
    if (s.charCodeAt(0) === C_BACKSLASH$1) {
        return s.charAt(1);
    }
    return lib.decodeHTML(s);
};
// Replace entities and backslash escapes with literal characters.
function unescapeString(s) {
    if (reBackslashOrAmp.test(s)) {
        return s.replace(reEntityOrEscapedChar, unescapeChar);
    }
    return s;
}
function normalizeURI(uri) {
    try {
        return encode_1(uri);
    }
    catch (err) {
        return uri;
    }
}
function esm_replaceUnsafeChar(s) {
    switch (s) {
        case '&':
            return '&amp;';
        case '<':
            return '&lt;';
        case '>':
            return '&gt;';
        case '"':
            return '&quot;';
        default:
            return s;
    }
}
function esm_escapeXml(s) {
    if (esm_reXmlSpecial.test(s)) {
        return s.replace(esm_reXmlSpecial, esm_replaceUnsafeChar);
    }
    return s;
}
function esm_repeat(str, count) {
    var arr = [];
    for (var i = 0; i < count; i++) {
        arr.push(str);
    }
    return arr.join('');
}
function isEmpty(str) {
    if (!str) {
        return true;
    }
    return !/[^ \t]+/.test(str);
}
var NodeWalker = /** @class */ (function () {
    function NodeWalker(root) {
        this.current = root;
        this.root = root;
        this.entering = true;
    }
    NodeWalker.prototype.next = function () {
        var cur = this.current;
        var entering = this.entering;
        if (cur === null) {
            return null;
        }
        var container = esm_isContainer(cur);
        if (entering && container) {
            if (cur.firstChild) {
                this.current = cur.firstChild;
                this.entering = true;
            }
            else {
                // stay on node but exit
                this.entering = false;
            }
        }
        else if (cur === this.root) {
            this.current = null;
        }
        else if (cur.next === null) {
            this.current = cur.parent;
            this.entering = false;
        }
        else {
            this.current = cur.next;
            this.entering = true;
        }
        return { entering: entering, node: cur };
    };
    NodeWalker.prototype.resumeAt = function (node, entering) {
        this.current = node;
        this.entering = entering === true;
    };
    return NodeWalker;
}());
function esm_isContainer(node) {
    switch (node.type) {
        case 'document':
        case 'blockQuote':
        case 'list':
        case 'item':
        case 'paragraph':
        case 'heading':
        case 'emph':
        case 'strong':
        case 'strike':
        case 'link':
        case 'image':
        case 'table':
        case 'tableHead':
        case 'tableBody':
        case 'tableRow':
        case 'tableCell':
        case 'tableDelimRow':
        case 'customInline':
            return true;
        default:
            return false;
    }
}
var lastNodeId = 1;
var nodeMap = {};
function getNodeById(id) {
    return nodeMap[id];
}
function removeNodeById(id) {
    delete nodeMap[id];
}
function removeAllNode() {
    nodeMap = {};
}
var esm_Node = /** @class */ (function () {
    function Node(nodeType, sourcepos) {
        this.parent = null;
        this.prev = null;
        this.next = null;
        // only for container node
        this.firstChild = null;
        this.lastChild = null;
        // only for leaf node
        this.literal = null;
        if (nodeType === 'document') {
            this.id = -1;
        }
        else {
            this.id = lastNodeId++;
        }
        this.type = nodeType;
        this.sourcepos = sourcepos;
        nodeMap[this.id] = this;
    }
    Node.prototype.isContainer = function () {
        return esm_isContainer(this);
    };
    Node.prototype.unlink = function () {
        if (this.prev) {
            this.prev.next = this.next;
        }
        else if (this.parent) {
            this.parent.firstChild = this.next;
        }
        if (this.next) {
            this.next.prev = this.prev;
        }
        else if (this.parent) {
            this.parent.lastChild = this.prev;
        }
        this.parent = null;
        this.next = null;
        this.prev = null;
    };
    Node.prototype.replaceWith = function (node) {
        this.insertBefore(node);
        this.unlink();
    };
    Node.prototype.insertAfter = function (sibling) {
        sibling.unlink();
        sibling.next = this.next;
        if (sibling.next) {
            sibling.next.prev = sibling;
        }
        sibling.prev = this;
        this.next = sibling;
        if (this.parent) {
            sibling.parent = this.parent;
            if (!sibling.next) {
                sibling.parent.lastChild = sibling;
            }
        }
    };
    Node.prototype.insertBefore = function (sibling) {
        sibling.unlink();
        sibling.prev = this.prev;
        if (sibling.prev) {
            sibling.prev.next = sibling;
        }
        sibling.next = this;
        this.prev = sibling;
        sibling.parent = this.parent;
        if (!sibling.prev) {
            sibling.parent.firstChild = sibling;
        }
    };
    Node.prototype.appendChild = function (child) {
        child.unlink();
        child.parent = this;
        if (this.lastChild) {
            this.lastChild.next = child;
            child.prev = this.lastChild;
            this.lastChild = child;
        }
        else {
            this.firstChild = child;
            this.lastChild = child;
        }
    };
    Node.prototype.prependChild = function (child) {
        child.unlink();
        child.parent = this;
        if (this.firstChild) {
            this.firstChild.prev = child;
            child.next = this.firstChild;
            this.firstChild = child;
        }
        else {
            this.firstChild = child;
            this.lastChild = child;
        }
    };
    Node.prototype.walker = function () {
        return new NodeWalker(this);
    };
    return Node;
}());
var BlockNode = /** @class */ (function (_super) {
    esm_extends(BlockNode, _super);
    function BlockNode(nodeType, sourcepos) {
        var _this = _super.call(this, nodeType, sourcepos) || this;
        // temporal data (for parsing)
        _this.open = true;
        _this.lineOffsets = null;
        _this.stringContent = null;
        _this.lastLineBlank = false;
        _this.lastLineChecked = false;
        _this.type = nodeType;
        return _this;
    }
    return BlockNode;
}(esm_Node));
var ListNode = /** @class */ (function (_super) {
    esm_extends(ListNode, _super);
    function ListNode() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.listData = null;
        return _this;
    }
    return ListNode;
}(BlockNode));
var HeadingNode = /** @class */ (function (_super) {
    esm_extends(HeadingNode, _super);
    function HeadingNode() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.level = 0;
        _this.headingType = 'atx';
        return _this;
    }
    return HeadingNode;
}(BlockNode));
var CodeBlockNode = /** @class */ (function (_super) {
    esm_extends(CodeBlockNode, _super);
    function CodeBlockNode() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isFenced = false;
        _this.fenceChar = null;
        _this.fenceLength = 0;
        _this.fenceOffset = -1;
        _this.info = null;
        _this.infoPadding = 0;
        return _this;
    }
    return CodeBlockNode;
}(BlockNode));
var TableNode = /** @class */ (function (_super) {
    esm_extends(TableNode, _super);
    function TableNode() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.columns = [];
        return _this;
    }
    return TableNode;
}(BlockNode));
var TableCellNode = /** @class */ (function (_super) {
    esm_extends(TableCellNode, _super);
    function TableCellNode() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.startIdx = 0;
        _this.endIdx = 0;
        _this.paddingLeft = 0;
        _this.paddingRight = 0;
        _this.ignored = false;
        return _this;
    }
    return TableCellNode;
}(BlockNode));
var RefDefNode = /** @class */ (function (_super) {
    esm_extends(RefDefNode, _super);
    function RefDefNode() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.title = '';
        _this.dest = '';
        _this.label = '';
        return _this;
    }
    return RefDefNode;
}(BlockNode));
var CustomBlockNode = /** @class */ (function (_super) {
    esm_extends(CustomBlockNode, _super);
    function CustomBlockNode() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.syntaxLength = 0;
        _this.offset = -1;
        _this.info = '';
        return _this;
    }
    return CustomBlockNode;
}(BlockNode));
var HtmlBlockNode = /** @class */ (function (_super) {
    esm_extends(HtmlBlockNode, _super);
    function HtmlBlockNode() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.htmlBlockType = -1;
        return _this;
    }
    return HtmlBlockNode;
}(BlockNode));
var LinkNode = /** @class */ (function (_super) {
    esm_extends(LinkNode, _super);
    function LinkNode() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.destination = null;
        _this.title = null;
        _this.extendedAutolink = false;
        return _this;
    }
    return LinkNode;
}(esm_Node));
var CodeNode = /** @class */ (function (_super) {
    esm_extends(CodeNode, _super);
    function CodeNode() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.tickCount = 0;
        return _this;
    }
    return CodeNode;
}(esm_Node));
var CustomInlineNode = /** @class */ (function (_super) {
    esm_extends(CustomInlineNode, _super);
    function CustomInlineNode() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.info = '';
        return _this;
    }
    return CustomInlineNode;
}(esm_Node));
function createNode(type, sourcepos) {
    switch (type) {
        case 'heading':
            return new HeadingNode(type, sourcepos);
        case 'list':
        case 'item':
            return new ListNode(type, sourcepos);
        case 'link':
        case 'image':
            return new LinkNode(type, sourcepos);
        case 'codeBlock':
            return new CodeBlockNode(type, sourcepos);
        case 'htmlBlock':
            return new HtmlBlockNode(type, sourcepos);
        case 'table':
            return new TableNode(type, sourcepos);
        case 'tableCell':
            return new TableCellNode(type, sourcepos);
        case 'document':
        case 'paragraph':
        case 'blockQuote':
        case 'thematicBreak':
        case 'tableRow':
        case 'tableBody':
        case 'tableHead':
        case 'frontMatter':
            return new BlockNode(type, sourcepos);
        case 'code':
            return new CodeNode(type, sourcepos);
        case 'refDef':
            return new RefDefNode(type, sourcepos);
        case 'customBlock':
            return new CustomBlockNode(type, sourcepos);
        case 'customInline':
            return new CustomInlineNode(type, sourcepos);
        default:
            return new esm_Node(type, sourcepos);
    }
}
function isCodeBlock(node) {
    return node.type === 'codeBlock';
}
function isHtmlBlock(node) {
    return node.type === 'htmlBlock';
}
function isHeading(node) {
    return node.type === 'heading';
}
function isList(node) {
    return node.type === 'list';
}
function isTable(node) {
    return node.type === 'table';
}
function isRefDef(node) {
    return node.type === 'refDef';
}
function isCustomBlock(node) {
    return node.type === 'customBlock';
}
function isCustomInline(node) {
    return node.type === 'customInline';
}
function esm_text(s, sourcepos) {
    var node = createNode('text', sourcepos);
    node.literal = s;
    return node;
}
var TAGNAME = '[A-Za-z][A-Za-z0-9-]*';
var ATTRIBUTENAME = '[a-zA-Z_:][a-zA-Z0-9:._-]*';
var UNQUOTEDVALUE = '[^"\'=<>`\\x00-\\x20]+';
var SINGLEQUOTEDVALUE = "'[^']*'";
var DOUBLEQUOTEDVALUE = '"[^"]*"';
var ATTRIBUTEVALUE = "(?:" + UNQUOTEDVALUE + "|" + SINGLEQUOTEDVALUE + "|" + DOUBLEQUOTEDVALUE + ")";
var ATTRIBUTEVALUESPEC = "" + '(?:\\s*=\\s*' + ATTRIBUTEVALUE + ")";
var esm_ATTRIBUTE = "" + '(?:\\s+' + ATTRIBUTENAME + ATTRIBUTEVALUESPEC + "?)";
var OPENTAG = "<" + TAGNAME + esm_ATTRIBUTE + "*\\s*/?>";
var CLOSETAG = "</" + TAGNAME + "\\s*[>]";
var HTMLCOMMENT = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var PROCESSINGINSTRUCTION = '[<][?].*?[?][>]';
var DECLARATION = '<![A-Z]+\\s+[^>]*>';
var CDATA = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';
var HTMLTAG = "(?:" + OPENTAG + "|" + CLOSETAG + "|" + HTMLCOMMENT + "|" + PROCESSINGINSTRUCTION + "|" + DECLARATION + "|" + CDATA + ")";
var reHtmlTag = new RegExp("^" + HTMLTAG, 'i');
// derived from https://github.com/mathiasbynens/String.fromCodePoint
/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */
var fromCodePoint;
if (String.fromCodePoint) {
    fromCodePoint = function (_) {
        try {
            return String.fromCodePoint(_);
        }
        catch (e) {
            if (e instanceof RangeError) {
                return String.fromCharCode(0xfffd);
            }
            throw e;
        }
    };
}
else {
    var stringFromCharCode_1 = String.fromCharCode;
    var floor_1 = Math.floor;
    fromCodePoint = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var MAX_SIZE = 0x4000;
        var codeUnits = [];
        var highSurrogate;
        var lowSurrogate;
        var index = -1;
        var length = args.length;
        if (!length) {
            return '';
        }
        var result = '';
        while (++index < length) {
            var codePoint = Number(args[index]);
            if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                codePoint < 0 || // not a valid Unicode code point
                codePoint > 0x10ffff || // not a valid Unicode code point
                floor_1(codePoint) !== codePoint // not an integer
            ) {
                return String.fromCharCode(0xfffd);
            }
            if (codePoint <= 0xffff) {
                // BMP code point
                codeUnits.push(codePoint);
            }
            else {
                // Astral code point; split in surrogate halves
                // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                codePoint -= 0x10000;
                highSurrogate = (codePoint >> 10) + 0xd800;
                lowSurrogate = (codePoint % 0x400) + 0xdc00;
                codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode_1.apply(void 0, codeUnits);
                codeUnits.length = 0;
            }
        }
        return result;
    };
}
var fromCodePoint$1 = fromCodePoint;
var DOMAIN = '(?:[w-]+.)*[A-Za-z0-9-]+.[A-Za-z0-9-]+';
var PATH = '[^<\\s]*[^<?!.,:*_?~\\s]';
var EMAIL = '[\\w.+-]+@(?:[\\w-]+\\.)+[\\w-]+';
function trimUnmatchedTrailingParens(source) {
    var trailingParen = /\)+$/.exec(source);
    if (trailingParen) {
        var count = 0;
        for (var _i = 0, source_1 = source; _i < source_1.length; _i++) {
            var ch = source_1[_i];
            if (ch === '(') {
                if (count < 0) {
                    count = 1;
                }
                else {
                    count += 1;
                }
            }
            else if (ch === ')') {
                count -= 1;
            }
        }
        if (count < 0) {
            var trimCount = Math.min(-count, trailingParen[0].length);
            return source.substring(0, source.length - trimCount);
        }
    }
    return source;
}
function trimTrailingEntity(source) {
    return source.replace(/&[A-Za-z0-9]+;$/, '');
}
function parseEmailLink(source) {
    var reEmailLink = new RegExp(EMAIL, 'g');
    var result = [];
    var m;
    while ((m = reEmailLink.exec(source))) {
        var text_1 = m[0];
        if (!/[_-]+$/.test(text_1)) {
            result.push({
                text: text_1,
                range: [m.index, m.index + text_1.length - 1],
                url: "mailto:" + text_1,
            });
        }
    }
    return result;
}
function parseUrlLink(source) {
    var reWwwAutolink = new RegExp("(www|https?://)." + DOMAIN + PATH, 'g');
    var result = [];
    var m;
    while ((m = reWwwAutolink.exec(source))) {
        var text_2 = trimTrailingEntity(trimUnmatchedTrailingParens(m[0]));
        var scheme = m[1] === 'www' ? 'http://' : '';
        result.push({
            text: text_2,
            range: [m.index, m.index + text_2.length - 1],
            url: "" + scheme + text_2,
        });
    }
    return result;
}
function baseAutolinkParser(source) {
    return esm_spreadArray(esm_spreadArray([], parseUrlLink(source)), parseEmailLink(source)).sort(function (a, b) { return a.range[0] - b.range[0]; });
}
function convertExtAutoLinks(walker, autolinkParser) {
    if (typeof autolinkParser === 'boolean') {
        autolinkParser = baseAutolinkParser;
    }
    var event;
    var _loop_1 = function () {
        var entering = event.entering, node = event.node;
        if (entering && node.type === 'text' && node.parent.type !== 'link') {
            var literal = node.literal;
            var linkInfos = autolinkParser(literal);
            if (!linkInfos || !linkInfos.length) {
                return "continue";
            }
            var lastIdx = 0;
            var _a = node.sourcepos[0], lineNum_1 = _a[0], chPos_1 = _a[1];
            var sourcepos = function (startIdx, endIdx) {
                return [
                    [lineNum_1, chPos_1 + startIdx],
                    [lineNum_1, chPos_1 + endIdx],
                ];
            };
            var newNodes = [];
            for (var _i = 0, linkInfos_1 = linkInfos; _i < linkInfos_1.length; _i++) {
                var _b = linkInfos_1[_i], range = _b.range, url = _b.url, linkText = _b.text;
                if (range[0] > lastIdx) {
                    newNodes.push(esm_text(literal.substring(lastIdx, range[0]), sourcepos(lastIdx, range[0] - 1)));
                }
                var linkNode = createNode('link', sourcepos.apply(void 0, range));
                linkNode.appendChild(esm_text(linkText, sourcepos.apply(void 0, range)));
                linkNode.destination = url;
                linkNode.extendedAutolink = true;
                newNodes.push(linkNode);
                lastIdx = range[1] + 1;
            }
            if (lastIdx < literal.length) {
                newNodes.push(esm_text(literal.substring(lastIdx), sourcepos(lastIdx, literal.length - 1)));
            }
            for (var _c = 0, newNodes_1 = newNodes; _c < newNodes_1.length; _c++) {
                var newNode = newNodes_1[_c];
                node.insertBefore(newNode);
            }
            node.unlink();
        }
    };
    while ((event = walker.next())) {
        _loop_1();
    }
}
function esm_last(arr) {
    return arr[arr.length - 1];
}
// normalize a reference in reference link (remove []s, trim,
// collapse internal space, unicode case fold.
// See commonmark/commonmark.js#168.
function normalizeReference(str) {
    return str
        .slice(1, str.length - 1)
        .trim()
        .replace(/[ \t\r\n]+/, ' ')
        .toLowerCase()
        .toUpperCase();
}
function iterateObject(obj, iteratee) {
    Object.keys(obj).forEach(function (key) {
        iteratee(key, obj[key]);
    });
}
function omit(obj) {
    var propNames = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        propNames[_i - 1] = arguments[_i];
    }
    var resultMap = esm_assign({}, obj);
    propNames.forEach(function (key) {
        delete resultMap[key];
    });
    return resultMap;
}
function isEmptyObj(obj) {
    return !Object.keys(obj).length;
}
function clearObj(obj) {
    Object.keys(obj).forEach(function (key) {
        delete obj[key];
    });
}
var C_NEWLINE = 10;
var C_ASTERISK = 42;
var C_UNDERSCORE = 95;
var C_BACKTICK = 96;
var C_OPEN_BRACKET$1 = 91;
var C_CLOSE_BRACKET = 93;
var C_TILDE = 126;
var C_LESSTHAN$1 = 60;
var C_BANG = 33;
var C_BACKSLASH = 92;
var C_AMPERSAND = 38;
var C_OPEN_PAREN = 40;
var C_CLOSE_PAREN = 41;
var C_COLON = 58;
var C_SINGLEQUOTE = 39;
var C_DOUBLEQUOTE = 34;
var C_DOLLAR = 36;
// Some regexps used in inline parser:
var ESCAPED_CHAR = "\\\\" + ESCAPABLE;
var rePunctuation = new RegExp(/[!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/);
var reLinkTitle = new RegExp("^(?:\"(" + ESCAPED_CHAR + "|[^\"\\x00])*\"" +
    "|" +
    ("'(" + ESCAPED_CHAR + "|[^'\\x00])*'") +
    "|" +
    ("\\((" + ESCAPED_CHAR + "|[^()\\x00])*\\))"));
var reLinkDestinationBraces = /^(?:<(?:[^<>\n\\\x00]|\\.)*>)/;
var reEscapable = new RegExp("^" + ESCAPABLE);
var reEntityHere = new RegExp("^" + ENTITY, 'i');
var reTicks = /`+/;
var reTicksHere = /^`+/;
var reEllipses = /\.\.\./g;
var reDash = /--+/g;
var reEmailAutolink = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
var reAutolink = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\x00-\x20]*>/i;
var reSpnl = /^ *(?:\n *)?/;
var reWhitespaceChar = /^[ \t\n\x0b\x0c\x0d]/;
var reUnicodeWhitespaceChar = /^\s/;
var reFinalSpace = / *$/;
var reInitialSpace = /^ */;
var reSpaceAtEndOfLine = /^ *(?:\n|$)/;
var reLinkLabel = /^\[(?:[^\\\[\]]|\\.){0,1000}\]/;
// Matches a string of non-special characters.
var reMain = /^[^\n`\[\]\\!<&*_'"~$]+/m;
var InlineParser = /** @class */ (function () {
    function InlineParser(options) {
        // An InlineParser keeps track of a subject (a string to be parsed)
        // and a position in that subject.
        this.subject = '';
        this.delimiters = null; // used by handleDelim method
        this.brackets = null;
        this.pos = 0;
        this.lineStartNum = 0;
        this.lineIdx = 0;
        this.lineOffsets = [0];
        this.linePosOffset = 0;
        this.refMap = {};
        this.refLinkCandidateMap = {};
        this.refDefCandidateMap = {};
        this.options = options;
    }
    InlineParser.prototype.sourcepos = function (start, end) {
        var linePosOffset = this.linePosOffset + this.lineOffsets[this.lineIdx];
        var lineNum = this.lineStartNum + this.lineIdx;
        var startpos = [lineNum, start + linePosOffset];
        if (typeof end === 'number') {
            return [startpos, [lineNum, end + linePosOffset]];
        }
        return startpos;
    };
    InlineParser.prototype.nextLine = function () {
        this.lineIdx += 1;
        this.linePosOffset = -this.pos;
    };
    // If re matches at current position in the subject, advance
    // position in subject and return the match; otherwise return null.
    InlineParser.prototype.match = function (re) {
        var m = re.exec(this.subject.slice(this.pos));
        if (m === null) {
            return null;
        }
        this.pos += m.index + m[0].length;
        return m[0];
    };
    // Returns the code for the character at the current subject position, or -1
    // there are no more characters.
    InlineParser.prototype.peek = function () {
        if (this.pos < this.subject.length) {
            return this.subject.charCodeAt(this.pos);
        }
        return -1;
    };
    // Parse zero or more space characters, including at most one newline
    InlineParser.prototype.spnl = function () {
        this.match(reSpnl);
        return true;
    };
    // All of the parsers below try to match something at the current position
    // in the subject.  If they succeed in matching anything, they
    // return the inline matched, advancing the subject.
    // Attempt to parse backticks, adding either a backtick code span or a
    // literal sequence of backticks.
    InlineParser.prototype.parseBackticks = function (block) {
        var startpos = this.pos + 1;
        var ticks = this.match(reTicksHere);
        if (ticks === null) {
            return false;
        }
        var afterOpenTicks = this.pos;
        var matched;
        while ((matched = this.match(reTicks)) !== null) {
            if (matched === ticks) {
                var contents = this.subject.slice(afterOpenTicks, this.pos - ticks.length);
                var sourcepos = this.sourcepos(startpos, this.pos);
                var lines = contents.split('\n');
                if (lines.length > 1) {
                    var lastLine = esm_last(lines);
                    this.lineIdx += lines.length - 1;
                    this.linePosOffset = -(this.pos - lastLine.length - ticks.length);
                    sourcepos[1] = this.sourcepos(this.pos);
                    contents = lines.join(' ');
                }
                var node = createNode('code', sourcepos);
                if (contents.length > 0 &&
                    contents.match(/[^ ]/) !== null &&
                    contents[0] == ' ' &&
                    contents[contents.length - 1] == ' ') {
                    node.literal = contents.slice(1, contents.length - 1);
                }
                else {
                    node.literal = contents;
                }
                node.tickCount = ticks.length;
                block.appendChild(node);
                return true;
            }
        }
        // If we got here, we didn't match a closing backtick sequence.
        this.pos = afterOpenTicks;
        block.appendChild(esm_text(ticks, this.sourcepos(startpos, this.pos - 1)));
        return true;
    };
    // Parse a backslash-escaped special character, adding either the escaped
    // character, a hard line break (if the backslash is followed by a newline),
    // or a literal backslash to the block's children.  Assumes current character
    // is a backslash.
    InlineParser.prototype.parseBackslash = function (block) {
        var subj = this.subject;
        var node;
        this.pos += 1;
        var startpos = this.pos;
        if (this.peek() === C_NEWLINE) {
            this.pos += 1;
            node = createNode('linebreak', this.sourcepos(this.pos - 1, this.pos));
            block.appendChild(node);
            this.nextLine();
        }
        else if (reEscapable.test(subj.charAt(this.pos))) {
            block.appendChild(esm_text(subj.charAt(this.pos), this.sourcepos(startpos, this.pos)));
            this.pos += 1;
        }
        else {
            block.appendChild(esm_text('\\', this.sourcepos(startpos, startpos)));
        }
        return true;
    };
    // Attempt to parse an autolink (URL or email in pointy brackets).
    InlineParser.prototype.parseAutolink = function (block) {
        var m;
        var dest;
        var node;
        var startpos = this.pos + 1;
        if ((m = this.match(reEmailAutolink))) {
            dest = m.slice(1, m.length - 1);
            node = createNode('link', this.sourcepos(startpos, this.pos));
            node.destination = normalizeURI("mailto:" + dest);
            node.title = '';
            node.appendChild(esm_text(dest, this.sourcepos(startpos + 1, this.pos - 1)));
            block.appendChild(node);
            return true;
        }
        if ((m = this.match(reAutolink))) {
            dest = m.slice(1, m.length - 1);
            node = createNode('link', this.sourcepos(startpos, this.pos));
            node.destination = normalizeURI(dest);
            node.title = '';
            node.appendChild(esm_text(dest, this.sourcepos(startpos + 1, this.pos - 1)));
            block.appendChild(node);
            return true;
        }
        return false;
    };
    // Attempt to parse a raw HTML tag.
    InlineParser.prototype.parseHtmlTag = function (block) {
        var startpos = this.pos + 1;
        var m = this.match(reHtmlTag);
        if (m === null) {
            return false;
        }
        var node = createNode('htmlInline', this.sourcepos(startpos, this.pos));
        node.literal = m;
        block.appendChild(node);
        return true;
    };
    // Scan a sequence of characters with code cc, and return information about
    // the number of delimiters and whether they are positioned such that
    // they can open and/or close emphasis or strong emphasis.  A utility
    // function for strong/emph parsing.
    InlineParser.prototype.scanDelims = function (cc) {
        var numdelims = 0;
        var startpos = this.pos;
        if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {
            numdelims++;
            this.pos++;
        }
        else {
            while (this.peek() === cc) {
                numdelims++;
                this.pos++;
            }
        }
        if (numdelims === 0 || (numdelims < 2 && (cc === C_TILDE || cc === C_DOLLAR))) {
            this.pos = startpos;
            return null;
        }
        var charBefore = startpos === 0 ? '\n' : this.subject.charAt(startpos - 1);
        var ccAfter = this.peek();
        var charAfter;
        if (ccAfter === -1) {
            charAfter = '\n';
        }
        else {
            charAfter = fromCodePoint$1(ccAfter);
        }
        var afterIsWhitespace = reUnicodeWhitespaceChar.test(charAfter);
        var afterIsPunctuation = rePunctuation.test(charAfter);
        var beforeIsWhitespace = reUnicodeWhitespaceChar.test(charBefore);
        var beforeIsPunctuation = rePunctuation.test(charBefore);
        var leftFlanking = !afterIsWhitespace && (!afterIsPunctuation || beforeIsWhitespace || beforeIsPunctuation);
        var rightFlanking = !beforeIsWhitespace && (!beforeIsPunctuation || afterIsWhitespace || afterIsPunctuation);
        var canOpen;
        var canClose;
        if (cc === C_UNDERSCORE) {
            canOpen = leftFlanking && (!rightFlanking || beforeIsPunctuation);
            canClose = rightFlanking && (!leftFlanking || afterIsPunctuation);
        }
        else if (cc === C_SINGLEQUOTE || cc === C_DOUBLEQUOTE) {
            canOpen = leftFlanking && !rightFlanking;
            canClose = rightFlanking;
        }
        else if (cc === C_DOLLAR) {
            canOpen = !afterIsWhitespace;
            canClose = !beforeIsWhitespace;
        }
        else {
            canOpen = leftFlanking;
            canClose = rightFlanking;
        }
        this.pos = startpos;
        return { numdelims: numdelims, canOpen: canOpen, canClose: canClose };
    };
    // Handle a delimiter marker for emphasis or a quote.
    InlineParser.prototype.handleDelim = function (cc, block) {
        var res = this.scanDelims(cc);
        if (!res) {
            return false;
        }
        var numdelims = res.numdelims;
        var startpos = this.pos + 1;
        var contents;
        this.pos += numdelims;
        if (cc === C_SINGLEQUOTE) {
            contents = '\u2019';
        }
        else if (cc === C_DOUBLEQUOTE) {
            contents = '\u201C';
        }
        else {
            contents = this.subject.slice(startpos - 1, this.pos);
        }
        var node = esm_text(contents, this.sourcepos(startpos, this.pos));
        block.appendChild(node);
        // Add entry to stack for this opener
        if ((res.canOpen || res.canClose) &&
            (this.options.smart || (cc !== C_SINGLEQUOTE && cc !== C_DOUBLEQUOTE))) {
            this.delimiters = {
                cc: cc,
                numdelims: numdelims,
                origdelims: numdelims,
                node: node,
                previous: this.delimiters,
                next: null,
                canOpen: res.canOpen,
                canClose: res.canClose,
            };
            if (this.delimiters.previous) {
                this.delimiters.previous.next = this.delimiters;
            }
        }
        return true;
    };
    InlineParser.prototype.removeDelimiter = function (delim) {
        if (delim.previous !== null) {
            delim.previous.next = delim.next;
        }
        if (delim.next === null) {
            // top of stack
            this.delimiters = delim.previous;
        }
        else {
            delim.next.previous = delim.previous;
        }
    };
    InlineParser.prototype.removeDelimitersBetween = function (bottom, top) {
        if (bottom.next !== top) {
            bottom.next = top;
            top.previous = bottom;
        }
    };
    /**
     * Process all delimiters - emphasis, strong emphasis, strikethrough(gfm)
     * If the smart punctuation options is true,
     * convert single/double quotes to corresponding unicode characters.
     **/
    InlineParser.prototype.processEmphasis = function (stackBottom) {
        var _a;
        var opener;
        var closer;
        var oldCloser;
        var openerInl, closerInl;
        var openerFound;
        var oddMatch = false;
        var openersBottom = (_a = {},
            _a[C_UNDERSCORE] = [stackBottom, stackBottom, stackBottom],
            _a[C_ASTERISK] = [stackBottom, stackBottom, stackBottom],
            _a[C_SINGLEQUOTE] = [stackBottom],
            _a[C_DOUBLEQUOTE] = [stackBottom],
            _a[C_TILDE] = [stackBottom],
            _a[C_DOLLAR] = [stackBottom],
            _a);
        // find first closer above stackBottom:
        closer = this.delimiters;
        while (closer !== null && closer.previous !== stackBottom) {
            closer = closer.previous;
        }
        // move forward, looking for closers, and handling each
        while (closer !== null) {
            var closercc = closer.cc;
            var closerEmph = closercc === C_UNDERSCORE || closercc === C_ASTERISK;
            if (!closer.canClose) {
                closer = closer.next;
            }
            else {
                // found emphasis closer. now look back for first matching opener:
                opener = closer.previous;
                openerFound = false;
                while (opener !== null &&
                    opener !== stackBottom &&
                    opener !== openersBottom[closercc][closerEmph ? closer.origdelims % 3 : 0]) {
                    oddMatch =
                        closerEmph &&
                            (closer.canOpen || opener.canClose) &&
                            closer.origdelims % 3 !== 0 &&
                            (opener.origdelims + closer.origdelims) % 3 === 0;
                    if (opener.cc === closer.cc && opener.canOpen && !oddMatch) {
                        openerFound = true;
                        break;
                    }
                    opener = opener.previous;
                }
                oldCloser = closer;
                if (closerEmph || closercc === C_TILDE || closercc === C_DOLLAR) {
                    if (!openerFound) {
                        closer = closer.next;
                    }
                    else if (opener) {
                        // (null opener check for type narrowing)
                        // calculate actual number of delimiters used from closer
                        var useDelims = closer.numdelims >= 2 && opener.numdelims >= 2 ? 2 : 1;
                        var emptyDelims = closerEmph ? 0 : 1;
                        openerInl = opener.node;
                        closerInl = closer.node;
                        // build contents for new emph element
                        var nodeType = closerEmph
                            ? useDelims === 1
                                ? 'emph'
                                : 'strong'
                            : 'strike';
                        if (closercc === C_DOLLAR) {
                            nodeType = 'customInline';
                        }
                        var newNode = createNode(nodeType);
                        var openerEndPos = openerInl.sourcepos[1];
                        var closerStartPos = closerInl.sourcepos[0];
                        newNode.sourcepos = [
                            [openerEndPos[0], openerEndPos[1] - useDelims + 1],
                            [closerStartPos[0], closerStartPos[1] + useDelims - 1],
                        ];
                        openerInl.sourcepos[1][1] -= useDelims;
                        closerInl.sourcepos[0][1] += useDelims;
                        openerInl.literal = openerInl.literal.slice(useDelims);
                        closerInl.literal = closerInl.literal.slice(useDelims);
                        opener.numdelims -= useDelims;
                        closer.numdelims -= useDelims;
                        // remove used delimiters from stack elts and inlines
                        var tmp = openerInl.next;
                        var next = void 0;
                        while (tmp && tmp !== closerInl) {
                            next = tmp.next;
                            tmp.unlink();
                            newNode.appendChild(tmp);
                            tmp = next;
                        }
                        // build custom inline node
                        if (closercc === C_DOLLAR) {
                            var textNode = newNode.firstChild;
                            var literal = textNode.literal || '';
                            var info = literal.split(/\s/)[0];
                            newNode.info = info;
                            if (literal.length <= info.length) {
                                textNode.unlink();
                            }
                            else {
                                textNode.sourcepos[0][1] += info.length;
                                textNode.literal = literal.replace(info + " ", '');
                            }
                        }
                        openerInl.insertAfter(newNode);
                        // remove elts between opener and closer in delimiters stack
                        this.removeDelimitersBetween(opener, closer);
                        // if opener has 0 delims, remove it and the inline
                        // if opener has 1 delims and character is tilde, remove delimiter only
                        if (opener.numdelims <= emptyDelims) {
                            if (opener.numdelims === 0) {
                                openerInl.unlink();
                            }
                            this.removeDelimiter(opener);
                        }
                        // if closer has 0 delims, remove it and the inline
                        // if closer has 1 delims and character is tilde, remove delimiter only
                        if (closer.numdelims <= emptyDelims) {
                            if (closer.numdelims === 0) {
                                closerInl.unlink();
                            }
                            var tempstack = closer.next;
                            this.removeDelimiter(closer);
                            closer = tempstack;
                        }
                    }
                }
                else if (closercc === C_SINGLEQUOTE) {
                    closer.node.literal = '\u2019';
                    if (openerFound) {
                        opener.node.literal = '\u2018';
                    }
                    closer = closer.next;
                }
                else if (closercc === C_DOUBLEQUOTE) {
                    closer.node.literal = '\u201D';
                    if (openerFound) {
                        opener.node.literal = '\u201C';
                    }
                    closer = closer.next;
                }
                if (!openerFound) {
                    // Set lower bound for future searches for openers:
                    openersBottom[closercc][closerEmph ? oldCloser.origdelims % 3 : 0] = oldCloser.previous;
                    if (!oldCloser.canOpen) {
                        // We can remove a closer that can't be an opener,
                        // once we've seen there's no matching opener:
                        this.removeDelimiter(oldCloser);
                    }
                }
            }
        }
        // remove all delimiters
        while (this.delimiters !== null && this.delimiters !== stackBottom) {
            this.removeDelimiter(this.delimiters);
        }
    };
    // Attempt to parse link title (sans quotes), returning the string
    // or null if no match.
    InlineParser.prototype.parseLinkTitle = function () {
        var title = this.match(reLinkTitle);
        if (title === null) {
            return null;
        }
        // chop off quotes from title and unescape:
        return unescapeString(title.substr(1, title.length - 2));
    };
    // Attempt to parse link destination, returning the string or null if no match.
    InlineParser.prototype.parseLinkDestination = function () {
        var res = this.match(reLinkDestinationBraces);
        if (res === null) {
            if (this.peek() === C_LESSTHAN$1) {
                return null;
            }
            // @TODO handrolled parser; res should be null or the string
            var savepos = this.pos;
            var openparens = 0;
            var c = void 0;
            while ((c = this.peek()) !== -1) {
                if (c === C_BACKSLASH && reEscapable.test(this.subject.charAt(this.pos + 1))) {
                    this.pos += 1;
                    if (this.peek() !== -1) {
                        this.pos += 1;
                    }
                }
                else if (c === C_OPEN_PAREN) {
                    this.pos += 1;
                    openparens += 1;
                }
                else if (c === C_CLOSE_PAREN) {
                    if (openparens < 1) {
                        break;
                    }
                    else {
                        this.pos += 1;
                        openparens -= 1;
                    }
                }
                else if (reWhitespaceChar.exec(fromCodePoint$1(c)) !== null) {
                    break;
                }
                else {
                    this.pos += 1;
                }
            }
            if (this.pos === savepos && c !== C_CLOSE_PAREN) {
                return null;
            }
            if (openparens !== 0) {
                return null;
            }
            res = this.subject.substr(savepos, this.pos - savepos);
            return normalizeURI(unescapeString(res));
        } // chop off surrounding <..>:
        return normalizeURI(unescapeString(res.substr(1, res.length - 2)));
    };
    // Attempt to parse a link label, returning number of characters parsed.
    InlineParser.prototype.parseLinkLabel = function () {
        var m = this.match(reLinkLabel);
        if (m === null || m.length > 1001) {
            return 0;
        }
        return m.length;
    };
    // Add open bracket to delimiter stack and add a text node to block's children.
    InlineParser.prototype.parseOpenBracket = function (block) {
        var startpos = this.pos;
        this.pos += 1;
        var node = esm_text('[', this.sourcepos(this.pos, this.pos));
        block.appendChild(node);
        // Add entry to stack for this opener
        this.addBracket(node, startpos, false);
        return true;
    };
    // IF next character is [, and ! delimiter to delimiter stack and
    // add a text node to block's children.  Otherwise just add a text node.
    InlineParser.prototype.parseBang = function (block) {
        var startpos = this.pos;
        this.pos += 1;
        if (this.peek() === C_OPEN_BRACKET$1) {
            this.pos += 1;
            var node = esm_text('![', this.sourcepos(this.pos - 1, this.pos));
            block.appendChild(node);
            // Add entry to stack for this opener
            this.addBracket(node, startpos + 1, true);
        }
        else {
            var node = esm_text('!', this.sourcepos(this.pos, this.pos));
            block.appendChild(node);
        }
        return true;
    };
    // Try to match close bracket against an opening in the delimiter
    // stack.  Add either a link or image, or a plain [ character,
    // to block's children.  If there is a matching delimiter,
    // remove it from the delimiter stack.
    InlineParser.prototype.parseCloseBracket = function (block) {
        var dest = null;
        var title = null;
        var matched = false;
        this.pos += 1;
        var startpos = this.pos;
        // get last [ or ![
        var opener = this.brackets;
        if (opener === null) {
            // no matched opener, just return a literal
            block.appendChild(esm_text(']', this.sourcepos(startpos, startpos)));
            return true;
        }
        if (!opener.active) {
            // no matched opener, just return a literal
            block.appendChild(esm_text(']', this.sourcepos(startpos, startpos)));
            // take opener off brackets stack
            this.removeBracket();
            return true;
        }
        // If we got here, open is a potential opener
        var isImage = opener.image;
        // Check to see if we have a link/image
        var savepos = this.pos;
        // Inline link?
        if (this.peek() === C_OPEN_PAREN) {
            this.pos++;
            if (this.spnl() &&
                (dest = this.parseLinkDestination()) !== null &&
                this.spnl() &&
                // make sure there's a space before the title:
                ((reWhitespaceChar.test(this.subject.charAt(this.pos - 1)) &&
                    (title = this.parseLinkTitle())) ||
                    true) &&
                this.spnl() &&
                this.peek() === C_CLOSE_PAREN) {
                this.pos += 1;
                matched = true;
            }
            else {
                this.pos = savepos;
            }
        }
        var refLabel = '';
        if (!matched) {
            // Next, see if there's a link label
            var beforelabel = this.pos;
            var n = this.parseLinkLabel();
            if (n > 2) {
                refLabel = this.subject.slice(beforelabel, beforelabel + n);
            }
            else if (!opener.bracketAfter) {
                // Empty or missing second label means to use the first label as the reference.
                // The reference must not contain a bracket. If we know there's a bracket, we don't even bother checking it.
                refLabel = this.subject.slice(opener.index, startpos);
            }
            if (n === 0) {
                // If shortcut reference link, rewind before spaces we skipped.
                this.pos = savepos;
            }
            if (refLabel) {
                refLabel = normalizeReference(refLabel);
                // lookup rawlabel in refMap
                var link = this.refMap[refLabel];
                if (link) {
                    dest = link.destination;
                    title = link.title;
                    matched = true;
                }
            }
        }
        if (matched) {
            var node = createNode(isImage ? 'image' : 'link');
            node.destination = dest;
            node.title = title || '';
            node.sourcepos = [opener.startpos, this.sourcepos(this.pos)];
            var tmp = opener.node.next;
            var next = void 0;
            while (tmp) {
                next = tmp.next;
                tmp.unlink();
                node.appendChild(tmp);
                tmp = next;
            }
            block.appendChild(node);
            this.processEmphasis(opener.previousDelimiter);
            this.removeBracket();
            opener.node.unlink();
            // We remove this bracket and processEmphasis will remove later delimiters.
            // Now, for a link, we also deactivate earlier link openers.
            // (no links in links)
            if (!isImage) {
                opener = this.brackets;
                while (opener !== null) {
                    if (!opener.image) {
                        opener.active = false; // deactivate this opener
                    }
                    opener = opener.previous;
                }
            }
            if (this.options.referenceDefinition) {
                this.refLinkCandidateMap[block.id] = { node: block, refLabel: refLabel };
            }
            return true;
        } // no match
        this.removeBracket(); // remove this opener from stack
        this.pos = startpos;
        block.appendChild(esm_text(']', this.sourcepos(startpos, startpos)));
        if (this.options.referenceDefinition) {
            this.refLinkCandidateMap[block.id] = { node: block, refLabel: refLabel };
        }
        return true;
    };
    InlineParser.prototype.addBracket = function (node, index, image) {
        if (this.brackets !== null) {
            this.brackets.bracketAfter = true;
        }
        this.brackets = {
            node: node,
            startpos: this.sourcepos(index + (image ? 0 : 1)),
            previous: this.brackets,
            previousDelimiter: this.delimiters,
            index: index,
            image: image,
            active: true,
        };
    };
    InlineParser.prototype.removeBracket = function () {
        if (this.brackets) {
            this.brackets = this.brackets.previous;
        }
    };
    // Attempt to parse an entity.
    InlineParser.prototype.parseEntity = function (block) {
        var m;
        var startpos = this.pos + 1;
        if ((m = this.match(reEntityHere))) {
            block.appendChild(esm_text(lib.decodeHTML(m), this.sourcepos(startpos, this.pos)));
            return true;
        }
        return false;
    };
    // Parse a run of ordinary characters, or a single character with
    // a special meaning in markdown, as a plain string.
    InlineParser.prototype.parseString = function (block) {
        var m;
        var startpos = this.pos + 1;
        if ((m = this.match(reMain))) {
            if (this.options.smart) {
                var lit = m.replace(reEllipses, '\u2026').replace(reDash, function (chars) {
                    var enCount = 0;
                    var emCount = 0;
                    if (chars.length % 3 === 0) {
                        // If divisible by 3, use all em dashes
                        emCount = chars.length / 3;
                    }
                    else if (chars.length % 2 === 0) {
                        // If divisible by 2, use all en dashes
                        enCount = chars.length / 2;
                    }
                    else if (chars.length % 3 === 2) {
                        // If 2 extra dashes, use en dash for last 2; em dashes for rest
                        enCount = 1;
                        emCount = (chars.length - 2) / 3;
                    }
                    else {
                        // Use en dashes for last 4 hyphens; em dashes for rest
                        enCount = 2;
                        emCount = (chars.length - 4) / 3;
                    }
                    return esm_repeat('\u2014', emCount) + esm_repeat('\u2013', enCount);
                });
                block.appendChild(esm_text(lit, this.sourcepos(startpos, this.pos)));
            }
            else {
                var node = esm_text(m, this.sourcepos(startpos, this.pos));
                block.appendChild(node);
            }
            return true;
        }
        return false;
    };
    // Parse a newline.  If it was preceded by two spaces, return a hard
    // line break; otherwise a soft line break.
    InlineParser.prototype.parseNewline = function (block) {
        this.pos += 1; // assume we're at a \n
        // check previous node for trailing spaces
        var lastc = block.lastChild;
        if (lastc && lastc.type === 'text' && lastc.literal[lastc.literal.length - 1] === ' ') {
            var hardbreak = lastc.literal[lastc.literal.length - 2] === ' ';
            var litLen = lastc.literal.length;
            lastc.literal = lastc.literal.replace(reFinalSpace, '');
            var finalSpaceLen = litLen - lastc.literal.length;
            lastc.sourcepos[1][1] -= finalSpaceLen;
            block.appendChild(createNode(hardbreak ? 'linebreak' : 'softbreak', this.sourcepos(this.pos - finalSpaceLen, this.pos)));
        }
        else {
            block.appendChild(createNode('softbreak', this.sourcepos(this.pos, this.pos)));
        }
        this.nextLine();
        this.match(reInitialSpace); // gobble leading spaces in next line
        return true;
    };
    // Attempt to parse a link reference, modifying refmap.
    InlineParser.prototype.parseReference = function (block, refMap) {
        if (!this.options.referenceDefinition) {
            return 0;
        }
        this.subject = block.stringContent;
        this.pos = 0;
        var title = null;
        var startpos = this.pos;
        // label:
        var matchChars = this.parseLinkLabel();
        if (matchChars === 0) {
            return 0;
        }
        var rawlabel = this.subject.substr(0, matchChars);
        // colon:
        if (this.peek() === C_COLON) {
            this.pos++;
        }
        else {
            this.pos = startpos;
            return 0;
        }
        //  link url
        this.spnl();
        var dest = this.parseLinkDestination();
        if (dest === null) {
            this.pos = startpos;
            return 0;
        }
        var beforetitle = this.pos;
        this.spnl();
        if (this.pos !== beforetitle) {
            title = this.parseLinkTitle();
        }
        if (title === null) {
            title = '';
            // rewind before spaces
            this.pos = beforetitle;
        }
        // make sure we're at line end:
        var atLineEnd = true;
        if (this.match(reSpaceAtEndOfLine) === null) {
            if (title === '') {
                atLineEnd = false;
            }
            else {
                // the potential title we found is not at the line end,
                // but it could still be a legal link reference if we
                // discard the title
                title = '';
                // rewind before spaces
                this.pos = beforetitle;
                // and instead check if the link URL is at the line end
                atLineEnd = this.match(reSpaceAtEndOfLine) !== null;
            }
        }
        if (!atLineEnd) {
            this.pos = startpos;
            return 0;
        }
        var normalLabel = normalizeReference(rawlabel);
        if (normalLabel === '') {
            // label must contain non-whitespace characters
            this.pos = startpos;
            return 0;
        }
        var sourcepos = this.getReferenceDefSourcepos(block);
        block.sourcepos[0][0] = sourcepos[1][0] + 1;
        var node = createNode('refDef', sourcepos);
        node.title = title;
        node.dest = dest;
        node.label = normalLabel;
        block.insertBefore(node);
        if (!refMap[normalLabel]) {
            refMap[normalLabel] = createRefDefState(node);
        }
        else {
            this.refDefCandidateMap[node.id] = node;
        }
        return this.pos - startpos;
    };
    InlineParser.prototype.mergeTextNodes = function (walker) {
        var event;
        var textNodes = [];
        while ((event = walker.next())) {
            var entering = event.entering, node = event.node;
            if (entering && node.type === 'text') {
                textNodes.push(node);
            }
            else if (textNodes.length === 1) {
                textNodes = [];
            }
            else if (textNodes.length > 1) {
                var firstNode = textNodes[0];
                var lastNode = textNodes[textNodes.length - 1];
                if (firstNode.sourcepos && lastNode.sourcepos) {
                    firstNode.sourcepos[1] = lastNode.sourcepos[1];
                }
                firstNode.next = lastNode.next;
                if (firstNode.next) {
                    firstNode.next.prev = firstNode;
                }
                for (var i = 1; i < textNodes.length; i += 1) {
                    firstNode.literal += textNodes[i].literal;
                    textNodes[i].unlink();
                }
                textNodes = [];
            }
        }
    };
    InlineParser.prototype.getReferenceDefSourcepos = function (block) {
        var lines = block.stringContent.split(/\n|\r\n/);
        var passedUrlLine = false;
        var quotationCount = 0;
        var lastLineOffset = { line: 0, ch: 0 };
        for (var i = 0; i < lines.length; i += 1) {
            var line = lines[i];
            if (reWhitespaceChar.test(line)) {
                break;
            }
            if (/\:/.test(line) && quotationCount === 0) {
                if (passedUrlLine) {
                    break;
                }
                var lineOffset = line.indexOf(':') === line.length - 1 ? i + 1 : i;
                lastLineOffset = { line: lineOffset, ch: lines[lineOffset].length };
                passedUrlLine = true;
            }
            // should consider extendable title
            var matched = line.match(/'|"/g);
            if (matched) {
                quotationCount += matched.length;
            }
            if (quotationCount === 2) {
                lastLineOffset = { line: i, ch: line.length };
                break;
            }
        }
        return [
            [block.sourcepos[0][0], block.sourcepos[0][1]],
            [block.sourcepos[0][0] + lastLineOffset.line, lastLineOffset.ch],
        ];
    };
    // Parse the next inline element in subject, advancing subject position.
    // On success, add the result to block's children and return true.
    // On failure, return false.
    InlineParser.prototype.parseInline = function (block) {
        var _a;
        var res = false;
        var c = this.peek();
        if (c === -1) {
            return false;
        }
        switch (c) {
            case C_NEWLINE:
                res = this.parseNewline(block);
                break;
            case C_BACKSLASH:
                res = this.parseBackslash(block);
                break;
            case C_BACKTICK:
                res = this.parseBackticks(block);
                break;
            case C_ASTERISK:
            case C_UNDERSCORE:
            case C_TILDE:
            case C_DOLLAR:
                res = this.handleDelim(c, block);
                break;
            case C_SINGLEQUOTE:
            case C_DOUBLEQUOTE:
                res = !!((_a = this.options) === null || _a === void 0 ? void 0 : _a.smart) && this.handleDelim(c, block);
                break;
            case C_OPEN_BRACKET$1:
                res = this.parseOpenBracket(block);
                break;
            case C_BANG:
                res = this.parseBang(block);
                break;
            case C_CLOSE_BRACKET:
                res = this.parseCloseBracket(block);
                break;
            case C_LESSTHAN$1:
                res = this.parseAutolink(block) || this.parseHtmlTag(block);
                break;
            case C_AMPERSAND:
                if (!block.disabledEntityParse) {
                    res = this.parseEntity(block);
                }
                break;
            default:
                res = this.parseString(block);
                break;
        }
        if (!res) {
            this.pos += 1;
            block.appendChild(esm_text(fromCodePoint$1(c), this.sourcepos(this.pos, this.pos + 1)));
        }
        return true;
    };
    // Parse string content in block into inline children,
    // using refmap to resolve references.
    InlineParser.prototype.parse = function (block) {
        this.subject = block.stringContent.trim();
        this.pos = 0;
        this.delimiters = null;
        this.brackets = null;
        this.lineOffsets = block.lineOffsets || [0];
        this.lineIdx = 0;
        this.linePosOffset = 0;
        this.lineStartNum = block.sourcepos[0][0];
        if (isHeading(block)) {
            this.lineOffsets[0] += block.level + 1;
        }
        while (this.parseInline(block)) { }
        block.stringContent = null; // allow raw string to be garbage collected
        this.processEmphasis(null);
        this.mergeTextNodes(block.walker());
        var _a = this.options, extendedAutolinks = _a.extendedAutolinks, customParser = _a.customParser;
        if (extendedAutolinks) {
            convertExtAutoLinks(block.walker(), extendedAutolinks);
        }
        if (customParser && block.firstChild) {
            var event_1;
            var walker = block.firstChild.walker();
            while ((event_1 = walker.next())) {
                var node = event_1.node, entering = event_1.entering;
                if (customParser[node.type]) {
                    customParser[node.type](node, { entering: entering, options: this.options });
                }
            }
        }
    };
    return InlineParser;
}());
var reTaskListItemMarker = /^\[([ \txX])\][ \t]+/;
// finalize for block handler
function taskListItemFinalize(_, block) {
    if (block.firstChild && block.firstChild.type === 'paragraph') {
        var p = block.firstChild;
        var m = p.stringContent.match(reTaskListItemMarker);
        if (m) {
            var mLen = m[0].length;
            p.stringContent = p.stringContent.substring(mLen - 1);
            p.sourcepos[0][1] += mLen;
            p.lineOffsets[0] += mLen;
            block.listData.task = true;
            block.listData.checked = /[xX]/.test(m[1]);
        }
    }
}
var table = {
    continue: function () {
        return 0 /* Go */;
    },
    finalize: function () { },
    canContain: function (t) {
        return t === 'tableHead' || t === 'tableBody';
    },
    acceptsLines: false,
};
var tableBody$1 = {
    continue: function () {
        return 0 /* Go */;
    },
    finalize: function () { },
    canContain: function (t) {
        return t === 'tableRow';
    },
    acceptsLines: false,
};
var tableHead$1 = {
    continue: function () {
        return 1 /* Stop */;
    },
    finalize: function () { },
    canContain: function (t) {
        return t === 'tableRow' || t === 'tableDelimRow';
    },
    acceptsLines: false,
};
var tableDelimRow = {
    continue: function () {
        return 1 /* Stop */;
    },
    finalize: function () { },
    canContain: function (t) {
        return t === 'tableDelimCell';
    },
    acceptsLines: false,
};
var tableDelimCell = {
    continue: function () {
        return 1 /* Stop */;
    },
    finalize: function () { },
    canContain: function () {
        return false;
    },
    acceptsLines: false,
};
var tableRow = {
    continue: function () {
        return 1 /* Stop */;
    },
    finalize: function () { },
    canContain: function (t) {
        return t === 'tableCell';
    },
    acceptsLines: false,
};
var tableCell = {
    continue: function () {
        return 1 /* Stop */;
    },
    finalize: function () { },
    canContain: function () {
        return false;
    },
    acceptsLines: false,
};
var CODE_INDENT = 4;
var C_TAB = 9;
var C_GREATERTHAN = 62;
var C_LESSTHAN = 60;
var C_SPACE = 32;
var C_OPEN_BRACKET = 91;
var reNonSpace = /[^ \t\f\v\r\n]/;
var reClosingCodeFence = /^(?:`{3,}|~{3,})(?= *$)/;
// Returns true if block ends with a blank line, descending if needed
// into lists and sublists.
function endsWithBlankLine(block) {
    var curBlock = block;
    while (curBlock) {
        if (curBlock.lastLineBlank) {
            return true;
        }
        var t = curBlock.type;
        if (!curBlock.lastLineChecked && (t === 'list' || t === 'item')) {
            curBlock.lastLineChecked = true;
            curBlock = curBlock.lastChild;
        }
        else {
            curBlock.lastLineChecked = true;
            break;
        }
    }
    return false;
}
function peek(ln, pos) {
    if (pos < ln.length) {
        return ln.charCodeAt(pos);
    }
    return -1;
}
// Returns true if string contains only space characters.
function isBlank(s) {
    return !reNonSpace.test(s);
}
function isSpaceOrTab(c) {
    return c === C_SPACE || c === C_TAB;
}
var reClosingCustomBlock = /^\$\$$/;
var customBlock$1 = {
    continue: function (parser, container) {
        var line = parser.currentLine;
        var match = line.match(reClosingCustomBlock);
        if (match) {
            // closing custom block
            parser.lastLineLength = match[0].length;
            parser.finalize(container, parser.lineNumber);
            return 2 /* Finished */;
        }
        // skip optional spaces of custom block offset
        var i = container.offset;
        while (i > 0 && isSpaceOrTab(peek(line, parser.offset))) {
            parser.advanceOffset(1, true);
            i--;
        }
        return 0 /* Go */;
    },
    finalize: function (_, block) {
        if (block.stringContent === null) {
            return;
        }
        // first line becomes info string
        var content = block.stringContent;
        var newlinePos = content.indexOf('\n');
        var firstLine = content.slice(0, newlinePos);
        var rest = content.slice(newlinePos + 1);
        var infoString = firstLine.match(/^(\s*)(.*)/);
        block.info = unescapeString(infoString[2].trim());
        block.literal = rest;
        block.stringContent = null;
    },
    canContain: function () {
        return false;
    },
    acceptsLines: true,
};
var noop = {
    continue: function () {
        return 1 /* Stop */;
    },
    finalize: function () { },
    canContain: function () {
        return false;
    },
    acceptsLines: true,
};
var document$1 = {
    continue: function () {
        return 0 /* Go */;
    },
    finalize: function () { },
    canContain: function (t) {
        return t !== 'item';
    },
    acceptsLines: false,
};
var list = {
    continue: function () {
        return 0 /* Go */;
    },
    finalize: function (_, block) {
        var item = block.firstChild;
        while (item) {
            // check for non-final list item ending with blank line:
            if (endsWithBlankLine(item) && item.next) {
                block.listData.tight = false;
                break;
            }
            // recurse into children of list item, to see if there are
            // spaces between any of them:
            var subitem = item.firstChild;
            while (subitem) {
                if (endsWithBlankLine(subitem) && (item.next || subitem.next)) {
                    block.listData.tight = false;
                    break;
                }
                subitem = subitem.next;
            }
            item = item.next;
        }
    },
    canContain: function (t) {
        return t === 'item';
    },
    acceptsLines: false,
};
var blockQuote$1 = {
    continue: function (parser) {
        var ln = parser.currentLine;
        if (!parser.indented && peek(ln, parser.nextNonspace) === C_GREATERTHAN) {
            parser.advanceNextNonspace();
            parser.advanceOffset(1, false);
            if (isSpaceOrTab(peek(ln, parser.offset))) {
                parser.advanceOffset(1, true);
            }
        }
        else {
            return 1 /* Stop */;
        }
        return 0 /* Go */;
    },
    finalize: function () { },
    canContain: function (t) {
        return t !== 'item';
    },
    acceptsLines: false,
};
var esm_item = {
    continue: function (parser, container) {
        if (parser.blank) {
            if (container.firstChild === null) {
                // Blank line after empty list item
                return 1 /* Stop */;
            }
            parser.advanceNextNonspace();
        }
        else if (parser.indent >= container.listData.markerOffset + container.listData.padding) {
            parser.advanceOffset(container.listData.markerOffset + container.listData.padding, true);
        }
        else {
            return 1 /* Stop */;
        }
        return 0 /* Go */;
    },
    finalize: taskListItemFinalize,
    canContain: function (t) {
        return t !== 'item';
    },
    acceptsLines: false,
};
var esm_heading = {
    continue: function () {
        // a heading can never container > 1 line, so fail to match:
        return 1 /* Stop */;
    },
    finalize: function () { },
    canContain: function () {
        return false;
    },
    acceptsLines: false,
};
var thematicBreak$1 = {
    continue: function () {
        // a thematic break can never container > 1 line, so fail to match:
        return 1 /* Stop */;
    },
    finalize: function () { },
    canContain: function () {
        return false;
    },
    acceptsLines: false,
};
var esm_codeBlock = {
    continue: function (parser, container) {
        var ln = parser.currentLine;
        var indent = parser.indent;
        if (container.isFenced) {
            // fenced
            var match = indent <= 3 &&
                ln.charAt(parser.nextNonspace) === container.fenceChar &&
                ln.slice(parser.nextNonspace).match(reClosingCodeFence);
            if (match && match[0].length >= container.fenceLength) {
                // closing fence - we're at end of line, so we can return
                parser.lastLineLength = parser.offset + indent + match[0].length;
                parser.finalize(container, parser.lineNumber);
                return 2 /* Finished */;
            }
            // skip optional spaces of fence offset
            var i = container.fenceOffset;
            while (i > 0 && isSpaceOrTab(peek(ln, parser.offset))) {
                parser.advanceOffset(1, true);
                i--;
            }
        }
        else {
            // indented
            if (indent >= CODE_INDENT) {
                parser.advanceOffset(CODE_INDENT, true);
            }
            else if (parser.blank) {
                parser.advanceNextNonspace();
            }
            else {
                return 1 /* Stop */;
            }
        }
        return 0 /* Go */;
    },
    finalize: function (_, block) {
        var _a;
        if (block.stringContent === null) {
            return;
        }
        if (block.isFenced) {
            // fenced
            // first line becomes info string
            var content = block.stringContent;
            var newlinePos = content.indexOf('\n');
            var firstLine = content.slice(0, newlinePos);
            var rest = content.slice(newlinePos + 1);
            var infoString = firstLine.match(/^(\s*)(.*)/);
            block.infoPadding = infoString[1].length;
            block.info = unescapeString(infoString[2].trim());
            block.literal = rest;
        }
        else {
            // indented
            block.literal = (_a = block.stringContent) === null || _a === void 0 ? void 0 : _a.replace(/(\n *)+$/, '\n');
        }
        block.stringContent = null; // allow GC
    },
    canContain: function () {
        return false;
    },
    acceptsLines: true,
};
var htmlBlock$1 = {
    continue: function (parser, container) {
        return parser.blank && (container.htmlBlockType === 6 || container.htmlBlockType === 7)
            ? 1 /* Stop */
            : 0 /* Go */;
    },
    finalize: function (_, block) {
        var _a;
        block.literal = ((_a = block.stringContent) === null || _a === void 0 ? void 0 : _a.replace(/(\n *)+$/, '')) || null;
        block.stringContent = null; // allow GC
    },
    canContain: function () {
        return false;
    },
    acceptsLines: true,
};
var paragraph = {
    continue: function (parser) {
        return parser.blank ? 1 /* Stop */ : 0 /* Go */;
    },
    finalize: function (parser, block) {
        if (block.stringContent === null) {
            return;
        }
        var pos;
        var hasReferenceDefs = false;
        // try parsing the beginning as link reference definitions:
        while (peek(block.stringContent, 0) === C_OPEN_BRACKET &&
            (pos = parser.inlineParser.parseReference(block, parser.refMap))) {
            block.stringContent = block.stringContent.slice(pos);
            hasReferenceDefs = true;
        }
        if (hasReferenceDefs && isBlank(block.stringContent)) {
            block.unlink();
        }
    },
    canContain: function () {
        return false;
    },
    acceptsLines: true,
};
var refDef = noop;
var frontMatter$2 = noop;
var blockHandlers = {
    document: document$1,
    list: list,
    blockQuote: blockQuote$1,
    item: esm_item,
    heading: esm_heading,
    thematicBreak: thematicBreak$1,
    codeBlock: esm_codeBlock,
    htmlBlock: htmlBlock$1,
    paragraph: paragraph,
    table: table,
    tableBody: tableBody$1,
    tableHead: tableHead$1,
    tableRow: tableRow,
    tableCell: tableCell,
    tableDelimRow: tableDelimRow,
    tableDelimCell: tableDelimCell,
    refDef: refDef,
    customBlock: customBlock$1,
    frontMatter: frontMatter$2,
};
function parseRowContent(content) {
    var startIdx = 0;
    var offset = 0;
    var cells = [];
    for (var i = 0; i < content.length; i += 1) {
        if (content[i] === '|' && content[i - 1] !== '\\') {
            var cell = content.substring(startIdx, i);
            if (startIdx === 0 && isEmpty(cell)) {
                offset = i + 1;
            }
            else {
                cells.push(cell);
            }
            startIdx = i + 1;
        }
    }
    if (startIdx < content.length) {
        var cell = content.substring(startIdx, content.length);
        if (!isEmpty(cell)) {
            cells.push(cell);
        }
    }
    return [offset, cells];
}
function generateTableCells(cellType, contents, lineNum, chPos) {
    var cells = [];
    for (var _i = 0, contents_1 = contents; _i < contents_1.length; _i++) {
        var content = contents_1[_i];
        var preSpaces = content.match(/^[ \t]+/);
        var paddingLeft = preSpaces ? preSpaces[0].length : 0;
        var paddingRight = void 0, trimmed = void 0;
        if (paddingLeft === content.length) {
            paddingLeft = 0;
            paddingRight = 0;
            trimmed = '';
        }
        else {
            var postSpaces = content.match(/[ \t]+$/);
            paddingRight = postSpaces ? postSpaces[0].length : 0;
            trimmed = content.slice(paddingLeft, content.length - paddingRight);
        }
        var chPosStart = chPos + paddingLeft;
        var tableCell = createNode(cellType, [
            [lineNum, chPos],
            [lineNum, chPos + content.length - 1],
        ]);
        tableCell.stringContent = trimmed.replace(/\\\|/g, '|'); // replace esacped pipe(\|)
        tableCell.startIdx = cells.length;
        tableCell.endIdx = cells.length;
        tableCell.lineOffsets = [chPosStart - 1];
        tableCell.paddingLeft = paddingLeft;
        tableCell.paddingRight = paddingRight;
        cells.push(tableCell);
        chPos += content.length + 1;
    }
    return cells;
}
function getColumnFromDelimCell(cellNode) {
    var align = null;
    var content = cellNode.stringContent;
    var firstCh = content[0];
    var lastCh = content[content.length - 1];
    if (lastCh === ':') {
        align = firstCh === ':' ? 'center' : 'right';
    }
    else if (firstCh === ':') {
        align = 'left';
    }
    return { align: align };
}
var tableHead = function (parser, container) {
    var stringContent = container.stringContent;
    if (container.type === 'paragraph' && !parser.indented && !parser.blank) {
        var lastNewLineIdx = stringContent.length - 1;
        var lastLineStartIdx = stringContent.lastIndexOf('\n', lastNewLineIdx - 1) + 1;
        var headerContent = stringContent.slice(lastLineStartIdx, lastNewLineIdx);
        var delimContent = parser.currentLine.slice(parser.nextNonspace);
        var _a = parseRowContent(headerContent), headerOffset = _a[0], headerCells = _a[1];
        var _b = parseRowContent(delimContent), delimOffset = _b[0], delimCells = _b[1];
        var reValidDelimCell_1 = /^[ \t]*:?-+:?[ \t]*$/;
        if (
        // not checking if the number of header cells and delimiter cells are the same
        // to consider the case of merged-column (via plugin)
        !headerCells.length ||
            !delimCells.length ||
            delimCells.some(function (cell) { return !reValidDelimCell_1.test(cell); }) ||
            // to prevent to regard setTextHeading as tabel delim cell with 'disallowDeepHeading' option
            (delimCells.length === 1 && delimContent.indexOf('|') !== 0)) {
            return 0 /* None */;
        }
        var lineOffsets = container.lineOffsets;
        var firstLineNum = parser.lineNumber - 1;
        var firstLineStart = esm_last(lineOffsets) + 1;
        var table = createNode('table', [
            [firstLineNum, firstLineStart],
            [parser.lineNumber, parser.offset],
        ]);
        // eslint-disable-next-line arrow-body-style
        table.columns = delimCells.map(function () { return ({ align: null }); });
        container.insertAfter(table);
        if (lineOffsets.length === 1) {
            container.unlink();
        }
        else {
            container.stringContent = stringContent.slice(0, lastLineStartIdx);
            var paraLastLineStartIdx = stringContent.lastIndexOf('\n', lastLineStartIdx - 2) + 1;
            var paraLastLineLen = lastLineStartIdx - paraLastLineStartIdx - 1;
            parser.lastLineLength = lineOffsets[lineOffsets.length - 2] + paraLastLineLen;
            parser.finalize(container, firstLineNum - 1);
        }
        parser.advanceOffset(parser.currentLine.length - parser.offset, false);
        var tableHead_1 = createNode('tableHead', [
            [firstLineNum, firstLineStart],
            [parser.lineNumber, parser.offset],
        ]);
        table.appendChild(tableHead_1);
        var tableHeadRow_1 = createNode('tableRow', [
            [firstLineNum, firstLineStart],
            [firstLineNum, firstLineStart + headerContent.length - 1],
        ]);
        var tableDelimRow_1 = createNode('tableDelimRow', [
            [parser.lineNumber, parser.nextNonspace + 1],
            [parser.lineNumber, parser.offset],
        ]);
        tableHead_1.appendChild(tableHeadRow_1);
        tableHead_1.appendChild(tableDelimRow_1);
        generateTableCells('tableCell', headerCells, firstLineNum, firstLineStart + headerOffset).forEach(function (cellNode) {
            tableHeadRow_1.appendChild(cellNode);
        });
        var delimCellNodes = generateTableCells('tableDelimCell', delimCells, parser.lineNumber, parser.nextNonspace + 1 + delimOffset);
        delimCellNodes.forEach(function (cellNode) {
            tableDelimRow_1.appendChild(cellNode);
        });
        table.columns = delimCellNodes.map(getColumnFromDelimCell);
        parser.tip = table;
        return 2 /* Leaf */;
    }
    return 0 /* None */;
};
var tableBody = function (parser, container) {
    if ((container.type !== 'table' && container.type !== 'tableBody') ||
        (!parser.blank && parser.currentLine.indexOf('|') === -1)) {
        return 0 /* None */;
    }
    parser.advanceOffset(parser.currentLine.length - parser.offset, false);
    if (parser.blank) {
        var table_1 = container;
        if (container.type === 'tableBody') {
            table_1 = container.parent;
            parser.finalize(container, parser.lineNumber - 1);
        }
        parser.finalize(table_1, parser.lineNumber - 1);
        return 0 /* None */;
    }
    var tableBody = container;
    if (container.type === 'table') {
        tableBody = parser.addChild('tableBody', parser.nextNonspace);
        tableBody.stringContent = null;
    }
    var tableRow = createNode('tableRow', [
        [parser.lineNumber, parser.nextNonspace + 1],
        [parser.lineNumber, parser.currentLine.length],
    ]);
    tableBody.appendChild(tableRow);
    var table = tableBody.parent;
    var content = parser.currentLine.slice(parser.nextNonspace);
    var _a = parseRowContent(content), offset = _a[0], cellContents = _a[1];
    generateTableCells('tableCell', cellContents, parser.lineNumber, parser.nextNonspace + 1 + offset).forEach(function (cellNode, idx) {
        if (idx >= table.columns.length) {
            cellNode.ignored = true;
        }
        tableRow.appendChild(cellNode);
    });
    return 2 /* Leaf */;
};
var reCustomBlock = /^(\$\$)(\s*[a-zA-Z])+/;
var reCanBeCustomInline = /^(\$\$)(\s*[a-zA-Z])+.*(\$\$)/;
var esm_customBlock = function (parser) {
    var match;
    if (!parser.indented &&
        !reCanBeCustomInline.test(parser.currentLine) &&
        (match = parser.currentLine.match(reCustomBlock))) {
        var syntaxLength = match[1].length;
        parser.closeUnmatchedBlocks();
        var container = parser.addChild('customBlock', parser.nextNonspace);
        container.syntaxLength = syntaxLength;
        container.offset = parser.indent;
        parser.advanceNextNonspace();
        parser.advanceOffset(syntaxLength, false);
        return 2 /* Leaf */;
    }
    return 0 /* None */;
};
var reCodeFence = /^`{3,}(?!.*`)|^~{3,}/;
var reHtmlBlockOpen = [
    /./,
    /^<(?:script|pre|style)(?:\s|>|$)/i,
    /^<!--/,
    /^<[?]/,
    /^<![A-Z]/,
    /^<!\[CDATA\[/,
    /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|[/]?[>]|$)/i,
    new RegExp("^(?:" + OPENTAG + "|" + CLOSETAG + ")\\s*$", 'i'),
];
var reSetextHeadingLine = /^(?:=+|-+)[ \t]*$/;
var reATXHeadingMarker = /^#{1,6}(?:[ \t]+|$)/;
var reThematicBreak = /^(?:(?:\*[ \t]*){3,}|(?:_[ \t]*){3,}|(?:-[ \t]*){3,})[ \t]*$/;
var reBulletListMarker = /^[*+-]/;
var reOrderedListMarker = /^(\d{1,9})([.)])/;
// Parse a list marker and return data on the marker (type,
// start, delimiter, bullet character, padding) or null.
function parseListMarker(parser, container) {
    var rest = parser.currentLine.slice(parser.nextNonspace);
    var match;
    var nextc;
    var data = {
        type: 'bullet',
        tight: true,
        bulletChar: '',
        start: 0,
        delimiter: '',
        padding: 0,
        markerOffset: parser.indent,
        // GFM: Task List Item
        task: false,
        checked: false,
    };
    if (parser.indent >= 4) {
        return null;
    }
    if ((match = rest.match(reBulletListMarker))) {
        data.type = 'bullet';
        data.bulletChar = match[0][0];
    }
    else if ((match = rest.match(reOrderedListMarker)) &&
        (container.type !== 'paragraph' || match[1] === '1')) {
        data.type = 'ordered';
        data.start = parseInt(match[1], 10);
        data.delimiter = match[2];
    }
    else {
        return null;
    }
    // make sure we have spaces after
    nextc = peek(parser.currentLine, parser.nextNonspace + match[0].length);
    if (!(nextc === -1 || nextc === C_TAB || nextc === C_SPACE)) {
        return null;
    }
    // if it interrupts paragraph, make sure first line isn't blank
    if (container.type === 'paragraph' &&
        !parser.currentLine.slice(parser.nextNonspace + match[0].length).match(reNonSpace)) {
        return null;
    }
    // we've got a match! advance offset and calculate padding
    parser.advanceNextNonspace(); // to start of marker
    parser.advanceOffset(match[0].length, true); // to end of marker
    var spacesStartCol = parser.column;
    var spacesStartOffset = parser.offset;
    do {
        parser.advanceOffset(1, true);
        nextc = peek(parser.currentLine, parser.offset);
    } while (parser.column - spacesStartCol < 5 && isSpaceOrTab(nextc));
    var blankItem = peek(parser.currentLine, parser.offset) === -1;
    var spacesAfterMarker = parser.column - spacesStartCol;
    if (spacesAfterMarker >= 5 || spacesAfterMarker < 1 || blankItem) {
        data.padding = match[0].length + 1;
        parser.column = spacesStartCol;
        parser.offset = spacesStartOffset;
        if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {
            parser.advanceOffset(1, true);
        }
    }
    else {
        data.padding = match[0].length + spacesAfterMarker;
    }
    return data;
}
// Returns true if the two list items are of the same type,
// with the same delimiter and bullet character.  This is used
// in agglomerating list items into lists.
function listsMatch(listData, itemData) {
    return (listData.type === itemData.type &&
        listData.delimiter === itemData.delimiter &&
        listData.bulletChar === itemData.bulletChar);
}
function isDisallowedDeepHeading(parser, node) {
    return parser.options.disallowDeepHeading && (node.type === 'blockQuote' || node.type === 'item');
}
var esm_blockQuote = function (parser) {
    if (!parser.indented && peek(parser.currentLine, parser.nextNonspace) === C_GREATERTHAN) {
        parser.advanceNextNonspace();
        parser.advanceOffset(1, false);
        // optional following space
        if (isSpaceOrTab(peek(parser.currentLine, parser.offset))) {
            parser.advanceOffset(1, true);
        }
        parser.closeUnmatchedBlocks();
        parser.addChild('blockQuote', parser.nextNonspace);
        return 1 /* Container */;
    }
    return 0 /* None */;
};
var atxHeading = function (parser, container) {
    var match;
    if (!parser.indented &&
        // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
        !isDisallowedDeepHeading(parser, container) &&
        (match = parser.currentLine.slice(parser.nextNonspace).match(reATXHeadingMarker))) {
        parser.advanceNextNonspace();
        parser.advanceOffset(match[0].length, false);
        parser.closeUnmatchedBlocks();
        var heading = parser.addChild('heading', parser.nextNonspace);
        heading.level = match[0].trim().length; // number of #s
        heading.headingType = 'atx';
        // remove trailing ###s:
        heading.stringContent = parser.currentLine
            .slice(parser.offset)
            .replace(/^[ \t]*#+[ \t]*$/, '')
            .replace(/[ \t]+#+[ \t]*$/, '');
        parser.advanceOffset(parser.currentLine.length - parser.offset);
        return 2 /* Leaf */;
    }
    return 0 /* None */;
};
var fencedCodeBlock = function (parser) {
    var match;
    if (!parser.indented &&
        (match = parser.currentLine.slice(parser.nextNonspace).match(reCodeFence))) {
        var fenceLength = match[0].length;
        parser.closeUnmatchedBlocks();
        var container = parser.addChild('codeBlock', parser.nextNonspace);
        container.isFenced = true;
        container.fenceLength = fenceLength;
        container.fenceChar = match[0][0];
        container.fenceOffset = parser.indent;
        parser.advanceNextNonspace();
        parser.advanceOffset(fenceLength, false);
        return 2 /* Leaf */;
    }
    return 0 /* None */;
};
var htmlBlock = function (parser, container) {
    if (!parser.indented && peek(parser.currentLine, parser.nextNonspace) === C_LESSTHAN) {
        var s = parser.currentLine.slice(parser.nextNonspace);
        var disallowedTags = parser.options.disallowedHtmlBlockTags;
        var blockType = void 0;
        for (blockType = 1; blockType <= 7; blockType++) {
            var matched = s.match(reHtmlBlockOpen[blockType]);
            if (matched) {
                if (blockType === 7) {
                    if (container.type === 'paragraph') {
                        return 0 /* None */;
                    }
                    if (disallowedTags.length > 0) {
                        var reDisallowedTags = new RegExp("</?(?:" + disallowedTags.join('|') + ")", 'i');
                        if (reDisallowedTags.test(matched[0])) {
                            return 0 /* None */;
                        }
                    }
                }
                parser.closeUnmatchedBlocks();
                // We don't adjust parser.offset;
                // spaces are part of the HTML block:
                var b = parser.addChild('htmlBlock', parser.offset);
                b.htmlBlockType = blockType;
                return 2 /* Leaf */;
            }
        }
    }
    return 0 /* None */;
};
var seTextHeading = function (parser, container) {
    var match;
    if (container.stringContent !== null &&
        !parser.indented &&
        container.type === 'paragraph' &&
        // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
        !isDisallowedDeepHeading(parser, container.parent) &&
        (match = parser.currentLine.slice(parser.nextNonspace).match(reSetextHeadingLine))) {
        parser.closeUnmatchedBlocks();
        // resolve reference link definitions
        var pos = void 0;
        while (peek(container.stringContent, 0) === C_OPEN_BRACKET &&
            (pos = parser.inlineParser.parseReference(container, parser.refMap))) {
            container.stringContent = container.stringContent.slice(pos);
        }
        if (container.stringContent.length > 0) {
            var heading = createNode('heading', container.sourcepos);
            heading.level = match[0][0] === '=' ? 1 : 2;
            heading.headingType = 'setext';
            heading.stringContent = container.stringContent;
            container.insertAfter(heading);
            container.unlink();
            parser.tip = heading;
            parser.advanceOffset(parser.currentLine.length - parser.offset, false);
            return 2 /* Leaf */;
        }
        return 0 /* None */;
    }
    return 0 /* None */;
};
var thematicBreak = function (parser) {
    if (!parser.indented && reThematicBreak.test(parser.currentLine.slice(parser.nextNonspace))) {
        parser.closeUnmatchedBlocks();
        parser.addChild('thematicBreak', parser.nextNonspace);
        parser.advanceOffset(parser.currentLine.length - parser.offset, false);
        return 2 /* Leaf */;
    }
    return 0 /* None */;
};
var listItem = function (parser, container) {
    var data;
    var currNode = container;
    if ((!parser.indented || container.type === 'list') &&
        (data = parseListMarker(parser, currNode))) {
        parser.closeUnmatchedBlocks();
        // add the list if needed
        if (parser.tip.type !== 'list' || !listsMatch(currNode.listData, data)) {
            currNode = parser.addChild('list', parser.nextNonspace);
            currNode.listData = data;
        }
        // add the list item
        currNode = parser.addChild('item', parser.nextNonspace);
        currNode.listData = data;
        return 1 /* Container */;
    }
    return 0 /* None */;
};
// indented code block
var indentedCodeBlock = function (parser) {
    if (parser.indented && parser.tip.type !== 'paragraph' && !parser.blank) {
        // indented code
        parser.advanceOffset(CODE_INDENT, true);
        parser.closeUnmatchedBlocks();
        parser.addChild('codeBlock', parser.offset);
        return 2 /* Leaf */;
    }
    return 0 /* None */;
};
var blockStarts = [
    esm_blockQuote,
    atxHeading,
    fencedCodeBlock,
    htmlBlock,
    seTextHeading,
    thematicBreak,
    listItem,
    indentedCodeBlock,
    tableHead,
    tableBody,
    esm_customBlock,
];
// `---` for YAML, `+++` for TOML, `;;;` for JSON
var reFrontMatter = /^(-{3}|\+{3}|;{3})$/;
var frontMatter$1 = function (parser, container) {
    var currentLine = parser.currentLine, lineNumber = parser.lineNumber, indented = parser.indented;
    if (lineNumber === 1 &&
        !indented &&
        container.type === 'document' &&
        reFrontMatter.test(currentLine)) {
        parser.closeUnmatchedBlocks();
        var frontMatter_1 = parser.addChild('frontMatter', parser.nextNonspace);
        frontMatter_1.stringContent = currentLine;
        parser.advanceNextNonspace();
        parser.advanceOffset(currentLine.length, false);
        return 2 /* Leaf */;
    }
    return 0 /* None */;
};
var frontMatter = {
    continue: function (parser, container) {
        var line = parser.currentLine;
        var match = line.match(reFrontMatter);
        if (container.type === 'frontMatter' && match) {
            container.stringContent += line;
            parser.lastLineLength = match[0].length;
            parser.finalize(container, parser.lineNumber);
            return 2 /* Finished */;
        }
        return 0 /* Go */;
    },
    finalize: function (_, block) {
        if (block.stringContent === null) {
            return;
        }
        block.literal = block.stringContent;
        block.stringContent = null;
    },
    canContain: function () {
        return false;
    },
    acceptsLines: true,
};
var reHtmlBlockClose = [
    /./,
    /<\/(?:script|pre|style)>/i,
    /-->/,
    /\?>/,
    />/,
    /\]\]>/,
];
var reMaybeSpecial = /^[#`~*+_=<>0-9-;$]/;
var reLineEnding$1 = /\r\n|\n|\r/;
function esm_document() {
    return createNode('document', [
        [1, 1],
        [0, 0],
    ]);
}
var defaultOptions$1 = {
    smart: false,
    tagFilter: false,
    extendedAutolinks: false,
    disallowedHtmlBlockTags: [],
    referenceDefinition: false,
    disallowDeepHeading: false,
    customParser: null,
    frontMatter: false,
};
var Parser = /** @class */ (function () {
    function Parser(options) {
        this.options = esm_assign(esm_assign({}, defaultOptions$1), options);
        this.doc = esm_document();
        this.tip = this.doc;
        this.oldtip = this.doc;
        this.lineNumber = 0;
        this.offset = 0;
        this.column = 0;
        this.nextNonspace = 0;
        this.nextNonspaceColumn = 0;
        this.indent = 0;
        this.currentLine = '';
        this.indented = false;
        this.blank = false;
        this.partiallyConsumedTab = false;
        this.allClosed = true;
        this.lastMatchedContainer = this.doc;
        this.refMap = {};
        this.refLinkCandidateMap = {};
        this.refDefCandidateMap = {};
        this.lastLineLength = 0;
        this.lines = [];
        if (this.options.frontMatter) {
            blockHandlers.frontMatter = frontMatter;
            blockStarts.unshift(frontMatter$1);
        }
        this.inlineParser = new InlineParser(this.options);
    }
    Parser.prototype.advanceOffset = function (count, columns) {
        if (columns === void 0) {
            columns = false;
        }
        var currentLine = this.currentLine;
        var charsToTab, charsToAdvance;
        var c;
        while (count > 0 && (c = currentLine[this.offset])) {
            if (c === '\t') {
                charsToTab = 4 - (this.column % 4);
                if (columns) {
                    this.partiallyConsumedTab = charsToTab > count;
                    charsToAdvance = charsToTab > count ? count : charsToTab;
                    this.column += charsToAdvance;
                    this.offset += this.partiallyConsumedTab ? 0 : 1;
                    count -= charsToAdvance;
                }
                else {
                    this.partiallyConsumedTab = false;
                    this.column += charsToTab;
                    this.offset += 1;
                    count -= 1;
                }
            }
            else {
                this.partiallyConsumedTab = false;
                this.offset += 1;
                this.column += 1; // assume ascii; block starts are ascii
                count -= 1;
            }
        }
    };
    Parser.prototype.advanceNextNonspace = function () {
        this.offset = this.nextNonspace;
        this.column = this.nextNonspaceColumn;
        this.partiallyConsumedTab = false;
    };
    Parser.prototype.findNextNonspace = function () {
        var currentLine = this.currentLine;
        var i = this.offset;
        var cols = this.column;
        var c;
        while ((c = currentLine.charAt(i)) !== '') {
            if (c === ' ') {
                i++;
                cols++;
            }
            else if (c === '\t') {
                i++;
                cols += 4 - (cols % 4);
            }
            else {
                break;
            }
        }
        this.blank = c === '\n' || c === '\r' || c === '';
        this.nextNonspace = i;
        this.nextNonspaceColumn = cols;
        this.indent = this.nextNonspaceColumn - this.column;
        this.indented = this.indent >= CODE_INDENT;
    };
    // Add a line to the block at the tip.  We assume the tip
    // can accept lines -- that check should be done before calling this.
    Parser.prototype.addLine = function () {
        if (this.partiallyConsumedTab) {
            this.offset += 1; // skip over tab
            // add space characters:
            var charsToTab = 4 - (this.column % 4);
            this.tip.stringContent += esm_repeat(' ', charsToTab);
        }
        if (this.tip.lineOffsets) {
            this.tip.lineOffsets.push(this.offset);
        }
        else {
            this.tip.lineOffsets = [this.offset];
        }
        this.tip.stringContent += this.currentLine.slice(this.offset) + "\n";
    };
    // Add block of type tag as a child of the tip.  If the tip can't
    // accept children, close and finalize it and try its parent,
    // and so on til we find a block that can accept children.
    Parser.prototype.addChild = function (tag, offset) {
        while (!blockHandlers[this.tip.type].canContain(tag)) {
            this.finalize(this.tip, this.lineNumber - 1);
        }
        var columnNumber = offset + 1; // offset 0 = column 1
        var newBlock = createNode(tag, [
            [this.lineNumber, columnNumber],
            [0, 0],
        ]);
        newBlock.stringContent = '';
        this.tip.appendChild(newBlock);
        this.tip = newBlock;
        return newBlock;
    };
    // Finalize and close any unmatched blocks.
    Parser.prototype.closeUnmatchedBlocks = function () {
        if (!this.allClosed) {
            // finalize any blocks not matched
            while (this.oldtip !== this.lastMatchedContainer) {
                var parent_1 = this.oldtip.parent;
                this.finalize(this.oldtip, this.lineNumber - 1);
                this.oldtip = parent_1;
            }
            this.allClosed = true;
        }
    };
    // Finalize a block.  Close it and do any necessary postprocessing,
    // e.g. creating stringContent from strings, setting the 'tight'
    // or 'loose' status of a list, and parsing the beginnings
    // of paragraphs for reference definitions.  Reset the tip to the
    // parent of the closed block.
    Parser.prototype.finalize = function (block, lineNumber) {
        var above = block.parent;
        block.open = false;
        block.sourcepos[1] = [lineNumber, this.lastLineLength];
        blockHandlers[block.type].finalize(this, block);
        this.tip = above;
    };
    // Walk through a block & children recursively, parsing string content
    // into inline content where appropriate.
    Parser.prototype.processInlines = function (block) {
        var event;
        var customParser = this.options.customParser;
        var walker = block.walker();
        this.inlineParser.refMap = this.refMap;
        this.inlineParser.refLinkCandidateMap = this.refLinkCandidateMap;
        this.inlineParser.refDefCandidateMap = this.refDefCandidateMap;
        this.inlineParser.options = this.options;
        while ((event = walker.next())) {
            var node = event.node, entering = event.entering;
            var t = node.type;
            if (customParser && customParser[t]) {
                customParser[t](node, { entering: entering, options: this.options });
            }
            if (!entering &&
                (t === 'paragraph' ||
                    t === 'heading' ||
                    (t === 'tableCell' && !node.ignored))) {
                this.inlineParser.parse(node);
            }
        }
    };
    // Analyze a line of text and update the document appropriately.
    // We parse markdown text by calling this on each line of input,
    // then finalizing the document.
    Parser.prototype.incorporateLine = function (ln) {
        var container = this.doc;
        this.oldtip = this.tip;
        this.offset = 0;
        this.column = 0;
        this.blank = false;
        this.partiallyConsumedTab = false;
        this.lineNumber += 1;
        // replace NUL characters for security
        if (ln.indexOf('\u0000') !== -1) {
            ln = ln.replace(/\0/g, '\uFFFD');
        }
        this.currentLine = ln;
        // For each containing block, try to parse the associated line start.
        // Bail out on failure: container will point to the last matching block.
        // Set allMatched to false if not all containers match.
        var allMatched = true;
        var lastChild;
        while ((lastChild = container.lastChild) && lastChild.open) {
            container = lastChild;
            this.findNextNonspace();
            switch (blockHandlers[container.type]['continue'](this, container)) {
                case 0 /* Go */: // we've matched, keep going
                    break;
                case 1 /* Stop */: // we've failed to match a block
                    allMatched = false;
                    break;
                case 2 /* Finished */: // we've hit end of line for fenced code close and can return
                    this.lastLineLength = ln.length;
                    return;
                default:
                    throw new Error('continue returned illegal value, must be 0, 1, or 2');
            }
            if (!allMatched) {
                container = container.parent; // back up to last matching block
                break;
            }
        }
        this.allClosed = container === this.oldtip;
        this.lastMatchedContainer = container;
        var matchedLeaf = container.type !== 'paragraph' && blockHandlers[container.type].acceptsLines;
        var blockStartsLen = blockStarts.length;
        // Unless last matched container is a code block, try new container starts,
        // adding children to the last matched container:
        while (!matchedLeaf) {
            this.findNextNonspace();
            // this is a little performance optimization:
            if (container.type !== 'table' &&
                container.type !== 'tableBody' &&
                container.type !== 'paragraph' &&
                !this.indented &&
                !reMaybeSpecial.test(ln.slice(this.nextNonspace))) {
                this.advanceNextNonspace();
                break;
            }
            var i = 0;
            while (i < blockStartsLen) {
                var res = blockStarts[i](this, container);
                if (res === 1 /* Container */) {
                    container = this.tip;
                    break;
                }
                else if (res === 2 /* Leaf */) {
                    container = this.tip;
                    matchedLeaf = true;
                    break;
                }
                else {
                    i++;
                }
            }
            if (i === blockStartsLen) {
                // nothing matched
                this.advanceNextNonspace();
                break;
            }
        }
        // What remains at the offset is a text line.  Add the text to the
        // appropriate container.
        // First check for a lazy paragraph continuation:
        if (!this.allClosed && !this.blank && this.tip.type === 'paragraph') {
            // lazy paragraph continuation
            this.addLine();
        }
        else {
            // not a lazy continuation
            // finalize any blocks not matched
            this.closeUnmatchedBlocks();
            if (this.blank && container.lastChild) {
                container.lastChild.lastLineBlank = true;
            }
            var t = container.type;
            // Block quote lines are never blank as they start with >
            // and we don't count blanks in fenced code for purposes of tight/loose
            // lists or breaking out of lists. We also don't set _lastLineBlank
            // on an empty list item, or if we just closed a fenced block.
            var lastLineBlank = this.blank &&
                !(t === 'blockQuote' ||
                    (isCodeBlock(container) && container.isFenced) ||
                    (t === 'item' && !container.firstChild && container.sourcepos[0][0] === this.lineNumber));
            // propagate lastLineBlank up through parents:
            var cont = container;
            while (cont) {
                cont.lastLineBlank = lastLineBlank;
                cont = cont.parent;
            }
            if (blockHandlers[t].acceptsLines) {
                this.addLine();
                // if HtmlBlock, check for end condition
                if (isHtmlBlock(container) &&
                    container.htmlBlockType >= 1 &&
                    container.htmlBlockType <= 5 &&
                    reHtmlBlockClose[container.htmlBlockType].test(this.currentLine.slice(this.offset))) {
                    this.lastLineLength = ln.length;
                    this.finalize(container, this.lineNumber);
                }
            }
            else if (this.offset < ln.length && !this.blank) {
                // create paragraph container for line
                container = this.addChild('paragraph', this.offset);
                this.advanceNextNonspace();
                this.addLine();
            }
        }
        this.lastLineLength = ln.length;
    };
    // The main parsing function.  Returns a parsed document AST.
    Parser.prototype.parse = function (input, lineTexts) {
        this.doc = esm_document();
        this.tip = this.doc;
        this.lineNumber = 0;
        this.lastLineLength = 0;
        this.offset = 0;
        this.column = 0;
        this.lastMatchedContainer = this.doc;
        this.currentLine = '';
        var lines = input.split(reLineEnding$1);
        var len = lines.length;
        this.lines = lineTexts ? lineTexts : lines;
        if (this.options.referenceDefinition) {
            this.clearRefMaps();
        }
        if (input.charCodeAt(input.length - 1) === C_NEWLINE) {
            // ignore last blank line created by final newline
            len -= 1;
        }
        for (var i = 0; i < len; i++) {
            this.incorporateLine(lines[i]);
        }
        while (this.tip) {
            this.finalize(this.tip, len);
        }
        this.processInlines(this.doc);
        return this.doc;
    };
    Parser.prototype.partialParseStart = function (lineNumber, lines) {
        this.doc = esm_document();
        this.tip = this.doc;
        this.lineNumber = lineNumber - 1;
        this.lastLineLength = 0;
        this.offset = 0;
        this.column = 0;
        this.lastMatchedContainer = this.doc;
        this.currentLine = '';
        var len = lines.length;
        for (var i = 0; i < len; i++) {
            this.incorporateLine(lines[i]);
        }
        return this.doc;
    };
    Parser.prototype.partialParseExtends = function (lines) {
        for (var i = 0; i < lines.length; i++) {
            this.incorporateLine(lines[i]);
        }
    };
    Parser.prototype.partialParseFinish = function () {
        while (this.tip) {
            this.finalize(this.tip, this.lineNumber);
        }
        this.processInlines(this.doc);
    };
    Parser.prototype.setRefMaps = function (refMap, refLinkCandidateMap, refDefCandidateMap) {
        this.refMap = refMap;
        this.refLinkCandidateMap = refLinkCandidateMap;
        this.refDefCandidateMap = refDefCandidateMap;
    };
    Parser.prototype.clearRefMaps = function () {
        [this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function (map) {
            clearObj(map);
        });
    };
    return Parser;
}());
function comparePos(p1, p2) {
    if (p1[0] < p2[0]) {
        return 1 /* LT */;
    }
    if (p1[0] > p2[0]) {
        return -1 /* GT */;
    }
    if (p1[1] < p2[1]) {
        return 1 /* LT */;
    }
    if (p1[1] > p2[1]) {
        return -1 /* GT */;
    }
    return 0 /* EQ */;
}
function compareRangeAndPos(_a, pos) {
    var startPos = _a[0], endPos = _a[1];
    if (comparePos(endPos, pos) === 1 /* LT */) {
        return 1 /* LT */;
    }
    if (comparePos(startPos, pos) === -1 /* GT */) {
        return -1 /* GT */;
    }
    return 0 /* EQ */;
}
function removeNextUntil(node, last) {
    if (node.parent !== last.parent || node === last) {
        return;
    }
    var next = node.next;
    while (next && next !== last) {
        var temp = next.next;
        for (var _i = 0, _a = ['parent', 'prev', 'next']; _i < _a.length; _i++) {
            var type = _a[_i];
            if (next[type]) {
                removeNodeById(next[type].id);
                next[type] = null;
            }
        }
        next = temp;
    }
    node.next = last.next;
    if (last.next) {
        last.next.prev = node;
    }
    else {
        node.parent.lastChild = node;
    }
}
function getChildNodes(parent) {
    var nodes = [];
    var curr = parent.firstChild;
    while (curr) {
        nodes.push(curr);
        curr = curr.next;
    }
    return nodes;
}
function insertNodesBefore(target, nodes) {
    for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var node = nodes_1[_i];
        target.insertBefore(node);
    }
}
function prependChildNodes(parent, nodes) {
    for (var i = nodes.length - 1; i >= 0; i -= 1) {
        parent.prependChild(nodes[i]);
    }
}
function updateNextLineNumbers(base, diff) {
    if (!base || !base.parent || diff === 0) {
        return;
    }
    var walker = base.parent.walker();
    walker.resumeAt(base, true);
    var event;
    while ((event = walker.next())) {
        var node = event.node, entering = event.entering;
        if (entering) {
            node.sourcepos[0][0] += diff;
            node.sourcepos[1][0] += diff;
        }
    }
}
function compareRangeAndLine(_a, line) {
    var startPos = _a[0], endPos = _a[1];
    if (endPos[0] < line) {
        return 1 /* LT */;
    }
    if (startPos[0] > line) {
        return -1 /* GT */;
    }
    return 0 /* EQ */;
}
function findChildNodeAtLine(parent, line) {
    var node = parent.firstChild;
    while (node) {
        var comp = compareRangeAndLine(node.sourcepos, line);
        if (comp === 0 /* EQ */) {
            return node;
        }
        if (comp === -1 /* GT */) {
            // To consider that top line is blank line
            return node.prev || node;
        }
        node = node.next;
    }
    return parent.lastChild;
}
function lastLeafNode(node) {
    while (node.lastChild) {
        node = node.lastChild;
    }
    return node;
}
function sameLineTopAncestor(node) {
    while (node.parent &&
        node.parent.type !== 'document' &&
        node.parent.sourcepos[0][0] === node.sourcepos[0][0]) {
        node = node.parent;
    }
    return node;
}
function findFirstNodeAtLine(parent, line) {
    var node = parent.firstChild;
    var prev = null;
    while (node) {
        var comp = compareRangeAndLine(node.sourcepos, line);
        if (comp === 0 /* EQ */) {
            if (node.sourcepos[0][0] === line || !node.firstChild) {
                return node;
            }
            prev = node;
            node = node.firstChild;
        }
        else if (comp === -1 /* GT */) {
            break;
        }
        else {
            prev = node;
            node = node.next;
        }
    }
    if (prev) {
        return sameLineTopAncestor(lastLeafNode(prev));
    }
    return null;
}
function findNodeAtPosition(parent, pos) {
    var node = parent;
    var prev = null;
    while (node) {
        var comp = compareRangeAndPos(node.sourcepos, pos);
        if (comp === 0 /* EQ */) {
            if (node.firstChild) {
                prev = node;
                node = node.firstChild;
            }
            else {
                return node;
            }
        }
        else if (comp === -1 /* GT */) {
            return prev;
        }
        else if (node.next) {
            node = node.next;
        }
        else {
            return prev;
        }
    }
    return node;
}
function findNodeById(id) {
    return getNodeById(id) || null;
}
function invokeNextUntil(callback, start, end) {
    if (end === void 0) {
        end = null;
    }
    if (start) {
        var walker = start.walker();
        while (start && start !== end) {
            callback(start);
            var next = walker.next();
            if (next) {
                start = next.node;
            }
            else {
                break;
            }
        }
    }
}
function isUnlinked(id) {
    var node = findNodeById(id);
    if (!node) {
        return true;
    }
    while (node && node.type !== 'document') {
        // eslint-disable-next-line no-loop-func
        if (!node.parent && !node.prev && !node.next) {
            return true;
        }
        node = node.parent;
    }
    return false;
}
var esm_reLineEnding = /\r\n|\n|\r/;
function canBeContinuedListItem(lineText) {
    var spaceMatch = lineText.match(/^[ \t]+/);
    if (spaceMatch && (spaceMatch[0].length >= 2 || /\t/.test(spaceMatch[0]))) {
        return true;
    }
    var leftTrimmed = spaceMatch ? lineText.slice(spaceMatch.length) : lineText;
    return reBulletListMarker.test(leftTrimmed) || reOrderedListMarker.test(leftTrimmed);
}
function canBeContinuedTableBody(lineText) {
    return !isBlank(lineText) && lineText.indexOf('|') !== -1;
}
function createRefDefState(node) {
    var id = node.id, title = node.title, sourcepos = node.sourcepos, dest = node.dest;
    return {
        id: id,
        title: title,
        sourcepos: sourcepos,
        unlinked: false,
        destination: dest,
    };
}
var ToastMark = /** @class */ (function () {
    function ToastMark(contents, options) {
        this.refMap = {};
        this.refLinkCandidateMap = {};
        this.refDefCandidateMap = {};
        this.referenceDefinition = !!(options === null || options === void 0 ? void 0 : options.referenceDefinition);
        this.parser = new Parser(options);
        this.parser.setRefMaps(this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap);
        this.eventHandlerMap = { change: [] };
        contents = contents || '';
        this.lineTexts = contents.split(esm_reLineEnding);
        this.root = this.parser.parse(contents, this.lineTexts);
    }
    ToastMark.prototype.updateLineTexts = function (startPos, endPos, newText) {
        var _a;
        var startLine = startPos[0], startCol = startPos[1];
        var endLine = endPos[0], endCol = endPos[1];
        var newLines = newText.split(esm_reLineEnding);
        var newLineLen = newLines.length;
        var startLineText = this.lineTexts[startLine - 1];
        var endLineText = this.lineTexts[endLine - 1];
        newLines[0] = startLineText.slice(0, startCol - 1) + newLines[0];
        newLines[newLineLen - 1] = newLines[newLineLen - 1] + endLineText.slice(endCol - 1);
        var removedLineLen = endLine - startLine + 1;
        (_a = this.lineTexts).splice.apply(_a, esm_spreadArray([startLine - 1, removedLineLen], newLines));
        return newLineLen - removedLineLen;
    };
    ToastMark.prototype.updateRootNodeState = function () {
        if (this.lineTexts.length === 1 && this.lineTexts[0] === '') {
            this.root.lastLineBlank = true;
            this.root.sourcepos = [
                [1, 1],
                [1, 0],
            ];
            return;
        }
        if (this.root.lastChild) {
            this.root.lastLineBlank = this.root.lastChild.lastLineBlank;
        }
        var lineTexts = this.lineTexts;
        var idx = lineTexts.length - 1;
        while (lineTexts[idx] === '') {
            idx -= 1;
        }
        if (lineTexts.length - 2 > idx) {
            idx += 1;
        }
        this.root.sourcepos[1] = [idx + 1, lineTexts[idx].length];
    };
    ToastMark.prototype.replaceRangeNodes = function (startNode, endNode, newNodes) {
        if (!startNode) {
            if (endNode) {
                insertNodesBefore(endNode, newNodes);
                removeNodeById(endNode.id);
                endNode.unlink();
            }
            else {
                prependChildNodes(this.root, newNodes);
            }
        }
        else {
            insertNodesBefore(startNode, newNodes);
            removeNextUntil(startNode, endNode);
            [startNode.id, endNode.id].forEach(function (id) { return removeNodeById(id); });
            startNode.unlink();
        }
    };
    ToastMark.prototype.getNodeRange = function (startPos, endPos) {
        var startNode = findChildNodeAtLine(this.root, startPos[0]);
        var endNode = findChildNodeAtLine(this.root, endPos[0]);
        // extend node range to include a following block which doesn't have preceding blank line
        if (endNode && endNode.next && endPos[0] + 1 === endNode.next.sourcepos[0][0]) {
            endNode = endNode.next;
        }
        return [startNode, endNode];
    };
    ToastMark.prototype.trigger = function (eventName, param) {
        this.eventHandlerMap[eventName].forEach(function (handler) {
            handler(param);
        });
    };
    ToastMark.prototype.extendEndLine = function (line) {
        while (this.lineTexts[line] === '') {
            line += 1;
        }
        return line;
    };
    ToastMark.prototype.parseRange = function (startNode, endNode, startLine, endLine) {
        // extends starting range if the first node can be a continued list item
        if (startNode &&
            startNode.prev &&
            ((isList(startNode.prev) && canBeContinuedListItem(this.lineTexts[startLine - 1])) ||
                (isTable(startNode.prev) && canBeContinuedTableBody(this.lineTexts[startLine - 1])))) {
            startNode = startNode.prev;
            startLine = startNode.sourcepos[0][0];
        }
        var editedLines = this.lineTexts.slice(startLine - 1, endLine);
        var root = this.parser.partialParseStart(startLine, editedLines);
        // extends ending range if the following node can be a fenced code block or a continued list item
        var nextNode = endNode ? endNode.next : this.root.firstChild;
        var lastChild = root.lastChild;
        var isOpenedLastChildCodeBlock = lastChild && isCodeBlock(lastChild) && lastChild.open;
        var isOpenedLastChildCustomBlock = lastChild && isCustomBlock(lastChild) && lastChild.open;
        var isLastChildList = lastChild && isList(lastChild);
        while (((isOpenedLastChildCodeBlock || isOpenedLastChildCustomBlock) && nextNode) ||
            (isLastChildList && nextNode && (nextNode.type === 'list' || nextNode.sourcepos[0][1] >= 2))) {
            var newEndLine = this.extendEndLine(nextNode.sourcepos[1][0]);
            this.parser.partialParseExtends(this.lineTexts.slice(endLine, newEndLine));
            if (!startNode) {
                startNode = endNode;
            }
            endNode = nextNode;
            endLine = newEndLine;
            nextNode = nextNode.next;
        }
        this.parser.partialParseFinish();
        var newNodes = getChildNodes(root);
        return { newNodes: newNodes, extStartNode: startNode, extEndNode: endNode };
    };
    ToastMark.prototype.getRemovedNodeRange = function (extStartNode, extEndNode) {
        if (!extStartNode ||
            (extStartNode && isRefDef(extStartNode)) ||
            (extEndNode && isRefDef(extEndNode))) {
            return null;
        }
        return {
            id: [extStartNode.id, extEndNode.id],
            line: [extStartNode.sourcepos[0][0] - 1, extEndNode.sourcepos[1][0] - 1],
        };
    };
    ToastMark.prototype.markDeletedRefMap = function (extStartNode, extEndNode) {
        var _this = this;
        if (!isEmptyObj(this.refMap)) {
            var markDeleted = function (node) {
                if (isRefDef(node)) {
                    var refDefState = _this.refMap[node.label];
                    if (refDefState && node.id === refDefState.id) {
                        refDefState.unlinked = true;
                    }
                }
            };
            if (extStartNode) {
                invokeNextUntil(markDeleted, extStartNode.parent, extEndNode);
            }
            if (extEndNode) {
                invokeNextUntil(markDeleted, extEndNode);
            }
        }
    };
    ToastMark.prototype.replaceWithNewRefDefState = function (nodes) {
        var _this = this;
        if (!isEmptyObj(this.refMap)) {
            var replaceWith_1 = function (node) {
                if (isRefDef(node)) {
                    var label = node.label;
                    var refDefState = _this.refMap[label];
                    if (!refDefState || refDefState.unlinked) {
                        _this.refMap[label] = createRefDefState(node);
                    }
                }
            };
            nodes.forEach(function (node) {
                invokeNextUntil(replaceWith_1, node);
            });
        }
    };
    ToastMark.prototype.replaceWithRefDefCandidate = function () {
        var _this = this;
        if (!isEmptyObj(this.refDefCandidateMap)) {
            iterateObject(this.refDefCandidateMap, function (_, candidate) {
                var label = candidate.label, sourcepos = candidate.sourcepos;
                var refDefState = _this.refMap[label];
                if (!refDefState ||
                    refDefState.unlinked ||
                    refDefState.sourcepos[0][0] > sourcepos[0][0]) {
                    _this.refMap[label] = createRefDefState(candidate);
                }
            });
        }
    };
    ToastMark.prototype.getRangeWithRefDef = function (startLine, endLine, startNode, endNode, lineDiff) {
        if (this.referenceDefinition && !isEmptyObj(this.refMap)) {
            var prevNode = findChildNodeAtLine(this.root, startLine - 1);
            var nextNode = findChildNodeAtLine(this.root, endLine + 1);
            if (prevNode && isRefDef(prevNode) && prevNode !== startNode && prevNode !== endNode) {
                startNode = prevNode;
                startLine = startNode.sourcepos[0][0];
            }
            if (nextNode && isRefDef(nextNode) && nextNode !== startNode && nextNode !== endNode) {
                endNode = nextNode;
                endLine = this.extendEndLine(endNode.sourcepos[1][0] + lineDiff);
            }
        }
        return [startNode, endNode, startLine, endLine];
    };
    ToastMark.prototype.parse = function (startPos, endPos, lineDiff) {
        if (lineDiff === void 0) {
            lineDiff = 0;
        }
        var range = this.getNodeRange(startPos, endPos);
        var startNode = range[0], endNode = range[1];
        var startLine = startNode ? Math.min(startNode.sourcepos[0][0], startPos[0]) : startPos[0];
        var endLine = this.extendEndLine((endNode ? Math.max(endNode.sourcepos[1][0], endPos[0]) : endPos[0]) + lineDiff);
        var parseResult = this.parseRange.apply(this, this.getRangeWithRefDef(startLine, endLine, startNode, endNode, lineDiff));
        var newNodes = parseResult.newNodes, extStartNode = parseResult.extStartNode, extEndNode = parseResult.extEndNode;
        var removedNodeRange = this.getRemovedNodeRange(extStartNode, extEndNode);
        var nextNode = extEndNode ? extEndNode.next : this.root.firstChild;
        if (this.referenceDefinition) {
            this.markDeletedRefMap(extStartNode, extEndNode);
            this.replaceRangeNodes(extStartNode, extEndNode, newNodes);
            this.replaceWithNewRefDefState(newNodes);
        }
        else {
            this.replaceRangeNodes(extStartNode, extEndNode, newNodes);
        }
        return { nodes: newNodes, removedNodeRange: removedNodeRange, nextNode: nextNode };
    };
    ToastMark.prototype.parseRefLink = function () {
        var _this = this;
        var result = [];
        if (!isEmptyObj(this.refMap)) {
            iterateObject(this.refMap, function (label, value) {
                if (value.unlinked) {
                    delete _this.refMap[label];
                }
                iterateObject(_this.refLinkCandidateMap, function (_, candidate) {
                    var node = candidate.node, refLabel = candidate.refLabel;
                    if (refLabel === label) {
                        result.push(_this.parse(node.sourcepos[0], node.sourcepos[1]));
                    }
                });
            });
        }
        return result;
    };
    ToastMark.prototype.removeUnlinkedCandidate = function () {
        if (!isEmptyObj(this.refDefCandidateMap)) {
            [this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function (candidateMap) {
                iterateObject(candidateMap, function (id) {
                    if (isUnlinked(id)) {
                        delete candidateMap[id];
                    }
                });
            });
        }
    };
    ToastMark.prototype.editMarkdown = function (startPos, endPos, newText) {
        var lineDiff = this.updateLineTexts(startPos, endPos, newText);
        var parseResult = this.parse(startPos, endPos, lineDiff);
        var editResult = omit(parseResult, 'nextNode');
        updateNextLineNumbers(parseResult.nextNode, lineDiff);
        this.updateRootNodeState();
        var result = [editResult];
        if (this.referenceDefinition) {
            this.removeUnlinkedCandidate();
            this.replaceWithRefDefCandidate();
            result = result.concat(this.parseRefLink());
        }
        this.trigger('change', result);
        return result;
    };
    ToastMark.prototype.getLineTexts = function () {
        return this.lineTexts;
    };
    ToastMark.prototype.getRootNode = function () {
        return this.root;
    };
    ToastMark.prototype.findNodeAtPosition = function (pos) {
        var node = findNodeAtPosition(this.root, pos);
        if (!node || node === this.root) {
            return null;
        }
        return node;
    };
    ToastMark.prototype.findFirstNodeAtLine = function (line) {
        return findFirstNodeAtLine(this.root, line);
    };
    ToastMark.prototype.on = function (eventName, callback) {
        this.eventHandlerMap[eventName].push(callback);
    };
    ToastMark.prototype.off = function (eventName, callback) {
        var handlers = this.eventHandlerMap[eventName];
        var idx = handlers.indexOf(callback);
        handlers.splice(idx, 1);
    };
    ToastMark.prototype.findNodeById = function (id) {
        return findNodeById(id);
    };
    ToastMark.prototype.removeAllNode = function () {
        removeAllNode();
    };
    return ToastMark;
}());
var disallowedTags = [
    'title',
    'textarea',
    'style',
    'xmp',
    'iframe',
    'noembed',
    'noframes',
    'script',
    'plaintext',
];
var reDisallowedTag = new RegExp("<(/?(?:" + disallowedTags.join('|') + ")[^>]*>)", 'ig');
function filterDisallowedTags(str) {
    if (reDisallowedTag.test(str)) {
        return str.replace(reDisallowedTag, function (_, group) { return "&lt;" + group; });
    }
    return str;
}
var baseConvertors = {
    heading: function (node, _a) {
        var entering = _a.entering;
        return {
            type: entering ? 'openTag' : 'closeTag',
            tagName: "h" + node.level,
            outerNewLine: true,
        };
    },
    text: function (node) {
        return {
            type: 'text',
            content: node.literal,
        };
    },
    softbreak: function (_, _a) {
        var options = _a.options;
        return {
            type: 'html',
            content: options.softbreak,
        };
    },
    linebreak: function () {
        return {
            type: 'html',
            content: '<br />\n',
        };
    },
    emph: function (_, _a) {
        var entering = _a.entering;
        return {
            type: entering ? 'openTag' : 'closeTag',
            tagName: 'em',
        };
    },
    strong: function (_, _a) {
        var entering = _a.entering;
        return {
            type: entering ? 'openTag' : 'closeTag',
            tagName: 'strong',
        };
    },
    paragraph: function (node, _a) {
        var _b;
        var entering = _a.entering;
        var grandparent = (_b = node.parent) === null || _b === void 0 ? void 0 : _b.parent;
        if (grandparent && grandparent.type === 'list') {
            if (grandparent.listData.tight) {
                return null;
            }
        }
        return {
            type: entering ? 'openTag' : 'closeTag',
            tagName: 'p',
            outerNewLine: true,
        };
    },
    thematicBreak: function () {
        return {
            type: 'openTag',
            tagName: 'hr',
            outerNewLine: true,
            selfClose: true,
        };
    },
    blockQuote: function (_, _a) {
        var entering = _a.entering;
        return {
            type: entering ? 'openTag' : 'closeTag',
            tagName: 'blockquote',
            outerNewLine: true,
            innerNewLine: true,
        };
    },
    list: function (node, _a) {
        var entering = _a.entering;
        var _b = node.listData, type = _b.type, start = _b.start;
        var tagName = type === 'bullet' ? 'ul' : 'ol';
        var attributes = {};
        if (tagName === 'ol' && start !== null && start !== 1) {
            attributes.start = start.toString();
        }
        return {
            type: entering ? 'openTag' : 'closeTag',
            tagName: tagName,
            attributes: attributes,
            outerNewLine: true,
        };
    },
    item: function (_, _a) {
        var entering = _a.entering;
        return {
            type: entering ? 'openTag' : 'closeTag',
            tagName: 'li',
            outerNewLine: true,
        };
    },
    htmlInline: function (node, _a) {
        var options = _a.options;
        var content = options.tagFilter ? filterDisallowedTags(node.literal) : node.literal;
        return { type: 'html', content: content };
    },
    htmlBlock: function (node, _a) {
        var options = _a.options;
        var content = options.tagFilter ? filterDisallowedTags(node.literal) : node.literal;
        if (options.nodeId) {
            return [
                { type: 'openTag', tagName: 'div', outerNewLine: true },
                { type: 'html', content: content },
                { type: 'closeTag', tagName: 'div', outerNewLine: true },
            ];
        }
        return { type: 'html', content: content, outerNewLine: true };
    },
    code: function (node) {
        return [
            { type: 'openTag', tagName: 'code' },
            { type: 'text', content: node.literal },
            { type: 'closeTag', tagName: 'code' },
        ];
    },
    codeBlock: function (node) {
        var infoStr = node.info;
        var infoWords = infoStr ? infoStr.split(/\s+/) : [];
        var codeClassNames = [];
        if (infoWords.length > 0 && infoWords[0].length > 0) {
            codeClassNames.push("language-" + esm_escapeXml(infoWords[0]));
        }
        return [
            { type: 'openTag', tagName: 'pre', outerNewLine: true },
            { type: 'openTag', tagName: 'code', classNames: codeClassNames },
            { type: 'text', content: node.literal },
            { type: 'closeTag', tagName: 'code' },
            { type: 'closeTag', tagName: 'pre', outerNewLine: true },
        ];
    },
    link: function (node, _a) {
        var entering = _a.entering;
        if (entering) {
            var _b = node, title = _b.title, destination = _b.destination;
            return {
                type: 'openTag',
                tagName: 'a',
                attributes: esm_assign({ href: esm_escapeXml(destination) }, (title && { title: esm_escapeXml(title) })),
            };
        }
        return { type: 'closeTag', tagName: 'a' };
    },
    image: function (node, _a) {
        var getChildrenText = _a.getChildrenText, skipChildren = _a.skipChildren;
        var _b = node, title = _b.title, destination = _b.destination;
        skipChildren();
        return {
            type: 'openTag',
            tagName: 'img',
            selfClose: true,
            attributes: esm_assign({ src: esm_escapeXml(destination), alt: getChildrenText(node) }, (title && { title: esm_escapeXml(title) })),
        };
    },
    customBlock: function (node, context, convertors) {
        var info = node.info.trim().toLowerCase();
        var customConvertor = convertors[info];
        if (customConvertor) {
            try {
                return customConvertor(node, context);
            }
            catch (e) {
                console.warn("[@toast-ui/editor] - The error occurred when " + info + " block node was parsed in markdown renderer: " + e);
            }
        }
        return [
            { type: 'openTag', tagName: 'div', outerNewLine: true },
            { type: 'text', content: node.literal },
            { type: 'closeTag', tagName: 'div', outerNewLine: true },
        ];
    },
    frontMatter: function (node) {
        return [
            {
                type: 'openTag',
                tagName: 'div',
                outerNewLine: true,
                // Because front matter is metadata, it should not be render.
                attributes: { style: 'white-space: pre; display: none;' },
            },
            { type: 'text', content: node.literal },
            { type: 'closeTag', tagName: 'div', outerNewLine: true },
        ];
    },
    customInline: function (node, context, convertors) {
        var _a = node, info = _a.info, firstChild = _a.firstChild;
        var nomalizedInfo = info.trim().toLowerCase();
        var customConvertor = convertors[nomalizedInfo];
        var entering = context.entering;
        if (customConvertor) {
            try {
                return customConvertor(node, context);
            }
            catch (e) {
                console.warn("[@toast-ui/editor] - The error occurred when " + nomalizedInfo + " inline node was parsed in markdown renderer: " + e);
            }
        }
        return entering
            ? [
                { type: 'openTag', tagName: 'span' },
                { type: 'text', content: "$$" + info + (firstChild ? ' ' : '') },
            ]
            : [
                { type: 'text', content: '$$' },
                { type: 'closeTag', tagName: 'span' },
            ];
    },
};
var gfmConvertors = {
    strike: function (_, _a) {
        var entering = _a.entering;
        return {
            type: entering ? 'openTag' : 'closeTag',
            tagName: 'del',
        };
    },
    item: function (node, _a) {
        var entering = _a.entering;
        var _b = node.listData, checked = _b.checked, task = _b.task;
        if (entering) {
            var itemTag = {
                type: 'openTag',
                tagName: 'li',
                outerNewLine: true,
            };
            if (task) {
                return [
                    itemTag,
                    {
                        type: 'openTag',
                        tagName: 'input',
                        selfClose: true,
                        attributes: esm_assign(esm_assign({}, (checked && { checked: '' })), { disabled: '', type: 'checkbox' }),
                    },
                    {
                        type: 'text',
                        content: ' ',
                    },
                ];
            }
            return itemTag;
        }
        return {
            type: 'closeTag',
            tagName: 'li',
            outerNewLine: true,
        };
    },
    table: function (_, _a) {
        var entering = _a.entering;
        return {
            type: entering ? 'openTag' : 'closeTag',
            tagName: 'table',
            outerNewLine: true,
        };
    },
    tableHead: function (_, _a) {
        var entering = _a.entering;
        return {
            type: entering ? 'openTag' : 'closeTag',
            tagName: 'thead',
            outerNewLine: true,
        };
    },
    tableBody: function (_, _a) {
        var entering = _a.entering;
        return {
            type: entering ? 'openTag' : 'closeTag',
            tagName: 'tbody',
            outerNewLine: true,
        };
    },
    tableRow: function (node, _a) {
        var entering = _a.entering;
        if (entering) {
            return {
                type: 'openTag',
                tagName: 'tr',
                outerNewLine: true,
            };
        }
        var result = [];
        if (node.lastChild) {
            var columnLen = node.parent.parent.columns.length;
            var lastColIdx = node.lastChild.endIdx;
            for (var i = lastColIdx + 1; i < columnLen; i += 1) {
                result.push({
                    type: 'openTag',
                    tagName: 'td',
                    outerNewLine: true,
                }, {
                    type: 'closeTag',
                    tagName: 'td',
                    outerNewLine: true,
                });
            }
        }
        result.push({
            type: 'closeTag',
            tagName: 'tr',
            outerNewLine: true,
        });
        return result;
    },
    tableCell: function (node, _a) {
        var entering = _a.entering;
        if (node.ignored) {
            return {
                type: 'text',
                content: '',
            };
        }
        var tablePart = node.parent.parent;
        var tagName = tablePart.type === 'tableHead' ? 'th' : 'td';
        var table = tablePart.parent;
        var columnInfo = table.columns[node.startIdx];
        var attributes = (columnInfo === null || columnInfo === void 0 ? void 0 : columnInfo.align) ? { align: columnInfo.align } : null;
        if (entering) {
            return esm_assign({ type: 'openTag', tagName: tagName, outerNewLine: true }, (attributes && { attributes: attributes }));
        }
        return {
            type: 'closeTag',
            tagName: tagName,
            outerNewLine: true,
        };
    },
};
var defaultOptions = {
    softbreak: '\n',
    gfm: false,
    tagFilter: false,
    nodeId: false,
};
function esm_getChildrenText(node) {
    var buffer = [];
    var walker = node.walker();
    var event = null;
    while ((event = walker.next())) {
        var node_1 = event.node;
        if (node_1.type === 'text') {
            buffer.push(node_1.literal);
        }
    }
    return buffer.join('');
}
var Renderer = /** @class */ (function () {
    function Renderer(customOptions) {
        this.buffer = [];
        this.options = esm_assign(esm_assign({}, defaultOptions), customOptions);
        this.convertors = this.createConvertors();
        delete this.options.convertors;
    }
    Renderer.prototype.createConvertors = function () {
        var convertors = esm_assign({}, baseConvertors);
        if (this.options.gfm) {
            convertors = esm_assign(esm_assign({}, convertors), gfmConvertors);
        }
        if (this.options.convertors) {
            var customConvertors_1 = this.options.convertors;
            var nodeTypes = Object.keys(customConvertors_1);
            var defaultConvertors_1 = esm_assign(esm_assign({}, baseConvertors), gfmConvertors);
            nodeTypes.forEach(function (nodeType) {
                var orgConvertor = convertors[nodeType];
                var convertor = customConvertors_1[nodeType];
                var convertorType = Object.keys(defaultConvertors_1).indexOf(nodeType) === -1
                    ? nodeType.toLowerCase()
                    : nodeType;
                if (orgConvertor) {
                    convertors[convertorType] = function (node, context, convertors) {
                        context.origin = function () { return orgConvertor(node, context, convertors); };
                        return convertor(node, context);
                    };
                }
                else {
                    convertors[convertorType] = convertor;
                }
            });
        }
        return convertors;
    };
    Renderer.prototype.getConvertors = function () {
        return this.convertors;
    };
    Renderer.prototype.getOptions = function () {
        return this.options;
    };
    Renderer.prototype.render = function (rootNode) {
        var _this = this;
        this.buffer = [];
        var walker = rootNode.walker();
        var event = null;
        var _loop_1 = function () {
            var node = event.node, entering = event.entering;
            var convertor = this_1.convertors[node.type];
            if (!convertor) {
                return "continue";
            }
            var skipped = false;
            var context = {
                entering: entering,
                leaf: !esm_isContainer(node),
                options: this_1.options,
                getChildrenText: esm_getChildrenText,
                skipChildren: function () {
                    skipped = true;
                },
            };
            var converted = isCustomBlock(node) || isCustomInline(node)
                ? convertor(node, context, this_1.convertors)
                : convertor(node, context);
            if (converted) {
                var htmlNodes = Array.isArray(converted) ? converted : [converted];
                htmlNodes.forEach(function (htmlNode, index) {
                    if (htmlNode.type === 'openTag' && _this.options.nodeId && index === 0) {
                        if (!htmlNode.attributes) {
                            htmlNode.attributes = {};
                        }
                        htmlNode.attributes['data-nodeid'] = String(node.id);
                    }
                    _this.renderHTMLNode(htmlNode);
                });
                if (skipped) {
                    walker.resumeAt(node, false);
                    walker.next();
                }
            }
        };
        var this_1 = this;
        while ((event = walker.next())) {
            _loop_1();
        }
        this.addNewLine();
        return this.buffer.join('');
    };
    Renderer.prototype.renderHTMLNode = function (node) {
        switch (node.type) {
            case 'openTag':
            case 'closeTag':
                this.renderElementNode(node);
                break;
            case 'text':
                this.renderTextNode(node);
                break;
            case 'html':
                this.renderRawHtmlNode(node);
                break;
            // no-default-case
        }
    };
    Renderer.prototype.generateOpenTagString = function (node) {
        var _this = this;
        var tagName = node.tagName, classNames = node.classNames, attributes = node.attributes;
        this.buffer.push("<" + tagName);
        if (classNames && classNames.length > 0) {
            this.buffer.push(" class=\"" + classNames.join(' ') + "\"");
        }
        if (attributes) {
            Object.keys(attributes).forEach(function (attrName) {
                var attrValue = attributes[attrName];
                _this.buffer.push(" " + attrName + "=\"" + attrValue + "\"");
            });
        }
        if (node.selfClose) {
            this.buffer.push(' /');
        }
        this.buffer.push('>');
    };
    Renderer.prototype.generateCloseTagString = function (_a) {
        var tagName = _a.tagName;
        this.buffer.push("</" + tagName + ">");
    };
    Renderer.prototype.addNewLine = function () {
        if (this.buffer.length && esm_last(esm_last(this.buffer)) !== '\n') {
            this.buffer.push('\n');
        }
    };
    Renderer.prototype.addOuterNewLine = function (node) {
        if (node.outerNewLine) {
            this.addNewLine();
        }
    };
    Renderer.prototype.addInnerNewLine = function (node) {
        if (node.innerNewLine) {
            this.addNewLine();
        }
    };
    Renderer.prototype.renderTextNode = function (node) {
        this.buffer.push(esm_escapeXml(node.content));
    };
    Renderer.prototype.renderRawHtmlNode = function (node) {
        this.addOuterNewLine(node);
        this.buffer.push(node.content);
        this.addOuterNewLine(node);
    };
    Renderer.prototype.renderElementNode = function (node) {
        if (node.type === 'openTag') {
            this.addOuterNewLine(node);
            this.generateOpenTagString(node);
            if (node.selfClose) {
                this.addOuterNewLine(node);
            }
            else {
                this.addInnerNewLine(node);
            }
        }
        else {
            this.addInnerNewLine(node);
            this.generateCloseTagString(node);
            this.addOuterNewLine(node);
        }
    };
    return Renderer;
}());


// EXTERNAL MODULE: ../../node_modules/dompurify/dist/purify.js
var purify = __nested_webpack_require_93901__(368);
var purify_default = /*#__PURE__*/__nested_webpack_require_93901__.n(purify);
;// CONCATENATED MODULE: ./src/sanitizer/htmlSanitizer.ts



var CAN_BE_WHITE_TAG_LIST = ['iframe', 'embed'];
var whiteTagList = [];
function registerTagWhitelistIfPossible(tagName) {
    if (common_includes(CAN_BE_WHITE_TAG_LIST, tagName)) {
        whiteTagList.push(tagName.toLowerCase());
    }
}
function sanitizeHTML(html, options) {
    return purify_default().sanitize(html, __assign({ ADD_TAGS: whiteTagList, ADD_ATTR: ['rel', 'target', 'hreflang', 'type'], FORBID_TAGS: [
            'input',
            'script',
            'textarea',
            'form',
            'button',
            'select',
            'meta',
            'style',
            'link',
            'title',
            'object',
            'base',
        ] }, options));
}

;// CONCATENATED MODULE: ./src/wysiwyg/nodes/html.ts




function getChildrenHTML(node, typeName) {
    return node
        .literal.replace(new RegExp("(<\\s*" + typeName + "[^>]*>)|(</" + typeName + "\\s*[>])", 'ig'), '')
        .trim();
}
function getHTMLAttrsByHTMLString(html) {
    html = html.match(reHTMLTag)[0];
    var attrs = html.match(new RegExp(ATTRIBUTE, 'g'));
    return attrs
        ? attrs.reduce(function (acc, attr) {
            var _a = attr.trim().split('='), name = _a[0], values = _a.slice(1);
            if (values.length) {
                acc[name] = values.join('=').replace(/'|"/g, '').trim();
            }
            return acc;
        }, {})
        : {};
}
function getHTMLAttrs(dom) {
    return toArray_default()(dom.attributes).reduce(function (acc, attr) {
        acc[attr.nodeName] = attr.nodeValue;
        return acc;
    }, {});
}
function sanitizeDOM(node, typeName, sanitizer, wwToDOMAdaptor) {
    var dom = wwToDOMAdaptor.getToDOMNode(typeName)(node);
    var html = sanitizer(dom.outerHTML);
    var container = document.createElement('div');
    container.innerHTML = html;
    dom = container.firstChild;
    var htmlAttrs = getHTMLAttrs(dom);
    return { dom: dom, htmlAttrs: htmlAttrs };
}
var schemaFactory = {
    htmlBlock: function (typeName, sanitizeHTML, wwToDOMAdaptor) {
        return {
            atom: true,
            content: 'block+',
            group: 'block',
            attrs: {
                htmlAttrs: { default: {} },
                childrenHTML: { default: '' },
                htmlBlock: { default: true },
            },
            parseDOM: [
                {
                    tag: typeName,
                    getAttrs: function (dom) {
                        return {
                            htmlAttrs: getHTMLAttrs(dom),
                            childrenHTML: dom.innerHTML,
                        };
                    },
                },
            ],
            toDOM: function (node) {
                var _a = sanitizeDOM(node, typeName, sanitizeHTML, wwToDOMAdaptor), dom = _a.dom, htmlAttrs = _a.htmlAttrs;
                htmlAttrs.class = htmlAttrs.class ? htmlAttrs.class + " html-block" : 'html-block';
                return __spreadArray([typeName, htmlAttrs], toArray_default()(dom.childNodes));
            },
        };
    },
    htmlInline: function (typeName, sanitizeHTML, wwToDOMAdaptor) {
        return {
            attrs: {
                htmlAttrs: { default: {} },
                htmlInline: { default: true },
            },
            parseDOM: [
                {
                    tag: typeName,
                    getAttrs: function (dom) {
                        return {
                            htmlAttrs: getHTMLAttrs(dom),
                        };
                    },
                },
            ],
            toDOM: function (node) {
                var htmlAttrs = sanitizeDOM(node, typeName, sanitizeHTML, wwToDOMAdaptor).htmlAttrs;
                return [typeName, htmlAttrs, 0];
            },
        };
    },
};
function createHTMLSchemaMap(convertorMap, sanitizeHTML, wwToDOMAdaptor) {
    var htmlSchemaMap = { nodes: {}, marks: {} };
    ['htmlBlock', 'htmlInline'].forEach(function (htmlType) {
        if (convertorMap[htmlType]) {
            Object.keys(convertorMap[htmlType]).forEach(function (type) {
                var targetType = htmlType === 'htmlBlock' ? 'nodes' : 'marks';
                // register tag white list for preventing to remove the html in sanitizer
                registerTagWhitelistIfPossible(type);
                htmlSchemaMap[targetType][type] = schemaFactory[htmlType](type, sanitizeHTML, wwToDOMAdaptor);
            });
        }
    });
    return htmlSchemaMap;
}

;// CONCATENATED MODULE: ./src/markdown/htmlRenderConvertors.ts






var reCloseTag = /^\s*<\s*\//;
var htmlRenderConvertors_baseConvertors = {
    paragraph: function (_, _a) {
        var entering = _a.entering, origin = _a.origin, options = _a.options;
        if (options.nodeId) {
            return {
                type: entering ? 'openTag' : 'closeTag',
                outerNewLine: true,
                tagName: 'p',
            };
        }
        return origin();
    },
    softbreak: function (node) {
        var isPrevNodeHTML = node.prev && node.prev.type === 'htmlInline';
        var isPrevBR = isPrevNodeHTML && /<br ?\/?>/.test(node.prev.literal);
        var content = isPrevBR ? '\n' : '<br>\n';
        return { type: 'html', content: content };
    },
    item: function (node, _a) {
        var entering = _a.entering;
        if (entering) {
            var attributes = {};
            var classNames = [];
            if (node.listData.task) {
                attributes['data-task'] = '';
                classNames.push('task-list-item');
                if (node.listData.checked) {
                    classNames.push('checked');
                    attributes['data-task-checked'] = '';
                }
            }
            return {
                type: 'openTag',
                tagName: 'li',
                classNames: classNames,
                attributes: attributes,
                outerNewLine: true,
            };
        }
        return {
            type: 'closeTag',
            tagName: 'li',
            outerNewLine: true,
        };
    },
    code: function (node) {
        var attributes = { 'data-backticks': String(node.tickCount) };
        return [
            { type: 'openTag', tagName: 'code', attributes: attributes },
            { type: 'text', content: node.literal },
            { type: 'closeTag', tagName: 'code' },
        ];
    },
    codeBlock: function (node) {
        var _a = node, fenceLength = _a.fenceLength, info = _a.info;
        var infoWords = info ? info.split(/\s+/) : [];
        var preClasses = [];
        var codeAttrs = {};
        if (fenceLength > 3) {
            codeAttrs['data-backticks'] = fenceLength;
        }
        if (infoWords.length > 0 && infoWords[0].length > 0) {
            var lang = infoWords[0];
            preClasses.push("lang-" + lang);
            codeAttrs['data-language'] = lang;
        }
        return [
            { type: 'openTag', tagName: 'pre', classNames: preClasses },
            { type: 'openTag', tagName: 'code', attributes: codeAttrs },
            { type: 'text', content: node.literal },
            { type: 'closeTag', tagName: 'code' },
            { type: 'closeTag', tagName: 'pre' },
        ];
    },
    customInline: function (node, _a) {
        var origin = _a.origin, entering = _a.entering, skipChildren = _a.skipChildren;
        var info = node.info;
        if (info.indexOf('widget') !== -1 && entering) {
            skipChildren();
            var content = getWidgetContent(node);
            var htmlInline = widgetToDOM(info, content).outerHTML;
            return [
                { type: 'openTag', tagName: 'span', classNames: ['tui-widget'] },
                { type: 'html', content: htmlInline },
                { type: 'closeTag', tagName: 'span' },
            ];
        }
        return origin();
    },
};
function getHTMLRenderConvertors(linkAttributes, customConvertors) {
    var convertors = __assign({}, htmlRenderConvertors_baseConvertors);
    if (linkAttributes) {
        convertors.link = function (_, _a) {
            var entering = _a.entering, origin = _a.origin;
            var result = origin();
            if (entering) {
                result.attributes = __assign(__assign({}, result.attributes), linkAttributes);
            }
            return result;
        };
    }
    if (customConvertors) {
        Object.keys(customConvertors).forEach(function (nodeType) {
            var orgConvertor = convertors[nodeType];
            var customConvertor = customConvertors[nodeType];
            if (orgConvertor && isFunction_default()(customConvertor)) {
                convertors[nodeType] = function (node, context) {
                    var newContext = __assign({}, context);
                    newContext.origin = function () { return orgConvertor(node, context); };
                    return customConvertor(node, newContext);
                };
            }
            else if (common_includes(['htmlBlock', 'htmlInline'], nodeType) && !isFunction_default()(customConvertor)) {
                convertors[nodeType] = function (node, context) {
                    var matched = node.literal.match(reHTMLTag);
                    if (matched) {
                        var rootHTML = matched[0], openTagName = matched[1], closeTagName = matched[3];
                        var typeName = (openTagName || closeTagName).toLowerCase();
                        var htmlConvertor = customConvertor[typeName];
                        var childrenHTML = getChildrenHTML(node, typeName);
                        if (htmlConvertor) {
                            // copy for preventing to overwrite the originial property
                            var newNode = __assign({}, node);
                            newNode.attrs = getHTMLAttrsByHTMLString(rootHTML);
                            newNode.childrenHTML = childrenHTML;
                            newNode.type = typeName;
                            context.entering = !reCloseTag.test(node.literal);
                            return htmlConvertor(newNode, context);
                        }
                    }
                    return context.origin();
                };
            }
            else {
                convertors[nodeType] = customConvertor;
            }
        });
    }
    return convertors;
}

;// CONCATENATED MODULE: ./src/markdown/scroll/dom.ts


var nestableTypes = ['list', 'item', 'blockQuote'];
var nestableTagNames = ['UL', 'OL', 'BLOCKQUOTE'];
function isBlankLine(doc, index) {
    var _a;
    var pmNode = doc.child(index);
    return !pmNode.childCount || (pmNode.childCount === 1 && !((_a = pmNode.firstChild.text) === null || _a === void 0 ? void 0 : _a.trim()));
}
function getEditorRangeHeightInfo(doc, mdNode, children) {
    var start = getMdStartLine(mdNode) - 1;
    var end = getMdEndLine(mdNode) - 1;
    var rect = children[start].getBoundingClientRect();
    var height = children[end].offsetTop -
        children[start].offsetTop +
        children[end].clientHeight;
    return {
        height: height <= 0
            ? children[start].clientHeight
            : height + getBlankLinesHeight(doc, children, Math.min(end + 1, doc.childCount - 1)),
        rect: rect,
    };
}
function getBlankLinesHeight(doc, children, start) {
    var end = doc.childCount - 1;
    var height = 0;
    while (start <= end && isBlankLine(doc, start)) {
        height += children[start].clientHeight;
        start += 1;
    }
    return height;
}
function findAncestorHavingId(el, root) {
    while (!el.getAttribute('data-nodeid') && el.parentElement !== root) {
        el = el.parentElement;
    }
    return el;
}
function getTotalOffsetTop(el, root) {
    var offsetTop = 0;
    while (el && el !== root) {
        if (!common_includes(nestableTagNames, el.tagName)) {
            offsetTop += el.offsetTop;
        }
        if (el.offsetParent === root.offsetParent) {
            break;
        }
        el = el.parentElement;
    }
    return offsetTop;
}
function findAdjacentElementToScrollTop(scrollTop, root) {
    var el = root;
    var prev = null;
    while (el) {
        var firstElementChild = el.firstElementChild;
        if (!firstElementChild) {
            break;
        }
        var lastSibling = findLastSiblingElementToScrollTop(firstElementChild, scrollTop, getTotalOffsetTop(el, root));
        prev = el;
        el = lastSibling;
    }
    var adjacentEl = el || prev;
    return adjacentEl === root ? null : adjacentEl;
}
function findLastSiblingElementToScrollTop(el, scrollTop, offsetTop) {
    if (el && scrollTop > offsetTop + el.offsetTop) {
        return (findLastSiblingElementToScrollTop(el.nextElementSibling, scrollTop, offsetTop) || el);
    }
    return null;
}
function getAdditionalPos(scrollTop, offsetTop, height, targetNodeHeight) {
    var ratio = Math.min((scrollTop - offsetTop) / height, 1);
    return ratio * targetNodeHeight;
}
function getParentNodeObj(previewContent, mdNode) {
    var el = previewContent.querySelector("[data-nodeid=\"" + mdNode.id + "\"]");
    while (!el || isStyledInlineNode(mdNode)) {
        mdNode = mdNode.parent;
        el = previewContent.querySelector("[data-nodeid=\"" + mdNode.id + "\"]");
    }
    return getNonNestableNodeObj({ mdNode: mdNode, el: el });
}
function getNonNestableNodeObj(_a) {
    var mdNode = _a.mdNode, el = _a.el;
    while ((common_includes(nestableTypes, mdNode.type) || mdNode.type === 'table') && mdNode.firstChild) {
        mdNode = mdNode.firstChild;
        el = el.firstElementChild;
    }
    return { mdNode: mdNode, el: el };
}

;// CONCATENATED MODULE: ./src/markdown/scroll/offset.ts


var offsetInfoMap = {};
function setHeight(id, height) {
    offsetInfoMap[id] = offsetInfoMap[id] || {};
    offsetInfoMap[id].height = height;
}
function setOffsetTop(id, offsetTop) {
    offsetInfoMap[id] = offsetInfoMap[id] || {};
    offsetInfoMap[id].offsetTop = offsetTop;
}
function getHeight(id) {
    return offsetInfoMap[id] && offsetInfoMap[id].height;
}
function getOffsetTop(id) {
    return offsetInfoMap[id] && offsetInfoMap[id].offsetTop;
}
function removeOffsetInfoByNode(node) {
    if (node) {
        delete offsetInfoMap[Number(node.getAttribute('data-nodeid'))];
        toArray_default()(node.children).forEach(function (child) {
            removeOffsetInfoByNode(child);
        });
    }
}
function getAndSaveOffsetInfo(node, root, mdNodeId) {
    var cachedHeight = getHeight(mdNodeId);
    var cachedTop = getOffsetTop(mdNodeId);
    var nodeHeight = cachedHeight || node.clientHeight;
    var offsetTop = cachedTop || getTotalOffsetTop(node, root) || node.offsetTop;
    if (!cachedHeight) {
        setHeight(mdNodeId, nodeHeight);
    }
    if (!cachedTop) {
        setOffsetTop(mdNodeId, offsetTop);
    }
    return { nodeHeight: nodeHeight, offsetTop: offsetTop };
}

;// CONCATENATED MODULE: ./src/markdown/mdPreview.ts











var CLASS_HIGHLIGHT = cls('md-preview-highlight');
function findTableCell(tableRow, chOffset) {
    var cell = tableRow.firstChild;
    while (cell && cell.next) {
        if (getMdStartCh(cell.next) > chOffset + 1) {
            break;
        }
        cell = cell.next;
    }
    return cell;
}
/**
 * Class Markdown Preview
 * @param {HTMLElement} el - base element
 * @param {eventEmitter} eventEmitter - event manager
 * @param {object} options
 * @param {boolean} options.isViewer - true for view-only mode
 * @param {boolean} options.highlight - true for using live-highlight feature
 * @param {object} opitons.linkAttributes - attributes for link element
 * @param {object} opitons.customHTMLRenderer - map of custom HTML render functions
 *
 * @ignore
 */
var MarkdownPreview = /** @class */ (function () {
    function MarkdownPreview(eventEmitter, options) {
        var el = document.createElement('div');
        this.el = el;
        this.eventEmitter = eventEmitter;
        this.isViewer = !!options.isViewer;
        this.el.className = cls('md-preview');
        var linkAttributes = options.linkAttributes, customHTMLRenderer = options.customHTMLRenderer, sanitizer = options.sanitizer, _a = options.highlight, highlight = _a === void 0 ? false : _a;
        this.renderer = new Renderer({
            gfm: true,
            nodeId: true,
            convertors: getHTMLRenderConvertors(linkAttributes, customHTMLRenderer),
        });
        this.cursorNodeId = null;
        this.sanitizer = sanitizer;
        this.initEvent(highlight);
        this.initContentSection();
        // To prevent overflowing contents in the viewer
        if (this.isViewer) {
            this.previewContent.style.overflowWrap = 'break-word';
        }
    }
    MarkdownPreview.prototype.initContentSection = function () {
        this.previewContent = createElementWith("<div class=\"" + cls('contents') + "\"></div>");
        if (!this.isViewer) {
            this.el.appendChild(this.previewContent);
        }
    };
    MarkdownPreview.prototype.toggleActive = function (active) {
        toggleClass(this.el, 'active', active);
    };
    MarkdownPreview.prototype.initEvent = function (highlight) {
        var _this = this;
        this.eventEmitter.listen('updatePreview', this.update.bind(this));
        if (this.isViewer) {
            return;
        }
        if (highlight) {
            this.eventEmitter.listen('changeToolbarState', function (_a) {
                var mdNode = _a.mdNode, cursorPos = _a.cursorPos;
                _this.updateCursorNode(mdNode, cursorPos);
            });
            this.eventEmitter.listen('blur', function () {
                _this.removeHighlight();
            });
        }
        on_default()(this.el, 'scroll', function (event) {
            _this.eventEmitter.emit('scroll', 'preview', findAdjacentElementToScrollTop(event.target.scrollTop, _this.previewContent));
        });
        this.eventEmitter.listen('changePreviewTabPreview', function () { return _this.toggleActive(true); });
        this.eventEmitter.listen('changePreviewTabWrite', function () { return _this.toggleActive(false); });
    };
    MarkdownPreview.prototype.removeHighlight = function () {
        if (this.cursorNodeId) {
            var currentEl = this.getElementByNodeId(this.cursorNodeId);
            if (currentEl) {
                removeClass_default()(currentEl, CLASS_HIGHLIGHT);
            }
        }
    };
    MarkdownPreview.prototype.updateCursorNode = function (cursorNode, cursorPos) {
        if (cursorNode) {
            cursorNode = findClosestNode(cursorNode, function (mdNode) { return !isInlineNode(mdNode); });
            if (cursorNode.type === 'tableRow') {
                cursorNode = findTableCell(cursorNode, cursorPos[1]);
            }
            else if (cursorNode.type === 'tableBody') {
                // empty line next to table
                cursorNode = null;
            }
        }
        var cursorNodeId = cursorNode ? cursorNode.id : null;
        if (this.cursorNodeId === cursorNodeId) {
            return;
        }
        var oldEL = this.getElementByNodeId(this.cursorNodeId);
        var newEL = this.getElementByNodeId(cursorNodeId);
        if (oldEL) {
            removeClass_default()(oldEL, CLASS_HIGHLIGHT);
        }
        if (newEL) {
            addClass_default()(newEL, CLASS_HIGHLIGHT);
        }
        this.cursorNodeId = cursorNodeId;
    };
    MarkdownPreview.prototype.getElementByNodeId = function (nodeId) {
        return nodeId
            ? this.previewContent.querySelector("[data-nodeid=\"" + nodeId + "\"]")
            : null;
    };
    MarkdownPreview.prototype.update = function (changed) {
        var _this = this;
        changed.forEach(function (editResult) { return _this.replaceRangeNodes(editResult); });
        this.eventEmitter.emit('afterPreviewRender', this);
    };
    MarkdownPreview.prototype.replaceRangeNodes = function (editResult) {
        var _this = this;
        var nodes = editResult.nodes, removedNodeRange = editResult.removedNodeRange;
        var contentEl = this.previewContent;
        var newHtml = this.eventEmitter.emitReduce('beforePreviewRender', this.sanitizer(nodes.map(function (node) { return _this.renderer.render(node); }).join('')));
        if (!removedNodeRange) {
            contentEl.insertAdjacentHTML('afterbegin', newHtml);
        }
        else {
            var _a = removedNodeRange.id, startNodeId = _a[0], endNodeId = _a[1];
            var startEl = this.getElementByNodeId(startNodeId);
            var endEl = this.getElementByNodeId(endNodeId);
            if (startEl) {
                startEl.insertAdjacentHTML('beforebegin', newHtml);
                var el = startEl;
                while (el && el !== endEl) {
                    var nextEl = el.nextElementSibling;
                    removeNode(el);
                    removeOffsetInfoByNode(el);
                    el = nextEl;
                }
                if (el === null || el === void 0 ? void 0 : el.parentNode) {
                    removeNode(el);
                    removeOffsetInfoByNode(el);
                }
            }
        }
    };
    MarkdownPreview.prototype.getRenderer = function () {
        return this.renderer;
    };
    MarkdownPreview.prototype.destroy = function () {
        off_default()(this.el, 'scroll');
        this.el = null;
    };
    MarkdownPreview.prototype.getElement = function () {
        return this.el;
    };
    MarkdownPreview.prototype.getHTML = function () {
        return removeProseMirrorHackNodes(this.previewContent.innerHTML);
    };
    MarkdownPreview.prototype.setHTML = function (html) {
        this.previewContent.innerHTML = html;
    };
    MarkdownPreview.prototype.setHeight = function (height) {
        css_default()(this.el, { height: height + "px" });
    };
    MarkdownPreview.prototype.setMinHeight = function (minHeight) {
        css_default()(this.el, { minHeight: minHeight + "px" });
    };
    return MarkdownPreview;
}());
/* harmony default export */ var mdPreview = (MarkdownPreview);

;// CONCATENATED MODULE: ./src/wysiwyg/helper/node.ts


function findNodeBy(pos, condition) {
    var depth = pos.depth;
    while (depth) {
        var node = pos.node(depth);
        if (condition(node, depth)) {
            return {
                node: node,
                depth: depth,
                offset: depth > 0 ? pos.before(depth) : 0,
            };
        }
        depth -= 1;
    }
    return null;
}
function node_isListNode(_a) {
    var type = _a.type;
    return type.name === 'bulletList' || type.name === 'orderedList';
}
function isInListNode(pos) {
    return !!findNodeBy(pos, function (_a) {
        var type = _a.type;
        return type.name === 'listItem' || type.name === 'bulletList' || type.name === 'orderedList';
    });
}
function isInTableNode(pos) {
    return !!findNodeBy(pos, function (_a) {
        var type = _a.type;
        return type.name === 'tableHeadCell' || type.name === 'tableBodyCell';
    });
}
function findListItem(pos) {
    return findNodeBy(pos, function (_a) {
        var type = _a.type;
        return type.name === 'listItem';
    });
}
function createDOMInfoParsedRawHTML(tag) {
    return {
        tag: tag,
        getAttrs: function (dom) {
            var rawHTML = dom.getAttribute('data-raw-html');
            return __assign({}, (rawHTML && { rawHTML: rawHTML }));
        },
    };
}
function createCellAttrs(attrs) {
    return Object.keys(attrs).reduce(function (acc, attrName) {
        if (attrName !== 'rawHTML' && attrs[attrName]) {
            attrName = attrName === 'className' ? 'class' : attrName;
            acc[attrName] = attrs[attrName];
        }
        return acc;
    }, {});
}
function createParsedCellDOM(tag) {
    return {
        tag: tag,
        getAttrs: function (dom) {
            return ['rawHTML', 'colspan', 'rowspan', 'extended'].reduce(function (acc, attrName) {
                var attrNameInDOM = attrName === 'rawHTML' ? 'data-raw-html' : attrName;
                var attrValue = dom.getAttribute(attrNameInDOM);
                if (attrValue) {
                    acc[attrName] = common_includes(['rawHTML', 'extended'], attrName)
                        ? attrValue
                        : Number(attrValue);
                }
                return acc;
            }, {});
        },
    };
}
function getDefaultCustomAttrs() {
    return {
        htmlAttrs: { default: null },
        classNames: { default: null },
    };
}
function getCustomAttrs(attrs) {
    var htmlAttrs = attrs.htmlAttrs, classNames = attrs.classNames;
    return __assign(__assign({}, htmlAttrs), { class: classNames ? classNames.join(' ') : null });
}

;// CONCATENATED MODULE: ./src/wysiwyg/command/list.ts




function findWrappingOutside(range, type) {
    var parent = range.parent, startIndex = range.startIndex, endIndex = range.endIndex;
    var around = parent.contentMatchAt(startIndex).findWrapping(type);
    if (around) {
        var outer = around.length ? around[0] : type;
        return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
    }
    return null;
}
function findWrappingInside(range, type) {
    var parent = range.parent, startIndex = range.startIndex, endIndex = range.endIndex;
    var inner = parent.child(startIndex);
    var inside = type.contentMatch.findWrapping(inner.type);
    if (inside) {
        var lastType = inside.length ? inside[inside.length - 1] : type;
        var innerMatch = lastType.contentMatch;
        for (var i = startIndex; innerMatch && i < endIndex; i += 1) {
            innerMatch = innerMatch.matchType(parent.child(i).type);
        }
        if (innerMatch && innerMatch.validEnd) {
            return inside;
        }
    }
    return null;
}
function findWrappers(range, innerRange, nodeType, attrs) {
    var around = findWrappingOutside(range, nodeType);
    var inner = findWrappingInside(innerRange, nodeType);
    if (around && inner) {
        var aroundNodes = around.map(function (type) {
            return { type: type };
        });
        var innerNodes = inner.map(function (type) {
            return { type: type, attrs: attrs };
        });
        return aroundNodes.concat({ type: nodeType }).concat(innerNodes);
    }
    return null;
}
function wrapInList(tr, _a, wrappers, joinBefore, list) {
    var start = _a.start, end = _a.end, startIndex = _a.startIndex, endIndex = _a.endIndex, parent = _a.parent;
    var content = external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.empty;
    for (var i = wrappers.length - 1; i >= 0; i -= 1) {
        content = external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
    }
    tr.step(new external_commonjs_prosemirror_transform_commonjs2_prosemirror_transform_amd_prosemirror_transform_.ReplaceAroundStep(start - (joinBefore ? 2 : 0), end, start, end, new external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Slice(content, 0, 0), wrappers.length, true));
    var foundListIndex = 0;
    for (var i = 0; i < wrappers.length; i += 1) {
        if (wrappers[i].type === list) {
            foundListIndex = i + 1;
            break;
        }
    }
    var splitDepth = wrappers.length - foundListIndex;
    var splitPos = start + wrappers.length - (joinBefore ? 2 : 0);
    for (var i = startIndex, len = endIndex; i < len; i += 1) {
        var first = i === startIndex;
        if (!first && (0,external_commonjs_prosemirror_transform_commonjs2_prosemirror_transform_amd_prosemirror_transform_.canSplit)(tr.doc, splitPos, splitDepth)) {
            tr.split(splitPos, splitDepth);
            splitPos += splitDepth * 2;
        }
        splitPos += parent.child(i).nodeSize;
    }
    return tr;
}
function changeToList(tr, range, list, attrs) {
    var $from = range.$from, $to = range.$to, depth = range.depth;
    var outerRange = range;
    var joinBefore = false;
    if (depth >= 2 &&
        $from.node(depth - 1).type.compatibleContent(list) &&
        range.startIndex === 0 &&
        $from.index(depth - 1)) {
        var start = tr.doc.resolve(range.start - 2);
        outerRange = new external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.NodeRange(start, start, depth);
        if (range.endIndex < range.parent.childCount) {
            range = new external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.NodeRange($from, tr.doc.resolve($to.end(depth)), depth);
        }
        joinBefore = true;
    }
    var wrappers = findWrappers(outerRange, range, list, attrs);
    if (wrappers) {
        return wrapInList(tr, range, wrappers, joinBefore, list);
    }
    return tr;
}
function getBeforeLineListItem(doc, offset) {
    var endListItemPos = doc.resolve(offset);
    while (endListItemPos.node().type.name !== 'paragraph') {
        offset -= 2; // The position value of </li></ul>
        endListItemPos = doc.resolve(offset);
    }
    return findListItem(endListItemPos);
}
function toggleTaskListItems(tr, _a) {
    var $from = _a.$from, $to = _a.$to;
    var startListItem = findListItem($from);
    var endListItem = findListItem($to);
    if (startListItem && endListItem) {
        while (endListItem) {
            var offset = endListItem.offset, node = endListItem.node;
            var attrs = { task: !node.attrs.task, checked: false };
            tr.setNodeMarkup(offset, null, attrs);
            if (offset === startListItem.offset) {
                break;
            }
            endListItem = getBeforeLineListItem(tr.doc, offset);
        }
    }
    return tr;
}
function changeListType(tr, _a, list) {
    var $from = _a.$from, $to = _a.$to;
    var startListItem = findListItem($from);
    var endListItem = findListItem($to);
    if (startListItem && endListItem) {
        while (endListItem) {
            var offset = endListItem.offset, node = endListItem.node, depth = endListItem.depth;
            if (node.attrs.task) {
                tr.setNodeMarkup(offset, null, { task: false, checked: false });
            }
            var resolvedPos = tr.doc.resolve(offset);
            if (resolvedPos.parent.type !== list) {
                var parentOffset = resolvedPos.before(depth - 1);
                tr.setNodeMarkup(parentOffset, list);
            }
            if (offset === startListItem.offset) {
                break;
            }
            endListItem = getBeforeLineListItem(tr.doc, offset);
        }
    }
    return tr;
}
function changeList(list) {
    return function (_a, dispatch) {
        var selection = _a.selection, tr = _a.tr;
        var $from = selection.$from, $to = selection.$to;
        var range = $from.blockRange($to);
        if (range) {
            var newTr = isInListNode($from)
                ? changeListType(tr, range, list)
                : changeToList(tr, range, list);
            dispatch(newTr);
            return true;
        }
        return false;
    };
}
function toggleTask() {
    return function (_a, dispatch) {
        var selection = _a.selection, tr = _a.tr, schema = _a.schema;
        var $from = selection.$from, $to = selection.$to;
        var range = $from.blockRange($to);
        if (range) {
            var newTr = isInListNode($from)
                ? toggleTaskListItems(tr, range)
                : changeToList(tr, range, schema.nodes.bulletList, { task: true });
            dispatch(newTr);
            return true;
        }
        return false;
    };
}
function sinkListItem(listItem) {
    return function (_a, dispatch) {
        var tr = _a.tr, selection = _a.selection;
        var $from = selection.$from, $to = selection.$to;
        var range = $from.blockRange($to, function (_a) {
            var childCount = _a.childCount, firstChild = _a.firstChild;
            return !!childCount && firstChild.type === listItem;
        });
        if (range && range.startIndex > 0) {
            var parent = range.parent;
            var nodeBefore = parent.child(range.startIndex - 1);
            if (nodeBefore.type !== listItem) {
                return false;
            }
            var nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type === parent.type;
            var inner = nestedBefore ? external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.from(listItem.create()) : null;
            var slice = new external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Slice(external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.from(listItem.create(null, external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
            var before = range.start;
            var after = range.end;
            tr.step(new external_commonjs_prosemirror_transform_commonjs2_prosemirror_transform_amd_prosemirror_transform_.ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true));
            dispatch(tr);
            return true;
        }
        return false;
    };
}
function liftToOuterList(tr, range, listItem) {
    var $from = range.$from, $to = range.$to, end = range.end, depth = range.depth, parent = range.parent;
    var endOfList = $to.end(depth);
    if (end < endOfList) {
        // There are siblings after the lifted items, which must become
        // children of the last item
        tr.step(new external_commonjs_prosemirror_transform_commonjs2_prosemirror_transform_amd_prosemirror_transform_.ReplaceAroundStep(end - 1, endOfList, end, endOfList, new external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Slice(external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.from(listItem.create(null, parent.copy())), 1, 0), 1, true));
        range = new external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.NodeRange(tr.doc.resolve($from.pos), tr.doc.resolve(endOfList), depth);
    }
    tr.lift(range, (0,external_commonjs_prosemirror_transform_commonjs2_prosemirror_transform_amd_prosemirror_transform_.liftTarget)(range));
    return tr;
}
function liftOutOfList(tr, range) {
    var list = range.parent;
    var pos = range.end;
    // Merge the list items into a single big item
    for (var i = range.endIndex - 1, len = range.startIndex; i > len; i -= 1) {
        pos -= list.child(i).nodeSize;
        tr.delete(pos - 1, pos + 1);
    }
    var startPos = tr.doc.resolve(range.start);
    var listItem = startPos.nodeAfter;
    var atStart = range.startIndex === 0;
    var atEnd = range.endIndex === list.childCount;
    var parent = startPos.node(-1);
    var indexBefore = startPos.index(-1);
    var canReplaceParent = parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, listItem === null || listItem === void 0 ? void 0 : listItem.content.append(atEnd ? external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.empty : external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.from(list)));
    if (listItem && canReplaceParent) {
        var start = startPos.pos;
        var end = start + listItem.nodeSize;
        // Strip off the surrounding list. At the sides where we're not at
        // the end of the list, the existing list is closed. At sides where
        // this is the end, it is overwritten to its end.
        tr.step(new external_commonjs_prosemirror_transform_commonjs2_prosemirror_transform_amd_prosemirror_transform_.ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Slice((atStart ? external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.empty : external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.from(list.copy(external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.empty))).append(atEnd ? external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.empty : external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.from(list.copy(external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
    }
    return tr;
}
function liftListItem(listItem) {
    return function (_a, dispatch) {
        var tr = _a.tr, selection = _a.selection;
        var $from = selection.$from, $to = selection.$to;
        var range = $from.blockRange($to, function (_a) {
            var childCount = _a.childCount, firstChild = _a.firstChild;
            return !!childCount && firstChild.type === listItem;
        });
        if (range) {
            var topListItem = $from.node(range.depth - 1).type === listItem;
            var newTr = topListItem ? liftToOuterList(tr, range, listItem) : liftOutOfList(tr, range);
            dispatch(newTr);
            return true;
        }
        return false;
    };
}
function splitListItem(listItem) {
    return function (_a, dispatch) {
        var tr = _a.tr, selection = _a.selection;
        var $from = selection.$from, $to = selection.$to;
        if ($from.depth < 2 || !$from.sameParent($to)) {
            return false;
        }
        var grandParent = $from.node(-1);
        if (grandParent.type !== listItem) {
            return false;
        }
        if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
            // In an empty block. If this is a nested list, the wrapping
            // list item should be split. Otherwise, bail out and let next
            // command handle lifting.
            if ($from.depth === 2 ||
                $from.node(-3).type !== listItem ||
                $from.index(-2) !== $from.node(-2).childCount - 1) {
                return false;
            }
            var keepItem = $from.index(-1) > 0;
            var wrapper = external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.empty;
            // Build a fragment containing empty versions of the structure
            // from the outer list item to the parent node of the cursor
            for (var depth = $from.depth - (keepItem ? 1 : 2); depth >= $from.depth - 3; depth -= 1) {
                wrapper = external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.from($from.node(depth).copy(wrapper));
            }
            // Add a second list item with an empty default start node
            wrapper = wrapper.append(external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.from(listItem.createAndFill()));
            tr.replace(keepItem ? $from.before() : $from.before(-1), $from.after(-3), new external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Slice(wrapper, keepItem ? 3 : 2, 2));
            tr.setSelection(external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Selection.near(tr.doc.resolve($from.pos + (keepItem ? 3 : 2))));
            dispatch(tr);
            return true;
        }
        var nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;
        var types = nextType && [null, { type: nextType }];
        tr.delete($from.pos, $to.pos);
        if ((0,external_commonjs_prosemirror_transform_commonjs2_prosemirror_transform_amd_prosemirror_transform_.canSplit)(tr.doc, $from.pos, 2, types)) {
            tr.split($from.pos, 2, types);
            dispatch(tr);
            return true;
        }
        return false;
    };
}

;// CONCATENATED MODULE: ./src/commands/wwCommands.ts


function indent() {
    return function () { return function (state, dispatch) {
        var selection = state.selection, schema = state.schema;
        var $from = selection.$from, $to = selection.$to;
        var range = $from.blockRange($to);
        if (range && isInListNode($from)) {
            return sinkListItem(schema.nodes.listItem)(state, dispatch);
        }
        return false;
    }; };
}
function outdent() {
    return function () { return function (state, dispatch) {
        var selection = state.selection, schema = state.schema;
        var $from = selection.$from, $to = selection.$to;
        var range = $from.blockRange($to);
        if (range && isInListNode($from)) {
            return liftListItem(schema.nodes.listItem)(state, dispatch);
        }
        return false;
    }; };
}
function getWwCommands() {
    return {
        indent: indent(),
        outdent: outdent(),
    };
}

;// CONCATENATED MODULE: ./src/wysiwyg/helper/tableOffsetMap.ts


var cache = new Map();
/* eslint-disable @typescript-eslint/no-unused-vars */
var TableOffsetMap = /** @class */ (function () {
    function TableOffsetMap(table, tableRows, tableStartPos, rowInfo) {
        this.table = table;
        this.tableRows = tableRows;
        this.tableStartPos = tableStartPos;
        this.rowInfo = rowInfo;
    }
    TableOffsetMap.create = function (cellPos) {
        var table = findNodeBy(cellPos, function (_a) {
            var type = _a.type;
            return type.name === 'table';
        });
        if (table) {
            var node = table.node, depth = table.depth, offset = table.offset;
            var cached = cache.get(node);
            if ((cached === null || cached === void 0 ? void 0 : cached.tableStartPos) === offset + 1) {
                return cached;
            }
            var rows_1 = [];
            var tablePos = cellPos.start(depth);
            var thead = node.child(0);
            var tbody = node.child(1);
            var theadCellInfo = createOffsetMap(thead, tablePos);
            var tbodyCellInfo = createOffsetMap(tbody, tablePos + thead.nodeSize);
            thead.forEach(function (row) { return rows_1.push(row); });
            tbody.forEach(function (row) { return rows_1.push(row); });
            var map = new TableOffsetMap(node, rows_1, tablePos, theadCellInfo.concat(tbodyCellInfo));
            cache.set(node, map);
            return map;
        }
        return null;
    };
    Object.defineProperty(TableOffsetMap.prototype, "totalRowCount", {
        get: function () {
            return this.rowInfo.length;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TableOffsetMap.prototype, "totalColumnCount", {
        get: function () {
            return this.rowInfo[0].length;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TableOffsetMap.prototype, "tableStartOffset", {
        get: function () {
            return this.tableStartPos;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TableOffsetMap.prototype, "tableEndOffset", {
        get: function () {
            return this.tableStartPos + this.table.nodeSize - 1;
        },
        enumerable: false,
        configurable: true
    });
    TableOffsetMap.prototype.getCellInfo = function (rowIdx, colIdx) {
        return this.rowInfo[rowIdx][colIdx];
    };
    TableOffsetMap.prototype.posAt = function (rowIdx, colIdx) {
        for (var i = 0, rowStart = this.tableStartPos;; i += 1) {
            var rowEnd = rowStart + this.tableRows[i].nodeSize;
            if (i === rowIdx) {
                var index = colIdx;
                // Skip the cells from previous row(via rowspan)
                while (index < this.totalColumnCount && this.rowInfo[i][index].offset < rowStart) {
                    index += 1;
                }
                return index === this.totalColumnCount ? rowEnd : this.rowInfo[i][index].offset;
            }
            rowStart = rowEnd;
        }
    };
    TableOffsetMap.prototype.getNodeAndPos = function (rowIdx, colIdx) {
        var cellInfo = this.rowInfo[rowIdx][colIdx];
        return {
            node: this.table.nodeAt(cellInfo.offset - this.tableStartOffset),
            pos: cellInfo.offset,
        };
    };
    TableOffsetMap.prototype.extendedRowspan = function (rowIdx, colIdx) {
        return false;
    };
    TableOffsetMap.prototype.extendedColspan = function (rowIdx, colIdx) {
        return false;
    };
    TableOffsetMap.prototype.getRowspanCount = function (rowIdx, colIdx) {
        return 0;
    };
    TableOffsetMap.prototype.getColspanCount = function (rowIdx, colIdx) {
        return 0;
    };
    TableOffsetMap.prototype.decreaseColspanCount = function (rowIdx, colIdx) {
        return 0;
    };
    TableOffsetMap.prototype.decreaseRowspanCount = function (rowIdx, colIdx) {
        return 0;
    };
    TableOffsetMap.prototype.getColspanStartInfo = function (rowIdx, colIdx) {
        return null;
    };
    TableOffsetMap.prototype.getRowspanStartInfo = function (rowIdx, colIdx) {
        return null;
    };
    TableOffsetMap.prototype.getCellStartOffset = function (rowIdx, colIdx) {
        var offset = this.rowInfo[rowIdx][colIdx].offset;
        return this.extendedRowspan(rowIdx, colIdx) ? this.posAt(rowIdx, colIdx) : offset;
    };
    TableOffsetMap.prototype.getCellEndOffset = function (rowIdx, colIdx) {
        var _a = this.rowInfo[rowIdx][colIdx], offset = _a.offset, nodeSize = _a.nodeSize;
        return this.extendedRowspan(rowIdx, colIdx) ? this.posAt(rowIdx, colIdx) : offset + nodeSize;
    };
    TableOffsetMap.prototype.getCellIndex = function (cellPos) {
        for (var rowIdx = 0; rowIdx < this.totalRowCount; rowIdx += 1) {
            var rowInfo = this.rowInfo[rowIdx];
            for (var colIdx = 0; colIdx < this.totalColumnCount; colIdx += 1) {
                if (rowInfo[colIdx].offset + 1 > cellPos.pos) {
                    return [rowIdx, colIdx];
                }
            }
        }
        return [0, 0];
    };
    TableOffsetMap.prototype.getRectOffsets = function (startCellPos, endCellPos) {
        var _a, _b, _c;
        if (endCellPos === void 0) { endCellPos = startCellPos; }
        if (startCellPos.pos > endCellPos.pos) {
            _a = [endCellPos, startCellPos], startCellPos = _a[0], endCellPos = _a[1];
        }
        var _d = this.getCellIndex(startCellPos), startRowIdx = _d[0], startColIdx = _d[1];
        var _e = this.getCellIndex(endCellPos), endRowIdx = _e[0], endColIdx = _e[1];
        _b = getSortedNumPair(startRowIdx, endRowIdx), startRowIdx = _b[0], endRowIdx = _b[1];
        _c = getSortedNumPair(startColIdx, endColIdx), startColIdx = _c[0], endColIdx = _c[1];
        return this.getSpannedOffsets({ startRowIdx: startRowIdx, startColIdx: startColIdx, endRowIdx: endRowIdx, endColIdx: endColIdx });
    };
    TableOffsetMap.prototype.getSpannedOffsets = function (selectionInfo) {
        return selectionInfo;
    };
    return TableOffsetMap;
}());

/* eslint-enable @typescript-eslint/no-unused-vars */
var createOffsetMap = function (headOrBody, startOffset) {
    var cellInfoMatrix = [];
    headOrBody.forEach(function (row, rowOffset) {
        // get row index based on table(not table head or table body)
        var rowInfo = { rowspanMap: {}, colspanMap: {}, length: 0 };
        row.forEach(function (_a, cellOffset) {
            var nodeSize = _a.nodeSize;
            var colIdx = 0;
            while (rowInfo[colIdx]) {
                colIdx += 1;
            }
            rowInfo[colIdx] = {
                // 2 is the sum of the front and back positions of the tag
                offset: startOffset + rowOffset + cellOffset + 2,
                nodeSize: nodeSize,
            };
            rowInfo.length += 1;
        });
        cellInfoMatrix.push(rowInfo);
    });
    return cellInfoMatrix;
};
function mixinTableOffsetMapPrototype(offsetMapMixin, createOffsetMapMixin) {
    common_assign(TableOffsetMap.prototype, offsetMapMixin);
    createOffsetMap = createOffsetMapMixin;
    return TableOffsetMap;
}

;// CONCATENATED MODULE: ./src/wysiwyg/plugins/selection/cellSelection.ts




function getSelectionRanges(doc, map, _a) {
    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx;
    var ranges = [];
    for (var rowIdx = startRowIdx; rowIdx <= endRowIdx; rowIdx += 1) {
        for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {
            var _b = map.getCellInfo(rowIdx, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;
            ranges.push(new external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.SelectionRange(doc.resolve(offset + 1), doc.resolve(offset + nodeSize - 1)));
        }
    }
    return ranges;
}
function createTableFragment(tableHead, tableBody) {
    var fragment = [];
    if (tableHead.childCount) {
        fragment.push(tableHead);
    }
    if (tableBody.childCount) {
        fragment.push(tableBody);
    }
    return external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.from(fragment);
}
var CellSelection = /** @class */ (function (_super) {
    __extends(CellSelection, _super);
    function CellSelection(startCellPos, endCellPos) {
        if (endCellPos === void 0) { endCellPos = startCellPos; }
        var _this = this;
        var doc = startCellPos.node(0);
        var map = TableOffsetMap.create(startCellPos);
        var selectionInfo = map.getRectOffsets(startCellPos, endCellPos);
        var ranges = getSelectionRanges(doc, map, selectionInfo);
        _this = _super.call(this, ranges[0].$from, ranges[0].$to, ranges) || this;
        _this.startCell = startCellPos;
        _this.endCell = endCellPos;
        _this.offsetMap = map;
        _this.isCellSelection = true;
        // This property is the api of the 'Selection' in prosemirror,
        // and is used to disable the text selection.
        _this.visible = false;
        return _this;
    }
    CellSelection.prototype.map = function (doc, mapping) {
        var startPos = this.startCell.pos;
        var endPos = this.endCell.pos;
        var startCell = doc.resolve(mapping.map(startPos));
        var endCell = doc.resolve(mapping.map(endPos));
        var map = TableOffsetMap.create(startCell);
        // text selection when rows or columns are deleted
        if (this.offsetMap.totalColumnCount > map.totalColumnCount ||
            this.offsetMap.totalRowCount > map.totalRowCount) {
            var depthMap = { tableBody: 1, tableRow: 2, tableCell: 3, paragraph: 4 };
            var depthFromTable = depthMap[endCell.parent.type.name];
            var tableEndPos = endCell.end(endCell.depth - depthFromTable);
            // subtract 4(</td></tr></tbody></table> tag length)
            var from = Math.min(tableEndPos - 4, endCell.pos);
            return external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.TextSelection.create(doc, from);
        }
        return new CellSelection(startCell, endCell);
    };
    CellSelection.prototype.eq = function (cell) {
        return (cell instanceof CellSelection &&
            cell.startCell.pos === this.startCell.pos &&
            cell.endCell.pos === this.endCell.pos);
    };
    CellSelection.prototype.content = function () {
        var table = this.startCell.node(-2);
        var tableOffset = this.startCell.start(-2);
        var row = table.child(1).firstChild;
        var tableHead = table.child(0).type.create();
        var tableBody = table.child(1).type.create();
        var map = TableOffsetMap.create(this.startCell);
        var selectionInfo = map.getRectOffsets(this.startCell, this.endCell);
        var startRowIdx = selectionInfo.startRowIdx, startColIdx = selectionInfo.startColIdx, endRowIdx = selectionInfo.endRowIdx, endColIdx = selectionInfo.endColIdx;
        var isTableHeadCell = false;
        for (var rowIdx = startRowIdx; rowIdx <= endRowIdx; rowIdx += 1) {
            var cells = [];
            for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {
                var offset = map.getCellInfo(rowIdx, colIdx).offset;
                var cell = table.nodeAt(offset - tableOffset);
                if (cell) {
                    isTableHeadCell = cell.type.name === 'tableHeadCell';
                    // mark the extended cell for pasting
                    if (map.extendedRowspan(rowIdx, colIdx) || map.extendedColspan(rowIdx, colIdx)) {
                        cells.push(cell.type.create({ extended: true }));
                    }
                    else {
                        cells.push(cell.copy(cell.content));
                    }
                }
            }
            var copiedRow = row.copy(external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.from(cells));
            var targetNode = isTableHeadCell ? tableHead : tableBody;
            // @ts-ignore
            targetNode.content = targetNode.content.append(external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.from(copiedRow));
        }
        return new external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Slice(createTableFragment(tableHead, tableBody), 1, 1);
    };
    CellSelection.prototype.toJSON = function () {
        return JSON.stringify(this);
    };
    return CellSelection;
}(external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Selection));
/* harmony default export */ var selection_cellSelection = (CellSelection);

;// CONCATENATED MODULE: ./src/wysiwyg/helper/table.ts



function createTableHeadRow(columnCount, schema, data) {
    var _a = schema.nodes, tableRow = _a.tableRow, tableHeadCell = _a.tableHeadCell, paragraph = _a.paragraph;
    var cells = [];
    for (var index = 0; index < columnCount; index += 1) {
        var text = data && data[index];
        var para = paragraph.create(null, text ? schema.text(text) : []);
        cells.push(tableHeadCell.create(null, para));
    }
    return [tableRow.create(null, cells)];
}
function createTableBodyRows(rowCount, columnCount, schema, data) {
    var _a = schema.nodes, tableRow = _a.tableRow, tableBodyCell = _a.tableBodyCell, paragraph = _a.paragraph;
    var tableRows = [];
    for (var rowIdx = 0; rowIdx < rowCount; rowIdx += 1) {
        var cells = [];
        for (var colIdx = 0; colIdx < columnCount; colIdx += 1) {
            var text = data && data[rowIdx * columnCount + colIdx];
            var para = paragraph.create(null, text ? schema.text(text) : []);
            cells.push(tableBodyCell.create(null, para));
        }
        tableRows.push(tableRow.create(null, cells));
    }
    return tableRows;
}
function createDummyCells(columnCount, rowIdx, schema, attrs) {
    if (attrs === void 0) { attrs = null; }
    var _a = schema.nodes, tableHeadCell = _a.tableHeadCell, tableBodyCell = _a.tableBodyCell, paragraph = _a.paragraph;
    var cell = rowIdx === 0 ? tableHeadCell : tableBodyCell;
    var cells = [];
    for (var index = 0; index < columnCount; index += 1) {
        cells.push(cell.create(attrs, paragraph.create()));
    }
    return cells;
}
function findCellElement(node, root) {
    while (node && node !== root) {
        if (node.nodeName === 'TD' || node.nodeName === 'TH') {
            return node;
        }
        node = node.parentNode;
    }
    return null;
}
function findCell(pos) {
    return findNodeBy(pos, function (_a) {
        var type = _a.type;
        return type.name === 'tableHeadCell' || type.name === 'tableBodyCell';
    });
}
function getResolvedSelection(selection) {
    if (selection instanceof external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.TextSelection) {
        var $anchor = selection.$anchor;
        var foundCell = findCell($anchor);
        if (foundCell) {
            var anchor = $anchor.node(0).resolve($anchor.before(foundCell.depth));
            return { anchor: anchor, head: anchor };
        }
    }
    var _a = selection, startCell = _a.startCell, endCell = _a.endCell;
    return { anchor: startCell, head: endCell };
}
function getTableContentFromSlice(slice) {
    var _a;
    if (slice.size) {
        var content = slice.content, openStart = slice.openStart, openEnd = slice.openEnd;
        if (content.childCount !== 1) {
            return null;
        }
        while (content.childCount === 1 &&
            ((openStart > 0 && openEnd > 0) || ((_a = content.firstChild) === null || _a === void 0 ? void 0 : _a.type.name) === 'table')) {
            openStart -= 1;
            openEnd -= 1;
            content = content.firstChild.content;
        }
        if (content.firstChild.type.name === 'tableHead' ||
            content.firstChild.type.name === 'tableBody') {
            return content;
        }
    }
    return null;
}
function getRowAndColumnCount(_a) {
    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx;
    var rowCount = endRowIdx - startRowIdx + 1;
    var columnCount = endColIdx - startColIdx + 1;
    return { rowCount: rowCount, columnCount: columnCount };
}
function setAttrs(cell, attrs) {
    return __assign(__assign({}, cell.attrs), attrs);
}

;// CONCATENATED MODULE: ./src/wysiwyg/plugins/selection/tableSelectionView.ts



var tableSelectionView_pluginKey = new external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.PluginKey('cellSelection');
var MOUSE_RIGHT_BUTTON = 2;
var TableSelection = /** @class */ (function () {
    function TableSelection(view) {
        this.view = view;
        this.handlers = {
            mousedown: this.handleMousedown.bind(this),
            mousemove: this.handleMousemove.bind(this),
            mouseup: this.handleMouseup.bind(this),
        };
        this.startCellPos = null;
        this.init();
    }
    TableSelection.prototype.init = function () {
        this.view.dom.addEventListener('mousedown', this.handlers.mousedown);
    };
    TableSelection.prototype.handleMousedown = function (ev) {
        var foundCell = findCellElement(ev.target, this.view.dom);
        if (ev.button === MOUSE_RIGHT_BUTTON) {
            ev.preventDefault();
            return;
        }
        if (foundCell) {
            var startCellPos = this.getCellPos(ev);
            if (startCellPos) {
                this.startCellPos = startCellPos;
            }
            this.bindEvent();
        }
    };
    TableSelection.prototype.handleMousemove = function (ev) {
        var prevEndCellOffset = tableSelectionView_pluginKey.getState(this.view.state);
        var endCellPos = this.getCellPos(ev);
        var startCellPos = this.startCellPos;
        var prevEndCellPos;
        if (prevEndCellOffset) {
            prevEndCellPos = this.view.state.doc.resolve(prevEndCellOffset);
        }
        else if (startCellPos !== endCellPos) {
            prevEndCellPos = startCellPos;
        }
        if (prevEndCellPos && startCellPos && endCellPos) {
            this.setCellSelection(startCellPos, endCellPos);
        }
    };
    TableSelection.prototype.handleMouseup = function () {
        this.startCellPos = null;
        this.unbindEvent();
        if (tableSelectionView_pluginKey.getState(this.view.state) !== null) {
            this.view.dispatch(this.view.state.tr.setMeta(tableSelectionView_pluginKey, -1));
        }
    };
    TableSelection.prototype.bindEvent = function () {
        var dom = this.view.dom;
        dom.addEventListener('mousemove', this.handlers.mousemove);
        dom.addEventListener('mouseup', this.handlers.mouseup);
    };
    TableSelection.prototype.unbindEvent = function () {
        var dom = this.view.dom;
        dom.removeEventListener('mousemove', this.handlers.mousemove);
        dom.removeEventListener('mouseup', this.handlers.mouseup);
    };
    TableSelection.prototype.getCellPos = function (_a) {
        var clientX = _a.clientX, clientY = _a.clientY;
        var mousePos = this.view.posAtCoords({ left: clientX, top: clientY });
        if (mousePos) {
            var doc = this.view.state.doc;
            var currentPos = doc.resolve(mousePos.pos);
            var foundCell = findCell(currentPos);
            if (foundCell) {
                var cellOffset = currentPos.before(foundCell.depth);
                return doc.resolve(cellOffset);
            }
        }
        return null;
    };
    TableSelection.prototype.setCellSelection = function (startCellPos, endCellPos) {
        var _a = this.view.state, selection = _a.selection, tr = _a.tr;
        var starting = tableSelectionView_pluginKey.getState(this.view.state) === null;
        var cellSelection = new selection_cellSelection(startCellPos, endCellPos);
        if (starting || !selection.eq(cellSelection)) {
            var newTr = tr.setSelection(cellSelection);
            if (starting) {
                newTr.setMeta(tableSelectionView_pluginKey, endCellPos.pos);
            }
            this.view.dispatch(newTr);
        }
    };
    TableSelection.prototype.destroy = function () {
        this.view.dom.removeEventListener('mousedown', this.handlers.mousedown);
    };
    return TableSelection;
}());
/* harmony default export */ var tableSelectionView = (TableSelection);

;// CONCATENATED MODULE: ./src/wysiwyg/plugins/selection/tableSelection.ts






var SELECTED_CELL_CLASS_NAME = cls('cell-selected');
function drawCellSelection(_a) {
    var selection = _a.selection, doc = _a.doc;
    if (selection instanceof selection_cellSelection) {
        var cells_1 = [];
        var ranges = selection.ranges;
        ranges.forEach(function (_a) {
            var $from = _a.$from, $to = _a.$to;
            cells_1.push(external_commonjs_prosemirror_view_commonjs2_prosemirror_view_amd_prosemirror_view_.Decoration.node($from.pos - 1, $to.pos + 1, { class: SELECTED_CELL_CLASS_NAME }));
        });
        return external_commonjs_prosemirror_view_commonjs2_prosemirror_view_amd_prosemirror_view_.DecorationSet.create(doc, cells_1);
    }
    return null;
}
function tableSelection() {
    return new external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Plugin({
        key: tableSelectionView_pluginKey,
        state: {
            init: function () {
                return null;
            },
            apply: function (tr, value) {
                var cellOffset = tr.getMeta(tableSelectionView_pluginKey);
                if (cellOffset) {
                    return cellOffset === -1 ? null : cellOffset;
                }
                if (isNull_default()(value) || !tr.docChanged) {
                    return value;
                }
                var _a = tr.mapping.mapResult(value), deleted = _a.deleted, pos = _a.pos;
                return deleted ? null : pos;
            },
        },
        props: {
            decorations: drawCellSelection,
            createSelectionBetween: function (_a) {
                var state = _a.state;
                if (!isNull_default()(tableSelectionView_pluginKey.getState(state))) {
                    return state.selection;
                }
                return null;
            },
        },
        view: function (editorView) {
            return new tableSelectionView(editorView);
        },
    });
}

// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/array/inArray.js
var inArray = __nested_webpack_require_93901__(928);
var inArray_default = /*#__PURE__*/__nested_webpack_require_93901__.n(inArray);
;// CONCATENATED MODULE: ./src/utils/map.ts

/**
 * @class
 * @ignore
 * @classdesc ES6 Map
 */
var map_Map = /** @class */ (function () {
    function Map() {
        this.keys = [];
        this.values = [];
    }
    Map.prototype.getKeyIndex = function (key) {
        return inArray_default()(key, this.keys);
    };
    Map.prototype.get = function (key) {
        return this.values[this.getKeyIndex(key)];
    };
    Map.prototype.set = function (key, value) {
        var keyIndex = this.getKeyIndex(key);
        if (keyIndex > -1) {
            this.values[keyIndex] = value;
        }
        else {
            this.keys.push(key);
            this.values.push(value);
        }
        return this;
    };
    Map.prototype.has = function (key) {
        return this.getKeyIndex(key) > -1;
    };
    Map.prototype.delete = function (key) {
        var keyIndex = this.getKeyIndex(key);
        if (keyIndex > -1) {
            this.keys.splice(keyIndex, 1);
            this.values.splice(keyIndex, 1);
            return true;
        }
        return false;
    };
    Map.prototype.forEach = function (callback, thisArg) {
        var _this = this;
        if (thisArg === void 0) { thisArg = this; }
        this.values.forEach(function (value, index) {
            if (value && _this.keys[index]) {
                callback.call(thisArg, value, _this.keys[index], _this);
            }
        });
    };
    Map.prototype.clear = function () {
        this.keys = [];
        this.values = [];
    };
    return Map;
}());
/* harmony default export */ var utils_map = (map_Map);

;// CONCATENATED MODULE: ./src/i18n/i18n.ts
/**
 * @fileoverview Implements i18n
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 */


var DEFAULT_CODE = 'en-US';
/**
 * Class I18n
 * @ignore
 */
var I18n = /** @class */ (function () {
    function I18n() {
        this.code = DEFAULT_CODE;
        this.langs = new utils_map();
    }
    I18n.prototype.setCode = function (code) {
        this.code = code || DEFAULT_CODE;
    };
    /**
     * Set language set
     * @param {string|string[]} codes locale code
     * @param {object} data language set
     */
    I18n.prototype.setLanguage = function (codes, data) {
        var _this = this;
        codes = [].concat(codes);
        codes.forEach(function (code) {
            if (!_this.langs.has(code)) {
                _this.langs.set(code, data);
            }
            else {
                var langData = _this.langs.get(code);
                _this.langs.set(code, extend_default()(langData, data));
            }
        });
    };
    I18n.prototype.get = function (key, code) {
        if (!code) {
            code = this.code;
        }
        var langSet = this.langs.get(code);
        if (!langSet) {
            langSet = this.langs.get(DEFAULT_CODE);
        }
        var text = langSet[key];
        if (!text) {
            throw new Error("There is no text key \"" + key + "\" in " + code);
        }
        return text;
    };
    return I18n;
}());

/* harmony default export */ var i18n = (new I18n());

;// CONCATENATED MODULE: ./src/wysiwyg/plugins/tableContextMenu.ts



var contextMenuGroups = [
    [
        {
            action: 'Add row to up',
            command: 'addRowToUp',
            disableInThead: true,
            className: 'add-row-up',
        },
        {
            action: 'Add row to down',
            command: 'addRowToDown',
            disableInThead: true,
            className: 'add-row-down',
        },
        { action: 'Remove row', command: 'removeRow', disableInThead: true, className: 'remove-row' },
    ],
    [
        { action: 'Add column to left', command: 'addColumnToLeft', className: 'add-column-left' },
        { action: 'Add column to right', command: 'addColumnToRight', className: 'add-column-right' },
        { action: 'Remove column', command: 'removeColumn', className: 'remove-column' },
    ],
    [
        {
            action: 'Align column to left',
            command: 'alignColumn',
            payload: { align: 'left' },
            className: 'align-column-left',
        },
        {
            action: 'Align column to center',
            command: 'alignColumn',
            payload: { align: 'center' },
            className: 'align-column-center',
        },
        {
            action: 'Align column to right',
            command: 'alignColumn',
            payload: { align: 'right' },
            className: 'align-column-right',
        },
    ],
    [{ action: 'Remove table', command: 'removeTable', className: 'remove-table' }],
];
function getContextMenuGroups(eventEmitter, inTableHead) {
    return contextMenuGroups
        .map(function (contextMenuGroup) {
        return contextMenuGroup.map(function (_a) {
            var action = _a.action, command = _a.command, payload = _a.payload, disableInThead = _a.disableInThead, className = _a.className;
            return {
                label: i18n.get(action),
                onClick: function () {
                    eventEmitter.emit('command', command, payload);
                },
                disabled: inTableHead && !!disableInThead,
                className: className,
            };
        });
    })
        .concat();
}
function tableContextMenu(eventEmitter) {
    return new external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Plugin({
        props: {
            handleDOMEvents: {
                contextmenu: function (view, ev) {
                    var tableCell = findCellElement(ev.target, view.dom);
                    if (tableCell) {
                        ev.preventDefault();
                        var _a = ev, clientX = _a.clientX, clientY = _a.clientY;
                        var _b = view.dom.parentNode.getBoundingClientRect(), left = _b.left, top = _b.top;
                        var inTableHead = tableCell.nodeName === 'TH';
                        eventEmitter.emit('contextmenu', {
                            pos: { left: clientX - left + 10 + "px", top: clientY - top + 30 + "px" },
                            menuGroups: getContextMenuGroups(eventEmitter, inTableHead),
                            tableCell: tableCell,
                        });
                        return true;
                    }
                    return false;
                },
            },
        },
    });
}

;// CONCATENATED MODULE: ./src/wysiwyg/plugins/task.ts




function task() {
    return new external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Plugin({
        props: {
            handleDOMEvents: {
                mousedown: function (view, ev) {
                    var _a = ev, clientX = _a.clientX, clientY = _a.clientY;
                    var mousePos = view.posAtCoords({ left: clientX, top: clientY });
                    if (mousePos) {
                        var _b = view.state, doc = _b.doc, tr = _b.tr;
                        var currentPos = doc.resolve(mousePos.pos);
                        var listItem = findListItem(currentPos);
                        var target = ev.target;
                        var style = getComputedStyle(target, ':before');
                        var _c = ev, offsetX = _c.offsetX, offsetY = _c.offsetY;
                        if (!listItem || !isPositionInBox(style, offsetX, offsetY)) {
                            return false;
                        }
                        ev.preventDefault();
                        var offset = currentPos.before(listItem.depth);
                        var attrs = listItem.node.attrs;
                        tr.setNodeMarkup(offset, null, __assign(__assign({}, attrs), { checked: !attrs.checked }));
                        view.dispatch(tr);
                        return true;
                    }
                    return false;
                },
            },
        },
    });
}

;// CONCATENATED MODULE: ./src/wysiwyg/plugins/toolbarState.ts


var EXCEPT_TYPES = ['image', 'link', 'customBlock', 'frontMatter'];
var MARK_TYPES = ['strong', 'strike', 'emph', 'code'];
var LIST_TYPES = ['bulletList', 'orderedList', 'taskList'];
function toolbarState_getToolbarStateType(node, parentNode) {
    var type = node.type.name;
    if (type === 'listItem') {
        return node.attrs.task ? 'taskList' : parentNode.type.name;
    }
    if (type.indexOf('table') !== -1) {
        return 'table';
    }
    return type;
}
function setListNodeToolbarState(type, nodeTypeState) {
    nodeTypeState[type] = { active: true };
    LIST_TYPES.filter(function (listName) { return listName !== type; }).forEach(function (listType) {
        if (nodeTypeState[listType]) {
            delete nodeTypeState[listType];
        }
    });
}
function setMarkTypeStates(from, to, schema, toolbarState) {
    MARK_TYPES.forEach(function (type) {
        var mark = schema.marks[type];
        var marksAtPos = from.marksAcross(to) || [];
        var foundMark = !!mark.isInSet(marksAtPos);
        if (foundMark) {
            toolbarState[type] = { active: true };
        }
    });
}
function toolbarState_getToolbarState(selection, doc, schema) {
    var $from = selection.$from, $to = selection.$to, from = selection.from, to = selection.to;
    var toolbarState = {
        indent: { active: false, disabled: true },
        outdent: { active: false, disabled: true },
    };
    doc.nodesBetween(from, to, function (node, _, parentNode) {
        var type = toolbarState_getToolbarStateType(node, parentNode);
        if (common_includes(EXCEPT_TYPES, type)) {
            return;
        }
        if (common_includes(LIST_TYPES, type)) {
            setListNodeToolbarState(type, toolbarState);
            toolbarState.indent.disabled = false;
            toolbarState.outdent.disabled = false;
        }
        else if (type === 'paragraph' || type === 'text') {
            setMarkTypeStates($from, $to, schema, toolbarState);
        }
        else {
            toolbarState[type] = { active: true };
        }
    });
    return toolbarState;
}
function toolbarStateHighlight(eventEmitter) {
    return new external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Plugin({
        view: function () {
            return {
                update: function (view) {
                    var _a = view.state, selection = _a.selection, doc = _a.doc, schema = _a.schema;
                    eventEmitter.emit('changeToolbarState', {
                        toolbarState: toolbarState_getToolbarState(selection, doc, schema),
                    });
                },
            };
        },
    });
}

;// CONCATENATED MODULE: ./src/wysiwyg/nodeview/customBlockView.ts









var CustomBlockView = /** @class */ (function () {
    function CustomBlockView(node, view, getPos, toDOMAdaptor) {
        var _this = this;
        this.openEditor = function () {
            if (_this.innerEditorView) {
                throw new Error('The editor is already opened.');
            }
            _this.dom.draggable = false;
            _this.wrapper.style.display = 'none';
            _this.innerViewContainer.style.display = 'block';
            _this.innerEditorView = new external_commonjs_prosemirror_view_commonjs2_prosemirror_view_amd_prosemirror_view_.EditorView(_this.innerViewContainer, {
                state: external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.EditorState.create({
                    doc: _this.node,
                    plugins: [
                        (0,external_commonjs_prosemirror_keymap_commonjs2_prosemirror_keymap_amd_prosemirror_keymap_.keymap)({
                            'Mod-z': function () { return (0,external_commonjs_prosemirror_history_commonjs2_prosemirror_history_amd_prosemirror_history_.undo)(_this.innerEditorView.state, _this.innerEditorView.dispatch); },
                            'Shift-Mod-z': function () { return (0,external_commonjs_prosemirror_history_commonjs2_prosemirror_history_amd_prosemirror_history_.redo)(_this.innerEditorView.state, _this.innerEditorView.dispatch); },
                            Tab: function (state, dispatch) {
                                dispatch(state.tr.insertText('\t'));
                                return true;
                            },
                            Enter: external_commonjs_prosemirror_commands_commonjs2_prosemirror_commands_amd_prosemirror_commands_.newlineInCode,
                            Escape: function () {
                                _this.cancelEditing();
                                return true;
                            },
                            'Ctrl-Enter': function () {
                                _this.saveAndFinishEditing();
                                return true;
                            },
                        }),
                        (0,external_commonjs_prosemirror_history_commonjs2_prosemirror_history_amd_prosemirror_history_.history)(),
                    ],
                }),
                dispatchTransaction: function (tr) { return _this.dispatchInner(tr); },
                handleDOMEvents: {
                    mousedown: function () {
                        if (_this.editorView.hasFocus()) {
                            _this.innerEditorView.focus();
                        }
                        return true;
                    },
                    blur: function () {
                        _this.saveAndFinishEditing();
                        return true;
                    },
                },
            });
            _this.innerEditorView.focus();
        };
        this.node = node;
        this.editorView = view;
        this.getPos = getPos;
        this.toDOMAdaptor = toDOMAdaptor;
        this.innerEditorView = null;
        this.canceled = false;
        this.dom = document.createElement('div');
        this.dom.className = cls('custom-block');
        this.wrapper = document.createElement('div');
        this.wrapper.className = cls('custom-block-view');
        this.createInnerViewContainer();
        this.renderCustomBlock();
        this.dom.appendChild(this.innerViewContainer);
        this.dom.appendChild(this.wrapper);
    }
    CustomBlockView.prototype.renderToolArea = function () {
        var _this = this;
        var tool = document.createElement('div');
        var span = document.createElement('span');
        var button = document.createElement('button');
        tool.className = 'tool';
        span.textContent = this.node.attrs.info;
        span.className = 'info';
        button.type = 'button';
        button.addEventListener('click', function () { return _this.openEditor(); });
        tool.appendChild(span);
        tool.appendChild(button);
        this.wrapper.appendChild(tool);
    };
    CustomBlockView.prototype.renderCustomBlock = function () {
        var toDOMNode = this.toDOMAdaptor.getToDOMNode(this.node.attrs.info);
        if (toDOMNode) {
            var node = toDOMNode(this.node);
            while (this.wrapper.hasChildNodes()) {
                this.wrapper.removeChild(this.wrapper.lastChild);
            }
            if (node) {
                this.wrapper.appendChild(node);
            }
            this.renderToolArea();
        }
    };
    CustomBlockView.prototype.createInnerViewContainer = function () {
        this.innerViewContainer = document.createElement('div');
        this.innerViewContainer.className = cls('custom-block-editor');
        this.innerViewContainer.style.display = 'none';
    };
    CustomBlockView.prototype.closeEditor = function () {
        if (this.innerEditorView) {
            this.innerEditorView.destroy();
            this.innerEditorView = null;
            this.innerViewContainer.style.display = 'none';
        }
        this.wrapper.style.display = 'block';
    };
    CustomBlockView.prototype.saveAndFinishEditing = function () {
        var to = this.editorView.state.selection.to;
        var outerState = this.editorView.state;
        this.editorView.dispatch(outerState.tr.setSelection(createTextSelection(outerState.tr, to)));
        this.editorView.focus();
        this.renderCustomBlock();
        this.closeEditor();
    };
    CustomBlockView.prototype.cancelEditing = function () {
        var undoableCount = (0,external_commonjs_prosemirror_history_commonjs2_prosemirror_history_amd_prosemirror_history_.undoDepth)(this.innerEditorView.state);
        this.canceled = true;
        // should undo editing result
        // eslint-disable-next-line no-plusplus
        while (undoableCount--) {
            (0,external_commonjs_prosemirror_history_commonjs2_prosemirror_history_amd_prosemirror_history_.undo)(this.innerEditorView.state, this.innerEditorView.dispatch);
            (0,external_commonjs_prosemirror_history_commonjs2_prosemirror_history_amd_prosemirror_history_.undo)(this.editorView.state, this.editorView.dispatch);
        }
        this.canceled = false;
        var to = this.editorView.state.selection.to;
        var outerState = this.editorView.state;
        this.editorView.dispatch(outerState.tr.setSelection(external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.TextSelection.create(outerState.doc, to)));
        this.editorView.focus();
        this.closeEditor();
    };
    CustomBlockView.prototype.dispatchInner = function (tr) {
        var _a = this.innerEditorView.state.applyTransaction(tr), state = _a.state, transactions = _a.transactions;
        this.innerEditorView.updateState(state);
        if (!this.canceled && isFunction_default()(this.getPos)) {
            var outerTr = this.editorView.state.tr;
            var offsetMap = external_commonjs_prosemirror_transform_commonjs2_prosemirror_transform_amd_prosemirror_transform_.StepMap.offset(this.getPos() + 1);
            for (var i = 0; i < transactions.length; i += 1) {
                var steps = transactions[i].steps;
                for (var j = 0; j < steps.length; j += 1) {
                    outerTr.step(steps[j].map(offsetMap));
                }
            }
            if (outerTr.docChanged) {
                this.editorView.dispatch(outerTr);
            }
        }
    };
    CustomBlockView.prototype.update = function (node) {
        if (!node.sameMarkup(this.node)) {
            return false;
        }
        this.node = node;
        if (!this.innerEditorView) {
            this.renderCustomBlock();
        }
        return true;
    };
    CustomBlockView.prototype.stopEvent = function (event) {
        return (!!this.innerEditorView &&
            !!event.target &&
            this.innerEditorView.dom.contains(event.target));
    };
    CustomBlockView.prototype.ignoreMutation = function () {
        return true;
    };
    CustomBlockView.prototype.destroy = function () {
        this.dom.removeEventListener('dblclick', this.openEditor);
        this.closeEditor();
    };
    return CustomBlockView;
}());


;// CONCATENATED MODULE: ./src/wysiwyg/nodeview/imageView.ts





var IMAGE_LINK_CLASS_NAME = 'image-link';
var ImageView = /** @class */ (function () {
    function ImageView(node, view, getPos, eventEmitter) {
        var _this = this;
        var _a;
        this.handleMousedown = function (ev) {
            ev.preventDefault();
            var target = ev.target, offsetX = ev.offsetX, offsetY = ev.offsetY;
            if (_this.imageLink &&
                isFunction_default()(_this.getPos) &&
                hasClass_default()(target, IMAGE_LINK_CLASS_NAME)) {
                var style = getComputedStyle(target, ':before');
                ev.stopPropagation();
                if (isPositionInBox(style, offsetX, offsetY)) {
                    var tr = _this.view.state.tr;
                    var pos = _this.getPos();
                    tr.setSelection(createTextSelection(tr, pos, pos + 1));
                    _this.view.dispatch(tr);
                    _this.eventEmitter.emit('openPopup', 'link', _this.imageLink.attrs);
                }
            }
        };
        this.node = node;
        this.view = view;
        this.getPos = getPos;
        this.eventEmitter = eventEmitter;
        this.imageLink = (_a = node.marks.filter(function (_a) {
            var type = _a.type;
            return type.name === 'link';
        })[0]) !== null && _a !== void 0 ? _a : null;
        this.dom = this.createElement();
        this.bindEvent();
    }
    ImageView.prototype.createElement = function () {
        var image = this.createImageElement(this.node);
        if (this.imageLink) {
            var wrapper = document.createElement('span');
            wrapper.className = IMAGE_LINK_CLASS_NAME;
            wrapper.appendChild(image);
            return wrapper;
        }
        return image;
    };
    ImageView.prototype.createImageElement = function (node) {
        var image = document.createElement('img');
        var _a = node.attrs, imageUrl = _a.imageUrl, altText = _a.altText;
        var attrs = getCustomAttrs(node.attrs);
        image.src = imageUrl;
        if (altText) {
            image.alt = altText;
        }
        setAttributes(attrs, image);
        return image;
    };
    ImageView.prototype.bindEvent = function () {
        if (this.imageLink) {
            this.dom.addEventListener('mousedown', this.handleMousedown);
        }
    };
    ImageView.prototype.stopEvent = function () {
        return true;
    };
    ImageView.prototype.destroy = function () {
        if (this.imageLink) {
            this.dom.removeEventListener('mousedown', this.handleMousedown);
        }
    };
    return ImageView;
}());


;// CONCATENATED MODULE: ./src/wysiwyg/nodeview/codeBlockView.ts




var WRAPPER_CLASS_NAME = 'toastui-editor-ww-code-block';
var CODE_BLOCK_LANG_CLASS_NAME = 'toastui-editor-ww-code-block-language';
var CodeBlockView = /** @class */ (function () {
    function CodeBlockView(node, view, getPos, eventEmitter) {
        var _this = this;
        this.contentDOM = null;
        this.input = null;
        this.timer = null;
        this.handleMousedown = function (ev) {
            var target = ev.target;
            var style = getComputedStyle(target, ':after');
            // judge to click pseudo element with background image for IE11
            if (style.backgroundImage !== 'none' && isFunction_default()(_this.getPos)) {
                var _a = _this.view.coordsAtPos(_this.getPos()), top = _a.top, right = _a.right;
                _this.createLanguageEditor({ top: top, right: right });
            }
        };
        this.handleKeydown = function (ev) {
            if (ev.key === 'Enter' && _this.input) {
                ev.preventDefault();
                _this.changeLanguage();
            }
        };
        this.node = node;
        this.view = view;
        this.getPos = getPos;
        this.eventEmitter = eventEmitter;
        this.createElement();
        this.bindDOMEvent();
        this.bindEvent();
    }
    CodeBlockView.prototype.createElement = function () {
        var language = this.node.attrs.language;
        var wrapper = document.createElement('div');
        wrapper.setAttribute('data-language', language || 'text');
        wrapper.className = WRAPPER_CLASS_NAME;
        var pre = this.createCodeBlockElement();
        var code = pre.firstChild;
        wrapper.appendChild(pre);
        this.dom = wrapper;
        this.contentDOM = code;
    };
    CodeBlockView.prototype.createCodeBlockElement = function () {
        var pre = document.createElement('pre');
        var code = document.createElement('code');
        var language = this.node.attrs.language;
        var attrs = getCustomAttrs(this.node.attrs);
        if (language) {
            code.setAttribute('data-language', language);
        }
        setAttributes(attrs, pre);
        pre.appendChild(code);
        return pre;
    };
    CodeBlockView.prototype.createLanguageEditor = function (_a) {
        var _this = this;
        var top = _a.top, right = _a.right;
        var wrapper = document.createElement('span');
        wrapper.className = CODE_BLOCK_LANG_CLASS_NAME;
        var input = document.createElement('input');
        input.type = 'text';
        input.value = this.node.attrs.language;
        wrapper.appendChild(input);
        this.view.dom.parentElement.appendChild(wrapper);
        var wrpperWidth = wrapper.clientWidth;
        css_default()(wrapper, {
            top: top + 10 + "px",
            left: right - wrpperWidth - 10 + "px",
            width: wrpperWidth + "px",
        });
        this.input = input;
        this.input.addEventListener('blur', function () { return _this.changeLanguage(); });
        this.input.addEventListener('keydown', this.handleKeydown);
        this.clearTimer();
        this.timer = setTimeout(function () {
            _this.input.focus();
        });
    };
    CodeBlockView.prototype.bindDOMEvent = function () {
        if (this.dom) {
            this.dom.addEventListener('click', this.handleMousedown);
        }
    };
    CodeBlockView.prototype.bindEvent = function () {
        var _this = this;
        this.eventEmitter.listen('scroll', function () {
            if (_this.input) {
                _this.reset();
            }
        });
    };
    CodeBlockView.prototype.changeLanguage = function () {
        if (this.input && isFunction_default()(this.getPos)) {
            var value = this.input.value;
            this.reset();
            var pos = this.getPos();
            var tr = this.view.state.tr;
            tr.setNodeMarkup(pos, null, { language: value });
            this.view.dispatch(tr);
        }
    };
    CodeBlockView.prototype.reset = function () {
        var _a;
        if ((_a = this.input) === null || _a === void 0 ? void 0 : _a.parentElement) {
            var parent = this.input.parentElement;
            this.input = null;
            removeNode(parent);
        }
    };
    CodeBlockView.prototype.clearTimer = function () {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
    };
    CodeBlockView.prototype.stopEvent = function () {
        return true;
    };
    CodeBlockView.prototype.update = function (node) {
        if (!node.sameMarkup(this.node)) {
            return false;
        }
        this.node = node;
        return true;
    };
    CodeBlockView.prototype.destroy = function () {
        this.reset();
        this.clearTimer();
        if (this.dom) {
            this.dom.removeEventListener('click', this.handleMousedown);
        }
    };
    return CodeBlockView;
}());


;// CONCATENATED MODULE: ./src/wysiwyg/clipboard/pasteMsoList.ts

var reMSOListClassName = /MsoListParagraph/;
var reMSOStylePrefix = /style=(.|\n)*mso-/;
var reMSOListStyle = /mso-list:(.*)/;
var reMSOTagName = /O:P/;
var reMSOListBullet = /^(n|u|l)/;
var MSO_CLASS_NAME_LIST_PARA = 'p.MsoListParagraph';
function isFromMso(html) {
    return reMSOStylePrefix.test(html);
}
function getListItemContents(para) {
    var removedNodes = [];
    var walker = document.createTreeWalker(para, 1, null, false);
    while (walker.nextNode()) {
        var node = walker.currentNode;
        if (isElemNode(node)) {
            var _a = node, outerHTML = _a.outerHTML, textContent = _a.textContent;
            var msoSpan = reMSOStylePrefix.test(outerHTML);
            var bulletSpan = reMSOListStyle.test(outerHTML);
            if (msoSpan && !bulletSpan && textContent) {
                removedNodes.push([node, true]);
            }
            else if (reMSOTagName.test(node.nodeName) || (msoSpan && !textContent) || bulletSpan) {
                removedNodes.push([node, false]);
            }
        }
    }
    removedNodes.forEach(function (_a) {
        var node = _a[0], isUnwrap = _a[1];
        if (isUnwrap) {
            unwrapNode(node);
        }
        else {
            removeNode(node);
        }
    });
    return para.innerHTML.trim();
}
function createListItemDataFromParagraph(para, index) {
    var styleAttr = para.getAttribute('style');
    if (styleAttr) {
        var _a = styleAttr.match(reMSOListStyle), listItemInfo = _a[1];
        var _b = listItemInfo.trim().split(' '), levelStr = _b[1];
        var level = parseInt(levelStr.replace('level', ''), 10);
        var unordered = reMSOListBullet.test(para.textContent || '');
        return {
            id: index,
            level: level,
            prev: null,
            parent: null,
            children: [],
            unordered: unordered,
            contents: getListItemContents(para),
        };
    }
    return null;
}
function addListItemDetailData(data, prevData) {
    if (prevData.level < data.level) {
        prevData.children.push(data);
        data.parent = prevData;
    }
    else {
        while (prevData) {
            if (prevData.level === data.level) {
                break;
            }
            prevData = prevData.parent;
        }
        if (prevData) {
            data.prev = prevData;
            data.parent = prevData.parent;
            if (data.parent) {
                data.parent.children.push(data);
            }
        }
    }
}
function createListData(paras) {
    var listData = [];
    paras.forEach(function (para, index) {
        var prevListItemData = listData[index - 1];
        var listItemData = createListItemDataFromParagraph(para, index);
        if (listItemData) {
            if (prevListItemData) {
                addListItemDetailData(listItemData, prevListItemData);
            }
            listData.push(listItemData);
        }
    });
    return listData;
}
function makeList(listData) {
    var listTagName = listData[0].unordered ? 'ul' : 'ol';
    var list = document.createElement(listTagName);
    listData.forEach(function (data) {
        var children = data.children, contents = data.contents;
        var listItem = document.createElement('li');
        listItem.innerHTML = contents;
        list.appendChild(listItem);
        if (children.length) {
            list.appendChild(makeList(children));
        }
    });
    return list;
}
function makeListFromParagraphs(paras) {
    var listData = createListData(paras);
    var rootChildren = listData.filter(function (_a) {
        var parent = _a.parent;
        return !parent;
    });
    return makeList(rootChildren);
}
function isMsoListParagraphEnd(node) {
    while (node) {
        if (isElemNode(node)) {
            break;
        }
        node = node.nextSibling;
    }
    return node ? !reMSOListClassName.test(node.className) : true;
}
function convertMsoParagraphsToList(html) {
    var container = document.createElement('div');
    container.innerHTML = html;
    var paras = [];
    var foundParas = findNodes(container, MSO_CLASS_NAME_LIST_PARA);
    foundParas.forEach(function (para) {
        var msoListParaEnd = isMsoListParagraphEnd(para.nextSibling);
        paras.push(para);
        if (msoListParaEnd) {
            var list = makeListFromParagraphs(paras);
            var nextSibling = para.nextSibling;
            if (nextSibling) {
                insertBeforeNode(list, nextSibling);
            }
            else {
                appendNodes(container, list);
            }
            paras = [];
        }
        removeNode(para);
    });
    // without `<p></p>`, the list string was parsed as a paragraph node and added
    var extraHTML = foundParas.length ? '<p></p>' : '';
    return "" + extraHTML + container.innerHTML;
}

;// CONCATENATED MODULE: ./src/wysiwyg/clipboard/paste.ts





var START_FRAGMENT_COMMENT = '<!--StartFragment-->';
var END_FRAGMENT_COMMENT = '<!--EndFragment-->';
function getContentBetweenFragmentComments(html) {
    var startFragmentIndex = html.indexOf(START_FRAGMENT_COMMENT);
    var endFragmentIndex = html.lastIndexOf(END_FRAGMENT_COMMENT);
    if (startFragmentIndex > -1 && endFragmentIndex > -1) {
        html = html.slice(startFragmentIndex + START_FRAGMENT_COMMENT.length, endFragmentIndex);
    }
    return html.replace(/<br[^>]*>/g, ALTERNATIVE_TAG_FOR_BR);
}
function convertMsoTableToCompletedTable(html) {
    // wrap with <tr> if html contains dangling <td> tags
    // dangling <td> tag is that tag does not have <tr> as parent node
    if (/<\/td>((?!<\/tr>)[\s\S])*$/i.test(html)) {
        html = "<tr>" + html + "</tr>";
    }
    // wrap with <table> if html contains dangling <tr> tags
    // dangling <tr> tag is that tag does not have <table> as parent node
    if (/<\/tr>((?!<\/table>)[\s\S])*$/i.test(html)) {
        html = "<table>" + html + "</table>";
    }
    return html;
}
function changePastedHTML(html) {
    html = getContentBetweenFragmentComments(html);
    html = convertMsoTableToCompletedTable(html);
    if (isFromMso(html)) {
        html = convertMsoParagraphsToList(html);
    }
    return html;
}
function getMaxColumnCount(rows) {
    var row = rows.reduce(function (prevRow, currentRow) {
        return prevRow.childCount > currentRow.childCount ? prevRow : currentRow;
    });
    return row.childCount;
}
function createCells(orgRow, maxColumnCount, cell) {
    var cells = [];
    var cellCount = orgRow.childCount;
    for (var colIdx = 0; colIdx < cellCount; colIdx += 1) {
        if (!orgRow.child(colIdx).attrs.extended) {
            var copiedCell = colIdx < cellCount
                ? cell.create(orgRow.child(colIdx).attrs, orgRow.child(colIdx).content)
                : cell.createAndFill();
            cells.push(copiedCell);
        }
    }
    return cells;
}
function copyTableHeadRow(orgRow, maxColumnCount, schema) {
    var _a = schema.nodes, tableRow = _a.tableRow, tableHeadCell = _a.tableHeadCell;
    var cells = createCells(orgRow, maxColumnCount, tableHeadCell);
    return tableRow.create(null, cells);
}
function copyTableBodyRow(orgRow, maxColumnCount, schema) {
    var _a = schema.nodes, tableRow = _a.tableRow, tableBodyCell = _a.tableBodyCell;
    var cells = createCells(orgRow, maxColumnCount, tableBodyCell);
    return tableRow.create(null, cells);
}
function creatTableBodyDummyRow(columnCount, schema) {
    var _a = schema.nodes, tableRow = _a.tableRow, tableBodyCell = _a.tableBodyCell;
    var cells = [];
    for (var columnIndex = 0; columnIndex < columnCount; columnIndex += 1) {
        var dummyCell = tableBodyCell.createAndFill();
        cells.push(dummyCell);
    }
    return tableRow.create({ dummyRowForPasting: true }, cells);
}
function createRowsFromPastingTable(tableContent) {
    var tableHeadRows = [];
    var tableBodyRows = [];
    if (tableContent.firstChild.type.name === 'tableHead') {
        var tableHead = tableContent.firstChild;
        tableHead.forEach(function (row) { return tableHeadRows.push(row); });
    }
    if (tableContent.lastChild.type.name === 'tableBody') {
        var tableBody = tableContent.lastChild;
        tableBody.forEach(function (row) { return tableBodyRows.push(row); });
    }
    return __spreadArray(__spreadArray([], tableHeadRows), tableBodyRows);
}
function createTableHead(tableHeadRow, maxColumnCount, schema) {
    var copiedRow = copyTableHeadRow(tableHeadRow, maxColumnCount, schema);
    return schema.nodes.tableHead.create(null, copiedRow);
}
function paste_createTableBody(tableBodyRows, maxColumnCount, schema) {
    var copiedRows = tableBodyRows.map(function (tableBodyRow) {
        return copyTableBodyRow(tableBodyRow, maxColumnCount, schema);
    });
    if (!tableBodyRows.length) {
        var dummyTableRow = creatTableBodyDummyRow(maxColumnCount, schema);
        copiedRows.push(dummyTableRow);
    }
    return schema.nodes.tableBody.create(null, copiedRows);
}
function createTableFromPastingTable(rows, schema, startFromBody, isInTable) {
    var columnCount = getMaxColumnCount(rows);
    if (startFromBody && isInTable) {
        return schema.nodes.table.create(null, [paste_createTableBody(rows, columnCount, schema)]);
    }
    var tableHeadRow = rows[0];
    var tableBodyRows = rows.slice(1);
    var nodes = [createTableHead(tableHeadRow, columnCount, schema)];
    if (tableBodyRows.length) {
        nodes.push(paste_createTableBody(tableBodyRows, columnCount, schema));
    }
    return schema.nodes.table.create(null, nodes);
}
function changePastedSlice(slice, schema, isInTable) {
    var nodes = [];
    var content = slice.content, openStart = slice.openStart, openEnd = slice.openEnd;
    content.forEach(function (node) {
        if (node.type.name === 'table') {
            var tableContent = getTableContentFromSlice(new external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Slice(external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.from(node), 0, 0));
            if (tableContent) {
                var rows = createRowsFromPastingTable(tableContent);
                var startFromBody = tableContent.firstChild.type.name === 'tableBody';
                var table = createTableFromPastingTable(rows, schema, startFromBody, isInTable);
                nodes.push(table);
            }
        }
        else {
            nodes.push(node);
        }
    });
    return new external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Slice(external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.from(nodes), openStart, openEnd);
}

;// CONCATENATED MODULE: ./src/wysiwyg/clipboard/pasteToTable.ts






var DUMMY_CELL_SIZE = 4;
var TR_NODES_SIZE = 2;
function getDummyCellSize(dummyCellCount) {
    return dummyCellCount * DUMMY_CELL_SIZE;
}
function createPastingCells(tableContent, curSelectionInfo, schema) {
    var pastingRows = [];
    var pastingTableRows = createRowsFromPastingTable(tableContent);
    var columnCount = pastingTableRows[0].childCount;
    var rowCount = pastingTableRows.length;
    var startToTableHead = curSelectionInfo.startRowIdx === 0;
    var slicedRows = pastingTableRows.slice(0, rowCount);
    if (startToTableHead) {
        var tableHeadRow = slicedRows.shift();
        if (tableHeadRow) {
            var content = copyTableHeadRow(tableHeadRow, columnCount, schema).content;
            pastingRows.push(content);
        }
    }
    slicedRows.forEach(function (tableBodyRow) {
        if (!tableBodyRow.attrs.dummyRowForPasting) {
            var content = copyTableBodyRow(tableBodyRow, columnCount, schema).content;
            pastingRows.push(content);
        }
    });
    return pastingRows;
}
function getPastingRangeInfo(map, _a, pastingCells) {
    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx;
    var pastingRowCount = pastingCells.length;
    var pastingColumnCount = 0;
    var _loop_1 = function (i) {
        var columnCount = pastingCells[i].childCount;
        pastingCells[i].forEach(function (_a) {
            var attrs = _a.attrs;
            var colspan = attrs.colspan;
            if (colspan > 1) {
                columnCount += colspan - 1;
            }
        });
        pastingColumnCount = Math.max(pastingColumnCount, columnCount);
    };
    for (var i = 0; i < pastingRowCount; i += 1) {
        _loop_1(i);
    }
    var endRowIdx = startRowIdx + pastingRowCount - 1;
    var endColIdx = startColIdx + pastingColumnCount - 1;
    var addedRowCount = Math.max(endRowIdx + 1 - map.totalRowCount, 0);
    var addedColumnCount = Math.max(endColIdx + 1 - map.totalColumnCount, 0);
    return {
        startRowIdx: startRowIdx,
        startColIdx: startColIdx,
        endRowIdx: endRowIdx,
        endColIdx: endColIdx,
        addedRowCount: addedRowCount,
        addedColumnCount: addedColumnCount,
    };
}
function addReplacedOffsets(_a, cellsOffsets) {
    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx, addedRowCount = _a.addedRowCount, addedColumnCount = _a.addedColumnCount;
    for (var rowIdx = startRowIdx; rowIdx <= endRowIdx - addedRowCount; rowIdx += 1) {
        cellsOffsets.push({
            rowIdx: rowIdx,
            startColIdx: startColIdx,
            endColIdx: endColIdx - addedColumnCount,
        });
    }
}
function expandColumns(tr, schema, map, _a, cellsOffsets) {
    var startRowIdx = _a.startRowIdx, startColIdx = _a.startColIdx, endRowIdx = _a.endRowIdx, endColIdx = _a.endColIdx, addedRowCount = _a.addedRowCount, addedColumnCount = _a.addedColumnCount;
    var totalRowCount = map.totalRowCount;
    var index = 0;
    for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {
        var _b = map.getCellInfo(rowIdx, endColIdx - addedColumnCount), offset = _b.offset, nodeSize = _b.nodeSize;
        var insertOffset = tr.mapping.map(offset + nodeSize);
        var cells = createDummyCells(addedColumnCount, rowIdx, schema);
        tr.insert(insertOffset, cells);
        if (rowIdx >= startRowIdx && rowIdx <= endRowIdx - addedRowCount) {
            var cellInfo = map.getCellInfo(rowIdx, endColIdx - addedColumnCount);
            var startCellOffset = tr.mapping.map(cellInfo.offset);
            var endCellOffset = insertOffset + getDummyCellSize(addedColumnCount);
            cellsOffsets[index] = {
                rowIdx: rowIdx,
                startColIdx: startColIdx,
                endColIdx: endColIdx,
                dummyOffsets: [startCellOffset, endCellOffset],
            };
            index += 1;
        }
    }
}
function expandRows(tr, schema, map, _a, cellsOffsets) {
    var addedRowCount = _a.addedRowCount, addedColumnCount = _a.addedColumnCount, startColIdx = _a.startColIdx, endColIdx = _a.endColIdx;
    var mapStart = tr.mapping.maps.length;
    var tableEndPos = map.tableEndOffset - 2;
    var rows = createTableBodyRows(addedRowCount, map.totalColumnCount + addedColumnCount, schema);
    var startOffset = tableEndPos;
    tr.insert(tr.mapping.slice(mapStart).map(startOffset), rows);
    for (var rowIndex = 0; rowIndex < addedRowCount; rowIndex += 1) {
        var startCellOffset = startOffset + getDummyCellSize(startColIdx) + 1;
        var endCellOffset = startOffset + getDummyCellSize(endColIdx + 1) + 1;
        var nextCellOffset = startOffset + getDummyCellSize(map.totalColumnCount + addedColumnCount) + TR_NODES_SIZE;
        cellsOffsets.push({
            rowIdx: rowIndex + map.totalRowCount,
            startColIdx: startColIdx,
            endColIdx: endColIdx,
            dummyOffsets: [startCellOffset, endCellOffset],
        });
        startOffset = nextCellOffset;
    }
}
function replaceCells(tr, pastingRows, cellsOffsets, map) {
    var mapStart = tr.mapping.maps.length;
    cellsOffsets.forEach(function (offsets, index) {
        var rowIdx = offsets.rowIdx, startColIdx = offsets.startColIdx, endColIdx = offsets.endColIdx, dummyOffsets = offsets.dummyOffsets;
        var mapping = tr.mapping.slice(mapStart);
        var cells = new external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Slice(pastingRows[index], 0, 0);
        var from = dummyOffsets ? dummyOffsets[0] : map.getCellStartOffset(rowIdx, startColIdx);
        var to = dummyOffsets ? dummyOffsets[1] : map.getCellEndOffset(rowIdx, endColIdx);
        tr.replace(mapping.map(from), mapping.map(to), cells);
    });
}
function pasteToTable(view, slice) {
    var _a = view.state, selection = _a.selection, schema = _a.schema, tr = _a.tr;
    var _b = getResolvedSelection(selection), anchor = _b.anchor, head = _b.head;
    if (anchor && head) {
        var tableContent = getTableContentFromSlice(slice);
        if (!tableContent) {
            return false;
        }
        var map = TableOffsetMap.create(anchor);
        var curSelectionInfo = map.getRectOffsets(anchor, head);
        var pastingCells = createPastingCells(tableContent, curSelectionInfo, schema);
        var pastingInfo = getPastingRangeInfo(map, curSelectionInfo, pastingCells);
        var cellsOffsets = [];
        // @TODO: unmerge the span and paste the cell
        if (canMerge(map, pastingInfo)) {
            addReplacedOffsets(pastingInfo, cellsOffsets);
            if (pastingInfo.addedColumnCount) {
                expandColumns(tr, schema, map, pastingInfo, cellsOffsets);
            }
            if (pastingInfo.addedRowCount) {
                expandRows(tr, schema, map, pastingInfo, cellsOffsets);
            }
            replaceCells(tr, pastingCells, cellsOffsets, map);
            view.dispatch(tr);
            setSelection(view, cellsOffsets, map.getCellInfo(0, 0).offset);
        }
        return true;
    }
    return false;
}
function setSelection(view, cellsOffsets, pos) {
    var _a = view.state, tr = _a.tr, doc = _a.doc;
    // get changed cell offsets
    var map = TableOffsetMap.create(doc.resolve(pos));
    // eslint-disable-next-line prefer-destructuring
    var _b = cellsOffsets[0], startRowIdx = _b.rowIdx, startColIdx = _b.startColIdx;
    var _c = last(cellsOffsets), endRowIdx = _c.rowIdx, endColIdx = _c.endColIdx;
    var startOffset = map.getCellInfo(startRowIdx, startColIdx).offset;
    var endOffset = map.getCellInfo(endRowIdx, endColIdx).offset;
    view.dispatch(tr.setSelection(new selection_cellSelection(doc.resolve(startOffset), doc.resolve(endOffset))));
}
function canMerge(map, pastingInfo) {
    var ranges = map.getSpannedOffsets(pastingInfo);
    var _a = getRowAndColumnCount(ranges), rowCount = _a.rowCount, columnCount = _a.columnCount;
    var _b = getRowAndColumnCount(pastingInfo), pastingRowCount = _b.rowCount, pastingColumnCount = _b.columnCount;
    return rowCount === pastingRowCount && columnCount === pastingColumnCount;
}

;// CONCATENATED MODULE: ./src/wysiwyg/nodes/doc.ts


var doc_Doc = /** @class */ (function (_super) {
    __extends(Doc, _super);
    function Doc() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Doc.prototype, "name", {
        get: function () {
            return 'doc';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Doc.prototype, "schema", {
        get: function () {
            return {
                content: 'block+',
            };
        },
        enumerable: false,
        configurable: true
    });
    return Doc;
}(node));


;// CONCATENATED MODULE: ./src/wysiwyg/nodes/paragraph.ts



var paragraph_Paragraph = /** @class */ (function (_super) {
    __extends(Paragraph, _super);
    function Paragraph() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Paragraph.prototype, "name", {
        get: function () {
            return 'paragraph';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Paragraph.prototype, "schema", {
        get: function () {
            return {
                content: 'inline*',
                group: 'block',
                attrs: __assign({}, getDefaultCustomAttrs()),
                parseDOM: [{ tag: 'p' }],
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    return ['p', getCustomAttrs(attrs), 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    return Paragraph;
}(node));


;// CONCATENATED MODULE: ./src/wysiwyg/nodes/text.ts



var reSoftTabLen = /\s{1,4}$/;
var text_Text = /** @class */ (function (_super) {
    __extends(Text, _super);
    function Text() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Text.prototype, "name", {
        get: function () {
            return 'text';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Text.prototype, "schema", {
        get: function () {
            return {
                group: 'inline',
            };
        },
        enumerable: false,
        configurable: true
    });
    Text.prototype.addSpaces = function () {
        return function (_a, dispatch) {
            var selection = _a.selection, tr = _a.tr;
            var $from = selection.$from, $to = selection.$to;
            var range = $from.blockRange($to);
            if (range && !isInListNode($from) && !isInTableNode($from)) {
                dispatch(tr.insertText('    ', $from.pos, $to.pos));
                return true;
            }
            return false;
        };
    };
    Text.prototype.removeSpaces = function () {
        return function (_a, dispatch) {
            var selection = _a.selection, tr = _a.tr;
            var $from = selection.$from, $to = selection.$to, from = selection.from;
            var range = $from.blockRange($to);
            if (range && !isInListNode($from) && !isInTableNode($from)) {
                var nodeBefore = $from.nodeBefore;
                if (nodeBefore && nodeBefore.isText) {
                    var text = nodeBefore.text;
                    var removedSpaceText = text.replace(reSoftTabLen, '');
                    var spaces = text.length - removedSpaceText.length;
                    dispatch(tr.delete(from - spaces, from));
                    return true;
                }
            }
            return false;
        };
    };
    Text.prototype.keymaps = function () {
        return {
            Tab: this.addSpaces(),
            'Shift-Tab': this.removeSpaces(),
        };
    };
    return Text;
}(node));


;// CONCATENATED MODULE: ./src/wysiwyg/nodes/heading.ts




var heading_Heading = /** @class */ (function (_super) {
    __extends(Heading, _super);
    function Heading() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Heading.prototype, "name", {
        get: function () {
            return 'heading';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Heading.prototype, "levels", {
        get: function () {
            return [1, 2, 3, 4, 5, 6];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Heading.prototype, "schema", {
        get: function () {
            var parseDOM = this.levels.map(function (level) {
                return {
                    tag: "h" + level,
                    getAttrs: function (dom) {
                        var rawHTML = dom.getAttribute('data-raw-html');
                        return __assign({ level: level }, (rawHTML && { rawHTML: rawHTML }));
                    },
                };
            });
            return {
                attrs: __assign({ level: { default: 1 }, headingType: { default: 'atx' }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
                content: 'inline*',
                group: 'block',
                defining: true,
                parseDOM: parseDOM,
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    return ["h" + attrs.level, getCustomAttrs(attrs), 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    Heading.prototype.commands = function () {
        return function (payload) { return function (state, dispatch) {
            var nodeType = state.schema.nodes[payload.level ? 'heading' : 'paragraph'];
            return (0,external_commonjs_prosemirror_commands_commonjs2_prosemirror_commands_amd_prosemirror_commands_.setBlockType)(nodeType, payload)(state, dispatch);
        }; };
    };
    return Heading;
}(node));


;// CONCATENATED MODULE: ./src/wysiwyg/nodes/codeBlock.ts






var codeBlock_CodeBlock = /** @class */ (function (_super) {
    __extends(CodeBlock, _super);
    function CodeBlock() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(CodeBlock.prototype, "name", {
        get: function () {
            return 'codeBlock';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CodeBlock.prototype, "schema", {
        get: function () {
            return {
                content: 'text*',
                group: 'block',
                attrs: __assign({ language: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
                code: true,
                defining: true,
                marks: '',
                parseDOM: [
                    {
                        tag: 'pre',
                        preserveWhitespace: 'full',
                        getAttrs: function (dom) {
                            var rawHTML = dom.getAttribute('data-raw-html');
                            var child = dom.firstElementChild;
                            return __assign({ language: (child === null || child === void 0 ? void 0 : child.getAttribute('data-language')) || null }, (rawHTML && { rawHTML: rawHTML }));
                        },
                    },
                ],
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    return [
                        attrs.rawHTML || 'pre',
                        ['code', __assign({ 'data-language': attrs.language }, getCustomAttrs(attrs)), 0],
                    ];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    CodeBlock.prototype.commands = function () {
        return function () { return function (state, dispatch) { return (0,external_commonjs_prosemirror_commands_commonjs2_prosemirror_commands_amd_prosemirror_commands_.setBlockType)(state.schema.nodes.codeBlock)(state, dispatch); }; };
    };
    CodeBlock.prototype.moveCursor = function (direction) {
        var _this = this;
        return function (state, dispatch) {
            var tr = state.tr, doc = state.doc, schema = state.schema;
            var $from = state.selection.$from;
            var view = _this.context.view;
            if (view.endOfTextblock(direction) && $from.node().type.name === 'codeBlock') {
                var lines = $from.parent.textContent.split('\n');
                var offset = direction === 'up' ? $from.start() : $from.end();
                var range = direction === 'up'
                    ? [offset, lines[0].length + offset]
                    : [offset - last(lines).length, offset];
                var pos = doc.resolve(direction === 'up' ? $from.before() : $from.after());
                var node = direction === 'up' ? pos.nodeBefore : pos.nodeAfter;
                if (between($from.pos, range[0], range[1]) && !node) {
                    var newTr = addParagraph(tr, pos, schema);
                    if (newTr) {
                        dispatch(newTr);
                        return true;
                    }
                }
            }
            return false;
        };
    };
    CodeBlock.prototype.keymaps = function () {
        var codeCommand = this.commands()();
        return {
            'Shift-Mod-p': codeCommand,
            'Shift-Mod-P': codeCommand,
            ArrowUp: this.moveCursor('up'),
            ArrowDown: this.moveCursor('down'),
        };
    };
    return CodeBlock;
}(node));


;// CONCATENATED MODULE: ./src/wysiwyg/nodes/bulletList.ts





var BulletList = /** @class */ (function (_super) {
    __extends(BulletList, _super);
    function BulletList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(BulletList.prototype, "name", {
        get: function () {
            return 'bulletList';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BulletList.prototype, "schema", {
        get: function () {
            return {
                content: 'listItem+',
                group: 'block',
                attrs: __assign({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
                parseDOM: [createDOMInfoParsedRawHTML('ul')],
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    return ['ul', getCustomAttrs(attrs), 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    BulletList.prototype.changeList = function () {
        return function (state, dispatch) { return changeList(state.schema.nodes.bulletList)(state, dispatch); };
    };
    BulletList.prototype.commands = function () {
        return {
            bulletList: this.changeList,
            taskList: toggleTask,
        };
    };
    BulletList.prototype.keymaps = function () {
        var bulletListCommand = this.changeList();
        var _a = getWwCommands(), indent = _a.indent, outdent = _a.outdent;
        return {
            'Mod-u': bulletListCommand,
            'Mod-U': bulletListCommand,
            Tab: indent(),
            'Shift-Tab': outdent(),
        };
    };
    return BulletList;
}(node));


;// CONCATENATED MODULE: ./src/wysiwyg/nodes/orderedList.ts





var OrderedList = /** @class */ (function (_super) {
    __extends(OrderedList, _super);
    function OrderedList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(OrderedList.prototype, "name", {
        get: function () {
            return 'orderedList';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(OrderedList.prototype, "schema", {
        get: function () {
            return {
                content: 'listItem+',
                group: 'block',
                attrs: __assign({ order: { default: 1 }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
                parseDOM: [
                    {
                        tag: 'ol',
                        getAttrs: function (dom) {
                            var start = dom.getAttribute('start');
                            var rawHTML = dom.getAttribute('data-raw-html');
                            return __assign({ order: dom.hasAttribute('start') ? Number(start) : 1 }, (rawHTML && { rawHTML: rawHTML }));
                        },
                    },
                ],
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    return [
                        attrs.rawHTML || 'ol',
                        __assign({ start: attrs.order === 1 ? null : attrs.order }, getCustomAttrs(attrs)),
                        0,
                    ];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    OrderedList.prototype.commands = function () {
        return function () { return function (state, dispatch) { return changeList(state.schema.nodes.orderedList)(state, dispatch); }; };
    };
    OrderedList.prototype.keymaps = function () {
        var orderedListCommand = this.commands()();
        var _a = getWwCommands(), indent = _a.indent, outdent = _a.outdent;
        return {
            'Mod-o': orderedListCommand,
            'Mod-O': orderedListCommand,
            Tab: indent(),
            'Shift-Tab': outdent(),
        };
    };
    return OrderedList;
}(node));


;// CONCATENATED MODULE: ./src/wysiwyg/nodes/listItem.ts



var listItem_ListItem = /** @class */ (function (_super) {
    __extends(ListItem, _super);
    function ListItem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ListItem.prototype, "name", {
        get: function () {
            return 'listItem';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ListItem.prototype, "schema", {
        get: function () {
            return {
                content: 'paragraph block*',
                selectable: false,
                attrs: {
                    task: { default: false },
                    checked: { default: false },
                    rawHTML: { default: null },
                },
                defining: true,
                parseDOM: [
                    {
                        tag: 'li',
                        getAttrs: function (dom) {
                            var rawHTML = dom.getAttribute('data-raw-html');
                            return __assign({ task: dom.hasAttribute('data-task'), checked: dom.hasAttribute('data-task-checked') }, (rawHTML && { rawHTML: rawHTML }));
                        },
                    },
                ],
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    var task = attrs.task, checked = attrs.checked;
                    if (!task) {
                        return [attrs.rawHTML || 'li', 0];
                    }
                    var classNames = ['task-list-item'];
                    if (checked) {
                        classNames.push('checked');
                    }
                    return [
                        attrs.rawHTML || 'li',
                        __assign({ class: classNames.join(' '), 'data-task': task }, (checked && { 'data-task-checked': checked })),
                        0,
                    ];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    ListItem.prototype.liftToPrevListItem = function () {
        return function (state, dispatch) {
            var selection = state.selection, tr = state.tr, schema = state.schema;
            var $from = selection.$from, empty = selection.empty;
            var listItem = schema.nodes.listItem;
            var parent = $from.parent;
            var listItemParent = $from.node(-1);
            if (empty && !parent.childCount && listItemParent.type === listItem) {
                // move to previous sibling list item when the current list item is not top list item
                if ($from.index(-2) >= 1) {
                    // should subtract '1' for considering tag length(<li>)
                    tr.delete($from.start(-1) - 1, $from.end(-1));
                    dispatch(tr);
                    return true;
                }
                var grandParentListItem = $from.node(-3);
                // move to parent list item when the current list item is top list item
                if (grandParentListItem.type === listItem) {
                    // should subtract '1' for considering tag length(<ul>)
                    tr.delete($from.start(-2) - 1, $from.end(-1));
                    dispatch(tr);
                    return true;
                }
            }
            return false;
        };
    };
    ListItem.prototype.keymaps = function () {
        var split = function (state, dispatch) {
            return splitListItem(state.schema.nodes.listItem)(state, dispatch);
        };
        return {
            Backspace: this.liftToPrevListItem(),
            Enter: split,
        };
    };
    return ListItem;
}(node));


;// CONCATENATED MODULE: ./src/wysiwyg/nodes/blockQuote.ts




var blockQuote_BlockQuote = /** @class */ (function (_super) {
    __extends(BlockQuote, _super);
    function BlockQuote() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(BlockQuote.prototype, "name", {
        get: function () {
            return 'blockQuote';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(BlockQuote.prototype, "schema", {
        get: function () {
            return {
                attrs: __assign({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
                content: 'block+',
                group: 'block',
                parseDOM: [createDOMInfoParsedRawHTML('blockquote')],
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    return ['blockquote', getCustomAttrs(attrs), 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    BlockQuote.prototype.commands = function () {
        return function () { return function (state, dispatch) { return (0,external_commonjs_prosemirror_commands_commonjs2_prosemirror_commands_amd_prosemirror_commands_.wrapIn)(state.schema.nodes.blockQuote)(state, dispatch); }; };
    };
    BlockQuote.prototype.keymaps = function () {
        var blockQutoeCommand = this.commands()();
        return {
            'Alt-q': blockQutoeCommand,
            'Alt-Q': blockQutoeCommand,
        };
    };
    return BlockQuote;
}(node));


;// CONCATENATED MODULE: ./src/wysiwyg/command/table.ts



var cellOffsetFnMap = {
    left: getLeftCellOffset,
    right: getRightCellOffset,
    up: getUpCellOffset,
    down: getDownCellOffset,
};
function isInFirstListItem(pos, doc, _a) {
    var paraDepth = _a[0], listDepth = _a[1];
    var listItemNode = doc.resolve(pos.before(paraDepth - 1));
    return listDepth === paraDepth && !listItemNode.nodeBefore;
}
function isInLastListItem(pos) {
    var _a;
    var depth = pos.depth;
    var parentNode;
    while (depth) {
        parentNode = pos.node(depth);
        if (parentNode.type.name === 'tableBodyCell') {
            break;
        }
        if (parentNode.type.name === 'listItem') {
            var grandParent = pos.node(depth - 1);
            var lastListItem = grandParent.lastChild === parentNode;
            var hasChildren = ((_a = parentNode.lastChild) === null || _a === void 0 ? void 0 : _a.type.name) !== 'paragraph';
            if (!lastListItem) {
                return false;
            }
            return !hasChildren;
        }
        depth -= 1;
    }
    return false;
}
function canMoveToBeforeCell(direction, _a, from, doc, inList) {
    var paraDepth = _a[0], listDepth = _a[1], curDepth = _a[2];
    if (direction === Direction.LEFT || direction === Direction.UP) {
        if (inList && !isInFirstListItem(from, doc, [paraDepth, listDepth])) {
            return false;
        }
        var endOffset = from.before(curDepth);
        var nodeBefore = doc.resolve(endOffset).nodeBefore;
        if (nodeBefore) {
            return false;
        }
    }
    return true;
}
function canMoveToAfterCell(direction, curDepth, from, doc, inList) {
    if (direction === Direction.RIGHT || direction === Direction.DOWN) {
        if (inList && !isInLastListItem(from)) {
            return false;
        }
        var endOffset = from.after(curDepth);
        var nodeAfter = doc.resolve(endOffset).nodeAfter;
        if (nodeAfter) {
            return false;
        }
    }
    return true;
}
function canMoveBetweenCells(direction, _a, from, doc) {
    var cellDepth = _a[0], paraDepth = _a[1];
    var listDepth = cellDepth + 3; // 3 is position of <ul><li><p>
    var inList = paraDepth >= listDepth;
    var curDepth = inList ? cellDepth + 1 : paraDepth;
    var moveBeforeCell = canMoveToBeforeCell(direction, [paraDepth, listDepth, curDepth], from, doc, inList);
    var moveAfterCell = canMoveToAfterCell(direction, curDepth, from, doc, inList);
    return moveBeforeCell && moveAfterCell;
}
function canBeOutOfTable(direction, map, _a) {
    var rowIdx = _a[0], colIdx = _a[1];
    var rowspanInfo = map.getRowspanStartInfo(rowIdx, colIdx);
    var inFirstRow = direction === Direction.UP && rowIdx === 0;
    var inLastRow = direction === Direction.DOWN &&
        ((rowspanInfo === null || rowspanInfo === void 0 ? void 0 : rowspanInfo.count) > 1 ? rowIdx + rowspanInfo.count - 1 : rowIdx) === map.totalRowCount - 1;
    return inFirstRow || inLastRow;
}
function addParagraphBeforeTable(tr, map, schema) {
    var tableStartPos = tr.doc.resolve(map.tableStartOffset - 1);
    if (!tableStartPos.nodeBefore) {
        return addParagraph(tr, tableStartPos, schema);
    }
    return tr.setSelection(external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Selection.near(tableStartPos, -1));
}
function addParagraphAfterTable(tr, map, schema, forcedAddtion) {
    if (forcedAddtion === void 0) { forcedAddtion = false; }
    var tableEndPos = tr.doc.resolve(map.tableEndOffset);
    if (forcedAddtion || !tableEndPos.nodeAfter) {
        return addParagraph(tr, tableEndPos, schema);
    }
    return tr.setSelection(external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Selection.near(tableEndPos, 1));
}
function getRightCellOffset(_a, map) {
    var rowIdx = _a[0], colIdx = _a[1];
    var totalRowCount = map.totalRowCount, totalColumnCount = map.totalColumnCount;
    var lastCellInRow = colIdx === totalColumnCount - 1;
    var lastCellInTable = rowIdx === totalRowCount - 1 && lastCellInRow;
    if (!lastCellInTable) {
        var nextColIdx = colIdx + 1;
        var colspanInfo = map.getColspanStartInfo(rowIdx, colIdx);
        if ((colspanInfo === null || colspanInfo === void 0 ? void 0 : colspanInfo.count) > 1) {
            nextColIdx += colspanInfo.count - 1;
        }
        if (lastCellInRow || nextColIdx === totalColumnCount) {
            rowIdx += 1;
            nextColIdx = 0;
        }
        var offset = map.getCellInfo(rowIdx, nextColIdx).offset;
        return offset + 2;
    }
    return null;
}
function getLeftCellOffset(_a, map) {
    var rowIdx = _a[0], colIdx = _a[1];
    var totalColumnCount = map.totalColumnCount;
    var firstCellInRow = colIdx === 0;
    var firstCellInTable = rowIdx === 0 && firstCellInRow;
    if (!firstCellInTable) {
        colIdx -= 1;
        if (firstCellInRow) {
            rowIdx -= 1;
            colIdx = totalColumnCount - 1;
        }
        var _b = map.getCellInfo(rowIdx, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;
        return offset + nodeSize - 2;
    }
    return null;
}
function getUpCellOffset(_a, map) {
    var rowIdx = _a[0], colIdx = _a[1];
    if (rowIdx > 0) {
        var _b = map.getCellInfo(rowIdx - 1, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;
        return offset + nodeSize - 2;
    }
    return null;
}
function getDownCellOffset(_a, map) {
    var rowIdx = _a[0], colIdx = _a[1];
    var totalRowCount = map.totalRowCount;
    if (rowIdx < totalRowCount - 1) {
        var nextRowIdx = rowIdx + 1;
        var rowspanInfo = map.getRowspanStartInfo(rowIdx, colIdx);
        if ((rowspanInfo === null || rowspanInfo === void 0 ? void 0 : rowspanInfo.count) > 1) {
            nextRowIdx += rowspanInfo.count - 1;
        }
        var offset = map.getCellInfo(nextRowIdx, colIdx).offset;
        return offset + 2;
    }
    return null;
}
function moveToCell(direction, tr, cellIndex, map) {
    var cellOffsetFn = cellOffsetFnMap[direction];
    var offset = cellOffsetFn(cellIndex, map);
    if (offset) {
        var dir = direction === Direction.RIGHT || direction === Direction.DOWN ? 1 : -1;
        return tr.setSelection(external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Selection.near(tr.doc.resolve(offset), dir));
    }
    return null;
}
function canSelectTableNode(direction, map, _a) {
    var rowIdx = _a[0], colIdx = _a[1];
    if (direction === Direction.UP || direction === Direction.DOWN) {
        return false;
    }
    var tableStartOffset = map.tableStartOffset, tableEndOffset = map.tableEndOffset;
    var _b = map.getCellInfo(rowIdx, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;
    var pos = direction === Direction.LEFT ? tableStartOffset : tableEndOffset;
    var curPos = direction === Direction.LEFT ? offset - 2 : offset + nodeSize + 3;
    return pos === curPos;
}
function selectNode(tr, pos, depth) {
    var tablePos = tr.doc.resolve(pos.before(depth - 3));
    return tr.setSelection(new external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.NodeSelection(tablePos));
}

;// CONCATENATED MODULE: ./src/wysiwyg/nodes/table.ts








// eslint-disable-next-line no-shadow
var Direction;
(function (Direction) {
    Direction["LEFT"] = "left";
    Direction["RIGHT"] = "right";
    Direction["UP"] = "up";
    Direction["DOWN"] = "down";
})(Direction || (Direction = {}));
function getTargetRowInfo(direction, map, selectionInfo) {
    var targetRowIdx;
    var insertColIdx;
    var nodeSize;
    if (direction === Direction.UP) {
        targetRowIdx = selectionInfo.startRowIdx;
        insertColIdx = 0;
        nodeSize = -1;
    }
    else {
        targetRowIdx = selectionInfo.endRowIdx;
        insertColIdx = map.totalColumnCount - 1;
        nodeSize = map.getCellInfo(targetRowIdx, insertColIdx).nodeSize + 1;
    }
    return { targetRowIdx: targetRowIdx, insertColIdx: insertColIdx, nodeSize: nodeSize };
}
function getRowRanges(map, rowIdx, totalColumnCount) {
    var startOffset = map.getCellInfo(rowIdx, 0).offset;
    var _a = map.getCellInfo(rowIdx, totalColumnCount - 1), offset = _a.offset, nodeSize = _a.nodeSize;
    return { from: startOffset, to: offset + nodeSize };
}
var table_Table = /** @class */ (function (_super) {
    __extends(Table, _super);
    function Table() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Table.prototype, "name", {
        get: function () {
            return 'table';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Table.prototype, "schema", {
        get: function () {
            return {
                content: 'tableHead{1} tableBody{1}',
                group: 'block',
                attrs: __assign({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
                parseDOM: [createDOMInfoParsedRawHTML('table')],
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    return ['table', getCustomAttrs(attrs), 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    Table.prototype.addTable = function () {
        return function (payload) {
            if (payload === void 0) { payload = { rowCount: 2, columnCount: 1, data: [] }; }
            return function (state, dispatch) {
                var rowCount = payload.rowCount, columnCount = payload.columnCount, data = payload.data;
                var schema = state.schema, selection = state.selection, tr = state.tr;
                var from = selection.from, to = selection.to, $from = selection.$from;
                var collapsed = from === to;
                if (collapsed && !isInTableNode($from)) {
                    var _a = schema.nodes, tableHead = _a.tableHead, tableBody = _a.tableBody;
                    var theadData = data === null || data === void 0 ? void 0 : data.slice(0, columnCount);
                    var tbodyData = data === null || data === void 0 ? void 0 : data.slice(columnCount, data.length);
                    var tableHeadRow = createTableHeadRow(columnCount, schema, theadData);
                    var tableBodyRows = createTableBodyRows(rowCount - 1, columnCount, schema, tbodyData);
                    var table = schema.nodes.table.create(null, [
                        tableHead.create(null, tableHeadRow),
                        tableBody.create(null, tableBodyRows),
                    ]);
                    dispatch(tr.replaceSelectionWith(table));
                    return true;
                }
                return false;
            };
        };
    };
    Table.prototype.removeTable = function () {
        return function () { return function (state, dispatch) {
            var selection = state.selection, tr = state.tr;
            var map = TableOffsetMap.create(selection.$anchor);
            if (map) {
                var tableStartOffset = map.tableStartOffset, tableEndOffset = map.tableEndOffset;
                var startOffset = tableStartOffset - 1;
                var cursorPos = createTextSelection(tr.delete(startOffset, tableEndOffset), startOffset);
                dispatch(tr.setSelection(cursorPos));
                return true;
            }
            return false;
        }; };
    };
    Table.prototype.addColumn = function (direction) {
        return function () { return function (state, dispatch) {
            var selection = state.selection, tr = state.tr, schema = state.schema;
            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;
            if (anchor && head) {
                var map = TableOffsetMap.create(anchor);
                var selectionInfo = map.getRectOffsets(anchor, head);
                var targetColIdx = direction === Direction.LEFT ? selectionInfo.startColIdx : selectionInfo.endColIdx + 1;
                var columnCount = getRowAndColumnCount(selectionInfo).columnCount;
                var totalRowCount = map.totalRowCount;
                for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {
                    var cells = createDummyCells(columnCount, rowIdx, schema);
                    tr.insert(tr.mapping.map(map.posAt(rowIdx, targetColIdx)), cells);
                }
                dispatch(tr);
                return true;
            }
            return false;
        }; };
    };
    Table.prototype.removeColumn = function () {
        return function () { return function (state, dispatch) {
            var selection = state.selection, tr = state.tr;
            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;
            if (anchor && head) {
                var map = TableOffsetMap.create(anchor);
                var selectionInfo = map.getRectOffsets(anchor, head);
                var totalColumnCount = map.totalColumnCount, totalRowCount = map.totalRowCount;
                var columnCount = getRowAndColumnCount(selectionInfo).columnCount;
                var selectedAllColumn = columnCount === totalColumnCount;
                if (selectedAllColumn) {
                    return false;
                }
                var startColIdx = selectionInfo.startColIdx, endColIdx = selectionInfo.endColIdx;
                var mapStart = tr.mapping.maps.length;
                for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {
                    for (var colIdx = endColIdx; colIdx >= startColIdx; colIdx -= 1) {
                        var _b = map.getCellInfo(rowIdx, colIdx), offset = _b.offset, nodeSize = _b.nodeSize;
                        var from = tr.mapping.slice(mapStart).map(offset);
                        var to = from + nodeSize;
                        tr.delete(from, to);
                    }
                }
                dispatch(tr);
                return true;
            }
            return false;
        }; };
    };
    Table.prototype.addRow = function (direction) {
        return function () { return function (state, dispatch) {
            var selection = state.selection, schema = state.schema, tr = state.tr;
            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;
            if (anchor && head) {
                var map = TableOffsetMap.create(anchor);
                var totalColumnCount = map.totalColumnCount;
                var selectionInfo = map.getRectOffsets(anchor, head);
                var rowCount = getRowAndColumnCount(selectionInfo).rowCount;
                var _b = getTargetRowInfo(direction, map, selectionInfo), targetRowIdx = _b.targetRowIdx, insertColIdx = _b.insertColIdx, nodeSize = _b.nodeSize;
                var selectedThead = targetRowIdx === 0;
                if (!selectedThead) {
                    var rows = [];
                    var from = tr.mapping.map(map.posAt(targetRowIdx, insertColIdx)) + nodeSize;
                    var cells = [];
                    for (var colIdx = 0; colIdx < totalColumnCount; colIdx += 1) {
                        cells = cells.concat(createDummyCells(1, targetRowIdx, schema));
                    }
                    for (var i = 0; i < rowCount; i += 1) {
                        rows.push(schema.nodes.tableRow.create(null, cells));
                    }
                    dispatch(tr.insert(from, rows));
                    return true;
                }
            }
            return false;
        }; };
    };
    Table.prototype.removeRow = function () {
        return function () { return function (state, dispatch) {
            var selection = state.selection, tr = state.tr;
            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;
            if (anchor && head) {
                var map = TableOffsetMap.create(anchor);
                var totalRowCount = map.totalRowCount, totalColumnCount = map.totalColumnCount;
                var selectionInfo = map.getRectOffsets(anchor, head);
                var rowCount = getRowAndColumnCount(selectionInfo).rowCount;
                var startRowIdx = selectionInfo.startRowIdx, endRowIdx = selectionInfo.endRowIdx;
                var selectedThead = startRowIdx === 0;
                var selectedAllTbodyRow = rowCount === totalRowCount - 1;
                if (selectedAllTbodyRow || selectedThead) {
                    return false;
                }
                for (var rowIdx = endRowIdx; rowIdx >= startRowIdx; rowIdx -= 1) {
                    var _b = getRowRanges(map, rowIdx, totalColumnCount), from = _b.from, to = _b.to;
                    // delete table row
                    tr.delete(from - 1, to + 1);
                }
                dispatch(tr);
                return true;
            }
            return false;
        }; };
    };
    Table.prototype.alignColumn = function () {
        return function (payload) {
            if (payload === void 0) { payload = { align: 'center' }; }
            return function (state, dispatch) {
                var align = payload.align;
                var selection = state.selection, tr = state.tr;
                var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;
                if (anchor && head) {
                    var map = TableOffsetMap.create(anchor);
                    var totalRowCount = map.totalRowCount;
                    var selectionInfo = map.getRectOffsets(anchor, head);
                    var startColIdx = selectionInfo.startColIdx, endColIdx = selectionInfo.endColIdx;
                    for (var rowIdx = 0; rowIdx < totalRowCount; rowIdx += 1) {
                        for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {
                            if (!map.extendedRowspan(rowIdx, colIdx) && !map.extendedColspan(rowIdx, colIdx)) {
                                var _b = map.getNodeAndPos(rowIdx, colIdx), node = _b.node, pos = _b.pos;
                                var attrs = setAttrs(node, { align: align });
                                tr.setNodeMarkup(pos, null, attrs);
                            }
                        }
                    }
                    dispatch(tr);
                    return true;
                }
                return false;
            };
        };
    };
    Table.prototype.moveToCell = function (direction) {
        return function (state, dispatch) {
            var selection = state.selection, tr = state.tr, schema = state.schema;
            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;
            if (anchor && head) {
                var map = TableOffsetMap.create(anchor);
                var cellIndex = map.getCellIndex(anchor);
                var newTr = void 0;
                if (canBeOutOfTable(direction, map, cellIndex)) {
                    // When there is no content before or after the table,
                    // an empty line('paragraph') is created by pressing the arrow keys.
                    newTr = addParagraphAfterTable(tr, map, schema);
                }
                else {
                    newTr = moveToCell(direction, tr, cellIndex, map);
                }
                if (newTr) {
                    dispatch(newTr);
                    return true;
                }
            }
            return false;
        };
    };
    Table.prototype.moveInCell = function (direction) {
        var _this = this;
        return function (state, dispatch) {
            var selection = state.selection, tr = state.tr, doc = state.doc, schema = state.schema;
            var $from = selection.$from;
            var view = _this.context.view;
            if (!view.endOfTextblock(direction)) {
                return false;
            }
            var cell = findNodeBy($from, function (_a) {
                var type = _a.type;
                return type.name === 'tableHeadCell' || type.name === 'tableBodyCell';
            });
            if (cell) {
                var para = findNodeBy($from, function (_a) {
                    var type = _a.type;
                    return type.name === 'paragraph';
                });
                var cellDepth = cell.depth;
                if (para && canMoveBetweenCells(direction, [cellDepth, para.depth], $from, doc)) {
                    var anchor = getResolvedSelection(selection).anchor;
                    var map = TableOffsetMap.create(anchor);
                    var cellIndex = map.getCellIndex(anchor);
                    var newTr = void 0;
                    if (canSelectTableNode(direction, map, cellIndex)) {
                        // When the cursor position is at the end of the cell,
                        // the table is selected when the left / right arrow keys are pressed.
                        newTr = selectNode(tr, $from, cellDepth);
                    }
                    else if (canBeOutOfTable(direction, map, cellIndex)) {
                        // When there is no content before or after the table,
                        // an empty line('paragraph') is created by pressing the arrow keys.
                        if (direction === Direction.UP) {
                            newTr = addParagraphBeforeTable(tr, map, schema);
                        }
                        else if (direction === Direction.DOWN) {
                            newTr = addParagraphAfterTable(tr, map, schema);
                        }
                    }
                    else {
                        newTr = moveToCell(direction, tr, cellIndex, map);
                    }
                    if (newTr) {
                        dispatch(newTr);
                        return true;
                    }
                }
            }
            return false;
        };
    };
    Table.prototype.deleteCells = function () {
        return function (state, dispatch) {
            var schema = state.schema, selection = state.selection, tr = state.tr;
            var _a = getResolvedSelection(selection), anchor = _a.anchor, head = _a.head;
            var textSelection = selection instanceof external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.TextSelection;
            if (anchor && head && !textSelection) {
                var map = TableOffsetMap.create(anchor);
                var _b = map.getRectOffsets(anchor, head), startRowIdx = _b.startRowIdx, startColIdx = _b.startColIdx, endRowIdx = _b.endRowIdx, endColIdx = _b.endColIdx;
                for (var rowIdx = startRowIdx; rowIdx <= endRowIdx; rowIdx += 1) {
                    for (var colIdx = startColIdx; colIdx <= endColIdx; colIdx += 1) {
                        if (!map.extendedRowspan(rowIdx, colIdx) && !map.extendedColspan(rowIdx, colIdx)) {
                            var _c = map.getNodeAndPos(rowIdx, colIdx), node = _c.node, pos = _c.pos;
                            var cells = createDummyCells(1, rowIdx, schema, node.attrs);
                            tr.replaceWith(tr.mapping.map(pos), tr.mapping.map(pos + node.nodeSize), cells);
                        }
                    }
                }
                dispatch(tr);
                return true;
            }
            return false;
        };
    };
    Table.prototype.exitTable = function () {
        return function (state, dispatch) {
            var selection = state.selection, tr = state.tr, schema = state.schema;
            var $from = selection.$from;
            var cell = findNodeBy($from, function (_a) {
                var type = _a.type;
                return type.name === 'tableHeadCell' || type.name === 'tableBodyCell';
            });
            if (cell) {
                var para = findNodeBy($from, function (_a) {
                    var type = _a.type;
                    return type.name === 'paragraph';
                });
                if (para) {
                    var anchor = getResolvedSelection(selection).anchor;
                    var map = TableOffsetMap.create(anchor);
                    dispatch(addParagraphAfterTable(tr, map, schema, true));
                    return true;
                }
            }
            return false;
        };
    };
    Table.prototype.commands = function () {
        return {
            addTable: this.addTable(),
            removeTable: this.removeTable(),
            addColumnToLeft: this.addColumn(Direction.LEFT),
            addColumnToRight: this.addColumn(Direction.RIGHT),
            removeColumn: this.removeColumn(),
            addRowToUp: this.addRow(Direction.UP),
            addRowToDown: this.addRow(Direction.DOWN),
            removeRow: this.removeRow(),
            alignColumn: this.alignColumn(),
        };
    };
    Table.prototype.keymaps = function () {
        var deleteCellContent = this.deleteCells();
        return {
            Tab: this.moveToCell(Direction.RIGHT),
            'Shift-Tab': this.moveToCell(Direction.LEFT),
            ArrowUp: this.moveInCell(Direction.UP),
            ArrowDown: this.moveInCell(Direction.DOWN),
            ArrowLeft: this.moveInCell(Direction.LEFT),
            ArrowRight: this.moveInCell(Direction.RIGHT),
            Backspace: deleteCellContent,
            'Mod-Backspace': deleteCellContent,
            Delete: deleteCellContent,
            'Mod-Delete': deleteCellContent,
            'Mod-Enter': this.exitTable(),
        };
    };
    return Table;
}(node));


;// CONCATENATED MODULE: ./src/wysiwyg/nodes/tableHead.ts



var TableHead = /** @class */ (function (_super) {
    __extends(TableHead, _super);
    function TableHead() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(TableHead.prototype, "name", {
        get: function () {
            return 'tableHead';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TableHead.prototype, "schema", {
        get: function () {
            return {
                content: 'tableRow{1}',
                attrs: __assign({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
                parseDOM: [createDOMInfoParsedRawHTML('thead')],
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    return ['thead', getCustomAttrs(attrs), 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    return TableHead;
}(node));


;// CONCATENATED MODULE: ./src/wysiwyg/nodes/tableBody.ts



var TableBody = /** @class */ (function (_super) {
    __extends(TableBody, _super);
    function TableBody() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(TableBody.prototype, "name", {
        get: function () {
            return 'tableBody';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TableBody.prototype, "schema", {
        get: function () {
            return {
                content: 'tableRow+',
                attrs: __assign({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
                parseDOM: [
                    {
                        tag: 'tbody',
                        getAttrs: function (dom) {
                            var rows = dom.querySelectorAll('tr');
                            var columns = rows[0].children.length;
                            var rawHTML = dom.getAttribute('data-raw-html');
                            if (!columns) {
                                return false;
                            }
                            return __assign({}, (rawHTML && { rawHTML: rawHTML }));
                        },
                    },
                ],
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    return ['tbody', getCustomAttrs(attrs), 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    return TableBody;
}(node));


;// CONCATENATED MODULE: ./src/wysiwyg/nodes/tableRow.ts



var TableRow = /** @class */ (function (_super) {
    __extends(TableRow, _super);
    function TableRow() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(TableRow.prototype, "name", {
        get: function () {
            return 'tableRow';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TableRow.prototype, "schema", {
        get: function () {
            return {
                content: '(tableHeadCell | tableBodyCell)*',
                attrs: __assign({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
                parseDOM: [
                    {
                        tag: 'tr',
                        getAttrs: function (dom) {
                            var columns = dom.children.length;
                            var rawHTML = dom.getAttribute('data-raw-html');
                            if (!columns) {
                                return false;
                            }
                            return __assign({}, (rawHTML && { rawHTML: rawHTML }));
                        },
                    },
                ],
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    return ['tr', getCustomAttrs(attrs), 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    return TableRow;
}(node));


;// CONCATENATED MODULE: ./src/wysiwyg/nodes/tableHeadCell.ts



var TableHeadCell = /** @class */ (function (_super) {
    __extends(TableHeadCell, _super);
    function TableHeadCell() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(TableHeadCell.prototype, "name", {
        get: function () {
            return 'tableHeadCell';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TableHeadCell.prototype, "schema", {
        get: function () {
            return {
                content: 'paragraph+',
                attrs: __assign({ align: { default: null }, className: { default: null }, rawHTML: { default: null }, colspan: { default: null }, extended: { default: null } }, getDefaultCustomAttrs()),
                isolating: true,
                parseDOM: [createParsedCellDOM('th')],
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    var cellAttrs = createCellAttrs(attrs);
                    return ['th', __assign(__assign({}, cellAttrs), getCustomAttrs(attrs)), 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    return TableHeadCell;
}(node));


;// CONCATENATED MODULE: ./src/wysiwyg/nodes/tableBodyCell.ts



var TableBodyCell = /** @class */ (function (_super) {
    __extends(TableBodyCell, _super);
    function TableBodyCell() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(TableBodyCell.prototype, "name", {
        get: function () {
            return 'tableBodyCell';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TableBodyCell.prototype, "schema", {
        get: function () {
            return {
                content: '(paragraph | bulletList | orderedList)+',
                attrs: {
                    align: { default: null },
                    className: { default: null },
                    rawHTML: { default: null },
                    colspan: { default: null },
                    rowspan: { default: null },
                    extended: { default: null },
                },
                isolating: true,
                parseDOM: [createParsedCellDOM('td')],
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    var cellAttrs = createCellAttrs(attrs);
                    return ['td', cellAttrs, 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    return TableBodyCell;
}(node));


;// CONCATENATED MODULE: ./src/wysiwyg/nodes/image.ts





var Image = /** @class */ (function (_super) {
    __extends(Image, _super);
    function Image() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Image.prototype, "name", {
        get: function () {
            return 'image';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Image.prototype, "schema", {
        get: function () {
            return {
                inline: true,
                attrs: __assign({ imageUrl: { default: '' }, altText: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
                group: 'inline',
                selectable: false,
                parseDOM: [
                    {
                        tag: 'img[src]',
                        getAttrs: function (dom) {
                            var sanitizedDOM = sanitizeHTML(dom, { RETURN_DOM_FRAGMENT: true })
                                .firstChild;
                            var imageUrl = sanitizedDOM.getAttribute('src') || '';
                            var rawHTML = sanitizedDOM.getAttribute('data-raw-html');
                            var altText = sanitizedDOM.getAttribute('alt');
                            return __assign({ imageUrl: imageUrl,
                                altText: altText }, (rawHTML && { rawHTML: rawHTML }));
                        },
                    },
                ],
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    return [
                        attrs.rawHTML || 'img',
                        __assign(__assign({ src: escapeXml(attrs.imageUrl) }, (attrs.altText && { alt: attrs.altText })), getCustomAttrs(attrs)),
                    ];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    Image.prototype.addImage = function () {
        return function (payload) { return function (_a, dispatch) {
            var schema = _a.schema, tr = _a.tr;
            var _b = payload, imageUrl = _b.imageUrl, altText = _b.altText;
            if (!imageUrl) {
                return false;
            }
            var node = schema.nodes.image.createAndFill(__assign({ imageUrl: imageUrl }, (altText && { altText: altText })));
            dispatch(tr.replaceSelectionWith(node).scrollIntoView());
            return true;
        }; };
    };
    Image.prototype.commands = function () {
        return {
            addImage: this.addImage(),
        };
    };
    return Image;
}(node));


;// CONCATENATED MODULE: ./src/wysiwyg/nodes/thematicBreak.ts



var ROOT_BLOCK_DEPTH = 1;
var thematicBreak_ThematicBreak = /** @class */ (function (_super) {
    __extends(ThematicBreak, _super);
    function ThematicBreak() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ThematicBreak.prototype, "name", {
        get: function () {
            return 'thematicBreak';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ThematicBreak.prototype, "schema", {
        get: function () {
            return {
                attrs: __assign({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
                group: 'block',
                parseDOM: [{ tag: 'hr' }],
                selectable: false,
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    return ['div', getCustomAttrs(attrs), [attrs.rawHTML || 'hr']];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    ThematicBreak.prototype.hr = function () {
        var _this = this;
        return function () { return function (state, dispatch) {
            var _a;
            var _b = state.selection, $from = _b.$from, $to = _b.$to;
            if ($from === $to) {
                var doc = state.doc;
                var _c = state.schema.nodes, thematicBreak = _c.thematicBreak, paragraph = _c.paragraph;
                var nodes = [thematicBreak.create()];
                var rootBlock = $from.node(ROOT_BLOCK_DEPTH);
                var lastBlock = doc.child(doc.childCount - 1) === rootBlock;
                var blockEnd = doc.resolve($from.after(ROOT_BLOCK_DEPTH));
                var nextHr = ((_a = $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.type.name) === _this.name;
                if (lastBlock || nextHr) {
                    nodes.push(paragraph.create());
                }
                dispatch(state.tr.insert(blockEnd.pos, nodes).scrollIntoView());
                return true;
            }
            return false;
        }; };
    };
    ThematicBreak.prototype.commands = function () {
        return { hr: this.hr() };
    };
    ThematicBreak.prototype.keymaps = function () {
        var hrCommand = this.hr()();
        return {
            'Mod-l': hrCommand,
            'Mod-L': hrCommand,
        };
    };
    return ThematicBreak;
}(node));


;// CONCATENATED MODULE: ./src/wysiwyg/marks/strong.ts




var strong_Strong = /** @class */ (function (_super) {
    __extends(Strong, _super);
    function Strong() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Strong.prototype, "name", {
        get: function () {
            return 'strong';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Strong.prototype, "schema", {
        get: function () {
            var parseDOM = ['b', 'strong'].map(function (tag) {
                return {
                    tag: tag,
                    getAttrs: function (dom) {
                        var rawHTML = dom.getAttribute('data-raw-html');
                        return __assign({}, (rawHTML && { rawHTML: rawHTML }));
                    },
                };
            });
            return {
                attrs: __assign({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
                parseDOM: parseDOM,
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    return [attrs.rawHTML || 'strong', getCustomAttrs(attrs)];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    Strong.prototype.bold = function () {
        return function () { return function (state, dispatch) { return (0,external_commonjs_prosemirror_commands_commonjs2_prosemirror_commands_amd_prosemirror_commands_.toggleMark)(state.schema.marks.strong)(state, dispatch); }; };
    };
    Strong.prototype.commands = function () {
        return { bold: this.bold() };
    };
    Strong.prototype.keymaps = function () {
        var boldCommand = this.bold()();
        return {
            'Mod-b': boldCommand,
            'Mod-B': boldCommand,
        };
    };
    return Strong;
}(mark));


;// CONCATENATED MODULE: ./src/wysiwyg/marks/emph.ts




var emph_Emph = /** @class */ (function (_super) {
    __extends(Emph, _super);
    function Emph() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Emph.prototype, "name", {
        get: function () {
            return 'emph';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Emph.prototype, "schema", {
        get: function () {
            var parseDOM = ['i', 'em'].map(function (tag) {
                return {
                    tag: tag,
                    getAttrs: function (dom) {
                        var rawHTML = dom.getAttribute('data-raw-html');
                        return __assign({}, (rawHTML && { rawHTML: rawHTML }));
                    },
                };
            });
            return {
                attrs: __assign({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
                parseDOM: parseDOM,
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    return [attrs.rawHTML || 'em', getCustomAttrs(attrs)];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    Emph.prototype.italic = function () {
        return function () { return function (state, dispatch) { return (0,external_commonjs_prosemirror_commands_commonjs2_prosemirror_commands_amd_prosemirror_commands_.toggleMark)(state.schema.marks.emph)(state, dispatch); }; };
    };
    Emph.prototype.commands = function () {
        return { italic: this.italic() };
    };
    Emph.prototype.keymaps = function () {
        var italicCommand = this.italic()();
        return {
            'Mod-i': italicCommand,
            'Mod-I': italicCommand,
        };
    };
    return Emph;
}(mark));


;// CONCATENATED MODULE: ./src/wysiwyg/marks/strike.ts




var strike_Strike = /** @class */ (function (_super) {
    __extends(Strike, _super);
    function Strike() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Strike.prototype, "name", {
        get: function () {
            return 'strike';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Strike.prototype, "schema", {
        get: function () {
            var parseDOM = ['s', 'del'].map(function (tag) {
                return {
                    tag: tag,
                    getAttrs: function (dom) {
                        var rawHTML = dom.getAttribute('data-raw-html');
                        return __assign({}, (rawHTML && { rawHTML: rawHTML }));
                    },
                };
            });
            return {
                attrs: __assign({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
                parseDOM: parseDOM,
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    return [attrs.rawHTML || 'del', getCustomAttrs(attrs)];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    Strike.prototype.commands = function () {
        return function () { return function (state, dispatch) { return (0,external_commonjs_prosemirror_commands_commonjs2_prosemirror_commands_amd_prosemirror_commands_.toggleMark)(state.schema.marks.strike)(state, dispatch); }; };
    };
    Strike.prototype.keymaps = function () {
        var strikeCommand = this.commands()();
        return {
            'Mod-s': strikeCommand,
            'Mod-S': strikeCommand,
        };
    };
    return Strike;
}(mark));


;// CONCATENATED MODULE: ./src/wysiwyg/marks/link.ts







var link_Link = /** @class */ (function (_super) {
    __extends(Link, _super);
    function Link(linkAttributes) {
        var _this = _super.call(this) || this;
        _this.linkAttributes = linkAttributes;
        return _this;
    }
    Object.defineProperty(Link.prototype, "name", {
        get: function () {
            return 'link';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Link.prototype, "schema", {
        get: function () {
            var _this = this;
            return {
                attrs: __assign({ linkUrl: { default: '' }, title: { default: null }, rawHTML: { default: null } }, getDefaultCustomAttrs()),
                inclusive: false,
                parseDOM: [
                    {
                        tag: 'a[href]',
                        getAttrs: function (dom) {
                            var sanitizedDOM = sanitizeHTML(dom, { RETURN_DOM_FRAGMENT: true })
                                .firstChild;
                            var href = sanitizedDOM.getAttribute('href') || '';
                            var title = sanitizedDOM.getAttribute('title') || '';
                            var rawHTML = sanitizedDOM.getAttribute('data-raw-html');
                            return __assign({ linkUrl: href, title: title }, (rawHTML && { rawHTML: rawHTML }));
                        },
                    },
                ],
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    return [
                        attrs.rawHTML || 'a',
                        __assign(__assign({ href: escapeXml(attrs.linkUrl) }, _this.linkAttributes), getCustomAttrs(attrs)),
                    ];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    Link.prototype.addLink = function () {
        return function (payload) { return function (state, dispatch) {
            var _a = payload, linkUrl = _a.linkUrl, _b = _a.linkText, linkText = _b === void 0 ? '' : _b;
            var schema = state.schema, tr = state.tr, selection = state.selection;
            var empty = selection.empty, from = selection.from, to = selection.to;
            if (from && to && linkUrl) {
                var attrs = { linkUrl: linkUrl };
                var mark = schema.mark('link', attrs);
                if (empty && linkText) {
                    var node = createTextNode(schema, linkText, mark);
                    tr.replaceRangeWith(from, to, node);
                }
                else {
                    tr.addMark(from, to, mark);
                }
                dispatch(tr.scrollIntoView());
                return true;
            }
            return false;
        }; };
    };
    Link.prototype.toggleLink = function () {
        return function (payload) { return function (state, dispatch) {
            return (0,external_commonjs_prosemirror_commands_commonjs2_prosemirror_commands_amd_prosemirror_commands_.toggleMark)(state.schema.marks.link, payload)(state, dispatch);
        }; };
    };
    Link.prototype.commands = function () {
        return {
            addLink: this.addLink(),
            toggleLink: this.toggleLink(),
        };
    };
    return Link;
}(mark));


;// CONCATENATED MODULE: ./src/wysiwyg/marks/code.ts




var code_Code = /** @class */ (function (_super) {
    __extends(Code, _super);
    function Code() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(Code.prototype, "name", {
        get: function () {
            return 'code';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Code.prototype, "schema", {
        get: function () {
            return {
                attrs: __assign({ rawHTML: { default: null } }, getDefaultCustomAttrs()),
                parseDOM: [
                    {
                        tag: 'code',
                        getAttrs: function (dom) {
                            var rawHTML = dom.getAttribute('data-raw-html');
                            return __assign({}, (rawHTML && { rawHTML: rawHTML }));
                        },
                    },
                ],
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    return [attrs.rawHTML || 'code', getCustomAttrs(attrs)];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    Code.prototype.commands = function () {
        return function () { return function (state, dispatch) { return (0,external_commonjs_prosemirror_commands_commonjs2_prosemirror_commands_amd_prosemirror_commands_.toggleMark)(state.schema.marks.code)(state, dispatch); }; };
    };
    Code.prototype.keymaps = function () {
        var codeCommand = this.commands()();
        return {
            'Shift-Mod-c': codeCommand,
            'Shift-Mod-C': codeCommand,
        };
    };
    return Code;
}(mark));


;// CONCATENATED MODULE: ./src/wysiwyg/nodes/customBlock.ts



var customBlock_CustomBlock = /** @class */ (function (_super) {
    __extends(CustomBlock, _super);
    function CustomBlock() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(CustomBlock.prototype, "name", {
        get: function () {
            return 'customBlock';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CustomBlock.prototype, "schema", {
        get: function () {
            return {
                content: 'text*',
                group: 'block',
                attrs: {
                    info: { default: null },
                },
                atom: true,
                code: true,
                defining: true,
                parseDOM: [
                    {
                        tag: 'div[data-custom-info]',
                        getAttrs: function (dom) {
                            var info = dom.getAttribute('data-custom-info');
                            return { info: info };
                        },
                    },
                ],
                toDOM: function (_a) {
                    var attrs = _a.attrs;
                    return ['div', { 'data-custom-info': attrs.info || null }, 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    CustomBlock.prototype.commands = function () {
        return function (payload) { return function (state, dispatch) {
            return (payload === null || payload === void 0 ? void 0 : payload.info)
                ? (0,external_commonjs_prosemirror_commands_commonjs2_prosemirror_commands_amd_prosemirror_commands_.setBlockType)(state.schema.nodes.customBlock, payload)(state, dispatch)
                : false;
        }; };
    };
    return CustomBlock;
}(node));


;// CONCATENATED MODULE: ./src/wysiwyg/nodes/frontMatter.ts



var FrontMatter = /** @class */ (function (_super) {
    __extends(FrontMatter, _super);
    function FrontMatter() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(FrontMatter.prototype, "name", {
        get: function () {
            return 'frontMatter';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(FrontMatter.prototype, "schema", {
        get: function () {
            return {
                content: 'text*',
                group: 'block',
                code: true,
                defining: true,
                parseDOM: [
                    {
                        preserveWhitespace: 'full',
                        tag: 'div[data-front-matter]',
                    },
                ],
                toDOM: function () {
                    return ['div', { 'data-front-matter': 'true' }, 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    FrontMatter.prototype.commands = function () {
        return function () { return function (state, dispatch, view) {
            var $from = state.selection.$from;
            if (view.endOfTextblock('down') && $from.node().type.name === 'frontMatter') {
                return (0,external_commonjs_prosemirror_commands_commonjs2_prosemirror_commands_amd_prosemirror_commands_.exitCode)(state, dispatch);
            }
            return false;
        }; };
    };
    FrontMatter.prototype.keymaps = function () {
        return {
            Enter: this.commands()(),
        };
    };
    return FrontMatter;
}(node));


;// CONCATENATED MODULE: ./src/wysiwyg/nodes/htmlComment.ts



var HTMLComment = /** @class */ (function (_super) {
    __extends(HTMLComment, _super);
    function HTMLComment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(HTMLComment.prototype, "name", {
        get: function () {
            return 'htmlComment';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(HTMLComment.prototype, "schema", {
        get: function () {
            return {
                content: 'text*',
                group: 'block',
                code: true,
                defining: true,
                parseDOM: [{ preserveWhitespace: 'full', tag: 'div[data-html-comment]' }],
                toDOM: function () {
                    return ['div', { 'data-html-comment': 'true' }, 0];
                },
            };
        },
        enumerable: false,
        configurable: true
    });
    HTMLComment.prototype.commands = function () {
        return function () { return function (state, dispatch, view) {
            var $from = state.selection.$from;
            if (view.endOfTextblock('down') && $from.node().type.name === 'htmlComment') {
                return (0,external_commonjs_prosemirror_commands_commonjs2_prosemirror_commands_amd_prosemirror_commands_.exitCode)(state, dispatch);
            }
            return false;
        }; };
    };
    HTMLComment.prototype.keymaps = function () {
        return {
            Enter: this.commands()(),
        };
    };
    return HTMLComment;
}(node));


;// CONCATENATED MODULE: ./src/wysiwyg/specCreator.ts



























function createSpecs(linkAttributes) {
    return new specManager([
        new doc_Doc(),
        new paragraph_Paragraph(),
        new text_Text(),
        new heading_Heading(),
        new codeBlock_CodeBlock(),
        new BulletList(),
        new OrderedList(),
        new listItem_ListItem(),
        new blockQuote_BlockQuote(),
        new table_Table(),
        new TableHead(),
        new TableBody(),
        new TableRow(),
        new TableHeadCell(),
        new TableBodyCell(),
        new Image(),
        new thematicBreak_ThematicBreak(),
        new strong_Strong(),
        new emph_Emph(),
        new strike_Strike(),
        new link_Link(linkAttributes),
        new code_Code(),
        new customBlock_CustomBlock(),
        new FrontMatter(),
        new Widget(),
        new HTMLComment(),
    ]);
}

;// CONCATENATED MODULE: ./src/wysiwyg/wwEditor.ts
























var CONTENTS_CLASS_NAME = cls('contents');
var WysiwygEditor = /** @class */ (function (_super) {
    __extends(WysiwygEditor, _super);
    function WysiwygEditor(eventEmitter, options) {
        var _this = _super.call(this, eventEmitter) || this;
        var toDOMAdaptor = options.toDOMAdaptor, _a = options.htmlSchemaMap, htmlSchemaMap = _a === void 0 ? {} : _a, _b = options.linkAttributes, linkAttributes = _b === void 0 ? {} : _b, _c = options.useCommandShortcut, useCommandShortcut = _c === void 0 ? true : _c, _d = options.wwPlugins, wwPlugins = _d === void 0 ? [] : _d, _e = options.wwNodeViews, wwNodeViews = _e === void 0 ? {} : _e;
        _this.editorType = 'wysiwyg';
        _this.el.classList.add('ww-mode');
        _this.toDOMAdaptor = toDOMAdaptor;
        _this.linkAttributes = linkAttributes;
        _this.extraPlugins = wwPlugins;
        _this.pluginNodeViews = wwNodeViews;
        _this.specs = _this.createSpecs();
        _this.schema = _this.createSchema(htmlSchemaMap);
        _this.context = _this.createContext();
        _this.keymaps = _this.createKeymaps(useCommandShortcut);
        _this.view = _this.createView();
        _this.commands = _this.createCommands();
        _this.specs.setContext(__assign(__assign({}, _this.context), { view: _this.view }));
        _this.initEvent();
        return _this;
    }
    WysiwygEditor.prototype.createSpecs = function () {
        return createSpecs(this.linkAttributes);
    };
    WysiwygEditor.prototype.createContext = function () {
        return {
            schema: this.schema,
            eventEmitter: this.eventEmitter,
        };
    };
    WysiwygEditor.prototype.createSchema = function (htmlSchemaMap) {
        return new external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Schema({
            nodes: __assign(__assign({}, this.specs.nodes), htmlSchemaMap.nodes),
            marks: __assign(__assign({}, this.specs.marks), htmlSchemaMap.marks),
        });
    };
    WysiwygEditor.prototype.createPlugins = function () {
        return __spreadArray([
            tableSelection(),
            tableContextMenu(this.eventEmitter),
            task(),
            toolbarStateHighlight(this.eventEmitter)
        ], this.createPluginProps()).concat(this.defaultPlugins);
    };
    WysiwygEditor.prototype.createPluginNodeViews = function () {
        var _a = this, eventEmitter = _a.eventEmitter, pluginNodeViews = _a.pluginNodeViews;
        var pluginNodeViewMap = {};
        if (pluginNodeViews) {
            Object.keys(pluginNodeViews).forEach(function (key) {
                pluginNodeViewMap[key] = function (node, view, getPos) {
                    return pluginNodeViews[key](node, view, getPos, eventEmitter);
                };
            });
        }
        return pluginNodeViewMap;
    };
    WysiwygEditor.prototype.createView = function () {
        var _this = this;
        var _a = this, toDOMAdaptor = _a.toDOMAdaptor, eventEmitter = _a.eventEmitter;
        return new external_commonjs_prosemirror_view_commonjs2_prosemirror_view_amd_prosemirror_view_.EditorView(this.el, {
            state: this.createState(),
            attributes: {
                class: CONTENTS_CLASS_NAME,
            },
            nodeViews: __assign({ customBlock: function (node, view, getPos) {
                    return new CustomBlockView(node, view, getPos, toDOMAdaptor);
                },
                image: function (node, view, getPos) {
                    return new ImageView(node, view, getPos, eventEmitter);
                },
                codeBlock: function (node, view, getPos) {
                    return new CodeBlockView(node, view, getPos, eventEmitter);
                }, widget: widgetNodeView }, this.createPluginNodeViews()),
            dispatchTransaction: function (tr) {
                var state = _this.view.state.applyTransaction(tr).state;
                _this.view.updateState(state);
                _this.emitChangeEvent(tr.scrollIntoView());
                _this.eventEmitter.emit('setFocusedNode', state.selection.$from.node(1));
            },
            transformPastedHTML: changePastedHTML,
            transformPasted: function (slice) {
                return changePastedSlice(slice, _this.schema, isInTableNode(_this.view.state.selection.$from));
            },
            handlePaste: function (view, _, slice) { return pasteToTable(view, slice); },
            handleKeyDown: function (_, ev) {
                _this.eventEmitter.emit('keydown', _this.editorType, ev);
                return false;
            },
            handleDOMEvents: {
                paste: function (_, ev) {
                    var clipboardData = ev.clipboardData || window.clipboardData;
                    var items = clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.items;
                    if (items) {
                        var containRtfItem = toArray_default()(items).some(function (item) { return item.kind === 'string' && item.type === 'text/rtf'; });
                        // if it contains rtf, it's most likely copy paste from office -> no image
                        if (!containRtfItem) {
                            var imageBlob = pasteImageOnly(items);
                            if (imageBlob) {
                                ev.preventDefault();
                                emitImageBlobHook(_this.eventEmitter, imageBlob, ev.type);
                            }
                        }
                    }
                    return false;
                },
                keyup: function (_, ev) {
                    _this.eventEmitter.emit('keyup', _this.editorType, ev);
                    return false;
                },
                scroll: function () {
                    _this.eventEmitter.emit('scroll', 'editor');
                    return true;
                },
            },
        });
    };
    WysiwygEditor.prototype.createCommands = function () {
        return this.specs.commands(this.view, getWwCommands());
    };
    WysiwygEditor.prototype.getHTML = function () {
        return removeProseMirrorHackNodes(this.view.dom.innerHTML);
    };
    WysiwygEditor.prototype.getModel = function () {
        return this.view.state.doc;
    };
    WysiwygEditor.prototype.getSelection = function () {
        var _a = this.view.state.selection, from = _a.from, to = _a.to;
        return [from, to];
    };
    WysiwygEditor.prototype.getSchema = function () {
        return this.view.state.schema;
    };
    WysiwygEditor.prototype.replaceSelection = function (text, start, end) {
        var _a = this.view.state, schema = _a.schema, tr = _a.tr;
        var lineTexts = text.split('\n');
        var paras = lineTexts.map(function (lineText) {
            return createParagraph(schema, createNodesWithWidget(lineText, schema));
        });
        var slice = new external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Slice(external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment.from(paras), 1, 1);
        var newTr = isNumber_default()(start) && isNumber_default()(end)
            ? tr.replaceRange(start, end, slice)
            : tr.replaceSelection(slice);
        this.view.dispatch(newTr);
        this.focus();
    };
    WysiwygEditor.prototype.deleteSelection = function (start, end) {
        var tr = this.view.state.tr;
        var newTr = isNumber_default()(start) && isNumber_default()(end) ? tr.deleteRange(start, end) : tr.deleteSelection();
        this.view.dispatch(newTr.scrollIntoView());
    };
    WysiwygEditor.prototype.getSelectedText = function (start, end) {
        var _a = this.view.state, doc = _a.doc, selection = _a.selection;
        var from = selection.from, to = selection.to;
        if (isNumber_default()(start) && isNumber_default()(end)) {
            from = start;
            to = end;
        }
        return doc.textBetween(from, to, '\n');
    };
    WysiwygEditor.prototype.setModel = function (newDoc, cursorToEnd) {
        if (cursorToEnd === void 0) { cursorToEnd = false; }
        var _a = this.view.state, tr = _a.tr, doc = _a.doc;
        this.view.dispatch(tr.replaceWith(0, doc.content.size, newDoc));
        if (cursorToEnd) {
            this.moveCursorToEnd(true);
        }
    };
    WysiwygEditor.prototype.setSelection = function (start, end) {
        if (end === void 0) { end = start; }
        var tr = this.view.state.tr;
        var selection = createTextSelection(tr, start, end);
        this.view.dispatch(tr.setSelection(selection).scrollIntoView());
    };
    WysiwygEditor.prototype.addWidget = function (node, style, pos) {
        var _a = this.view, dispatch = _a.dispatch, state = _a.state;
        dispatch(state.tr.setMeta('widget', { pos: pos !== null && pos !== void 0 ? pos : state.selection.to, node: node, style: style }));
    };
    WysiwygEditor.prototype.replaceWithWidget = function (start, end, text) {
        var _a = this.view.state, tr = _a.tr, schema = _a.schema;
        var nodes = createNodesWithWidget(text, schema);
        this.view.dispatch(tr.replaceWith(start, end, nodes));
    };
    WysiwygEditor.prototype.getRangeInfoOfNode = function (pos) {
        var _a = this.view.state, doc = _a.doc, selection = _a.selection;
        var $pos = pos ? doc.resolve(pos) : selection.$from;
        var marks = $pos.marks();
        var node = $pos.node();
        var start = $pos.start();
        var end = $pos.end();
        var type = node.type.name;
        if (marks.length || type === 'paragraph') {
            var mark_1 = marks[marks.length - 1];
            var maybeHasMark_1 = function (nodeMarks) {
                return nodeMarks.length ? common_includes(nodeMarks, mark_1) : true;
            };
            type = mark_1 ? mark_1.type.name : 'text';
            node.forEach(function (child, offset) {
                var isText = child.isText, nodeSize = child.nodeSize, nodeMarks = child.marks;
                var startOffset = $pos.pos - start;
                if (isText &&
                    offset <= startOffset &&
                    offset + nodeSize >= startOffset &&
                    maybeHasMark_1(nodeMarks)) {
                    start = start + offset;
                    end = start + nodeSize;
                }
            });
        }
        return { range: [start, end], type: type };
    };
    return WysiwygEditor;
}(base));
/* harmony default export */ var wwEditor = (WysiwygEditor);

// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isFalsy.js
var isFalsy = __nested_webpack_require_93901__(404);
var isFalsy_default = /*#__PURE__*/__nested_webpack_require_93901__.n(isFalsy);
;// CONCATENATED MODULE: ./src/event/eventEmitter.ts




var eventTypeList = [
    'afterPreviewRender',
    'updatePreview',
    'changeMode',
    'needChangeMode',
    'command',
    'changePreviewStyle',
    'changePreviewTabPreview',
    'changePreviewTabWrite',
    'scroll',
    'contextmenu',
    'show',
    'hide',
    'changeLanguage',
    'changeToolbarState',
    'toggleScrollSync',
    'mixinTableOffsetMapPrototype',
    'setFocusedNode',
    'removePopupWidget',
    'query',
    // provide event for user
    'openPopup',
    'closePopup',
    'addImageBlobHook',
    'beforePreviewRender',
    'beforeConvertWysiwygToMarkdown',
    'load',
    'loadUI',
    'change',
    'caretChange',
    'destroy',
    'focus',
    'blur',
    'keydown',
    'keyup',
];
/**
 * Class EventEmitter
 * @ignore
 */
var EventEmitter = /** @class */ (function () {
    function EventEmitter() {
        var _this = this;
        this.events = new utils_map();
        this.eventTypes = eventTypeList.reduce(function (types, type) {
            return __assign(__assign({}, types), { type: type });
        }, {});
        this.hold = false;
        eventTypeList.forEach(function (eventType) {
            _this.addEventType(eventType);
        });
    }
    /**
     * Listen event and bind event handler
     * @param {string} type Event type string
     * @param {function} handler Event handler
     */
    EventEmitter.prototype.listen = function (type, handler) {
        var typeInfo = this.getTypeInfo(type);
        var eventHandlers = this.events.get(typeInfo.type) || [];
        if (!this.hasEventType(typeInfo.type)) {
            throw new Error("There is no event type " + typeInfo.type);
        }
        if (typeInfo.namespace) {
            handler.namespace = typeInfo.namespace;
        }
        eventHandlers.push(handler);
        this.events.set(typeInfo.type, eventHandlers);
    };
    /**
     * Emit event
     * @param {string} eventName Event name to emit
     * @returns {Array}
     */
    EventEmitter.prototype.emit = function (type) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var typeInfo = this.getTypeInfo(type);
        var eventHandlers = this.events.get(typeInfo.type);
        var results = [];
        if (!this.hold && eventHandlers) {
            eventHandlers.forEach(function (handler) {
                var result = handler.apply(void 0, args);
                if (!isUndefined_default()(result)) {
                    results.push(result);
                }
            });
        }
        return results;
    };
    /**
     * Emit given event and return result
     * @param {string} eventName Event name to emit
     * @param {any} source Source to change
     * @returns {string}
     */
    EventEmitter.prototype.emitReduce = function (type, source) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var eventHandlers = this.events.get(type);
        if (!this.hold && eventHandlers) {
            eventHandlers.forEach(function (handler) {
                var result = handler.apply(void 0, __spreadArray([source], args));
                if (!isFalsy_default()(result)) {
                    source = result;
                }
            });
        }
        return source;
    };
    /**
     * Get event type and namespace
     * @param {string} type Event type name
     * @returns {{type: string, namespace: string}}
     * @private
     */
    EventEmitter.prototype.getTypeInfo = function (type) {
        var splited = type.split('.');
        return {
            type: splited[0],
            namespace: splited[1],
        };
    };
    /**
     * Check whether event type exists or not
     * @param {string} type Event type name
     * @returns {boolean}
     * @private
     */
    EventEmitter.prototype.hasEventType = function (type) {
        return !isUndefined_default()(this.eventTypes[this.getTypeInfo(type).type]);
    };
    /**
     * Add event type when given event not exists
     * @param {string} type Event type name
     */
    EventEmitter.prototype.addEventType = function (type) {
        if (this.hasEventType(type)) {
            throw new Error("There is already have event type " + type);
        }
        this.eventTypes[type] = type;
    };
    /**
     * Remove event handler from given event type
     * @param {string} eventType Event type name
     * @param {function} [handler] - registered event handler
     */
    EventEmitter.prototype.removeEventHandler = function (eventType, handler) {
        var _this = this;
        var _a = this.getTypeInfo(eventType), type = _a.type, namespace = _a.namespace;
        if (type && handler) {
            this.removeEventHandlerWithHandler(type, handler);
        }
        else if (type && !namespace) {
            this.events.delete(type);
        }
        else if (!type && namespace) {
            this.events.forEach(function (_, evtType) {
                _this.removeEventHandlerWithTypeInfo(evtType, namespace);
            });
        }
        else if (type && namespace) {
            this.removeEventHandlerWithTypeInfo(type, namespace);
        }
    };
    /**
     * Remove event handler with event handler
     * @param {string} type - event type name
     * @param {function} handler - event handler
     * @private
     */
    EventEmitter.prototype.removeEventHandlerWithHandler = function (type, handler) {
        var eventHandlers = this.events.get(type);
        if (eventHandlers) {
            var handlerIndex = eventHandlers.indexOf(handler);
            if (eventHandlers.indexOf(handler) >= 0) {
                eventHandlers.splice(handlerIndex, 1);
            }
        }
    };
    /**
     * Remove event handler with event type information
     * @param {string} type Event type name
     * @param {string} namespace Event namespace
     * @private
     */
    EventEmitter.prototype.removeEventHandlerWithTypeInfo = function (type, namespace) {
        var handlersToSurvive = [];
        var eventHandlers = this.events.get(type);
        if (!eventHandlers) {
            return;
        }
        eventHandlers.map(function (handler) {
            if (handler.namespace !== namespace) {
                handlersToSurvive.push(handler);
            }
            return null;
        });
        this.events.set(type, handlersToSurvive);
    };
    EventEmitter.prototype.getEvents = function () {
        return this.events;
    };
    EventEmitter.prototype.holdEventInvoke = function (fn) {
        this.hold = true;
        fn();
        this.hold = false;
    };
    return EventEmitter;
}());
/* harmony default export */ var eventEmitter = (EventEmitter);

;// CONCATENATED MODULE: ./src/commands/commandManager.ts
var CommandManager = /** @class */ (function () {
    function CommandManager(eventEmitter, mdCommands, wwCommands, getEditorType) {
        this.eventEmitter = eventEmitter;
        this.mdCommands = mdCommands;
        this.wwCommands = wwCommands;
        this.getEditorType = getEditorType;
        this.initEvent();
    }
    CommandManager.prototype.initEvent = function () {
        var _this = this;
        this.eventEmitter.listen('command', function (command, payload) {
            _this.exec(command, payload);
        });
    };
    CommandManager.prototype.addCommand = function (type, name, command) {
        if (type === 'markdown') {
            this.mdCommands[name] = command;
        }
        else {
            this.wwCommands[name] = command;
        }
    };
    CommandManager.prototype.deleteCommand = function (type, name) {
        if (type === 'markdown') {
            delete this.mdCommands[name];
        }
        else {
            delete this.wwCommands[name];
        }
    };
    CommandManager.prototype.exec = function (name, payload) {
        var type = this.getEditorType();
        if (type === 'markdown') {
            this.mdCommands[name](payload);
        }
        else {
            this.wwCommands[name](payload);
        }
    };
    return CommandManager;
}());
/* harmony default export */ var commandManager = (CommandManager);

;// CONCATENATED MODULE: ./src/convertors/toWysiwyg/htmlToWwConvertors.ts




function getTextWithoutTrailingNewline(text) {
    return text[text.length - 1] === '\n' ? text.slice(0, text.length - 1) : text;
}
function isCustomHTMLInlineNode(_a, node) {
    var schema = _a.schema;
    var html = node.literal;
    var matched = html.match(reHTMLTag);
    if (matched) {
        var openTagName = matched[1], closeTagName = matched[3];
        var typeName = (openTagName || closeTagName).toLowerCase();
        return node.type === 'htmlInline' && !!(schema.marks[typeName] || schema.nodes[typeName]);
    }
    return false;
}
function htmlToWwConvertors_isInlineNode(_a) {
    var type = _a.type;
    return common_includes(['text', 'strong', 'emph', 'strike', 'image', 'link', 'code'], type);
}
function isSoftbreak(mdNode) {
    return (mdNode === null || mdNode === void 0 ? void 0 : mdNode.type) === 'softbreak';
}
function htmlToWwConvertors_isListNode(_a) {
    var type = _a.type, literal = _a.literal;
    var matched = type === 'htmlInline' && literal.match(reHTMLTag);
    if (matched) {
        var openTagName = matched[1], closeTagName = matched[3];
        var tagName = openTagName || closeTagName;
        if (tagName) {
            return common_includes(['ul', 'ol', 'li'], tagName.toLowerCase());
        }
    }
    return false;
}
function getListItemAttrs(_a) {
    var literal = _a.literal;
    var task = /data-task/.test(literal);
    var checked = /data-task-checked/.test(literal);
    return { task: task, checked: checked };
}
function getMatchedAttributeValue(rawHTML) {
    var attrNames = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        attrNames[_i - 1] = arguments[_i];
    }
    var wrapper = document.createElement('div');
    wrapper.innerHTML = sanitizeHTML(rawHTML);
    var el = wrapper.firstChild;
    return attrNames.map(function (attrName) { return el.getAttribute(attrName) || ''; });
}
function createConvertors(convertors) {
    var convertorMap = {};
    Object.keys(convertors).forEach(function (key) {
        var tagNames = key.split(', ');
        tagNames.forEach(function (tagName) {
            var name = tagName.toLowerCase();
            convertorMap[name] = convertors[key];
        });
    });
    return convertorMap;
}
var convertors = {
    'b, strong': function (state, _, openTagName) {
        var strong = state.schema.marks.strong;
        if (openTagName) {
            state.openMark(strong.create({ rawHTML: openTagName }));
        }
        else {
            state.closeMark(strong);
        }
    },
    'i, em': function (state, _, openTagName) {
        var emph = state.schema.marks.emph;
        if (openTagName) {
            state.openMark(emph.create({ rawHTML: openTagName }));
        }
        else {
            state.closeMark(emph);
        }
    },
    's, del': function (state, _, openTagName) {
        var strike = state.schema.marks.strike;
        if (openTagName) {
            state.openMark(strike.create({ rawHTML: openTagName }));
        }
        else {
            state.closeMark(strike);
        }
    },
    code: function (state, _, openTagName) {
        var code = state.schema.marks.code;
        if (openTagName) {
            state.openMark(code.create({ rawHTML: openTagName }));
        }
        else {
            state.closeMark(code);
        }
    },
    a: function (state, node, openTagName) {
        var tag = node.literal;
        var link = state.schema.marks.link;
        if (openTagName) {
            var linkUrl = getMatchedAttributeValue(tag, 'href')[0];
            state.openMark(link.create({
                linkUrl: linkUrl,
                rawHTML: openTagName,
            }));
        }
        else {
            state.closeMark(link);
        }
    },
    img: function (state, node, openTagName) {
        var tag = node.literal;
        if (openTagName) {
            var _a = getMatchedAttributeValue(tag, 'src', 'alt'), imageUrl = _a[0], altText = _a[1];
            var image = state.schema.nodes.image;
            state.addNode(image, __assign({ rawHTML: openTagName, imageUrl: imageUrl }, (altText && { altText: altText })));
        }
    },
    hr: function (state, _, openTagName) {
        state.addNode(state.schema.nodes.thematicBreak, { rawHTML: openTagName });
    },
    br: function (state, node) {
        var paragraph = state.schema.nodes.paragraph;
        var parent = node.parent, prev = node.prev, next = node.next;
        if ((parent === null || parent === void 0 ? void 0 : parent.type) === 'paragraph') {
            // should open a paragraph node when line text has only <br> tag
            // ex) first line\n\n<br>\nfourth line
            if (isSoftbreak(prev)) {
                state.openNode(paragraph);
            }
            // should close a paragraph node when line text has only <br> tag
            // ex) first line\n\n<br>\nfourth line
            if (isSoftbreak(next)) {
                state.closeNode();
                // should close a paragraph node and open a paragraph node to separate between blocks
                // when <br> tag is in the middle of the paragraph
                // ex) first <br>line\nthird line
            }
            else if (next) {
                state.closeNode();
                state.openNode(paragraph);
            }
        }
        else if ((parent === null || parent === void 0 ? void 0 : parent.type) === 'tableCell') {
            if (prev && (htmlToWwConvertors_isInlineNode(prev) || isCustomHTMLInlineNode(state, prev))) {
                state.closeNode();
            }
            if (next && (htmlToWwConvertors_isInlineNode(next) || isCustomHTMLInlineNode(state, next))) {
                state.openNode(paragraph);
            }
        }
    },
    pre: function (state, node, openTagName) {
        var _a, _b;
        var container = document.createElement('div');
        container.innerHTML = node.literal;
        var literal = (_b = (_a = container.firstChild) === null || _a === void 0 ? void 0 : _a.firstChild) === null || _b === void 0 ? void 0 : _b.textContent;
        state.openNode(state.schema.nodes.codeBlock, { rawHTML: openTagName });
        state.addText(getTextWithoutTrailingNewline(literal));
        state.closeNode();
    },
    'ul, ol': function (state, node, openTagName) {
        // in the table cell, '<ul>', '<ol>' is parsed as 'htmlInline' node
        if (node.parent.type === 'tableCell') {
            var _a = state.schema.nodes, bulletList = _a.bulletList, orderedList = _a.orderedList, paragraph = _a.paragraph;
            var list = openTagName === 'ul' ? bulletList : orderedList;
            if (openTagName) {
                if (node.prev && !htmlToWwConvertors_isListNode(node.prev)) {
                    state.closeNode();
                }
                state.openNode(list, { rawHTML: openTagName });
            }
            else {
                state.closeNode();
                if (node.next && !htmlToWwConvertors_isListNode(node.next)) {
                    state.openNode(paragraph);
                }
            }
        }
    },
    li: function (state, node, openTagName) {
        var _a;
        // in the table cell, '<li>' is parsed as 'htmlInline' node
        if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === 'tableCell') {
            var _b = state.schema.nodes, listItem = _b.listItem, paragraph = _b.paragraph;
            if (openTagName) {
                var attrs = getListItemAttrs(node);
                if (node.prev && !htmlToWwConvertors_isListNode(node.prev)) {
                    state.closeNode();
                }
                state.openNode(listItem, __assign({ rawHTML: openTagName }, attrs));
                if (node.next && !htmlToWwConvertors_isListNode(node.next)) {
                    state.openNode(paragraph);
                }
            }
            else {
                if (node.prev && !htmlToWwConvertors_isListNode(node.prev)) {
                    state.closeNode();
                }
                state.closeNode();
            }
        }
    },
};
var htmlToWwConvertors = createConvertors(convertors);

;// CONCATENATED MODULE: ./src/convertors/toWysiwyg/toWwConvertors.ts










function isBRTag(node) {
    return node.type === 'htmlInline' && reBR.test(node.literal);
}
function addRawHTMLAttributeToDOM(parent) {
    toArray_default()(parent.childNodes).forEach(function (child) {
        if (isElemNode(child)) {
            var openTagName = child.nodeName.toLowerCase();
            child.setAttribute('data-raw-html', openTagName);
            if (child.childNodes) {
                addRawHTMLAttributeToDOM(child);
            }
        }
    });
}
var toWwConvertors = {
    text: function (state, node) {
        state.addText(node.literal || '');
    },
    paragraph: function (state, node, _a, customAttrs) {
        var _b;
        var entering = _a.entering;
        if (entering) {
            var paragraph = state.schema.nodes.paragraph;
            // The `\n\n` entered in markdown separates the paragraph.
            // When changing to wysiwyg, a newline is added between the two paragraphs.
            if (((_b = node.prev) === null || _b === void 0 ? void 0 : _b.type) === 'paragraph') {
                state.openNode(paragraph, customAttrs);
                state.closeNode();
            }
            state.openNode(paragraph, customAttrs);
        }
        else {
            state.closeNode();
        }
    },
    heading: function (state, node, _a, customAttrs) {
        var entering = _a.entering;
        if (entering) {
            var _b = node, level = _b.level, headingType = _b.headingType;
            state.openNode(state.schema.nodes.heading, __assign({ level: level, headingType: headingType }, customAttrs));
        }
        else {
            state.closeNode();
        }
    },
    codeBlock: function (state, node, customAttrs) {
        var codeBlock = state.schema.nodes.codeBlock;
        var _a = node, info = _a.info, literal = _a.literal;
        state.openNode(codeBlock, __assign({ language: info }, customAttrs));
        state.addText(getTextWithoutTrailingNewline(literal || ''));
        state.closeNode();
    },
    list: function (state, node, _a, customAttrs) {
        var entering = _a.entering;
        if (entering) {
            var _b = state.schema.nodes, bulletList = _b.bulletList, orderedList = _b.orderedList;
            var _c = node.listData, type = _c.type, start = _c.start;
            if (type === 'bullet') {
                state.openNode(bulletList, customAttrs);
            }
            else {
                state.openNode(orderedList, __assign({ order: start }, customAttrs));
            }
        }
        else {
            state.closeNode();
        }
    },
    item: function (state, node, _a, customAttrs) {
        var entering = _a.entering;
        var listItem = state.schema.nodes.listItem;
        var _b = node.listData, task = _b.task, checked = _b.checked;
        if (entering) {
            var attrs = __assign(__assign(__assign({}, (task && { task: task })), (checked && { checked: checked })), customAttrs);
            state.openNode(listItem, attrs);
        }
        else {
            state.closeNode();
        }
    },
    blockQuote: function (state, _, _a, customAttrs) {
        var entering = _a.entering;
        if (entering) {
            state.openNode(state.schema.nodes.blockQuote, customAttrs);
        }
        else {
            state.closeNode();
        }
    },
    image: function (state, node, _a, customAttrs) {
        var entering = _a.entering, skipChildren = _a.skipChildren;
        var image = state.schema.nodes.image;
        var _b = node, destination = _b.destination, firstChild = _b.firstChild;
        if (entering && skipChildren) {
            skipChildren();
        }
        state.addNode(image, __assign(__assign({ imageUrl: destination }, (firstChild && { altText: firstChild.literal })), customAttrs));
    },
    thematicBreak: function (state, node, _, customAttrs) {
        state.addNode(state.schema.nodes.thematicBreak, customAttrs);
    },
    strong: function (state, _, _a, customAttrs) {
        var entering = _a.entering;
        var strong = state.schema.marks.strong;
        if (entering) {
            state.openMark(strong.create(customAttrs));
        }
        else {
            state.closeMark(strong);
        }
    },
    emph: function (state, _, _a, customAttrs) {
        var entering = _a.entering;
        var emph = state.schema.marks.emph;
        if (entering) {
            state.openMark(emph.create(customAttrs));
        }
        else {
            state.closeMark(emph);
        }
    },
    link: function (state, node, _a, customAttrs) {
        var entering = _a.entering;
        var link = state.schema.marks.link;
        var _b = node, destination = _b.destination, title = _b.title;
        if (entering) {
            var attrs = __assign({ linkUrl: destination, title: title }, customAttrs);
            state.openMark(link.create(attrs));
        }
        else {
            state.closeMark(link);
        }
    },
    softbreak: function (state, node) {
        if (node.parent.type === 'paragraph') {
            var prev = node.prev, next = node.next;
            if (prev && !isBRTag(prev)) {
                state.closeNode();
            }
            if (next && !isBRTag(next)) {
                state.openNode(state.schema.nodes.paragraph);
            }
        }
    },
    // GFM specifications node
    table: function (state, _, _a, customAttrs) {
        var entering = _a.entering;
        if (entering) {
            state.openNode(state.schema.nodes.table, customAttrs);
        }
        else {
            state.closeNode();
        }
    },
    tableHead: function (state, _, _a, customAttrs) {
        var entering = _a.entering;
        if (entering) {
            state.openNode(state.schema.nodes.tableHead, customAttrs);
        }
        else {
            state.closeNode();
        }
    },
    tableBody: function (state, _, _a, customAttrs) {
        var entering = _a.entering;
        if (entering) {
            state.openNode(state.schema.nodes.tableBody, customAttrs);
        }
        else {
            state.closeNode();
        }
    },
    tableRow: function (state, _, _a, customAttrs) {
        var entering = _a.entering;
        if (entering) {
            state.openNode(state.schema.nodes.tableRow, customAttrs);
        }
        else {
            state.closeNode();
        }
    },
    tableCell: function (state, node, _a) {
        var entering = _a.entering;
        if (!node.ignored) {
            var hasParaNode = function (childNode) {
                return childNode && (htmlToWwConvertors_isInlineNode(childNode) || isCustomHTMLInlineNode(state, childNode));
            };
            if (entering) {
                var _b = state.schema.nodes, tableHeadCell = _b.tableHeadCell, tableBodyCell = _b.tableBodyCell, paragraph = _b.paragraph;
                var tablePart = node.parent.parent;
                var cell = tablePart.type === 'tableHead' ? tableHeadCell : tableBodyCell;
                var table = tablePart.parent;
                var align = (table.columns[node.startIdx] || {}).align;
                var attrs = __assign({}, node.attrs);
                if (align) {
                    attrs.align = align;
                }
                state.openNode(cell, attrs);
                if (hasParaNode(node.firstChild)) {
                    state.openNode(paragraph);
                }
            }
            else {
                if (hasParaNode(node.lastChild)) {
                    state.closeNode();
                }
                state.closeNode();
            }
        }
    },
    strike: function (state, _, _a, customAttrs) {
        var entering = _a.entering;
        var strike = state.schema.marks.strike;
        if (entering) {
            state.openMark(strike.create(customAttrs));
        }
        else {
            state.closeMark(strike);
        }
    },
    code: function (state, node, _, customAttrs) {
        var code = state.schema.marks.code;
        state.openMark(code.create(customAttrs));
        state.addText(getTextWithoutTrailingNewline(node.literal || ''));
        state.closeMark(code);
    },
    customBlock: function (state, node) {
        var _a = state.schema.nodes, customBlock = _a.customBlock, paragraph = _a.paragraph;
        var _b = node, info = _b.info, literal = _b.literal;
        state.openNode(customBlock, { info: info });
        state.addText(getTextWithoutTrailingNewline(literal || ''));
        state.closeNode();
        // add empty line to edit the content in next line
        if (!node.next) {
            state.openNode(paragraph);
            state.closeNode();
        }
    },
    frontMatter: function (state, node) {
        state.openNode(state.schema.nodes.frontMatter);
        state.addText(node.literal);
        state.closeNode();
    },
    htmlInline: function (state, node) {
        var html = node.literal;
        var matched = html.match(reHTMLTag);
        var openTagName = matched[1], closeTagName = matched[3];
        var typeName = (openTagName || closeTagName).toLowerCase();
        var markType = state.schema.marks[typeName];
        var sanitizedHTML = sanitizeHTML(html);
        // for user defined html schema
        if (markType === null || markType === void 0 ? void 0 : markType.spec.attrs.htmlInline) {
            if (openTagName) {
                var htmlAttrs = getHTMLAttrsByHTMLString(sanitizedHTML);
                state.openMark(markType.create({ htmlAttrs: htmlAttrs }));
            }
            else {
                state.closeMark(markType);
            }
        }
        else {
            var htmlToWwConvertor = htmlToWwConvertors[typeName];
            if (htmlToWwConvertor) {
                htmlToWwConvertor(state, node, openTagName);
            }
        }
    },
    htmlBlock: function (state, node) {
        var html = node.literal;
        var container = document.createElement('div');
        var isHTMLComment = reHTMLComment.test(html);
        if (isHTMLComment) {
            state.openNode(state.schema.nodes.htmlComment);
            state.addText(node.literal);
            state.closeNode();
        }
        else {
            var matched = html.match(reHTMLTag);
            var openTagName = matched[1], closeTagName = matched[3];
            var typeName = (openTagName || closeTagName).toLowerCase();
            var nodeType = state.schema.nodes[typeName];
            var sanitizedHTML = sanitizeHTML(html);
            // for user defined html schema
            if (nodeType === null || nodeType === void 0 ? void 0 : nodeType.spec.attrs.htmlBlock) {
                var htmlAttrs = getHTMLAttrsByHTMLString(sanitizedHTML);
                var childrenHTML = getChildrenHTML(node, typeName);
                state.addNode(nodeType, { htmlAttrs: htmlAttrs, childrenHTML: childrenHTML });
            }
            else {
                container.innerHTML = sanitizedHTML;
                addRawHTMLAttributeToDOM(container);
                state.convertByDOMParser(container);
            }
        }
    },
    customInline: function (state, node, _a) {
        var entering = _a.entering, skipChildren = _a.skipChildren;
        var _b = node, info = _b.info, firstChild = _b.firstChild;
        var schema = state.schema;
        if (info.indexOf('widget') !== -1 && entering) {
            var content = getWidgetContent(node);
            skipChildren();
            state.addNode(schema.nodes.widget, { info: info }, [
                schema.text(createWidgetContent(info, content)),
            ]);
        }
        else {
            var text = '$$';
            if (entering) {
                text += firstChild ? info + " " : info;
            }
            state.addText(text);
        }
    },
};
function createWwConvertors(customConvertors) {
    var customConvertorTypes = Object.keys(customConvertors);
    var convertors = __assign({}, toWwConvertors);
    var renderer = new Renderer({
        gfm: true,
        nodeId: true,
        convertors: customConvertors,
    });
    var orgConvertors = renderer.getConvertors();
    customConvertorTypes.forEach(function (type) {
        var wwConvertor = toWwConvertors[type];
        if (wwConvertor && !common_includes(['htmlBlock', 'htmlInline'], type)) {
            convertors[type] = function (state, node, context) {
                context.origin = function () { return orgConvertors[type](node, context, orgConvertors); };
                var tokens = customConvertors[type](node, context);
                var attrs;
                if (tokens) {
                    var _a = Array.isArray(tokens) ? tokens[0] : tokens, htmlAttrs = _a.attributes, classNames = _a.classNames;
                    attrs = { htmlAttrs: htmlAttrs, classNames: classNames };
                }
                wwConvertor(state, node, context, attrs);
            };
        }
    });
    return convertors;
}

;// CONCATENATED MODULE: ./src/convertors/toWysiwyg/toWwConvertorState.ts



function mergeMarkText(a, b) {
    if (a.isText && b.isText && external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Mark.sameSet(a.marks, b.marks)) {
        // @ts-ignore
        // type is not defined for "withText" in prosemirror-model
        return a.withText(a.text + b.text);
    }
    return false;
}
var ToWwConvertorState = /** @class */ (function () {
    function ToWwConvertorState(schema, convertors) {
        this.schema = schema;
        this.convertors = convertors;
        this.stack = [{ type: this.schema.topNodeType, attrs: null, content: [] }];
        this.marks = external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Mark.none;
    }
    ToWwConvertorState.prototype.top = function () {
        return last(this.stack);
    };
    ToWwConvertorState.prototype.push = function (node) {
        if (this.stack.length) {
            this.top().content.push(node);
        }
    };
    ToWwConvertorState.prototype.addText = function (text) {
        if (text) {
            var nodes = this.top().content;
            var lastNode = last(nodes);
            var node = this.schema.text(text, this.marks);
            var merged = lastNode && mergeMarkText(lastNode, node);
            if (merged) {
                nodes[nodes.length - 1] = merged;
            }
            else {
                nodes.push(node);
            }
        }
    };
    ToWwConvertorState.prototype.openMark = function (mark) {
        this.marks = mark.addToSet(this.marks);
    };
    ToWwConvertorState.prototype.closeMark = function (mark) {
        this.marks = mark.removeFromSet(this.marks);
    };
    ToWwConvertorState.prototype.addNode = function (type, attrs, content) {
        var node = type.createAndFill(attrs, content, this.marks);
        if (node) {
            this.push(node);
            return node;
        }
        return null;
    };
    ToWwConvertorState.prototype.openNode = function (type, attrs) {
        this.stack.push({ type: type, attrs: attrs, content: [] });
    };
    ToWwConvertorState.prototype.closeNode = function () {
        if (this.marks.length) {
            this.marks = external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Mark.none;
        }
        var _a = this.stack.pop(), type = _a.type, attrs = _a.attrs, content = _a.content;
        return this.addNode(type, attrs, content);
    };
    ToWwConvertorState.prototype.convertByDOMParser = function (root) {
        var _this = this;
        var doc = external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.DOMParser.fromSchema(this.schema).parse(root);
        doc.content.forEach(function (node) { return _this.push(node); });
    };
    ToWwConvertorState.prototype.closeUnmatchedHTMLInline = function (node, entering) {
        var _a;
        if (!entering && node.type !== 'htmlInline') {
            var length = this.stack.length - 1;
            for (var i = length; i >= 0; i -= 1) {
                var nodeInfo = this.stack[i];
                if ((_a = nodeInfo.attrs) === null || _a === void 0 ? void 0 : _a.rawHTML) {
                    if (nodeInfo.content.length) {
                        this.closeNode();
                    }
                    else {
                        // just pop useless unmatched html inline node
                        this.stack.pop();
                    }
                }
                else {
                    break;
                }
            }
        }
    };
    ToWwConvertorState.prototype.convert = function (mdNode, infoForPosSync) {
        var walker = mdNode.walker();
        var event = walker.next();
        var _loop_1 = function () {
            var node = event.node, entering = event.entering;
            var convertor = this_1.convertors[node.type];
            var skipped = false;
            if (convertor) {
                var context = {
                    entering: entering,
                    leaf: !isContainer(node),
                    getChildrenText: getChildrenText,
                    options: { gfm: true, nodeId: false, tagFilter: false, softbreak: '\n' },
                    skipChildren: function () {
                        skipped = true;
                    },
                };
                this_1.closeUnmatchedHTMLInline(node, entering);
                convertor(this_1, node, context);
                if ((infoForPosSync === null || infoForPosSync === void 0 ? void 0 : infoForPosSync.node) === node) {
                    var pos = this_1.stack.reduce(function (nodeSize, stackItem) {
                        return nodeSize +
                            stackItem.content.reduce(function (contentSize, pmNode) { return contentSize + pmNode.nodeSize; }, 0);
                    }, 0) + 1;
                    infoForPosSync.setMappedPos(pos);
                }
            }
            if (skipped) {
                walker.resumeAt(node, false);
                walker.next();
            }
            event = walker.next();
        };
        var this_1 = this;
        while (event) {
            _loop_1();
        }
    };
    ToWwConvertorState.prototype.convertNode = function (mdNode, infoForPosSync) {
        this.convert(mdNode, infoForPosSync);
        if (this.stack.length) {
            return this.closeNode();
        }
        return null;
    };
    return ToWwConvertorState;
}());
/* harmony default export */ var toWwConvertorState = (ToWwConvertorState);

;// CONCATENATED MODULE: ./src/convertors/toMarkdown/toMdNodeTypeWriters.ts


function convertToRawHTMLHavingInlines(state, node, _a) {
    var openTag = _a[0], closeTag = _a[1];
    state.write(openTag);
    state.convertInline(node);
    state.write(closeTag);
}
function convertToRawHTMLHavingBlocks(state, _a, _b) {
    var node = _a.node, parent = _a.parent;
    var openTag = _b[0], closeTag = _b[1];
    state.stopNewline = true;
    state.write(openTag);
    state.convertNode(node);
    state.write(closeTag);
    if ((parent === null || parent === void 0 ? void 0 : parent.type.name) === 'doc') {
        state.closeBlock(node);
        state.stopNewline = false;
    }
}
function createTableHeadDelim(textContent, columnAlign) {
    var textLen = textContent.length;
    var leftDelim = '';
    var rightDelim = '';
    if (columnAlign === 'left') {
        leftDelim = ':';
        textLen -= 1;
    }
    else if (columnAlign === 'right') {
        rightDelim = ':';
        textLen -= 1;
    }
    else if (columnAlign === 'center') {
        leftDelim = ':';
        rightDelim = ':';
        textLen -= 2;
    }
    return "" + leftDelim + repeat('-', Math.max(textLen, 3)) + rightDelim;
}
var nodeTypeWriters = {
    text: function (state, _a) {
        var _b;
        var node = _a.node;
        var text = (_b = node.text) !== null && _b !== void 0 ? _b : '';
        if ((node.marks || []).some(function (mark) { return mark.type.name === 'link'; })) {
            state.text(escapeTextForLink(text), false);
        }
        else {
            state.text(text);
        }
    },
    paragraph: function (state, _a) {
        var node = _a.node, parent = _a.parent, _b = _a.index, index = _b === void 0 ? 0 : _b;
        if (state.stopNewline) {
            state.convertInline(node);
        }
        else {
            var firstChildNode = index === 0;
            var prevNode = !firstChildNode && parent.child(index - 1);
            var prevEmptyNode = prevNode && prevNode.childCount === 0;
            var nextNode = index < parent.childCount - 1 && parent.child(index + 1);
            var nextParaNode = nextNode && nextNode.type.name === 'paragraph';
            var emptyNode = node.childCount === 0;
            if (emptyNode && prevEmptyNode) {
                state.write('<br>\n');
            }
            else if (emptyNode && !prevEmptyNode && !firstChildNode) {
                if ((parent === null || parent === void 0 ? void 0 : parent.type.name) === 'listItem') {
                    var prevDelim = state.getDelim();
                    state.setDelim('');
                    state.write('<br>');
                    state.setDelim(prevDelim);
                }
                state.write('\n');
            }
            else {
                state.convertInline(node);
                if (nextParaNode) {
                    state.write('\n');
                }
                else {
                    state.closeBlock(node);
                }
            }
        }
    },
    heading: function (state, _a, _b) {
        var node = _a.node;
        var delim = _b.delim;
        var headingType = node.attrs.headingType;
        if (headingType === 'atx') {
            state.write(delim + " ");
            state.convertInline(node);
            state.closeBlock(node);
        }
        else {
            state.convertInline(node);
            state.ensureNewLine();
            state.write(delim);
            state.closeBlock(node);
        }
    },
    codeBlock: function (state, _a, _b) {
        var node = _a.node;
        var delim = _b.delim, text = _b.text;
        var _c = delim, openDelim = _c[0], closeDelim = _c[1];
        state.write(openDelim);
        state.ensureNewLine();
        state.text(text, false);
        state.ensureNewLine();
        state.write(closeDelim);
        state.closeBlock(node);
    },
    blockQuote: function (state, _a, _b) {
        var node = _a.node, parent = _a.parent;
        var delim = _b.delim;
        if ((parent === null || parent === void 0 ? void 0 : parent.type.name) === node.type.name) {
            state.flushClose(1);
        }
        state.wrapBlock(delim, null, node, function () { return state.convertNode(node); });
    },
    bulletList: function (state, _a, _b) {
        var node = _a.node;
        var delim = _b.delim;
        // soft-tab(4)
        state.convertList(node, repeat(' ', 4), function () { return delim + " "; });
    },
    orderedList: function (state, _a) {
        var node = _a.node;
        var start = node.attrs.order || 1;
        // soft-tab(4)
        state.convertList(node, repeat(' ', 4), function (index) {
            var orderedNum = String(start + index);
            return orderedNum + ". ";
        });
    },
    listItem: function (state, _a) {
        var node = _a.node;
        var _b = node.attrs, task = _b.task, checked = _b.checked;
        if (task) {
            state.write("[" + (checked ? 'x' : ' ') + "] ");
        }
        state.convertNode(node);
    },
    image: function (state, _, _a) {
        var attrs = _a.attrs;
        state.write("![" + (attrs === null || attrs === void 0 ? void 0 : attrs.altText) + "](" + (attrs === null || attrs === void 0 ? void 0 : attrs.imageUrl) + ")");
    },
    thematicBreak: function (state, _a, _b) {
        var node = _a.node;
        var delim = _b.delim;
        state.write(delim);
        state.closeBlock(node);
    },
    table: function (state, _a) {
        var node = _a.node;
        state.convertNode(node);
        state.closeBlock(node);
    },
    tableHead: function (state, _a, _b) {
        var node = _a.node;
        var delim = _b.delim;
        var row = node.firstChild;
        state.convertNode(node);
        var result = delim !== null && delim !== void 0 ? delim : '';
        if (!delim && row) {
            row.forEach(function (_a) {
                var textContent = _a.textContent, attrs = _a.attrs;
                var headDelim = createTableHeadDelim(textContent, attrs.align);
                result += "| " + headDelim + " ";
            });
        }
        state.write(result + "|");
        state.ensureNewLine();
    },
    tableBody: function (state, _a) {
        var node = _a.node;
        state.convertNode(node);
    },
    tableRow: function (state, _a) {
        var node = _a.node;
        state.convertNode(node);
        state.write('|');
        state.ensureNewLine();
    },
    tableHeadCell: function (state, _a, _b) {
        var node = _a.node;
        var _c = _b.delim, delim = _c === void 0 ? '| ' : _c;
        state.write(delim);
        state.convertTableCell(node);
        state.write(' ');
    },
    tableBodyCell: function (state, _a, _b) {
        var node = _a.node;
        var _c = _b.delim, delim = _c === void 0 ? '| ' : _c;
        state.write(delim);
        state.convertTableCell(node);
        state.write(' ');
    },
    customBlock: function (state, _a, _b) {
        var node = _a.node;
        var delim = _b.delim, text = _b.text;
        var _c = delim, openDelim = _c[0], closeDelim = _c[1];
        state.write(openDelim);
        state.ensureNewLine();
        state.text(text, false);
        state.ensureNewLine();
        state.write(closeDelim);
        state.closeBlock(node);
    },
    frontMatter: function (state, _a, _b) {
        var node = _a.node;
        var text = _b.text;
        state.text(text, false);
        state.closeBlock(node);
    },
    widget: function (state, _, _a) {
        var text = _a.text;
        state.write(text);
    },
    html: function (state, _a, _b) {
        var node = _a.node;
        var text = _b.text;
        state.write(text);
        if (node.attrs.htmlBlock) {
            state.closeBlock(node);
        }
    },
    htmlComment: function (state, _a, _b) {
        var node = _a.node;
        var text = _b.text;
        state.write(text);
        state.closeBlock(node);
    },
};
function write(type, _a) {
    var state = _a.state, nodeInfo = _a.nodeInfo, params = _a.params;
    var rawHTML = params.rawHTML;
    if (rawHTML) {
        if (inArray_default()(type, ['heading', 'codeBlock']) > -1) {
            convertToRawHTMLHavingInlines(state, nodeInfo.node, rawHTML);
        }
        else if (inArray_default()(type, ['image', 'thematicBreak']) > -1) {
            state.write(rawHTML);
        }
        else {
            convertToRawHTMLHavingBlocks(state, nodeInfo, rawHTML);
        }
    }
    else {
        nodeTypeWriters[type](state, nodeInfo, params);
    }
}

;// CONCATENATED MODULE: ./src/convertors/toMarkdown/toMdConvertors.ts




function addBackticks(node, side) {
    var text = node.text;
    var ticks = /`+/g;
    var len = 0;
    if (node.isText && text) {
        var matched = ticks.exec(text);
        while (matched) {
            len = Math.max(len, matched[0].length);
            matched = ticks.exec(text);
        }
    }
    var result = len > 0 && side > 0 ? ' `' : '`';
    for (var i = 0; i < len; i += 1) {
        result += '`';
    }
    if (len > 0 && side < 0) {
        result += ' ';
    }
    return result;
}
function getPairRawHTML(rawHTML) {
    return rawHTML ? ["<" + rawHTML + ">", "</" + rawHTML + ">"] : null;
}
function getOpenRawHTML(rawHTML) {
    return rawHTML ? "<" + rawHTML + ">" : null;
}
function getCloseRawHTML(rawHTML) {
    return rawHTML ? "</" + rawHTML + ">" : null;
}
var toMdConvertors = {
    heading: function (_a) {
        var node = _a.node;
        var attrs = node.attrs;
        var level = attrs.level;
        var delim = repeat('#', level);
        if (attrs.headingType === 'setext') {
            delim = level === 1 ? '===' : '---';
        }
        return {
            delim: delim,
            rawHTML: getPairRawHTML(attrs.rawHTML),
        };
    },
    codeBlock: function (_a) {
        var node = _a.node;
        var _b = node, attrs = _b.attrs, textContent = _b.textContent;
        return {
            delim: ["```" + (attrs.language || ''), '```'],
            rawHTML: getPairRawHTML(attrs.rawHTML),
            text: textContent,
        };
    },
    blockQuote: function (_a) {
        var node = _a.node;
        return {
            delim: '> ',
            rawHTML: getPairRawHTML(node.attrs.rawHTML),
        };
    },
    bulletList: function (_a, _b) {
        var node = _a.node;
        var inTable = _b.inTable;
        var rawHTML = node.attrs.rawHTML;
        if (inTable) {
            rawHTML = rawHTML || 'ul';
        }
        return {
            delim: '*',
            rawHTML: getPairRawHTML(rawHTML),
        };
    },
    orderedList: function (_a, _b) {
        var node = _a.node;
        var inTable = _b.inTable;
        var rawHTML = node.attrs.rawHTML;
        if (inTable) {
            rawHTML = rawHTML || 'ol';
        }
        return {
            rawHTML: getPairRawHTML(rawHTML),
        };
    },
    listItem: function (_a, _b) {
        var node = _a.node;
        var inTable = _b.inTable;
        var _c = node.attrs, task = _c.task, checked = _c.checked;
        var rawHTML = node.attrs.rawHTML;
        if (inTable) {
            rawHTML = rawHTML || 'li';
        }
        var className = task ? " class=\"task-list-item" + (checked ? ' checked' : '') + "\"" : '';
        var dataset = task ? " data-task" + (checked ? " data-task-checked" : '') : '';
        return {
            rawHTML: rawHTML ? ["<" + rawHTML + className + dataset + ">", "</" + rawHTML + ">"] : null,
        };
    },
    table: function (_a) {
        var node = _a.node;
        return {
            rawHTML: getPairRawHTML(node.attrs.rawHTML),
        };
    },
    tableHead: function (_a) {
        var node = _a.node;
        return {
            rawHTML: getPairRawHTML(node.attrs.rawHTML),
        };
    },
    tableBody: function (_a) {
        var node = _a.node;
        return {
            rawHTML: getPairRawHTML(node.attrs.rawHTML),
        };
    },
    tableRow: function (_a) {
        var node = _a.node;
        return {
            rawHTML: getPairRawHTML(node.attrs.rawHTML),
        };
    },
    tableHeadCell: function (_a) {
        var node = _a.node;
        return {
            rawHTML: getPairRawHTML(node.attrs.rawHTML),
        };
    },
    tableBodyCell: function (_a) {
        var node = _a.node;
        return {
            rawHTML: getPairRawHTML(node.attrs.rawHTML),
        };
    },
    image: function (_a) {
        var node = _a.node;
        var attrs = node.attrs;
        var rawHTML = attrs.rawHTML, altText = attrs.altText;
        var imageUrl = attrs.imageUrl.replace(/&amp;/g, '&');
        var altAttr = altText ? " alt=\"" + escapeXml(altText) + "\"" : '';
        return {
            rawHTML: rawHTML ? "<" + rawHTML + " src=\"" + escapeXml(imageUrl) + "\"" + altAttr + ">" : null,
            attrs: {
                altText: escapeTextForLink(altText || ''),
                imageUrl: imageUrl,
            },
        };
    },
    thematicBreak: function (_a) {
        var node = _a.node;
        return {
            delim: '***',
            rawHTML: getOpenRawHTML(node.attrs.rawHTML),
        };
    },
    customBlock: function (_a) {
        var node = _a.node;
        var _b = node, attrs = _b.attrs, textContent = _b.textContent;
        return {
            delim: ["$$" + attrs.info, '$$'],
            text: textContent,
        };
    },
    frontMatter: function (_a) {
        var node = _a.node;
        return {
            text: node.textContent,
        };
    },
    widget: function (_a) {
        var node = _a.node;
        return {
            text: node.textContent,
        };
    },
    strong: function (_a, _b) {
        var node = _a.node;
        var entering = _b.entering;
        var rawHTML = node.attrs.rawHTML;
        return {
            delim: '**',
            rawHTML: entering ? getOpenRawHTML(rawHTML) : getCloseRawHTML(rawHTML),
        };
    },
    emph: function (_a, _b) {
        var node = _a.node;
        var entering = _b.entering;
        var rawHTML = node.attrs.rawHTML;
        return {
            delim: '*',
            rawHTML: entering ? getOpenRawHTML(rawHTML) : getCloseRawHTML(rawHTML),
        };
    },
    strike: function (_a, _b) {
        var node = _a.node;
        var entering = _b.entering;
        var rawHTML = node.attrs.rawHTML;
        return {
            delim: '~~',
            rawHTML: entering ? getOpenRawHTML(rawHTML) : getCloseRawHTML(rawHTML),
        };
    },
    link: function (_a, _b) {
        var node = _a.node;
        var entering = _b.entering;
        var attrs = node.attrs;
        var title = attrs.title, rawHTML = attrs.rawHTML;
        var linkUrl = attrs.linkUrl.replace(/&amp;/g, '&');
        var titleAttr = title ? " title=\"" + escapeXml(title) + "\"" : '';
        if (entering) {
            return {
                delim: '[',
                rawHTML: rawHTML ? "<" + rawHTML + " href=\"" + escapeXml(linkUrl) + "\"" + titleAttr + ">" : null,
            };
        }
        return {
            delim: "](" + linkUrl + (title ? " " + quote(escapeTextForLink(title)) : '') + ")",
            rawHTML: getCloseRawHTML(rawHTML),
        };
    },
    code: function (_a, _b) {
        var node = _a.node, parent = _a.parent, _c = _a.index, index = _c === void 0 ? 0 : _c;
        var entering = _b.entering;
        var delim = entering
            ? addBackticks(parent.child(index), -1)
            : addBackticks(parent.child(index - 1), 1);
        var rawHTML = entering
            ? getOpenRawHTML(node.attrs.rawHTML)
            : getCloseRawHTML(node.attrs.rawHTML);
        return {
            delim: delim,
            rawHTML: rawHTML,
        };
    },
    htmlComment: function (_a) {
        var node = _a.node;
        return {
            text: node.textContent,
        };
    },
    // html inline node, html block node
    html: function (_a, _b) {
        var node = _a.node;
        var entering = _b.entering;
        var tagName = node.type.name;
        var attrs = node.attrs.htmlAttrs;
        var openTag = "<" + tagName;
        var closeTag = "</" + tagName + ">";
        Object.keys(attrs).forEach(function (attrName) {
            // To prevent broken converting when attributes has double quote string
            openTag += " " + attrName + "=\"" + attrs[attrName].replace(/"/g, "'") + "\"";
        });
        openTag += '>';
        if (node.attrs.htmlInline) {
            return {
                rawHTML: entering ? openTag : closeTag,
            };
        }
        return {
            text: "" + openTag + node.attrs.childrenHTML + closeTag,
        };
    },
};
var markTypeOptions = {
    strong: {
        mixable: true,
        removedEnclosingWhitespace: true,
    },
    emph: {
        mixable: true,
        removedEnclosingWhitespace: true,
    },
    strike: {
        mixable: true,
        removedEnclosingWhitespace: true,
    },
    code: {
        escape: false,
    },
    link: null,
    html: null,
};
function createNodeTypeConvertors(convertors) {
    var nodeTypeConvertors = {};
    var nodeTypes = Object.keys(nodeTypeWriters);
    nodeTypes.forEach(function (type) {
        nodeTypeConvertors[type] = function (state, nodeInfo) {
            var writer = nodeTypeWriters[type];
            if (writer) {
                var convertor = convertors[type];
                var params = convertor
                    ? convertor(nodeInfo, {
                        inTable: state.inTable,
                    })
                    : {};
                write(type, { state: state, nodeInfo: nodeInfo, params: params });
            }
        };
    });
    return nodeTypeConvertors;
}
function createMarkTypeConvertors(convertors) {
    var markTypeConvertors = {};
    var markTypes = Object.keys(markTypeOptions);
    markTypes.forEach(function (type) {
        markTypeConvertors[type] = function (nodeInfo, entering) {
            var markOption = markTypeOptions[type];
            var convertor = convertors[type];
            // There are two ways to call the mark type converter
            // in the `toMdConvertorState` module.
            // When calling the converter without using `delim` and `rawHTML` values,
            // the converter is called without parameters.
            var runConvertor = convertor && nodeInfo && !isUndefined_default()(entering);
            var params = runConvertor ? convertor(nodeInfo, { entering: entering }) : {};
            return __assign(__assign({}, params), markOption);
        };
    });
    return markTypeConvertors;
}
// Step 1: Create the converter by overriding the custom converter
//         to the original converter defined in the `toMdConvertors` module.
//         If the node type is defined in the original converter,
//         the `origin()` function is exported to the paramter of the converter.
// Step 2: Create a converter for the node type of ProseMirror by combining the converter
//         created in Step 1 with the writers defined in the`toMdNodeTypeWriters` module.
//         Each writer converts the ProseMirror's node to a string with the value returned
//         by the converter, and then stores the state in the`toMdConverterState` class.
// Step 3: Create a converter for the mark type of ProseMirror by combining the converter
//         created in Step 1 with `markTypeOptions`.
// Step 4: The created node type converter and mark type converter are injected
//         when creating an instance of the`toMdConverterState` class.
function createMdConvertors(customConvertors) {
    var customConvertorTypes = Object.keys(customConvertors);
    customConvertorTypes.forEach(function (type) {
        var baseConvertor = toMdConvertors[type];
        var customConvertor = customConvertors[type];
        if (baseConvertor) {
            toMdConvertors[type] = function (nodeInfo, context) {
                context.origin = function () { return baseConvertor(nodeInfo, context); };
                return customConvertor(nodeInfo, context);
            };
        }
        else {
            toMdConvertors[type] = customConvertor;
        }
        delete customConvertors[type];
    });
    var nodeTypeConvertors = createNodeTypeConvertors(toMdConvertors);
    var markTypeConvertors = createMarkTypeConvertors(toMdConvertors);
    return {
        nodeTypeConvertors: nodeTypeConvertors,
        markTypeConvertors: markTypeConvertors,
    };
}

;// CONCATENATED MODULE: ./src/convertors/toMarkdown/toMdConvertorState.ts

var ToMdConvertorState = /** @class */ (function () {
    function ToMdConvertorState(_a) {
        var nodeTypeConvertors = _a.nodeTypeConvertors, markTypeConvertors = _a.markTypeConvertors;
        this.nodeTypeConvertors = nodeTypeConvertors;
        this.markTypeConvertors = markTypeConvertors;
        this.delim = '';
        this.result = '';
        this.closed = false;
        this.tightList = false;
        this.stopNewline = false;
        this.inTable = false;
    }
    ToMdConvertorState.prototype.getMarkConvertor = function (mark) {
        var type = mark.attrs.htmlInline ? 'html' : mark.type.name;
        return this.markTypeConvertors[type];
    };
    ToMdConvertorState.prototype.isInBlank = function () {
        return /(^|\n)$/.test(this.result);
    };
    ToMdConvertorState.prototype.markText = function (mark, entering, parent, index) {
        var convertor = this.getMarkConvertor(mark);
        if (convertor) {
            var _a = convertor({ node: mark, parent: parent, index: index }, entering), delim = _a.delim, rawHTML = _a.rawHTML;
            return rawHTML || delim;
        }
        return '';
    };
    ToMdConvertorState.prototype.setDelim = function (delim) {
        this.delim = delim;
    };
    ToMdConvertorState.prototype.getDelim = function () {
        return this.delim;
    };
    ToMdConvertorState.prototype.flushClose = function (size) {
        if (!this.stopNewline && this.closed) {
            if (!this.isInBlank()) {
                this.result += '\n';
            }
            if (!size) {
                size = 2;
            }
            if (size > 1) {
                var delimMin = this.delim;
                var trim = /\s+$/.exec(delimMin);
                if (trim) {
                    delimMin = delimMin.slice(0, delimMin.length - trim[0].length);
                }
                for (var i = 1; i < size; i += 1) {
                    this.result += delimMin + "\n";
                }
            }
            this.closed = false;
        }
    };
    ToMdConvertorState.prototype.wrapBlock = function (delim, firstDelim, node, fn) {
        var old = this.getDelim();
        this.write(firstDelim || delim);
        this.setDelim(this.getDelim() + delim);
        fn();
        this.setDelim(old);
        this.closeBlock(node);
    };
    ToMdConvertorState.prototype.ensureNewLine = function () {
        if (!this.isInBlank()) {
            this.result += '\n';
        }
    };
    ToMdConvertorState.prototype.write = function (content) {
        if (content === void 0) { content = ''; }
        this.flushClose();
        if (this.delim && this.isInBlank()) {
            this.result += this.delim;
        }
        if (content) {
            this.result += content;
        }
    };
    ToMdConvertorState.prototype.closeBlock = function (node) {
        this.closed = node;
    };
    ToMdConvertorState.prototype.text = function (text, escaped) {
        if (escaped === void 0) { escaped = true; }
        var lines = text.split('\n');
        for (var i = 0; i < lines.length; i += 1) {
            this.write();
            this.result += escaped ? common_escape(lines[i]) : lines[i];
            if (i !== lines.length - 1) {
                this.result += '\n';
            }
        }
    };
    ToMdConvertorState.prototype.convertBlock = function (node, parent, index) {
        var type = node.type.name;
        var convertor = this.nodeTypeConvertors[type];
        var nodeInfo = { node: node, parent: parent, index: index };
        if (node.attrs.htmlBlock) {
            this.nodeTypeConvertors.html(this, nodeInfo);
        }
        else if (convertor) {
            convertor(this, nodeInfo);
        }
    };
    ToMdConvertorState.prototype.convertInline = function (parent) {
        var _this = this;
        var active = [];
        var trailing = '';
        var progress = function (node, _, index) {
            var marks = node ? node.marks : [];
            var leading = trailing;
            trailing = '';
            // If whitespace has to be expelled from the node, adjust
            // leading and trailing accordingly.
            var removedWhitespace = node &&
                node.isText &&
                marks.some(function (mark) {
                    var markConvertor = _this.getMarkConvertor(mark);
                    var info = markConvertor && markConvertor();
                    return info && info.removedEnclosingWhitespace;
                });
            if (removedWhitespace && node && node.text) {
                var _a = /^(\s*)(.*?)(\s*)$/m.exec(node.text), lead = _a[1], mark = _a[2], trail = _a[3];
                leading += lead;
                trailing = trail;
                if (lead || trail) {
                    // @ts-ignore
                    // type is not defined for "withText" in prosemirror-model
                    node = mark ? node.withText(mark) : null;
                    if (!node) {
                        marks = active;
                    }
                }
            }
            var lastMark = marks.length && last(marks);
            var markConvertor = lastMark && _this.getMarkConvertor(lastMark);
            var markType = markConvertor && markConvertor();
            var noEscape = markType && markType.escape === false;
            var len = marks.length - (noEscape ? 1 : 0);
            // Try to reorder 'mixable' marks, such as em and strong, which
            // in Markdown may be opened and closed in different order, so
            // that order of the marks for the token matches the order in
            // active.
            for (var i = 0; i < len; i += 1) {
                var mark = marks[i];
                if (markType && !markType.mixable) {
                    break;
                }
                for (var j = 0; j < active.length; j += 1) {
                    var other = active[j];
                    if (markType && !markType.mixable) {
                        break;
                    }
                    if (mark.eq(other)) {
                        // eslint-disable-next-line max-depth
                        if (i > j) {
                            marks = marks
                                .slice(0, j)
                                .concat(mark)
                                .concat(marks.slice(j, i))
                                .concat(marks.slice(i + 1, len));
                        }
                        else if (j > i) {
                            marks = marks
                                .slice(0, i)
                                .concat(marks.slice(i + 1, j))
                                .concat(mark)
                                .concat(marks.slice(j, len));
                        }
                        break;
                    }
                }
            }
            // Find the prefix of the mark set that didn't change
            var keep = 0;
            while (keep < Math.min(active.length, len) && marks[keep].eq(active[keep])) {
                keep += 1;
            }
            // Close the marks that need to be closed
            while (keep < active.length) {
                var activedMark = active.pop();
                if (activedMark) {
                    _this.text(_this.markText(activedMark, false, parent, index), false);
                }
            }
            // Output any previously expelled trailing whitespace outside the marks
            if (leading) {
                _this.text(leading);
            }
            // Open the marks that need to be opened
            if (node) {
                while (active.length < len) {
                    var mark = marks[active.length];
                    active.push(mark);
                    _this.text(_this.markText(mark, true, parent, index), false);
                }
                // Render the node. Special case code marks, since their content
                // may not be escaped.
                if (noEscape && node.isText) {
                    _this.text(_this.markText(lastMark, true, parent, index) +
                        node.text +
                        _this.markText(lastMark, false, parent, index + 1), false);
                }
                else {
                    _this.convertBlock(node, parent, index);
                }
            }
        };
        parent.forEach(progress);
        progress(null, null, parent.childCount);
    };
    // Render a node's content as a list. `delim` should be the extra
    // indentation added to all lines except the first in an item,
    // `firstDelimFn` is a function going from an item index to a
    // delimiter for the first line of the item.
    ToMdConvertorState.prototype.convertList = function (node, delim, firstDelimFn) {
        var _this = this;
        var _a;
        if (this.closed && this.closed.type === node.type) {
            this.flushClose(3);
        }
        else if (this.tightList) {
            this.flushClose(1);
        }
        var tight = (_a = node.attrs.tight) !== null && _a !== void 0 ? _a : true;
        var prevTight = this.tightList;
        this.tightList = tight;
        node.forEach(function (child, _, index) {
            if (index && tight) {
                _this.flushClose(1);
            }
            _this.wrapBlock(delim, firstDelimFn(index), node, function () { return _this.convertBlock(child, node, index); });
        });
        this.tightList = prevTight;
    };
    ToMdConvertorState.prototype.convertTableCell = function (node) {
        var _this = this;
        this.stopNewline = true;
        this.inTable = true;
        node.forEach(function (child, _, index) {
            if (common_includes(['bulletList', 'orderedList'], child.type.name)) {
                _this.convertBlock(child, node, index);
                _this.closed = false;
            }
            else {
                _this.convertInline(child);
                if (index < node.childCount - 1) {
                    var nextChild = node.child(index + 1);
                    if (nextChild.type.name === 'paragraph') {
                        _this.write('<br>');
                    }
                }
            }
        });
        this.stopNewline = false;
        this.inTable = false;
    };
    ToMdConvertorState.prototype.convertNode = function (parent, infoForPosSync) {
        var _this = this;
        parent.forEach(function (node, _, index) {
            _this.convertBlock(node, parent, index);
            if ((infoForPosSync === null || infoForPosSync === void 0 ? void 0 : infoForPosSync.node) === node) {
                var lineTexts = _this.result.split('\n');
                infoForPosSync.setMappedPos([lineTexts.length, last(lineTexts).length + 1]);
            }
        });
        return this.result;
    };
    return ToMdConvertorState;
}());
/* harmony default export */ var toMdConvertorState = (ToMdConvertorState);

;// CONCATENATED MODULE: ./src/convertors/convertor.ts




var Convertor = /** @class */ (function () {
    function Convertor(schema, toMdConvertors, toHTMLConvertors, eventEmitter) {
        var _this = this;
        this.setMappedPos = function (pos) {
            _this.mappedPosWhenConverting = pos;
        };
        this.schema = schema;
        this.eventEmitter = eventEmitter;
        this.focusedNode = null;
        this.mappedPosWhenConverting = null;
        this.toWwConvertors = createWwConvertors(toHTMLConvertors);
        this.toMdConvertors = createMdConvertors(toMdConvertors || {});
        this.eventEmitter.listen('setFocusedNode', function (node) { return (_this.focusedNode = node); });
    }
    Convertor.prototype.getMappedPos = function () {
        return this.mappedPosWhenConverting;
    };
    Convertor.prototype.getInfoForPosSync = function () {
        return { node: this.focusedNode, setMappedPos: this.setMappedPos };
    };
    Convertor.prototype.toWysiwygModel = function (mdNode) {
        var state = new toWwConvertorState(this.schema, this.toWwConvertors);
        return state.convertNode(mdNode, this.getInfoForPosSync());
    };
    Convertor.prototype.toMarkdownText = function (wwNode) {
        var state = new toMdConvertorState(this.toMdConvertors);
        var markdownText = state.convertNode(wwNode, this.getInfoForPosSync());
        markdownText = this.eventEmitter.emitReduce('beforeConvertWysiwygToMarkdown', markdownText);
        return markdownText;
    };
    return Convertor;
}());
/* harmony default export */ var convertor = (Convertor);

;// CONCATENATED MODULE: ./src/helper/plugin.ts










function execPlugin(pluginInfo) {
    var plugin = pluginInfo.plugin, eventEmitter = pluginInfo.eventEmitter, usageStatistics = pluginInfo.usageStatistics, instance = pluginInfo.instance;
    var pmState = { Plugin: external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Plugin, PluginKey: external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.PluginKey, Selection: external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.Selection, TextSelection: external_commonjs_prosemirror_state_commonjs2_prosemirror_state_amd_prosemirror_state_.TextSelection };
    var pmView = { Decoration: external_commonjs_prosemirror_view_commonjs2_prosemirror_view_amd_prosemirror_view_.Decoration, DecorationSet: external_commonjs_prosemirror_view_commonjs2_prosemirror_view_amd_prosemirror_view_.DecorationSet };
    var pmModel = { Fragment: external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Fragment };
    var pmRules = { InputRule: external_commonjs_prosemirror_inputrules_commonjs2_prosemirror_inputrules_amd_prosemirror_inputrules_.InputRule, inputRules: external_commonjs_prosemirror_inputrules_commonjs2_prosemirror_inputrules_amd_prosemirror_inputrules_.inputRules, undoInputRule: external_commonjs_prosemirror_inputrules_commonjs2_prosemirror_inputrules_amd_prosemirror_inputrules_.undoInputRule };
    var pmKeymap = { keymap: external_commonjs_prosemirror_keymap_commonjs2_prosemirror_keymap_amd_prosemirror_keymap_.keymap };
    var context = {
        eventEmitter: eventEmitter,
        usageStatistics: usageStatistics,
        instance: instance,
        pmState: pmState,
        pmView: pmView,
        pmModel: pmModel,
        pmRules: pmRules,
        pmKeymap: pmKeymap,
        i18n: i18n,
    };
    if (isArray_default()(plugin)) {
        var pluginFn = plugin[0], _a = plugin[1], options = _a === void 0 ? {} : _a;
        return pluginFn(context, options);
    }
    return plugin(context);
}
function getPluginInfo(pluginsInfo) {
    var plugins = pluginsInfo.plugins, eventEmitter = pluginsInfo.eventEmitter, usageStatistics = pluginsInfo.usageStatistics, instance = pluginsInfo.instance;
    eventEmitter.listen('mixinTableOffsetMapPrototype', mixinTableOffsetMapPrototype);
    return (plugins !== null && plugins !== void 0 ? plugins : []).reduce(function (acc, plugin) {
        var pluginInfoResult = execPlugin({
            plugin: plugin,
            eventEmitter: eventEmitter,
            usageStatistics: usageStatistics,
            instance: instance,
        });
        if (!pluginInfoResult) {
            throw new Error('The return value of the executed plugin is empty.');
        }
        var markdownParsers = pluginInfoResult.markdownParsers, toHTMLRenderers = pluginInfoResult.toHTMLRenderers, toMarkdownRenderers = pluginInfoResult.toMarkdownRenderers, markdownPlugins = pluginInfoResult.markdownPlugins, wysiwygPlugins = pluginInfoResult.wysiwygPlugins, wysiwygNodeViews = pluginInfoResult.wysiwygNodeViews, markdownCommands = pluginInfoResult.markdownCommands, wysiwygCommands = pluginInfoResult.wysiwygCommands, toolbarItems = pluginInfoResult.toolbarItems;
        if (toHTMLRenderers) {
            acc.toHTMLRenderers = deepMergedCopy(acc.toHTMLRenderers, toHTMLRenderers);
        }
        if (toMarkdownRenderers) {
            acc.toMarkdownRenderers = deepMergedCopy(acc.toMarkdownRenderers, toMarkdownRenderers);
        }
        if (markdownPlugins) {
            acc.mdPlugins = acc.mdPlugins.concat(markdownPlugins);
        }
        if (wysiwygPlugins) {
            acc.wwPlugins = acc.wwPlugins.concat(wysiwygPlugins);
        }
        if (wysiwygNodeViews) {
            acc.wwNodeViews = __assign(__assign({}, acc.wwNodeViews), wysiwygNodeViews);
        }
        if (markdownCommands) {
            acc.mdCommands = __assign(__assign({}, acc.mdCommands), markdownCommands);
        }
        if (wysiwygCommands) {
            acc.wwCommands = __assign(__assign({}, acc.wwCommands), wysiwygCommands);
        }
        if (toolbarItems) {
            acc.toolbarItems = acc.toolbarItems.concat(toolbarItems);
        }
        if (markdownParsers) {
            acc.markdownParsers = __assign(__assign({}, acc.markdownParsers), markdownParsers);
        }
        return acc;
    }, {
        toHTMLRenderers: {},
        toMarkdownRenderers: {},
        mdPlugins: [],
        wwPlugins: [],
        wwNodeViews: {},
        mdCommands: {},
        wwCommands: {},
        toolbarItems: [],
        markdownParsers: {},
    });
}

;// CONCATENATED MODULE: ./src/viewer.ts












var TASK_ATTR_NAME = 'data-task';
var DISABLED_TASK_ATTR_NAME = 'data-task-disabled';
var TASK_CHECKED_CLASS_NAME = 'checked';
function registerHTMLTagToWhitelist(convertorMap) {
    ['htmlBlock', 'htmlInline'].forEach(function (htmlType) {
        if (convertorMap[htmlType]) {
            // register tag white list for preventing to remove the html in sanitizer
            Object.keys(convertorMap[htmlType]).forEach(function (type) { return registerTagWhitelistIfPossible(type); });
        }
    });
}
/**
 * Class ToastUIEditorViewer
 * @param {object} options Option object
 *     @param {HTMLElement} options.el - container element
 *     @param {string} [options.initialValue] Editor's initial value
 *     @param {Object} [options.events] - Events
 *         @param {function} [options.events.load] - It would be emitted when editor fully load
 *         @param {function} [options.events.change] - It would be emitted when content changed
 *         @param {function} [options.events.caretChange] - It would be emitted when format change by cursor position
 *         @param {function} [options.events.focus] - It would be emitted when editor get focus
 *         @param {function} [options.events.blur] - It would be emitted when editor loose focus
 *     @param {Array.<function|Array>} [options.plugins] - Array of plugins. A plugin can be either a function or an array in the form of [function, options].
 *     @param {Object} [options.extendedAutolinks] - Using extended Autolinks specified in GFM spec
 *     @param {Object} [options.linkAttributes] - Attributes of anchor element that should be rel, target, hreflang, type
 *     @param {Object} [options.customHTMLRenderer=null] - Object containing custom renderer functions correspond to change markdown node to preview HTML or wysiwyg node
 *     @param {boolean} [options.referenceDefinition=false] - whether use the specification of link reference definition
 *     @param {function} [options.customHTMLSanitizer=null] - custom HTML sanitizer
 *     @param {boolean} [options.frontMatter=false] - whether use the front matter
 *     @param {string} [options.theme] - The theme to style the viewer with. The default is included in toastui-editor.css.
 */
var ToastUIEditorViewer = /** @class */ (function () {
    function ToastUIEditorViewer(options) {
        var _this = this;
        this.options = extend_default()({
            linkAttributes: null,
            extendedAutolinks: false,
            customHTMLRenderer: null,
            referenceDefinition: false,
            customHTMLSanitizer: null,
            frontMatter: false,
            usageStatistics: true,
            theme: 'light',
        }, options);
        this.eventEmitter = new eventEmitter();
        var linkAttributes = sanitizeLinkAttribute(this.options.linkAttributes);
        var _a = getPluginInfo({
            plugins: this.options.plugins,
            eventEmitter: this.eventEmitter,
            usageStatistics: this.options.usageStatistics,
            instance: this,
        }) || {}, toHTMLRenderers = _a.toHTMLRenderers, markdownParsers = _a.markdownParsers;
        var _b = this.options, customHTMLRenderer = _b.customHTMLRenderer, extendedAutolinks = _b.extendedAutolinks, referenceDefinition = _b.referenceDefinition, frontMatter = _b.frontMatter, customHTMLSanitizer = _b.customHTMLSanitizer;
        var rendererOptions = {
            linkAttributes: linkAttributes,
            customHTMLRenderer: __assign(__assign({}, toHTMLRenderers), customHTMLRenderer),
            extendedAutolinks: extendedAutolinks,
            referenceDefinition: referenceDefinition,
            frontMatter: frontMatter,
            sanitizer: customHTMLSanitizer || sanitizeHTML,
        };
        registerHTMLTagToWhitelist(rendererOptions.customHTMLRenderer);
        if (this.options.events) {
            forEachOwnProperties_default()(this.options.events, function (fn, key) {
                _this.on(key, fn);
            });
        }
        var _c = this.options, el = _c.el, initialValue = _c.initialValue, theme = _c.theme;
        var existingHTML = el.innerHTML;
        if (theme !== 'light') {
            el.classList.add(cls(theme));
        }
        el.innerHTML = '';
        this.toastMark = new ToastMark('', {
            disallowedHtmlBlockTags: ['br', 'img'],
            extendedAutolinks: extendedAutolinks,
            referenceDefinition: referenceDefinition,
            disallowDeepHeading: true,
            frontMatter: frontMatter,
            customParser: markdownParsers,
        });
        this.preview = new mdPreview(this.eventEmitter, __assign(__assign({}, rendererOptions), { isViewer: true }));
        on_default()(this.preview.previewContent, 'mousedown', this.toggleTask.bind(this));
        if (initialValue) {
            this.setMarkdown(initialValue);
        }
        else if (existingHTML) {
            this.preview.setHTML(existingHTML);
        }
        el.appendChild(this.preview.previewContent);
        this.eventEmitter.emit('load', this);
    }
    /**
     * Toggle task by detecting mousedown event.
     * @param {MouseEvent} ev - event
     * @private
     */
    ToastUIEditorViewer.prototype.toggleTask = function (ev) {
        var element = ev.target;
        var style = getComputedStyle(element, ':before');
        if (!element.hasAttribute(DISABLED_TASK_ATTR_NAME) &&
            element.hasAttribute(TASK_ATTR_NAME) &&
            isPositionInBox(style, ev.offsetX, ev.offsetY)) {
            toggleClass(element, TASK_CHECKED_CLASS_NAME);
            this.eventEmitter.emit('change', {
                source: 'viewer',
                date: ev,
            });
        }
    };
    /**
     * Set content for preview
     * @param {string} markdown Markdown text
     */
    ToastUIEditorViewer.prototype.setMarkdown = function (markdown) {
        var lineTexts = this.toastMark.getLineTexts();
        var length = lineTexts.length;
        var lastLine = last(lineTexts);
        var endSourcepos = [length, lastLine.length + 1];
        var editResult = this.toastMark.editMarkdown([1, 1], endSourcepos, markdown || '');
        this.eventEmitter.emit('updatePreview', editResult);
    };
    /**
     * Bind eventHandler to event type
     * @param {string} type Event type
     * @param {function} handler Event handler
     */
    ToastUIEditorViewer.prototype.on = function (type, handler) {
        this.eventEmitter.listen(type, handler);
    };
    /**
     * Unbind eventHandler from event type
     * @param {string} type Event type
     */
    ToastUIEditorViewer.prototype.off = function (type) {
        this.eventEmitter.removeEventHandler(type);
    };
    /**
     * Add hook to TUIEditor event
     * @param {string} type Event type
     * @param {function} handler Event handler
     */
    ToastUIEditorViewer.prototype.addHook = function (type, handler) {
        this.eventEmitter.removeEventHandler(type);
        this.eventEmitter.listen(type, handler);
    };
    /**
     * Remove Viewer preview from document
     */
    ToastUIEditorViewer.prototype.destroy = function () {
        off_default()(this.preview.el, 'mousedown', this.toggleTask.bind(this));
        this.preview.destroy();
        this.eventEmitter.emit('destroy');
    };
    /**
     * Return true
     * @returns {boolean}
     */
    ToastUIEditorViewer.prototype.isViewer = function () {
        return true;
    };
    /**
     * Return false
     * @returns {boolean}
     */
    ToastUIEditorViewer.prototype.isMarkdownMode = function () {
        return false;
    };
    /**
     * Return false
     * @returns {boolean}
     */
    ToastUIEditorViewer.prototype.isWysiwygMode = function () {
        return false;
    };
    return ToastUIEditorViewer;
}());
/* harmony default export */ var viewer = (ToastUIEditorViewer);

;// CONCATENATED MODULE: ./src/wysiwyg/adaptor/mdLikeNode.ts



function isPmNode(node) {
    return node instanceof external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.Node;
}
function mdLikeNode_isContainer(type) {
    var containerTypes = [
        'document',
        'blockQuote',
        'bulletList',
        'orderedList',
        'listItem',
        'paragraph',
        'heading',
        'emph',
        'strong',
        'strike',
        'link',
        'image',
        'table',
        'tableHead',
        'tableBody',
        'tableRow',
        'tableHeadCell',
        'tableBodyCell',
    ];
    return common_includes(containerTypes, type);
}
function createMdLikeNode(node) {
    var attrs = node.attrs, type = node.type;
    var nodeType = type.name;
    var mdLikeNode = {
        type: nodeType,
        wysiwygNode: true,
        literal: !mdLikeNode_isContainer(nodeType) && isPmNode(node) ? node.textContent : null,
    };
    var nodeTypeMap = {
        heading: { level: attrs.level },
        link: { destination: attrs.linkUrl, title: attrs.title },
        image: { destination: attrs.imageUrl },
        codeBlock: { info: attrs.language },
        bulletList: { type: 'list', listData: { type: 'bullet' } },
        orderedList: { type: 'list', listData: { type: 'ordered', start: attrs.order } },
        listItem: { type: 'item', listData: { task: attrs.task, checked: attrs.checked } },
        tableHeadCell: { type: 'tableCell', cellType: 'head', align: attrs.align },
        tableBodyCell: { type: 'tableCell', cellType: 'body', align: attrs.align },
        customBlock: { info: attrs.info },
    };
    var nodeInfo = nodeTypeMap[nodeType];
    var attributes = __assign(__assign({}, mdLikeNode), nodeInfo);
    // html block, inline node
    var _a = node.attrs, htmlAttrs = _a.htmlAttrs, childrenHTML = _a.childrenHTML;
    if (htmlAttrs) {
        return __assign(__assign({}, attributes), { attrs: htmlAttrs, childrenHTML: childrenHTML });
    }
    return attributes;
}

;// CONCATENATED MODULE: ./src/wysiwyg/adaptor/wwToDOMAdaptor.ts







var tokenToDOMNode = {
    openTag: function (token, stack) {
        var _a = token, tagName = _a.tagName, classNames = _a.classNames, attributes = _a.attributes;
        var el = document.createElement(tagName);
        var attrs = {};
        if (classNames) {
            el.className = classNames.join(' ');
        }
        if (attributes) {
            attrs = __assign(__assign({}, attrs), attributes);
        }
        setAttributes(attrs, el);
        stack.push(el);
    },
    closeTag: function (_, stack) {
        if (stack.length > 1) {
            var el = stack.pop();
            last(stack).appendChild(el);
        }
    },
    html: function (token, stack) {
        last(stack).insertAdjacentHTML('beforeend', token.content);
    },
    text: function (token, stack) {
        var textNode = document.createTextNode(token.content);
        last(stack).appendChild(textNode);
    },
};
var WwToDOMAdaptor = /** @class */ (function () {
    function WwToDOMAdaptor(linkAttributes, customRenderer) {
        var convertors = getHTMLRenderConvertors(linkAttributes, customRenderer);
        var customHTMLConvertor = __assign(__assign({}, customRenderer.htmlBlock), customRenderer.htmlInline);
        // flatten the html block, inline convertor to other custom convertors
        this.customConvertorKeys = Object.keys(customRenderer).concat(Object.keys(customHTMLConvertor));
        this.renderer = new Renderer({
            gfm: true,
            convertors: __assign(__assign({}, convertors), customHTMLConvertor),
        });
        this.convertors = this.renderer.getConvertors();
    }
    WwToDOMAdaptor.prototype.generateTokens = function (node) {
        var mdLikeNode = createMdLikeNode(node);
        var context = {
            entering: true,
            leaf: isPmNode(node) ? node.isLeaf : false,
            options: this.renderer.getOptions(),
            getChildrenText: function () { return (isPmNode(node) ? node.textContent : ''); },
            skipChildren: function () { return false; },
        };
        var convertor = this.convertors[node.type.name];
        var converted = convertor(mdLikeNode, context, this.convertors);
        var tokens = isArray_default()(converted) ? converted : [converted];
        if (mdLikeNode_isContainer(node.type.name) || node.attrs.htmlInline) {
            context.entering = false;
            tokens.push({ type: 'text', content: isPmNode(node) ? node.textContent : '' });
            tokens = tokens.concat(convertor(mdLikeNode, context, this.convertors));
        }
        return tokens;
    };
    WwToDOMAdaptor.prototype.toDOMNode = function (node) {
        var tokens = this.generateTokens(node);
        var stack = [];
        tokens.forEach(function (token) { return tokenToDOMNode[token.type](token, stack); });
        return stack[0];
    };
    WwToDOMAdaptor.prototype.getToDOMNode = function (name) {
        if (common_includes(this.customConvertorKeys, name)) {
            return this.toDOMNode.bind(this);
        }
        return null;
    };
    return WwToDOMAdaptor;
}());


;// CONCATENATED MODULE: ./src/markdown/scroll/animation.ts
var ANIMATION_TIME = 100;
var SCROLL_BLOCKING_RESET_DELAY = 15;
var currentTimeoutId = null;
var releaseTimer = null;
function run(deltaScrollTop, _a) {
    var syncScrollTop = _a.syncScrollTop, releaseEventBlock = _a.releaseEventBlock;
    if (releaseTimer) {
        clearTimeout(releaseTimer);
    }
    syncScrollTop(deltaScrollTop);
    releaseTimer = setTimeout(function () {
        releaseEventBlock();
    }, SCROLL_BLOCKING_RESET_DELAY);
}
function animate(curScrollTop, targetScrollTop, syncCallbacks) {
    var diff = targetScrollTop - curScrollTop;
    var startTime = Date.now();
    var step = function () {
        var stepTime = Date.now();
        var progress = (stepTime - startTime) / ANIMATION_TIME;
        var deltaValue;
        if (currentTimeoutId) {
            clearTimeout(currentTimeoutId);
        }
        if (progress < 1) {
            deltaValue = curScrollTop + diff * Math.cos(((1 - progress) * Math.PI) / 2);
            run(Math.ceil(deltaValue), syncCallbacks);
            currentTimeoutId = setTimeout(step, 1);
        }
        else {
            run(targetScrollTop, syncCallbacks);
            currentTimeoutId = null;
        }
    };
    step();
}

;// CONCATENATED MODULE: ./src/markdown/scroll/scrollSync.ts




var EDITOR_BOTTOM_PADDING = 18;
var ScrollSync = /** @class */ (function () {
    function ScrollSync(mdEditor, preview, eventEmitter) {
        this.latestEditorScrollTop = null;
        this.latestPreviewScrollTop = null;
        this.blockedScroll = null;
        this.active = true;
        this.timer = null;
        var previewRoot = preview.previewContent, previewEl = preview.el;
        this.previewRoot = previewRoot;
        this.previewEl = previewEl;
        this.mdEditor = mdEditor;
        this.editorView = mdEditor.view;
        this.toastMark = mdEditor.getToastMark();
        this.eventEmitter = eventEmitter;
        this.addScrollSyncEvent();
    }
    ScrollSync.prototype.addScrollSyncEvent = function () {
        var _this = this;
        this.eventEmitter.listen('afterPreviewRender', function () {
            _this.clearTimer();
            // Immediately after the 'afterPreviewRender' event has occurred,
            // browser rendering is not yet complete.
            // So the size of elements can not be accurately measured.
            _this.timer = setTimeout(function () {
                _this.syncPreviewScrollTop(true);
            }, 200);
        });
        this.eventEmitter.listen('scroll', function (type, data) {
            if (_this.active) {
                if (type === 'editor' && _this.blockedScroll !== 'editor') {
                    _this.syncPreviewScrollTop();
                }
                else if (type === 'preview' && _this.blockedScroll !== 'preview') {
                    _this.syncEditorScrollTop(data);
                }
            }
        });
        this.eventEmitter.listen('toggleScrollSync', function (active) {
            _this.active = active;
        });
    };
    ScrollSync.prototype.getMdNodeAtPos = function (doc, posInfo) {
        var indexInfo = doc.content.findIndex(posInfo.pos);
        var line = indexInfo.index;
        return this.toastMark.findFirstNodeAtLine(line + 1);
    };
    ScrollSync.prototype.getScrollTopByCaretPos = function () {
        var pos = this.mdEditor.getSelection();
        var firstMdNode = this.toastMark.findFirstNodeAtLine(pos[0][0]);
        var previewHeight = this.previewEl.clientHeight;
        var el = getParentNodeObj(this.previewRoot, firstMdNode).el;
        var totalOffsetTop = getTotalOffsetTop(el, this.previewRoot) || el.offsetTop;
        var nodeHeight = el.clientHeight;
        // multiply 0.5 for calculating the position in the middle of preview area
        var targetScrollTop = totalOffsetTop + nodeHeight - previewHeight * 0.5;
        this.latestEditorScrollTop = null;
        var diff = el.getBoundingClientRect().top - this.previewEl.getBoundingClientRect().top;
        return diff < previewHeight ? null : targetScrollTop;
    };
    ScrollSync.prototype.syncPreviewScrollTop = function (editing) {
        if (editing === void 0) { editing = false; }
        var _a = this, editorView = _a.editorView, previewEl = _a.previewEl, previewRoot = _a.previewRoot;
        var _b = editorView.dom.getBoundingClientRect(), left = _b.left, top = _b.top;
        var posInfo = editorView.posAtCoords({ left: left, top: top });
        var doc = editorView.state.doc;
        var firstMdNode = this.getMdNodeAtPos(doc, posInfo);
        if (!firstMdNode || isHTMLNode(firstMdNode)) {
            return;
        }
        var curScrollTop = previewEl.scrollTop;
        var _c = editorView.dom, scrollTop = _c.scrollTop, scrollHeight = _c.scrollHeight, clientHeight = _c.clientHeight, children = _c.children;
        var isBottomPos = scrollHeight - scrollTop <= clientHeight + EDITOR_BOTTOM_PADDING;
        var targetScrollTop = isBottomPos ? previewEl.scrollHeight : 0;
        if (scrollTop && !isBottomPos) {
            if (editing) {
                var scrollTopByEditing = this.getScrollTopByCaretPos();
                if (!scrollTopByEditing) {
                    return;
                }
                targetScrollTop = scrollTopByEditing;
            }
            else {
                var _d = getParentNodeObj(this.previewRoot, firstMdNode), el = _d.el, mdNode = _d.mdNode;
                var _e = getEditorRangeHeightInfo(doc, mdNode, children), height = _e.height, rect = _e.rect;
                var totalOffsetTop = getTotalOffsetTop(el, previewRoot) || el.offsetTop;
                var nodeHeight = el.clientHeight;
                var ratio = top > rect.top ? Math.min((top - rect.top) / height, 1) : 0;
                targetScrollTop = totalOffsetTop + nodeHeight * ratio;
            }
            targetScrollTop = this.getResolvedScrollTop('editor', scrollTop, targetScrollTop, curScrollTop);
            this.latestEditorScrollTop = scrollTop;
        }
        if (targetScrollTop !== curScrollTop) {
            this.run('editor', targetScrollTop, curScrollTop);
        }
    };
    ScrollSync.prototype.syncEditorScrollTop = function (targetNode) {
        var _a = this, toastMark = _a.toastMark, editorView = _a.editorView, previewRoot = _a.previewRoot, previewEl = _a.previewEl;
        var dom = editorView.dom, state = editorView.state;
        var scrollTop = previewEl.scrollTop, clientHeight = previewEl.clientHeight, scrollHeight = previewEl.scrollHeight;
        var isBottomPos = scrollHeight - scrollTop <= clientHeight;
        var curScrollTop = dom.scrollTop;
        var targetScrollTop = isBottomPos ? dom.scrollHeight : 0;
        if (scrollTop && targetNode && !isBottomPos) {
            targetNode = findAncestorHavingId(targetNode, previewRoot);
            if (!targetNode.getAttribute('data-nodeid')) {
                return;
            }
            var children = dom.children;
            var mdNodeId = Number(targetNode.getAttribute('data-nodeid'));
            var _b = getParentNodeObj(this.previewRoot, toastMark.findNodeById(mdNodeId)), mdNode = _b.mdNode, el = _b.el;
            var mdNodeStartLine = getMdStartLine(mdNode);
            targetScrollTop = children[mdNodeStartLine - 1].offsetTop;
            var height = getEditorRangeHeightInfo(state.doc, mdNode, children).height;
            var _c = getAndSaveOffsetInfo(el, previewRoot, mdNodeId), nodeHeight = _c.nodeHeight, offsetTop = _c.offsetTop;
            targetScrollTop += getAdditionalPos(scrollTop, offsetTop, nodeHeight, height);
            targetScrollTop = this.getResolvedScrollTop('preview', scrollTop, targetScrollTop, curScrollTop);
            this.latestPreviewScrollTop = scrollTop;
        }
        if (targetScrollTop !== curScrollTop) {
            this.run('preview', targetScrollTop, curScrollTop);
        }
    };
    ScrollSync.prototype.getResolvedScrollTop = function (from, scrollTop, targetScrollTop, curScrollTop) {
        var latestScrollTop = from === 'editor' ? this.latestEditorScrollTop : this.latestPreviewScrollTop;
        if (latestScrollTop === null) {
            return targetScrollTop;
        }
        return latestScrollTop < scrollTop
            ? Math.max(targetScrollTop, curScrollTop)
            : Math.min(targetScrollTop, curScrollTop);
    };
    ScrollSync.prototype.run = function (from, targetScrollTop, curScrollTop) {
        var _this = this;
        var scrollTarget;
        if (from === 'editor') {
            scrollTarget = this.previewEl;
            this.blockedScroll = 'preview';
        }
        else {
            scrollTarget = this.editorView.dom;
            this.blockedScroll = 'editor';
        }
        var syncCallbacks = {
            syncScrollTop: function (scrollTop) { return (scrollTarget.scrollTop = scrollTop); },
            releaseEventBlock: function () { return (_this.blockedScroll = null); },
        };
        animate(curScrollTop, targetScrollTop, syncCallbacks);
    };
    ScrollSync.prototype.clearTimer = function () {
        if (this.timer) {
            clearTimeout(this.timer);
            this.timer = null;
        }
    };
    ScrollSync.prototype.destroy = function () {
        this.clearTimer();
        this.eventEmitter.removeEventHandler('scroll');
        this.eventEmitter.removeEventHandler('afterPreviewRender');
    };
    return ScrollSync;
}());


;// CONCATENATED MODULE: ./src/queries/queryManager.ts
var queryMap = {
    getPopupInitialValues: function (editor, payload) {
        var popupName = payload.popupName;
        return popupName === 'link' ? { linkText: editor.getSelectedText() } : {};
    },
};
function buildQuery(editor) {
    editor.eventEmitter.listen('query', function (query, payload) {
        return queryMap[query](editor, payload);
    });
}

;// CONCATENATED MODULE: ./src/editorCore.ts






























/**
 * ToastUIEditorCore
 * @param {Object} options Option object
 *     @param {HTMLElement} options.el - container element
 *     @param {string} [options.height='300px'] - Editor's height style value. Height is applied as border-box ex) '300px', '100%', 'auto'
 *     @param {string} [options.minHeight='200px'] - Editor's min-height style value in pixel ex) '300px'
 *     @param {string} [options.initialValue] - Editor's initial value
 *     @param {string} [options.previewStyle] - Markdown editor's preview style (tab, vertical)
 *     @param {boolean} [options.previewHighlight = true] - Highlight a preview element corresponds to the cursor position in the markdown editor
 *     @param {string} [options.initialEditType] - Initial editor type (markdown, wysiwyg)
 *     @param {Object} [options.events] - Events
 *         @param {function} [options.events.load] - It would be emitted when editor fully load
 *         @param {function} [options.events.change] - It would be emitted when content changed
 *         @param {function} [options.events.caretChange] - It would be emitted when format change by cursor position
 *         @param {function} [options.events.focus] - It would be emitted when editor get focus
 *         @param {function} [options.events.blur] - It would be emitted when editor loose focus
 *         @param {function} [options.events.keydown] - It would be emitted when the key is pressed in editor
 *         @param {function} [options.events.keyup] - It would be emitted when the key is released in editor
 *         @param {function} [options.events.beforePreviewRender] - It would be emitted before rendering the markdown preview with html string
 *         @param {function} [options.events.beforeConvertWysiwygToMarkdown] - It would be emitted before converting wysiwyg to markdown with markdown text
 *     @param {Object} [options.hooks] - Hooks
 *         @param {addImageBlobHook} [options.hooks.addImageBlobHook] - hook for image upload
 *     @param {string} [options.language='en-US'] - language
 *     @param {boolean} [options.useCommandShortcut=true] - whether use keyboard shortcuts to perform commands
 *     @param {boolean} [options.usageStatistics=true] - send hostname to google analytics
 *     @param {Array.<string|toolbarItemsValue>} [options.toolbarItems] - toolbar items.
 *     @param {boolean} [options.hideModeSwitch=false] - hide mode switch tab bar
 *     @param {Array.<function|Array>} [options.plugins] - Array of plugins. A plugin can be either a function or an array in the form of [function, options].
 *     @param {Object} [options.extendedAutolinks] - Using extended Autolinks specified in GFM spec
 *     @param {string} [options.placeholder] - The placeholder text of the editable element.
 *     @param {Object} [options.linkAttributes] - Attributes of anchor element that should be rel, target, hreflang, type
 *     @param {Object} [options.customHTMLRenderer=null] - Object containing custom renderer functions correspond to change markdown node to preview HTML or wysiwyg node
 *     @param {Object} [options.customMarkdownRenderer=null] - Object containing custom renderer functions correspond to change wysiwyg node to markdown text
 *     @param {boolean} [options.referenceDefinition=false] - whether use the specification of link reference definition
 *     @param {function} [options.customHTMLSanitizer=null] - custom HTML sanitizer
 *     @param {boolean} [options.previewHighlight=false] - whether highlight preview area
 *     @param {boolean} [options.frontMatter=false] - whether use the front matter
 *     @param {Array.<object>} [options.widgetRules=[]] - The rules for replacing the text with widget node
 *     @param {string} [options.theme] - The theme to style the editor with. The default is included in toastui-editor.css.
 *     @param {autofocus} [options.autofocus=true] - automatically focus the editor on creation.
 */
var ToastUIEditorCore = /** @class */ (function () {
    function ToastUIEditorCore(options) {
        var _this = this;
        this.initialHTML = options.el.innerHTML;
        options.el.innerHTML = '';
        this.options = extend_default()({
            previewStyle: 'tab',
            previewHighlight: true,
            initialEditType: 'markdown',
            height: '300px',
            minHeight: '200px',
            language: 'en-US',
            useCommandShortcut: true,
            usageStatistics: true,
            toolbarItems: [
                ['heading', 'bold', 'italic', 'strike'],
                ['hr', 'quote'],
                ['ul', 'ol', 'task', 'indent', 'outdent'],
                ['table', 'image', 'link'],
                ['code', 'codeblock'],
                ['scrollSync'],
            ],
            hideModeSwitch: false,
            linkAttributes: null,
            extendedAutolinks: false,
            customHTMLRenderer: null,
            customMarkdownRenderer: null,
            referenceDefinition: false,
            customHTMLSanitizer: null,
            frontMatter: false,
            widgetRules: [],
            theme: 'light',
            autofocus: true,
        }, options);
        var _a = this.options, customHTMLRenderer = _a.customHTMLRenderer, extendedAutolinks = _a.extendedAutolinks, referenceDefinition = _a.referenceDefinition, frontMatter = _a.frontMatter, customMarkdownRenderer = _a.customMarkdownRenderer, useCommandShortcut = _a.useCommandShortcut, initialEditType = _a.initialEditType, widgetRules = _a.widgetRules, customHTMLSanitizer = _a.customHTMLSanitizer;
        this.mode = initialEditType || 'markdown';
        this.mdPreviewStyle = this.options.previewStyle;
        this.i18n = i18n;
        this.i18n.setCode(this.options.language);
        this.eventEmitter = new eventEmitter();
        setWidgetRules(widgetRules);
        var linkAttributes = sanitizeLinkAttribute(this.options.linkAttributes);
        this.pluginInfo = getPluginInfo({
            plugins: this.options.plugins,
            eventEmitter: this.eventEmitter,
            usageStatistics: this.options.usageStatistics,
            instance: this,
        });
        var _b = this.pluginInfo, toHTMLRenderers = _b.toHTMLRenderers, toMarkdownRenderers = _b.toMarkdownRenderers, mdPlugins = _b.mdPlugins, wwPlugins = _b.wwPlugins, wwNodeViews = _b.wwNodeViews, mdCommands = _b.mdCommands, wwCommands = _b.wwCommands, markdownParsers = _b.markdownParsers;
        var rendererOptions = {
            linkAttributes: linkAttributes,
            customHTMLRenderer: deepMergedCopy(toHTMLRenderers, customHTMLRenderer),
            extendedAutolinks: extendedAutolinks,
            referenceDefinition: referenceDefinition,
            frontMatter: frontMatter,
            sanitizer: customHTMLSanitizer || sanitizeHTML,
        };
        var wwToDOMAdaptor = new WwToDOMAdaptor(linkAttributes, rendererOptions.customHTMLRenderer);
        var htmlSchemaMap = createHTMLSchemaMap(rendererOptions.customHTMLRenderer, rendererOptions.sanitizer, wwToDOMAdaptor);
        this.toastMark = new ToastMark('', {
            disallowedHtmlBlockTags: ['br', 'img'],
            extendedAutolinks: extendedAutolinks,
            referenceDefinition: referenceDefinition,
            disallowDeepHeading: true,
            frontMatter: frontMatter,
            customParser: markdownParsers,
        });
        this.mdEditor = new mdEditor(this.eventEmitter, {
            toastMark: this.toastMark,
            useCommandShortcut: useCommandShortcut,
            mdPlugins: mdPlugins,
        });
        this.preview = new mdPreview(this.eventEmitter, __assign(__assign({}, rendererOptions), { isViewer: false, highlight: this.options.previewHighlight }));
        this.wwEditor = new wwEditor(this.eventEmitter, {
            toDOMAdaptor: wwToDOMAdaptor,
            useCommandShortcut: useCommandShortcut,
            htmlSchemaMap: htmlSchemaMap,
            linkAttributes: linkAttributes,
            wwPlugins: wwPlugins,
            wwNodeViews: wwNodeViews,
        });
        this.convertor = new convertor(this.wwEditor.getSchema(), __assign(__assign({}, toMarkdownRenderers), customMarkdownRenderer), getHTMLRenderConvertors(linkAttributes, rendererOptions.customHTMLRenderer), this.eventEmitter);
        this.setMinHeight(this.options.minHeight);
        this.setHeight(this.options.height);
        this.setMarkdown(this.options.initialValue, false);
        if (this.options.placeholder) {
            this.setPlaceholder(this.options.placeholder);
        }
        if (!this.options.initialValue) {
            this.setHTML(this.initialHTML, false);
        }
        this.commandManager = new commandManager(this.eventEmitter, this.mdEditor.commands, this.wwEditor.commands, function () { return _this.mode; });
        if (this.options.usageStatistics) {
            sendHostName();
        }
        this.scrollSync = new ScrollSync(this.mdEditor, this.preview, this.eventEmitter);
        this.addInitEvent();
        this.addInitCommand(mdCommands, wwCommands);
        buildQuery(this);
        if (this.options.hooks) {
            forEachOwnProperties_default()(this.options.hooks, function (fn, key) { return _this.addHook(key, fn); });
        }
        if (this.options.events) {
            forEachOwnProperties_default()(this.options.events, function (fn, key) { return _this.on(key, fn); });
        }
        this.eventEmitter.emit('load', this);
        this.moveCursorToStart(this.options.autofocus);
    }
    ToastUIEditorCore.prototype.addInitEvent = function () {
        var _this = this;
        this.on('needChangeMode', this.changeMode.bind(this));
        this.on('loadUI', function () {
            if (_this.height !== 'auto') {
                // 75px equals default editor ui height - the editing area height
                var minHeight = Math.min(parseInt(_this.minHeight, 10), parseInt(_this.height, 10) - 75) + "px";
                _this.setMinHeight(minHeight);
            }
        });
        addDefaultImageBlobHook(this.eventEmitter);
    };
    ToastUIEditorCore.prototype.addInitCommand = function (mdCommands, wwCommands) {
        var _this = this;
        var addPluginCommands = function (type, commandMap) {
            Object.keys(commandMap).forEach(function (name) {
                _this.addCommand(type, name, commandMap[name]);
            });
        };
        this.addCommand('markdown', 'toggleScrollSync', function (payload) {
            _this.eventEmitter.emit('toggleScrollSync', payload.active);
            return true;
        });
        addPluginCommands('markdown', mdCommands);
        addPluginCommands('wysiwyg', wwCommands);
    };
    ToastUIEditorCore.prototype.getCurrentModeEditor = function () {
        return (this.isMarkdownMode() ? this.mdEditor : this.wwEditor);
    };
    /**
     * Factory method for Editor
     * @param {object} options Option for initialize TUIEditor
     * @returns {object} ToastUIEditorCore or ToastUIEditorViewer
     */
    ToastUIEditorCore.factory = function (options) {
        return options.viewer ? new viewer(options) : new ToastUIEditorCore(options);
    };
    /**
     * Set language
     * @param {string|string[]} code - code for I18N language
     * @param {object} data - language set
     */
    ToastUIEditorCore.setLanguage = function (code, data) {
        i18n.setLanguage(code, data);
    };
    /**
     * change preview style
     * @param {string} style - 'tab'|'vertical'
     */
    ToastUIEditorCore.prototype.changePreviewStyle = function (style) {
        if (this.mdPreviewStyle !== style) {
            this.mdPreviewStyle = style;
            this.eventEmitter.emit('changePreviewStyle', style);
        }
    };
    /**
     * execute editor command
     * @param {string} name - command name
     * @param {object} [payload] - payload for command
     */
    ToastUIEditorCore.prototype.exec = function (name, payload) {
        this.commandManager.exec(name, payload);
    };
    /**
     * @param {string} type - editor type
     * @param {string} name - command name
     * @param {function} command - command handler
     */
    ToastUIEditorCore.prototype.addCommand = function (type, name, command) {
        var _this = this;
        var commandHoc = function (paylaod) {
            if (paylaod === void 0) { paylaod = {}; }
            var view = (type === 'markdown' ? _this.mdEditor : _this.wwEditor).view;
            command(paylaod, view.state, view.dispatch, view);
        };
        this.commandManager.addCommand(type, name, commandHoc);
    };
    /**
     * Bind eventHandler to event type
     * @param {string} type Event type
     * @param {function} handler Event handler
     */
    ToastUIEditorCore.prototype.on = function (type, handler) {
        this.eventEmitter.listen(type, handler);
    };
    /**
     * Unbind eventHandler from event type
     * @param {string} type Event type
     */
    ToastUIEditorCore.prototype.off = function (type) {
        this.eventEmitter.removeEventHandler(type);
    };
    /**
     * Add hook to TUIEditor event
     * @param {string} type Event type
     * @param {function} handler Event handler
     */
    ToastUIEditorCore.prototype.addHook = function (type, handler) {
        this.eventEmitter.removeEventHandler(type);
        this.eventEmitter.listen(type, handler);
    };
    /**
     * Remove hook from TUIEditor event
     * @param {string} type Event type
     */
    ToastUIEditorCore.prototype.removeHook = function (type) {
        this.eventEmitter.removeEventHandler(type);
    };
    /**
     * Set focus to current Editor
     */
    ToastUIEditorCore.prototype.focus = function () {
        this.getCurrentModeEditor().focus();
    };
    /**
     * Remove focus of current Editor
     */
    ToastUIEditorCore.prototype.blur = function () {
        this.getCurrentModeEditor().blur();
    };
    /**
     * Set cursor position to end
     * @param {boolean} [focus] - automatically focus the editor
     */
    ToastUIEditorCore.prototype.moveCursorToEnd = function (focus) {
        if (focus === void 0) { focus = true; }
        this.getCurrentModeEditor().moveCursorToEnd(focus);
    };
    /**
     * Set cursor position to start
     * @param {boolean} [focus] - automatically focus the editor
     */
    ToastUIEditorCore.prototype.moveCursorToStart = function (focus) {
        if (focus === void 0) { focus = true; }
        this.getCurrentModeEditor().moveCursorToStart(focus);
    };
    /**
     * Set markdown syntax text.
     * @param {string} markdown - markdown syntax text.
     * @param {boolean} [cursorToEnd=true] - move cursor to contents end
     */
    ToastUIEditorCore.prototype.setMarkdown = function (markdown, cursorToEnd) {
        if (markdown === void 0) { markdown = ''; }
        if (cursorToEnd === void 0) { cursorToEnd = true; }
        this.mdEditor.setMarkdown(markdown, cursorToEnd);
        if (this.isWysiwygMode()) {
            var mdNode = this.toastMark.getRootNode();
            var wwNode = this.convertor.toWysiwygModel(mdNode);
            this.wwEditor.setModel(wwNode, cursorToEnd);
        }
    };
    /**
     * Set html value.
     * @param {string} html - html syntax text
     * @param {boolean} [cursorToEnd=true] - move cursor to contents end
     */
    ToastUIEditorCore.prototype.setHTML = function (html, cursorToEnd) {
        if (html === void 0) { html = ''; }
        if (cursorToEnd === void 0) { cursorToEnd = true; }
        var container = document.createElement('div');
        // the `br` tag should be replaced with empty block to separate between blocks
        container.innerHTML = replaceBRWithEmptyBlock(html);
        var wwNode = external_commonjs_prosemirror_model_commonjs2_prosemirror_model_amd_prosemirror_model_.DOMParser.fromSchema(this.wwEditor.schema).parse(container);
        if (this.isMarkdownMode()) {
            this.mdEditor.setMarkdown(this.convertor.toMarkdownText(wwNode), cursorToEnd);
        }
        else {
            this.wwEditor.setModel(wwNode, cursorToEnd);
        }
    };
    /**
     * Get content to markdown
     * @returns {string} markdown text
     */
    ToastUIEditorCore.prototype.getMarkdown = function () {
        if (this.isMarkdownMode()) {
            return this.mdEditor.getMarkdown();
        }
        return this.convertor.toMarkdownText(this.wwEditor.getModel());
    };
    /**
     * Get content to html
     * @returns {string} html string
     */
    ToastUIEditorCore.prototype.getHTML = function () {
        var _this = this;
        this.eventEmitter.holdEventInvoke(function () {
            if (_this.isMarkdownMode()) {
                var mdNode = _this.toastMark.getRootNode();
                var wwNode = _this.convertor.toWysiwygModel(mdNode);
                _this.wwEditor.setModel(wwNode);
            }
        });
        var html = removeProseMirrorHackNodes(this.wwEditor.view.dom.innerHTML);
        if (this.placeholder) {
            var rePlaceholder = new RegExp("<span class=\"placeholder[^>]+>" + this.placeholder + "</span>", 'i');
            return html.replace(rePlaceholder, '');
        }
        return html;
    };
    /**
     * Insert text
     * @param {string} text - text content
     */
    ToastUIEditorCore.prototype.insertText = function (text) {
        this.getCurrentModeEditor().replaceSelection(text);
    };
    /**
     * Set selection range
     * @param {number|Array.<number>} start - start position
     * @param {number|Array.<number>} end - end position
     */
    ToastUIEditorCore.prototype.setSelection = function (start, end) {
        this.getCurrentModeEditor().setSelection(start, end);
    };
    /**
     * Replace selection range with given text content
     * @param {string} text - text content
     * @param {number|Array.<number>} [start] - start position
     * @param {number|Array.<number>} [end] - end position
     */
    ToastUIEditorCore.prototype.replaceSelection = function (text, start, end) {
        this.getCurrentModeEditor().replaceSelection(text, start, end);
    };
    /**
     * Delete the content of selection range
     * @param {number|Array.<number>} [start] - start position
     * @param {number|Array.<number>} [end] - end position
     */
    ToastUIEditorCore.prototype.deleteSelection = function (start, end) {
        this.getCurrentModeEditor().deleteSelection(start, end);
    };
    /**
     * Get selected text content
     * @param {number|Array.<number>} [start] - start position
     * @param {number|Array.<number>} [end] - end position
     * @returns {string} - selected text content
     */
    ToastUIEditorCore.prototype.getSelectedText = function (start, end) {
        return this.getCurrentModeEditor().getSelectedText(start, end);
    };
    /**
     * Get range of the node
     * @param {number|Array.<number>} [pos] - position
     * @returns {Array.<number[]>|Array.<number>} - node [start, end] range
     * @example
     * // Markdown mode
     * const rangeInfo = editor.getRangeInfoOfNode();
     *
     * console.log(rangeInfo); // { range: [[startLineOffset, startCurorOffset], [endLineOffset, endCurorOffset]], type: 'emph' }
     *
     * // WYSIWYG mode
     * const rangeInfo = editor.getRangeInfoOfNode();
     *
     * console.log(rangeInfo); // { range: [startCursorOffset, endCursorOffset], type: 'emph' }
     */
    ToastUIEditorCore.prototype.getRangeInfoOfNode = function (pos) {
        return this.getCurrentModeEditor().getRangeInfoOfNode(pos);
    };
    /**
     * Add widget to selection
     * @param {Node} node - widget node
     * @param {string} style - Adding style "top" or "bottom"
     * @param {number|Array.<number>} [pos] - position
     */
    ToastUIEditorCore.prototype.addWidget = function (node, style, pos) {
        this.getCurrentModeEditor().addWidget(node, style, pos);
    };
    /**
     * Replace node with widget to range
     * @param {number|Array.<number>} start - start position
     * @param {number|Array.<number>} end - end position
     * @param {string} text - widget text content
     */
    ToastUIEditorCore.prototype.replaceWithWidget = function (start, end, text) {
        this.getCurrentModeEditor().replaceWithWidget(start, end, text);
    };
    /**
     * Set editor height
     * @param {string} height - editor height in pixel
     */
    ToastUIEditorCore.prototype.setHeight = function (height) {
        var el = this.options.el;
        if (isString_default()(height)) {
            if (height === 'auto') {
                addClass_default()(el, 'auto-height');
            }
            else {
                removeClass_default()(el, 'auto-height');
            }
            this.setMinHeight(this.getMinHeight());
        }
        css_default()(el, { height: height });
        this.height = height;
    };
    /**
     * Get editor height
     * @returns {string} editor height in pixel
     */
    ToastUIEditorCore.prototype.getHeight = function () {
        return this.height;
    };
    /**
     * Set minimum height to editor content
     * @param {string} minHeight - min content height in pixel
     */
    ToastUIEditorCore.prototype.setMinHeight = function (minHeight) {
        if (minHeight !== this.minHeight) {
            var height = this.height || this.options.height;
            if (height !== 'auto' && this.options.el.querySelector("." + cls('main'))) {
                // 75px equals default editor ui height - the editing area height
                minHeight = Math.min(parseInt(minHeight, 10), parseInt(height, 10) - 75) + "px";
            }
            var minHeightNum = parseInt(minHeight, 10);
            this.minHeight = minHeight;
            this.wwEditor.setMinHeight(minHeightNum);
            this.mdEditor.setMinHeight(minHeightNum);
            this.preview.setMinHeight(minHeightNum);
        }
    };
    /**
     * Get minimum height of editor content
     * @returns {string} min height in pixel
     */
    ToastUIEditorCore.prototype.getMinHeight = function () {
        return this.minHeight;
    };
    /**
     * Return true if current editor mode is Markdown
     * @returns {boolean}
     */
    ToastUIEditorCore.prototype.isMarkdownMode = function () {
        return this.mode === 'markdown';
    };
    /**
     * Return true if current editor mode is WYSIWYG
     * @returns {boolean}
     */
    ToastUIEditorCore.prototype.isWysiwygMode = function () {
        return this.mode === 'wysiwyg';
    };
    /**
     * Return false
     * @returns {boolean}
     */
    ToastUIEditorCore.prototype.isViewer = function () {
        return false;
    };
    /**
     * Get current Markdown editor's preview style
     * @returns {string}
     */
    ToastUIEditorCore.prototype.getCurrentPreviewStyle = function () {
        return this.mdPreviewStyle;
    };
    /**
     * Change editor's mode to given mode string
     * @param {string} mode - Editor mode name of want to change
     * @param {boolean} [withoutFocus] - Change mode without focus
     */
    ToastUIEditorCore.prototype.changeMode = function (mode, withoutFocus) {
        if (this.mode === mode) {
            return;
        }
        this.mode = mode;
        if (this.isWysiwygMode()) {
            var mdNode = this.toastMark.getRootNode();
            var wwNode = this.convertor.toWysiwygModel(mdNode);
            this.wwEditor.setModel(wwNode);
        }
        else {
            var wwNode = this.wwEditor.getModel();
            this.mdEditor.setMarkdown(this.convertor.toMarkdownText(wwNode), !withoutFocus);
        }
        this.eventEmitter.emit('removePopupWidget');
        this.eventEmitter.emit('changeMode', mode);
        if (!withoutFocus) {
            var pos = this.convertor.getMappedPos();
            this.focus();
            if (this.isWysiwygMode() && isNumber_default()(pos)) {
                this.wwEditor.setSelection(pos);
            }
            else if (Array.isArray(pos)) {
                this.mdEditor.setSelection(pos);
            }
        }
    };
    /**
     * Destroy TUIEditor from document
     */
    ToastUIEditorCore.prototype.destroy = function () {
        var _this = this;
        this.wwEditor.destroy();
        this.mdEditor.destroy();
        this.preview.destroy();
        this.scrollSync.destroy();
        this.eventEmitter.emit('destroy');
        this.eventEmitter.getEvents().forEach(function (_, type) { return _this.off(type); });
    };
    /**
     * Hide TUIEditor
     */
    ToastUIEditorCore.prototype.hide = function () {
        this.eventEmitter.emit('hide');
    };
    /**
     * Show TUIEditor
     */
    ToastUIEditorCore.prototype.show = function () {
        this.eventEmitter.emit('show');
    };
    /**
     * Move on scroll position of the editor container
     * @param {number} value scrollTop value of editor container
     */
    ToastUIEditorCore.prototype.setScrollTop = function (value) {
        this.getCurrentModeEditor().setScrollTop(value);
    };
    /**
     * Get scroll position value of editor container
     * @returns {number} scrollTop value of editor container
     */
    ToastUIEditorCore.prototype.getScrollTop = function () {
        return this.getCurrentModeEditor().getScrollTop();
    };
    /**
     * Reset TUIEditor
     */
    ToastUIEditorCore.prototype.reset = function () {
        this.wwEditor.setModel([]);
        this.mdEditor.setMarkdown('');
    };
    /**
     * Get current selection range
     * @returns {Array.<number[]>|Array.<number>} Returns the range of the selection depending on the editor mode
     * @example
     * // Markdown mode
     * const mdSelection = editor.getSelection();
     *
     * console.log(mdSelection); // [[startLineOffset, startCurorOffset], [endLineOffset, endCurorOffset]]
     *
     * // WYSIWYG mode
     * const wwSelection = editor.getSelection();
     *
     * console.log(wwSelection); // [startCursorOffset, endCursorOffset]
     */
    ToastUIEditorCore.prototype.getSelection = function () {
        return this.getCurrentModeEditor().getSelection();
    };
    /**
     * Set the placeholder on all editors
     * @param {string} placeholder - placeholder to set
     */
    ToastUIEditorCore.prototype.setPlaceholder = function (placeholder) {
        this.placeholder = placeholder;
        this.mdEditor.setPlaceholder(placeholder);
        this.wwEditor.setPlaceholder(placeholder);
    };
    /**
     * Get markdown editor, preview, wysiwyg editor DOM elements
     */
    ToastUIEditorCore.prototype.getEditorElements = function () {
        return {
            mdEditor: this.mdEditor.getElement(),
            mdPreview: this.preview.getElement(),
            wwEditor: this.wwEditor.getElement(),
        };
    };
    /**
     * Convert position to match editor mode
     * @param {number|Array.<number>} start - start position
     * @param {number|Array.<number>} end - end position
     * @param {string} mode - Editor mode name of want to match converted position to
     */
    ToastUIEditorCore.prototype.convertPosToMatchEditorMode = function (start, end, mode) {
        var _a, _b;
        if (end === void 0) { end = start; }
        if (mode === void 0) { mode = this.mode; }
        var doc = this.mdEditor.view.state.doc;
        var isFromArray = Array.isArray(start);
        var isToArray = Array.isArray(end);
        var convertedFrom = start;
        var convertedTo = end;
        if (isFromArray !== isToArray) {
            throw new Error('Types of arguments must be same');
        }
        if (mode === 'markdown' && !isFromArray && !isToArray) {
            _a = getEditorToMdPos(doc, start, end), convertedFrom = _a[0], convertedTo = _a[1];
        }
        else if (mode === 'wysiwyg' && isFromArray && isToArray) {
            _b = getMdToEditorPos(doc, start, end), convertedFrom = _b[0], convertedTo = _b[1];
        }
        return [convertedFrom, convertedTo];
    };
    return ToastUIEditorCore;
}());
// // (Not an official API)
// // Create a function converting markdown to HTML using the internal parser and renderer.
// ToastUIEditor._createMarkdownToHTML = createMarkdownToHTML;
/* harmony default export */ var editorCore = (ToastUIEditorCore);

;// CONCATENATED MODULE: ./src/ui/vdom/htm.js

// @TODO: change syntax with our convention
/* eslint-disable */
/* harmony default export */ function htm(n) {
    for (var l, e, s = arguments, t = 1, r = '', u = '', a = [0], c = function (n) {
        t === 1 && (n || (r = r.replace(/^\s*\n\s*|\s*\n\s*$/g, '')))
            ? a.push(n ? s[n] : r)
            : t === 3 && (n || r)
                ? ((a[1] = n ? s[n] : r), (t = 2))
                : t === 2 && r === '...' && n
                    ? (a[2] = common_assign(a[2] || {}, s[n]))
                    : t === 2 && r && !n
                        ? ((a[2] = a[2] || {})[r] = !0)
                        : t >= 5 &&
                            (t === 5
                                ? (((a[2] = a[2] || {})[e] = n ? (r ? r + s[n] : s[n]) : r), (t = 6))
                                : (n || r) && (a[2][e] += n ? r + s[n] : r)),
            (r = '');
    }, h = 0; h < n.length; h++) {
        h && (t === 1 && c(), c(h));
        for (var i = 0; i < n[h].length; i++)
            (l = n[h][i]),
                t === 1
                    ? l === '<'
                        ? (c(), (a = [a, '', null]), (t = 3))
                        : (r += l)
                    : t === 4
                        ? r === '--' && l === '>'
                            ? ((t = 1), (r = ''))
                            : (r = l + r[0])
                        : u
                            ? l === u
                                ? (u = '')
                                : (r += l)
                            : l === '"' || l === "'"
                                ? (u = l)
                                : l === '>'
                                    ? (c(), (t = 1))
                                    : t &&
                                        (l === '='
                                            ? ((t = 5), (e = r), (r = ''))
                                            : l === '/' && (t < 5 || n[h][i + 1] === '>')
                                                ? (c(),
                                                    t === 3 && (a = a[0]),
                                                    (t = a),
                                                    (a = a[0]).push(this.apply(null, t.slice(1))),
                                                    (t = 0))
                                                : l === ' ' || l === '\t' || l === '\n' || l === '\r'
                                                    ? (c(), (t = 2))
                                                    : (r += l)),
                t === 3 && r === '!--' && ((t = 4), (a = a[0]));
    }
    return c(), a.length > 2 ? a.slice(1) : a[1];
}

// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isBoolean.js
var isBoolean = __nested_webpack_require_93901__(326);
var isBoolean_default = /*#__PURE__*/__nested_webpack_require_93901__.n(isBoolean);
;// CONCATENATED MODULE: ./src/ui/vdom/vnode.ts
var VNodeWalker = /** @class */ (function () {
    function VNodeWalker(current) {
        this.current = current;
        this.root = current;
        this.entering = true;
    }
    VNodeWalker.prototype.walk = function () {
        var _a = this, entering = _a.entering, cur = _a.current;
        if (!cur) {
            return null;
        }
        if (entering) {
            if (cur.firstChild) {
                this.current = cur.firstChild;
                this.entering = true;
            }
            else {
                this.entering = false;
            }
        }
        else if (cur === this.root) {
            this.current = null;
        }
        else if (cur.next) {
            this.current = cur.next;
            this.entering = true;
        }
        else {
            this.current = cur.parent;
            this.entering = false;
        }
        return { vnode: cur, entering: entering };
    };
    return VNodeWalker;
}());
var VNode = /** @class */ (function () {
    function VNode(type, props, children) {
        this.parent = null;
        this.old = null;
        this.firstChild = null;
        this.next = null;
        this.skip = false;
        this.type = type;
        this.props = props;
        this.children = children;
        this.props.children = children;
        if (props.ref) {
            this.ref = props.ref;
            delete props.ref;
        }
        if (props.key) {
            this.key = props.key;
            delete props.key;
        }
    }
    VNode.prototype.walker = function () {
        return new VNodeWalker(this);
    };
    VNode.removalNodes = [];
    return VNode;
}());


;// CONCATENATED MODULE: ./src/ui/vdom/template.ts





function template_createTextNode(text) {
    return new VNode('TEXT_NODE', { nodeValue: text }, []);
}
function excludeUnnecessaryChild(child, flatted) {
    var vnode = child;
    // eslint-disable-next-line no-eq-null,eqeqeq
    if (isBoolean_default()(child) || child == null) {
        vnode = null;
    }
    else if (isString_default()(child) || isNumber_default()(child)) {
        vnode = template_createTextNode(String(child));
    }
    if (vnode) {
        flatted.push(vnode);
    }
}
function h(type, props) {
    var children = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        children[_i - 2] = arguments[_i];
    }
    var flatted = [];
    children.forEach(function (child) {
        if (Array.isArray(child)) {
            child.forEach(function (vnode) {
                excludeUnnecessaryChild(vnode, flatted);
            });
        }
        else {
            excludeUnnecessaryChild(child, flatted);
        }
    });
    return new VNode(type, props || {}, flatted);
}
// @ts-ignore
/* harmony default export */ var template = (htm.bind(h));

// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/type/isObject.js
var type_isObject = __nested_webpack_require_93901__(73);
var isObject_default = /*#__PURE__*/__nested_webpack_require_93901__.n(type_isObject);
;// CONCATENATED MODULE: ./src/ui/vdom/dom.ts




// @TODO: clearfy the type definition for CSSDeclaration
function dom_createNode(vnode) {
    var node;
    if (vnode.type === 'TEXT_NODE') {
        node = document.createTextNode(vnode.props.nodeValue);
    }
    else {
        node = document.createElement(vnode.type);
        setProps(node, {}, vnode.props);
    }
    return node;
}
function dom_removeNode(vnode, parentNode) {
    if (vnode.node) {
        parentNode.removeChild(vnode.node);
    }
    else {
        dom_removeNode(vnode.firstChild, parentNode);
    }
}
function innerDiff(node, prevProps, nextProps) {
    Object.keys(prevProps).forEach(function (propName) {
        if (/^on/.test(propName)) {
            if (!nextProps[propName] || prevProps[propName] !== nextProps[propName]) {
                var eventName = propName.slice(2).toLowerCase();
                node.removeEventListener(eventName, prevProps[propName]);
            }
        }
        else if (propName !== 'children' && !nextProps[propName] && !isTextNode(node)) {
            node.removeAttribute(propName);
        }
    });
    setProps(node, prevProps, nextProps, function (propName) { return !shallowEqual(prevProps[propName], nextProps[propName]); });
}
var reNonDimension = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
function setProps(node, prevProps, props, condition) {
    Object.keys(props).forEach(function (propName) {
        if (!condition || condition(propName)) {
            if (/^on/.test(propName)) {
                var eventName = propName.slice(2).toLowerCase();
                node.addEventListener(eventName, props[propName]);
            }
            else if (propName === 'nodeValue') {
                node[propName] = props[propName];
            }
            else if (propName === 'style' && isObject_default()(props[propName])) {
                setStyleProps(node, prevProps[propName], props[propName]);
            }
            else if (propName !== 'children') {
                if (props[propName] === false) {
                    node.removeAttribute(propName);
                }
                else {
                    node.setAttribute(propName, props[propName]);
                }
            }
        }
    });
}
function setStyleProps(node, prevStyleProps, styleProps) {
    if (prevStyleProps) {
        Object.keys(prevStyleProps).forEach(function (styleProp) {
            // @ts-ignore
            node.style[styleProp] = '';
        });
    }
    Object.keys(styleProps).forEach(function (styleProp) {
        var value = styleProps[styleProp];
        // @ts-ignore
        node.style[styleProp] =
            isNumber_default()(value) && !reNonDimension.test(styleProp) ? value + "px" : value;
    });
}

;// CONCATENATED MODULE: ./src/ui/vdom/commit.ts



function commit(vnode) {
    VNode.removalNodes.forEach(function (removalNode) { return diff(removalNode); });
    if (vnode) {
        var next = void 0;
        var walker = vnode.walker();
        while ((next = walker.walk())) {
            vnode = next.vnode;
            if (next.entering) {
                diff(vnode);
            }
            else if (isFunction_default()(vnode.type)) {
                var comp = vnode.component;
                // lifecycle method
                if (!vnode.old && comp.mounted) {
                    comp.mounted();
                }
                if (vnode.old && comp.updated) {
                    var prevProps = comp.prevProps || {};
                    comp.updated(prevProps);
                }
            }
        }
    }
}
function getParentNode(vnode) {
    var parent = vnode.parent;
    while (!parent.node) {
        parent = parent.parent;
    }
    return parent.node;
}
function diff(vnode) {
    if (!vnode || !vnode.parent) {
        return;
    }
    if (vnode.node) {
        var parentNode = getParentNode(vnode);
        if (vnode.effect === 'A') {
            parentNode.appendChild(vnode.node);
        }
        else if (vnode.effect === 'U') {
            innerDiff(vnode.node, vnode.old.props, vnode.props);
        }
    }
    if (vnode.effect === 'D') {
        var next = void 0;
        var walker = vnode.walker();
        while ((next = walker.walk())) {
            vnode = next.vnode;
            if (!next.entering) {
                if (isFunction_default()(vnode.type)) {
                    var comp = vnode.component;
                    // lifecycle method
                    if (comp.beforeDestroy) {
                        comp.beforeDestroy();
                    }
                }
                else {
                    var parentNode = getParentNode(vnode);
                    dom_removeNode(vnode, parentNode);
                }
            }
        }
    }
    // apply ref
    if (vnode.ref) {
        if (vnode.component) {
            vnode.ref(vnode.component);
        }
        else if (vnode.node) {
            vnode.ref(vnode.node);
        }
    }
}

;// CONCATENATED MODULE: ./src/ui/vdom/render.ts




function createComponent(Comp, vnode) {
    var props = vnode.props, component = vnode.component;
    if (component) {
        component.prevProps = component.props;
        component.props = vnode.props;
        return component;
    }
    return new Comp(props);
}
function buildVNode(vnode) {
    var root = vnode;
    while (vnode && !vnode.skip) {
        if (isFunction_default()(vnode.type)) {
            var instance = createComponent(vnode.type, vnode);
            instance.vnode = vnode;
            vnode.component = instance;
            vnode.props.children = vnode.children = [instance.render()];
            buildChildrenVNode(vnode);
        }
        else {
            if (!vnode.node) {
                vnode.node = dom_createNode(vnode);
            }
            buildChildrenVNode(vnode);
        }
        if (vnode.firstChild) {
            vnode = vnode.firstChild;
        }
        else {
            while (vnode && vnode.parent && !vnode.next) {
                vnode = vnode.parent;
                if (vnode === root) {
                    break;
                }
            }
            vnode = vnode.next;
        }
    }
}
function isSameType(old, vnode) {
    return old && vnode && vnode.type === old.type && (!vnode.key || vnode.key === old.key);
}
// @TODO: add key diff algorithm
function buildChildrenVNode(parent) {
    var children = parent.children;
    var old = parent.old ? parent.old.firstChild : null;
    var prev = null;
    children.forEach(function (vnode, index) {
        var sameType = isSameType(old, vnode);
        if (sameType) {
            vnode.old = old;
            vnode.parent = parent;
            vnode.node = old.node;
            vnode.component = old.component;
            vnode.effect = 'U';
        }
        if (vnode && !sameType) {
            vnode.old = null;
            vnode.parent = parent;
            vnode.node = null;
            vnode.effect = 'A';
        }
        if (old && !sameType) {
            VNode.removalNodes.push(old);
            old.effect = 'D';
        }
        if (old) {
            old = old.next;
        }
        if (index === 0) {
            parent.firstChild = vnode;
        }
        else if (vnode) {
            prev.next = vnode;
        }
        prev = vnode;
    });
    var lastChild = last(children);
    if (!children.length) {
        while (old) {
            VNode.removalNodes.push(old);
            old.effect = 'D';
            old = old.next;
        }
    }
    while (old && lastChild) {
        if (old && lastChild.old !== old) {
            VNode.removalNodes.push(old);
            old.effect = 'D';
            old = old.next;
        }
    }
}

;// CONCATENATED MODULE: ./src/ui/vdom/renderer.ts



function destroy(vnode) {
    vnode.effect = 'D';
    VNode.removalNodes = [vnode];
    commit();
    VNode.removalNodes = [];
}
function rerender(comp) {
    var root = comp.vnode;
    root.effect = 'U';
    root.old = root;
    // skip for unnecessary reconciliation
    if (root.next) {
        root.next.skip = true;
    }
    VNode.removalNodes = [];
    buildVNode(root);
    commit(root);
    if (root.next) {
        root.next.skip = false;
    }
}
function render(container, vnode) {
    var root = new VNode(container.tagName.toLowerCase(), {}, [vnode]);
    root.node = container;
    VNode.removalNodes = [];
    buildVNode(root);
    commit(root);
    return function () { return destroy(root.firstChild); };
}

;// CONCATENATED MODULE: ./src/ui/vdom/component.ts



var Component = /** @class */ (function () {
    function Component(props) {
        this.props = props;
        this.state = {};
        this.refs = {};
    }
    Component.prototype.setState = function (state) {
        var newState = __assign(__assign({}, this.state), state);
        if (!shallowEqual(this.state, newState)) {
            this.state = newState;
            rerender(this);
        }
    };
    return Component;
}());


;// CONCATENATED MODULE: ./src/ui/components/switch.ts





var Switch = /** @class */ (function (_super) {
    __extends(Switch, _super);
    function Switch(props) {
        var _this = _super.call(this, props) || this;
        _this.state = {
            hide: false,
        };
        return _this;
    }
    Switch.prototype.show = function () {
        this.setState({ hide: false });
    };
    Switch.prototype.hide = function () {
        this.setState({ hide: true });
    };
    Switch.prototype.render = function () {
        var _a = this.props, editorType = _a.editorType, eventEmitter = _a.eventEmitter;
        return template(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n      <div class=\"", "\" style=\"display: ", "\">\n        <div\n          class=\"tab-item", "\"\n          onClick=", "\n        >\n          ", "\n        </div>\n        <div\n          class=\"tab-item", "\"\n          onClick=", "\n        >\n          ", "\n        </div>\n      </div>\n    "], ["\n      <div class=\"", "\" style=\"display: ", "\">\n        <div\n          class=\"tab-item", "\"\n          onClick=",
            "\n        >\n          ", "\n        </div>\n        <div\n          class=\"tab-item", "\"\n          onClick=",
            "\n        >\n          ", "\n        </div>\n      </div>\n    "])), cls('mode-switch'), this.state.hide ? 'none' : 'block', editorType === 'markdown' ? ' active' : '', function () {
            eventEmitter.emit('needChangeMode', 'markdown');
        }, i18n.get('Markdown'), editorType === 'wysiwyg' ? ' active' : '', function () {
            eventEmitter.emit('needChangeMode', 'wysiwyg');
        }, i18n.get('WYSIWYG'));
    };
    return Switch;
}(Component));

var templateObject_1;

// EXTERNAL MODULE: ../../node_modules/tui-code-snippet/tricks/throttle.js
var throttle = __nested_webpack_require_93901__(423);
var throttle_default = /*#__PURE__*/__nested_webpack_require_93901__.n(throttle);
;// CONCATENATED MODULE: ../../node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof __nested_webpack_require_93901__.g !== 'undefined' && __nested_webpack_require_93901__.g.Math === Math) {
        return __nested_webpack_require_93901__.g;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function ResizeObserver_es_throttle (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = ResizeObserver_es_throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver;
})();

/* harmony default export */ var ResizeObserver_es = (index);

;// CONCATENATED MODULE: ./src/ui/components/toolbar/headingPopupBody.ts





var HeadingPopupBody = /** @class */ (function (_super) {
    __extends(HeadingPopupBody, _super);
    function HeadingPopupBody() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    HeadingPopupBody.prototype.execCommand = function (ev) {
        var el = closest(ev.target, 'li');
        this.props.execCommand('heading', {
            level: Number(el.getAttribute('data-level')),
        });
    };
    HeadingPopupBody.prototype.render = function () {
        var _this = this;
        return template(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n      <ul\n        onClick=", "\n        aria-role=\"menu\"\n        aria-label=\"", "\"\n      >\n        ", "\n        <li data-type=\"Paragraph\" aria-role=\"menuitem\">\n          <div>", "</div>\n        </li>\n      </ul>\n    "], ["\n      <ul\n        onClick=", "\n        aria-role=\"menu\"\n        aria-label=\"", "\"\n      >\n        ",
            "\n        <li data-type=\"Paragraph\" aria-role=\"menuitem\">\n          <div>", "</div>\n        </li>\n      </ul>\n    "])), function (ev) { return _this.execCommand(ev); }, i18n.get('Headings'), [1, 2, 3, 4, 5, 6].map(function (level) {
            return template(headingPopupBody_templateObject_1 || (headingPopupBody_templateObject_1 = __makeTemplateObject(["\n              <li data-level=\"", "\" data-type=\"Heading\" aria-role=\"menuitem\">\n                <", ">", " ", "</$>\n              </li>\n            "], ["\n              <li data-level=\"", "\" data-type=\"Heading\" aria-role=\"menuitem\">\n                <", ">", " ", "</$>\n              </li>\n            "])), level, "h" + level, i18n.get('Heading'), level);
        }), i18n.get('Paragraph'));
    };
    return HeadingPopupBody;
}(Component));

var headingPopupBody_templateObject_1, templateObject_2;

;// CONCATENATED MODULE: ./src/ui/components/tabs.ts





var Tabs = /** @class */ (function (_super) {
    __extends(Tabs, _super);
    function Tabs() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Tabs.prototype.toggleTab = function (ev, activeTab) {
        this.props.onClick(ev, activeTab);
    };
    Tabs.prototype.render = function () {
        var _this = this;
        return template(tabs_templateObject_2 || (tabs_templateObject_2 = __makeTemplateObject(["\n      <div class=\"", "\" aria-role=\"tabpanel\">\n        ", "\n      </div>\n    "], ["\n      <div class=\"", "\" aria-role=\"tabpanel\">\n        ",
            "\n      </div>\n    "])), cls('tabs'), this.props.tabs.map(function (_a) {
            var name = _a.name, text = _a.text;
            var isActive = _this.props.activeTab === name;
            return template(tabs_templateObject_1 || (tabs_templateObject_1 = __makeTemplateObject(["\n            <div\n              class=\"tab-item", "\"\n              onClick=", "\n              aria-role=\"tab\"\n              aria-label=\"", "\"\n              aria-selected=\"", "\"\n              tabindex=\"", "\"\n            >\n              ", "\n            </div>\n          "], ["\n            <div\n              class=\"tab-item", "\"\n              onClick=", "\n              aria-role=\"tab\"\n              aria-label=\"", "\"\n              aria-selected=\"", "\"\n              tabindex=\"", "\"\n            >\n              ", "\n            </div>\n          "])), isActive ? ' active' : '', function (ev) { return _this.toggleTab(ev, name); }, i18n.get(text), isActive ? 'true' : 'false', isActive ? '0' : '-1', i18n.get(text));
        }));
    };
    return Tabs;
}(Component));

var tabs_templateObject_1, tabs_templateObject_2;

;// CONCATENATED MODULE: ./src/ui/components/toolbar/imagePopupBody.ts








var TYPE_UI = 'ui';
var ImagePopupBody = /** @class */ (function (_super) {
    __extends(ImagePopupBody, _super);
    function ImagePopupBody(props) {
        var _this = _super.call(this, props) || this;
        _this.initialize = function (activeTab) {
            if (activeTab === void 0) { activeTab = 'file'; }
            var urlEl = _this.refs.url;
            urlEl.value = '';
            _this.refs.altText.value = '';
            _this.refs.file.value = '';
            removeClass_default()(urlEl, 'wrong');
            _this.setState({ activeTab: activeTab, file: null, fileNameElClassName: '' });
        };
        _this.execCommand = function () {
            if (_this.state.activeTab === 'file') {
                _this.emitAddImageBlob();
            }
            else {
                _this.emitAddImage();
            }
        };
        _this.toggleTab = function (_, activeTab) {
            if (activeTab !== _this.state.activeTab) {
                _this.initialize(activeTab);
            }
        };
        _this.showFileSelectBox = function () {
            _this.refs.file.click();
        };
        _this.changeFile = function (ev) {
            var files = ev.target.files;
            if (files === null || files === void 0 ? void 0 : files.length) {
                _this.setState({ file: files[0] });
            }
        };
        _this.state = { activeTab: 'file', file: null, fileNameElClassName: '' };
        _this.tabs = [
            { name: 'file', text: 'File' },
            { name: 'url', text: 'URL' },
        ];
        return _this;
    }
    ImagePopupBody.prototype.emitAddImageBlob = function () {
        var _this = this;
        var files = this.refs.file.files;
        var altTextEl = this.refs.altText;
        var fileNameElClassName = ' wrong';
        if (files === null || files === void 0 ? void 0 : files.length) {
            fileNameElClassName = '';
            var imageFile = files.item(0);
            var hookCallback = function (url, text) {
                return _this.props.execCommand('addImage', { imageUrl: url, altText: text || altTextEl.value });
            };
            this.props.eventEmitter.emit('addImageBlobHook', imageFile, hookCallback, TYPE_UI);
        }
        this.setState({ fileNameElClassName: fileNameElClassName });
    };
    ImagePopupBody.prototype.emitAddImage = function () {
        var imageUrlEl = this.refs.url;
        var altTextEl = this.refs.altText;
        var imageUrl = imageUrlEl.value;
        var altText = altTextEl.value || 'image';
        removeClass_default()(imageUrlEl, 'wrong');
        if (!imageUrl.length) {
            addClass_default()(imageUrlEl, 'wrong');
            return;
        }
        if (imageUrl) {
            this.props.execCommand('addImage', { imageUrl: imageUrl, altText: altText });
        }
    };
    ImagePopupBody.prototype.preventSelectStart = function (ev) {
        ev.preventDefault();
    };
    ImagePopupBody.prototype.updated = function () {
        if (!this.props.show) {
            this.initialize();
        }
    };
    ImagePopupBody.prototype.render = function () {
        var _this = this;
        var _a = this.state, activeTab = _a.activeTab, file = _a.file, fileNameElClassName = _a.fileNameElClassName;
        return template(imagePopupBody_templateObject_1 || (imagePopupBody_templateObject_1 = __makeTemplateObject(["\n      <div aria-label=\"", "\">\n        <", " tabs=", " activeTab=", " onClick=", " />\n        <div style=\"display:", "\">\n          <label for=\"toastuiImageUrlInput\">", "</label>\n          <input\n            id=\"toastuiImageUrlInput\"\n            type=\"text\"\n            ref=", "\n          />\n        </div>\n        <div style=\"display:", ";position: relative;\">\n          <label for=\"toastuiImageFileInput\">", "</label>\n          <span\n            class=\"", "", "\"\n            onClick=", "\n            onSelectstart=", "\n          >\n            ", "\n          </span>\n          <button\n            type=\"button\"\n            class=\"", "\"\n            onClick=", "\n          >\n            ", "\n          </button>\n          <input\n            id=\"toastuiImageFileInput\"\n            type=\"file\"\n            accept=\"image/*\"\n            onChange=", "\n            ref=", "\n          />\n        </div>\n        <label for=\"toastuiAltTextInput\">", "</label>\n        <input\n          id=\"toastuiAltTextInput\"\n          type=\"text\"\n          ref=", "\n        />\n        <div class=\"", "\">\n          <button type=\"button\" class=\"", "\" onClick=", ">\n            ", "\n          </button>\n          <button type=\"button\" class=\"", "\" onClick=", ">\n            ", "\n          </button>\n        </div>\n      </div>\n    "], ["\n      <div aria-label=\"", "\">\n        <", " tabs=", " activeTab=", " onClick=", " />\n        <div style=\"display:", "\">\n          <label for=\"toastuiImageUrlInput\">", "</label>\n          <input\n            id=\"toastuiImageUrlInput\"\n            type=\"text\"\n            ref=", "\n          />\n        </div>\n        <div style=\"display:", ";position: relative;\">\n          <label for=\"toastuiImageFileInput\">", "</label>\n          <span\n            class=\"", "", "\"\n            onClick=", "\n            onSelectstart=", "\n          >\n            ", "\n          </span>\n          <button\n            type=\"button\"\n            class=\"", "\"\n            onClick=", "\n          >\n            ", "\n          </button>\n          <input\n            id=\"toastuiImageFileInput\"\n            type=\"file\"\n            accept=\"image/*\"\n            onChange=", "\n            ref=", "\n          />\n        </div>\n        <label for=\"toastuiAltTextInput\">", "</label>\n        <input\n          id=\"toastuiAltTextInput\"\n          type=\"text\"\n          ref=", "\n        />\n        <div class=\"", "\">\n          <button type=\"button\" class=\"", "\" onClick=", ">\n            ", "\n          </button>\n          <button type=\"button\" class=\"", "\" onClick=", ">\n            ", "\n          </button>\n        </div>\n      </div>\n    "])), i18n.get('Insert image'), Tabs, this.tabs, activeTab, this.toggleTab, activeTab === 'url' ? 'block' : 'none', i18n.get('Image URL'), function (el) { return (_this.refs.url = el); }, activeTab === 'file' ? 'block' : 'none', i18n.get('Select image file'), cls('file-name'), file ? ' has-file' : fileNameElClassName, this.showFileSelectBox, this.preventSelectStart, file ? file.name : i18n.get('No file'), cls('file-select-button'), this.showFileSelectBox, i18n.get('Choose a file'), this.changeFile, function (el) { return (_this.refs.file = el); }, i18n.get('Description'), function (el) { return (_this.refs.altText = el); }, cls('button-container'), cls('close-button'), this.props.hidePopup, i18n.get('Cancel'), cls('ok-button'), this.execCommand, i18n.get('OK'));
    };
    return ImagePopupBody;
}(Component));

var imagePopupBody_templateObject_1;

;// CONCATENATED MODULE: ./src/ui/components/toolbar/linkPopupBody.ts








var LinkPopupBody = /** @class */ (function (_super) {
    __extends(LinkPopupBody, _super);
    function LinkPopupBody() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.execCommand = function () {
            var linkUrlEl = _this.refs.url;
            var linkTextEl = _this.refs.text;
            removeClass_default()(linkUrlEl, 'wrong');
            removeClass_default()(linkTextEl, 'wrong');
            if (linkUrlEl.value.length < 1) {
                addClass_default()(linkUrlEl, 'wrong');
                return;
            }
            var checkLinkText = isUndefined_default()(_this.props.initialValues.linkUrl);
            if (checkLinkText && linkTextEl.value.length < 1) {
                addClass_default()(linkTextEl, 'wrong');
                return;
            }
            _this.props.execCommand('addLink', {
                linkUrl: linkUrlEl.value,
                linkText: linkTextEl.value,
            });
        };
        return _this;
    }
    LinkPopupBody.prototype.initialize = function () {
        var _a = this.props.initialValues, linkUrl = _a.linkUrl, linkText = _a.linkText;
        var linkUrlEl = this.refs.url;
        var linkTextEl = this.refs.text;
        removeClass_default()(linkUrlEl, 'wrong');
        removeClass_default()(linkTextEl, 'wrong', 'disabled');
        linkTextEl.removeAttribute('disabled');
        if (linkUrl) {
            addClass_default()(linkTextEl, 'disabled');
            linkTextEl.setAttribute('disabled', 'disabled');
        }
        linkUrlEl.value = linkUrl || '';
        linkTextEl.value = linkText || '';
    };
    LinkPopupBody.prototype.mounted = function () {
        this.initialize();
    };
    LinkPopupBody.prototype.updated = function (prevProps) {
        if (!prevProps.show && this.props.show) {
            this.initialize();
        }
    };
    LinkPopupBody.prototype.render = function () {
        var _this = this;
        return template(linkPopupBody_templateObject_1 || (linkPopupBody_templateObject_1 = __makeTemplateObject(["\n      <div aria-label=\"", "\">\n        <label for=\"toastuiLinkUrlInput\">", "</label>\n        <input\n          id=\"toastuiLinkUrlInput\"\n          type=\"text\"\n          ref=", "\n        />\n        <label for=\"toastuiLinkTextInput\">", "</label>\n        <input\n          id=\"toastuiLinkTextInput\"\n          type=\"text\"\n          ref=", "\n        />\n        <div class=\"", "\">\n          <button type=\"button\" class=\"", "\" onClick=", ">\n            ", "\n          </button>\n          <button type=\"button\" class=\"", "\" onClick=", ">\n            ", "\n          </button>\n        </div>\n      </div>\n    "], ["\n      <div aria-label=\"", "\">\n        <label for=\"toastuiLinkUrlInput\">", "</label>\n        <input\n          id=\"toastuiLinkUrlInput\"\n          type=\"text\"\n          ref=", "\n        />\n        <label for=\"toastuiLinkTextInput\">", "</label>\n        <input\n          id=\"toastuiLinkTextInput\"\n          type=\"text\"\n          ref=", "\n        />\n        <div class=\"", "\">\n          <button type=\"button\" class=\"", "\" onClick=", ">\n            ", "\n          </button>\n          <button type=\"button\" class=\"", "\" onClick=", ">\n            ", "\n          </button>\n        </div>\n      </div>\n    "])), i18n.get('Insert link'), i18n.get('URL'), function (el) { return (_this.refs.url = el); }, i18n.get('Link text'), function (el) { return (_this.refs.text = el); }, cls('button-container'), cls('close-button'), this.props.hidePopup, i18n.get('Cancel'), cls('ok-button'), this.execCommand, i18n.get('OK'));
    };
    return LinkPopupBody;
}(Component));

var linkPopupBody_templateObject_1;

;// CONCATENATED MODULE: ./src/ui/components/toolbar/tablePopupBody.ts





var CELL_WIDTH = 20;
var CELL_HEIGHT = 20;
var MIN_ROW_INDEX = 5;
var MAX_ROW_INDEX = 14;
var MIN_COL_INDEX = 5;
var MAX_COL_INDEX = 9;
var MIN_ROW_SELECTION_INDEX = 1;
var MIN_COL_SELECTION_INDEX = 1;
var BORDER_WIDTH = 1;
var TablePopupBody = /** @class */ (function (_super) {
    __extends(TablePopupBody, _super);
    function TablePopupBody(props) {
        var _this = _super.call(this, props) || this;
        _this.extendSelectionRange = function (_a) {
            var pageX = _a.pageX, pageY = _a.pageY;
            var x = pageX - _this.offsetRect.left;
            var y = pageY - _this.offsetRect.top;
            var range = _this.getSelectionRangeByOffset(x, y);
            _this.setState(__assign({}, range));
        };
        _this.execCommand = function () {
            _this.props.execCommand('addTable', {
                rowCount: _this.state.rowIdx + 1,
                columnCount: _this.state.colIdx + 1,
            });
        };
        _this.state = {
            rowIdx: -1,
            colIdx: -1,
        };
        return _this;
    }
    TablePopupBody.prototype.getDescription = function () {
        return this.state.colIdx === -1 ? '' : this.state.colIdx + 1 + " x " + (this.state.rowIdx + 1);
    };
    TablePopupBody.prototype.getBoundByRange = function (colIdx, rowIdx) {
        return {
            width: (colIdx + 1) * CELL_WIDTH,
            height: (rowIdx + 1) * CELL_HEIGHT,
        };
    };
    TablePopupBody.prototype.getRangeByOffset = function (x, y) {
        return {
            colIdx: Math.floor(x / CELL_WIDTH),
            rowIdx: Math.floor(y / CELL_HEIGHT),
        };
    };
    TablePopupBody.prototype.getTableRange = function () {
        var _a = this.state, orgColIdx = _a.colIdx, orgRowIdx = _a.rowIdx;
        var colIdx = Math.max(orgColIdx, MIN_COL_INDEX);
        var rowIdx = Math.max(orgRowIdx, MIN_ROW_INDEX);
        if (orgColIdx >= MIN_COL_INDEX && colIdx < MAX_COL_INDEX) {
            colIdx += 1;
        }
        if (orgRowIdx >= MIN_ROW_INDEX && rowIdx < MAX_ROW_INDEX) {
            rowIdx += 1;
        }
        return { colIdx: colIdx + 1, rowIdx: rowIdx + 1 };
    };
    TablePopupBody.prototype.getSelectionAreaBound = function () {
        var _a = this.getBoundByRange(this.state.colIdx, this.state.rowIdx), width = _a.width, height = _a.height;
        if (!width && !height) {
            return { display: 'none' };
        }
        return { width: width - BORDER_WIDTH, height: height - BORDER_WIDTH, display: 'block' };
    };
    TablePopupBody.prototype.getSelectionRangeByOffset = function (x, y) {
        var range = this.getRangeByOffset(x, y);
        range.rowIdx = Math.min(Math.max(range.rowIdx, MIN_ROW_SELECTION_INDEX), MAX_ROW_INDEX);
        range.colIdx = Math.min(Math.max(range.colIdx, MIN_COL_SELECTION_INDEX), MAX_COL_INDEX);
        return range;
    };
    TablePopupBody.prototype.updated = function () {
        if (!this.props.show) {
            this.setState({ colIdx: -1, rowIdx: -1 });
        }
        else if (this.state.colIdx === -1 && this.state.rowIdx === -1) {
            var _a = this.refs.tableEl.getBoundingClientRect(), left = _a.left, top = _a.top;
            this.offsetRect = {
                left: window.pageXOffset + left,
                top: window.pageYOffset + top,
            };
        }
    };
    TablePopupBody.prototype.createTableArea = function (tableRange) {
        var colIdx = tableRange.colIdx, rowIdx = tableRange.rowIdx;
        var rows = [];
        for (var i = 0; i < rowIdx; i += 1) {
            var cells = [];
            for (var j = 0; j < colIdx; j += 1) {
                var cellClassNames = "" + cls('table-cell') + (i > 0 ? '' : ' header');
                cells.push(template(tablePopupBody_templateObject_1 || (tablePopupBody_templateObject_1 = __makeTemplateObject(["<div class=\"", "\"></div>"], ["<div class=\"", "\"></div>"])), cellClassNames));
            }
            rows.push(template(tablePopupBody_templateObject_2 || (tablePopupBody_templateObject_2 = __makeTemplateObject(["<div class=\"", "\">", "</div>"], ["<div class=\"", "\">", "</div>"])), cls('table-row'), cells));
        }
        return template(templateObject_3 || (templateObject_3 = __makeTemplateObject(["<div class=\"", "\">", "</div>"], ["<div class=\"", "\">", "</div>"])), cls('table'), rows);
    };
    TablePopupBody.prototype.render = function () {
        var _this = this;
        var tableRange = this.getTableRange();
        var selectionAreaBound = this.getSelectionAreaBound();
        return template(templateObject_4 || (templateObject_4 = __makeTemplateObject(["\n      <div aria-label=\"", "\">\n        <div\n          class=\"", "\"\n          ref=", "\n          onMousemove=", "\n          onClick=", "\n        >\n          ", "\n          <div class=\"", "\" style=", "></div>\n        </div>\n        <p class=\"", "\">", "</p>\n      </div>\n    "], ["\n      <div aria-label=\"", "\">\n        <div\n          class=\"", "\"\n          ref=", "\n          onMousemove=", "\n          onClick=", "\n        >\n          ", "\n          <div class=\"", "\" style=", "></div>\n        </div>\n        <p class=\"", "\">", "</p>\n      </div>\n    "])), i18n.get('Insert table'), cls('table-selection'), function (el) { return (_this.refs.tableEl = el); }, this.extendSelectionRange, this.execCommand, this.createTableArea(tableRange), cls('table-selection-layer'), selectionAreaBound, cls('table-description'), this.getDescription());
    };
    return TablePopupBody;
}(Component));

var tablePopupBody_templateObject_1, tablePopupBody_templateObject_2, templateObject_3, templateObject_4;

;// CONCATENATED MODULE: ./src/ui/components/toolbar/customPopupBody.ts



var CustomPopupBody = /** @class */ (function (_super) {
    __extends(CustomPopupBody, _super);
    function CustomPopupBody() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CustomPopupBody.prototype.mounted = function () {
        // append the custom popup body element
        this.refs.el.appendChild(this.props.body);
    };
    CustomPopupBody.prototype.updated = function (prevProps) {
        // update custom popup element
        this.refs.el.replaceChild(this.props.body, prevProps.body);
    };
    CustomPopupBody.prototype.render = function () {
        var _this = this;
        return template(customPopupBody_templateObject_1 || (customPopupBody_templateObject_1 = __makeTemplateObject(["<div ref=", "></div>"], ["<div ref=", "></div>"])), function (el) { return (_this.refs.el = el); });
    };
    return CustomPopupBody;
}(Component));

var customPopupBody_templateObject_1;

;// CONCATENATED MODULE: ./src/ui/toolbarItemFactory.ts












function createToolbarItemInfo(type) {
    return isString_default()(type) ? createDefaultToolbarItemInfo(type) : type;
}
function createScrollSyncToolbarItem() {
    var label = document.createElement('label');
    var checkbox = document.createElement('input');
    var toggleSwitch = document.createElement('span');
    label.className = 'scroll-sync active';
    checkbox.type = 'checkbox';
    checkbox.checked = true;
    toggleSwitch.className = 'switch';
    var onMounted = function (execCommand) {
        return checkbox.addEventListener('change', function (ev) {
            var checked = ev.target.checked;
            if (checked) {
                addClass_default()(label, 'active');
            }
            else {
                removeClass_default()(label, 'active');
            }
            execCommand('toggleScrollSync', { active: checked });
        });
    };
    label.appendChild(checkbox);
    label.appendChild(toggleSwitch);
    return {
        name: 'scrollSync',
        el: label,
        onMounted: onMounted,
    };
}
function createDefaultToolbarItemInfo(type) {
    var info;
    switch (type) {
        case 'heading':
            info = {
                name: 'heading',
                className: 'heading',
                tooltip: i18n.get('Headings'),
                state: 'heading',
            };
            break;
        case 'bold':
            info = {
                name: 'bold',
                className: 'bold',
                command: 'bold',
                tooltip: i18n.get('Bold'),
                state: 'strong',
            };
            break;
        case 'italic':
            info = {
                name: 'italic',
                className: 'italic',
                command: 'italic',
                tooltip: i18n.get('Italic'),
                state: 'emph',
            };
            break;
        case 'strike':
            info = {
                name: 'strike',
                className: 'strike',
                command: 'strike',
                tooltip: i18n.get('Strike'),
                state: 'strike',
            };
            break;
        case 'hr':
            info = {
                name: 'hr',
                className: 'hrline',
                command: 'hr',
                tooltip: i18n.get('Line'),
                state: 'thematicBreak',
            };
            break;
        case 'quote':
            info = {
                name: 'quote',
                className: 'quote',
                command: 'blockQuote',
                tooltip: i18n.get('Blockquote'),
                state: 'blockQuote',
            };
            break;
        case 'ul':
            info = {
                name: 'ul',
                className: 'bullet-list',
                command: 'bulletList',
                tooltip: i18n.get('Unordered list'),
                state: 'bulletList',
            };
            break;
        case 'ol':
            info = {
                name: 'ol',
                className: 'ordered-list',
                command: 'orderedList',
                tooltip: i18n.get('Ordered list'),
                state: 'orderedList',
            };
            break;
        case 'task':
            info = {
                name: 'task',
                className: 'task-list',
                command: 'taskList',
                tooltip: i18n.get('Task'),
                state: 'taskList',
            };
            break;
        case 'table':
            info = {
                name: 'table',
                className: 'table',
                tooltip: i18n.get('Insert table'),
                state: 'table',
            };
            break;
        case 'image':
            info = {
                name: 'image',
                className: 'image',
                tooltip: i18n.get('Insert image'),
            };
            break;
        case 'link':
            info = {
                name: 'link',
                className: 'link',
                tooltip: i18n.get('Insert link'),
            };
            break;
        case 'code':
            info = {
                name: 'code',
                className: 'code',
                command: 'code',
                tooltip: i18n.get('Code'),
                state: 'code',
            };
            break;
        case 'codeblock':
            info = {
                name: 'codeblock',
                className: 'codeblock',
                command: 'codeBlock',
                tooltip: i18n.get('Insert CodeBlock'),
                state: 'codeBlock',
            };
            break;
        case 'indent':
            info = {
                name: 'indent',
                className: 'indent',
                command: 'indent',
                tooltip: i18n.get('Indent'),
                state: 'indent',
            };
            break;
        case 'outdent':
            info = {
                name: 'outdent',
                className: 'outdent',
                command: 'outdent',
                tooltip: i18n.get('Outdent'),
                state: 'outdent',
            };
            break;
        case 'scrollSync':
            info = createScrollSyncToolbarItem();
            break;
        case 'more':
            info = {
                name: 'more',
                className: 'more',
                tooltip: i18n.get('More'),
            };
            break;
        default:
        // do nothing
    }
    if (info.name !== 'scrollSync') {
        info.className += " " + cls('toolbar-icons');
    }
    return info;
}
function createPopupInfo(type, payload) {
    var el = payload.el, pos = payload.pos, popup = payload.popup, initialValues = payload.initialValues;
    switch (type) {
        case 'heading':
            return {
                render: function (props) { return template(toolbarItemFactory_templateObject_1 || (toolbarItemFactory_templateObject_1 = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), HeadingPopupBody, props); },
                className: cls('popup-add-heading'),
                fromEl: el,
                pos: pos,
            };
        case 'link':
            return {
                render: function (props) { return template(toolbarItemFactory_templateObject_2 || (toolbarItemFactory_templateObject_2 = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), LinkPopupBody, props); },
                className: cls('popup-add-link'),
                fromEl: el,
                pos: pos,
                initialValues: initialValues,
            };
        case 'image':
            return {
                render: function (props) { return template(toolbarItemFactory_templateObject_3 || (toolbarItemFactory_templateObject_3 = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), ImagePopupBody, props); },
                className: cls('popup-add-image'),
                fromEl: el,
                pos: pos,
            };
        case 'table':
            return {
                render: function (props) { return template(toolbarItemFactory_templateObject_4 || (toolbarItemFactory_templateObject_4 = __makeTemplateObject(["<", " ...", " />"], ["<", " ...", " />"])), TablePopupBody, props); },
                className: cls('popup-add-table'),
                fromEl: el,
                pos: pos,
            };
        case 'customPopupBody':
            if (!popup) {
                return null;
            }
            return __assign({ render: function (props) { return template(templateObject_5 || (templateObject_5 = __makeTemplateObject(["<", " ...", " body=", " />"], ["<", " ...", " body=", " />"])), CustomPopupBody, props, popup.body); }, fromEl: el, pos: pos }, popup);
        default:
            return null;
    }
}
function setGroupState(group) {
    group.hidden = group.length === group.filter(function (info) { return info.hidden; }).length;
}
function groupToolbarItems(toolbarItems, hiddenScrollSync) {
    var toggleScrollSyncState = function (item) {
        item.hidden = item.name === 'scrollSync' && hiddenScrollSync;
        return item;
    };
    return toolbarItems.reduce(function (acc, item) {
        acc.push(item.map(function (type) { return toggleScrollSyncState(createToolbarItemInfo(type)); }));
        var group = acc[(acc.length || 1) - 1];
        if (group) {
            setGroupState(group);
        }
        return acc;
    }, []);
}
function toggleScrollSync(toolbarItems, hiddenScrollSync) {
    toolbarItems.forEach(function (group) {
        group.forEach(function (item) { return (item.hidden = item.name === 'scrollSync' && hiddenScrollSync); });
        setGroupState(group);
    });
}
var toolbarItemFactory_templateObject_1, toolbarItemFactory_templateObject_2, toolbarItemFactory_templateObject_3, toolbarItemFactory_templateObject_4, templateObject_5;

;// CONCATENATED MODULE: ./src/ui/components/popup.ts





var MARGIN_FROM_RIGHT_SIDE = 20;
var Popup = /** @class */ (function (_super) {
    __extends(Popup, _super);
    function Popup() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.handleMousedown = function (ev) {
            if (!closest(ev.target, "." + cls('popup')) &&
                !closest(ev.target, _this.props.info.fromEl)) {
                _this.props.hidePopup();
            }
        };
        return _this;
    }
    Popup.prototype.mounted = function () {
        document.addEventListener('mousedown', this.handleMousedown);
        this.props.eventEmitter.listen('closePopup', this.props.hidePopup);
    };
    Popup.prototype.beforeDestroy = function () {
        document.removeEventListener('mousedown', this.handleMousedown);
    };
    Popup.prototype.updated = function (prevProps) {
        var _a = this.props, show = _a.show, info = _a.info;
        if (show && info.pos && prevProps.show !== show) {
            var popupPos = __assign({}, info.pos);
            var offsetWidth = this.refs.el.offsetWidth;
            var toolbarEl = closest(this.refs.el, "." + cls('toolbar'));
            var toolbarOffsetWidth = toolbarEl.offsetWidth;
            if (popupPos.left + offsetWidth >= toolbarOffsetWidth) {
                popupPos.left = toolbarOffsetWidth - offsetWidth - MARGIN_FROM_RIGHT_SIDE;
            }
            if (!shallowEqual(this.state.popupPos, popupPos)) {
                this.setState({ popupPos: popupPos });
            }
        }
    };
    Popup.prototype.render = function () {
        var _this = this;
        var _a = this.props, info = _a.info, show = _a.show, hidePopup = _a.hidePopup, eventEmitter = _a.eventEmitter, execCommand = _a.execCommand;
        var _b = info || {}, _c = _b.className, className = _c === void 0 ? '' : _c, style = _b.style, render = _b.render, _d = _b.initialValues, initialValues = _d === void 0 ? {} : _d;
        var popupStyle = __assign(__assign({ display: show ? 'block' : 'none' }, style), this.state.popupPos);
        return template(popup_templateObject_1 || (popup_templateObject_1 = __makeTemplateObject(["\n      <div\n        class=\"", " ", "\"\n        style=", "\n        ref=", "\n        aria-role=\"dialog\"\n      >\n        <div class=\"", "\">\n          ", "\n        </div>\n      </div>\n    "], ["\n      <div\n        class=\"", " ", "\"\n        style=", "\n        ref=", "\n        aria-role=\"dialog\"\n      >\n        <div class=\"", "\">\n          ", "\n        </div>\n      </div>\n    "])), cls('popup'), className, popupStyle, function (el) { return (_this.refs.el = el); }, cls('popup-body'), render && render({ eventEmitter: eventEmitter, show: show, hidePopup: hidePopup, execCommand: execCommand, initialValues: initialValues }));
    };
    return Popup;
}(Component));

var popup_templateObject_1;

;// CONCATENATED MODULE: ./src/ui/components/toolbar/buttonHoc.ts





var TOOLTIP_INDENT = 6;
function connectHOC(WrappedComponent) {
    return /** @class */ (function (_super) {
        __extends(ButtonHOC, _super);
        function ButtonHOC(props) {
            var _this = _super.call(this, props) || this;
            _this.showTooltip = function (el) {
                var tooltip = _this.props.item.tooltip;
                if (!_this.props.disabled && tooltip) {
                    var bound = _this.getBound(el);
                    var left = bound.left + TOOLTIP_INDENT + "px";
                    var top = bound.top + TOOLTIP_INDENT + "px";
                    css_default()(_this.props.tooltipRef.current, { display: 'block', left: left, top: top });
                    _this.props.tooltipRef.current.querySelector('.text').textContent = tooltip;
                }
            };
            _this.hideTooltip = function () {
                css_default()(_this.props.tooltipRef.current, 'display', 'none');
            };
            _this.state = { active: false, disabled: props.disabled };
            _this.addEvent();
            return _this;
        }
        ButtonHOC.prototype.addEvent = function () {
            var _this = this;
            var _a = this.props, item = _a.item, eventEmitter = _a.eventEmitter;
            if (item.state) {
                eventEmitter.listen('changeToolbarState', function (_a) {
                    var _b;
                    var toolbarState = _a.toolbarState;
                    var _c = (_b = toolbarState[item.state]) !== null && _b !== void 0 ? _b : {}, active = _c.active, disabled = _c.disabled;
                    _this.setState({ active: !!active, disabled: disabled !== null && disabled !== void 0 ? disabled : _this.props.disabled });
                });
            }
        };
        ButtonHOC.prototype.getBound = function (el) {
            var _a = getTotalOffset(el, closest(el, "." + cls('toolbar'))), offsetLeft = _a.offsetLeft, offsetTop = _a.offsetTop;
            return { left: offsetLeft, top: el.offsetHeight + offsetTop };
        };
        ButtonHOC.prototype.render = function () {
            return template(buttonHoc_templateObject_1 || (buttonHoc_templateObject_1 = __makeTemplateObject(["\n        <", "\n          ...", "\n          active=", "\n          showTooltip=", "\n          hideTooltip=", "\n          getBound=", "\n          disabled=", "\n        />\n      "], ["\n        <", "\n          ...", "\n          active=", "\n          showTooltip=", "\n          hideTooltip=", "\n          getBound=", "\n          disabled=", "\n        />\n      "])), WrappedComponent, this.props, this.state.active, this.showTooltip, this.hideTooltip, this.getBound, this.state.disabled || this.props.disabled);
        };
        return ButtonHOC;
    }(Component));
}
var buttonHoc_templateObject_1;

;// CONCATENATED MODULE: ./src/ui/components/toolbar/toolbarButton.ts






var DEFAULT_WIDTH = 80;
var ToolbarButtonComp = /** @class */ (function (_super) {
    __extends(ToolbarButtonComp, _super);
    function ToolbarButtonComp() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.showTooltip = function () {
            _this.props.showTooltip(_this.refs.el);
        };
        _this.execCommand = function () {
            var _a = _this.props, item = _a.item, execCommand = _a.execCommand, setPopupInfo = _a.setPopupInfo, getBound = _a.getBound, eventEmitter = _a.eventEmitter;
            var command = item.command, name = item.name, popup = item.popup;
            if (command) {
                execCommand(command);
            }
            else {
                var popupName = popup ? 'customPopupBody' : name;
                var initialValues = eventEmitter.emit('query', 'getPopupInitialValues', { popupName: popupName })[0];
                var info = createPopupInfo(popupName, {
                    el: _this.refs.el,
                    pos: getBound(_this.refs.el),
                    popup: popup,
                    initialValues: initialValues,
                });
                if (info) {
                    setPopupInfo(info);
                }
            }
        };
        return _this;
    }
    ToolbarButtonComp.prototype.mounted = function () {
        this.setItemWidth();
    };
    ToolbarButtonComp.prototype.updated = function (prevProps) {
        if (prevProps.item.name !== this.props.item.name) {
            this.setItemWidth();
        }
    };
    ToolbarButtonComp.prototype.setItemWidth = function () {
        var _a = this.props, setItemWidth = _a.setItemWidth, item = _a.item;
        // set width only if it is not a dropdown toolbar
        if (setItemWidth) {
            setItemWidth(item.name, getOuterWidth(this.refs.el) + (item.hidden ? DEFAULT_WIDTH : 0));
        }
    };
    ToolbarButtonComp.prototype.render = function () {
        var _this = this;
        var _a = this.props, hideTooltip = _a.hideTooltip, disabled = _a.disabled, item = _a.item, active = _a.active;
        var style = __assign({ display: item.hidden ? 'none' : null }, item.style);
        var classNames = "" + (item.className || '') + (active ? ' active' : '');
        return template(toolbarButton_templateObject_1 || (toolbarButton_templateObject_1 = __makeTemplateObject(["\n      <button\n        ref=", "\n        type=\"button\"\n        style=", "\n        class=", "\n        onClick=", "\n        onMouseover=", "\n        onMouseout=", "\n        disabled=", "\n        aria-label=", "\n      >\n        ", "\n      </button>\n    "], ["\n      <button\n        ref=", "\n        type=\"button\"\n        style=", "\n        class=", "\n        onClick=", "\n        onMouseover=", "\n        onMouseout=", "\n        disabled=", "\n        aria-label=", "\n      >\n        ", "\n      </button>\n    "])), function (el) { return (_this.refs.el = el); }, style, classNames, this.execCommand, this.showTooltip, hideTooltip, !!disabled, item.text || item.tooltip || '', item.text || '');
    };
    return ToolbarButtonComp;
}(Component));

var ToolbarButton = connectHOC(ToolbarButtonComp);
var toolbarButton_templateObject_1;

;// CONCATENATED MODULE: ./src/ui/components/toolbar/customToolbarItem.ts






var CustomToolbarItemComp = /** @class */ (function (_super) {
    __extends(CustomToolbarItemComp, _super);
    function CustomToolbarItemComp() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.showTooltip = function () {
            _this.props.showTooltip(_this.refs.el);
        };
        _this.showPopup = function () {
            var info = createPopupInfo('customPopupBody', {
                el: _this.refs.el,
                pos: _this.props.getBound(_this.refs.el),
                popup: _this.props.item.popup,
            });
            if (info) {
                _this.props.setPopupInfo(info);
            }
        };
        return _this;
    }
    CustomToolbarItemComp.prototype.mounted = function () {
        var _a = this.props, setItemWidth = _a.setItemWidth, item = _a.item;
        // append the custom html element
        this.refs.el.appendChild(item.el);
        // set width only if it is not a dropdown toolbar
        if (setItemWidth) {
            setItemWidth(item.name, getOuterWidth(this.refs.el));
        }
        if (item.onMounted) {
            item.onMounted(this.props.execCommand);
        }
    };
    CustomToolbarItemComp.prototype.updated = function (prevProps) {
        var _a;
        var _b = this.props, item = _b.item, active = _b.active, disabled = _b.disabled;
        if (prevProps.active !== active || prevProps.disabled !== disabled) {
            (_a = item.onUpdated) === null || _a === void 0 ? void 0 : _a.call(item, { active: active, disabled: disabled });
        }
    };
    CustomToolbarItemComp.prototype.render = function () {
        var _this = this;
        var _a = this.props, disabled = _a.disabled, item = _a.item;
        var style = { display: item.hidden ? 'none' : 'inline-block' };
        var getListener = function (listener) { return (disabled ? null : listener); };
        return template(customToolbarItem_templateObject_1 || (customToolbarItem_templateObject_1 = __makeTemplateObject(["\n      <div\n        ref=", "\n        style=", "\n        class=", "\n        onClick=", "\n        onMouseover=", "\n        onMouseout=", "\n      ></div>\n    "], ["\n      <div\n        ref=", "\n        style=", "\n        class=", "\n        onClick=", "\n        onMouseover=", "\n        onMouseout=", "\n      ></div>\n    "])), function (el) { return (_this.refs.el = el); }, style, cls('toolbar-item-wrapper'), getListener(this.showPopup), getListener(this.showTooltip), getListener(this.props.hideTooltip));
    };
    return CustomToolbarItemComp;
}(Component));
var CustomToolbarItem = connectHOC(CustomToolbarItemComp);
var customToolbarItem_templateObject_1;

;// CONCATENATED MODULE: ./src/ui/components/toolbar/toolbarGroup.ts






var ToolbarGroup = /** @class */ (function (_super) {
    __extends(ToolbarGroup, _super);
    function ToolbarGroup() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ToolbarGroup.prototype.render = function () {
        var _this = this;
        var _a = this.props, group = _a.group, hiddenDivider = _a.hiddenDivider;
        var groupStyle = group.hidden ? { display: 'none' } : null;
        var dividerStyle = hiddenDivider ? { display: 'none' } : null;
        return template(toolbarGroup_templateObject_2 || (toolbarGroup_templateObject_2 = __makeTemplateObject(["\n      <div class=\"", "\" style=", ">\n        ", "\n        <div class=\"", "\" style=", "></div>\n      </div>\n    "], ["\n      <div class=\"", "\" style=", ">\n        ",
            "\n        <div class=\"", "\" style=", "></div>\n      </div>\n    "])), cls('toolbar-group'), groupStyle, group.map(function (item) {
            var Comp = item.el ? CustomToolbarItem : ToolbarButton;
            return template(toolbarGroup_templateObject_1 || (toolbarGroup_templateObject_1 = __makeTemplateObject(["<", " key=", " ...", " item=", " />"], ["<", " key=", " ...", " item=", " />"])), Comp, item.name, _this.props, item);
        }), cls('toolbar-divider'), dividerStyle);
    };
    return ToolbarGroup;
}(Component));

var toolbarGroup_templateObject_1, toolbarGroup_templateObject_2;

;// CONCATENATED MODULE: ./src/ui/components/toolbar/dropdownToolbarButton.ts






var POPUP_INDENT = 4;
var DropdownToolbarButtonComp = /** @class */ (function (_super) {
    __extends(DropdownToolbarButtonComp, _super);
    function DropdownToolbarButtonComp(props) {
        var _this = _super.call(this, props) || this;
        _this.handleClickDocument = function (_a) {
            var target = _a.target;
            if (!closest(target, "." + cls('dropdown-toolbar')) &&
                !closest(target, '.more')) {
                _this.setState({ showDropdown: false, dropdownPos: null });
            }
        };
        _this.showTooltip = function () {
            _this.props.showTooltip(_this.refs.el);
        };
        _this.state = { showDropdown: false, dropdownPos: null };
        return _this;
    }
    DropdownToolbarButtonComp.prototype.getBound = function () {
        var rect = this.props.getBound(this.refs.el);
        rect.top += POPUP_INDENT;
        return __assign(__assign({}, rect), { left: null, right: 10 });
    };
    DropdownToolbarButtonComp.prototype.mounted = function () {
        document.addEventListener('click', this.handleClickDocument);
    };
    DropdownToolbarButtonComp.prototype.updated = function () {
        if (this.state.showDropdown && !this.state.dropdownPos) {
            this.setState({ dropdownPos: this.getBound() });
        }
    };
    DropdownToolbarButtonComp.prototype.beforeDestroy = function () {
        document.removeEventListener('click', this.handleClickDocument);
    };
    DropdownToolbarButtonComp.prototype.render = function () {
        var _this = this;
        var _a = this.state, showDropdown = _a.showDropdown, dropdownPos = _a.dropdownPos;
        var _b = this.props, disabled = _b.disabled, item = _b.item, items = _b.items, hideTooltip = _b.hideTooltip;
        var visibleItems = items.filter(function (dropdownItem) { return !dropdownItem.hidden; });
        var groupStyle = visibleItems.length ? null : { display: 'none' };
        var dropdownStyle = showDropdown ? null : { display: 'none' };
        return template(dropdownToolbarButton_templateObject_2 || (dropdownToolbarButton_templateObject_2 = __makeTemplateObject(["\n      <div class=\"", "\" style=", ">\n        <button\n          ref=", "\n          type=\"button\"\n          class=", "\n          onClick=", "\n          onMouseover=", "\n          onMouseout=", "\n          disabled=", "\n        ></button>\n        <div\n          class=\"", "\"\n          style=", "\n          ref=", "\n        >\n          ", "\n        </div>\n      </div>\n    "], ["\n      <div class=\"", "\" style=", ">\n        <button\n          ref=", "\n          type=\"button\"\n          class=", "\n          onClick=", "\n          onMouseover=", "\n          onMouseout=", "\n          disabled=", "\n        ></button>\n        <div\n          class=\"", "\"\n          style=", "\n          ref=", "\n        >\n          ",
            "\n        </div>\n      </div>\n    "])), cls('toolbar-group'), groupStyle, function (el) { return (_this.refs.el = el); }, item.className, function () { return _this.setState({ showDropdown: true }); }, this.showTooltip, hideTooltip, disabled, cls('dropdown-toolbar'), __assign(__assign({}, dropdownStyle), dropdownPos), function (el) { return (_this.refs.dropdownEl = el); }, visibleItems.length
            ? visibleItems.map(function (group, index) {
                var _a;
                return template(dropdownToolbarButton_templateObject_1 || (dropdownToolbarButton_templateObject_1 = __makeTemplateObject(["\n                  <", "\n                    group=", "\n                    hiddenDivider=", "\n                    ...", "\n                  />\n                "], ["\n                  <", "\n                    group=", "\n                    hiddenDivider=",
                    "\n                    ...", "\n                  />\n                "])), ToolbarGroup, group, index === visibleItems.length - 1 ||
                    ((_a = visibleItems[index + 1]) === null || _a === void 0 ? void 0 : _a.hidden), _this.props);
            })
            : null);
    };
    return DropdownToolbarButtonComp;
}(Component));
var DropdownToolbarButton = connectHOC(DropdownToolbarButtonComp);
var dropdownToolbarButton_templateObject_1, dropdownToolbarButton_templateObject_2;

;// CONCATENATED MODULE: ./src/ui/components/toolbar/toolbar.ts













var INLINE_PADDING = 50;
var Toolbar = /** @class */ (function (_super) {
    __extends(Toolbar, _super);
    function Toolbar(props) {
        var _this = _super.call(this, props) || this;
        _this.toggleTab = function (_, activeTab) {
            var eventEmitter = _this.props.eventEmitter;
            if (_this.state.activeTab !== activeTab) {
                var event = activeTab === 'write' ? 'changePreviewTabWrite' : 'changePreviewTabPreview';
                eventEmitter.emit(event);
                _this.setState({ activeTab: activeTab });
            }
        };
        _this.setItemWidth = function (name, width) {
            _this.itemWidthMap[name] = width;
        };
        _this.setPopupInfo = function (popupInfo) {
            _this.setState({ showPopup: true, popupInfo: popupInfo });
        };
        _this.openPopup = function (popupName, initialValues) {
            if (initialValues === void 0) { initialValues = {}; }
            var el = _this.refs.el.querySelector("." + cls('toolbar-group') + " ." + popupName);
            if (el) {
                var _a = getTotalOffset(el, closest(el, "." + cls('toolbar'))), offsetLeft = _a.offsetLeft, offsetTop = _a.offsetTop;
                var info = createPopupInfo(popupName, {
                    el: el,
                    pos: { left: offsetLeft, top: el.offsetHeight + offsetTop },
                    initialValues: initialValues,
                });
                if (info) {
                    _this.setPopupInfo(info);
                }
            }
        };
        _this.hidePopup = function () {
            if (_this.state.showPopup) {
                _this.setState({ showPopup: false });
            }
        };
        _this.execCommand = function (command, payload) {
            var eventEmitter = _this.props.eventEmitter;
            eventEmitter.emit('command', command, payload);
            _this.hidePopup();
        };
        _this.tabs = [
            { name: 'write', text: 'Write' },
            { name: 'preview', text: 'Preview' },
        ];
        _this.itemWidthMap = {};
        _this.initialItems = groupToolbarItems(props.toolbarItems || [], _this.hiddenScrollSync());
        _this.state = {
            items: _this.initialItems,
            dropdownItems: [],
            showPopup: false,
            popupInfo: {},
            activeTab: 'write',
        };
        _this.tooltipRef = { current: null };
        _this.resizeObserver = new ResizeObserver_es(function () { return _this.handleResize(); });
        _this.addEvent();
        return _this;
    }
    Toolbar.prototype.insertToolbarItem = function (indexList, item) {
        var groupIndex = indexList.groupIndex, itemIndex = indexList.itemIndex;
        var group = this.initialItems[groupIndex];
        item = createToolbarItemInfo(item);
        if (group) {
            group.splice(itemIndex, 0, item);
        }
        else {
            this.initialItems.push([item]);
        }
        this.setState(this.classifyToolbarItems());
    };
    Toolbar.prototype.removeToolbarItem = function (name) {
        var _this = this;
        forEachArray_default()(this.initialItems, function (group) {
            var found = false;
            forEachArray_default()(group, function (item, index) {
                if (item.name === name) {
                    found = true;
                    group.splice(index, 1);
                    _this.setState(_this.classifyToolbarItems());
                    return false;
                }
                return true;
            });
            return !found;
        });
    };
    Toolbar.prototype.addEvent = function () {
        var _this = this;
        var eventEmitter = this.props.eventEmitter;
        this.handleResize = throttle_default()(function () {
            // reset toolbar items to re-layout toolbar items with each clientWidth
            _this.setState({ items: _this.initialItems, dropdownItems: [] });
            _this.setState(_this.classifyToolbarItems());
        }, 200);
        eventEmitter.listen('openPopup', this.openPopup);
    };
    Toolbar.prototype.appendTooltipToRoot = function () {
        var tooltip = "<div class=\"" + cls('tooltip') + "\" style=\"display:none\">\n        <div class=\"arrow\"></div>\n        <span class=\"text\"></span>\n      </div>";
        this.tooltipRef.current = createElementWith(tooltip, this.refs.el);
    };
    Toolbar.prototype.hiddenScrollSync = function () {
        return this.props.editorType === 'wysiwyg' || this.props.previewStyle === 'tab';
    };
    Toolbar.prototype.movePrevItemToDropdownToolbar = function (itemIndex, items, group, dropdownGroup) {
        var moveItem = function (targetGroup) {
            var item = targetGroup.pop();
            if (item) {
                dropdownGroup.push(item);
            }
        };
        if (itemIndex > 1) {
            moveItem(group);
        }
        else {
            var prevGroup = last(items);
            if (prevGroup) {
                moveItem(prevGroup);
            }
        }
    };
    Toolbar.prototype.classifyToolbarItems = function () {
        var _this = this;
        var totalWidth = 0;
        var clientWidth = this.refs.el.clientWidth;
        var divider = this.refs.el.querySelector("." + cls('toolbar-divider'));
        var dividerWidth = divider ? getOuterWidth(divider) : 0;
        var items = [];
        var dropdownItems = [];
        var moved = false;
        this.initialItems.forEach(function (initialGroup, groupIndex) {
            var group = [];
            var dropdownGroup = [];
            initialGroup.forEach(function (item, itemIndex) {
                if (!item.hidden) {
                    totalWidth += _this.itemWidthMap[item.name];
                    if (totalWidth > clientWidth - INLINE_PADDING) {
                        // should move the prev item to dropdown toolbar for placing the more button
                        if (!moved) {
                            _this.movePrevItemToDropdownToolbar(itemIndex, items, group, dropdownGroup);
                            moved = true;
                        }
                        dropdownGroup.push(item);
                    }
                    else {
                        group.push(item);
                    }
                }
            });
            if (group.length) {
                setGroupState(group);
                items.push(group);
            }
            if (dropdownGroup.length) {
                setGroupState(dropdownGroup);
                dropdownItems.push(dropdownGroup);
            }
            // add divider width
            if (groupIndex < _this.state.items.length - 1) {
                totalWidth += dividerWidth;
            }
        });
        return { items: items, dropdownItems: dropdownItems };
    };
    Toolbar.prototype.mounted = function () {
        if (this.props.previewStyle === 'tab') {
            this.props.eventEmitter.emit('changePreviewTabWrite', true);
        }
        // classify toolbar and dropdown toolbar after DOM has been rendered
        this.setState(this.classifyToolbarItems());
        this.appendTooltipToRoot();
        this.resizeObserver.observe(this.refs.el);
    };
    Toolbar.prototype.updated = function (prevProps) {
        var _a = this.props, editorType = _a.editorType, previewStyle = _a.previewStyle, eventEmitter = _a.eventEmitter;
        var changedStyle = previewStyle !== prevProps.previewStyle;
        var changedType = editorType !== prevProps.editorType;
        if (changedStyle || changedType) {
            // show or hide scrollSync button
            toggleScrollSync(this.initialItems, this.hiddenScrollSync());
            var newState = this.classifyToolbarItems();
            if (changedStyle || (previewStyle === 'tab' && editorType === 'markdown')) {
                eventEmitter.emit('changePreviewTabWrite');
                newState.activeTab = 'write';
            }
            this.setState(newState);
        }
    };
    Toolbar.prototype.beforeDestroy = function () {
        window.removeEventListener('resize', this.handleResize);
        this.resizeObserver.disconnect();
        removeNode(this.tooltipRef.current);
    };
    Toolbar.prototype.render = function () {
        var _this = this;
        var _a = this.props, previewStyle = _a.previewStyle, eventEmitter = _a.eventEmitter, editorType = _a.editorType;
        var _b = this.state, popupInfo = _b.popupInfo, showPopup = _b.showPopup, activeTab = _b.activeTab, items = _b.items, dropdownItems = _b.dropdownItems;
        var props = {
            eventEmitter: eventEmitter,
            tooltipRef: this.tooltipRef,
            disabled: editorType === 'markdown' && previewStyle === 'tab' && activeTab === 'preview',
            execCommand: this.execCommand,
            setPopupInfo: this.setPopupInfo,
        };
        var toolbarStyle = previewStyle === 'tab' ? { borderTopLeftRadius: 0 } : null;
        return template(toolbar_templateObject_2 || (toolbar_templateObject_2 = __makeTemplateObject(["\n      <div class=\"", "\">\n        <div\n          class=\"", "\"\n          style=\"display: ", "\"\n        >\n          <", " tabs=", " activeTab=", " onClick=", " />\n        </div>\n        <div\n          class=\"", "\"\n          ref=", "\n          style=", "\n        >\n          ", "\n          <", "\n            item=", "\n            items=", "\n            ...", "\n          />\n        </div>\n        <", "\n          info=", "\n          show=", "\n          eventEmitter=", "\n          hidePopup=", "\n          execCommand=", "\n        />\n      </div>\n    "], ["\n      <div class=\"", "\">\n        <div\n          class=\"", "\"\n          style=\"display: ",
            "\"\n        >\n          <", " tabs=", " activeTab=", " onClick=", " />\n        </div>\n        <div\n          class=\"", "\"\n          ref=", "\n          style=", "\n        >\n          ",
            "\n          <", "\n            item=", "\n            items=", "\n            ...", "\n          />\n        </div>\n        <", "\n          info=", "\n          show=", "\n          eventEmitter=", "\n          hidePopup=", "\n          execCommand=", "\n        />\n      </div>\n    "])), cls('toolbar'), cls('md-tab-container'), editorType === 'wysiwyg' || previewStyle === 'vertical'
            ? 'none'
            : 'block', Tabs, this.tabs, activeTab, this.toggleTab, cls('defaultUI-toolbar'), function (el) { return (_this.refs.el = el); }, toolbarStyle, items.map(function (group, index) {
            var _a;
            return template(toolbar_templateObject_1 || (toolbar_templateObject_1 = __makeTemplateObject(["\n              <", "\n                group=", "\n                hiddenDivider=", "\n                setItemWidth=", "\n                ...", "\n              />\n            "], ["\n              <", "\n                group=", "\n                hiddenDivider=", "\n                setItemWidth=", "\n                ...", "\n              />\n            "])), ToolbarGroup, group, index === items.length - 1 || ((_a = items[index + 1]) === null || _a === void 0 ? void 0 : _a.hidden), _this.setItemWidth, props);
        }), DropdownToolbarButton, createToolbarItemInfo('more'), dropdownItems, props, Popup, popupInfo, showPopup, eventEmitter, this.hidePopup, this.execCommand);
    };
    return Toolbar;
}(Component));

var toolbar_templateObject_1, toolbar_templateObject_2;

;// CONCATENATED MODULE: ./src/ui/components/contextMenu.ts




var ContextMenu = /** @class */ (function (_super) {
    __extends(ContextMenu, _super);
    function ContextMenu(props) {
        var _this = _super.call(this, props) || this;
        _this.handleClickDocument = function (ev) {
            if (!closest(ev.target, "." + cls('context-menu'))) {
                _this.setState({ pos: null });
            }
        };
        _this.state = {
            pos: null,
            menuGroups: [],
        };
        _this.addEvent();
        return _this;
    }
    ContextMenu.prototype.addEvent = function () {
        var _this = this;
        this.props.eventEmitter.listen('contextmenu', function (_a) {
            var pos = _a.pos, menuGroups = _a.menuGroups;
            _this.setState({ pos: pos, menuGroups: menuGroups });
        });
    };
    ContextMenu.prototype.mounted = function () {
        document.addEventListener('click', this.handleClickDocument);
    };
    ContextMenu.prototype.beforeDestroy = function () {
        document.removeEventListener('click', this.handleClickDocument);
    };
    ContextMenu.prototype.getMenuGroupElements = function () {
        var _this = this;
        var _a = this.state, pos = _a.pos, menuGroups = _a.menuGroups;
        return pos
            ? menuGroups.reduce(function (acc, group) {
                var menuItem = [];
                group.forEach(function (_a) {
                    var label = _a.label, _b = _a.className, className = _b === void 0 ? false : _b, disabled = _a.disabled, onClick = _a.onClick;
                    var handleClick = function () {
                        if (!disabled) {
                            onClick();
                            _this.setState({ pos: null });
                        }
                    };
                    menuItem.push(template(contextMenu_templateObject_1 || (contextMenu_templateObject_1 = __makeTemplateObject(["\n                <li\n                  onClick=", "\n                  class=\"menu-item", "\"\n                  aria-role=\"menuitem\"\n                >\n                  <span class=\"", "\">", "</span>\n                </li>\n              "], ["\n                <li\n                  onClick=", "\n                  class=\"menu-item", "\"\n                  aria-role=\"menuitem\"\n                >\n                  <span class=\"", "\">", "</span>\n                </li>\n              "])), handleClick, disabled ? ' disabled' : '', className, label));
                });
                acc.push(template(contextMenu_templateObject_2 || (contextMenu_templateObject_2 = __makeTemplateObject(["<ul class=\"menu-group\">\n              ", "\n            </ul>"], ["<ul class=\"menu-group\">\n              ", "\n            </ul>"])), menuItem));
                return acc;
            }, [])
            : [];
    };
    ContextMenu.prototype.render = function () {
        var style = __assign({ display: this.state.pos ? 'block' : 'none' }, this.state.pos);
        return template(contextMenu_templateObject_3 || (contextMenu_templateObject_3 = __makeTemplateObject(["<div class=\"", "\" style=", " aria-role=\"menu\">\n      ", "\n    </div>"], ["<div class=\"", "\" style=", " aria-role=\"menu\">\n      ", "\n    </div>"])), cls('context-menu'), style, this.getMenuGroupElements());
    };
    return ContextMenu;
}(Component));

var contextMenu_templateObject_1, contextMenu_templateObject_2, contextMenu_templateObject_3;

;// CONCATENATED MODULE: ./src/ui/components/layout.ts







var Layout = /** @class */ (function (_super) {
    __extends(Layout, _super);
    function Layout(props) {
        var _this = _super.call(this, props) || this;
        _this.changeMode = function (editorType) {
            if (editorType !== _this.state.editorType) {
                _this.setState({ editorType: editorType });
            }
        };
        _this.changePreviewStyle = function (previewStyle) {
            if (previewStyle !== _this.state.previewStyle) {
                _this.setState({ previewStyle: previewStyle });
            }
        };
        _this.hide = function () {
            _this.setState({ hide: true });
        };
        _this.show = function () {
            _this.setState({ hide: false });
        };
        var editorType = props.editorType, previewStyle = props.previewStyle;
        _this.state = {
            editorType: editorType,
            previewStyle: previewStyle,
            hide: false,
        };
        _this.addEvent();
        return _this;
    }
    Layout.prototype.mounted = function () {
        var _a = this.props.slots, wwEditor = _a.wwEditor, mdEditor = _a.mdEditor, mdPreview = _a.mdPreview;
        this.refs.wwContainer.appendChild(wwEditor);
        this.refs.mdContainer.insertAdjacentElement('afterbegin', mdEditor);
        this.refs.mdContainer.appendChild(mdPreview);
    };
    Layout.prototype.insertToolbarItem = function (indexList, item) {
        this.toolbar.insertToolbarItem(indexList, item);
    };
    Layout.prototype.removeToolbarItem = function (name) {
        this.toolbar.removeToolbarItem(name);
    };
    Layout.prototype.render = function () {
        var _this = this;
        var _a = this.props, eventEmitter = _a.eventEmitter, hideModeSwitch = _a.hideModeSwitch, toolbarItems = _a.toolbarItems, theme = _a.theme;
        var _b = this.state, hide = _b.hide, previewStyle = _b.previewStyle, editorType = _b.editorType;
        var displayClassName = hide ? ' hidden' : '';
        var editorTypeClassName = cls(editorType === 'markdown' ? 'md-mode' : 'ww-mode');
        var previewClassName = cls('md') + "-" + previewStyle + "-style";
        var themeClassName = cls([theme !== 'light', theme + " "]);
        return template(layout_templateObject_2 || (layout_templateObject_2 = __makeTemplateObject(["\n      <div\n        class=\"", "", "", "\"\n        ref=", "\n      >\n        <", "\n          ref=", "\n          eventEmitter=", "\n          previewStyle=", "\n          toolbarItems=", "\n          editorType=", "\n        />\n        <div\n          class=\"", " ", "\"\n          ref=", "\n        >\n          <div class=\"", "\">\n            <div\n              class=\"", " ", "\"\n              ref=", "\n            >\n              <div class=\"", "\"></div>\n            </div>\n            <div\n              class=\"", "\"\n              ref=", "\n            />\n          </div>\n        </div>\n        ", "\n        <", " eventEmitter=", " />\n      </div>\n    "], ["\n      <div\n        class=\"", "", "", "\"\n        ref=", "\n      >\n        <", "\n          ref=", "\n          eventEmitter=", "\n          previewStyle=", "\n          toolbarItems=", "\n          editorType=", "\n        />\n        <div\n          class=\"", " ", "\"\n          ref=", "\n        >\n          <div class=\"", "\">\n            <div\n              class=\"", " ", "\"\n              ref=", "\n            >\n              <div class=\"", "\"></div>\n            </div>\n            <div\n              class=\"", "\"\n              ref=", "\n            />\n          </div>\n        </div>\n        ",
            "\n        <", " eventEmitter=", " />\n      </div>\n    "])), themeClassName, cls('defaultUI'), displayClassName, function (el) { return (_this.refs.el = el); }, Toolbar, function (toolbar) { return (_this.toolbar = toolbar); }, eventEmitter, previewStyle, toolbarItems, editorType, cls('main'), editorTypeClassName, function (el) { return (_this.refs.editorSection = el); }, cls('main-container'), cls('md-container'), previewClassName, function (el) { return (_this.refs.mdContainer = el); }, cls('md-splitter'), cls('ww-container'), function (el) { return (_this.refs.wwContainer = el); }, !hideModeSwitch && template(layout_templateObject_1 || (layout_templateObject_1 = __makeTemplateObject(["<", " eventEmitter=", " editorType=", " />"], ["<", " eventEmitter=", " editorType=", " />"])), Switch, eventEmitter, editorType), ContextMenu, eventEmitter);
    };
    Layout.prototype.addEvent = function () {
        var eventEmitter = this.props.eventEmitter;
        eventEmitter.listen('hide', this.hide);
        eventEmitter.listen('show', this.show);
        eventEmitter.listen('changeMode', this.changeMode);
        eventEmitter.listen('changePreviewStyle', this.changePreviewStyle);
    };
    return Layout;
}(Component));

var layout_templateObject_1, layout_templateObject_2;

;// CONCATENATED MODULE: ./src/editor.ts






/**
 * ToastUI Editor
 * @extends ToastUIEditorCore
 */
var ToastUIEditor = /** @class */ (function (_super) {
    __extends(ToastUIEditor, _super);
    function ToastUIEditor(options) {
        var _a;
        var _this = _super.call(this, options) || this;
        var layoutComp;
        var destroy = render(_this.options.el, template(editor_templateObject_1 || (editor_templateObject_1 = __makeTemplateObject(["\n        <", "\n          ref=", "\n          eventEmitter=", "\n          slots=", "\n          hideModeSwitch=", "\n          toolbarItems=", "\n          previewStyle=", "\n          editorType=", "\n          theme=", "\n        />\n      "], ["\n        <", "\n          ref=", "\n          eventEmitter=", "\n          slots=", "\n          hideModeSwitch=", "\n          toolbarItems=", "\n          previewStyle=", "\n          editorType=", "\n          theme=", "\n        />\n      "])), Layout, function (layout) { return (layoutComp = layout); }, _this.eventEmitter, _this.getEditorElements(), _this.options.hideModeSwitch, _this.options.toolbarItems, _this.options.previewStyle, _this.options.initialEditType, _this.options.theme));
        _this.setMinHeight(_this.options.minHeight);
        _this.setHeight(_this.options.height);
        _this.defaultUI = {
            insertToolbarItem: layoutComp.insertToolbarItem.bind(layoutComp),
            removeToolbarItem: layoutComp.removeToolbarItem.bind(layoutComp),
            destroy: destroy,
        };
        (_a = _this.pluginInfo.toolbarItems) === null || _a === void 0 ? void 0 : _a.forEach(function (toolbarItem) {
            var groupIndex = toolbarItem.groupIndex, itemIndex = toolbarItem.itemIndex, item = toolbarItem.item;
            _this.defaultUI.insertToolbarItem({ groupIndex: groupIndex, itemIndex: itemIndex }, item);
        });
        _this.eventEmitter.emit('loadUI', _this);
        return _this;
    }
    /**
     * Factory method for Editor
     * @param {object} options Option for initialize TUIEditor
     * @returns {object} ToastUIEditor or ToastUIEditorViewer
     */
    ToastUIEditor.factory = function (options) {
        return options.viewer ? new viewer(options) : new ToastUIEditor(options);
    };
    /**
     * add toolbar item
     * @param {Object} indexInfo group index and item index of the toolbar item
     * @param {string|Object} item toolbar item
     */
    ToastUIEditor.prototype.insertToolbarItem = function (indexInfo, item) {
        this.defaultUI.insertToolbarItem(indexInfo, item);
    };
    /**
     * Remove toolbar item
     * @param {string} itemName toolbar item name
     */
    ToastUIEditor.prototype.removeToolbarItem = function (itemName) {
        this.defaultUI.removeToolbarItem(itemName);
    };
    /**
     * Destroy TUIEditor from document
     */
    ToastUIEditor.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        this.defaultUI.destroy();
    };
    return ToastUIEditor;
}(editorCore));
/* harmony default export */ var editor = (ToastUIEditor);
var editor_templateObject_1;

;// CONCATENATED MODULE: ../../node_modules/prosemirror-view/style/prosemirror.css
// extracted by mini-css-extract-plugin

;// CONCATENATED MODULE: ./src/i18n/en-us.ts
/**
 * @fileoverview I18N for English
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 */

editorCore.setLanguage(['en', 'en-US'], {
    Markdown: 'Markdown',
    WYSIWYG: 'WYSIWYG',
    Write: 'Write',
    Preview: 'Preview',
    Headings: 'Headings',
    Paragraph: 'Paragraph',
    Bold: 'Bold',
    Italic: 'Italic',
    Strike: 'Strike',
    Code: 'Inline code',
    Line: 'Line',
    Blockquote: 'Blockquote',
    'Unordered list': 'Unordered list',
    'Ordered list': 'Ordered list',
    Task: 'Task',
    Indent: 'Indent',
    Outdent: 'Outdent',
    'Insert link': 'Insert link',
    'Insert CodeBlock': 'Insert codeBlock',
    'Insert table': 'Insert table',
    'Insert image': 'Insert image',
    Heading: 'Heading',
    'Image URL': 'Image URL',
    'Select image file': 'Select image file',
    'Choose a file': 'Choose a file',
    'No file': 'No file',
    Description: 'Description',
    OK: 'OK',
    More: 'More',
    Cancel: 'Cancel',
    File: 'File',
    URL: 'URL',
    'Link text': 'Link text',
    'Add row to up': 'Add row to up',
    'Add row to down': 'Add row to down',
    'Add column to left': 'Add column to left',
    'Add column to right': 'Add column to right',
    'Remove row': 'Remove row',
    'Remove column': 'Remove column',
    'Align column to left': 'Align column to left',
    'Align column to center': 'Align column to center',
    'Align column to right': 'Align column to right',
    'Remove table': 'Remove table',
    'Would you like to paste as table?': 'Would you like to paste as table?',
    'Text color': 'Text color',
    'Auto scroll enabled': 'Auto scroll enabled',
    'Auto scroll disabled': 'Auto scroll disabled',
    'Choose language': 'Choose language',
});

;// CONCATENATED MODULE: ./src/index.ts








/* harmony default export */ var src = (editor);


}();
__nested_webpack_exports__ = __nested_webpack_exports__["default"];
/******/ 	return __nested_webpack_exports__;
/******/ })()
;
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-6!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Editor.vue?vue&type=script&setup=true&lang=ts":
/*!**************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-6!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Editor.vue?vue&type=script&setup=true&lang=ts ***!
  \**************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var vue_1 = __webpack_require__(/*! vue */ "vue");
var vue_2 = __webpack_require__(/*! vue */ "vue");
var useEditor_1 = __importDefault(__webpack_require__(/*! ../composables/useEditor */ "./resources/js/composables/useEditor.ts"));
exports["default"] = (0, vue_1.defineComponent)({
  __name: 'Editor',
  props: {
    value: {
      type: String,
      required: true
    },
    addImageBlobHook: {
      type: Function,
      required: false
    },
    height: {
      type: String,
      required: false,
      "default": '500px'
    },
    plugins: {
      type: Array,
      required: false,
      "default": function _default() {
        return [];
      }
    },
    initialEditType: {
      type: String,
      required: false,
      "default": 'markdown'
    },
    previewStyle: {
      type: String,
      required: false,
      "default": 'tab'
    }
  },
  emits: ['input'],
  setup: function setup(__props, _a) {
    var __expose = _a.expose,
      emit = _a.emit;
    __expose();
    var props = __props;
    var editor = (0, vue_2.ref)(null);
    var fullScreen = (0, vue_2.ref)(false);
    var darkMode = (0, vue_2.ref)(false);
    var resolveNovaDarkMode = function resolveNovaDarkMode() {
      var cls = document.documentElement.classList;
      var novaDarkModeEnabled = cls.contains('dark');
      if (novaDarkModeEnabled && !darkMode.value) {
        darkMode.value = true;
      } else if (!novaDarkModeEnabled && darkMode.value) {
        darkMode.value = false;
      }
    };
    (0, vue_2.onMounted)(function () {
      resolveNovaDarkMode();
      new MutationObserver(resolveNovaDarkMode).observe(document.documentElement, {
        attributes: true,
        attributeOldValue: true,
        attributeFilter: ['class']
      });
      var e = (0, useEditor_1["default"])(editor, {
        height: '100cqh',
        initialValue: props.value,
        initialEditType: props.initialEditType,
        plugins: props.plugins,
        previewStyle: props.previewStyle,
        addImageBlobHook: props.addImageBlobHook,
        onChange: function onChange(e) {
          return emit('input', e.getMarkdown());
        }
      });
    });
    var __returned__ = {
      props: props,
      emit: emit,
      editor: editor,
      fullScreen: fullScreen,
      darkMode: darkMode,
      resolveNovaDarkMode: resolveNovaDarkMode
    };
    Object.defineProperty(__returned__, '__isScriptSetup', {
      enumerable: false,
      value: true
    });
    return __returned__;
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-6!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Editor.vue?vue&type=template&id=1dbb5118&ts=true":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-6!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Editor.vue?vue&type=template&id=1dbb5118&ts=true ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.render = void 0;
var vue_1 = __webpack_require__(/*! vue */ "vue");
var _hoisted_1 = {
  ref: "editor",
  "class": "form-input form-input-bordered"
};
var _hoisted_2 = {
  "class": "fullscreen-button-container"
};
var _hoisted_3 = /*#__PURE__*/(0, vue_1.createElementVNode)("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  fill: "none",
  viewBox: "0 0 24 24",
  stroke: "currentColor",
  "stroke-width": "2"
}, [/*#__PURE__*/(0, vue_1.createElementVNode)("path", {
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  d: "M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"
})], -1 /* HOISTED */);
var _hoisted_4 = [_hoisted_3];
function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (0, vue_1.openBlock)(), (0, vue_1.createElementBlock)("div", {
    "class": (0, vue_1.normalizeClass)(["nova-toastui", {
      'relative': !$setup.fullScreen,
      'fixed inset-0 z-50': $setup.fullScreen,
      'toastui-editor-dark': $setup.darkMode
    }]),
    style: (0, vue_1.normalizeStyle)({
      height: !$setup.fullScreen ? $props.height : undefined
    })
  }, [(0, vue_1.createElementVNode)("div", _hoisted_1, null, 512 /* NEED_PATCH */), (0, vue_1.createElementVNode)("div", _hoisted_2, [(0, vue_1.createElementVNode)("a", {
    href: "#",
    "class": "fullscreen-button",
    onClick: _cache[0] || (_cache[0] = (0, vue_1.withModifiers)(function ($event) {
      return $setup.fullScreen = !$setup.fullScreen;
    }, ["prevent"]))
  }, _hoisted_4)])], 6 /* CLASS, STYLE */);
}

exports.render = render;

/***/ }),

/***/ "./resources/js/composables/useEditor.ts":
/*!***********************************************!*\
  !*** ./resources/js/composables/useEditor.ts ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var editor_1 = __importDefault(__webpack_require__(/*! @toast-ui/editor */ "./node_modules/@toast-ui/editor/dist/toastui-editor.js"));
var editor_plugin_chart_1 = __importDefault(__webpack_require__(/*! @toast-ui/editor-plugin-chart */ "./node_modules/@toast-ui/editor-plugin-chart/dist/toastui-editor-plugin-chart.js"));
var editor_plugin_code_syntax_highlight_1 = __importDefault(__webpack_require__(/*! @toast-ui/editor-plugin-code-syntax-highlight */ "./node_modules/@toast-ui/editor-plugin-code-syntax-highlight/dist/toastui-editor-plugin-code-syntax-highlight.js"));
var editor_plugin_color_syntax_1 = __importDefault(__webpack_require__(/*! @toast-ui/editor-plugin-color-syntax */ "./node_modules/@toast-ui/editor-plugin-color-syntax/dist/toastui-editor-plugin-color-syntax.js"));
var editor_plugin_table_merged_cell_1 = __importDefault(__webpack_require__(/*! @toast-ui/editor-plugin-table-merged-cell */ "./node_modules/@toast-ui/editor-plugin-table-merged-cell/dist/toastui-editor-plugin-table-merged-cell.js"));
var editor_plugin_uml_1 = __importDefault(__webpack_require__(/*! @toast-ui/editor-plugin-uml */ "./node_modules/@toast-ui/editor-plugin-uml/dist/toastui-editor-plugin-uml.js"));
exports["default"] = function (elRef, options) {
  var e = new editor_1["default"]({
    el: elRef.value,
    height: options.height,
    plugins: mapPlugins(options.plugins),
    initialEditType: options.initialEditType,
    previewStyle: options.previewStyle,
    initialValue: options.initialValue,
    events: {
      change: function change() {
        return options.onChange(e);
      }
    },
    hooks: {
      addImageBlobHook: options.addImageBlobHook
    }
  });
  return e;
};
var mapPlugins = function mapPlugins(plugins) {
  var pluginMap = {
    chart: editor_plugin_chart_1["default"],
    codeSyntaxHighlight: editor_plugin_code_syntax_highlight_1["default"],
    colorSyntax: editor_plugin_color_syntax_1["default"],
    tableMergedCell: editor_plugin_table_merged_cell_1["default"],
    uml: editor_plugin_uml_1["default"]
  };
  return plugins.map(function (plugin) {
    return pluginMap[plugin];
  });
};

/***/ }),

/***/ "./resources/js/entry.ts":
/*!*******************************!*\
  !*** ./resources/js/entry.ts ***!
  \*******************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", ({
  value: true
}));
var DetailField_vue_1 = __importDefault(__webpack_require__(/*! ./components/DetailField.vue */ "./resources/js/components/DetailField.vue"));
var FormField_vue_1 = __importDefault(__webpack_require__(/*! ./components/FormField.vue */ "./resources/js/components/FormField.vue"));
Nova.booting(function (Vue) {
  Vue.component('detail-nova-tui-editor', DetailField_vue_1["default"]);
  Vue.component('form-nova-tui-editor', FormField_vue_1["default"]);
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/DetailField.vue?vue&type=script&lang=js":
/*!*****************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/DetailField.vue?vue&type=script&lang=js ***!
  \*****************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: ['index', 'resource', 'resourceName', 'resourceId', 'field'],
  components: {
    //
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/FormField.vue?vue&type=script&lang=js":
/*!***************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/FormField.vue?vue&type=script&lang=js ***!
  \***************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Editor_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Editor.vue */ "./resources/js/components/Editor.vue");
/* harmony import */ var laravel_nova__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! laravel-nova */ "laravel-nova");
/* harmony import */ var laravel_nova__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(laravel_nova__WEBPACK_IMPORTED_MODULE_1__);


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  mixins: [laravel_nova__WEBPACK_IMPORTED_MODULE_1__.FormField, laravel_nova__WEBPACK_IMPORTED_MODULE_1__.HandlesValidationErrors, laravel_nova__WEBPACK_IMPORTED_MODULE_1__.HandlesFieldAttachments],
  components: {
    Editor: _Editor_vue__WEBPACK_IMPORTED_MODULE_0__["default"]
  },
  computed: {
    decodedFieldValue: function decodedFieldValue() {
      var _this$field$value;
      return this.decodeEntities((_this$field$value = this.field.value) !== null && _this$field$value !== void 0 ? _this$field$value : '');
    }
  },
  methods: {
    decodeEntities: function decodeEntities(value) {
      value = value.replace(/%7B/g, '{');
      value = value.replace(/%7D/g, '}');
      return value;
    },
    setInitialValue: function setInitialValue() {
      this.value = this.decodedFieldValue;
    },
    fill: function fill(formData) {
      formData.append(this.field.attribute, this.value || '');
    },
    handleChange: function handleChange(value) {
      this.value = value;
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/DetailField.vue?vue&type=template&id=0224618e":
/*!*********************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/DetailField.vue?vue&type=template&id=0224618e ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);

function render(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_PanelItem = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("PanelItem");
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_PanelItem, {
    index: $props.index,
    field: $props.field
  }, {
    value: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(function () {
      return [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)((0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)($props.field.value), 1 /* TEXT */)];
    }),

    _: 1 /* STABLE */
  }, 8 /* PROPS */, ["index", "field"]);
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/FormField.vue?vue&type=template&id=c023248a":
/*!*******************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/FormField.vue?vue&type=template&id=c023248a ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);

function render(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_Editor = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("Editor");
  var _component_DefaultField = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("DefaultField");
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_DefaultField, {
    field: _ctx.field,
    errors: _ctx.errors,
    "full-width-content": _ctx.fullWidthContent,
    key: _ctx.index,
    "show-help-text": _ctx.showHelpText
  }, {
    field: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(function () {
      return [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_Editor, {
        ref: "toastUiEditor",
        value: _ctx.value,
        onInput: $options.handleChange
      }, null, 8 /* PROPS */, ["value", "onInput"])];
    }),
    _: 1 /* STABLE */
  }, 8 /* PROPS */, ["field", "errors", "full-width-content", "show-help-text"]);
}

/***/ }),

/***/ "./resources/css/entry.pcss":
/*!**********************************!*\
  !*** ./resources/css/entry.pcss ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/plantuml-encoder/browser-index.js":
/*!********************************************************!*\
  !*** ./node_modules/plantuml-encoder/browser-index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  encode: (__webpack_require__(/*! ./dist/plantuml-encoder */ "./node_modules/plantuml-encoder/dist/plantuml-encoder.js").encode),
  decode: (__webpack_require__(/*! ./dist/plantuml-decoder */ "./node_modules/plantuml-encoder/dist/plantuml-decoder.js").decode)
}


/***/ }),

/***/ "./node_modules/plantuml-encoder/dist/plantuml-decoder.js":
/*!****************************************************************!*\
  !*** ./node_modules/plantuml-encoder/dist/plantuml-decoder.js ***!
  \****************************************************************/
/***/ ((module) => {

(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=undefined;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=undefined,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict'

var pako = require('pako/lib/inflate.js')

module.exports = function (data) {
  return pako.inflateRaw(data, { to: 'string' })
}

},{"pako/lib/inflate.js":4}],2:[function(require,module,exports){
'use strict'

// Reverse of
// http://plantuml.sourceforge.net/codejavascript2.html

// It is described as being "a transformation close to base64"
// The code has been slightly modified to pass linters

function decode6bit (cc) {
  var c = cc.charCodeAt(0)
  if (cc === '_') return 63
  if (cc === '-') return 62
  if (c >= 97) return c - 61 // - 97 + 26 + 10
  if (c >= 65) return c - 55 // - 65 + 10
  if (c >= 48) return c - 48
  return '?'
}

function extract3bytes (data) {
  var c1 = decode6bit(data[0])
  var c2 = decode6bit(data[1])
  var c3 = decode6bit(data[2])
  var c4 = decode6bit(data[3])
  var b1 = c1 << 2 | (c2 >> 4) & 0x3F
  var b2 = (c2 << 4) & 0xF0 | (c3 >> 2) & 0xF
  var b3 = (c3 << 6) & 0xC0 | c4 & 0x3F

  return [b1, b2, b3]
}

module.exports = function (data) {
  var r = ''
  var i = 0
  for (i = 0; i < data.length; i += 4) {
    var t = extract3bytes(data.substring(i, i + 4))
    r = r + String.fromCharCode(t[0])
    r = r + String.fromCharCode(t[1])
    r = r + String.fromCharCode(t[2])
  }
  return r
}

},{}],3:[function(require,module,exports){
'use strict'

var inflate = require('./inflate')
var decode64 = require('./decode64')

module.exports.decode = function (encoded) {
  var deflated = decode64(encoded)
  return inflate(deflated)
}

},{"./decode64":2,"./inflate":1}],4:[function(require,module,exports){
'use strict';


var zlib_inflate = require('./zlib/inflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var c            = require('./zlib/constants');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');
var GZheader     = require('./zlib/gzheader');

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 aligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;

},{"./utils/common":5,"./utils/strings":6,"./zlib/constants":8,"./zlib/gzheader":10,"./zlib/inflate":12,"./zlib/messages":14,"./zlib/zstream":15}],5:[function(require,module,exports){
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],6:[function(require,module,exports){
// String encode/decode helpers
'use strict';


var utils = require('./common');


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

},{"./common":5}],7:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;

},{}],8:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};

},{}],9:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;

},{}],10:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;

},{}],11:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};

},{}],12:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils         = require('../utils/common');
var adler32       = require('./adler32');
var crc32         = require('./crc32');
var inflate_fast  = require('./inffast');
var inflate_table = require('./inftrees');

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }
        state.dmax = 1 << len;
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }
              utils.arraySet(
                state.head.extra,
                input,
                next,
                // extra field is limited to 65536 bytes
                // - no need for additional size check
                copy,
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          utils.arraySet(output, input, next, copy, put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inflate_fast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

},{"../utils/common":5,"./adler32":7,"./crc32":9,"./inffast":11,"./inftrees":13}],13:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = require('../utils/common');

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};

},{"../utils/common":5}],14:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],15:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}]},{},[3])(3)
});


/***/ }),

/***/ "./node_modules/plantuml-encoder/dist/plantuml-encoder.js":
/*!****************************************************************!*\
  !*** ./node_modules/plantuml-encoder/dist/plantuml-encoder.js ***!
  \****************************************************************/
/***/ ((module) => {

(function(f){if(true){module.exports=f()}else { var g; }})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=undefined;if(!f&&c)return require(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=undefined,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict'

var pako = require('pako/lib/deflate.js')

module.exports = function (data) {
  return pako.deflateRaw(data, { level: 9, to: 'string' })
}

},{"pako/lib/deflate.js":4}],2:[function(require,module,exports){
'use strict'

// Encode code taken from the PlantUML website:
// http://plantuml.sourceforge.net/codejavascript2.html

// It is described as being "a transformation close to base64"
// The code has been slightly modified to pass linters

function encode6bit (b) {
  if (b < 10) {
    return String.fromCharCode(48 + b)
  }
  b -= 10
  if (b < 26) {
    return String.fromCharCode(65 + b)
  }
  b -= 26
  if (b < 26) {
    return String.fromCharCode(97 + b)
  }
  b -= 26
  if (b === 0) {
    return '-'
  }
  if (b === 1) {
    return '_'
  }
  return '?'
}

function append3bytes (b1, b2, b3) {
  var c1 = b1 >> 2
  var c2 = ((b1 & 0x3) << 4) | (b2 >> 4)
  var c3 = ((b2 & 0xF) << 2) | (b3 >> 6)
  var c4 = b3 & 0x3F
  var r = ''
  r += encode6bit(c1 & 0x3F)
  r += encode6bit(c2 & 0x3F)
  r += encode6bit(c3 & 0x3F)
  r += encode6bit(c4 & 0x3F)
  return r
}

module.exports = function (data) {
  var r = ''
  for (var i = 0; i < data.length; i += 3) {
    if (i + 2 === data.length) {
      r += append3bytes(data.charCodeAt(i), data.charCodeAt(i + 1), 0)
    } else if (i + 1 === data.length) {
      r += append3bytes(data.charCodeAt(i), 0, 0)
    } else {
      r += append3bytes(data.charCodeAt(i),
        data.charCodeAt(i + 1),
        data.charCodeAt(i + 2))
    }
  }
  return r
}

},{}],3:[function(require,module,exports){
'use strict'

var deflate = require('./deflate')
var encode64 = require('./encode64')

module.exports.encode = function (puml) {
  var deflated = deflate(puml)
  return encode64(deflated)
}

},{"./deflate":1,"./encode64":2}],4:[function(require,module,exports){
'use strict';


var zlib_deflate = require('./zlib/deflate');
var utils        = require('./utils/common');
var strings      = require('./utils/strings');
var msg          = require('./zlib/messages');
var ZStream      = require('./zlib/zstream');

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH      = 0;
var Z_FINISH        = 4;

var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_SYNC_FLUSH    = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY    = 0;

var Z_DEFLATED  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;

},{"./utils/common":5,"./utils/strings":6,"./zlib/deflate":9,"./zlib/messages":10,"./zlib/zstream":12}],5:[function(require,module,exports){
'use strict';


var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

},{}],6:[function(require,module,exports){
// String encode/decode helpers
'use strict';


var utils = require('./common');


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};

},{"./common":5}],7:[function(require,module,exports){
'use strict';

// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;

},{}],8:[function(require,module,exports){
'use strict';

// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;

},{}],9:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils   = require('../utils/common');
var trees   = require('./trees');
var adler32 = require('./adler32');
var crc32   = require('./crc32');
var msg     = require('./messages');

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

},{"../utils/common":5,"./adler32":7,"./crc32":8,"./messages":10,"./trees":11}],10:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};

},{}],11:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

var utils = require('../utils/common');

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

},{"../utils/common":5}],12:[function(require,module,exports){
'use strict';

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;

},{}]},{},[3])(3)
});


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/tui-color-picker/dist/tui-color-picker.js":
/*!****************************************************************!*\
  !*** ./node_modules/tui-color-picker/dist/tui-color-picker.js ***!
  \****************************************************************/
/***/ ((module) => {

/*!
 * TOAST UI Color Picker
 * @version 2.2.8
 * @author NHN Cloud FE Development Team <dl_javascript@nhn.com>
 * @license MIT
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_719__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_719__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_719__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_719__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_719__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_719__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__nested_webpack_require_719__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__nested_webpack_require_719__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __nested_webpack_require_719__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__nested_webpack_require_719__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_719__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_719__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_719__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_719__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_719__.p = "dist";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_719__(__nested_webpack_require_719__.s = 33);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Extend the target object from other objects.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * @module object
 */

/**
 * Extend the target object from other objects.
 * @param {object} target - Object that will be extended
 * @param {...object} objects - Objects as sources
 * @returns {object} Extended object
 * @memberof module:object
 */
function extend(target, objects) { // eslint-disable-line no-unused-vars
  var hasOwnProp = Object.prototype.hasOwnProperty;
  var source, prop, i, len;

  for (i = 1, len = arguments.length; i < len; i += 1) {
    source = arguments[i];
    for (prop in source) {
      if (hasOwnProp.call(source, prop)) {
        target[prop] = source[prop];
      }
    }
  }

  return target;
}

module.exports = extend;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Check whether the given variable is an instance of Array or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check whether the given variable is an instance of Array or not.
 * If the given variable is an instance of Array, return true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is array instance?
 * @memberof module:type
 */
function isArray(obj) {
  return obj instanceof Array;
}

module.exports = isArray;


/***/ }),
/* 2 */
/***/ (function(module, exports, __nested_webpack_require_5645__) {

"use strict";
/**
 * @fileoverview Execute the provided callback once for each property of object(or element of array) which actually exist.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isArray = __nested_webpack_require_5645__(1);
var forEachArray = __nested_webpack_require_5645__(6);
var forEachOwnProperties = __nested_webpack_require_5645__(7);

/**
 * @module collection
 */

/**
 * Execute the provided callback once for each property of object(or element of array) which actually exist.
 * If the object is Array-like object(ex-arguments object), It needs to transform to Array.(see 'ex2' of example).
 * If the callback function returns false, the loop will be stopped.
 * Callback function(iteratee) is invoked with three arguments:
 *  1) The value of the property(or The value of the element)
 *  2) The name of the property(or The index of the element)
 *  3) The object being traversed
 * @param {Object} obj The object that will be traversed
 * @param {function} iteratee Callback function
 * @param {Object} [context] Context(this) of callback function
 * @memberof module:collection
 * @example
 * var forEach = require('tui-code-snippet/collection/forEach'); // node, commonjs
 *
 * var sum = 0;
 *
 * forEach([1,2,3], function(value){
 *     sum += value;
 * });
 * alert(sum); // 6
 *
 * // In case of Array-like object
 * var array = Array.prototype.slice.call(arrayLike); // change to array
 * forEach(array, function(value){
 *     sum += value;
 * });
 */
function forEach(obj, iteratee, context) {
  if (isArray(obj)) {
    forEachArray(obj, iteratee, context);
  } else {
    forEachOwnProperties(obj, iteratee, context);
  }
}

module.exports = forEach;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Check whether the given variable is undefined or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check whether the given variable is undefined or not.
 * If the given variable is undefined, returns true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is undefined?
 * @memberof module:type
 */
function isUndefined(obj) {
  return obj === undefined; // eslint-disable-line no-undefined
}

module.exports = isUndefined;


/***/ }),
/* 4 */
/***/ (function(module, exports, __nested_webpack_require_7966__) {

"use strict";
/**
 * @fileoverview Utils for ColorPicker component
 */


var browser = __nested_webpack_require_7966__(22);

var forEach = __nested_webpack_require_7966__(2);

var forEachArray = __nested_webpack_require_7966__(6);

var forEachOwnProperties = __nested_webpack_require_7966__(7);

var sendHostname = __nested_webpack_require_7966__(37);

var currentId = 0;
/**
 * Utils
 * @namespace util
 * @ignore
 */

var utils = {
  /**
   * Get the number of properties in the object.
   * @param {Object} obj - object
   * @returns {number}
   */
  getLength: function (obj) {
    var length = 0;
    forEachOwnProperties(obj, function () {
      length += 1;
    });
    return length;
  },

  /**
   * Constructs a new array by executing the provided callback function.
   * @param {Object|Array} obj - object or array to be traversed
   * @param {function} iteratee - callback function
   * @param {Object} context - context of callback function
   * @returns {Array}
   */
  map: function (obj, iteratee, context) {
    var result = [];
    forEach(obj, function () {
      result.push(iteratee.apply(context || null, arguments));
    });
    return result;
  },

  /**
   * Construct a new array with elements that pass the test by the provided callback function.
   * @param {Array|NodeList|Arguments} arr - array to be traversed
   * @param {function} iteratee - callback function
   * @param {Object} context - context of callback function
   * @returns {Array}
   */
  filter: function (arr, iteratee, context) {
    var result = [];
    forEachArray(arr, function (elem) {
      if (iteratee.apply(context || null, arguments)) {
        result.push(elem);
      }
    });
    return result;
  },

  /**
   * Create an unique id for a color-picker instance.
   * @returns {number}
   */
  generateId: function () {
    currentId += 1;
    return currentId;
  },

  /**
   * True when browser is below IE8.
   */
  isOldBrowser: function () {
    return browser.msie && browser.version < 9;
  }(),

  /**
   * send host name
   * @ignore
   */
  sendHostName: function () {
    sendHostname('color-picker', 'UA-129987462-1');
  }
};
module.exports = utils;

/***/ }),
/* 5 */
/***/ (function(module, exports, __nested_webpack_require_10152__) {

"use strict";
/* eslint-disable complexity */
/**
 * @fileoverview Returns the first index at which a given element can be found in the array.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isArray = __nested_webpack_require_10152__(1);

/**
 * @module array
 */

/**
 * Returns the first index at which a given element can be found in the array
 * from start index(default 0), or -1 if it is not present.
 * It compares searchElement to elements of the Array using strict equality
 * (the same method used by the ===, or triple-equals, operator).
 * @param {*} searchElement Element to locate in the array
 * @param {Array} array Array that will be traversed.
 * @param {number} startIndex Start index in array for searching (default 0)
 * @returns {number} the First index at which a given element, or -1 if it is not present
 * @memberof module:array
 * @example
 * var inArray = require('tui-code-snippet/array/inArray'); // node, commonjs
 *
 * var arr = ['one', 'two', 'three', 'four'];
 * var idx1 = inArray('one', arr, 3); // -1
 * var idx2 = inArray('one', arr); // 0
 */
function inArray(searchElement, array, startIndex) {
  var i;
  var length;
  startIndex = startIndex || 0;

  if (!isArray(array)) {
    return -1;
  }

  if (Array.prototype.indexOf) {
    return Array.prototype.indexOf.call(array, searchElement, startIndex);
  }

  length = array.length;
  for (i = startIndex; startIndex >= 0 && i < length; i += 1) {
    if (array[i] === searchElement) {
      return i;
    }
  }

  return -1;
}

module.exports = inArray;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Execute the provided callback once for each element present in the array(or Array-like object) in ascending order.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Execute the provided callback once for each element present
 * in the array(or Array-like object) in ascending order.
 * If the callback function returns false, the loop will be stopped.
 * Callback function(iteratee) is invoked with three arguments:
 *  1) The value of the element
 *  2) The index of the element
 *  3) The array(or Array-like object) being traversed
 * @param {Array|Arguments|NodeList} arr The array(or Array-like object) that will be traversed
 * @param {function} iteratee Callback function
 * @param {Object} [context] Context(this) of callback function
 * @memberof module:collection
 * @example
 * var forEachArray = require('tui-code-snippet/collection/forEachArray'); // node, commonjs
 *
 * var sum = 0;
 *
 * forEachArray([1,2,3], function(value){
 *     sum += value;
 * });
 * alert(sum); // 6
 */
function forEachArray(arr, iteratee, context) {
  var index = 0;
  var len = arr.length;

  context = context || null;

  for (; index < len; index += 1) {
    if (iteratee.call(context, arr[index], index, arr) === false) {
      break;
    }
  }
}

module.exports = forEachArray;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Execute the provided callback once for each property of object which actually exist.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Execute the provided callback once for each property of object which actually exist.
 * If the callback function returns false, the loop will be stopped.
 * Callback function(iteratee) is invoked with three arguments:
 *  1) The value of the property
 *  2) The name of the property
 *  3) The object being traversed
 * @param {Object} obj The object that will be traversed
 * @param {function} iteratee  Callback function
 * @param {Object} [context] Context(this) of callback function
 * @memberof module:collection
 * @example
 * var forEachOwnProperties = require('tui-code-snippet/collection/forEachOwnProperties'); // node, commonjs
 *
 * var sum = 0;
 *
 * forEachOwnProperties({a:1,b:2,c:3}, function(value){
 *     sum += value;
 * });
 * alert(sum); // 6
 */
function forEachOwnProperties(obj, iteratee, context) {
  var key;

  context = context || null;

  for (key in obj) {
    if (obj.hasOwnProperty(key)) {
      if (iteratee.call(context, obj[key], key, obj) === false) {
        break;
      }
    }
  }
}

module.exports = forEachOwnProperties;


/***/ }),
/* 8 */
/***/ (function(module, exports, __nested_webpack_require_14525__) {

"use strict";
/**
 * @fileoverview The base class of views.
 */


var addClass = __nested_webpack_require_14525__(39);

var isFunction = __nested_webpack_require_14525__(13);

var isNumber = __nested_webpack_require_14525__(41);

var isUndefined = __nested_webpack_require_14525__(3);

var domUtil = __nested_webpack_require_14525__(9);

var Collection = __nested_webpack_require_14525__(19);

var util = __nested_webpack_require_14525__(4);
/**
 * Base class of views.
 *
 * All views create own container element inside supplied container element.
 * @constructor
 * @param {options} options The object for describe view's specs.
 * @param {HTMLElement} container Default container element for view. you can use this element for this.container syntax.
 * @ignore
 */


function View(options, container) {
  var id = util.generateId();
  options = options || {};

  if (isUndefined(container)) {
    container = domUtil.appendHTMLElement('div');
  }

  addClass(container, 'tui-view-' + id);
  /**
   * unique id
   * @type {number}
   */

  this.id = id;
  /**
   * base element of view.
   * @type {HTMLDIVElement}
   */

  this.container = container;
  /**
   * child views.
   * @type {Collection}
   */

  this.childs = new Collection(function (view) {
    return view.id;
  });
  /**
   * parent view instance.
   * @type {View}
   */

  this.parent = null;
}
/**
 * Add child views.
 * @param {View} view The view instance to add.
 * @param {function} [fn] Function for invoke before add. parent view class is supplied first arguments.
 */


View.prototype.addChild = function (view, fn) {
  if (fn) {
    fn.call(view, this);
  } // add parent view


  view.parent = this;
  this.childs.add(view);
};
/**
 * Remove added child view.
 * @param {(number|View)} id View id or instance itself to remove.
 * @param {function} [fn] Function for invoke before remove. parent view class is supplied first arguments.
 */


View.prototype.removeChild = function (id, fn) {
  var view = isNumber(id) ? this.childs.items[id] : id;

  if (fn) {
    fn.call(view, this);
  }

  this.childs.remove(view.id);
};
/**
 * Render view recursively.
 */


View.prototype.render = function () {
  this.childs.each(function (childView) {
    childView.render();
  });
};
/**
 * Invoke function recursively.
 * @param {function} fn - function to invoke child view recursively
 * @param {boolean} [skipThis=false] - set true then skip invoke with this(root) view.
 */


View.prototype.recursive = function (fn, skipThis) {
  if (!isFunction(fn)) {
    return;
  }

  if (!skipThis) {
    fn(this);
  }

  this.childs.each(function (childView) {
    childView.recursive(fn);
  });
};
/**
 * Resize view recursively to parent.
 */


View.prototype.resize = function () {
  var args = Array.prototype.slice.call(arguments);
  var parent = this.parent;

  while (parent) {
    if (isFunction(parent._onResize)) {
      parent._onResize.apply(parent, args);
    }

    parent = parent.parent;
  }
};
/**
 * Invoking method before destroying.
 */


View.prototype._beforeDestroy = function () {};
/**
 * Clear properties
 */


View.prototype._destroy = function () {
  this._beforeDestroy();

  this.container.innerHTML = '';
  this.id = this.parent = this.childs = this.container = null;
};
/**
 * Destroy child view recursively.
 * @param {boolean} isChildView - Whether it is the child view or not
 */


View.prototype.destroy = function (isChildView) {
  if (this.childs) {
    this.childs.each(function (childView) {
      childView.destroy(true);

      childView._destroy();
    });
    this.childs.clear();
  }

  if (isChildView) {
    return;
  }

  this._destroy();
};
/**
 * Calculate view's container element bound.
 * @returns {object} The bound of container element.
 */


View.prototype.getViewBound = function () {
  var bound = this.container.getBoundingClientRect();
  return {
    x: bound.left,
    y: bound.top,
    width: bound.right - bound.left,
    height: bound.bottom - bound.top
  };
};

module.exports = View;

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Utility modules for manipulate DOM elements.
 */


var domUtil = {
  /**
   * Create DOM element and return it.
   * @param {string} tagName Tag name to append.
   * @param {HTMLElement} [container] HTML element will be parent to created element.
   * if not supplied, will use **document.body**
   * @param {string} [className] Design class names to appling created element.
   * @returns {HTMLElement} HTML element created.
   */
  appendHTMLElement: function (tagName, container, className) {
    var el = document.createElement(tagName);
    el.className = className || '';

    if (container) {
      container.appendChild(el);
    } else {
      document.body.appendChild(el);
    }

    return el;
  }
};
module.exports = domUtil;

/***/ }),
/* 10 */
/***/ (function(module, exports, __nested_webpack_require_19377__) {

"use strict";
/**
 * @fileoverview This module provides some functions for custom events. And it is implemented in the observer design pattern.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var extend = __nested_webpack_require_19377__(0);
var isExisty = __nested_webpack_require_19377__(20);
var isString = __nested_webpack_require_19377__(11);
var isObject = __nested_webpack_require_19377__(21);
var isArray = __nested_webpack_require_19377__(1);
var isFunction = __nested_webpack_require_19377__(13);
var forEach = __nested_webpack_require_19377__(2);

var R_EVENTNAME_SPLIT = /\s+/g;

/**
 * @class
 * @example
 * // node, commonjs
 * var CustomEvents = require('tui-code-snippet/customEvents/customEvents');
 */
function CustomEvents() {
  /**
     * @type {HandlerItem[]}
     */
  this.events = null;

  /**
     * only for checking specific context event was binded
     * @type {object[]}
     */
  this.contexts = null;
}

/**
 * Mixin custom events feature to specific constructor
 * @param {function} func - constructor
 * @example
 * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
 *
 * var model;
 * function Model() {
 *     this.name = '';
 * }
 * CustomEvents.mixin(Model);
 *
 * model = new Model();
 * model.on('change', function() { this.name = 'model'; }, this);
 * model.fire('change');
 * alert(model.name); // 'model';
 */
CustomEvents.mixin = function(func) {
  extend(func.prototype, CustomEvents.prototype);
};

/**
 * Get HandlerItem object
 * @param {function} handler - handler function
 * @param {object} [context] - context for handler
 * @returns {HandlerItem} HandlerItem object
 * @private
 */
CustomEvents.prototype._getHandlerItem = function(handler, context) {
  var item = {handler: handler};

  if (context) {
    item.context = context;
  }

  return item;
};

/**
 * Get event object safely
 * @param {string} [eventName] - create sub event map if not exist.
 * @returns {(object|array)} event object. if you supplied `eventName`
 *  parameter then make new array and return it
 * @private
 */
CustomEvents.prototype._safeEvent = function(eventName) {
  var events = this.events;
  var byName;

  if (!events) {
    events = this.events = {};
  }

  if (eventName) {
    byName = events[eventName];

    if (!byName) {
      byName = [];
      events[eventName] = byName;
    }

    events = byName;
  }

  return events;
};

/**
 * Get context array safely
 * @returns {array} context array
 * @private
 */
CustomEvents.prototype._safeContext = function() {
  var context = this.contexts;

  if (!context) {
    context = this.contexts = [];
  }

  return context;
};

/**
 * Get index of context
 * @param {object} ctx - context that used for bind custom event
 * @returns {number} index of context
 * @private
 */
CustomEvents.prototype._indexOfContext = function(ctx) {
  var context = this._safeContext();
  var index = 0;

  while (context[index]) {
    if (ctx === context[index][0]) {
      return index;
    }

    index += 1;
  }

  return -1;
};

/**
 * Memorize supplied context for recognize supplied object is context or
 *  name: handler pair object when off()
 * @param {object} ctx - context object to memorize
 * @private
 */
CustomEvents.prototype._memorizeContext = function(ctx) {
  var context, index;

  if (!isExisty(ctx)) {
    return;
  }

  context = this._safeContext();
  index = this._indexOfContext(ctx);

  if (index > -1) {
    context[index][1] += 1;
  } else {
    context.push([ctx, 1]);
  }
};

/**
 * Forget supplied context object
 * @param {object} ctx - context object to forget
 * @private
 */
CustomEvents.prototype._forgetContext = function(ctx) {
  var context, contextIndex;

  if (!isExisty(ctx)) {
    return;
  }

  context = this._safeContext();
  contextIndex = this._indexOfContext(ctx);

  if (contextIndex > -1) {
    context[contextIndex][1] -= 1;

    if (context[contextIndex][1] <= 0) {
      context.splice(contextIndex, 1);
    }
  }
};

/**
 * Bind event handler
 * @param {(string|{name:string, handler:function})} eventName - custom
 *  event name or an object {eventName: handler}
 * @param {(function|object)} [handler] - handler function or context
 * @param {object} [context] - context for binding
 * @private
 */
CustomEvents.prototype._bindEvent = function(eventName, handler, context) {
  var events = this._safeEvent(eventName);
  this._memorizeContext(context);
  events.push(this._getHandlerItem(handler, context));
};

/**
 * Bind event handlers
 * @param {(string|{name:string, handler:function})} eventName - custom
 *  event name or an object {eventName: handler}
 * @param {(function|object)} [handler] - handler function or context
 * @param {object} [context] - context for binding
 * //-- #1. Get Module --//
 * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
 *
 * //-- #2. Use method --//
 * // # 2.1 Basic Usage
 * CustomEvents.on('onload', handler);
 *
 * // # 2.2 With context
 * CustomEvents.on('onload', handler, myObj);
 *
 * // # 2.3 Bind by object that name, handler pairs
 * CustomEvents.on({
 *     'play': handler,
 *     'pause': handler2
 * });
 *
 * // # 2.4 Bind by object that name, handler pairs with context object
 * CustomEvents.on({
 *     'play': handler
 * }, myObj);
 */
CustomEvents.prototype.on = function(eventName, handler, context) {
  var self = this;

  if (isString(eventName)) {
    // [syntax 1, 2]
    eventName = eventName.split(R_EVENTNAME_SPLIT);
    forEach(eventName, function(name) {
      self._bindEvent(name, handler, context);
    });
  } else if (isObject(eventName)) {
    // [syntax 3, 4]
    context = handler;
    forEach(eventName, function(func, name) {
      self.on(name, func, context);
    });
  }
};

/**
 * Bind one-shot event handlers
 * @param {(string|{name:string,handler:function})} eventName - custom
 *  event name or an object {eventName: handler}
 * @param {function|object} [handler] - handler function or context
 * @param {object} [context] - context for binding
 */
CustomEvents.prototype.once = function(eventName, handler, context) {
  var self = this;

  if (isObject(eventName)) {
    context = handler;
    forEach(eventName, function(func, name) {
      self.once(name, func, context);
    });

    return;
  }

  function onceHandler() { // eslint-disable-line require-jsdoc
    handler.apply(context, arguments);
    self.off(eventName, onceHandler, context);
  }

  this.on(eventName, onceHandler, context);
};

/**
 * Splice supplied array by callback result
 * @param {array} arr - array to splice
 * @param {function} predicate - function return boolean
 * @private
 */
CustomEvents.prototype._spliceMatches = function(arr, predicate) {
  var i = 0;
  var len;

  if (!isArray(arr)) {
    return;
  }

  for (len = arr.length; i < len; i += 1) {
    if (predicate(arr[i]) === true) {
      arr.splice(i, 1);
      len -= 1;
      i -= 1;
    }
  }
};

/**
 * Get matcher for unbind specific handler events
 * @param {function} handler - handler function
 * @returns {function} handler matcher
 * @private
 */
CustomEvents.prototype._matchHandler = function(handler) {
  var self = this;

  return function(item) {
    var needRemove = handler === item.handler;

    if (needRemove) {
      self._forgetContext(item.context);
    }

    return needRemove;
  };
};

/**
 * Get matcher for unbind specific context events
 * @param {object} context - context
 * @returns {function} object matcher
 * @private
 */
CustomEvents.prototype._matchContext = function(context) {
  var self = this;

  return function(item) {
    var needRemove = context === item.context;

    if (needRemove) {
      self._forgetContext(item.context);
    }

    return needRemove;
  };
};

/**
 * Get matcher for unbind specific hander, context pair events
 * @param {function} handler - handler function
 * @param {object} context - context
 * @returns {function} handler, context matcher
 * @private
 */
CustomEvents.prototype._matchHandlerAndContext = function(handler, context) {
  var self = this;

  return function(item) {
    var matchHandler = (handler === item.handler);
    var matchContext = (context === item.context);
    var needRemove = (matchHandler && matchContext);

    if (needRemove) {
      self._forgetContext(item.context);
    }

    return needRemove;
  };
};

/**
 * Unbind event by event name
 * @param {string} eventName - custom event name to unbind
 * @param {function} [handler] - handler function
 * @private
 */
CustomEvents.prototype._offByEventName = function(eventName, handler) {
  var self = this;
  var andByHandler = isFunction(handler);
  var matchHandler = self._matchHandler(handler);

  eventName = eventName.split(R_EVENTNAME_SPLIT);

  forEach(eventName, function(name) {
    var handlerItems = self._safeEvent(name);

    if (andByHandler) {
      self._spliceMatches(handlerItems, matchHandler);
    } else {
      forEach(handlerItems, function(item) {
        self._forgetContext(item.context);
      });

      self.events[name] = [];
    }
  });
};

/**
 * Unbind event by handler function
 * @param {function} handler - handler function
 * @private
 */
CustomEvents.prototype._offByHandler = function(handler) {
  var self = this;
  var matchHandler = this._matchHandler(handler);

  forEach(this._safeEvent(), function(handlerItems) {
    self._spliceMatches(handlerItems, matchHandler);
  });
};

/**
 * Unbind event by object(name: handler pair object or context object)
 * @param {object} obj - context or {name: handler} pair object
 * @param {function} handler - handler function
 * @private
 */
CustomEvents.prototype._offByObject = function(obj, handler) {
  var self = this;
  var matchFunc;

  if (this._indexOfContext(obj) < 0) {
    forEach(obj, function(func, name) {
      self.off(name, func);
    });
  } else if (isString(handler)) {
    matchFunc = this._matchContext(obj);

    self._spliceMatches(this._safeEvent(handler), matchFunc);
  } else if (isFunction(handler)) {
    matchFunc = this._matchHandlerAndContext(handler, obj);

    forEach(this._safeEvent(), function(handlerItems) {
      self._spliceMatches(handlerItems, matchFunc);
    });
  } else {
    matchFunc = this._matchContext(obj);

    forEach(this._safeEvent(), function(handlerItems) {
      self._spliceMatches(handlerItems, matchFunc);
    });
  }
};

/**
 * Unbind custom events
 * @param {(string|object|function)} eventName - event name or context or
 *  {name: handler} pair object or handler function
 * @param {(function)} handler - handler function
 * @example
 * //-- #1. Get Module --//
 * var CustomEvents = require('tui-code-snippet/customEvents/customEvents'); // node, commonjs
 *
 * //-- #2. Use method --//
 * // # 2.1 off by event name
 * CustomEvents.off('onload');
 *
 * // # 2.2 off by event name and handler
 * CustomEvents.off('play', handler);
 *
 * // # 2.3 off by handler
 * CustomEvents.off(handler);
 *
 * // # 2.4 off by context
 * CustomEvents.off(myObj);
 *
 * // # 2.5 off by context and handler
 * CustomEvents.off(myObj, handler);
 *
 * // # 2.6 off by context and event name
 * CustomEvents.off(myObj, 'onload');
 *
 * // # 2.7 off by an Object.<string, function> that is {eventName: handler}
 * CustomEvents.off({
 *   'play': handler,
 *   'pause': handler2
 * });
 *
 * // # 2.8 off the all events
 * CustomEvents.off();
 */
CustomEvents.prototype.off = function(eventName, handler) {
  if (isString(eventName)) {
    // [syntax 1, 2]
    this._offByEventName(eventName, handler);
  } else if (!arguments.length) {
    // [syntax 8]
    this.events = {};
    this.contexts = [];
  } else if (isFunction(eventName)) {
    // [syntax 3]
    this._offByHandler(eventName);
  } else if (isObject(eventName)) {
    // [syntax 4, 5, 6]
    this._offByObject(eventName, handler);
  }
};

/**
 * Fire custom event
 * @param {string} eventName - name of custom event
 */
CustomEvents.prototype.fire = function(eventName) {  // eslint-disable-line
  this.invoke.apply(this, arguments);
};

/**
 * Fire a event and returns the result of operation 'boolean AND' with all
 *  listener's results.
 *
 * So, It is different from {@link CustomEvents#fire}.
 *
 * In service code, use this as a before event in component level usually
 *  for notifying that the event is cancelable.
 * @param {string} eventName - Custom event name
 * @param {...*} data - Data for event
 * @returns {boolean} The result of operation 'boolean AND'
 * @example
 * var map = new Map();
 * map.on({
 *     'beforeZoom': function() {
 *         // It should cancel the 'zoom' event by some conditions.
 *         if (that.disabled && this.getState()) {
 *             return false;
 *         }
 *         return true;
 *     }
 * });
 *
 * if (this.invoke('beforeZoom')) {    // check the result of 'beforeZoom'
 *     // if true,
 *     // doSomething
 * }
 */
CustomEvents.prototype.invoke = function(eventName) {
  var events, args, index, item;

  if (!this.hasListener(eventName)) {
    return true;
  }

  events = this._safeEvent(eventName);
  args = Array.prototype.slice.call(arguments, 1);
  index = 0;

  while (events[index]) {
    item = events[index];

    if (item.handler.apply(item.context, args) === false) {
      return false;
    }

    index += 1;
  }

  return true;
};

/**
 * Return whether at least one of the handlers is registered in the given
 *  event name.
 * @param {string} eventName - Custom event name
 * @returns {boolean} Is there at least one handler in event name?
 */
CustomEvents.prototype.hasListener = function(eventName) {
  return this.getListenerLength(eventName) > 0;
};

/**
 * Return a count of events registered.
 * @param {string} eventName - Custom event name
 * @returns {number} number of event
 */
CustomEvents.prototype.getListenerLength = function(eventName) {
  var events = this._safeEvent(eventName);

  return events.length;
};

module.exports = CustomEvents;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Check whether the given variable is a string or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check whether the given variable is a string or not.
 * If the given variable is a string, return true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is string?
 * @memberof module:type
 */
function isString(obj) {
  return typeof obj === 'string' || obj instanceof String;
}

module.exports = isString;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Utility methods to manipulate colors
 */


var hexRX = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i;
var colorUtil = {
  /**
   * pad left zero characters.
   * @param {number} number number value to pad zero.
   * @param {number} length pad length to want.
   * @returns {string} padded string.
   */
  leadingZero: function (number, length) {
    var zero = '';
    var i = 0;

    if ((number + '').length > length) {
      return number + '';
    }

    for (; i < length - 1; i += 1) {
      zero += '0';
    }

    return (zero + number).slice(length * -1);
  },

  /**
   * Check validate of hex string value is RGB
   * @param {string} str - rgb hex string
   * @returns {boolean} return true when supplied str is valid RGB hex string
   */
  isValidRGB: function (str) {
    return hexRX.test(str);
  },
  // @license RGB <-> HSV conversion utilities based off of http://www.cs.rit.edu/~ncs/color/t_convert.html

  /**
   * Convert color hex string to rgb number array
   * @param {string} hexStr - hex string
   * @returns {number[]} rgb numbers
   */
  hexToRGB: function (hexStr) {
    var r, g, b;

    if (!colorUtil.isValidRGB(hexStr)) {
      return false;
    }

    hexStr = hexStr.substring(1);
    r = parseInt(hexStr.substr(0, 2), 16);
    g = parseInt(hexStr.substr(2, 2), 16);
    b = parseInt(hexStr.substr(4, 2), 16);
    return [r, g, b];
  },

  /**
   * Convert rgb number to hex string
   * @param {number} r - red
   * @param {number} g - green
   * @param {number} b - blue
   * @returns {string|boolean} return false when supplied rgb number is not valid. otherwise, converted hex string
   */
  rgbToHEX: function (r, g, b) {
    var hexStr = '#' + colorUtil.leadingZero(r.toString(16), 2) + colorUtil.leadingZero(g.toString(16), 2) + colorUtil.leadingZero(b.toString(16), 2);

    if (colorUtil.isValidRGB(hexStr)) {
      return hexStr;
    }

    return false;
  },

  /**
   * Convert rgb number to HSV value
   * @param {number} r - red
   * @param {number} g - green
   * @param {number} b - blue
   * @returns {number[]} hsv value
   */
  rgbToHSV: function (r, g, b) {
    var max, min, h, s, v, d;
    r /= 255;
    g /= 255;
    b /= 255;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    v = max;
    d = max - min;
    s = max === 0 ? 0 : d / max;

    if (max === min) {
      h = 0;
    } else {
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;

        case g:
          h = (b - r) / d + 2;
          break;

        case b:
          h = (r - g) / d + 4;
          break;
        // no default
      }

      h /= 6;
    }

    return [Math.round(h * 360), Math.round(s * 100), Math.round(v * 100)];
  },

  /**
   * Convert HSV number to RGB
   * @param {number} h - hue
   * @param {number} s - saturation
   * @param {number} v - value
   * @returns {number[]} rgb value
   */
  hsvToRGB: function (h, s, v) {
    var r, g, b;
    var i;
    var f, p, q, t;
    h = Math.max(0, Math.min(360, h));
    s = Math.max(0, Math.min(100, s));
    v = Math.max(0, Math.min(100, v));
    s /= 100;
    v /= 100;

    if (s === 0) {
      // Achromatic (grey)
      r = g = b = v;
      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    h /= 60; // sector 0 to 5

    i = Math.floor(h);
    f = h - i; // factorial part of h

    p = v * (1 - s);
    q = v * (1 - s * f);
    t = v * (1 - s * (1 - f));

    switch (i) {
      case 0:
        r = v;
        g = t;
        b = p;
        break;

      case 1:
        r = q;
        g = v;
        b = p;
        break;

      case 2:
        r = p;
        g = v;
        b = t;
        break;

      case 3:
        r = p;
        g = q;
        b = v;
        break;

      case 4:
        r = t;
        g = p;
        b = v;
        break;

      default:
        r = v;
        g = p;
        b = q;
        break;
    }

    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
  }
};
module.exports = colorUtil;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Check whether the given variable is a function or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check whether the given variable is a function or not.
 * If the given variable is a function, return true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is function?
 * @memberof module:type
 */
function isFunction(obj) {
  return obj instanceof Function;
}

module.exports = isFunction;


/***/ }),
/* 14 */
/***/ (function(module, exports, __nested_webpack_require_38558__) {

"use strict";
/**
 * @fileoverview Bind DOM events
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isString = __nested_webpack_require_38558__(11);
var forEach = __nested_webpack_require_38558__(2);

var safeEvent = __nested_webpack_require_38558__(26);

/**
 * Bind DOM events.
 * @param {HTMLElement} element - element to bind events
 * @param {(string|object)} types - Space splitted events names or eventName:handler object
 * @param {(function|object)} handler - handler function or context for handler method
 * @param {object} [context] context - context for handler method.
 * @memberof module:domEvent
 * @example
 * var div = document.querySelector('div');
 * 
 * // Bind one event to an element.
 * on(div, 'click', toggle);
 * 
 * // Bind multiple events with a same handler to multiple elements at once.
 * // Use event names splitted by a space.
 * on(div, 'mouseenter mouseleave', changeColor);
 * 
 * // Bind multiple events with different handlers to an element at once.
 * // Use an object which of key is an event name and value is a handler function.
 * on(div, {
 *   keydown: highlight,
 *   keyup: dehighlight
 * });
 * 
 * // Set a context for handler method.
 * var name = 'global';
 * var repository = {name: 'CodeSnippet'};
 * on(div, 'drag', function() {
 *  console.log(this.name);
 * }, repository);
 * // Result when you drag a div: "CodeSnippet"
 */
function on(element, types, handler, context) {
  if (isString(types)) {
    forEach(types.split(/\s+/g), function(type) {
      bindEvent(element, type, handler, context);
    });

    return;
  }

  forEach(types, function(func, type) {
    bindEvent(element, type, func, handler);
  });
}

/**
 * Bind DOM events
 * @param {HTMLElement} element - element to bind events
 * @param {string} type - events name
 * @param {function} handler - handler function or context for handler method
 * @param {object} [context] context - context for handler method.
 * @private
 */
function bindEvent(element, type, handler, context) {
  /**
     * Event handler
     * @param {Event} e - event object
     */
  function eventHandler(e) {
    handler.call(context || element, e || window.event);
  }

  if ('addEventListener' in element) {
    element.addEventListener(type, eventHandler);
  } else if ('attachEvent' in element) {
    element.attachEvent('on' + type, eventHandler);
  }
  memorizeHandler(element, type, handler, eventHandler);
}

/**
 * Memorize DOM event handler for unbinding.
 * @param {HTMLElement} element - element to bind events
 * @param {string} type - events name
 * @param {function} handler - handler function that user passed at on() use
 * @param {function} wrappedHandler - handler function that wrapped by domevent for implementing some features
 * @private
 */
function memorizeHandler(element, type, handler, wrappedHandler) {
  var events = safeEvent(element, type);
  var existInEvents = false;

  forEach(events, function(obj) {
    if (obj.handler === handler) {
      existInEvents = true;

      return false;
    }

    return true;
  });

  if (!existInEvents) {
    events.push({
      handler: handler,
      wrappedHandler: wrappedHandler
    });
  }
}

module.exports = on;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Prevent default action
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Prevent default action
 * @param {Event} e - event object
 * @memberof module:domEvent
 */
function preventDefault(e) {
  if (e.preventDefault) {
    e.preventDefault();

    return;
  }

  e.returnValue = false;
}

module.exports = preventDefault;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Convert kebab-case
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Convert kebab-case
 * @param {string} key - string to be converted to Kebab-case
 * @private
 */
function convertToKebabCase(key) {
  return key.replace(/([A-Z])/g, function(match) {
    return '-' + match.toLowerCase();
  });
}

module.exports = convertToKebabCase;


/***/ }),
/* 17 */
/***/ (function(module, exports, __nested_webpack_require_42739__) {

"use strict";
/**
 * @fileoverview Unbind DOM events
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isString = __nested_webpack_require_42739__(11);
var forEach = __nested_webpack_require_42739__(2);

var safeEvent = __nested_webpack_require_42739__(26);

/**
 * Unbind DOM events
 * If a handler function is not passed, remove all events of that type.
 * @param {HTMLElement} element - element to unbind events
 * @param {(string|object)} types - Space splitted events names or eventName:handler object
 * @param {function} [handler] - handler function
 * @memberof module:domEvent
 * @example
 * // Following the example of domEvent#on
 * 
 * // Unbind one event from an element.
 * off(div, 'click', toggle);
 * 
 * // Unbind multiple events with a same handler from multiple elements at once.
 * // Use event names splitted by a space.
 * off(element, 'mouseenter mouseleave', changeColor);
 * 
 * // Unbind multiple events with different handlers from an element at once.
 * // Use an object which of key is an event name and value is a handler function.
 * off(div, {
 *   keydown: highlight,
 *   keyup: dehighlight
 * });
 * 
 * // Unbind events without handlers.
 * off(div, 'drag');
 */
function off(element, types, handler) {
  if (isString(types)) {
    forEach(types.split(/\s+/g), function(type) {
      unbindEvent(element, type, handler);
    });

    return;
  }

  forEach(types, function(func, type) {
    unbindEvent(element, type, func);
  });
}

/**
 * Unbind DOM events
 * If a handler function is not passed, remove all events of that type.
 * @param {HTMLElement} element - element to unbind events
 * @param {string} type - events name
 * @param {function} [handler] - handler function
 * @private
 */
function unbindEvent(element, type, handler) {
  var events = safeEvent(element, type);
  var index;

  if (!handler) {
    forEach(events, function(item) {
      removeHandler(element, type, item.wrappedHandler);
    });
    events.splice(0, events.length);
  } else {
    forEach(events, function(item, idx) {
      if (handler === item.handler) {
        removeHandler(element, type, item.wrappedHandler);
        index = idx;

        return false;
      }

      return true;
    });
    events.splice(index, 1);
  }
}

/**
 * Remove an event handler
 * @param {HTMLElement} element - An element to remove an event
 * @param {string} type - event type
 * @param {function} handler - event handler
 * @private
 */
function removeHandler(element, type, handler) {
  if ('removeEventListener' in element) {
    element.removeEventListener(type, handler);
  } else if ('detachEvent' in element) {
    element.detachEvent('on' + type, handler);
  }
}

module.exports = off;


/***/ }),
/* 18 */
/***/ (function(module, exports, __nested_webpack_require_45502__) {

"use strict";
/**
 * @fileoverview Provide a simple inheritance in prototype-oriented.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var createObject = __nested_webpack_require_45502__(50);

/**
 * Provide a simple inheritance in prototype-oriented.
 * Caution :
 *  Don't overwrite the prototype of child constructor.
 *
 * @param {function} subType Child constructor
 * @param {function} superType Parent constructor
 * @memberof module:inheritance
 * @example
 * var inherit = require('tui-code-snippet/inheritance/inherit'); // node, commonjs
 *
 * // Parent constructor
 * function Animal(leg) {
 *     this.leg = leg;
 * }
 * Animal.prototype.growl = function() {
 *     // ...
 * };
 *
 * // Child constructor
 * function Person(name) {
 *     this.name = name;
 * }
 *
 * // Inheritance
 * inherit(Person, Animal);
 *
 * // After this inheritance, please use only the extending of property.
 * // Do not overwrite prototype.
 * Person.prototype.walk = function(direction) {
 *     // ...
 * };
 */
function inherit(subType, superType) {
  var prototype = createObject(superType.prototype);
  prototype.constructor = subType;
  subType.prototype = prototype;
}

module.exports = inherit;


/***/ }),
/* 19 */
/***/ (function(module, exports, __nested_webpack_require_46781__) {

"use strict";
/**
 * @fileoverview Common collections.
 */


var forEachArray = __nested_webpack_require_46781__(6);

var forEachOwnProperties = __nested_webpack_require_46781__(7);

var extend = __nested_webpack_require_46781__(0);

var isArray = __nested_webpack_require_46781__(1);

var isExisty = __nested_webpack_require_46781__(20);

var isFunction = __nested_webpack_require_46781__(13);

var isObject = __nested_webpack_require_46781__(21);

var util = __nested_webpack_require_46781__(4);

var slice = Array.prototype.slice;
/**
 * Common collection.
 *
 * It need function for get model's unique id.
 *
 * if the function is not supplied then it use default function {@link Collection#getItemID}
 * @constructor
 * @param {function} [getItemIDFn] function for get model's id.
 * @ignore
 */

function Collection(getItemIDFn) {
  /**
   * @type {object.<string, *>}
   */
  this.items = {};
  /**
   * @type {number}
   */

  this.length = 0;

  if (isFunction(getItemIDFn)) {
    /**
     * @type {function}
     */
    this.getItemID = getItemIDFn;
  }
}
/**********
 * static props
 **********/

/**
 * Combind supplied function filters and condition.
 * @param {...function} filters - function filters
 * @returns {function} combined filter
 */


Collection.and = function (filters) {
  var cnt;
  filters = slice.call(arguments);
  cnt = filters.length;
  return function (item) {
    var i = 0;

    for (; i < cnt; i += 1) {
      if (!filters[i].call(null, item)) {
        return false;
      }
    }

    return true;
  };
};
/**
 * Combine multiple function filters with OR clause.
 * @param {...function} filters - function filters
 * @returns {function} combined filter
 */


Collection.or = function (filters) {
  var cnt;
  filters = slice.call(arguments);
  cnt = filters.length;
  return function (item) {
    var i = 1;
    var result = filters[0].call(null, item);

    for (; i < cnt; i += 1) {
      result = result || filters[i].call(null, item);
    }

    return result;
  };
};
/**
 * Merge several collections.
 *
 * You can\'t merge collections different _getEventID functions. Take case of use.
 * @param {...Collection} collections collection arguments to merge
 * @returns {Collection} merged collection.
 */


Collection.merge = function (firstCollection) {
  var newItems = {};
  var merged = new Collection(firstCollection.getItemID);
  forEachArray(arguments, function (col) {
    extend(newItems, col.items);
  });
  merged.items = newItems;
  merged.length = util.getLength(merged.items);
  return merged;
};
/**********
 * prototype props
 **********/

/**
 * get model's unique id.
 * @param {object} item model instance.
 * @returns {number} model unique id.
 */


Collection.prototype.getItemID = function (item) {
  return item._id + '';
};
/**
 * add models.
 * @param {...*} item models to add this collection.
 */


Collection.prototype.add = function (item) {
  var id, ownItems;

  if (arguments.length > 1) {
    forEachArray(slice.call(arguments), function (o) {
      this.add(o);
    }, this);
    return;
  }

  id = this.getItemID(item);
  ownItems = this.items;

  if (!ownItems[id]) {
    this.length += 1;
  }

  ownItems[id] = item;
};
/**
 * remove models.
 * @param {...(object|string|number)} id model instance or unique id to delete.
 * @returns {array} deleted model list.
 */


Collection.prototype.remove = function (id) {
  var removed = [];
  var ownItems, itemToRemove;

  if (!this.length) {
    return removed;
  }

  if (arguments.length > 1) {
    removed = util.map(slice.call(arguments), function (id) {
      return this.remove(id);
    }, this);
    return removed;
  }

  ownItems = this.items;

  if (isObject(id)) {
    id = this.getItemID(id);
  }

  if (!ownItems[id]) {
    return removed;
  }

  this.length -= 1;
  itemToRemove = ownItems[id];
  delete ownItems[id];
  return itemToRemove;
};
/**
 * remove all models in collection.
 */


Collection.prototype.clear = function () {
  this.items = {};
  this.length = 0;
};
/**
 * check collection has specific model.
 * @param {(object|string|number|function)} id model instance or id or filter function to check
 * @returns {boolean} is has model?
 */


Collection.prototype.has = function (id) {
  var isFilter, has;

  if (!this.length) {
    return false;
  }

  isFilter = isFunction(id);
  has = false;

  if (isFilter) {
    this.each(function (item) {
      if (id(item) === true) {
        has = true;
        return false;
      }

      return true;
    });
  } else {
    id = isObject(id) ? this.getItemID(id) : id;
    has = isExisty(this.items[id]);
  }

  return has;
};
/**
 * invoke callback when model exist in collection.
 * @param {(string|number)} id model unique id.
 * @param {function} fn the callback.
 * @param {*} [context] callback context.
 */


Collection.prototype.doWhenHas = function (id, fn, context) {
  var item = this.items[id];

  if (!isExisty(item)) {
    return;
  }

  fn.call(context || this, item);
};
/**
 * Search model. and return new collection.
 * @param {function} filter filter function.
 * @returns {Collection} new collection with filtered models.
 * @example
 * collection.find(function(item) {
 *     return item.edited === true;
 * });
 *
 * function filter1(item) {
 *     return item.edited === false;
 * }
 *
 * function filter2(item) {
 *     return item.disabled === false;
 * }
 *
 * collection.find(Collection.and(filter1, filter2));
 *
 * collection.find(Collection.or(filter1, filter2));
 */


Collection.prototype.find = function (filter) {
  var result = new Collection();

  if (this.hasOwnProperty('getItemID')) {
    result.getItemID = this.getItemID;
  }

  this.each(function (item) {
    if (filter(item) === true) {
      result.add(item);
    }
  });
  return result;
};
/**
 * Group element by specific key values.
 *
 * if key parameter is function then invoke it and use returned value.
 * @param {(string|number|function|array)} key key property or getter function. if string[] supplied, create each collection before grouping.
 * @param {function} [groupFunc] - function that return each group's key
 * @returns {object.<string, Collection>} grouped object
 * @example
 *
 * // pass `string`, `number`, `boolean` type value then group by property value.
 * collection.groupBy('gender');    // group by 'gender' property value.
 * collection.groupBy(50);          // group by '50' property value.
 *
 * // pass `function` then group by return value. each invocation `function` is called with `(item)`.
 * collection.groupBy(function(item) {
 *     if (item.score > 60) {
 *         return 'pass';
 *     }
 *     return 'fail';
 * });
 *
 * // pass `array` with first arguments then create each collection before grouping.
 * collection.groupBy(['go', 'ruby', 'javascript']);
 * // result: { 'go': empty Collection, 'ruby': empty Collection, 'javascript': empty Collection }
 *
 * // can pass `function` with `array` then group each elements.
 * collection.groupBy(['go', 'ruby', 'javascript'], function(item) {
 *     if (item.isFast) {
 *         return 'go';
 *     }
 *
 *     return item.name;
 * });
 */


Collection.prototype.groupBy = function (key, groupFunc) {
  var result = {};
  var keyIsFunc = isFunction(key);
  var getItemIDFn = this.getItemID;
  var collection, baseValue;

  if (isArray(key)) {
    forEachArray(key, function (k) {
      result[k + ''] = new Collection(getItemIDFn);
    });

    if (!groupFunc) {
      return result;
    }

    key = groupFunc;
    keyIsFunc = true;
  }

  this.each(function (item) {
    if (keyIsFunc) {
      baseValue = key(item);
    } else {
      baseValue = item[key];

      if (isFunction(baseValue)) {
        baseValue = baseValue.apply(item);
      }
    }

    collection = result[baseValue];

    if (!collection) {
      collection = result[baseValue] = new Collection(getItemIDFn);
    }

    collection.add(item);
  });
  return result;
};
/**
 * Return single item in collection.
 *
 * Returned item is inserted in this collection firstly.
 * @returns {object} item.
 */


Collection.prototype.single = function () {
  var result;
  this.each(function (item) {
    result = item;
    return false;
  }, this);
  return result;
};
/**
 * sort a basis of supplied compare function.
 * @param {function} compareFunction compareFunction
 * @returns {array} sorted array.
 */


Collection.prototype.sort = function (compareFunction) {
  var arr = [];
  this.each(function (item) {
    arr.push(item);
  });

  if (isFunction(compareFunction)) {
    arr = arr.sort(compareFunction);
  }

  return arr;
};
/**
 * iterate each model element.
 *
 * when iteratee return false then break the loop.
 * @param {function} iteratee iteratee(item, index, items)
 * @param {*} [context] context
 */


Collection.prototype.each = function (iteratee, context) {
  forEachOwnProperties(this.items, iteratee, context || this);
};
/**
 * return new array with collection items.
 * @returns {array} new array.
 */


Collection.prototype.toArray = function () {
  if (!this.length) {
    return [];
  }

  return util.map(this.items, function (item) {
    return item;
  });
};

module.exports = Collection;

/***/ }),
/* 20 */
/***/ (function(module, exports, __nested_webpack_require_55933__) {

"use strict";
/**
 * @fileoverview Check whether the given variable is existing or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isUndefined = __nested_webpack_require_55933__(3);
var isNull = __nested_webpack_require_55933__(36);

/**
 * Check whether the given variable is existing or not.
 * If the given variable is not null and not undefined, returns true.
 * @param {*} param - Target for checking
 * @returns {boolean} Is existy?
 * @memberof module:type
 * @example
 * var isExisty = require('tui-code-snippet/type/isExisty'); // node, commonjs
 *
 * isExisty(''); //true
 * isExisty(0); //true
 * isExisty([]); //true
 * isExisty({}); //true
 * isExisty(null); //false
 * isExisty(undefined); //false
*/
function isExisty(param) {
  return !isUndefined(param) && !isNull(param);
}

module.exports = isExisty;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Check whether the given variable is an object or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check whether the given variable is an object or not.
 * If the given variable is an object, return true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is object?
 * @memberof module:type
 */
function isObject(obj) {
  return obj === Object(obj);
}

module.exports = isObject;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview This module detects the kind of well-known browser and version.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Browser module
 * @module browser
 */

/**
 * This object has an information that indicate the kind of browser. It can detect IE8 ~ IE11, Chrome, Firefox, Safari, and Edge.
 * @memberof module:browser
 * @example
 * var browser = require('tui-code-snippet/browser/browser'); // node, commonjs
 *
 * browser.chrome === true; // chrome
 * browser.firefox === true; // firefox
 * browser.safari === true; // safari
 * browser.msie === true; // IE
 * browser.edge === true; // edge
 * browser.others === true; // other browser
 * browser.version; // browser version
 */
var browser = {
  chrome: false,
  firefox: false,
  safari: false,
  msie: false,
  edge: false,
  others: false,
  version: 0
};

if (typeof window !== 'undefined' && window.navigator) {
  detectBrowser();
}

/**
 * Detect the browser.
 * @private
 */
function detectBrowser() {
  var nav = window.navigator;
  var appName = nav.appName.replace(/\s/g, '_');
  var userAgent = nav.userAgent;

  var rIE = /MSIE\s([0-9]+[.0-9]*)/;
  var rIE11 = /Trident.*rv:11\./;
  var rEdge = /Edge\/(\d+)\./;
  var versionRegex = {
    firefox: /Firefox\/(\d+)\./,
    chrome: /Chrome\/(\d+)\./,
    safari: /Version\/([\d.]+).*Safari\/(\d+)/
  };

  var key, tmp;

  var detector = {
    Microsoft_Internet_Explorer: function() { // eslint-disable-line camelcase
      var detectedVersion = userAgent.match(rIE);

      if (detectedVersion) { // ie8 ~ ie10
        browser.msie = true;
        browser.version = parseFloat(detectedVersion[1]);
      } else { // no version information
        browser.others = true;
      }
    },
    Netscape: function() { // eslint-disable-line complexity
      var detected = false;

      if (rIE11.exec(userAgent)) {
        browser.msie = true;
        browser.version = 11;
        detected = true;
      } else if (rEdge.exec(userAgent)) {
        browser.edge = true;
        browser.version = userAgent.match(rEdge)[1];
        detected = true;
      } else {
        for (key in versionRegex) {
          if (versionRegex.hasOwnProperty(key)) {
            tmp = userAgent.match(versionRegex[key]);
            if (tmp && tmp.length > 1) { // eslint-disable-line max-depth
              browser[key] = detected = true;
              browser.version = parseFloat(tmp[1] || 0);
              break;
            }
          }
        }
      }
      if (!detected) {
        browser.others = true;
      }
    }
  };

  var fn = detector[appName];

  if (fn) {
    detector[appName]();
  }
}

module.exports = browser;


/***/ }),
/* 23 */
/***/ (function(module, exports, __nested_webpack_require_60127__) {

"use strict";
/**
 * @fileoverview Get HTML element's design classes.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isUndefined = __nested_webpack_require_60127__(3);

/**
 * Get HTML element's design classes.
 * @param {(HTMLElement|SVGElement)} element target element
 * @returns {string} element css class name
 * @memberof module:domUtil
 */
function getClass(element) {
  if (!element || !element.className) {
    return '';
  }

  if (isUndefined(element.className.baseVal)) {
    return element.className;
  }

  return element.className.baseVal;
}

module.exports = getClass;


/***/ }),
/* 24 */
/***/ (function(module, exports, __nested_webpack_require_60799__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**
 * @fileoverview General drag handler
 */


var CustomEvents = __nested_webpack_require_60799__(10);

var disableTextSelection = __nested_webpack_require_60799__(42);

var enableTextSelection = __nested_webpack_require_60799__(44);

var getMouseButton = __nested_webpack_require_60799__(47);

var getTarget = __nested_webpack_require_60799__(28);

var off = __nested_webpack_require_60799__(17);

var on = __nested_webpack_require_60799__(14);

var preventDefault = __nested_webpack_require_60799__(15);

var extend = __nested_webpack_require_60799__(0);
/**
 * @constructor
 * @mixes CustomEvents
 * @param {object} options - options for drag handler
 * @param {number} [options.distance=10] - distance in pixels after mouse must move before dragging should start
 * @param {HTMLElement} container - container element to bind drag events
 * @ignore
 */


function Drag(options, container) {
  on(container, 'mousedown', this._onMouseDown, this);
  this.options = extend({
    distance: 10
  }, options);
  /**
   * @type {HTMLElement}
   */

  this.container = container;
  /**
   * @type {boolean}
   */

  this._isMoved = false;
  /**
   * dragging distance in pixel between mousedown and firing dragStart events
   * @type {number}
   */

  this._distance = 0;
  /**
   * @type {boolean}
   */

  this._dragStartFired = false;
  /**
   * @type {object}
   */

  this._dragStartEventData = null;
}
/**
 * Destroy method.
 */


Drag.prototype.destroy = function () {
  off(this.container, 'mousedown', this._onMouseDown);
  this.options = this.container = this._isMoved = this._distance = this._dragStartFired = this._dragStartEventData = null;
};
/**
 * Toggle events for mouse dragging.
 * @param {boolean} toBind - bind events related with dragging when supplied "true"
 */


Drag.prototype._toggleDragEvent = function (toBind) {
  var container = this.container;

  if (toBind) {
    disableTextSelection(container);
    on(window, 'dragstart', preventDefault);
    on(global.document, {
      mousemove: this._onMouseMove,
      mouseup: this._onMouseUp
    }, this);
  } else {
    enableTextSelection(container);
    off(window, 'dragstart', preventDefault);
    off(global.document, {
      mousemove: this._onMouseMove,
      mouseup: this._onMouseUp
    });
  }
};
/**
 * Normalize mouse event object.
 * @param {MouseEvent} mouseEvent - mouse event object.
 * @returns {object} normalized mouse event data.
 */


Drag.prototype._getEventData = function (mouseEvent) {
  return {
    target: getTarget(mouseEvent),
    originEvent: mouseEvent
  };
};
/**
 * MouseDown DOM event handler.
 * @param {MouseEvent} mouseDownEvent MouseDown event object.
 */


Drag.prototype._onMouseDown = function (mouseDownEvent) {
  // only primary button can start drag.
  if (getMouseButton(mouseDownEvent) !== 0) {
    return;
  }

  this._distance = 0;
  this._dragStartFired = false;
  this._dragStartEventData = this._getEventData(mouseDownEvent);

  this._toggleDragEvent(true);
};
/**
 * MouseMove DOM event handler.
 * @emits Drag#drag
 * @emits Drag#dragStart
 * @param {MouseEvent} mouseMoveEvent MouseMove event object.
 */


Drag.prototype._onMouseMove = function (mouseMoveEvent) {
  var distance = this.options.distance; // prevent automatic scrolling.

  preventDefault(mouseMoveEvent);
  this._isMoved = true;

  if (this._distance < distance) {
    this._distance += 1;
    return;
  }

  if (!this._dragStartFired) {
    this._dragStartFired = true;
    /**
     * Drag starts events. cancelable.
     * @event Drag#dragStart
     * @type {object}
     * @property {HTMLElement} target - target element in this event.
     * @property {MouseEvent} originEvent - original mouse event object.
     */

    if (!this.invoke('dragStart', this._dragStartEventData)) {
      this._toggleDragEvent(false);

      return;
    }
  }
  /**
   * Events while dragging.
   * @event Drag#drag
   * @type {object}
   * @property {HTMLElement} target - target element in this event.
   * @property {MouseEvent} originEvent - original mouse event object.
   */


  this.fire('drag', this._getEventData(mouseMoveEvent));
};
/**
 * MouseUp DOM event handler.
 * @param {MouseEvent} mouseUpEvent MouseUp event object.
 * @emits Drag#dragEnd
 * @emits Drag#click
 */


Drag.prototype._onMouseUp = function (mouseUpEvent) {
  this._toggleDragEvent(false); // emit "click" event when not emitted drag event between mousedown and mouseup.


  if (this._isMoved) {
    this._isMoved = false;
    /**
     * Drag end events.
     * @event Drag#dragEnd
     * @type {MouseEvent}
     * @property {HTMLElement} target - target element in this event.
     * @property {MouseEvent} originEvent - original mouse event object.
     */

    this.fire('dragEnd', this._getEventData(mouseUpEvent));
    return;
  }
  /**
   * Click events.
   * @event Drag#click
   * @type {MouseEvent}
   * @property {HTMLElement} target - target element in this event.
   * @property {MouseEvent} originEvent - original mouse event object.
   */


  this.fire('click', this._getEventData(mouseUpEvent));
};

CustomEvents.mixin(Drag);
module.exports = Drag;
/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_60799__(25)))

/***/ }),
/* 25 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Get event collection for specific HTML element
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var EVENT_KEY = '_feEventKey';

/**
 * Get event collection for specific HTML element
 * @param {HTMLElement} element - HTML element
 * @param {string} type - event type
 * @returns {array}
 * @private
 */
function safeEvent(element, type) {
  var events = element[EVENT_KEY];
  var handlers;

  if (!events) {
    events = element[EVENT_KEY] = {};
  }

  handlers = events[type];
  if (!handlers) {
    handlers = events[type] = [];
  }

  return handlers;
}

module.exports = safeEvent;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Check specific CSS style is available.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check specific CSS style is available.
 * @param {array} props property name to testing
 * @returns {(string|boolean)} return true when property is available
 * @private
 */
function testCSSProp(props) {
  var style = document.documentElement.style;
  var i, len;

  for (i = 0, len = props.length; i < len; i += 1) {
    if (props[i] in style) {
      return props[i];
    }
  }

  return false;
}

module.exports = testCSSProp;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Get a target element from an event object.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Get a target element from an event object.
 * @param {Event} e - event object
 * @returns {HTMLElement} - target element
 * @memberof module:domEvent
 */
function getTarget(e) {
  return e.target || e.srcElement;
}

module.exports = getTarget;


/***/ }),
/* 29 */
/***/ (function(module, exports, __nested_webpack_require_68380__) {

"use strict";
/**
 * @fileoverview Color palette view
 */


var CustomEvents = __nested_webpack_require_68380__(10);

var getTarget = __nested_webpack_require_68380__(28);

var off = __nested_webpack_require_68380__(17);

var on = __nested_webpack_require_68380__(14);

var hasClass = __nested_webpack_require_68380__(30);

var extend = __nested_webpack_require_68380__(0);

var inherit = __nested_webpack_require_68380__(18);

var domUtil = __nested_webpack_require_68380__(9);

var colorUtil = __nested_webpack_require_68380__(12);

var View = __nested_webpack_require_68380__(8);

var tmpl = __nested_webpack_require_68380__(51);
/**
 * @constructor
 * @extends {View}
 * @mixes CustomEvents
 * @param {object} options - options for color palette view
 * @param {string[]} options.preset - color list
 * @param {HTMLDivElement} container - container element
 * @ignore
 */


function Palette(options, container) {
  /**
   * option object
   * @type {object}
   */
  this.options = extend({
    cssPrefix: 'tui-colorpicker-',
    preset: ['#181818', '#282828', '#383838', '#585858', '#B8B8B8', '#D8D8D8', '#E8E8E8', '#F8F8F8', '#AB4642', '#DC9656', '#F7CA88', '#A1B56C', '#86C1B9', '#7CAFC2', '#BA8BAF', '#A16946'],
    detailTxt: 'Detail'
  }, options);
  container = domUtil.appendHTMLElement('div', container, this.options.cssPrefix + 'palette-container');
  View.call(this, options, container);
}

inherit(Palette, View);
/**
 * Mouse click event handler
 * @fires Palette#_selectColor
 * @fires Palette#_toggleSlider
 * @param {MouseEvent} clickEvent - mouse event object
 */

Palette.prototype._onClick = function (clickEvent) {
  var options = this.options;
  var target = getTarget(clickEvent);
  var eventData = {};

  if (hasClass(target, options.cssPrefix + 'palette-button')) {
    eventData.color = target.value;
    /**
     * @event Palette#_selectColor
     * @type {object}
     * @property {string} color - selected color value
     */

    this.fire('_selectColor', eventData);
    return;
  }

  if (hasClass(target, options.cssPrefix + 'palette-toggle-slider')) {
    /**
     * @event Palette#_toggleSlider
     */
    this.fire('_toggleSlider');
  }
};
/**
 * Textbox change event handler
 * @fires Palette#_selectColor
 * @param {Event} changeEvent - change event object
 */


Palette.prototype._onChange = function (changeEvent) {
  var options = this.options;
  var target = getTarget(changeEvent);
  var eventData = {};

  if (hasClass(target, options.cssPrefix + 'palette-hex')) {
    eventData.color = target.value;
    /**
     * @event Palette#_selectColor
     * @type {object}
     * @property {string} color - selected color value
     */

    this.fire('_selectColor', eventData);
  }
};
/**
 * Invoke before destory
 * @override
 */


Palette.prototype._beforeDestroy = function () {
  this._toggleEvent(false);
};
/**
 * Toggle view DOM events
 * @param {boolean} [toBind=false] - true to bind event.
 */


Palette.prototype._toggleEvent = function (toBind) {
  var options = this.options;
  var container = this.container;
  var handleEvent = toBind ? on : off;
  var hexTextBox;
  handleEvent(container, 'click', this._onClick, this);
  hexTextBox = container.querySelector('.' + options.cssPrefix + 'palette-hex', container);

  if (hexTextBox) {
    handleEvent(hexTextBox, 'change', this._onChange, this);
  }
};
/**
 * Render palette
 * @override
 */


Palette.prototype.render = function (color) {
  var options = this.options;
  var html = '';

  this._toggleEvent(false);

  html = tmpl({
    cssPrefix: options.cssPrefix,
    preset: options.preset,
    detailTxt: options.detailTxt,
    color: color,
    isValidRGB: colorUtil.isValidRGB,
    getItemClass: function (itemColor) {
      return !itemColor ? ' ' + options.cssPrefix + 'color-transparent' : '';
    },
    isSelected: function (itemColor) {
      return itemColor === color ? ' ' + options.cssPrefix + 'selected' : '';
    }
  });
  this.container.innerHTML = html;

  this._toggleEvent(true);
};

CustomEvents.mixin(Palette);
module.exports = Palette;

/***/ }),
/* 30 */
/***/ (function(module, exports, __nested_webpack_require_72381__) {

"use strict";
/**
 * @fileoverview Check element has specific css class
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var inArray = __nested_webpack_require_72381__(5);
var getClass = __nested_webpack_require_72381__(23);

/**
 * Check element has specific css class
 * @param {(HTMLElement|SVGElement)} element - target element
 * @param {string} cssClass - css class
 * @returns {boolean}
 * @memberof module:domUtil
 */
function hasClass(element, cssClass) {
  var origin;

  if (element.classList) {
    return element.classList.contains(cssClass);
  }

  origin = getClass(element).split(/\s+/);

  return inArray(cssClass, origin) > -1;
}

module.exports = hasClass;


/***/ }),
/* 31 */
/***/ (function(module, exports, __nested_webpack_require_73125__) {

"use strict";
/**
 * @fileoverview Slider view
 */


var CustomEvents = __nested_webpack_require_73125__(10);

var getMousePosition = __nested_webpack_require_73125__(53);

var closest = __nested_webpack_require_73125__(54);

var hasClass = __nested_webpack_require_73125__(30);

var extend = __nested_webpack_require_73125__(0);

var inherit = __nested_webpack_require_73125__(18);

var domUtil = __nested_webpack_require_73125__(9);

var svgvml = __nested_webpack_require_73125__(32);

var colorUtil = __nested_webpack_require_73125__(12);

var View = __nested_webpack_require_73125__(8);

var Drag = __nested_webpack_require_73125__(24);

var tmpl = __nested_webpack_require_73125__(57); // Limitation position of point element inside of colorslider and hue bar
// Minimum value can to be negative because that using color point of handle element is center point. not left, top point.


var DEFAULT_COLORSLIDER_POS_LIMIT_MIN = -7;
var DEFAULT_COLORSLIDER_POS_LIMIT_MAX = 112;
var DEFAULT_HUEBAR_POS_LIMIT_MIN = -3;
var DEFAULT_HUEBAR_POS_LIMIT_MAX = 115;
var HUE_WHEEL_MAX = 359.99;
/**
 * @constructor
 * @extends {View}
 * @mixes CustomEvents
 * @param {object} options - options for view
 *  @param {string} options.cssPrefix - design css prefix
 * @param {HTMLElement} container - container element
 * @ignore
 */

function Slider(options, container) {
  container = domUtil.appendHTMLElement('div', container, options.cssPrefix + 'slider-container');
  container.style.display = 'none';
  View.call(this, options, container);
  /**
   * @type {object}
   */

  this.options = extend({
    color: '#f8f8f8',
    cssPrefix: 'tui-colorpicker-'
  }, options);
  /**
   * Cache immutable data in click, drag events.
   *
   * (i.e. is event related with colorslider? or huebar?)
   * @type {object}
   * @property {boolean} isColorSlider
   * @property {number[]} containerSize
   */

  this._dragDataCache = {};
  /**
   * Color slider handle element
   * @type {SVG|VML}
   */

  this.sliderHandleElement = null;
  /**
   * hue bar handle element
   * @type {SVG|VML}
   */

  this.huebarHandleElement = null;
  /**
   * Element that render base color in colorslider part
   * @type {SVG|VML}
   */

  this.baseColorElement = null;
  /**
   * @type {Drag}
   */

  this.drag = new Drag({
    distance: 0
  }, container);
  this.colorSliderPosLimitRange = [DEFAULT_COLORSLIDER_POS_LIMIT_MIN, DEFAULT_COLORSLIDER_POS_LIMIT_MAX];
  this.huebarPosLimitRange = [DEFAULT_HUEBAR_POS_LIMIT_MIN, DEFAULT_HUEBAR_POS_LIMIT_MAX]; // bind drag events

  this.drag.on({
    dragStart: this._onDragStart,
    drag: this._onDrag,
    dragEnd: this._onDragEnd,
    click: this._onClick
  }, this);
}

inherit(Slider, View);
/**
 * @override
 */

Slider.prototype._beforeDestroy = function () {
  this.drag.off();
  this.drag = this.options = this._dragDataCache = this.sliderHandleElement = this.huebarHandleElement = this.baseColorElement = null;
};
/**
 * Toggle slider view
 * @param {boolean} onOff - set true then reveal slider view
 */


Slider.prototype.toggle = function (onOff) {
  this.container.style.display = !!onOff ? 'block' : 'none';
};
/**
 * Get slider display status
 * @returns {boolean} return true when slider is visible
 */


Slider.prototype.isVisible = function () {
  return this.container.style.display === 'block';
};
/**
 * Render slider view
 * @override
 * @param {string} colorStr - hex string color from parent view (Layout)
 */


Slider.prototype.render = function (colorStr) {
  var container = this.container;
  var options = this.options;
  var html = tmpl.layout;
  var rgb, hsv;

  if (!colorUtil.isValidRGB(colorStr)) {
    return;
  }

  html = html.replace(/{{slider}}/, tmpl.slider);
  html = html.replace(/{{huebar}}/, tmpl.huebar);
  html = html.replace(/{{cssPrefix}}/g, options.cssPrefix);
  html = html.replace(/{{id}}/g, options.id);
  this.container.innerHTML = html;
  this.sliderSvgElement = container.querySelector('.' + options.cssPrefix + 'svg-slider');
  this.huebarSvgElement = container.querySelector('.' + options.cssPrefix + 'svg-huebar');
  this.sliderHandleElement = container.querySelector('.' + options.cssPrefix + 'slider-handle');
  this.huebarHandleElement = container.querySelector('.' + options.cssPrefix + 'huebar-handle');
  this.baseColorElement = container.querySelector('.' + options.cssPrefix + 'slider-basecolor');
  rgb = colorUtil.hexToRGB(colorStr);
  hsv = colorUtil.rgbToHSV.apply(null, rgb);
  this.moveHue(hsv[0], true);
  this.moveSaturationAndValue(hsv[1], hsv[2], true);
};

Slider.prototype._setColorSliderPosMax = function () {
  var sliderRects = this.sliderSvgElement.getClientRects()[0];

  if (sliderRects) {
    this.colorSliderPosLimitRange[1] = sliderRects.height - 10;
  }
};
/**
 * Move colorslider by newLeft(X), newTop(Y) value
 * @private
 * @param {number} newLeft - left pixel value to move handle
 * @param {number} newTop - top pixel value to move handle
 * @param {boolean} [silent=false] - set true then not fire custom event
 */


Slider.prototype._moveColorSliderHandle = function (newLeft, newTop, silent) {
  var handle = this.sliderHandleElement;
  var handleColor; // Check position limitation.

  newTop = Math.max(this.colorSliderPosLimitRange[0], newTop);
  newTop = Math.min(this.colorSliderPosLimitRange[1], newTop);
  newLeft = Math.max(this.colorSliderPosLimitRange[0], newLeft);
  newLeft = Math.min(this.colorSliderPosLimitRange[1], newLeft);
  svgvml.setTranslateXY(handle, newLeft, newTop);
  handleColor = newTop > 50 ? 'white' : 'black';
  svgvml.setStrokeColor(handle, handleColor);

  if (!silent) {
    this.fire('_selectColor', {
      color: colorUtil.rgbToHEX.apply(null, this.getRGB())
    });
  }
};
/**
 * Move colorslider by supplied saturation and values.
 *
 * The movement of color slider handle follow HSV cylinder model. {@link https://en.wikipedia.org/wiki/HSL_and_HSV}
 * @param {number} saturation - the percent of saturation (0% ~ 100%)
 * @param {number} value - the percent of saturation (0% ~ 100%)
 * @param {boolean} [silent=false] - set true then not fire custom event
 */


Slider.prototype.moveSaturationAndValue = function (saturation, value, silent) {
  var absMin, maxValue, newLeft, newTop;
  saturation = saturation || 0;
  value = value || 0;
  absMin = Math.abs(this.colorSliderPosLimitRange[0]);
  maxValue = this.colorSliderPosLimitRange[1]; // subtract absMin value because current color position is not left, top of handle element.
  // The saturation. from left 0 to right 100

  newLeft = saturation * maxValue / 100 - absMin; // The Value. from top 100 to bottom 0. that why newTop subtract by maxValue.

  newTop = maxValue - value * maxValue / 100 - absMin;

  this._moveColorSliderHandle(newLeft, newTop, silent);
};
/**
 * Move color slider handle to supplied position
 *
 * The number of X, Y must be related value from color slider container
 * @private
 * @param {number} x - the pixel value to move handle
 * @param {number} y - the pixel value to move handle
 */


Slider.prototype._moveColorSliderByPosition = function (x, y) {
  var offset = this.colorSliderPosLimitRange[0];

  this._moveColorSliderHandle(x + offset, y + offset);
};
/**
 * Get saturation and value value.
 * @returns {number[]} saturation and value
 */


Slider.prototype.getSaturationAndValue = function () {
  var absMin = Math.abs(this.colorSliderPosLimitRange[0]);
  var maxValue = absMin + this.colorSliderPosLimitRange[1];
  var position = svgvml.getTranslateXY(this.sliderHandleElement);
  var saturation, value;
  saturation = (position[1] + absMin) / maxValue * 100; // The value of HSV color model is inverted. top 100 ~ bottom 0. so subtract by 100

  value = 100 - (position[0] + absMin) / maxValue * 100;
  return [saturation, value];
};

Slider.prototype._setHueBarPosMax = function () {
  var huebarRects = this.huebarSvgElement.getClientRects()[0];

  if (huebarRects) {
    this.huebarPosLimitRange[1] = huebarRects.height - 7;
  }
};
/**
 * Move hue handle supplied pixel value
 * @private
 * @param {number} newTop - pixel to move hue handle
 * @param {boolean} [silent=false] - set true then not fire custom event
 */


Slider.prototype._moveHueHandle = function (newTop, silent) {
  var hueHandleElement = this.huebarHandleElement;
  var baseColorElement = this.baseColorElement;
  var newGradientColor, hexStr;
  newTop = Math.max(this.huebarPosLimitRange[0], newTop);
  newTop = Math.min(this.huebarPosLimitRange[1], newTop);
  svgvml.setTranslateY(hueHandleElement, newTop);
  newGradientColor = colorUtil.hsvToRGB(this.getHue(), 100, 100);
  hexStr = colorUtil.rgbToHEX.apply(null, newGradientColor);
  svgvml.setGradientColorStop(baseColorElement, hexStr);

  if (!silent) {
    this.fire('_selectColor', {
      color: colorUtil.rgbToHEX.apply(null, this.getRGB())
    });
  }
};
/**
 * Move hue bar handle by supplied degree
 * @param {number} degree - (0 ~ 359.9 degree)
 * @param {boolean} [silent=false] - set true then not fire custom event
 */


Slider.prototype.moveHue = function (degree, silent) {
  var newTop = 0;
  var absMin, maxValue;
  absMin = Math.abs(this.huebarPosLimitRange[0]);
  maxValue = absMin + this.huebarPosLimitRange[1];
  degree = degree || 0;
  newTop = maxValue * degree / HUE_WHEEL_MAX - absMin;

  this._moveHueHandle(newTop, silent);
};
/**
 * Move hue bar handle by supplied percent
 * @private
 * @param {number} y - pixel value to move hue handle
 */


Slider.prototype._moveHueByPosition = function (y) {
  var offset = this.huebarPosLimitRange[0];

  this._moveHueHandle(y + offset);
};
/**
 * Get huebar handle position by color degree
 * @returns {number} degree (0 ~ 359.9 degree)
 */


Slider.prototype.getHue = function () {
  var handle = this.huebarHandleElement;
  var position = svgvml.getTranslateXY(handle);
  var absMin, maxValue;
  absMin = Math.abs(this.huebarPosLimitRange[0]);
  maxValue = absMin + this.huebarPosLimitRange[1]; // maxValue : 359.99 = pos.y : x

  return (position[0] + absMin) * HUE_WHEEL_MAX / maxValue;
};
/**
 * Get HSV value from slider
 * @returns {number[]} hsv values
 */


Slider.prototype.getHSV = function () {
  var sv = this.getSaturationAndValue();
  var h = this.getHue();
  return [h].concat(sv);
};
/**
 * Get RGB value from slider
 * @returns {number[]} RGB value
 */


Slider.prototype.getRGB = function () {
  return colorUtil.hsvToRGB.apply(null, this.getHSV());
};
/**********
 * Drag event handler
 **********/

/**
 * Cache immutable data when dragging or click view
 * @param {object} event - Click, DragStart event.
 * @returns {object} cached data.
 */


Slider.prototype._prepareColorSliderForMouseEvent = function (event) {
  var options = this.options;
  var sliderPart = closest(event.target, '.' + options.cssPrefix + 'slider-part');
  var cache;
  cache = this._dragDataCache = {
    isColorSlider: hasClass(sliderPart, options.cssPrefix + 'slider-left'),
    parentElement: sliderPart
  };
  return cache;
};
/**
 * Click event handler
 * @param {object} clickEvent - Click event from Drag module
 */


Slider.prototype._onClick = function (clickEvent) {
  var cache = this._prepareColorSliderForMouseEvent(clickEvent);

  var mousePos = getMousePosition(clickEvent.originEvent, cache.parentElement);

  if (cache.isColorSlider) {
    this._moveColorSliderByPosition(mousePos[0], mousePos[1]);
  } else {
    this._moveHueByPosition(mousePos[1]);
  }

  this._dragDataCache = null;
};
/**
 * DragStart event handler
 * @param {object} dragStartEvent - dragStart event data from Drag#dragStart
 */


Slider.prototype._onDragStart = function (dragStartEvent) {
  this._setColorSliderPosMax();

  this._setHueBarPosMax();

  this._prepareColorSliderForMouseEvent(dragStartEvent);
};
/**
 * Drag event handler
 * @param {Drag#drag} dragEvent - drag event data
 */


Slider.prototype._onDrag = function (dragEvent) {
  var cache = this._dragDataCache;
  var mousePos = getMousePosition(dragEvent.originEvent, cache.parentElement);

  if (cache.isColorSlider) {
    this._moveColorSliderByPosition(mousePos[0], mousePos[1]);
  } else {
    this._moveHueByPosition(mousePos[1]);
  }
};
/**
 * Drag#dragEnd event handler
 */


Slider.prototype._onDragEnd = function () {
  this._dragDataCache = null;
};

CustomEvents.mixin(Slider);
module.exports = Slider;

/***/ }),
/* 32 */
/***/ (function(module, exports, __nested_webpack_require_85363__) {

"use strict";
/**
 * @fileoverview module for manipulate SVG or VML object
 */


var isOldBrowser = __nested_webpack_require_85363__(4).isOldBrowser;

var PARSE_TRANSLATE_NUM_REGEX = /[\.\-0-9]+/g;
var SVG_HUE_HANDLE_RIGHT_POS = -6;
/* istanbul ignore next */

var svgvml = {
  /**
   * Get translate transform value
   * @param {SVG|VML} obj - svg or vml object that want to know translate x, y
   * @returns {number[]} translated coordinates [x, y]
   */
  getTranslateXY: function (obj) {
    var temp;

    if (isOldBrowser) {
      temp = obj.style;
      return [parseFloat(temp.top), parseFloat(temp.left)];
    }

    temp = obj.getAttribute('transform');

    if (!temp) {
      return [0, 0];
    }

    temp = temp.match(PARSE_TRANSLATE_NUM_REGEX); // need caution for difference of VML, SVG coordinates system.
    // translate command need X coords in first parameter. but VML is use CSS coordinate system(top, left)

    return [parseFloat(temp[1]), parseFloat(temp[0])];
  },

  /**
   * Set translate transform value
   * @param {SVG|VML} obj - SVG or VML object to setting translate transform.
   * @param {number} x - translate X value
   * @param {number} y - translate Y value
   */
  setTranslateXY: function (obj, x, y) {
    if (isOldBrowser) {
      obj.style.left = x + 'px';
      obj.style.top = y + 'px';
    } else {
      obj.setAttribute('transform', 'translate(' + x + ',' + y + ')');
    }
  },

  /**
   * Set translate only Y value
   * @param {SVG|VML} obj - SVG or VML object to setting translate transform.
   * @param {number} y - translate Y value
   */
  setTranslateY: function (obj, y) {
    if (isOldBrowser) {
      obj.style.top = y + 'px';
    } else {
      obj.setAttribute('transform', 'translate(' + SVG_HUE_HANDLE_RIGHT_POS + ',' + y + ')');
    }
  },

  /**
   * Set stroke color to SVG or VML object
   * @param {SVG|VML} obj - SVG or VML object to setting stroke color
   * @param {string} colorStr - color string
   */
  setStrokeColor: function (obj, colorStr) {
    if (isOldBrowser) {
      obj.strokecolor = colorStr;
    } else {
      obj.setAttribute('stroke', colorStr);
    }
  },

  /**
   * Set gradient stop color to SVG, VML object.
   * @param {SVG|VML} obj - SVG, VML object to applying gradient stop color
   * @param {string} colorStr - color string
   */
  setGradientColorStop: function (obj, colorStr) {
    if (isOldBrowser) {
      obj.color = colorStr;
    } else {
      obj.setAttribute('stop-color', colorStr);
    }
  }
};
module.exports = svgvml;

/***/ }),
/* 33 */
/***/ (function(module, exports, __nested_webpack_require_87959__) {

__nested_webpack_require_87959__(34);
module.exports = __nested_webpack_require_87959__(35);


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 35 */
/***/ (function(module, exports, __nested_webpack_require_88221__) {

"use strict";


var Collection = __nested_webpack_require_88221__(19);

var View = __nested_webpack_require_88221__(8);

var Drag = __nested_webpack_require_88221__(24);

var create = __nested_webpack_require_88221__(48);

var Palette = __nested_webpack_require_88221__(29);

var Slider = __nested_webpack_require_88221__(31);

var colorUtil = __nested_webpack_require_88221__(12);

var svgvml = __nested_webpack_require_88221__(32);

var colorPicker = {
  Collection: Collection,
  View: View,
  Drag: Drag,
  create: create,
  Palette: Palette,
  Slider: Slider,
  colorutil: colorUtil,
  svgvml: svgvml
};
module.exports = colorPicker;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Check whether the given variable is null or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check whether the given variable is null or not.
 * If the given variable(arguments[0]) is null, returns true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is null?
 * @memberof module:type
 */
function isNull(obj) {
  return obj === null;
}

module.exports = isNull;


/***/ }),
/* 37 */
/***/ (function(module, exports, __nested_webpack_require_89352__) {

"use strict";
/**
 * @fileoverview Send hostname on DOMContentLoaded.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isUndefined = __nested_webpack_require_89352__(3);
var imagePing = __nested_webpack_require_89352__(38);

var ms7days = 7 * 24 * 60 * 60 * 1000;

/**
 * Check if the date has passed 7 days
 * @param {number} date - milliseconds
 * @returns {boolean}
 * @private
 */
function isExpired(date) {
  var now = new Date().getTime();

  return now - date > ms7days;
}

/**
 * Send hostname on DOMContentLoaded.
 * To prevent hostname set tui.usageStatistics to false.
 * @param {string} appName - application name
 * @param {string} trackingId - GA tracking ID
 * @ignore
 */
function sendHostname(appName, trackingId) {
  var url = 'https://www.google-analytics.com/collect';
  var hostname = location.hostname;
  var hitType = 'event';
  var eventCategory = 'use';
  var applicationKeyForStorage = 'TOAST UI ' + appName + ' for ' + hostname + ': Statistics';
  var date = window.localStorage.getItem(applicationKeyForStorage);

  // skip if the flag is defined and is set to false explicitly
  if (!isUndefined(window.tui) && window.tui.usageStatistics === false) {
    return;
  }

  // skip if not pass seven days old
  if (date && !isExpired(date)) {
    return;
  }

  window.localStorage.setItem(applicationKeyForStorage, new Date().getTime());

  setTimeout(function() {
    if (document.readyState === 'interactive' || document.readyState === 'complete') {
      imagePing(url, {
        v: 1,
        t: hitType,
        tid: trackingId,
        cid: hostname,
        dp: hostname,
        dh: appName,
        el: appName,
        ec: eventCategory
      });
    }
  }, 1000);
}

module.exports = sendHostname;


/***/ }),
/* 38 */
/***/ (function(module, exports, __nested_webpack_require_91159__) {

"use strict";
/**
 * @fileoverview Request image ping.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var forEachOwnProperties = __nested_webpack_require_91159__(7);

/**
 * @module request
 */

/**
 * Request image ping.
 * @param {String} url url for ping request
 * @param {Object} trackingInfo infos for make query string
 * @returns {HTMLElement}
 * @memberof module:request
 * @example
 * var imagePing = require('tui-code-snippet/request/imagePing'); // node, commonjs
 *
 * imagePing('https://www.google-analytics.com/collect', {
 *     v: 1,
 *     t: 'event',
 *     tid: 'trackingid',
 *     cid: 'cid',
 *     dp: 'dp',
 *     dh: 'dh'
 * });
 */
function imagePing(url, trackingInfo) {
  var trackingElement = document.createElement('img');
  var queryString = '';
  forEachOwnProperties(trackingInfo, function(value, key) {
    queryString += '&' + key + '=' + value;
  });
  queryString = queryString.substring(1);

  trackingElement.src = url + '?' + queryString;

  trackingElement.style.display = 'none';
  document.body.appendChild(trackingElement);
  document.body.removeChild(trackingElement);

  return trackingElement;
}

module.exports = imagePing;


/***/ }),
/* 39 */
/***/ (function(module, exports, __nested_webpack_require_92415__) {

"use strict";
/**
 * @fileoverview Add css class to element
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var forEach = __nested_webpack_require_92415__(2);
var inArray = __nested_webpack_require_92415__(5);
var getClass = __nested_webpack_require_92415__(23);
var setClassName = __nested_webpack_require_92415__(40);

/**
 * domUtil module
 * @module domUtil
 */

/**
 * Add css class to element
 * @param {(HTMLElement|SVGElement)} element - target element
 * @param {...string} cssClass - css classes to add
 * @memberof module:domUtil
 */
function addClass(element) {
  var cssClass = Array.prototype.slice.call(arguments, 1);
  var classList = element.classList;
  var newClass = [];
  var origin;

  if (classList) {
    forEach(cssClass, function(name) {
      element.classList.add(name);
    });

    return;
  }

  origin = getClass(element);

  if (origin) {
    cssClass = [].concat(origin.split(/\s+/), cssClass);
  }

  forEach(cssClass, function(cls) {
    if (inArray(cls, newClass) < 0) {
      newClass.push(cls);
    }
  });

  setClassName(element, newClass);
}

module.exports = addClass;


/***/ }),
/* 40 */
/***/ (function(module, exports, __nested_webpack_require_93570__) {

"use strict";
/**
 * @fileoverview Set className value
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isArray = __nested_webpack_require_93570__(1);
var isUndefined = __nested_webpack_require_93570__(3);

/**
 * Set className value
 * @param {(HTMLElement|SVGElement)} element - target element
 * @param {(string|string[])} cssClass - class names
 * @private
 */
function setClassName(element, cssClass) {
  cssClass = isArray(cssClass) ? cssClass.join(' ') : cssClass;

  cssClass = cssClass.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

  if (isUndefined(element.className.baseVal)) {
    element.className = cssClass;

    return;
  }

  element.className.baseVal = cssClass;
}

module.exports = setClassName;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Check whether the given variable is a number or not.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * Check whether the given variable is a number or not.
 * If the given variable is a number, return true.
 * @param {*} obj - Target for checking
 * @returns {boolean} Is number?
 * @memberof module:type
 */
function isNumber(obj) {
  return typeof obj === 'number' || obj instanceof Number;
}

module.exports = isNumber;


/***/ }),
/* 42 */
/***/ (function(module, exports, __nested_webpack_require_94921__) {

"use strict";
/**
 * @fileoverview Disable browser's text selection behaviors.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var on = __nested_webpack_require_94921__(14);
var preventDefault = __nested_webpack_require_94921__(15);
var setData = __nested_webpack_require_94921__(43);
var testCSSProp = __nested_webpack_require_94921__(27);

var SUPPORT_SELECTSTART = 'onselectstart' in document;
var KEY_PREVIOUS_USER_SELECT = 'prevUserSelect';
var userSelectProperty = testCSSProp([
  'userSelect',
  'WebkitUserSelect',
  'OUserSelect',
  'MozUserSelect',
  'msUserSelect'
]);

/**
 * Disable browser's text selection behaviors.
 * @param {HTMLElement} [el] - target element. if not supplied, use `document`
 * @memberof module:domUtil
 */
function disableTextSelection(el) {
  if (!el) {
    el = document;
  }

  if (SUPPORT_SELECTSTART) {
    on(el, 'selectstart', preventDefault);
  } else {
    el = (el === document) ? document.documentElement : el;
    setData(el, KEY_PREVIOUS_USER_SELECT, el.style[userSelectProperty]);
    el.style[userSelectProperty] = 'none';
  }
}

module.exports = disableTextSelection;


/***/ }),
/* 43 */
/***/ (function(module, exports, __nested_webpack_require_96085__) {

"use strict";
/**
 * @fileoverview Set data attribute to target element
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var convertToKebabCase = __nested_webpack_require_96085__(16);

/**
 * Set data attribute to target element
 * @param {HTMLElement} element - element to set data attribute
 * @param {string} key - key
 * @param {string} value - value
 * @memberof module:domUtil
 */
function setData(element, key, value) {
  if (element.dataset) {
    element.dataset[key] = value;

    return;
  }

  element.setAttribute('data-' + convertToKebabCase(key), value);
}

module.exports = setData;


/***/ }),
/* 44 */
/***/ (function(module, exports, __nested_webpack_require_96765__) {

"use strict";
/**
 * @fileoverview Transform the Array-like object to Array.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var off = __nested_webpack_require_96765__(17);
var preventDefault = __nested_webpack_require_96765__(15);
var getData = __nested_webpack_require_96765__(45);
var removeData = __nested_webpack_require_96765__(46);
var testCSSProp = __nested_webpack_require_96765__(27);

var SUPPORT_SELECTSTART = 'onselectstart' in document;
var KEY_PREVIOUS_USER_SELECT = 'prevUserSelect';
var userSelectProperty = testCSSProp([
  'userSelect',
  'WebkitUserSelect',
  'OUserSelect',
  'MozUserSelect',
  'msUserSelect'
]);

/**
 * Enable browser's text selection behaviors.
 * @param {HTMLElement} [el] - target element. if not supplied, use `document`
 * @memberof module:domUtil
 */
function enableTextSelection(el) {
  if (!el) {
    el = document;
  }

  if (SUPPORT_SELECTSTART) {
    off(el, 'selectstart', preventDefault);
  } else {
    el = (el === document) ? document.documentElement : el;
    el.style[userSelectProperty] = getData(el, KEY_PREVIOUS_USER_SELECT) || 'auto';
    removeData(el, KEY_PREVIOUS_USER_SELECT);
  }
}

module.exports = enableTextSelection;


/***/ }),
/* 45 */
/***/ (function(module, exports, __nested_webpack_require_97982__) {

"use strict";
/**
 * @fileoverview Get data value from data-attribute
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var convertToKebabCase = __nested_webpack_require_97982__(16);

/**
 * Get data value from data-attribute
 * @param {HTMLElement} element - target element
 * @param {string} key - key
 * @returns {string} value
 * @memberof module:domUtil
 */
function getData(element, key) {
  if (element.dataset) {
    return element.dataset[key];
  }

  return element.getAttribute('data-' + convertToKebabCase(key));
}

module.exports = getData;


/***/ }),
/* 46 */
/***/ (function(module, exports, __nested_webpack_require_98616__) {

"use strict";
/**
 * @fileoverview Remove data property
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var convertToKebabCase = __nested_webpack_require_98616__(16);

/**
 * Remove data property
 * @param {HTMLElement} element - target element
 * @param {string} key - key
 * @memberof module:domUtil
 */
function removeData(element, key) {
  if (element.dataset) {
    delete element.dataset[key];

    return;
  }

  element.removeAttribute('data-' + convertToKebabCase(key));
}

module.exports = removeData;


/***/ }),
/* 47 */
/***/ (function(module, exports, __nested_webpack_require_99210__) {

"use strict";
/**
 * @fileoverview Normalize mouse event's button attributes.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var browser = __nested_webpack_require_99210__(22);
var inArray = __nested_webpack_require_99210__(5);

var primaryButton = ['0', '1', '3', '5', '7'];
var secondaryButton = ['2', '6'];
var wheelButton = ['4'];

/**
 * @module domEvent
 */

/**
 * Normalize mouse event's button attributes.
 *
 * Can detect which button is clicked by this method.
 *
 * Meaning of return numbers
 *
 * - 0: primary mouse button
 * - 1: wheel button or center button
 * - 2: secondary mouse button
 * @param {MouseEvent} mouseEvent - The mouse event object want to know.
 * @returns {number} - The value of meaning which button is clicked?
 * @memberof module:domEvent
 */
function getMouseButton(mouseEvent) {
  if (browser.msie && browser.version <= 8) {
    return getMouseButtonIE8AndEarlier(mouseEvent);
  }

  return mouseEvent.button;
}

/**
 * Normalize return value of mouseEvent.button
 * Make same to standard MouseEvent's button value
 * @param {DispCEventObj} mouseEvent - mouse event object
 * @returns {number|null} - id indicating which mouse button is clicked
 * @private
 */
function getMouseButtonIE8AndEarlier(mouseEvent) {
  var button = String(mouseEvent.button);

  if (inArray(button, primaryButton) > -1) {
    return 0;
  }

  if (inArray(button, secondaryButton) > -1) {
    return 2;
  }

  if (inArray(button, wheelButton) > -1) {
    return 1;
  }

  return null;
}

module.exports = getMouseButton;


/***/ }),
/* 48 */
/***/ (function(module, exports, __nested_webpack_require_100817__) {

"use strict";
/**
 * @fileoverview ColorPicker factory module
 */


var CustomEvents = __nested_webpack_require_100817__(10);

var extend = __nested_webpack_require_100817__(0);

var util = __nested_webpack_require_100817__(4);

var colorUtil = __nested_webpack_require_100817__(12);

var Layout = __nested_webpack_require_100817__(49);

var Palette = __nested_webpack_require_100817__(29);

var Slider = __nested_webpack_require_100817__(31);
/**
 * Create an unique id for a color-picker instance.
 * @private
 */


var currentId = 0;

function generateId() {
  currentId += 1;
  return currentId;
}
/**
 * @constructor
 * @param {object} options - options for colorpicker component
 *  @param {HTMLDivElement} options.container - container element
 *  @param {string} [options.color='#ffffff'] - default selected color
 *  @param {string[]} [options.preset] - color preset for palette (use base16 palette if not supplied)
 *  @param {string} [options.cssPrefix='tui-colorpicker-'] - css prefix text for each child elements
 *  @param {string} [options.detailTxt='Detail'] - text for detail button.
 *  @param {boolean} [options.usageStatistics=true] - Let us know the hostname. If you don't want to send the hostname, please set to false.
 * @example
 * // ES6
 * import colorPicker from 'tui-color-picker';
 *
 * // CommonJS
 * const colorPicker = require('tui-color-picker');
 *
 * // Browser
 * const colorPicker = tui.colorPicker;
 *
 * const instance = colorPicker.create({
 *   container: document.getElementById('color-picker')
 * });
 */


function ColorPicker(options) {
  var layout;

  if (!(this instanceof ColorPicker)) {
    return new ColorPicker(options);
  }
  /**
   * Option object
   * @type {object}
   * @private
   */


  options = this.options = extend({
    container: null,
    color: '#f8f8f8',
    preset: ['#181818', '#282828', '#383838', '#585858', '#b8b8b8', '#d8d8d8', '#e8e8e8', '#f8f8f8', '#ab4642', '#dc9656', '#f7ca88', '#a1b56c', '#86c1b9', '#7cafc2', '#ba8baf', '#a16946'],
    cssPrefix: 'tui-colorpicker-',
    detailTxt: 'Detail',
    id: generateId(),
    usageStatistics: true
  }, options);

  if (!options.container) {
    throw new Error('ColorPicker(): need container option.');
  }
  /**********
   * Create layout view
   **********/

  /**
   * @type {Layout}
   * @private
   */


  layout = this.layout = new Layout(options, options.container);
  /**********
   * Create palette view
   **********/

  this.palette = new Palette(options, layout.container);
  this.palette.on({
    _selectColor: this._onSelectColorInPalette,
    _toggleSlider: this._onToggleSlider
  }, this);
  /**********
   * Create slider view
   **********/

  this.slider = new Slider(options, layout.container);
  this.slider.on('_selectColor', this._onSelectColorInSlider, this);
  /**********
   * Add child views
   **********/

  layout.addChild(this.palette);
  layout.addChild(this.slider);
  this.render(options.color);

  if (options.usageStatistics) {
    util.sendHostName();
  }
}
/**
 * Handler method for Palette#_selectColor event
 * @private
 * @fires ColorPicker#selectColor
 * @param {object} selectColorEventData - event data
 */


ColorPicker.prototype._onSelectColorInPalette = function (selectColorEventData) {
  var color = selectColorEventData.color;
  var opt = this.options;

  if (!colorUtil.isValidRGB(color) && color !== '') {
    this.render();
    return;
  }
  /**
   * @event ColorPicker#selectColor
   * @type {object}
   * @property {string} color - selected color (hex string)
   * @property {string} origin - flags for represent the source of event fires.
   */


  this.fire('selectColor', {
    color: color,
    origin: 'palette'
  });

  if (opt.color === color) {
    return;
  }

  opt.color = color;
  this.render(color);
};
/**
 * Handler method for Palette#_toggleSlider event
 * @private
 */


ColorPicker.prototype._onToggleSlider = function () {
  this.slider.toggle(!this.slider.isVisible());
};
/**
 * Handler method for Slider#_selectColor event
 * @private
 * @fires ColorPicker#selectColor
 * @param {object} selectColorEventData - event data
 */


ColorPicker.prototype._onSelectColorInSlider = function (selectColorEventData) {
  var color = selectColorEventData.color;
  var opt = this.options;
  /**
   * @event ColorPicker#selectColor
   * @type {object}
   * @property {string} color - selected color (hex string)
   * @property {string} origin - flags for represent the source of event fires.
   * @ignore
   */

  this.fire('selectColor', {
    color: color,
    origin: 'slider'
  });

  if (opt.color === color) {
    return;
  }

  opt.color = color;
  this.palette.render(color);
};
/**********
 * PUBLIC API
 **********/

/**
 * Set color to colorpicker instance.<br>
 * The string parameter must be hex color value
 * @param {string} hexStr - hex formatted color string
 * @example
 * instance.setColor('#ffff00');
 */


ColorPicker.prototype.setColor = function (hexStr) {
  if (!colorUtil.isValidRGB(hexStr)) {
    throw new Error('ColorPicker#setColor(): need valid hex string color value');
  }

  this.options.color = hexStr;
  this.render(hexStr);
};
/**
 * Get hex color string of current selected color in colorpicker instance.
 * @returns {string} hex string formatted color
 * @example
 * instance.setColor('#ffff00');
 * instance.getColor(); // '#ffff00';
 */


ColorPicker.prototype.getColor = function () {
  return this.options.color;
};
/**
 * Toggle colorpicker element. set true then reveal colorpicker view.
 * @param {boolean} [isShow=false] - A flag to show
 * @example
 * instance.toggle(false); // hide
 * instance.toggle(); // hide
 * instance.toggle(true); // show
 */


ColorPicker.prototype.toggle = function (isShow) {
  this.layout.container.style.display = !!isShow ? 'block' : 'none';
};
/**
 * Render colorpicker
 * @param {string} [color] - selected color
 * @ignore
 */


ColorPicker.prototype.render = function (color) {
  this.layout.render(color || this.options.color);
};
/**
 * Destroy colorpicker instance.
 * @example
 * instance.destroy(); // DOM-element is removed
 */


ColorPicker.prototype.destroy = function () {
  this.layout.destroy();
  this.options.container.innerHTML = '';
  this.layout = this.slider = this.palette = this.options = null;
};

CustomEvents.mixin(ColorPicker);
module.exports = ColorPicker;

/***/ }),
/* 49 */
/***/ (function(module, exports, __nested_webpack_require_107150__) {

"use strict";
/**
 * @fileoverview ColorPicker layout module
 */


var extend = __nested_webpack_require_107150__(0);

var inherit = __nested_webpack_require_107150__(18);

var domUtil = __nested_webpack_require_107150__(9);

var View = __nested_webpack_require_107150__(8);
/**
 * @constructor
 * @extends {View}
 * @param {object} options - option object
 *  @param {string} options.cssPrefix - css prefix for each child elements
 * @param {HTMLDivElement} container - container
 * @ignore
 */


function Layout(options, container) {
  /**
   * option object
   * @type {object}
   */
  this.options = extend({
    cssPrefix: 'tui-colorpicker-'
  }, options);
  container = domUtil.appendHTMLElement('div', container, this.options.cssPrefix + 'container');
  View.call(this, options, container);
  this.render();
}

inherit(Layout, View);
/**
 * @override
 * @param {string} [color] - selected color
 */

Layout.prototype.render = function (color) {
  this.recursive(function (view) {
    view.render(color);
  }, true);
};

module.exports = Layout;

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @fileoverview Create a new object with the specified prototype object and properties.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



/**
 * @module inheritance
 */

/**
 * Create a new object with the specified prototype object and properties.
 * @param {Object} obj This object will be a prototype of the newly-created object.
 * @returns {Object}
 * @memberof module:inheritance
 */
function createObject(obj) {
  function F() {} // eslint-disable-line require-jsdoc
  F.prototype = obj;

  return new F();
}

module.exports = createObject;


/***/ }),
/* 51 */
/***/ (function(module, exports, __nested_webpack_require_108883__) {

"use strict";
/**
 * @fileoverview Palette view template
 */


var template = __nested_webpack_require_108883__(52);

module.exports = function (context) {
  var item = ['<li><input class="{{cssPrefix}}palette-button{{isSelected @this}}{{getItemClass @this}}" type="button"', '{{if isValidRGB @this}}', ' style="background-color:{{@this}};color:{{@this}}"', '{{/if}}', ' title="{{@this}}" value="{{@this}}" /></li>'].join('');
  var layout = ['<ul class="{{cssPrefix}}clearfix">', '{{each preset}}', item, '{{/each}}', '</ul>', '<div class="{{cssPrefix}}clearfix" style="overflow:hidden">', '<input type="button" class="{{cssPrefix}}palette-toggle-slider" value="{{detailTxt}}" />', '<input type="text" class="{{cssPrefix}}palette-hex" value="{{color}}" maxlength="7" />', '<span class="{{cssPrefix}}palette-preview" style="background-color:{{color}};color:{{color}}">{{color}}</span>', '</div>'].join('\n');
  return template(layout, context);
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __nested_webpack_require_109894__) {

"use strict";
/**
 * @fileoverview Convert text by binding expressions with context.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var inArray = __nested_webpack_require_109894__(5);
var forEach = __nested_webpack_require_109894__(2);
var isArray = __nested_webpack_require_109894__(1);
var isString = __nested_webpack_require_109894__(11);
var extend = __nested_webpack_require_109894__(0);

// IE8 does not support capture groups.
var EXPRESSION_REGEXP = /{{\s?|\s?}}/g;
var BRACKET_NOTATION_REGEXP = /^[a-zA-Z0-9_@]+\[[a-zA-Z0-9_@"']+\]$/;
var BRACKET_REGEXP = /\[\s?|\s?\]/;
var DOT_NOTATION_REGEXP = /^[a-zA-Z_]+\.[a-zA-Z_]+$/;
var DOT_REGEXP = /\./;
var STRING_NOTATION_REGEXP = /^["']\w+["']$/;
var STRING_REGEXP = /"|'/g;
var NUMBER_REGEXP = /^-?\d+\.?\d*$/;

var EXPRESSION_INTERVAL = 2;

var BLOCK_HELPERS = {
  'if': handleIf,
  'each': handleEach,
  'with': handleWith
};

var isValidSplit = 'a'.split(/a/).length === 3;

/**
 * Split by RegExp. (Polyfill for IE8)
 * @param {string} text - text to be splitted\
 * @param {RegExp} regexp - regular expression
 * @returns {Array.<string>}
 */
var splitByRegExp = (function() {
  if (isValidSplit) {
    return function(text, regexp) {
      return text.split(regexp);
    };
  }

  return function(text, regexp) {
    var result = [];
    var prevIndex = 0;
    var match, index;

    if (!regexp.global) {
      regexp = new RegExp(regexp, 'g');
    }

    match = regexp.exec(text);
    while (match !== null) {
      index = match.index;
      result.push(text.slice(prevIndex, index));

      prevIndex = index + match[0].length;
      match = regexp.exec(text);
    }
    result.push(text.slice(prevIndex));

    return result;
  };
})();

/**
 * Find value in the context by an expression.
 * @param {string} exp - an expression
 * @param {object} context - context
 * @returns {*}
 * @private
 */
// eslint-disable-next-line complexity
function getValueFromContext(exp, context) {
  var splitedExps;
  var value = context[exp];

  if (exp === 'true') {
    value = true;
  } else if (exp === 'false') {
    value = false;
  } else if (STRING_NOTATION_REGEXP.test(exp)) {
    value = exp.replace(STRING_REGEXP, '');
  } else if (BRACKET_NOTATION_REGEXP.test(exp)) {
    splitedExps = exp.split(BRACKET_REGEXP);
    value = getValueFromContext(splitedExps[0], context)[getValueFromContext(splitedExps[1], context)];
  } else if (DOT_NOTATION_REGEXP.test(exp)) {
    splitedExps = exp.split(DOT_REGEXP);
    value = getValueFromContext(splitedExps[0], context)[splitedExps[1]];
  } else if (NUMBER_REGEXP.test(exp)) {
    value = parseFloat(exp);
  }

  return value;
}

/**
 * Extract elseif and else expressions.
 * @param {Array.<string>} ifExps - args of if expression
 * @param {Array.<string>} sourcesInsideBlock - sources inside if block
 * @returns {object} - exps: expressions of if, elseif, and else / sourcesInsideIf: sources inside if, elseif, and else block.
 * @private
 */
function extractElseif(ifExps, sourcesInsideBlock) {
  var exps = [ifExps];
  var sourcesInsideIf = [];
  var otherIfCount = 0;
  var start = 0;

  // eslint-disable-next-line complexity
  forEach(sourcesInsideBlock, function(source, index) {
    if (source.indexOf('if') === 0) {
      otherIfCount += 1;
    } else if (source === '/if') {
      otherIfCount -= 1;
    } else if (!otherIfCount && (source.indexOf('elseif') === 0 || source === 'else')) {
      exps.push(source === 'else' ? ['true'] : source.split(' ').slice(1));
      sourcesInsideIf.push(sourcesInsideBlock.slice(start, index));
      start = index + 1;
    }
  });

  sourcesInsideIf.push(sourcesInsideBlock.slice(start));

  return {
    exps: exps,
    sourcesInsideIf: sourcesInsideIf
  };
}

/**
 * Helper function for "if". 
 * @param {Array.<string>} exps - array of expressions split by spaces
 * @param {Array.<string>} sourcesInsideBlock - array of sources inside the if block
 * @param {object} context - context
 * @returns {string}
 * @private
 */
function handleIf(exps, sourcesInsideBlock, context) {
  var analyzed = extractElseif(exps, sourcesInsideBlock);
  var result = false;
  var compiledSource = '';

  forEach(analyzed.exps, function(exp, index) {
    result = handleExpression(exp, context);
    if (result) {
      compiledSource = compile(analyzed.sourcesInsideIf[index], context);
    }

    return !result;
  });

  return compiledSource;
}

/**
 * Helper function for "each".
 * @param {Array.<string>} exps - array of expressions split by spaces
 * @param {Array.<string>} sourcesInsideBlock - array of sources inside the each block
 * @param {object} context - context
 * @returns {string}
 * @private
 */
function handleEach(exps, sourcesInsideBlock, context) {
  var collection = handleExpression(exps, context);
  var additionalKey = isArray(collection) ? '@index' : '@key';
  var additionalContext = {};
  var result = '';

  forEach(collection, function(item, key) {
    additionalContext[additionalKey] = key;
    additionalContext['@this'] = item;
    extend(context, additionalContext);

    result += compile(sourcesInsideBlock.slice(), context);
  });

  return result;
}

/**
 * Helper function for "with ... as"
 * @param {Array.<string>} exps - array of expressions split by spaces
 * @param {Array.<string>} sourcesInsideBlock - array of sources inside the with block
 * @param {object} context - context
 * @returns {string}
 * @private
 */
function handleWith(exps, sourcesInsideBlock, context) {
  var asIndex = inArray('as', exps);
  var alias = exps[asIndex + 1];
  var result = handleExpression(exps.slice(0, asIndex), context);

  var additionalContext = {};
  additionalContext[alias] = result;

  return compile(sourcesInsideBlock, extend(context, additionalContext)) || '';
}

/**
 * Extract sources inside block in place.
 * @param {Array.<string>} sources - array of sources
 * @param {number} start - index of start block
 * @param {number} end - index of end block
 * @returns {Array.<string>}
 * @private
 */
function extractSourcesInsideBlock(sources, start, end) {
  var sourcesInsideBlock = sources.splice(start + 1, end - start);
  sourcesInsideBlock.pop();

  return sourcesInsideBlock;
}

/**
 * Handle block helper function
 * @param {string} helperKeyword - helper keyword (ex. if, each, with)
 * @param {Array.<string>} sourcesToEnd - array of sources after the starting block
 * @param {object} context - context
 * @returns {Array.<string>}
 * @private
 */
function handleBlockHelper(helperKeyword, sourcesToEnd, context) {
  var executeBlockHelper = BLOCK_HELPERS[helperKeyword];
  var helperCount = 1;
  var startBlockIndex = 0;
  var endBlockIndex;
  var index = startBlockIndex + EXPRESSION_INTERVAL;
  var expression = sourcesToEnd[index];

  while (helperCount && isString(expression)) {
    if (expression.indexOf(helperKeyword) === 0) {
      helperCount += 1;
    } else if (expression.indexOf('/' + helperKeyword) === 0) {
      helperCount -= 1;
      endBlockIndex = index;
    }

    index += EXPRESSION_INTERVAL;
    expression = sourcesToEnd[index];
  }

  if (helperCount) {
    throw Error(helperKeyword + ' needs {{/' + helperKeyword + '}} expression.');
  }

  sourcesToEnd[startBlockIndex] = executeBlockHelper(
    sourcesToEnd[startBlockIndex].split(' ').slice(1),
    extractSourcesInsideBlock(sourcesToEnd, startBlockIndex, endBlockIndex),
    context
  );

  return sourcesToEnd;
}

/**
 * Helper function for "custom helper".
 * If helper is not a function, return helper itself.
 * @param {Array.<string>} exps - array of expressions split by spaces (first element: helper)
 * @param {object} context - context
 * @returns {string}
 * @private
 */
function handleExpression(exps, context) {
  var result = getValueFromContext(exps[0], context);

  if (result instanceof Function) {
    return executeFunction(result, exps.slice(1), context);
  }

  return result;
}

/**
 * Execute a helper function.
 * @param {Function} helper - helper function
 * @param {Array.<string>} argExps - expressions of arguments
 * @param {object} context - context
 * @returns {string} - result of executing the function with arguments
 * @private
 */
function executeFunction(helper, argExps, context) {
  var args = [];
  forEach(argExps, function(exp) {
    args.push(getValueFromContext(exp, context));
  });

  return helper.apply(null, args);
}

/**
 * Get a result of compiling an expression with the context.
 * @param {Array.<string>} sources - array of sources split by regexp of expression.
 * @param {object} context - context
 * @returns {Array.<string>} - array of sources that bind with its context
 * @private
 */
function compile(sources, context) {
  var index = 1;
  var expression = sources[index];
  var exps, firstExp, result;

  while (isString(expression)) {
    exps = expression.split(' ');
    firstExp = exps[0];

    if (BLOCK_HELPERS[firstExp]) {
      result = handleBlockHelper(firstExp, sources.splice(index, sources.length - index), context);
      sources = sources.concat(result);
    } else {
      sources[index] = handleExpression(exps, context);
    }

    index += EXPRESSION_INTERVAL;
    expression = sources[index];
  }

  return sources.join('');
}

/**
 * Convert text by binding expressions with context.
 * <br>
 * If expression exists in the context, it will be replaced.
 * ex) '{{title}}' with context {title: 'Hello!'} is converted to 'Hello!'.
 * An array or object can be accessed using bracket and dot notation.
 * ex) '{{odds\[2\]}}' with context {odds: \[1, 3, 5\]} is converted to '5'.
 * ex) '{{evens\[first\]}}' with context {evens: \[2, 4\], first: 0} is converted to '2'.
 * ex) '{{project\["name"\]}}' and '{{project.name}}' with context {project: {name: 'CodeSnippet'}} is converted to 'CodeSnippet'.
 * <br>
 * If replaced expression is a function, next expressions will be arguments of the function.
 * ex) '{{add 1 2}}' with context {add: function(a, b) {return a + b;}} is converted to '3'.
 * <br>
 * It has 3 predefined block helpers '{{helper ...}} ... {{/helper}}': 'if', 'each', 'with ... as ...'.
 * 1) 'if' evaluates conditional statements. It can use with 'elseif' and 'else'.
 * 2) 'each' iterates an array or object. It provides '@index'(array), '@key'(object), and '@this'(current element).
 * 3) 'with ... as ...' provides an alias.
 * @param {string} text - text with expressions
 * @param {object} context - context
 * @returns {string} - text that bind with its context
 * @memberof module:domUtil
 * @example
 * var template = require('tui-code-snippet/domUtil/template');
 * 
 * var source = 
 *     '<h1>'
 *   +   '{{if isValidNumber title}}'
 *   +     '{{title}}th'
 *   +   '{{elseif isValidDate title}}'
 *   +     'Date: {{title}}'
 *   +   '{{/if}}'
 *   + '</h1>'
 *   + '{{each list}}'
 *   +   '{{with addOne @index as idx}}'
 *   +     '<p>{{idx}}: {{@this}}</p>'
 *   +   '{{/with}}'
 *   + '{{/each}}';
 * 
 * var context = {
 *   isValidDate: function(text) {
 *     return /^\d{4}-(0|1)\d-(0|1|2|3)\d$/.test(text);
 *   },
 *   isValidNumber: function(text) {
 *     return /^\d+$/.test(text);
 *   }
 *   title: '2019-11-25',
 *   list: ['Clean the room', 'Wash the dishes'],
 *   addOne: function(num) {
 *     return num + 1;
 *   }
 * };
 * 
 * var result = template(source, context);
 * console.log(result); // <h1>Date: 2019-11-25</h1><p>1: Clean the room</p><p>2: Wash the dishes</p>
 */
function template(text, context) {
  return compile(splitByRegExp(text, EXPRESSION_REGEXP), context);
}

module.exports = template;


/***/ }),
/* 53 */
/***/ (function(module, exports, __nested_webpack_require_121452__) {

"use strict";
/**
 * @fileoverview Get mouse position from mouse event
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var isArray = __nested_webpack_require_121452__(1);

/**
 * Get mouse position from mouse event
 *
 * If supplied relatveElement parameter then return relative position based on
 *  element
 * @param {(MouseEvent|object|number[])} position - mouse position object
 * @param {HTMLElement} relativeElement HTML element that calculate relative
 *  position
 * @returns {number[]} mouse position
 * @memberof module:domEvent
 */
function getMousePosition(position, relativeElement) {
  var positionArray = isArray(position);
  var clientX = positionArray ? position[0] : position.clientX;
  var clientY = positionArray ? position[1] : position.clientY;
  var rect;

  if (!relativeElement) {
    return [clientX, clientY];
  }

  rect = relativeElement.getBoundingClientRect();

  return [
    clientX - rect.left - relativeElement.clientLeft,
    clientY - rect.top - relativeElement.clientTop
  ];
}

module.exports = getMousePosition;


/***/ }),
/* 54 */
/***/ (function(module, exports, __nested_webpack_require_122586__) {

"use strict";
/**
 * @fileoverview Find parent element recursively
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var matches = __nested_webpack_require_122586__(55);

/**
 * Find parent element recursively
 * @param {HTMLElement} element - base element to start find
 * @param {string} selector - selector string for find
 * @returns {HTMLElement} - element finded or null
 * @memberof module:domUtil
 */
function closest(element, selector) {
  var parent = element.parentNode;

  if (matches(element, selector)) {
    return element;
  }

  while (parent && parent !== document) {
    if (matches(parent, selector)) {
      return parent;
    }

    parent = parent.parentNode;
  }

  return null;
}

module.exports = closest;


/***/ }),
/* 55 */
/***/ (function(module, exports, __nested_webpack_require_123397__) {

"use strict";
/**
 * @fileoverview Check element match selector
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var inArray = __nested_webpack_require_123397__(5);
var toArray = __nested_webpack_require_123397__(56);

var elProto = Element.prototype;
var matchSelector = elProto.matches ||
    elProto.webkitMatchesSelector ||
    elProto.mozMatchesSelector ||
    elProto.msMatchesSelector ||
    function(selector) {
      var doc = this.document || this.ownerDocument;

      return inArray(this, toArray(doc.querySelectorAll(selector))) > -1;
    };

/**
 * Check element match selector
 * @param {HTMLElement} element - element to check
 * @param {string} selector - selector to check
 * @returns {boolean} is selector matched to element?
 * @memberof module:domUtil
 */
function matches(element, selector) {
  return matchSelector.call(element, selector);
}

module.exports = matches;


/***/ }),
/* 56 */
/***/ (function(module, exports, __nested_webpack_require_124355__) {

"use strict";
/**
 * @fileoverview Transform the Array-like object to Array.
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 */



var forEachArray = __nested_webpack_require_124355__(6);

/**
 * Transform the Array-like object to Array.
 * In low IE (below 8), Array.prototype.slice.call is not perfect. So, try-catch statement is used.
 * @param {*} arrayLike Array-like object
 * @returns {Array} Array
 * @memberof module:collection
 * @example
 * var toArray = require('tui-code-snippet/collection/toArray'); // node, commonjs
 *
 * var arrayLike = {
 *     0: 'one',
 *     1: 'two',
 *     2: 'three',
 *     3: 'four',
 *     length: 4
 * };
 * var result = toArray(arrayLike);
 *
 * alert(result instanceof Array); // true
 * alert(result); // one,two,three,four
 */
function toArray(arrayLike) {
  var arr;
  try {
    arr = Array.prototype.slice.call(arrayLike);
  } catch (e) {
    arr = [];
    forEachArray(arrayLike, function(value) {
      arr.push(value);
    });
  }

  return arr;
}

module.exports = toArray;


/***/ }),
/* 57 */
/***/ (function(module, exports, __nested_webpack_require_125459__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/**
 * @fileoverview Slider template
 */


var isOldBrowser = __nested_webpack_require_125459__(4).isOldBrowser;

var layout = ['<div class="{{cssPrefix}}slider-left {{cssPrefix}}slider-part">{{slider}}</div>', '<div class="{{cssPrefix}}slider-right {{cssPrefix}}slider-part">{{huebar}}</div>'].join('\n');
var SVGSlider = ['<svg class="{{cssPrefix}}svg {{cssPrefix}}svg-slider">', '<defs>', '<linearGradient id="{{cssPrefix}}svg-fill-color-{{id}}" x1="0%" y1="0%" x2="100%" y2="0%">', '<stop offset="0%" stop-color="rgb(255,255,255)" />', '<stop class="{{cssPrefix}}slider-basecolor" offset="100%" stop-color="rgb(255,0,0)" />', '</linearGradient>', '<linearGradient id="{{cssPrefix}}svn-fill-black-{{id}}" x1="0%" y1="0%" x2="0%" y2="100%">', '<stop offset="0%" style="stop-color:rgb(0,0,0);stop-opacity:0" />', '<stop offset="100%" style="stop-color:rgb(0,0,0);stop-opacity:1" />', '</linearGradient>', '</defs>', '<rect width="100%" height="100%" fill="url(#{{cssPrefix}}svg-fill-color-{{id}})"></rect>', '<rect width="100%" height="100%" fill="url(#{{cssPrefix}}svn-fill-black-{{id}})"></rect>', '<path transform="translate(0,0)" class="{{cssPrefix}}slider-handle" d="M0 7.5 L15 7.5 M7.5 15 L7.5 0 M2 7 a5.5 5.5 0 1 1 0 1 Z" stroke="black" stroke-width="0.75" fill="none" />', '</svg>'].join('\n');
var VMLSlider = ['<div class="{{cssPrefix}}vml-slider">', '<v:rect strokecolor="none" class="{{cssPrefix}}vml {{cssPrefix}}vml-slider-bg">', '<v:fill class="{{cssPrefix}}vml {{cssPrefix}}slider-basecolor" type="gradient" method="none" color="#ff0000" color2="#fff" angle="90" />', '</v:rect>', '<v:rect strokecolor="#ccc" class="{{cssPrefix}}vml {{cssPrefix}}vml-slider-bg">', '<v:fill type="gradient" method="none" color="black" color2="white" o:opacity2="0%" class="{{cssPrefix}}vml" />', '</v:rect>', '<v:shape class="{{cssPrefix}}vml {{cssPrefix}}slider-handle" coordsize="1 1" style="width:1px;height:1px;"' + 'path="m 0,7 l 14,7 m 7,14 l 7,0 ar 12,12 2,2 z" filled="false" stroked="true" />', '</div>'].join('\n');
var SVGHuebar = ['<svg class="{{cssPrefix}}svg {{cssPrefix}}svg-huebar">', '<defs>', '<linearGradient id="g-{{id}}" x1="0%" y1="0%" x2="0%" y2="100%">', '<stop offset="0%" stop-color="rgb(255,0,0)" />', '<stop offset="16.666%" stop-color="rgb(255,255,0)" />', '<stop offset="33.333%" stop-color="rgb(0,255,0)" />', '<stop offset="50%" stop-color="rgb(0,255,255)" />', '<stop offset="66.666%" stop-color="rgb(0,0,255)" />', '<stop offset="83.333%" stop-color="rgb(255,0,255)" />', '<stop offset="100%" stop-color="rgb(255,0,0)" />', '</linearGradient>', '</defs>', '<rect width="18px" height="100%" fill="url(#g-{{id}})"></rect>', '<path transform="translate(-6,-3)" class="{{cssPrefix}}huebar-handle" d="M0 0 L4 4 L0 8 L0 0 Z" fill="black" stroke="none" />', '</svg>'].join('\n');
var VMLHuebar = ['<div class="{{cssPrefix}}vml-huebar">', '<v:rect strokecolor="#ccc" class="{{cssPrefix}}vml {{cssPrefix}}vml-huebar-bg">', '<v:fill type="gradient" method="none" colors="' + '0% rgb(255,0,0), 16.666% rgb(255,255,0), 33.333% rgb(0,255,0), 50% rgb(0,255,255), 66.666% rgb(0,0,255), 83.333% rgb(255,0,255), 100% rgb(255,0,0)' + '" angle="180" class="{{cssPrefix}}vml" />', '</v:rect>', '<v:shape class="{{cssPrefix}}vml {{cssPrefix}}huebar-handle" coordsize="1 1" style="width:1px;height:1px;position:absolute;z-index:1;right:22px;top:-3px;"' + 'path="m 0,0 l 4,4 l 0,8 l 0,0 z" filled="true" fillcolor="black" stroked="false" />', '</div>'].join('\n');

if (isOldBrowser) {
  global.document.namespaces.add('v', 'urn:schemas-microsoft-com:vml');
}

module.exports = {
  layout: layout,
  slider: isOldBrowser ? VMLSlider : SVGSlider,
  huebar: isOldBrowser ? VMLHuebar : SVGHuebar
};
/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_125459__(25)))

/***/ })
/******/ ]);
});

/***/ }),

/***/ "./node_modules/vue-loader/dist/exportHelper.js":
/*!******************************************************!*\
  !*** ./node_modules/vue-loader/dist/exportHelper.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// runtime helper for setting properties on components
// in a tree-shakable way
exports["default"] = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
        target[key] = val;
    }
    return target;
};


/***/ }),

/***/ "./resources/js/components/DetailField.vue":
/*!*************************************************!*\
  !*** ./resources/js/components/DetailField.vue ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DetailField_vue_vue_type_template_id_0224618e__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DetailField.vue?vue&type=template&id=0224618e */ "./resources/js/components/DetailField.vue?vue&type=template&id=0224618e");
/* harmony import */ var _DetailField_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DetailField.vue?vue&type=script&lang=js */ "./resources/js/components/DetailField.vue?vue&type=script&lang=js");
/* harmony import */ var _node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;
const __exports__ = /*#__PURE__*/(0,_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_DetailField_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_DetailField_vue_vue_type_template_id_0224618e__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"resources/js/components/DetailField.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./resources/js/components/Editor.vue":
/*!********************************************!*\
  !*** ./resources/js/components/Editor.vue ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _Editor_vue_vue_type_template_id_1dbb5118_ts_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Editor.vue?vue&type=template&id=1dbb5118&ts=true */ "./resources/js/components/Editor.vue?vue&type=template&id=1dbb5118&ts=true");
/* harmony import */ var _Editor_vue_vue_type_script_setup_true_lang_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Editor.vue?vue&type=script&setup=true&lang=ts */ "./resources/js/components/Editor.vue?vue&type=script&setup=true&lang=ts");
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _Editor_vue_vue_type_script_setup_true_lang_ts__WEBPACK_IMPORTED_MODULE_1__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _Editor_vue_vue_type_script_setup_true_lang_ts__WEBPACK_IMPORTED_MODULE_1__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
/* harmony import */ var _node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;
const __exports__ = /*#__PURE__*/(0,_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_Editor_vue_vue_type_script_setup_true_lang_ts__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_Editor_vue_vue_type_template_id_1dbb5118_ts_true__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"resources/js/components/Editor.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./resources/js/components/FormField.vue":
/*!***********************************************!*\
  !*** ./resources/js/components/FormField.vue ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _FormField_vue_vue_type_template_id_c023248a__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FormField.vue?vue&type=template&id=c023248a */ "./resources/js/components/FormField.vue?vue&type=template&id=c023248a");
/* harmony import */ var _FormField_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FormField.vue?vue&type=script&lang=js */ "./resources/js/components/FormField.vue?vue&type=script&lang=js");
/* harmony import */ var _node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;
const __exports__ = /*#__PURE__*/(0,_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_FormField_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_FormField_vue_vue_type_template_id_c023248a__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"resources/js/components/FormField.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./resources/js/components/Editor.vue?vue&type=script&setup=true&lang=ts":
/*!*******************************************************************************!*\
  !*** ./resources/js/components/Editor.vue?vue&type=script&setup=true&lang=ts ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport default from dynamic */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_ts_loader_index_js_clonedRuleSet_6_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Editor_vue_vue_type_script_setup_true_lang_ts__WEBPACK_IMPORTED_MODULE_0___default.a)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_ts_loader_index_js_clonedRuleSet_6_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Editor_vue_vue_type_script_setup_true_lang_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../node_modules/ts-loader/index.js??clonedRuleSet-6!../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Editor.vue?vue&type=script&setup=true&lang=ts */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-6!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Editor.vue?vue&type=script&setup=true&lang=ts");
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_ts_loader_index_js_clonedRuleSet_6_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Editor_vue_vue_type_script_setup_true_lang_ts__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_ts_loader_index_js_clonedRuleSet_6_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Editor_vue_vue_type_script_setup_true_lang_ts__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_ts_loader_index_js_clonedRuleSet_6_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Editor_vue_vue_type_script_setup_true_lang_ts__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== "default") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_ts_loader_index_js_clonedRuleSet_6_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Editor_vue_vue_type_script_setup_true_lang_ts__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);
 

/***/ }),

/***/ "./resources/js/components/Editor.vue?vue&type=template&id=1dbb5118&ts=true":
/*!**********************************************************************************!*\
  !*** ./resources/js/components/Editor.vue?vue&type=template&id=1dbb5118&ts=true ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __esModule: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_ts_loader_index_js_clonedRuleSet_6_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_3_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Editor_vue_vue_type_template_id_1dbb5118_ts_true__WEBPACK_IMPORTED_MODULE_0__.__esModule),
/* harmony export */   render: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_ts_loader_index_js_clonedRuleSet_6_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_3_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Editor_vue_vue_type_template_id_1dbb5118_ts_true__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_ts_loader_index_js_clonedRuleSet_6_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_3_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_Editor_vue_vue_type_template_id_1dbb5118_ts_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../node_modules/ts-loader/index.js??clonedRuleSet-6!../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./Editor.vue?vue&type=template&id=1dbb5118&ts=true */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-6!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/Editor.vue?vue&type=template&id=1dbb5118&ts=true");


/***/ }),

/***/ "./resources/js/components/DetailField.vue?vue&type=script&lang=js":
/*!*************************************************************************!*\
  !*** ./resources/js/components/DetailField.vue?vue&type=script&lang=js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_DetailField_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_DetailField_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./DetailField.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/DetailField.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./resources/js/components/FormField.vue?vue&type=script&lang=js":
/*!***********************************************************************!*\
  !*** ./resources/js/components/FormField.vue?vue&type=script&lang=js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_FormField_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_FormField_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./FormField.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/FormField.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./resources/js/components/DetailField.vue?vue&type=template&id=0224618e":
/*!*******************************************************************************!*\
  !*** ./resources/js/components/DetailField.vue?vue&type=template&id=0224618e ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_3_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_DetailField_vue_vue_type_template_id_0224618e__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_3_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_DetailField_vue_vue_type_template_id_0224618e__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./DetailField.vue?vue&type=template&id=0224618e */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/DetailField.vue?vue&type=template&id=0224618e");


/***/ }),

/***/ "./resources/js/components/FormField.vue?vue&type=template&id=c023248a":
/*!*****************************************************************************!*\
  !*** ./resources/js/components/FormField.vue?vue&type=template&id=c023248a ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_3_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_FormField_vue_vue_type_template_id_c023248a__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_3_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_FormField_vue_vue_type_template_id_c023248a__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./FormField.vue?vue&type=template&id=c023248a */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[3]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/FormField.vue?vue&type=template&id=c023248a");


/***/ }),

/***/ "laravel-nova":
/*!******************************!*\
  !*** external "LaravelNova" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = LaravelNova;

/***/ }),

/***/ "vue":
/*!**********************!*\
  !*** external "Vue" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = Vue;

/***/ }),

/***/ "./node_modules/orderedmap/dist/index.cjs":
/*!************************************************!*\
  !*** ./node_modules/orderedmap/dist/index.cjs ***!
  \************************************************/
/***/ ((module) => {

"use strict";


// ::- Persistent data structure representing an ordered mapping from
// strings to values, with some convenient update methods.
function OrderedMap(content) {
  this.content = content;
}

OrderedMap.prototype = {
  constructor: OrderedMap,

  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key) return i
    return -1
  },

  // :: (string)  ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found = this.find(key);
    return found == -1 ? undefined : this.content[found + 1]
  },

  // :: (string, any, ?string)  OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self = newKey && newKey != key ? this.remove(newKey) : this;
    var found = self.find(key), content = self.content.slice();
    if (found == -1) {
      content.push(newKey || key, value);
    } else {
      content[found + 1] = value;
      if (newKey) content[found] = newKey;
    }
    return new OrderedMap(content)
  },

  // :: (string)  OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found = this.find(key);
    if (found == -1) return this
    var content = this.content.slice();
    content.splice(found, 2);
    return new OrderedMap(content)
  },

  // :: (string, any)  OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content))
  },

  // :: (string, any)  OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content)
  },

  // :: (string, string, any)  OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found = without.find(place);
    content.splice(found == -1 ? content.length : found, 0, key, value);
    return new OrderedMap(content)
  },

  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },

  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map) {
    map = OrderedMap.from(map);
    if (!map.size) return this
    return new OrderedMap(map.content.concat(this.subtract(map).content))
  },

  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map) {
    map = OrderedMap.from(map);
    if (!map.size) return this
    return new OrderedMap(this.subtract(map).content.concat(map.content))
  },

  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map) {
    var result = this;
    map = OrderedMap.from(map);
    for (var i = 0; i < map.content.length; i += 2)
      result = result.remove(map.content[i]);
    return result
  },

  // :: ()  Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var result = {};
    this.forEach(function(key, value) { result[key] = value; });
    return result
  },

  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1
  }
};

// :: (?union<Object, OrderedMap>)  OrderedMap
// Return a map with the given content. If null, create an empty
// map. If given an ordered map, return that map itself. If given an
// object, create a map from the object's properties.
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap) return value
  var content = [];
  if (value) for (var prop in value) content.push(prop, value[prop]);
  return new OrderedMap(content)
};

module.exports = OrderedMap;


/***/ }),

/***/ "./node_modules/prosemirror-commands/dist/index.cjs":
/*!**********************************************************!*\
  !*** ./node_modules/prosemirror-commands/dist/index.cjs ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.cjs");

var prosemirrorModel = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.cjs");

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

var deleteSelection = function deleteSelection(state, dispatch) {
  if (state.selection.empty) return false;
  if (dispatch) dispatch(state.tr.deleteSelection().scrollIntoView());
  return true;
};

function atBlockStart(state, view) {
  var $cursor = state.selection.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0)) return null;
  return $cursor;
}

var joinBackward = function joinBackward(state, dispatch, view) {
  var $cursor = atBlockStart(state, view);
  if (!$cursor) return false;
  var $cut = findCutBefore($cursor);

  if (!$cut) {
    var range = $cursor.blockRange(),
        target = range && prosemirrorTransform.liftTarget(range);
    if (target == null) return false;
    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }

  var before = $cut.nodeBefore;
  if (!before.type.spec.isolating && deleteBarrier(state, $cut, dispatch)) return true;

  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || prosemirrorState.NodeSelection.isSelectable(before))) {
    var delStep = prosemirrorTransform.replaceStep(state.doc, $cursor.before(), $cursor.after(), prosemirrorModel.Slice.empty);

    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        var tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(before, "end") ? prosemirrorState.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : prosemirrorState.NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
        dispatch(tr.scrollIntoView());
      }

      return true;
    }
  }

  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch) dispatch(state.tr["delete"]($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }

  return false;
};

var joinTextblockBackward = function joinTextblockBackward(state, dispatch, view) {
  var $cursor = atBlockStart(state, view);
  if (!$cursor) return false;
  var $cut = findCutBefore($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
};

var joinTextblockForward = function joinTextblockForward(state, dispatch, view) {
  var $cursor = atBlockEnd(state, view);
  if (!$cursor) return false;
  var $cut = findCutAfter($cursor);
  return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;
};

function joinTextblocksAround(state, $cut, dispatch) {
  var before = $cut.nodeBefore,
      beforeText = before,
      beforePos = $cut.pos - 1;

  for (; !beforeText.isTextblock; beforePos--) {
    if (beforeText.type.spec.isolating) return false;
    var child = beforeText.lastChild;
    if (!child) return false;
    beforeText = child;
  }

  var after = $cut.nodeAfter,
      afterText = after,
      afterPos = $cut.pos + 1;

  for (; !afterText.isTextblock; afterPos++) {
    if (afterText.type.spec.isolating) return false;
    var _child = afterText.firstChild;
    if (!_child) return false;
    afterText = _child;
  }

  var step = prosemirrorTransform.replaceStep(state.doc, beforePos, afterPos, prosemirrorModel.Slice.empty);
  if (!step || step.from != beforePos || step instanceof prosemirrorTransform.ReplaceStep && step.slice.size >= afterPos - beforePos) return false;

  if (dispatch) {
    var tr = state.tr.step(step);
    tr.setSelection(prosemirrorState.TextSelection.create(tr.doc, beforePos));
    dispatch(tr.scrollIntoView());
  }

  return true;
}

function textblockAt(node, side) {
  var only = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  for (var scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock) return true;
    if (only && scan.childCount != 1) return false;
  }

  return false;
}

var selectNodeBackward = function selectNodeBackward(state, dispatch, view) {
  var _state$selection = state.selection,
      $head = _state$selection.$head,
      empty = _state$selection.empty,
      $cut = $head;
  if (!empty) return false;

  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0) return false;
    $cut = findCutBefore($head);
  }

  var node = $cut && $cut.nodeBefore;
  if (!node || !prosemirrorState.NodeSelection.isSelectable(node)) return false;
  if (dispatch) dispatch(state.tr.setSelection(prosemirrorState.NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
  return true;
};

function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating) for (var i = $pos.depth - 1; i >= 0; i--) {
    if ($pos.index(i) > 0) return $pos.doc.resolve($pos.before(i + 1));
    if ($pos.node(i).type.spec.isolating) break;
  }
  return null;
}

function atBlockEnd(state, view) {
  var $cursor = state.selection.$cursor;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size)) return null;
  return $cursor;
}

var joinForward = function joinForward(state, dispatch, view) {
  var $cursor = atBlockEnd(state, view);
  if (!$cursor) return false;
  var $cut = findCutAfter($cursor);
  if (!$cut) return false;
  var after = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch)) return true;

  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || prosemirrorState.NodeSelection.isSelectable(after))) {
    var delStep = prosemirrorTransform.replaceStep(state.doc, $cursor.before(), $cursor.after(), prosemirrorModel.Slice.empty);

    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        var tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(after, "start") ? prosemirrorState.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : prosemirrorState.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
        dispatch(tr.scrollIntoView());
      }

      return true;
    }
  }

  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch) dispatch(state.tr["delete"]($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }

  return false;
};

var selectNodeForward = function selectNodeForward(state, dispatch, view) {
  var _state$selection2 = state.selection,
      $head = _state$selection2.$head,
      empty = _state$selection2.empty,
      $cut = $head;
  if (!empty) return false;

  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size) return false;
    $cut = findCutAfter($head);
  }

  var node = $cut && $cut.nodeAfter;
  if (!node || !prosemirrorState.NodeSelection.isSelectable(node)) return false;
  if (dispatch) dispatch(state.tr.setSelection(prosemirrorState.NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  return true;
};

function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating) for (var i = $pos.depth - 1; i >= 0; i--) {
    var parent = $pos.node(i);
    if ($pos.index(i) + 1 < parent.childCount) return $pos.doc.resolve($pos.after(i + 1));
    if (parent.type.spec.isolating) break;
  }
  return null;
}

var joinUp = function joinUp(state, dispatch) {
  var sel = state.selection,
      nodeSel = sel instanceof prosemirrorState.NodeSelection,
      point;

  if (nodeSel) {
    if (sel.node.isTextblock || !prosemirrorTransform.canJoin(state.doc, sel.from)) return false;
    point = sel.from;
  } else {
    point = prosemirrorTransform.joinPoint(state.doc, sel.from, -1);
    if (point == null) return false;
  }

  if (dispatch) {
    var tr = state.tr.join(point);
    if (nodeSel) tr.setSelection(prosemirrorState.NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
    dispatch(tr.scrollIntoView());
  }

  return true;
};

var joinDown = function joinDown(state, dispatch) {
  var sel = state.selection,
      point;

  if (sel instanceof prosemirrorState.NodeSelection) {
    if (sel.node.isTextblock || !prosemirrorTransform.canJoin(state.doc, sel.to)) return false;
    point = sel.to;
  } else {
    point = prosemirrorTransform.joinPoint(state.doc, sel.to, 1);
    if (point == null) return false;
  }

  if (dispatch) dispatch(state.tr.join(point).scrollIntoView());
  return true;
};

var lift = function lift(state, dispatch) {
  var _state$selection3 = state.selection,
      $from = _state$selection3.$from,
      $to = _state$selection3.$to;
  var range = $from.blockRange($to),
      target = range && prosemirrorTransform.liftTarget(range);
  if (target == null) return false;
  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};

var newlineInCode = function newlineInCode(state, dispatch) {
  var _state$selection4 = state.selection,
      $head = _state$selection4.$head,
      $anchor = _state$selection4.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;
  if (dispatch) dispatch(state.tr.insertText("\n").scrollIntoView());
  return true;
};

function defaultBlockAt(match) {
  for (var i = 0; i < match.edgeCount; i++) {
    var _match$edge = match.edge(i),
        type = _match$edge.type;

    if (type.isTextblock && !type.hasRequiredAttrs()) return type;
  }

  return null;
}

var exitCode = function exitCode(state, dispatch) {
  var _state$selection5 = state.selection,
      $head = _state$selection5.$head,
      $anchor = _state$selection5.$anchor;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor)) return false;
  var above = $head.node(-1),
      after = $head.indexAfter(-1),
      type = defaultBlockAt(above.contentMatchAt(after));
  if (!type || !above.canReplaceWith(after, after, type)) return false;

  if (dispatch) {
    var pos = $head.after(),
        tr = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr.setSelection(prosemirrorState.Selection.near(tr.doc.resolve(pos), 1));
    dispatch(tr.scrollIntoView());
  }

  return true;
};

var createParagraphNear = function createParagraphNear(state, dispatch) {
  var sel = state.selection,
      $from = sel.$from,
      $to = sel.$to;
  if (sel instanceof prosemirrorState.AllSelection || $from.parent.inlineContent || $to.parent.inlineContent) return false;
  var type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock) return false;

  if (dispatch) {
    var side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    var tr = state.tr.insert(side, type.createAndFill());
    tr.setSelection(prosemirrorState.TextSelection.create(tr.doc, side + 1));
    dispatch(tr.scrollIntoView());
  }

  return true;
};

var liftEmptyBlock = function liftEmptyBlock(state, dispatch) {
  var $cursor = state.selection.$cursor;
  if (!$cursor || $cursor.parent.content.size) return false;

  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    var before = $cursor.before();

    if (prosemirrorTransform.canSplit(state.doc, before)) {
      if (dispatch) dispatch(state.tr.split(before).scrollIntoView());
      return true;
    }
  }

  var range = $cursor.blockRange(),
      target = range && prosemirrorTransform.liftTarget(range);
  if (target == null) return false;
  if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};

function splitBlockAs(splitNode) {
  return function (state, dispatch) {
    var _state$selection6 = state.selection,
        $from = _state$selection6.$from,
        $to = _state$selection6.$to;

    if (state.selection instanceof prosemirrorState.NodeSelection && state.selection.node.isBlock) {
      if (!$from.parentOffset || !prosemirrorTransform.canSplit(state.doc, $from.pos)) return false;
      if (dispatch) dispatch(state.tr.split($from.pos).scrollIntoView());
      return true;
    }

    if (!$from.parent.isBlock) return false;

    if (dispatch) {
      var atEnd = $to.parentOffset == $to.parent.content.size;
      var tr = state.tr;
      if (state.selection instanceof prosemirrorState.TextSelection || state.selection instanceof prosemirrorState.AllSelection) tr.deleteSelection();
      var deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));
      var splitType = splitNode && splitNode($to.parent, atEnd);
      var types = splitType ? [splitType] : atEnd && deflt ? [{
        type: deflt
      }] : undefined;
      var can = prosemirrorTransform.canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);

      if (!types && !can && prosemirrorTransform.canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{
        type: deflt
      }] : undefined)) {
        if (deflt) types = [{
          type: deflt
        }];
        can = true;
      }

      if (can) {
        tr.split(tr.mapping.map($from.pos), 1, types);

        if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {
          var first = tr.mapping.map($from.before()),
              $first = tr.doc.resolve(first);
          if (deflt && $from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
        }
      }

      dispatch(tr.scrollIntoView());
    }

    return true;
  };
}

var splitBlock = splitBlockAs();

var splitBlockKeepMarks = function splitBlockKeepMarks(state, dispatch) {
  return splitBlock(state, dispatch && function (tr) {
    var marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
    if (marks) tr.ensureMarks(marks);
    dispatch(tr);
  });
};

var selectParentNode = function selectParentNode(state, dispatch) {
  var _state$selection7 = state.selection,
      $from = _state$selection7.$from,
      to = _state$selection7.to,
      pos;
  var same = $from.sharedDepth(to);
  if (same == 0) return false;
  pos = $from.before(same);
  if (dispatch) dispatch(state.tr.setSelection(prosemirrorState.NodeSelection.create(state.doc, pos)));
  return true;
};

var selectAll = function selectAll(state, dispatch) {
  if (dispatch) dispatch(state.tr.setSelection(new prosemirrorState.AllSelection(state.doc)));
  return true;
};

function joinMaybeClear(state, $pos, dispatch) {
  var before = $pos.nodeBefore,
      after = $pos.nodeAfter,
      index = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type)) return false;

  if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {
    if (dispatch) dispatch(state.tr["delete"]($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }

  if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || prosemirrorTransform.canJoin(state.doc, $pos.pos))) return false;
  if (dispatch) dispatch(state.tr.clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount)).join($pos.pos).scrollIntoView());
  return true;
}

function deleteBarrier(state, $cut, dispatch) {
  var before = $cut.nodeBefore,
      after = $cut.nodeAfter,
      conn,
      match;
  if (before.type.spec.isolating || after.type.spec.isolating) return false;
  if (joinMaybeClear(state, $cut, dispatch)) return true;
  var canDelAfter = $cut.parent.canReplace($cut.index(), $cut.index() + 1);

  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      var end = $cut.pos + after.nodeSize,
          wrap = prosemirrorModel.Fragment.empty;

      for (var i = conn.length - 1; i >= 0; i--) {
        wrap = prosemirrorModel.Fragment.from(conn[i].create(null, wrap));
      }

      wrap = prosemirrorModel.Fragment.from(before.copy(wrap));
      var tr = state.tr.step(new prosemirrorTransform.ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new prosemirrorModel.Slice(wrap, 1, 0), conn.length, true));
      var joinAt = end + 2 * conn.length;
      if (prosemirrorTransform.canJoin(tr.doc, joinAt)) tr.join(joinAt);
      dispatch(tr.scrollIntoView());
    }

    return true;
  }

  var selAfter = prosemirrorState.Selection.findFrom($cut, 1);
  var range = selAfter && selAfter.$from.blockRange(selAfter.$to),
      target = range && prosemirrorTransform.liftTarget(range);

  if (target != null && target >= $cut.depth) {
    if (dispatch) dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }

  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    var at = before,
        _wrap = [];

    for (;;) {
      _wrap.push(at);

      if (at.isTextblock) break;
      at = at.lastChild;
    }

    var afterText = after,
        afterDepth = 1;

    for (; !afterText.isTextblock; afterText = afterText.firstChild) {
      afterDepth++;
    }

    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch) {
        var _end = prosemirrorModel.Fragment.empty;

        for (var _i = _wrap.length - 1; _i >= 0; _i--) {
          _end = prosemirrorModel.Fragment.from(_wrap[_i].copy(_end));
        }

        var _tr = state.tr.step(new prosemirrorTransform.ReplaceAroundStep($cut.pos - _wrap.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new prosemirrorModel.Slice(_end, _wrap.length, 0), 0, true));

        dispatch(_tr.scrollIntoView());
      }

      return true;
    }
  }

  return false;
}

function selectTextblockSide(side) {
  return function (state, dispatch) {
    var sel = state.selection,
        $pos = side < 0 ? sel.$from : sel.$to;
    var depth = $pos.depth;

    while ($pos.node(depth).isInline) {
      if (!depth) return false;
      depth--;
    }

    if (!$pos.node(depth).isTextblock) return false;
    if (dispatch) dispatch(state.tr.setSelection(prosemirrorState.TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}

var selectTextblockStart = selectTextblockSide(-1);
var selectTextblockEnd = selectTextblockSide(1);

function wrapIn(nodeType) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return function (state, dispatch) {
    var _state$selection8 = state.selection,
        $from = _state$selection8.$from,
        $to = _state$selection8.$to;
    var range = $from.blockRange($to),
        wrapping = range && prosemirrorTransform.findWrapping(range, nodeType, attrs);
    if (!wrapping) return false;
    if (dispatch) dispatch(state.tr.wrap(range, wrapping).scrollIntoView());
    return true;
  };
}

function setBlockType(nodeType) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return function (state, dispatch) {
    var applicable = false;

    for (var i = 0; i < state.selection.ranges.length && !applicable; i++) {
      var _state$selection$rang = state.selection.ranges[i],
          from = _state$selection$rang.$from.pos,
          to = _state$selection$rang.$to.pos;
      state.doc.nodesBetween(from, to, function (node, pos) {
        if (applicable) return false;
        if (!node.isTextblock || node.hasMarkup(nodeType, attrs)) return;

        if (node.type == nodeType) {
          applicable = true;
        } else {
          var $pos = state.doc.resolve(pos),
              index = $pos.index();
          applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);
        }
      });
    }

    if (!applicable) return false;

    if (dispatch) {
      var tr = state.tr;

      for (var _i2 = 0; _i2 < state.selection.ranges.length; _i2++) {
        var _state$selection$rang2 = state.selection.ranges[_i2],
            _from = _state$selection$rang2.$from.pos,
            _to = _state$selection$rang2.$to.pos;
        tr.setBlockType(_from, _to, nodeType, attrs);
      }

      dispatch(tr.scrollIntoView());
    }

    return true;
  };
}

function markApplies(doc, ranges, type) {
  var _loop = function _loop(i) {
    var _ranges$i = ranges[i],
        $from = _ranges$i.$from,
        $to = _ranges$i.$to;
    var can = $from.depth == 0 ? doc.inlineContent && doc.type.allowsMarkType(type) : false;
    doc.nodesBetween($from.pos, $to.pos, function (node) {
      if (can) return false;
      can = node.inlineContent && node.type.allowsMarkType(type);
    });
    if (can) return {
      v: true
    };
  };

  for (var i = 0; i < ranges.length; i++) {
    var _ret = _loop(i);

    if (_typeof(_ret) === "object") return _ret.v;
  }

  return false;
}

function toggleMark(markType) {
  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return function (state, dispatch) {
    var _state$selection9 = state.selection,
        empty = _state$selection9.empty,
        $cursor = _state$selection9.$cursor,
        ranges = _state$selection9.ranges;
    if (empty && !$cursor || !markApplies(state.doc, ranges, markType)) return false;

    if (dispatch) {
      if ($cursor) {
        if (markType.isInSet(state.storedMarks || $cursor.marks())) dispatch(state.tr.removeStoredMark(markType));else dispatch(state.tr.addStoredMark(markType.create(attrs)));
      } else {
        var has = false,
            tr = state.tr;

        for (var i = 0; !has && i < ranges.length; i++) {
          var _ranges$i2 = ranges[i],
              $from = _ranges$i2.$from,
              $to = _ranges$i2.$to;
          has = state.doc.rangeHasMark($from.pos, $to.pos, markType);
        }

        for (var _i3 = 0; _i3 < ranges.length; _i3++) {
          var _ranges$_i = ranges[_i3],
              _$from = _ranges$_i.$from,
              _$to = _ranges$_i.$to;

          if (has) {
            tr.removeMark(_$from.pos, _$to.pos, markType);
          } else {
            var from = _$from.pos,
                to = _$to.pos,
                start = _$from.nodeAfter,
                end = _$to.nodeBefore;
            var spaceStart = start && start.isText ? /^\s*/.exec(start.text)[0].length : 0;
            var spaceEnd = end && end.isText ? /\s*$/.exec(end.text)[0].length : 0;

            if (from + spaceStart < to) {
              from += spaceStart;
              to -= spaceEnd;
            }

            tr.addMark(from, to, markType.create(attrs));
          }
        }

        dispatch(tr.scrollIntoView());
      }
    }

    return true;
  };
}

function wrapDispatchForJoin(dispatch, isJoinable) {
  return function (tr) {
    if (!tr.isGeneric) return dispatch(tr);
    var ranges = [];

    for (var i = 0; i < tr.mapping.maps.length; i++) {
      var map = tr.mapping.maps[i];

      for (var j = 0; j < ranges.length; j++) {
        ranges[j] = map.map(ranges[j]);
      }

      map.forEach(function (_s, _e, from, to) {
        return ranges.push(from, to);
      });
    }

    var joinable = [];

    for (var _i4 = 0; _i4 < ranges.length; _i4 += 2) {
      var from = ranges[_i4],
          to = ranges[_i4 + 1];
      var $from = tr.doc.resolve(from),
          depth = $from.sharedDepth(to),
          parent = $from.node(depth);

      for (var index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {
        var after = parent.maybeChild(index);
        if (!after) break;

        if (index && joinable.indexOf(pos) == -1) {
          var before = parent.child(index - 1);
          if (before.type == after.type && isJoinable(before, after)) joinable.push(pos);
        }

        pos += after.nodeSize;
      }
    }

    joinable.sort(function (a, b) {
      return a - b;
    });

    for (var _i5 = joinable.length - 1; _i5 >= 0; _i5--) {
      if (prosemirrorTransform.canJoin(tr.doc, joinable[_i5])) tr.join(joinable[_i5]);
    }

    dispatch(tr);
  };
}

function autoJoin(command, isJoinable) {
  var canJoin = Array.isArray(isJoinable) ? function (node) {
    return isJoinable.indexOf(node.type.name) > -1;
  } : isJoinable;
  return function (state, dispatch, view) {
    return command(state, dispatch && wrapDispatchForJoin(dispatch, canJoin), view);
  };
}

function chainCommands() {
  for (var _len = arguments.length, commands = new Array(_len), _key = 0; _key < _len; _key++) {
    commands[_key] = arguments[_key];
  }

  return function (state, dispatch, view) {
    for (var i = 0; i < commands.length; i++) {
      if (commands[i](state, dispatch, view)) return true;
    }

    return false;
  };
}

var backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);
var del = chainCommands(deleteSelection, joinForward, selectNodeForward);
var pcBaseKeymap = {
  "Enter": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),
  "Mod-Enter": exitCode,
  "Backspace": backspace,
  "Mod-Backspace": backspace,
  "Shift-Backspace": backspace,
  "Delete": del,
  "Mod-Delete": del,
  "Mod-a": selectAll
};
var macBaseKeymap = {
  "Ctrl-h": pcBaseKeymap["Backspace"],
  "Alt-Backspace": pcBaseKeymap["Mod-Backspace"],
  "Ctrl-d": pcBaseKeymap["Delete"],
  "Ctrl-Alt-Backspace": pcBaseKeymap["Mod-Delete"],
  "Alt-Delete": pcBaseKeymap["Mod-Delete"],
  "Alt-d": pcBaseKeymap["Mod-Delete"],
  "Ctrl-a": selectTextblockStart,
  "Ctrl-e": selectTextblockEnd
};

for (var key in pcBaseKeymap) {
  macBaseKeymap[key] = pcBaseKeymap[key];
}

var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
var baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;
exports.autoJoin = autoJoin;
exports.baseKeymap = baseKeymap;
exports.chainCommands = chainCommands;
exports.createParagraphNear = createParagraphNear;
exports.deleteSelection = deleteSelection;
exports.exitCode = exitCode;
exports.joinBackward = joinBackward;
exports.joinDown = joinDown;
exports.joinForward = joinForward;
exports.joinTextblockBackward = joinTextblockBackward;
exports.joinTextblockForward = joinTextblockForward;
exports.joinUp = joinUp;
exports.lift = lift;
exports.liftEmptyBlock = liftEmptyBlock;
exports.macBaseKeymap = macBaseKeymap;
exports.newlineInCode = newlineInCode;
exports.pcBaseKeymap = pcBaseKeymap;
exports.selectAll = selectAll;
exports.selectNodeBackward = selectNodeBackward;
exports.selectNodeForward = selectNodeForward;
exports.selectParentNode = selectParentNode;
exports.selectTextblockEnd = selectTextblockEnd;
exports.selectTextblockStart = selectTextblockStart;
exports.setBlockType = setBlockType;
exports.splitBlock = splitBlock;
exports.splitBlockAs = splitBlockAs;
exports.splitBlockKeepMarks = splitBlockKeepMarks;
exports.toggleMark = toggleMark;
exports.wrapIn = wrapIn;


/***/ }),

/***/ "./node_modules/prosemirror-history/dist/index.cjs":
/*!*********************************************************!*\
  !*** ./node_modules/prosemirror-history/dist/index.cjs ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var RopeSequence = __webpack_require__(/*! rope-sequence */ "./node_modules/rope-sequence/dist/index.cjs");

var prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.cjs");

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

function _interopDefaultLegacy(e) {
  return e && _typeof(e) === 'object' && 'default' in e ? e : {
    'default': e
  };
}

var RopeSequence__default = _interopDefaultLegacy(RopeSequence);

var max_empty_items = 500;

var Branch = function () {
  function Branch(items, eventCount) {
    _classCallCheck(this, Branch);

    this.items = items;
    this.eventCount = eventCount;
  }

  _createClass(Branch, [{
    key: "popEvent",
    value: function popEvent(state, preserveItems) {
      var _this = this;

      if (this.eventCount == 0) return null;
      var end = this.items.length;

      for (;; end--) {
        var next = this.items.get(end - 1);

        if (next.selection) {
          --end;
          break;
        }
      }

      var remap, mapFrom;

      if (preserveItems) {
        remap = this.remapping(end, this.items.length);
        mapFrom = remap.maps.length;
      }

      var transform = state.tr;
      var selection, remaining;
      var addAfter = [],
          addBefore = [];
      this.items.forEach(function (item, i) {
        if (!item.step) {
          if (!remap) {
            remap = _this.remapping(end, i + 1);
            mapFrom = remap.maps.length;
          }

          mapFrom--;
          addBefore.push(item);
          return;
        }

        if (remap) {
          addBefore.push(new Item(item.map));
          var step = item.step.map(remap.slice(mapFrom)),
              map;

          if (step && transform.maybeStep(step).doc) {
            map = transform.mapping.maps[transform.mapping.maps.length - 1];
            addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));
          }

          mapFrom--;
          if (map) remap.appendMap(map, mapFrom);
        } else {
          transform.maybeStep(item.step);
        }

        if (item.selection) {
          selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
          remaining = new Branch(_this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), _this.eventCount - 1);
          return false;
        }
      }, this.items.length, 0);
      return {
        remaining: remaining,
        transform: transform,
        selection: selection
      };
    }
  }, {
    key: "addTransform",
    value: function addTransform(transform, selection, histOptions, preserveItems) {
      var newItems = [],
          eventCount = this.eventCount;
      var oldItems = this.items,
          lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;

      for (var i = 0; i < transform.steps.length; i++) {
        var step = transform.steps[i].invert(transform.docs[i]);
        var item = new Item(transform.mapping.maps[i], step, selection),
            merged = void 0;

        if (merged = lastItem && lastItem.merge(item)) {
          item = merged;
          if (i) newItems.pop();else oldItems = oldItems.slice(0, oldItems.length - 1);
        }

        newItems.push(item);

        if (selection) {
          eventCount++;
          selection = undefined;
        }

        if (!preserveItems) lastItem = item;
      }

      var overflow = eventCount - histOptions.depth;

      if (overflow > DEPTH_OVERFLOW) {
        oldItems = cutOffEvents(oldItems, overflow);
        eventCount -= overflow;
      }

      return new Branch(oldItems.append(newItems), eventCount);
    }
  }, {
    key: "remapping",
    value: function remapping(from, to) {
      var maps = new prosemirrorTransform.Mapping();
      this.items.forEach(function (item, i) {
        var mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from ? maps.maps.length - item.mirrorOffset : undefined;
        maps.appendMap(item.map, mirrorPos);
      }, from, to);
      return maps;
    }
  }, {
    key: "addMaps",
    value: function addMaps(array) {
      if (this.eventCount == 0) return this;
      return new Branch(this.items.append(array.map(function (map) {
        return new Item(map);
      })), this.eventCount);
    }
  }, {
    key: "rebased",
    value: function rebased(rebasedTransform, rebasedCount) {
      if (!this.eventCount) return this;
      var rebasedItems = [],
          start = Math.max(0, this.items.length - rebasedCount);
      var mapping = rebasedTransform.mapping;
      var newUntil = rebasedTransform.steps.length;
      var eventCount = this.eventCount;
      this.items.forEach(function (item) {
        if (item.selection) eventCount--;
      }, start);
      var iRebased = rebasedCount;
      this.items.forEach(function (item) {
        var pos = mapping.getMirror(--iRebased);
        if (pos == null) return;
        newUntil = Math.min(newUntil, pos);
        var map = mapping.maps[pos];

        if (item.step) {
          var step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
          var selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
          if (selection) eventCount++;
          rebasedItems.push(new Item(map, step, selection));
        } else {
          rebasedItems.push(new Item(map));
        }
      }, start);
      var newMaps = [];

      for (var i = rebasedCount; i < newUntil; i++) {
        newMaps.push(new Item(mapping.maps[i]));
      }

      var items = this.items.slice(0, start).append(newMaps).append(rebasedItems);
      var branch = new Branch(items, eventCount);
      if (branch.emptyItemCount() > max_empty_items) branch = branch.compress(this.items.length - rebasedItems.length);
      return branch;
    }
  }, {
    key: "emptyItemCount",
    value: function emptyItemCount() {
      var count = 0;
      this.items.forEach(function (item) {
        if (!item.step) count++;
      });
      return count;
    }
  }, {
    key: "compress",
    value: function compress() {
      var upto = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.items.length;
      var remap = this.remapping(0, upto),
          mapFrom = remap.maps.length;
      var items = [],
          events = 0;
      this.items.forEach(function (item, i) {
        if (i >= upto) {
          items.push(item);
          if (item.selection) events++;
        } else if (item.step) {
          var step = item.step.map(remap.slice(mapFrom)),
              map = step && step.getMap();
          mapFrom--;
          if (map) remap.appendMap(map, mapFrom);

          if (step) {
            var selection = item.selection && item.selection.map(remap.slice(mapFrom));
            if (selection) events++;
            var newItem = new Item(map.invert(), step, selection),
                merged,
                last = items.length - 1;
            if (merged = items.length && items[last].merge(newItem)) items[last] = merged;else items.push(newItem);
          }
        } else if (item.map) {
          mapFrom--;
        }
      }, this.items.length, 0);
      return new Branch(RopeSequence__default["default"].from(items.reverse()), events);
    }
  }]);

  return Branch;
}();

Branch.empty = new Branch(RopeSequence__default["default"].empty, 0);

function cutOffEvents(items, n) {
  var cutPoint;
  items.forEach(function (item, i) {
    if (item.selection && n-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items.slice(cutPoint);
}

var Item = function () {
  function Item(map, step, selection, mirrorOffset) {
    _classCallCheck(this, Item);

    this.map = map;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }

  _createClass(Item, [{
    key: "merge",
    value: function merge(other) {
      if (this.step && other.step && !other.selection) {
        var step = other.step.merge(this.step);
        if (step) return new Item(step.getMap().invert(), step, this.selection);
      }
    }
  }]);

  return Item;
}();

var HistoryState = _createClass(function HistoryState(done, undone, prevRanges, prevTime, prevComposition) {
  _classCallCheck(this, HistoryState);

  this.done = done;
  this.undone = undone;
  this.prevRanges = prevRanges;
  this.prevTime = prevTime;
  this.prevComposition = prevComposition;
});

var DEPTH_OVERFLOW = 20;

function applyTransaction(history, state, tr, options) {
  var historyTr = tr.getMeta(historyKey),
      rebased;
  if (historyTr) return historyTr.historyState;
  if (tr.getMeta(closeHistoryKey)) history = new HistoryState(history.done, history.undone, null, 0, -1);
  var appended = tr.getMeta("appendedTransaction");

  if (tr.steps.length == 0) {
    return history;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo) return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps[tr.steps.length - 1]), history.prevTime, history.prevComposition);else return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime, history.prevComposition);
  } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    var composition = tr.getMeta("composition");
    var newGroup = history.prevTime == 0 || !appended && history.prevComposition != composition && (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges));
    var prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps[tr.steps.length - 1]);
    return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history.prevComposition : composition);
  } else if (rebased = tr.getMeta("rebased")) {
    return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);
  } else {
    return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);
  }
}

function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges) return false;
  if (!transform.docChanged) return true;
  var adjacent = false;
  transform.mapping.maps[0].forEach(function (start, end) {
    for (var i = 0; i < prevRanges.length; i += 2) {
      if (start <= prevRanges[i + 1] && end >= prevRanges[i]) adjacent = true;
    }
  });
  return adjacent;
}

function rangesFor(map) {
  var result = [];
  map.forEach(function (_from, _to, from, to) {
    return result.push(from, to);
  });
  return result;
}

function mapRanges(ranges, mapping) {
  if (!ranges) return null;
  var result = [];

  for (var i = 0; i < ranges.length; i += 2) {
    var from = mapping.map(ranges[i], 1),
        to = mapping.map(ranges[i + 1], -1);
    if (from <= to) result.push(from, to);
  }

  return result;
}

function histTransaction(history, state, dispatch, redo) {
  var preserveItems = mustPreserveItems(state);
  var histOptions = historyKey.get(state).spec.config;
  var pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);
  if (!pop) return;
  var selection = pop.selection.resolve(pop.transform.doc);
  var added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  var newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);
  dispatch(pop.transform.setSelection(selection).setMeta(historyKey, {
    redo: redo,
    historyState: newHist
  }).scrollIntoView());
}

var cachedPreserveItems = false,
    cachedPreserveItemsPlugins = null;

function mustPreserveItems(state) {
  var plugins = state.plugins;

  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;

    for (var i = 0; i < plugins.length; i++) {
      if (plugins[i].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
    }
  }

  return cachedPreserveItems;
}

function closeHistory(tr) {
  return tr.setMeta(closeHistoryKey, true);
}

var historyKey = new prosemirrorState.PluginKey("history");
var closeHistoryKey = new prosemirrorState.PluginKey("closeHistory");

function history() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  config = {
    depth: config.depth || 100,
    newGroupDelay: config.newGroupDelay || 500
  };
  return new prosemirrorState.Plugin({
    key: historyKey,
    state: {
      init: function init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
      },
      apply: function apply(tr, hist, state) {
        return applyTransaction(hist, state, tr, config);
      }
    },
    config: config,
    props: {
      handleDOMEvents: {
        beforeinput: function beforeinput(view, e) {
          var inputType = e.inputType;
          var command = inputType == "historyUndo" ? undo : inputType == "historyRedo" ? redo : null;
          if (!command) return false;
          e.preventDefault();
          return command(view.state, view.dispatch);
        }
      }
    }
  });
}

var undo = function undo(state, dispatch) {
  var hist = historyKey.getState(state);
  if (!hist || hist.done.eventCount == 0) return false;
  if (dispatch) histTransaction(hist, state, dispatch, false);
  return true;
};

var redo = function redo(state, dispatch) {
  var hist = historyKey.getState(state);
  if (!hist || hist.undone.eventCount == 0) return false;
  if (dispatch) histTransaction(hist, state, dispatch, true);
  return true;
};

function undoDepth(state) {
  var hist = historyKey.getState(state);
  return hist ? hist.done.eventCount : 0;
}

function redoDepth(state) {
  var hist = historyKey.getState(state);
  return hist ? hist.undone.eventCount : 0;
}

exports.closeHistory = closeHistory;
exports.history = history;
exports.redo = redo;
exports.redoDepth = redoDepth;
exports.undo = undo;
exports.undoDepth = undoDepth;


/***/ }),

/***/ "./node_modules/prosemirror-inputrules/dist/index.cjs":
/*!************************************************************!*\
  !*** ./node_modules/prosemirror-inputrules/dist/index.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

var prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.cjs");

var InputRule = _createClass(function InputRule(match, handler) {
  _classCallCheck(this, InputRule);

  this.match = match;
  this.match = match;
  this.handler = typeof handler == "string" ? stringHandler(handler) : handler;
});

function stringHandler(string) {
  return function (state, match, start, end) {
    var insert = string;

    if (match[1]) {
      var offset = match[0].lastIndexOf(match[1]);
      insert += match[0].slice(offset + match[1].length);
      start += offset;
      var cutOff = start - end;

      if (cutOff > 0) {
        insert = match[0].slice(offset - cutOff, offset) + insert;
        start = end;
      }
    }

    return state.tr.insertText(insert, start, end);
  };
}

var MAX_MATCH = 500;

function inputRules(_ref) {
  var rules = _ref.rules;
  var plugin = new prosemirrorState.Plugin({
    state: {
      init: function init() {
        return null;
      },
      apply: function apply(tr, prev) {
        var stored = tr.getMeta(this);
        if (stored) return stored;
        return tr.selectionSet || tr.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput: function handleTextInput(view, from, to, text) {
        return run(view, from, to, text, rules, plugin);
      },
      handleDOMEvents: {
        compositionend: function compositionend(view) {
          setTimeout(function () {
            var $cursor = view.state.selection.$cursor;
            if ($cursor) run(view, $cursor.pos, $cursor.pos, "", rules, plugin);
          });
        }
      }
    },
    isInputRules: true
  });
  return plugin;
}

function run(view, from, to, text, rules, plugin) {
  if (view.composing) return false;
  var state = view.state,
      $from = state.doc.resolve(from);
  if ($from.parent.type.spec.code) return false;
  var textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset, null, "\uFFFC") + text;

  for (var i = 0; i < rules.length; i++) {
    var match = rules[i].match.exec(textBefore);
    var tr = match && rules[i].handler(state, match, from - (match[0].length - text.length), to);
    if (!tr) continue;
    view.dispatch(tr.setMeta(plugin, {
      transform: tr,
      from: from,
      to: to,
      text: text
    }));
    return true;
  }

  return false;
}

var undoInputRule = function undoInputRule(state, dispatch) {
  var plugins = state.plugins;

  for (var i = 0; i < plugins.length; i++) {
    var plugin = plugins[i],
        undoable = void 0;

    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch) {
        var tr = state.tr,
            toUndo = undoable.transform;

        for (var j = toUndo.steps.length - 1; j >= 0; j--) {
          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }

        if (undoable.text) {
          var marks = tr.doc.resolve(undoable.from).marks();
          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr["delete"](undoable.from, undoable.to);
        }

        dispatch(tr);
      }

      return true;
    }
  }

  return false;
};

var emDash = new InputRule(/--$/, "");
var ellipsis = new InputRule(/\.\.\.$/, "");
var openDoubleQuote = new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "");
var closeDoubleQuote = new InputRule(/"$/, "");
var openSingleQuote = new InputRule(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "");
var closeSingleQuote = new InputRule(/'$/, "");
var smartQuotes = [openDoubleQuote, closeDoubleQuote, openSingleQuote, closeSingleQuote];

function wrappingInputRule(regexp, nodeType) {
  var getAttrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var joinPredicate = arguments.length > 3 ? arguments[3] : undefined;
  return new InputRule(regexp, function (state, match, start, end) {
    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
    var tr = state.tr["delete"](start, end);
    var $start = tr.doc.resolve(start),
        range = $start.blockRange(),
        wrapping = range && prosemirrorTransform.findWrapping(range, nodeType, attrs);
    if (!wrapping) return null;
    tr.wrap(range, wrapping);
    var before = tr.doc.resolve(start - 1).nodeBefore;
    if (before && before.type == nodeType && prosemirrorTransform.canJoin(tr.doc, start - 1) && (!joinPredicate || joinPredicate(match, before))) tr.join(start - 1);
    return tr;
  });
}

function textblockTypeInputRule(regexp, nodeType) {
  var getAttrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return new InputRule(regexp, function (state, match, start, end) {
    var $start = state.doc.resolve(start);
    var attrs = getAttrs instanceof Function ? getAttrs(match) : getAttrs;
    if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), nodeType)) return null;
    return state.tr["delete"](start, end).setBlockType(start, start, nodeType, attrs);
  });
}

exports.InputRule = InputRule;
exports.closeDoubleQuote = closeDoubleQuote;
exports.closeSingleQuote = closeSingleQuote;
exports.ellipsis = ellipsis;
exports.emDash = emDash;
exports.inputRules = inputRules;
exports.openDoubleQuote = openDoubleQuote;
exports.openSingleQuote = openSingleQuote;
exports.smartQuotes = smartQuotes;
exports.textblockTypeInputRule = textblockTypeInputRule;
exports.undoInputRule = undoInputRule;
exports.wrappingInputRule = wrappingInputRule;


/***/ }),

/***/ "./node_modules/prosemirror-keymap/dist/index.cjs":
/*!********************************************************!*\
  !*** ./node_modules/prosemirror-keymap/dist/index.cjs ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var w3cKeyname = __webpack_require__(/*! w3c-keyname */ "./node_modules/w3c-keyname/index.cjs");

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

var mac = typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;

function normalizeKeyName(name) {
  var parts = name.split(/-(?!$)/),
      result = parts[parts.length - 1];
  if (result == "Space") result = " ";
  var alt, ctrl, shift, meta;

  for (var i = 0; i < parts.length - 1; i++) {
    var mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod)) meta = true;else if (/^a(lt)?$/i.test(mod)) alt = true;else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;else if (/^s(hift)?$/i.test(mod)) shift = true;else if (/^mod$/i.test(mod)) {
      if (mac) meta = true;else ctrl = true;
    } else throw new Error("Unrecognized modifier name: " + mod);
  }

  if (alt) result = "Alt-" + result;
  if (ctrl) result = "Ctrl-" + result;
  if (meta) result = "Meta-" + result;
  if (shift) result = "Shift-" + result;
  return result;
}

function normalize(map) {
  var copy = Object.create(null);

  for (var prop in map) {
    copy[normalizeKeyName(prop)] = map[prop];
  }

  return copy;
}

function modifiers(name, event) {
  var shift = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  if (event.altKey) name = "Alt-" + name;
  if (event.ctrlKey) name = "Ctrl-" + name;
  if (event.metaKey) name = "Meta-" + name;
  if (shift && event.shiftKey) name = "Shift-" + name;
  return name;
}

function keymap(bindings) {
  return new prosemirrorState.Plugin({
    props: {
      handleKeyDown: keydownHandler(bindings)
    }
  });
}

function keydownHandler(bindings) {
  var map = normalize(bindings);
  return function (view, event) {
    var name = w3cKeyname.keyName(event),
        baseName,
        direct = map[modifiers(name, event)];
    if (direct && direct(view.state, view.dispatch, view)) return true;

    if (name.length == 1 && name != " ") {
      if (event.shiftKey) {
        var noShift = map[modifiers(name, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view)) return true;
      }

      if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) && (baseName = w3cKeyname.base[event.keyCode]) && baseName != name) {
        var fromCode = map[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view)) return true;
      }
    }

    return false;
  };
}

exports.keydownHandler = keydownHandler;
exports.keymap = keymap;


/***/ }),

/***/ "./node_modules/prosemirror-model/dist/index.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/prosemirror-model/dist/index.cjs ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var OrderedMap = __webpack_require__(/*! orderedmap */ "./node_modules/orderedmap/dist/index.cjs");

function _interopDefaultLegacy(e) {
  return e && _typeof(e) === 'object' && 'default' in e ? e : {
    'default': e
  };
}

var OrderedMap__default = _interopDefaultLegacy(OrderedMap);

function _findDiffStart(a, b, pos) {
  for (var i = 0;; i++) {
    if (i == a.childCount || i == b.childCount) return a.childCount == b.childCount ? null : pos;
    var childA = a.child(i),
        childB = b.child(i);

    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }

    if (!childA.sameMarkup(childB)) return pos;

    if (childA.isText && childA.text != childB.text) {
      for (var j = 0; childA.text[j] == childB.text[j]; j++) {
        pos++;
      }

      return pos;
    }

    if (childA.content.size || childB.content.size) {
      var inner = _findDiffStart(childA.content, childB.content, pos + 1);

      if (inner != null) return inner;
    }

    pos += childA.nodeSize;
  }
}

function _findDiffEnd(a, b, posA, posB) {
  for (var iA = a.childCount, iB = b.childCount;;) {
    if (iA == 0 || iB == 0) return iA == iB ? null : {
      a: posA,
      b: posB
    };
    var childA = a.child(--iA),
        childB = b.child(--iB),
        size = childA.nodeSize;

    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }

    if (!childA.sameMarkup(childB)) return {
      a: posA,
      b: posB
    };

    if (childA.isText && childA.text != childB.text) {
      var same = 0,
          minSize = Math.min(childA.text.length, childB.text.length);

      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }

      return {
        a: posA,
        b: posB
      };
    }

    if (childA.content.size || childB.content.size) {
      var inner = _findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);

      if (inner) return inner;
    }

    posA -= size;
    posB -= size;
  }
}

var Fragment = function () {
  function Fragment(content, size) {
    _classCallCheck(this, Fragment);

    this.content = content;
    this.size = size || 0;
    if (size == null) for (var i = 0; i < content.length; i++) {
      this.size += content[i].nodeSize;
    }
  }

  _createClass(Fragment, [{
    key: "nodesBetween",
    value: function nodesBetween(from, to, f) {
      var nodeStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var parent = arguments.length > 4 ? arguments[4] : undefined;

      for (var i = 0, pos = 0; pos < to; i++) {
        var child = this.content[i],
            end = pos + child.nodeSize;

        if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
          var start = pos + 1;
          child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);
        }

        pos = end;
      }
    }
  }, {
    key: "descendants",
    value: function descendants(f) {
      this.nodesBetween(0, this.size, f);
    }
  }, {
    key: "textBetween",
    value: function textBetween(from, to, blockSeparator, leafText) {
      var text = "",
          separated = true;
      this.nodesBetween(from, to, function (node, pos) {
        if (node.isText) {
          text += node.text.slice(Math.max(from, pos) - pos, to - pos);
          separated = !blockSeparator;
        } else if (node.isLeaf) {
          if (leafText) {
            text += typeof leafText === "function" ? leafText(node) : leafText;
          } else if (node.type.spec.leafText) {
            text += node.type.spec.leafText(node);
          }

          separated = !blockSeparator;
        } else if (!separated && node.isBlock) {
          text += blockSeparator;
          separated = true;
        }
      }, 0);
      return text;
    }
  }, {
    key: "append",
    value: function append(other) {
      if (!other.size) return this;
      if (!this.size) return other;
      var last = this.lastChild,
          first = other.firstChild,
          content = this.content.slice(),
          i = 0;

      if (last.isText && last.sameMarkup(first)) {
        content[content.length - 1] = last.withText(last.text + first.text);
        i = 1;
      }

      for (; i < other.content.length; i++) {
        content.push(other.content[i]);
      }

      return new Fragment(content, this.size + other.size);
    }
  }, {
    key: "cut",
    value: function cut(from) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;
      if (from == 0 && to == this.size) return this;
      var result = [],
          size = 0;
      if (to > from) for (var i = 0, pos = 0; pos < to; i++) {
        var child = this.content[i],
            end = pos + child.nodeSize;

        if (end > from) {
          if (pos < from || end > to) {
            if (child.isText) child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));else child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));
          }

          result.push(child);
          size += child.nodeSize;
        }

        pos = end;
      }
      return new Fragment(result, size);
    }
  }, {
    key: "cutByIndex",
    value: function cutByIndex(from, to) {
      if (from == to) return Fragment.empty;
      if (from == 0 && to == this.content.length) return this;
      return new Fragment(this.content.slice(from, to));
    }
  }, {
    key: "replaceChild",
    value: function replaceChild(index, node) {
      var current = this.content[index];
      if (current == node) return this;
      var copy = this.content.slice();
      var size = this.size + node.nodeSize - current.nodeSize;
      copy[index] = node;
      return new Fragment(copy, size);
    }
  }, {
    key: "addToStart",
    value: function addToStart(node) {
      return new Fragment([node].concat(this.content), this.size + node.nodeSize);
    }
  }, {
    key: "addToEnd",
    value: function addToEnd(node) {
      return new Fragment(this.content.concat(node), this.size + node.nodeSize);
    }
  }, {
    key: "eq",
    value: function eq(other) {
      if (this.content.length != other.content.length) return false;

      for (var i = 0; i < this.content.length; i++) {
        if (!this.content[i].eq(other.content[i])) return false;
      }

      return true;
    }
  }, {
    key: "firstChild",
    get: function get() {
      return this.content.length ? this.content[0] : null;
    }
  }, {
    key: "lastChild",
    get: function get() {
      return this.content.length ? this.content[this.content.length - 1] : null;
    }
  }, {
    key: "childCount",
    get: function get() {
      return this.content.length;
    }
  }, {
    key: "child",
    value: function child(index) {
      var found = this.content[index];
      if (!found) throw new RangeError("Index " + index + " out of range for " + this);
      return found;
    }
  }, {
    key: "maybeChild",
    value: function maybeChild(index) {
      return this.content[index] || null;
    }
  }, {
    key: "forEach",
    value: function forEach(f) {
      for (var i = 0, p = 0; i < this.content.length; i++) {
        var child = this.content[i];
        f(child, p, i);
        p += child.nodeSize;
      }
    }
  }, {
    key: "findDiffStart",
    value: function findDiffStart(other) {
      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return _findDiffStart(this, other, pos);
    }
  }, {
    key: "findDiffEnd",
    value: function findDiffEnd(other) {
      var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;
      var otherPos = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : other.size;
      return _findDiffEnd(this, other, pos, otherPos);
    }
  }, {
    key: "findIndex",
    value: function findIndex(pos) {
      var round = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
      if (pos == 0) return retIndex(0, pos);
      if (pos == this.size) return retIndex(this.content.length, pos);
      if (pos > this.size || pos < 0) throw new RangeError("Position ".concat(pos, " outside of fragment (").concat(this, ")"));

      for (var i = 0, curPos = 0;; i++) {
        var cur = this.child(i),
            end = curPos + cur.nodeSize;

        if (end >= pos) {
          if (end == pos || round > 0) return retIndex(i + 1, end);
          return retIndex(i, curPos);
        }

        curPos = end;
      }
    }
  }, {
    key: "toString",
    value: function toString() {
      return "<" + this.toStringInner() + ">";
    }
  }, {
    key: "toStringInner",
    value: function toStringInner() {
      return this.content.join(", ");
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.content.length ? this.content.map(function (n) {
        return n.toJSON();
      }) : null;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, value) {
      if (!value) return Fragment.empty;
      if (!Array.isArray(value)) throw new RangeError("Invalid input for Fragment.fromJSON");
      return new Fragment(value.map(schema.nodeFromJSON));
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      if (!array.length) return Fragment.empty;
      var joined,
          size = 0;

      for (var i = 0; i < array.length; i++) {
        var node = array[i];
        size += node.nodeSize;

        if (i && node.isText && array[i - 1].sameMarkup(node)) {
          if (!joined) joined = array.slice(0, i);
          joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
        } else if (joined) {
          joined.push(node);
        }
      }

      return new Fragment(joined || array, size);
    }
  }, {
    key: "from",
    value: function from(nodes) {
      if (!nodes) return Fragment.empty;
      if (nodes instanceof Fragment) return nodes;
      if (Array.isArray(nodes)) return this.fromArray(nodes);
      if (nodes.attrs) return new Fragment([nodes], nodes.nodeSize);
      throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
    }
  }]);

  return Fragment;
}();

Fragment.empty = new Fragment([], 0);
var found = {
  index: 0,
  offset: 0
};

function retIndex(index, offset) {
  found.index = index;
  found.offset = offset;
  return found;
}

function compareDeep(a, b) {
  if (a === b) return true;
  if (!(a && _typeof(a) == "object") || !(b && _typeof(b) == "object")) return false;
  var array = Array.isArray(a);
  if (Array.isArray(b) != array) return false;

  if (array) {
    if (a.length != b.length) return false;

    for (var i = 0; i < a.length; i++) {
      if (!compareDeep(a[i], b[i])) return false;
    }
  } else {
    for (var p in a) {
      if (!(p in b) || !compareDeep(a[p], b[p])) return false;
    }

    for (var _p in b) {
      if (!(_p in a)) return false;
    }
  }

  return true;
}

var Mark = function () {
  function Mark(type, attrs) {
    _classCallCheck(this, Mark);

    this.type = type;
    this.attrs = attrs;
  }

  _createClass(Mark, [{
    key: "addToSet",
    value: function addToSet(set) {
      var copy,
          placed = false;

      for (var i = 0; i < set.length; i++) {
        var other = set[i];
        if (this.eq(other)) return set;

        if (this.type.excludes(other.type)) {
          if (!copy) copy = set.slice(0, i);
        } else if (other.type.excludes(this.type)) {
          return set;
        } else {
          if (!placed && other.type.rank > this.type.rank) {
            if (!copy) copy = set.slice(0, i);
            copy.push(this);
            placed = true;
          }

          if (copy) copy.push(other);
        }
      }

      if (!copy) copy = set.slice();
      if (!placed) copy.push(this);
      return copy;
    }
  }, {
    key: "removeFromSet",
    value: function removeFromSet(set) {
      for (var i = 0; i < set.length; i++) {
        if (this.eq(set[i])) return set.slice(0, i).concat(set.slice(i + 1));
      }

      return set;
    }
  }, {
    key: "isInSet",
    value: function isInSet(set) {
      for (var i = 0; i < set.length; i++) {
        if (this.eq(set[i])) return true;
      }

      return false;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var obj = {
        type: this.type.name
      };

      for (var _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }

      return obj;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (!json) throw new RangeError("Invalid input for Mark.fromJSON");
      var type = schema.marks[json.type];
      if (!type) throw new RangeError("There is no mark type ".concat(json.type, " in this schema"));
      return type.create(json.attrs);
    }
  }, {
    key: "sameSet",
    value: function sameSet(a, b) {
      if (a == b) return true;
      if (a.length != b.length) return false;

      for (var i = 0; i < a.length; i++) {
        if (!a[i].eq(b[i])) return false;
      }

      return true;
    }
  }, {
    key: "setFrom",
    value: function setFrom(marks) {
      if (!marks || Array.isArray(marks) && marks.length == 0) return Mark.none;
      if (marks instanceof Mark) return [marks];
      var copy = marks.slice();
      copy.sort(function (a, b) {
        return a.type.rank - b.type.rank;
      });
      return copy;
    }
  }]);

  return Mark;
}();

Mark.none = [];

var ReplaceError = function (_Error) {
  _inherits(ReplaceError, _Error);

  var _super = _createSuper(ReplaceError);

  function ReplaceError() {
    _classCallCheck(this, ReplaceError);

    return _super.apply(this, arguments);
  }

  return _createClass(ReplaceError);
}(_wrapNativeSuper(Error));

var Slice = function () {
  function Slice(content, openStart, openEnd) {
    _classCallCheck(this, Slice);

    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }

  _createClass(Slice, [{
    key: "size",
    get: function get() {
      return this.content.size - this.openStart - this.openEnd;
    }
  }, {
    key: "insertAt",
    value: function insertAt(pos, fragment) {
      var content = insertInto(this.content, pos + this.openStart, fragment);
      return content && new Slice(content, this.openStart, this.openEnd);
    }
  }, {
    key: "removeBetween",
    value: function removeBetween(from, to) {
      return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.content + "(" + this.openStart + "," + this.openEnd + ")";
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      if (!this.content.size) return null;
      var json = {
        content: this.content.toJSON()
      };
      if (this.openStart > 0) json.openStart = this.openStart;
      if (this.openEnd > 0) json.openEnd = this.openEnd;
      return json;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (!json) return Slice.empty;
      var openStart = json.openStart || 0,
          openEnd = json.openEnd || 0;
      if (typeof openStart != "number" || typeof openEnd != "number") throw new RangeError("Invalid input for Slice.fromJSON");
      return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
    }
  }, {
    key: "maxOpen",
    value: function maxOpen(fragment) {
      var openIsolating = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var openStart = 0,
          openEnd = 0;

      for (var n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild) {
        openStart++;
      }

      for (var _n = fragment.lastChild; _n && !_n.isLeaf && (openIsolating || !_n.type.spec.isolating); _n = _n.lastChild) {
        openEnd++;
      }

      return new Slice(fragment, openStart, openEnd);
    }
  }]);

  return Slice;
}();

Slice.empty = new Slice(Fragment.empty, 0, 0);

function removeRange(content, from, to) {
  var _content$findIndex = content.findIndex(from),
      index = _content$findIndex.index,
      offset = _content$findIndex.offset,
      child = content.maybeChild(index);

  var _content$findIndex2 = content.findIndex(to),
      indexTo = _content$findIndex2.index,
      offsetTo = _content$findIndex2.offset;

  if (offset == from || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText) throw new RangeError("Removing non-flat range");
    return content.cut(0, from).append(content.cut(to));
  }

  if (index != indexTo) throw new RangeError("Removing non-flat range");
  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));
}

function insertInto(content, dist, insert, parent) {
  var _content$findIndex3 = content.findIndex(dist),
      index = _content$findIndex3.index,
      offset = _content$findIndex3.offset,
      child = content.maybeChild(index);

  if (offset == dist || child.isText) {
    if (parent && !parent.canReplace(index, index, insert)) return null;
    return content.cut(0, dist).append(insert).append(content.cut(dist));
  }

  var inner = insertInto(child.content, dist - offset - 1, insert);
  return inner && content.replaceChild(index, child.copy(inner));
}

function _replace($from, $to, slice) {
  if (slice.openStart > $from.depth) throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice.openStart != $to.depth - slice.openEnd) throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice, 0);
}

function replaceOuter($from, $to, slice, depth) {
  var index = $from.index(depth),
      node = $from.node(depth);

  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {
    var inner = replaceOuter($from, $to, slice, depth + 1);
    return node.copy(node.content.replaceChild(index, inner));
  } else if (!slice.content.size) {
    return close(node, replaceTwoWay($from, $to, depth));
  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {
    var parent = $from.parent,
        content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));
  } else {
    var _prepareSliceForRepla = prepareSliceForReplace(slice, $from),
        start = _prepareSliceForRepla.start,
        end = _prepareSliceForRepla.end;

    return close(node, replaceThreeWay($from, start, end, $to, depth));
  }
}

function checkJoin(main, sub) {
  if (!sub.type.compatibleContent(main.type)) throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
}

function joinable($before, $after, depth) {
  var node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node;
}

function addNode(child, target) {
  var last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last])) target[last] = child.withText(target[last].text + child.text);else target.push(child);
}

function addRange($start, $end, depth, target) {
  var node = ($end || $start).node(depth);
  var startIndex = 0,
      endIndex = $end ? $end.index(depth) : node.childCount;

  if ($start) {
    startIndex = $start.index(depth);

    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }

  for (var i = startIndex; i < endIndex; i++) {
    addNode(node.child(i), target);
  }

  if ($end && $end.depth == depth && $end.textOffset) addNode($end.nodeBefore, target);
}

function close(node, content) {
  node.type.checkContent(content);
  return node.copy(content);
}

function replaceThreeWay($from, $start, $end, $to, depth) {
  var openStart = $from.depth > depth && joinable($from, $start, depth + 1);
  var openEnd = $to.depth > depth && joinable($end, $to, depth + 1);
  var content = [];
  addRange(null, $from, depth, content);

  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart) addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd) addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }

  addRange($to, null, depth, content);
  return new Fragment(content);
}

function replaceTwoWay($from, $to, depth) {
  var content = [];
  addRange(null, $from, depth, content);

  if ($from.depth > depth) {
    var type = joinable($from, $to, depth + 1);
    addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);
  }

  addRange($to, null, depth, content);
  return new Fragment(content);
}

function prepareSliceForReplace(slice, $along) {
  var extra = $along.depth - slice.openStart,
      parent = $along.node(extra);
  var node = parent.copy(slice.content);

  for (var i = extra - 1; i >= 0; i--) {
    node = $along.node(i).copy(Fragment.from(node));
  }

  return {
    start: node.resolveNoCache(slice.openStart + extra),
    end: node.resolveNoCache(node.content.size - slice.openEnd - extra)
  };
}

var ResolvedPos = function () {
  function ResolvedPos(pos, path, parentOffset) {
    _classCallCheck(this, ResolvedPos);

    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }

  _createClass(ResolvedPos, [{
    key: "resolveDepth",
    value: function resolveDepth(val) {
      if (val == null) return this.depth;
      if (val < 0) return this.depth + val;
      return val;
    }
  }, {
    key: "parent",
    get: function get() {
      return this.node(this.depth);
    }
  }, {
    key: "doc",
    get: function get() {
      return this.node(0);
    }
  }, {
    key: "node",
    value: function node(depth) {
      return this.path[this.resolveDepth(depth) * 3];
    }
  }, {
    key: "index",
    value: function index(depth) {
      return this.path[this.resolveDepth(depth) * 3 + 1];
    }
  }, {
    key: "indexAfter",
    value: function indexAfter(depth) {
      depth = this.resolveDepth(depth);
      return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
    }
  }, {
    key: "start",
    value: function start(depth) {
      depth = this.resolveDepth(depth);
      return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    }
  }, {
    key: "end",
    value: function end(depth) {
      depth = this.resolveDepth(depth);
      return this.start(depth) + this.node(depth).content.size;
    }
  }, {
    key: "before",
    value: function before(depth) {
      depth = this.resolveDepth(depth);
      if (!depth) throw new RangeError("There is no position before the top-level node");
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
    }
  }, {
    key: "after",
    value: function after(depth) {
      depth = this.resolveDepth(depth);
      if (!depth) throw new RangeError("There is no position after the top-level node");
      return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
    }
  }, {
    key: "textOffset",
    get: function get() {
      return this.pos - this.path[this.path.length - 1];
    }
  }, {
    key: "nodeAfter",
    get: function get() {
      var parent = this.parent,
          index = this.index(this.depth);
      if (index == parent.childCount) return null;
      var dOff = this.pos - this.path[this.path.length - 1],
          child = parent.child(index);
      return dOff ? parent.child(index).cut(dOff) : child;
    }
  }, {
    key: "nodeBefore",
    get: function get() {
      var index = this.index(this.depth);
      var dOff = this.pos - this.path[this.path.length - 1];
      if (dOff) return this.parent.child(index).cut(0, dOff);
      return index == 0 ? null : this.parent.child(index - 1);
    }
  }, {
    key: "posAtIndex",
    value: function posAtIndex(index, depth) {
      depth = this.resolveDepth(depth);
      var node = this.path[depth * 3],
          pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;

      for (var i = 0; i < index; i++) {
        pos += node.child(i).nodeSize;
      }

      return pos;
    }
  }, {
    key: "marks",
    value: function marks() {
      var parent = this.parent,
          index = this.index();
      if (parent.content.size == 0) return Mark.none;
      if (this.textOffset) return parent.child(index).marks;
      var main = parent.maybeChild(index - 1),
          other = parent.maybeChild(index);

      if (!main) {
        var tmp = main;
        main = other;
        other = tmp;
      }

      var marks = main.marks;

      for (var i = 0; i < marks.length; i++) {
        if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks))) marks = marks[i--].removeFromSet(marks);
      }

      return marks;
    }
  }, {
    key: "marksAcross",
    value: function marksAcross($end) {
      var after = this.parent.maybeChild(this.index());
      if (!after || !after.isInline) return null;
      var marks = after.marks,
          next = $end.parent.maybeChild($end.index());

      for (var i = 0; i < marks.length; i++) {
        if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks))) marks = marks[i--].removeFromSet(marks);
      }

      return marks;
    }
  }, {
    key: "sharedDepth",
    value: function sharedDepth(pos) {
      for (var depth = this.depth; depth > 0; depth--) {
        if (this.start(depth) <= pos && this.end(depth) >= pos) return depth;
      }

      return 0;
    }
  }, {
    key: "blockRange",
    value: function blockRange() {
      var other = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;
      var pred = arguments.length > 1 ? arguments[1] : undefined;
      if (other.pos < this.pos) return other.blockRange(this);

      for (var d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--) {
        if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) return new NodeRange(this, other, d);
      }

      return null;
    }
  }, {
    key: "sameParent",
    value: function sameParent(other) {
      return this.pos - this.parentOffset == other.pos - other.parentOffset;
    }
  }, {
    key: "max",
    value: function max(other) {
      return other.pos > this.pos ? other : this;
    }
  }, {
    key: "min",
    value: function min(other) {
      return other.pos < this.pos ? other : this;
    }
  }, {
    key: "toString",
    value: function toString() {
      var str = "";

      for (var i = 1; i <= this.depth; i++) {
        str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
      }

      return str + ":" + this.parentOffset;
    }
  }], [{
    key: "resolve",
    value: function resolve(doc, pos) {
      if (!(pos >= 0 && pos <= doc.content.size)) throw new RangeError("Position " + pos + " out of range");
      var path = [];
      var start = 0,
          parentOffset = pos;

      for (var node = doc;;) {
        var _node$content$findInd = node.content.findIndex(parentOffset),
            index = _node$content$findInd.index,
            offset = _node$content$findInd.offset;

        var rem = parentOffset - offset;
        path.push(node, index, start + offset);
        if (!rem) break;
        node = node.child(index);
        if (node.isText) break;
        parentOffset = rem - 1;
        start += offset + 1;
      }

      return new ResolvedPos(pos, path, parentOffset);
    }
  }, {
    key: "resolveCached",
    value: function resolveCached(doc, pos) {
      for (var i = 0; i < resolveCache.length; i++) {
        var cached = resolveCache[i];
        if (cached.pos == pos && cached.doc == doc) return cached;
      }

      var result = resolveCache[resolveCachePos] = ResolvedPos.resolve(doc, pos);
      resolveCachePos = (resolveCachePos + 1) % resolveCacheSize;
      return result;
    }
  }]);

  return ResolvedPos;
}();

var resolveCache = [],
    resolveCachePos = 0,
    resolveCacheSize = 12;

var NodeRange = function () {
  function NodeRange($from, $to, depth) {
    _classCallCheck(this, NodeRange);

    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }

  _createClass(NodeRange, [{
    key: "start",
    get: function get() {
      return this.$from.before(this.depth + 1);
    }
  }, {
    key: "end",
    get: function get() {
      return this.$to.after(this.depth + 1);
    }
  }, {
    key: "parent",
    get: function get() {
      return this.$from.node(this.depth);
    }
  }, {
    key: "startIndex",
    get: function get() {
      return this.$from.index(this.depth);
    }
  }, {
    key: "endIndex",
    get: function get() {
      return this.$to.indexAfter(this.depth);
    }
  }]);

  return NodeRange;
}();

var emptyAttrs = Object.create(null);

var Node = function () {
  function Node(type, attrs, content) {
    var marks = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Mark.none;

    _classCallCheck(this, Node);

    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.content = content || Fragment.empty;
  }

  _createClass(Node, [{
    key: "nodeSize",
    get: function get() {
      return this.isLeaf ? 1 : 2 + this.content.size;
    }
  }, {
    key: "childCount",
    get: function get() {
      return this.content.childCount;
    }
  }, {
    key: "child",
    value: function child(index) {
      return this.content.child(index);
    }
  }, {
    key: "maybeChild",
    value: function maybeChild(index) {
      return this.content.maybeChild(index);
    }
  }, {
    key: "forEach",
    value: function forEach(f) {
      this.content.forEach(f);
    }
  }, {
    key: "nodesBetween",
    value: function nodesBetween(from, to, f) {
      var startPos = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      this.content.nodesBetween(from, to, f, startPos, this);
    }
  }, {
    key: "descendants",
    value: function descendants(f) {
      this.nodesBetween(0, this.content.size, f);
    }
  }, {
    key: "textContent",
    get: function get() {
      return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
    }
  }, {
    key: "textBetween",
    value: function textBetween(from, to, blockSeparator, leafText) {
      return this.content.textBetween(from, to, blockSeparator, leafText);
    }
  }, {
    key: "firstChild",
    get: function get() {
      return this.content.firstChild;
    }
  }, {
    key: "lastChild",
    get: function get() {
      return this.content.lastChild;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this == other || this.sameMarkup(other) && this.content.eq(other.content);
    }
  }, {
    key: "sameMarkup",
    value: function sameMarkup(other) {
      return this.hasMarkup(other.type, other.attrs, other.marks);
    }
  }, {
    key: "hasMarkup",
    value: function hasMarkup(type, attrs, marks) {
      return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
    }
  }, {
    key: "copy",
    value: function copy() {
      var content = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      if (content == this.content) return this;
      return new Node(this.type, this.attrs, content, this.marks);
    }
  }, {
    key: "mark",
    value: function mark(marks) {
      return marks == this.marks ? this : new Node(this.type, this.attrs, this.content, marks);
    }
  }, {
    key: "cut",
    value: function cut(from) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.content.size;
      if (from == 0 && to == this.content.size) return this;
      return this.copy(this.content.cut(from, to));
    }
  }, {
    key: "slice",
    value: function slice(from) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.content.size;
      var includeParents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (from == to) return Slice.empty;
      var $from = this.resolve(from),
          $to = this.resolve(to);
      var depth = includeParents ? 0 : $from.sharedDepth(to);
      var start = $from.start(depth),
          node = $from.node(depth);
      var content = node.content.cut($from.pos - start, $to.pos - start);
      return new Slice(content, $from.depth - depth, $to.depth - depth);
    }
  }, {
    key: "replace",
    value: function replace(from, to, slice) {
      return _replace(this.resolve(from), this.resolve(to), slice);
    }
  }, {
    key: "nodeAt",
    value: function nodeAt(pos) {
      for (var node = this;;) {
        var _node$content$findInd2 = node.content.findIndex(pos),
            index = _node$content$findInd2.index,
            offset = _node$content$findInd2.offset;

        node = node.maybeChild(index);
        if (!node) return null;
        if (offset == pos || node.isText) return node;
        pos -= offset + 1;
      }
    }
  }, {
    key: "childAfter",
    value: function childAfter(pos) {
      var _this$content$findInd = this.content.findIndex(pos),
          index = _this$content$findInd.index,
          offset = _this$content$findInd.offset;

      return {
        node: this.content.maybeChild(index),
        index: index,
        offset: offset
      };
    }
  }, {
    key: "childBefore",
    value: function childBefore(pos) {
      if (pos == 0) return {
        node: null,
        index: 0,
        offset: 0
      };

      var _this$content$findInd2 = this.content.findIndex(pos),
          index = _this$content$findInd2.index,
          offset = _this$content$findInd2.offset;

      if (offset < pos) return {
        node: this.content.child(index),
        index: index,
        offset: offset
      };
      var node = this.content.child(index - 1);
      return {
        node: node,
        index: index - 1,
        offset: offset - node.nodeSize
      };
    }
  }, {
    key: "resolve",
    value: function resolve(pos) {
      return ResolvedPos.resolveCached(this, pos);
    }
  }, {
    key: "resolveNoCache",
    value: function resolveNoCache(pos) {
      return ResolvedPos.resolve(this, pos);
    }
  }, {
    key: "rangeHasMark",
    value: function rangeHasMark(from, to, type) {
      var found = false;
      if (to > from) this.nodesBetween(from, to, function (node) {
        if (type.isInSet(node.marks)) found = true;
        return !found;
      });
      return found;
    }
  }, {
    key: "isBlock",
    get: function get() {
      return this.type.isBlock;
    }
  }, {
    key: "isTextblock",
    get: function get() {
      return this.type.isTextblock;
    }
  }, {
    key: "inlineContent",
    get: function get() {
      return this.type.inlineContent;
    }
  }, {
    key: "isInline",
    get: function get() {
      return this.type.isInline;
    }
  }, {
    key: "isText",
    get: function get() {
      return this.type.isText;
    }
  }, {
    key: "isLeaf",
    get: function get() {
      return this.type.isLeaf;
    }
  }, {
    key: "isAtom",
    get: function get() {
      return this.type.isAtom;
    }
  }, {
    key: "toString",
    value: function toString() {
      if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);
      var name = this.type.name;
      if (this.content.size) name += "(" + this.content.toStringInner() + ")";
      return wrapMarks(this.marks, name);
    }
  }, {
    key: "contentMatchAt",
    value: function contentMatchAt(index) {
      var match = this.type.contentMatch.matchFragment(this.content, 0, index);
      if (!match) throw new Error("Called contentMatchAt on a node with invalid content");
      return match;
    }
  }, {
    key: "canReplace",
    value: function canReplace(from, to) {
      var replacement = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Fragment.empty;
      var start = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var end = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : replacement.childCount;
      var one = this.contentMatchAt(from).matchFragment(replacement, start, end);
      var two = one && one.matchFragment(this.content, to);
      if (!two || !two.validEnd) return false;

      for (var i = start; i < end; i++) {
        if (!this.type.allowsMarks(replacement.child(i).marks)) return false;
      }

      return true;
    }
  }, {
    key: "canReplaceWith",
    value: function canReplaceWith(from, to, type, marks) {
      if (marks && !this.type.allowsMarks(marks)) return false;
      var start = this.contentMatchAt(from).matchType(type);
      var end = start && start.matchFragment(this.content, to);
      return end ? end.validEnd : false;
    }
  }, {
    key: "canAppend",
    value: function canAppend(other) {
      if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content);else return this.type.compatibleContent(other.type);
    }
  }, {
    key: "check",
    value: function check() {
      this.type.checkContent(this.content);
      var copy = Mark.none;

      for (var i = 0; i < this.marks.length; i++) {
        copy = this.marks[i].addToSet(copy);
      }

      if (!Mark.sameSet(copy, this.marks)) throw new RangeError("Invalid collection of marks for node ".concat(this.type.name, ": ").concat(this.marks.map(function (m) {
        return m.type.name;
      })));
      this.content.forEach(function (node) {
        return node.check();
      });
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var obj = {
        type: this.type.name
      };

      for (var _ in this.attrs) {
        obj.attrs = this.attrs;
        break;
      }

      if (this.content.size) obj.content = this.content.toJSON();
      if (this.marks.length) obj.marks = this.marks.map(function (n) {
        return n.toJSON();
      });
      return obj;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (!json) throw new RangeError("Invalid input for Node.fromJSON");
      var marks = null;

      if (json.marks) {
        if (!Array.isArray(json.marks)) throw new RangeError("Invalid mark data for Node.fromJSON");
        marks = json.marks.map(schema.markFromJSON);
      }

      if (json.type == "text") {
        if (typeof json.text != "string") throw new RangeError("Invalid text node in JSON");
        return schema.text(json.text, marks);
      }

      var content = Fragment.fromJSON(schema, json.content);
      return schema.nodeType(json.type).create(json.attrs, content, marks);
    }
  }]);

  return Node;
}();

Node.prototype.text = undefined;

var TextNode = function (_Node) {
  _inherits(TextNode, _Node);

  var _super2 = _createSuper(TextNode);

  function TextNode(type, attrs, content, marks) {
    var _this;

    _classCallCheck(this, TextNode);

    _this = _super2.call(this, type, attrs, null, marks);
    if (!content) throw new RangeError("Empty text nodes are not allowed");
    _this.text = content;
    return _this;
  }

  _createClass(TextNode, [{
    key: "toString",
    value: function toString() {
      if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);
      return wrapMarks(this.marks, JSON.stringify(this.text));
    }
  }, {
    key: "textContent",
    get: function get() {
      return this.text;
    }
  }, {
    key: "textBetween",
    value: function textBetween(from, to) {
      return this.text.slice(from, to);
    }
  }, {
    key: "nodeSize",
    get: function get() {
      return this.text.length;
    }
  }, {
    key: "mark",
    value: function mark(marks) {
      return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);
    }
  }, {
    key: "withText",
    value: function withText(text) {
      if (text == this.text) return this;
      return new TextNode(this.type, this.attrs, text, this.marks);
    }
  }, {
    key: "cut",
    value: function cut() {
      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.text.length;
      if (from == 0 && to == this.text.length) return this;
      return this.withText(this.text.slice(from, to));
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this.sameMarkup(other) && this.text == other.text;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var base = _get(_getPrototypeOf(TextNode.prototype), "toJSON", this).call(this);

      base.text = this.text;
      return base;
    }
  }]);

  return TextNode;
}(Node);

function wrapMarks(marks, str) {
  for (var i = marks.length - 1; i >= 0; i--) {
    str = marks[i].type.name + "(" + str + ")";
  }

  return str;
}

var ContentMatch = function () {
  function ContentMatch(validEnd) {
    _classCallCheck(this, ContentMatch);

    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }

  _createClass(ContentMatch, [{
    key: "matchType",
    value: function matchType(type) {
      for (var i = 0; i < this.next.length; i++) {
        if (this.next[i].type == type) return this.next[i].next;
      }

      return null;
    }
  }, {
    key: "matchFragment",
    value: function matchFragment(frag) {
      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : frag.childCount;
      var cur = this;

      for (var i = start; cur && i < end; i++) {
        cur = cur.matchType(frag.child(i).type);
      }

      return cur;
    }
  }, {
    key: "inlineContent",
    get: function get() {
      return this.next.length != 0 && this.next[0].type.isInline;
    }
  }, {
    key: "defaultType",
    get: function get() {
      for (var i = 0; i < this.next.length; i++) {
        var type = this.next[i].type;
        if (!(type.isText || type.hasRequiredAttrs())) return type;
      }

      return null;
    }
  }, {
    key: "compatible",
    value: function compatible(other) {
      for (var i = 0; i < this.next.length; i++) {
        for (var j = 0; j < other.next.length; j++) {
          if (this.next[i].type == other.next[j].type) return true;
        }
      }

      return false;
    }
  }, {
    key: "fillBefore",
    value: function fillBefore(after) {
      var toEnd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var seen = [this];

      function search(match, types) {
        var finished = match.matchFragment(after, startIndex);
        if (finished && (!toEnd || finished.validEnd)) return Fragment.from(types.map(function (tp) {
          return tp.createAndFill();
        }));

        for (var i = 0; i < match.next.length; i++) {
          var _match$next$i = match.next[i],
              type = _match$next$i.type,
              next = _match$next$i.next;

          if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
            seen.push(next);

            var _found = search(next, types.concat(type));

            if (_found) return _found;
          }
        }

        return null;
      }

      return search(this, []);
    }
  }, {
    key: "findWrapping",
    value: function findWrapping(target) {
      for (var i = 0; i < this.wrapCache.length; i += 2) {
        if (this.wrapCache[i] == target) return this.wrapCache[i + 1];
      }

      var computed = this.computeWrapping(target);
      this.wrapCache.push(target, computed);
      return computed;
    }
  }, {
    key: "computeWrapping",
    value: function computeWrapping(target) {
      var seen = Object.create(null),
          active = [{
        match: this,
        type: null,
        via: null
      }];

      while (active.length) {
        var current = active.shift(),
            match = current.match;

        if (match.matchType(target)) {
          var result = [];

          for (var obj = current; obj.type; obj = obj.via) {
            result.push(obj.type);
          }

          return result.reverse();
        }

        for (var i = 0; i < match.next.length; i++) {
          var _match$next$i2 = match.next[i],
              type = _match$next$i2.type,
              next = _match$next$i2.next;

          if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {
            active.push({
              match: type.contentMatch,
              type: type,
              via: current
            });
            seen[type.name] = true;
          }
        }
      }

      return null;
    }
  }, {
    key: "edgeCount",
    get: function get() {
      return this.next.length;
    }
  }, {
    key: "edge",
    value: function edge(n) {
      if (n >= this.next.length) throw new RangeError("There's no ".concat(n, "th edge in this content match"));
      return this.next[n];
    }
  }, {
    key: "toString",
    value: function toString() {
      var seen = [];

      function scan(m) {
        seen.push(m);

        for (var i = 0; i < m.next.length; i++) {
          if (seen.indexOf(m.next[i].next) == -1) scan(m.next[i].next);
        }
      }

      scan(this);
      return seen.map(function (m, i) {
        var out = i + (m.validEnd ? "*" : " ") + " ";

        for (var _i = 0; _i < m.next.length; _i++) {
          out += (_i ? ", " : "") + m.next[_i].type.name + "->" + seen.indexOf(m.next[_i].next);
        }

        return out;
      }).join("\n");
    }
  }], [{
    key: "parse",
    value: function parse(string, nodeTypes) {
      var stream = new TokenStream(string, nodeTypes);
      if (stream.next == null) return ContentMatch.empty;
      var expr = parseExpr(stream);
      if (stream.next) stream.err("Unexpected trailing text");
      var match = dfa(nfa(expr));
      checkForDeadEnds(match, stream);
      return match;
    }
  }]);

  return ContentMatch;
}();

ContentMatch.empty = new ContentMatch(true);

var TokenStream = function () {
  function TokenStream(string, nodeTypes) {
    _classCallCheck(this, TokenStream);

    this.string = string;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "") this.tokens.pop();
    if (this.tokens[0] == "") this.tokens.shift();
  }

  _createClass(TokenStream, [{
    key: "next",
    get: function get() {
      return this.tokens[this.pos];
    }
  }, {
    key: "eat",
    value: function eat(tok) {
      return this.next == tok && (this.pos++ || true);
    }
  }, {
    key: "err",
    value: function err(str) {
      throw new SyntaxError(str + " (in content expression '" + this.string + "')");
    }
  }]);

  return TokenStream;
}();

function parseExpr(stream) {
  var exprs = [];

  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));

  return exprs.length == 1 ? exprs[0] : {
    type: "choice",
    exprs: exprs
  };
}

function parseExprSeq(stream) {
  var exprs = [];

  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");

  return exprs.length == 1 ? exprs[0] : {
    type: "seq",
    exprs: exprs
  };
}

function parseExprSubscript(stream) {
  var expr = parseExprAtom(stream);

  for (;;) {
    if (stream.eat("+")) expr = {
      type: "plus",
      expr: expr
    };else if (stream.eat("*")) expr = {
      type: "star",
      expr: expr
    };else if (stream.eat("?")) expr = {
      type: "opt",
      expr: expr
    };else if (stream.eat("{")) expr = parseExprRange(stream, expr);else break;
  }

  return expr;
}

function parseNum(stream) {
  if (/\D/.test(stream.next)) stream.err("Expected number, got '" + stream.next + "'");
  var result = Number(stream.next);
  stream.pos++;
  return result;
}

function parseExprRange(stream, expr) {
  var min = parseNum(stream),
      max = min;

  if (stream.eat(",")) {
    if (stream.next != "}") max = parseNum(stream);else max = -1;
  }

  if (!stream.eat("}")) stream.err("Unclosed braced range");
  return {
    type: "range",
    min: min,
    max: max,
    expr: expr
  };
}

function resolveName(stream, name) {
  var types = stream.nodeTypes,
      type = types[name];
  if (type) return [type];
  var result = [];

  for (var typeName in types) {
    var _type = types[typeName];
    if (_type.groups.indexOf(name) > -1) result.push(_type);
  }

  if (result.length == 0) stream.err("No node type or group '" + name + "' found");
  return result;
}

function parseExprAtom(stream) {
  if (stream.eat("(")) {
    var expr = parseExpr(stream);
    if (!stream.eat(")")) stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    var exprs = resolveName(stream, stream.next).map(function (type) {
      if (stream.inline == null) stream.inline = type.isInline;else if (stream.inline != type.isInline) stream.err("Mixing inline and block content");
      return {
        type: "name",
        value: type
      };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : {
      type: "choice",
      exprs: exprs
    };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}

function nfa(expr) {
  var nfa = [[]];
  connect(compile(expr, 0), node());
  return nfa;

  function node() {
    return nfa.push([]) - 1;
  }

  function edge(from, to, term) {
    var edge = {
      term: term,
      to: to
    };
    nfa[from].push(edge);
    return edge;
  }

  function connect(edges, to) {
    edges.forEach(function (edge) {
      return edge.to = to;
    });
  }

  function compile(expr, from) {
    if (expr.type == "choice") {
      return expr.exprs.reduce(function (out, expr) {
        return out.concat(compile(expr, from));
      }, []);
    } else if (expr.type == "seq") {
      for (var i = 0;; i++) {
        var next = compile(expr.exprs[i], from);
        if (i == expr.exprs.length - 1) return next;
        connect(next, from = node());
      }
    } else if (expr.type == "star") {
      var loop = node();
      edge(from, loop);
      connect(compile(expr.expr, loop), loop);
      return [edge(loop)];
    } else if (expr.type == "plus") {
      var _loop = node();

      connect(compile(expr.expr, from), _loop);
      connect(compile(expr.expr, _loop), _loop);
      return [edge(_loop)];
    } else if (expr.type == "opt") {
      return [edge(from)].concat(compile(expr.expr, from));
    } else if (expr.type == "range") {
      var cur = from;

      for (var _i2 = 0; _i2 < expr.min; _i2++) {
        var _next = node();

        connect(compile(expr.expr, cur), _next);
        cur = _next;
      }

      if (expr.max == -1) {
        connect(compile(expr.expr, cur), cur);
      } else {
        for (var _i3 = expr.min; _i3 < expr.max; _i3++) {
          var _next2 = node();

          edge(cur, _next2);
          connect(compile(expr.expr, cur), _next2);
          cur = _next2;
        }
      }

      return [edge(cur)];
    } else if (expr.type == "name") {
      return [edge(from, undefined, expr.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}

function cmp(a, b) {
  return b - a;
}

function nullFrom(nfa, node) {
  var result = [];
  scan(node);
  return result.sort(cmp);

  function scan(node) {
    var edges = nfa[node];
    if (edges.length == 1 && !edges[0].term) return scan(edges[0].to);
    result.push(node);

    for (var i = 0; i < edges.length; i++) {
      var _edges$i = edges[i],
          term = _edges$i.term,
          to = _edges$i.to;
      if (!term && result.indexOf(to) == -1) scan(to);
    }
  }
}

function dfa(nfa) {
  var labeled = Object.create(null);
  return explore(nullFrom(nfa, 0));

  function explore(states) {
    var out = [];
    states.forEach(function (node) {
      nfa[node].forEach(function (_ref) {
        var term = _ref.term,
            to = _ref.to;
        if (!term) return;
        var set;

        for (var i = 0; i < out.length; i++) {
          if (out[i][0] == term) set = out[i][1];
        }

        nullFrom(nfa, to).forEach(function (node) {
          if (!set) out.push([term, set = []]);
          if (set.indexOf(node) == -1) set.push(node);
        });
      });
    });
    var state = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);

    for (var i = 0; i < out.length; i++) {
      var _states = out[i][1].sort(cmp);

      state.next.push({
        type: out[i][0],
        next: labeled[_states.join(",")] || explore(_states)
      });
    }

    return state;
  }
}

function checkForDeadEnds(match, stream) {
  for (var i = 0, work = [match]; i < work.length; i++) {
    var state = work[i],
        dead = !state.validEnd,
        nodes = [];

    for (var j = 0; j < state.next.length; j++) {
      var _state$next$j = state.next[j],
          type = _state$next$j.type,
          next = _state$next$j.next;
      nodes.push(type.name);
      if (dead && !(type.isText || type.hasRequiredAttrs())) dead = false;
      if (work.indexOf(next) == -1) work.push(next);
    }

    if (dead) stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}

function defaultAttrs(attrs) {
  var defaults = Object.create(null);

  for (var attrName in attrs) {
    var attr = attrs[attrName];
    if (!attr.hasDefault) return null;
    defaults[attrName] = attr["default"];
  }

  return defaults;
}

function _computeAttrs(attrs, value) {
  var built = Object.create(null);

  for (var name in attrs) {
    var given = value && value[name];

    if (given === undefined) {
      var attr = attrs[name];
      if (attr.hasDefault) given = attr["default"];else throw new RangeError("No value supplied for attribute " + name);
    }

    built[name] = given;
  }

  return built;
}

function initAttrs(attrs) {
  var result = Object.create(null);
  if (attrs) for (var name in attrs) {
    result[name] = new Attribute(attrs[name]);
  }
  return result;
}

var NodeType = function () {
  function NodeType(name, schema, spec) {
    _classCallCheck(this, NodeType);

    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }

  _createClass(NodeType, [{
    key: "isInline",
    get: function get() {
      return !this.isBlock;
    }
  }, {
    key: "isTextblock",
    get: function get() {
      return this.isBlock && this.inlineContent;
    }
  }, {
    key: "isLeaf",
    get: function get() {
      return this.contentMatch == ContentMatch.empty;
    }
  }, {
    key: "isAtom",
    get: function get() {
      return this.isLeaf || !!this.spec.atom;
    }
  }, {
    key: "whitespace",
    get: function get() {
      return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
    }
  }, {
    key: "hasRequiredAttrs",
    value: function hasRequiredAttrs() {
      for (var n in this.attrs) {
        if (this.attrs[n].isRequired) return true;
      }

      return false;
    }
  }, {
    key: "compatibleContent",
    value: function compatibleContent(other) {
      return this == other || this.contentMatch.compatible(other.contentMatch);
    }
  }, {
    key: "computeAttrs",
    value: function computeAttrs(attrs) {
      if (!attrs && this.defaultAttrs) return this.defaultAttrs;else return _computeAttrs(this.attrs, attrs);
    }
  }, {
    key: "create",
    value: function create() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var content = arguments.length > 1 ? arguments[1] : undefined;
      var marks = arguments.length > 2 ? arguments[2] : undefined;
      if (this.isText) throw new Error("NodeType.create can't construct text nodes");
      return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));
    }
  }, {
    key: "createChecked",
    value: function createChecked() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var content = arguments.length > 1 ? arguments[1] : undefined;
      var marks = arguments.length > 2 ? arguments[2] : undefined;
      content = Fragment.from(content);
      this.checkContent(content);
      return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
    }
  }, {
    key: "createAndFill",
    value: function createAndFill() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var content = arguments.length > 1 ? arguments[1] : undefined;
      var marks = arguments.length > 2 ? arguments[2] : undefined;
      attrs = this.computeAttrs(attrs);
      content = Fragment.from(content);

      if (content.size) {
        var before = this.contentMatch.fillBefore(content);
        if (!before) return null;
        content = before.append(content);
      }

      var matched = this.contentMatch.matchFragment(content);
      var after = matched && matched.fillBefore(Fragment.empty, true);
      if (!after) return null;
      return new Node(this, attrs, content.append(after), Mark.setFrom(marks));
    }
  }, {
    key: "validContent",
    value: function validContent(content) {
      var result = this.contentMatch.matchFragment(content);
      if (!result || !result.validEnd) return false;

      for (var i = 0; i < content.childCount; i++) {
        if (!this.allowsMarks(content.child(i).marks)) return false;
      }

      return true;
    }
  }, {
    key: "checkContent",
    value: function checkContent(content) {
      if (!this.validContent(content)) throw new RangeError("Invalid content for node ".concat(this.name, ": ").concat(content.toString().slice(0, 50)));
    }
  }, {
    key: "allowsMarkType",
    value: function allowsMarkType(markType) {
      return this.markSet == null || this.markSet.indexOf(markType) > -1;
    }
  }, {
    key: "allowsMarks",
    value: function allowsMarks(marks) {
      if (this.markSet == null) return true;

      for (var i = 0; i < marks.length; i++) {
        if (!this.allowsMarkType(marks[i].type)) return false;
      }

      return true;
    }
  }, {
    key: "allowedMarks",
    value: function allowedMarks(marks) {
      if (this.markSet == null) return marks;
      var copy;

      for (var i = 0; i < marks.length; i++) {
        if (!this.allowsMarkType(marks[i].type)) {
          if (!copy) copy = marks.slice(0, i);
        } else if (copy) {
          copy.push(marks[i]);
        }
      }

      return !copy ? marks : copy.length ? copy : Mark.none;
    }
  }], [{
    key: "compile",
    value: function compile(nodes, schema) {
      var result = Object.create(null);
      nodes.forEach(function (name, spec) {
        return result[name] = new NodeType(name, schema, spec);
      });
      var topType = schema.spec.topNode || "doc";
      if (!result[topType]) throw new RangeError("Schema is missing its top node type ('" + topType + "')");
      if (!result.text) throw new RangeError("Every schema needs a 'text' type");

      for (var _ in result.text.attrs) {
        throw new RangeError("The text node type should not have attributes");
      }

      return result;
    }
  }]);

  return NodeType;
}();

var Attribute = function () {
  function Attribute(options) {
    _classCallCheck(this, Attribute);

    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this["default"] = options["default"];
  }

  _createClass(Attribute, [{
    key: "isRequired",
    get: function get() {
      return !this.hasDefault;
    }
  }]);

  return Attribute;
}();

var MarkType = function () {
  function MarkType(name, rank, schema, spec) {
    _classCallCheck(this, MarkType);

    this.name = name;
    this.rank = rank;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(spec.attrs);
    this.excluded = null;
    var defaults = defaultAttrs(this.attrs);
    this.instance = defaults ? new Mark(this, defaults) : null;
  }

  _createClass(MarkType, [{
    key: "create",
    value: function create() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      if (!attrs && this.instance) return this.instance;
      return new Mark(this, _computeAttrs(this.attrs, attrs));
    }
  }, {
    key: "removeFromSet",
    value: function removeFromSet(set) {
      for (var i = 0; i < set.length; i++) {
        if (set[i].type == this) {
          set = set.slice(0, i).concat(set.slice(i + 1));
          i--;
        }
      }

      return set;
    }
  }, {
    key: "isInSet",
    value: function isInSet(set) {
      for (var i = 0; i < set.length; i++) {
        if (set[i].type == this) return set[i];
      }
    }
  }, {
    key: "excludes",
    value: function excludes(other) {
      return this.excluded.indexOf(other) > -1;
    }
  }], [{
    key: "compile",
    value: function compile(marks, schema) {
      var result = Object.create(null),
          rank = 0;
      marks.forEach(function (name, spec) {
        return result[name] = new MarkType(name, rank++, schema, spec);
      });
      return result;
    }
  }]);

  return MarkType;
}();

var Schema = function () {
  function Schema(spec) {
    _classCallCheck(this, Schema);

    this.cached = Object.create(null);
    var instanceSpec = this.spec = {};

    for (var prop in spec) {
      instanceSpec[prop] = spec[prop];
    }

    instanceSpec.nodes = OrderedMap__default["default"].from(spec.nodes), instanceSpec.marks = OrderedMap__default["default"].from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    var contentExprCache = Object.create(null);

    for (var _prop in this.nodes) {
      if (_prop in this.marks) throw new RangeError(_prop + " can not be both a node and a mark");
      var type = this.nodes[_prop],
          contentExpr = type.spec.content || "",
          markExpr = type.spec.marks;
      type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type.inlineContent = type.contentMatch.inlineContent;
      type.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type.inlineContent ? [] : null;
    }

    for (var _prop2 in this.marks) {
      var _type2 = this.marks[_prop2],
          excl = _type2.spec.excludes;
      _type2.excluded = excl == null ? [_type2] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }

    this.nodeFromJSON = this.nodeFromJSON.bind(this);
    this.markFromJSON = this.markFromJSON.bind(this);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = Object.create(null);
  }

  _createClass(Schema, [{
    key: "node",
    value: function node(type) {
      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var content = arguments.length > 2 ? arguments[2] : undefined;
      var marks = arguments.length > 3 ? arguments[3] : undefined;
      if (typeof type == "string") type = this.nodeType(type);else if (!(type instanceof NodeType)) throw new RangeError("Invalid node type: " + type);else if (type.schema != this) throw new RangeError("Node type from different schema used (" + type.name + ")");
      return type.createChecked(attrs, content, marks);
    }
  }, {
    key: "text",
    value: function text(_text, marks) {
      var type = this.nodes.text;
      return new TextNode(type, type.defaultAttrs, _text, Mark.setFrom(marks));
    }
  }, {
    key: "mark",
    value: function mark(type, attrs) {
      if (typeof type == "string") type = this.marks[type];
      return type.create(attrs);
    }
  }, {
    key: "nodeFromJSON",
    value: function nodeFromJSON(json) {
      return Node.fromJSON(this, json);
    }
  }, {
    key: "markFromJSON",
    value: function markFromJSON(json) {
      return Mark.fromJSON(this, json);
    }
  }, {
    key: "nodeType",
    value: function nodeType(name) {
      var found = this.nodes[name];
      if (!found) throw new RangeError("Unknown node type: " + name);
      return found;
    }
  }]);

  return Schema;
}();

function gatherMarks(schema, marks) {
  var found = [];

  for (var i = 0; i < marks.length; i++) {
    var name = marks[i],
        mark = schema.marks[name],
        ok = mark;

    if (mark) {
      found.push(mark);
    } else {
      for (var prop in schema.marks) {
        var _mark = schema.marks[prop];
        if (name == "_" || _mark.spec.group && _mark.spec.group.split(" ").indexOf(name) > -1) found.push(ok = _mark);
      }
    }

    if (!ok) throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
  }

  return found;
}

var DOMParser = function () {
  function DOMParser(schema, rules) {
    var _this2 = this;

    _classCallCheck(this, DOMParser);

    this.schema = schema;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    rules.forEach(function (rule) {
      if (rule.tag) _this2.tags.push(rule);else if (rule.style) _this2.styles.push(rule);
    });
    this.normalizeLists = !this.tags.some(function (r) {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node) return false;
      var node = schema.nodes[r.node];
      return node.contentMatch.matchType(node);
    });
  }

  _createClass(DOMParser, [{
    key: "parse",
    value: function parse(dom) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var context = new ParseContext(this, options, false);
      context.addAll(dom, options.from, options.to);
      return context.finish();
    }
  }, {
    key: "parseSlice",
    value: function parseSlice(dom) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var context = new ParseContext(this, options, true);
      context.addAll(dom, options.from, options.to);
      return Slice.maxOpen(context.finish());
    }
  }, {
    key: "matchTag",
    value: function matchTag(dom, context, after) {
      for (var i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
        var rule = this.tags[i];

        if (matches(dom, rule.tag) && (rule.namespace === undefined || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
          if (rule.getAttrs) {
            var result = rule.getAttrs(dom);
            if (result === false) continue;
            rule.attrs = result || undefined;
          }

          return rule;
        }
      }
    }
  }, {
    key: "matchStyle",
    value: function matchStyle(prop, value, context, after) {
      for (var i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
        var rule = this.styles[i],
            style = rule.style;
        if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value)) continue;

        if (rule.getAttrs) {
          var result = rule.getAttrs(value);
          if (result === false) continue;
          rule.attrs = result || undefined;
        }

        return rule;
      }
    }
  }], [{
    key: "schemaRules",
    value: function schemaRules(schema) {
      var result = [];

      function insert(rule) {
        var priority = rule.priority == null ? 50 : rule.priority,
            i = 0;

        for (; i < result.length; i++) {
          var next = result[i],
              nextPriority = next.priority == null ? 50 : next.priority;
          if (nextPriority < priority) break;
        }

        result.splice(i, 0, rule);
      }

      var _loop2 = function _loop2(name) {
        var rules = schema.marks[name].spec.parseDOM;
        if (rules) rules.forEach(function (rule) {
          insert(rule = copy(rule));
          if (!(rule.mark || rule.ignore || rule.clearMark)) rule.mark = name;
        });
      };

      for (var name in schema.marks) {
        _loop2(name);
      }

      var _loop3 = function _loop3(_name) {
        var rules = schema.nodes[_name].spec.parseDOM;
        if (rules) rules.forEach(function (rule) {
          insert(rule = copy(rule));
          if (!(rule.node || rule.ignore || rule.mark)) rule.node = _name;
        });
      };

      for (var _name in schema.nodes) {
        _loop3(_name);
      }

      return result;
    }
  }, {
    key: "fromSchema",
    value: function fromSchema(schema) {
      return schema.cached.domParser || (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));
    }
  }]);

  return DOMParser;
}();

var blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
var ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
var listTags = {
  ol: true,
  ul: true
};
var OPT_PRESERVE_WS = 1,
    OPT_PRESERVE_WS_FULL = 2,
    OPT_OPEN_LEFT = 4;

function wsOptionsFor(type, preserveWhitespace, base) {
  if (preserveWhitespace != null) return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type && type.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;
}

var NodeContext = function () {
  function NodeContext(type, attrs, marks, pendingMarks, solid, match, options) {
    _classCallCheck(this, NodeContext);

    this.type = type;
    this.attrs = attrs;
    this.marks = marks;
    this.pendingMarks = pendingMarks;
    this.solid = solid;
    this.options = options;
    this.content = [];
    this.activeMarks = Mark.none;
    this.stashMarks = [];
    this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);
  }

  _createClass(NodeContext, [{
    key: "findWrapping",
    value: function findWrapping(node) {
      if (!this.match) {
        if (!this.type) return [];
        var fill = this.type.contentMatch.fillBefore(Fragment.from(node));

        if (fill) {
          this.match = this.type.contentMatch.matchFragment(fill);
        } else {
          var start = this.type.contentMatch,
              wrap;

          if (wrap = start.findWrapping(node.type)) {
            this.match = start;
            return wrap;
          } else {
            return null;
          }
        }
      }

      return this.match.findWrapping(node.type);
    }
  }, {
    key: "finish",
    value: function finish(openEnd) {
      if (!(this.options & OPT_PRESERVE_WS)) {
        var last = this.content[this.content.length - 1],
            m;

        if (last && last.isText && (m = /[ \t\r\n\u000c]+$/.exec(last.text))) {
          var text = last;
          if (last.text.length == m[0].length) this.content.pop();else this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));
        }
      }

      var content = Fragment.from(this.content);
      if (!openEnd && this.match) content = content.append(this.match.fillBefore(Fragment.empty, true));
      return this.type ? this.type.create(this.attrs, content, this.marks) : content;
    }
  }, {
    key: "popFromStashMark",
    value: function popFromStashMark(mark) {
      for (var i = this.stashMarks.length - 1; i >= 0; i--) {
        if (mark.eq(this.stashMarks[i])) return this.stashMarks.splice(i, 1)[0];
      }
    }
  }, {
    key: "applyPending",
    value: function applyPending(nextType) {
      for (var i = 0, pending = this.pendingMarks; i < pending.length; i++) {
        var mark = pending[i];

        if ((this.type ? this.type.allowsMarkType(mark.type) : markMayApply(mark.type, nextType)) && !mark.isInSet(this.activeMarks)) {
          this.activeMarks = mark.addToSet(this.activeMarks);
          this.pendingMarks = mark.removeFromSet(this.pendingMarks);
        }
      }
    }
  }, {
    key: "inlineContext",
    value: function inlineContext(node) {
      if (this.type) return this.type.inlineContent;
      if (this.content.length) return this.content[0].isInline;
      return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
    }
  }]);

  return NodeContext;
}();

var ParseContext = function () {
  function ParseContext(parser, options, isOpen) {
    _classCallCheck(this, ParseContext);

    this.parser = parser;
    this.options = options;
    this.isOpen = isOpen;
    this.open = 0;
    var topNode = options.topNode,
        topContext;
    var topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode) topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);else if (isOpen) topContext = new NodeContext(null, null, Mark.none, Mark.none, true, null, topOptions);else topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, Mark.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options.findPositions;
    this.needsBlock = false;
  }

  _createClass(ParseContext, [{
    key: "top",
    get: function get() {
      return this.nodes[this.open];
    }
  }, {
    key: "addDOM",
    value: function addDOM(dom) {
      if (dom.nodeType == 3) {
        this.addTextNode(dom);
      } else if (dom.nodeType == 1) {
        var style = dom.getAttribute("style");

        if (!style) {
          this.addElement(dom);
        } else {
          var marks = this.readStyles(parseStyles(style));
          if (!marks) return;

          var _marks = _slicedToArray(marks, 2),
              addMarks = _marks[0],
              removeMarks = _marks[1],
              top = this.top;

          for (var i = 0; i < removeMarks.length; i++) {
            this.removePendingMark(removeMarks[i], top);
          }

          for (var _i4 = 0; _i4 < addMarks.length; _i4++) {
            this.addPendingMark(addMarks[_i4]);
          }

          this.addElement(dom);

          for (var _i5 = 0; _i5 < addMarks.length; _i5++) {
            this.removePendingMark(addMarks[_i5], top);
          }

          for (var _i6 = 0; _i6 < removeMarks.length; _i6++) {
            this.addPendingMark(removeMarks[_i6]);
          }
        }
      }
    }
  }, {
    key: "addTextNode",
    value: function addTextNode(dom) {
      var value = dom.nodeValue;
      var top = this.top;

      if (top.options & OPT_PRESERVE_WS_FULL || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
        if (!(top.options & OPT_PRESERVE_WS)) {
          value = value.replace(/[ \t\r\n\u000c]+/g, " ");

          if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
            var nodeBefore = top.content[top.content.length - 1];
            var domNodeBefore = dom.previousSibling;
            if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == 'BR' || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text)) value = value.slice(1);
          }
        } else if (!(top.options & OPT_PRESERVE_WS_FULL)) {
          value = value.replace(/\r?\n|\r/g, " ");
        } else {
          value = value.replace(/\r\n?/g, "\n");
        }

        if (value) this.insertNode(this.parser.schema.text(value));
        this.findInText(dom);
      } else {
        this.findInside(dom);
      }
    }
  }, {
    key: "addElement",
    value: function addElement(dom, matchAfter) {
      var name = dom.nodeName.toLowerCase(),
          ruleID;
      if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) normalizeList(dom);
      var rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));

      if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
        this.findInside(dom);
        this.ignoreFallback(dom);
      } else if (!rule || rule.skip || rule.closeParent) {
        if (rule && rule.closeParent) this.open = Math.max(0, this.open - 1);else if (rule && rule.skip.nodeType) dom = rule.skip;
        var sync,
            top = this.top,
            oldNeedsBlock = this.needsBlock;

        if (blockTags.hasOwnProperty(name)) {
          if (top.content.length && top.content[0].isInline && this.open) {
            this.open--;
            top = this.top;
          }

          sync = true;
          if (!top.type) this.needsBlock = true;
        } else if (!dom.firstChild) {
          this.leafFallback(dom);
          return;
        }

        this.addAll(dom);
        if (sync) this.sync(top);
        this.needsBlock = oldNeedsBlock;
      } else {
        this.addElementByRule(dom, rule, rule.consuming === false ? ruleID : undefined);
      }
    }
  }, {
    key: "leafFallback",
    value: function leafFallback(dom) {
      if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent) this.addTextNode(dom.ownerDocument.createTextNode("\n"));
    }
  }, {
    key: "ignoreFallback",
    value: function ignoreFallback(dom) {
      if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent)) this.findPlace(this.parser.schema.text("-"));
    }
  }, {
    key: "readStyles",
    value: function readStyles(styles) {
      var _this3 = this;

      var add = Mark.none,
          remove = Mark.none;

      for (var i = 0; i < styles.length; i += 2) {
        var _loop4 = function _loop4(_after) {
          var rule = _this3.parser.matchStyle(styles[i], styles[i + 1], _this3, _after);

          if (!rule) {
            after = _after;
            return "break";
          }

          if (rule.ignore) {
            after = _after;
            return {
              v: null
            };
          }

          if (rule.clearMark) {
            _this3.top.pendingMarks.concat(_this3.top.activeMarks).forEach(function (m) {
              if (rule.clearMark(m)) remove = m.addToSet(remove);
            });
          } else {
            add = _this3.parser.schema.marks[rule.mark].create(rule.attrs).addToSet(add);
          }

          if (rule.consuming === false) _after = rule;else {
            after = _after;
            return "break";
          }
          after = _after;
        };

        for (var after = undefined;;) {
          var _ret = _loop4(after);

          if (_ret === "break") break;
          if (_typeof(_ret) === "object") return _ret.v;
        }
      }

      return [add, remove];
    }
  }, {
    key: "addElementByRule",
    value: function addElementByRule(dom, rule, continueAfter) {
      var _this4 = this;

      var sync, nodeType, mark;

      if (rule.node) {
        nodeType = this.parser.schema.nodes[rule.node];

        if (!nodeType.isLeaf) {
          sync = this.enter(nodeType, rule.attrs || null, rule.preserveWhitespace);
        } else if (!this.insertNode(nodeType.create(rule.attrs))) {
          this.leafFallback(dom);
        }
      } else {
        var markType = this.parser.schema.marks[rule.mark];
        mark = markType.create(rule.attrs);
        this.addPendingMark(mark);
      }

      var startIn = this.top;

      if (nodeType && nodeType.isLeaf) {
        this.findInside(dom);
      } else if (continueAfter) {
        this.addElement(dom, continueAfter);
      } else if (rule.getContent) {
        this.findInside(dom);
        rule.getContent(dom, this.parser.schema).forEach(function (node) {
          return _this4.insertNode(node);
        });
      } else {
        var contentDOM = dom;
        if (typeof rule.contentElement == "string") contentDOM = dom.querySelector(rule.contentElement);else if (typeof rule.contentElement == "function") contentDOM = rule.contentElement(dom);else if (rule.contentElement) contentDOM = rule.contentElement;
        this.findAround(dom, contentDOM, true);
        this.addAll(contentDOM);
      }

      if (sync && this.sync(startIn)) this.open--;
      if (mark) this.removePendingMark(mark, startIn);
    }
  }, {
    key: "addAll",
    value: function addAll(parent, startIndex, endIndex) {
      var index = startIndex || 0;

      for (var dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {
        this.findAtPoint(parent, index);
        this.addDOM(dom);
      }

      this.findAtPoint(parent, index);
    }
  }, {
    key: "findPlace",
    value: function findPlace(node) {
      var route, sync;

      for (var depth = this.open; depth >= 0; depth--) {
        var cx = this.nodes[depth];

        var _found2 = cx.findWrapping(node);

        if (_found2 && (!route || route.length > _found2.length)) {
          route = _found2;
          sync = cx;
          if (!_found2.length) break;
        }

        if (cx.solid) break;
      }

      if (!route) return false;
      this.sync(sync);

      for (var i = 0; i < route.length; i++) {
        this.enterInner(route[i], null, false);
      }

      return true;
    }
  }, {
    key: "insertNode",
    value: function insertNode(node) {
      if (node.isInline && this.needsBlock && !this.top.type) {
        var block = this.textblockFromContext();
        if (block) this.enterInner(block);
      }

      if (this.findPlace(node)) {
        this.closeExtra();
        var top = this.top;
        top.applyPending(node.type);
        if (top.match) top.match = top.match.matchType(node.type);
        var marks = top.activeMarks;

        for (var i = 0; i < node.marks.length; i++) {
          if (!top.type || top.type.allowsMarkType(node.marks[i].type)) marks = node.marks[i].addToSet(marks);
        }

        top.content.push(node.mark(marks));
        return true;
      }

      return false;
    }
  }, {
    key: "enter",
    value: function enter(type, attrs, preserveWS) {
      var ok = this.findPlace(type.create(attrs));
      if (ok) this.enterInner(type, attrs, true, preserveWS);
      return ok;
    }
  }, {
    key: "enterInner",
    value: function enterInner(type) {
      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var solid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var preserveWS = arguments.length > 3 ? arguments[3] : undefined;
      this.closeExtra();
      var top = this.top;
      top.applyPending(type);
      top.match = top.match && top.match.matchType(type);
      var options = wsOptionsFor(type, preserveWS, top.options);
      if (top.options & OPT_OPEN_LEFT && top.content.length == 0) options |= OPT_OPEN_LEFT;
      this.nodes.push(new NodeContext(type, attrs, top.activeMarks, top.pendingMarks, solid, null, options));
      this.open++;
    }
  }, {
    key: "closeExtra",
    value: function closeExtra() {
      var openEnd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var i = this.nodes.length - 1;

      if (i > this.open) {
        for (; i > this.open; i--) {
          this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
        }

        this.nodes.length = this.open + 1;
      }
    }
  }, {
    key: "finish",
    value: function finish() {
      this.open = 0;
      this.closeExtra(this.isOpen);
      return this.nodes[0].finish(this.isOpen || this.options.topOpen);
    }
  }, {
    key: "sync",
    value: function sync(to) {
      for (var i = this.open; i >= 0; i--) {
        if (this.nodes[i] == to) {
          this.open = i;
          return true;
        }
      }

      return false;
    }
  }, {
    key: "currentPos",
    get: function get() {
      this.closeExtra();
      var pos = 0;

      for (var i = this.open; i >= 0; i--) {
        var content = this.nodes[i].content;

        for (var j = content.length - 1; j >= 0; j--) {
          pos += content[j].nodeSize;
        }

        if (i) pos++;
      }

      return pos;
    }
  }, {
    key: "findAtPoint",
    value: function findAtPoint(parent, offset) {
      if (this.find) for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset) this.find[i].pos = this.currentPos;
      }
    }
  }, {
    key: "findInside",
    value: function findInside(parent) {
      if (this.find) for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) this.find[i].pos = this.currentPos;
      }
    }
  }, {
    key: "findAround",
    value: function findAround(parent, content, before) {
      if (parent != content && this.find) for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          var pos = content.compareDocumentPosition(this.find[i].node);
          if (pos & (before ? 2 : 4)) this.find[i].pos = this.currentPos;
        }
      }
    }
  }, {
    key: "findInText",
    value: function findInText(textNode) {
      if (this.find) for (var i = 0; i < this.find.length; i++) {
        if (this.find[i].node == textNode) this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
    }
  }, {
    key: "matchesContext",
    value: function matchesContext(context) {
      var _this5 = this;

      if (context.indexOf("|") > -1) return context.split(/\s*\|\s*/).some(this.matchesContext, this);
      var parts = context.split("/");
      var option = this.options.context;
      var useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
      var minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);

      var match = function match(i, depth) {
        for (; i >= 0; i--) {
          var part = parts[i];

          if (part == "") {
            if (i == parts.length - 1 || i == 0) continue;

            for (; depth >= minDepth; depth--) {
              if (match(i - 1, depth)) return true;
            }

            return false;
          } else {
            var next = depth > 0 || depth == 0 && useRoot ? _this5.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
            if (!next || next.name != part && next.groups.indexOf(part) == -1) return false;
            depth--;
          }
        }

        return true;
      };

      return match(parts.length - 1, this.open);
    }
  }, {
    key: "textblockFromContext",
    value: function textblockFromContext() {
      var $context = this.options.context;
      if ($context) for (var d = $context.depth; d >= 0; d--) {
        var deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt;
      }

      for (var name in this.parser.schema.nodes) {
        var type = this.parser.schema.nodes[name];
        if (type.isTextblock && type.defaultAttrs) return type;
      }
    }
  }, {
    key: "addPendingMark",
    value: function addPendingMark(mark) {
      var found = findSameMarkInSet(mark, this.top.pendingMarks);
      if (found) this.top.stashMarks.push(found);
      this.top.pendingMarks = mark.addToSet(this.top.pendingMarks);
    }
  }, {
    key: "removePendingMark",
    value: function removePendingMark(mark, upto) {
      for (var depth = this.open; depth >= 0; depth--) {
        var level = this.nodes[depth];

        var _found3 = level.pendingMarks.lastIndexOf(mark);

        if (_found3 > -1) {
          level.pendingMarks = mark.removeFromSet(level.pendingMarks);
        } else {
          level.activeMarks = mark.removeFromSet(level.activeMarks);
          var stashMark = level.popFromStashMark(mark);
          if (stashMark && level.type && level.type.allowsMarkType(stashMark.type)) level.activeMarks = stashMark.addToSet(level.activeMarks);
        }

        if (level == upto) break;
      }
    }
  }]);

  return ParseContext;
}();

function normalizeList(dom) {
  for (var child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    var name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;

    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}

function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}

function parseStyles(style) {
  var re = /\s*([\w-]+)\s*:\s*([^;]+)/g,
      m,
      result = [];

  while (m = re.exec(style)) {
    result.push(m[1], m[2].trim());
  }

  return result;
}

function copy(obj) {
  var copy = {};

  for (var prop in obj) {
    copy[prop] = obj[prop];
  }

  return copy;
}

function markMayApply(markType, nodeType) {
  var nodes = nodeType.schema.nodes;

  var _loop5 = function _loop5(name) {
    var parent = nodes[name];
    if (!parent.allowsMarkType(markType)) return "continue";

    var seen = [],
        scan = function scan(match) {
      seen.push(match);

      for (var i = 0; i < match.edgeCount; i++) {
        var _match$edge = match.edge(i),
            type = _match$edge.type,
            next = _match$edge.next;

        if (type == nodeType) return true;
        if (seen.indexOf(next) < 0 && scan(next)) return true;
      }
    };

    if (scan(parent.contentMatch)) return {
      v: true
    };
  };

  for (var name in nodes) {
    var _ret2 = _loop5(name);

    if (_ret2 === "continue") continue;
    if (_typeof(_ret2) === "object") return _ret2.v;
  }
}

function findSameMarkInSet(mark, set) {
  for (var i = 0; i < set.length; i++) {
    if (mark.eq(set[i])) return set[i];
  }
}

var DOMSerializer = function () {
  function DOMSerializer(nodes, marks) {
    _classCallCheck(this, DOMSerializer);

    this.nodes = nodes;
    this.marks = marks;
  }

  _createClass(DOMSerializer, [{
    key: "serializeFragment",
    value: function serializeFragment(fragment) {
      var _this6 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var target = arguments.length > 2 ? arguments[2] : undefined;
      if (!target) target = doc(options).createDocumentFragment();
      var top = target,
          active = [];
      fragment.forEach(function (node) {
        if (active.length || node.marks.length) {
          var keep = 0,
              rendered = 0;

          while (keep < active.length && rendered < node.marks.length) {
            var next = node.marks[rendered];

            if (!_this6.marks[next.type.name]) {
              rendered++;
              continue;
            }

            if (!next.eq(active[keep][0]) || next.type.spec.spanning === false) break;
            keep++;
            rendered++;
          }

          while (keep < active.length) {
            top = active.pop()[1];
          }

          while (rendered < node.marks.length) {
            var add = node.marks[rendered++];

            var markDOM = _this6.serializeMark(add, node.isInline, options);

            if (markDOM) {
              active.push([add, top]);
              top.appendChild(markDOM.dom);
              top = markDOM.contentDOM || markDOM.dom;
            }
          }
        }

        top.appendChild(_this6.serializeNodeInner(node, options));
      });
      return target;
    }
  }, {
    key: "serializeNodeInner",
    value: function serializeNodeInner(node, options) {
      var _DOMSerializer$render = DOMSerializer.renderSpec(doc(options), this.nodes[node.type.name](node)),
          dom = _DOMSerializer$render.dom,
          contentDOM = _DOMSerializer$render.contentDOM;

      if (contentDOM) {
        if (node.isLeaf) throw new RangeError("Content hole not allowed in a leaf node spec");
        this.serializeFragment(node.content, options, contentDOM);
      }

      return dom;
    }
  }, {
    key: "serializeNode",
    value: function serializeNode(node) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var dom = this.serializeNodeInner(node, options);

      for (var i = node.marks.length - 1; i >= 0; i--) {
        var wrap = this.serializeMark(node.marks[i], node.isInline, options);

        if (wrap) {
          (wrap.contentDOM || wrap.dom).appendChild(dom);
          dom = wrap.dom;
        }
      }

      return dom;
    }
  }, {
    key: "serializeMark",
    value: function serializeMark(mark, inline) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var toDOM = this.marks[mark.type.name];
      return toDOM && DOMSerializer.renderSpec(doc(options), toDOM(mark, inline));
    }
  }], [{
    key: "renderSpec",
    value: function renderSpec(doc, structure) {
      var xmlNS = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      if (typeof structure == "string") return {
        dom: doc.createTextNode(structure)
      };
      if (structure.nodeType != null) return {
        dom: structure
      };
      if (structure.dom && structure.dom.nodeType != null) return structure;
      var tagName = structure[0],
          space = tagName.indexOf(" ");

      if (space > 0) {
        xmlNS = tagName.slice(0, space);
        tagName = tagName.slice(space + 1);
      }

      var contentDOM;
      var dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName);
      var attrs = structure[1],
          start = 1;

      if (attrs && _typeof(attrs) == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
        start = 2;

        for (var name in attrs) {
          if (attrs[name] != null) {
            var _space = name.indexOf(" ");

            if (_space > 0) dom.setAttributeNS(name.slice(0, _space), name.slice(_space + 1), attrs[name]);else dom.setAttribute(name, attrs[name]);
          }
        }
      }

      for (var i = start; i < structure.length; i++) {
        var child = structure[i];

        if (child === 0) {
          if (i < structure.length - 1 || i > start) throw new RangeError("Content hole must be the only child of its parent node");
          return {
            dom: dom,
            contentDOM: dom
          };
        } else {
          var _DOMSerializer$render2 = DOMSerializer.renderSpec(doc, child, xmlNS),
              inner = _DOMSerializer$render2.dom,
              innerContent = _DOMSerializer$render2.contentDOM;

          dom.appendChild(inner);

          if (innerContent) {
            if (contentDOM) throw new RangeError("Multiple content holes");
            contentDOM = innerContent;
          }
        }
      }

      return {
        dom: dom,
        contentDOM: contentDOM
      };
    }
  }, {
    key: "fromSchema",
    value: function fromSchema(schema) {
      return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
    }
  }, {
    key: "nodesFromSchema",
    value: function nodesFromSchema(schema) {
      var result = gatherToDOM(schema.nodes);
      if (!result.text) result.text = function (node) {
        return node.text;
      };
      return result;
    }
  }, {
    key: "marksFromSchema",
    value: function marksFromSchema(schema) {
      return gatherToDOM(schema.marks);
    }
  }]);

  return DOMSerializer;
}();

function gatherToDOM(obj) {
  var result = {};

  for (var name in obj) {
    var toDOM = obj[name].spec.toDOM;
    if (toDOM) result[name] = toDOM;
  }

  return result;
}

function doc(options) {
  return options.document || window.document;
}

exports.ContentMatch = ContentMatch;
exports.DOMParser = DOMParser;
exports.DOMSerializer = DOMSerializer;
exports.Fragment = Fragment;
exports.Mark = Mark;
exports.MarkType = MarkType;
exports.Node = Node;
exports.NodeRange = NodeRange;
exports.NodeType = NodeType;
exports.ReplaceError = ReplaceError;
exports.ResolvedPos = ResolvedPos;
exports.Schema = Schema;
exports.Slice = Slice;


/***/ }),

/***/ "./node_modules/prosemirror-state/dist/index.cjs":
/*!*******************************************************!*\
  !*** ./node_modules/prosemirror-state/dist/index.cjs ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorModel = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.cjs");

var prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.cjs");

var classesById = Object.create(null);

var Selection = function () {
  function Selection($anchor, $head, ranges) {
    _classCallCheck(this, Selection);

    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }

  _createClass(Selection, [{
    key: "anchor",
    get: function get() {
      return this.$anchor.pos;
    }
  }, {
    key: "head",
    get: function get() {
      return this.$head.pos;
    }
  }, {
    key: "from",
    get: function get() {
      return this.$from.pos;
    }
  }, {
    key: "to",
    get: function get() {
      return this.$to.pos;
    }
  }, {
    key: "$from",
    get: function get() {
      return this.ranges[0].$from;
    }
  }, {
    key: "$to",
    get: function get() {
      return this.ranges[0].$to;
    }
  }, {
    key: "empty",
    get: function get() {
      var ranges = this.ranges;

      for (var i = 0; i < ranges.length; i++) {
        if (ranges[i].$from.pos != ranges[i].$to.pos) return false;
      }

      return true;
    }
  }, {
    key: "content",
    value: function content() {
      return this.$from.doc.slice(this.from, this.to, true);
    }
  }, {
    key: "replace",
    value: function replace(tr) {
      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : prosemirrorModel.Slice.empty;
      var lastNode = content.content.lastChild,
          lastParent = null;

      for (var i = 0; i < content.openEnd; i++) {
        lastParent = lastNode;
        lastNode = lastNode.lastChild;
      }

      var mapFrom = tr.steps.length,
          ranges = this.ranges;

      for (var _i = 0; _i < ranges.length; _i++) {
        var _ranges$_i = ranges[_i],
            $from = _ranges$_i.$from,
            $to = _ranges$_i.$to,
            mapping = tr.mapping.slice(mapFrom);
        tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), _i ? prosemirrorModel.Slice.empty : content);
        if (_i == 0) selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
      }
    }
  }, {
    key: "replaceWith",
    value: function replaceWith(tr, node) {
      var mapFrom = tr.steps.length,
          ranges = this.ranges;

      for (var i = 0; i < ranges.length; i++) {
        var _ranges$i = ranges[i],
            $from = _ranges$i.$from,
            $to = _ranges$i.$to,
            mapping = tr.mapping.slice(mapFrom);
        var from = mapping.map($from.pos),
            to = mapping.map($to.pos);

        if (i) {
          tr.deleteRange(from, to);
        } else {
          tr.replaceRangeWith(from, to, node);
          selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
        }
      }
    }
  }, {
    key: "getBookmark",
    value: function getBookmark() {
      return TextSelection.between(this.$anchor, this.$head).getBookmark();
    }
  }], [{
    key: "findFrom",
    value: function findFrom($pos, dir) {
      var textOnly = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
      if (inner) return inner;

      for (var depth = $pos.depth - 1; depth >= 0; depth--) {
        var found = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
        if (found) return found;
      }

      return null;
    }
  }, {
    key: "near",
    value: function near($pos) {
      var bias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
    }
  }, {
    key: "atStart",
    value: function atStart(doc) {
      return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);
    }
  }, {
    key: "atEnd",
    value: function atEnd(doc) {
      return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc);
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(doc, json) {
      if (!json || !json.type) throw new RangeError("Invalid input for Selection.fromJSON");
      var cls = classesById[json.type];
      if (!cls) throw new RangeError("No selection type ".concat(json.type, " defined"));
      return cls.fromJSON(doc, json);
    }
  }, {
    key: "jsonID",
    value: function jsonID(id, selectionClass) {
      if (id in classesById) throw new RangeError("Duplicate use of selection JSON ID " + id);
      classesById[id] = selectionClass;
      selectionClass.prototype.jsonID = id;
      return selectionClass;
    }
  }]);

  return Selection;
}();

Selection.prototype.visible = true;

var SelectionRange = _createClass(function SelectionRange($from, $to) {
  _classCallCheck(this, SelectionRange);

  this.$from = $from;
  this.$to = $to;
});

var warnedAboutTextSelection = false;

function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}

var TextSelection = function (_Selection) {
  _inherits(TextSelection, _Selection);

  var _super = _createSuper(TextSelection);

  function TextSelection($anchor) {
    var $head = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $anchor;

    _classCallCheck(this, TextSelection);

    checkTextSelection($anchor);
    checkTextSelection($head);
    return _super.call(this, $anchor, $head);
  }

  _createClass(TextSelection, [{
    key: "$cursor",
    get: function get() {
      return this.$anchor.pos == this.$head.pos ? this.$head : null;
    }
  }, {
    key: "map",
    value: function map(doc, mapping) {
      var $head = doc.resolve(mapping.map(this.head));
      if (!$head.parent.inlineContent) return Selection.near($head);
      var $anchor = doc.resolve(mapping.map(this.anchor));
      return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
    }
  }, {
    key: "replace",
    value: function replace(tr) {
      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : prosemirrorModel.Slice.empty;

      _get(_getPrototypeOf(TextSelection.prototype), "replace", this).call(this, tr, content);

      if (content == prosemirrorModel.Slice.empty) {
        var marks = this.$from.marksAcross(this.$to);
        if (marks) tr.ensureMarks(marks);
      }
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;
    }
  }, {
    key: "getBookmark",
    value: function getBookmark() {
      return new TextBookmark(this.anchor, this.head);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: "text",
        anchor: this.anchor,
        head: this.head
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(doc, json) {
      if (typeof json.anchor != "number" || typeof json.head != "number") throw new RangeError("Invalid input for TextSelection.fromJSON");
      return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head));
    }
  }, {
    key: "create",
    value: function create(doc, anchor) {
      var head = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : anchor;
      var $anchor = doc.resolve(anchor);
      return new this($anchor, head == anchor ? $anchor : doc.resolve(head));
    }
  }, {
    key: "between",
    value: function between($anchor, $head, bias) {
      var dPos = $anchor.pos - $head.pos;
      if (!bias || dPos) bias = dPos >= 0 ? 1 : -1;

      if (!$head.parent.inlineContent) {
        var found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
        if (found) $head = found.$head;else return Selection.near($head, bias);
      }

      if (!$anchor.parent.inlineContent) {
        if (dPos == 0) {
          $anchor = $head;
        } else {
          $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
          if ($anchor.pos < $head.pos != dPos < 0) $anchor = $head;
        }
      }

      return new TextSelection($anchor, $head);
    }
  }]);

  return TextSelection;
}(Selection);

Selection.jsonID("text", TextSelection);

var TextBookmark = function () {
  function TextBookmark(anchor, head) {
    _classCallCheck(this, TextBookmark);

    this.anchor = anchor;
    this.head = head;
  }

  _createClass(TextBookmark, [{
    key: "map",
    value: function map(mapping) {
      return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
    }
  }, {
    key: "resolve",
    value: function resolve(doc) {
      return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head));
    }
  }]);

  return TextBookmark;
}();

var NodeSelection = function (_Selection2) {
  _inherits(NodeSelection, _Selection2);

  var _super2 = _createSuper(NodeSelection);

  function NodeSelection($pos) {
    var _this;

    _classCallCheck(this, NodeSelection);

    var node = $pos.nodeAfter;
    var $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    _this = _super2.call(this, $pos, $end);
    _this.node = node;
    return _this;
  }

  _createClass(NodeSelection, [{
    key: "map",
    value: function map(doc, mapping) {
      var _mapping$mapResult = mapping.mapResult(this.anchor),
          deleted = _mapping$mapResult.deleted,
          pos = _mapping$mapResult.pos;

      var $pos = doc.resolve(pos);
      if (deleted) return Selection.near($pos);
      return new NodeSelection($pos);
    }
  }, {
    key: "content",
    value: function content() {
      return new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(this.node), 0, 0);
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return other instanceof NodeSelection && other.anchor == this.anchor;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: "node",
        anchor: this.anchor
      };
    }
  }, {
    key: "getBookmark",
    value: function getBookmark() {
      return new NodeBookmark(this.anchor);
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(doc, json) {
      if (typeof json.anchor != "number") throw new RangeError("Invalid input for NodeSelection.fromJSON");
      return new NodeSelection(doc.resolve(json.anchor));
    }
  }, {
    key: "create",
    value: function create(doc, from) {
      return new NodeSelection(doc.resolve(from));
    }
  }, {
    key: "isSelectable",
    value: function isSelectable(node) {
      return !node.isText && node.type.spec.selectable !== false;
    }
  }]);

  return NodeSelection;
}(Selection);

NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);

var NodeBookmark = function () {
  function NodeBookmark(anchor) {
    _classCallCheck(this, NodeBookmark);

    this.anchor = anchor;
  }

  _createClass(NodeBookmark, [{
    key: "map",
    value: function map(mapping) {
      var _mapping$mapResult2 = mapping.mapResult(this.anchor),
          deleted = _mapping$mapResult2.deleted,
          pos = _mapping$mapResult2.pos;

      return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
    }
  }, {
    key: "resolve",
    value: function resolve(doc) {
      var $pos = doc.resolve(this.anchor),
          node = $pos.nodeAfter;
      if (node && NodeSelection.isSelectable(node)) return new NodeSelection($pos);
      return Selection.near($pos);
    }
  }]);

  return NodeBookmark;
}();

var AllSelection = function (_Selection3) {
  _inherits(AllSelection, _Selection3);

  var _super3 = _createSuper(AllSelection);

  function AllSelection(doc) {
    _classCallCheck(this, AllSelection);

    return _super3.call(this, doc.resolve(0), doc.resolve(doc.content.size));
  }

  _createClass(AllSelection, [{
    key: "replace",
    value: function replace(tr) {
      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : prosemirrorModel.Slice.empty;

      if (content == prosemirrorModel.Slice.empty) {
        tr["delete"](0, tr.doc.content.size);
        var sel = Selection.atStart(tr.doc);
        if (!sel.eq(tr.selection)) tr.setSelection(sel);
      } else {
        _get(_getPrototypeOf(AllSelection.prototype), "replace", this).call(this, tr, content);
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        type: "all"
      };
    }
  }, {
    key: "map",
    value: function map(doc) {
      return new AllSelection(doc);
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return other instanceof AllSelection;
    }
  }, {
    key: "getBookmark",
    value: function getBookmark() {
      return AllBookmark;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(doc) {
      return new AllSelection(doc);
    }
  }]);

  return AllSelection;
}(Selection);

Selection.jsonID("all", AllSelection);
var AllBookmark = {
  map: function map() {
    return this;
  },
  resolve: function resolve(doc) {
    return new AllSelection(doc);
  }
};

function findSelectionIn(doc, node, pos, index, dir) {
  var text = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  if (node.inlineContent) return TextSelection.create(doc, pos);

  for (var i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
    var child = node.child(i);

    if (!child.isAtom) {
      var inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner) return inner;
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));
    }

    pos += child.nodeSize * dir;
  }

  return null;
}

function selectionToInsertionEnd(tr, startLen, bias) {
  var last = tr.steps.length - 1;
  if (last < startLen) return;
  var step = tr.steps[last];
  if (!(step instanceof prosemirrorTransform.ReplaceStep || step instanceof prosemirrorTransform.ReplaceAroundStep)) return;
  var map = tr.mapping.maps[last],
      end;
  map.forEach(function (_from, _to, _newFrom, newTo) {
    if (end == null) end = newTo;
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
}

var UPDATED_SEL = 1,
    UPDATED_MARKS = 2,
    UPDATED_SCROLL = 4;

var Transaction = function (_prosemirrorTransform) {
  _inherits(Transaction, _prosemirrorTransform);

  var _super4 = _createSuper(Transaction);

  function Transaction(state) {
    var _this2;

    _classCallCheck(this, Transaction);

    _this2 = _super4.call(this, state.doc);
    _this2.curSelectionFor = 0;
    _this2.updated = 0;
    _this2.meta = Object.create(null);
    _this2.time = Date.now();
    _this2.curSelection = state.selection;
    _this2.storedMarks = state.storedMarks;
    return _this2;
  }

  _createClass(Transaction, [{
    key: "selection",
    get: function get() {
      if (this.curSelectionFor < this.steps.length) {
        this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
        this.curSelectionFor = this.steps.length;
      }

      return this.curSelection;
    }
  }, {
    key: "setSelection",
    value: function setSelection(selection) {
      if (selection.$from.doc != this.doc) throw new RangeError("Selection passed to setSelection must point at the current document");
      this.curSelection = selection;
      this.curSelectionFor = this.steps.length;
      this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
      this.storedMarks = null;
      return this;
    }
  }, {
    key: "selectionSet",
    get: function get() {
      return (this.updated & UPDATED_SEL) > 0;
    }
  }, {
    key: "setStoredMarks",
    value: function setStoredMarks(marks) {
      this.storedMarks = marks;
      this.updated |= UPDATED_MARKS;
      return this;
    }
  }, {
    key: "ensureMarks",
    value: function ensureMarks(marks) {
      if (!prosemirrorModel.Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks)) this.setStoredMarks(marks);
      return this;
    }
  }, {
    key: "addStoredMark",
    value: function addStoredMark(mark) {
      return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
    }
  }, {
    key: "removeStoredMark",
    value: function removeStoredMark(mark) {
      return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
    }
  }, {
    key: "storedMarksSet",
    get: function get() {
      return (this.updated & UPDATED_MARKS) > 0;
    }
  }, {
    key: "addStep",
    value: function addStep(step, doc) {
      _get(_getPrototypeOf(Transaction.prototype), "addStep", this).call(this, step, doc);

      this.updated = this.updated & ~UPDATED_MARKS;
      this.storedMarks = null;
    }
  }, {
    key: "setTime",
    value: function setTime(time) {
      this.time = time;
      return this;
    }
  }, {
    key: "replaceSelection",
    value: function replaceSelection(slice) {
      this.selection.replace(this, slice);
      return this;
    }
  }, {
    key: "replaceSelectionWith",
    value: function replaceSelectionWith(node) {
      var inheritMarks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var selection = this.selection;
      if (inheritMarks) node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || prosemirrorModel.Mark.none));
      selection.replaceWith(this, node);
      return this;
    }
  }, {
    key: "deleteSelection",
    value: function deleteSelection() {
      this.selection.replace(this);
      return this;
    }
  }, {
    key: "insertText",
    value: function insertText(text, from, to) {
      var schema = this.doc.type.schema;

      if (from == null) {
        if (!text) return this.deleteSelection();
        return this.replaceSelectionWith(schema.text(text), true);
      } else {
        if (to == null) to = from;
        to = to == null ? from : to;
        if (!text) return this.deleteRange(from, to);
        var marks = this.storedMarks;

        if (!marks) {
          var $from = this.doc.resolve(from);
          marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
        }

        this.replaceRangeWith(from, to, schema.text(text, marks));
        if (!this.selection.empty) this.setSelection(Selection.near(this.selection.$to));
        return this;
      }
    }
  }, {
    key: "setMeta",
    value: function setMeta(key, value) {
      this.meta[typeof key == "string" ? key : key.key] = value;
      return this;
    }
  }, {
    key: "getMeta",
    value: function getMeta(key) {
      return this.meta[typeof key == "string" ? key : key.key];
    }
  }, {
    key: "isGeneric",
    get: function get() {
      for (var _ in this.meta) {
        return false;
      }

      return true;
    }
  }, {
    key: "scrollIntoView",
    value: function scrollIntoView() {
      this.updated |= UPDATED_SCROLL;
      return this;
    }
  }, {
    key: "scrolledIntoView",
    get: function get() {
      return (this.updated & UPDATED_SCROLL) > 0;
    }
  }]);

  return Transaction;
}(prosemirrorTransform.Transform);

function bind(f, self) {
  return !self || !f ? f : f.bind(self);
}

var FieldDesc = _createClass(function FieldDesc(name, desc, self) {
  _classCallCheck(this, FieldDesc);

  this.name = name;
  this.init = bind(desc.init, self);
  this.apply = bind(desc.apply, self);
});

var baseFields = [new FieldDesc("doc", {
  init: function init(config) {
    return config.doc || config.schema.topNodeType.createAndFill();
  },
  apply: function apply(tr) {
    return tr.doc;
  }
}), new FieldDesc("selection", {
  init: function init(config, instance) {
    return config.selection || Selection.atStart(instance.doc);
  },
  apply: function apply(tr) {
    return tr.selection;
  }
}), new FieldDesc("storedMarks", {
  init: function init(config) {
    return config.storedMarks || null;
  },
  apply: function apply(tr, _marks, _old, state) {
    return state.selection.$cursor ? tr.storedMarks : null;
  }
}), new FieldDesc("scrollToSelection", {
  init: function init() {
    return 0;
  },
  apply: function apply(tr, prev) {
    return tr.scrolledIntoView ? prev + 1 : prev;
  }
})];

var Configuration = _createClass(function Configuration(schema, plugins) {
  var _this3 = this;

  _classCallCheck(this, Configuration);

  this.schema = schema;
  this.plugins = [];
  this.pluginsByKey = Object.create(null);
  this.fields = baseFields.slice();
  if (plugins) plugins.forEach(function (plugin) {
    if (_this3.pluginsByKey[plugin.key]) throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");

    _this3.plugins.push(plugin);

    _this3.pluginsByKey[plugin.key] = plugin;
    if (plugin.spec.state) _this3.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
  });
});

var EditorState = function () {
  function EditorState(config) {
    _classCallCheck(this, EditorState);

    this.config = config;
  }

  _createClass(EditorState, [{
    key: "schema",
    get: function get() {
      return this.config.schema;
    }
  }, {
    key: "plugins",
    get: function get() {
      return this.config.plugins;
    }
  }, {
    key: "apply",
    value: function apply(tr) {
      return this.applyTransaction(tr).state;
    }
  }, {
    key: "filterTransaction",
    value: function filterTransaction(tr) {
      var ignore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;

      for (var i = 0; i < this.config.plugins.length; i++) {
        if (i != ignore) {
          var plugin = this.config.plugins[i];
          if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this)) return false;
        }
      }

      return true;
    }
  }, {
    key: "applyTransaction",
    value: function applyTransaction(rootTr) {
      if (!this.filterTransaction(rootTr)) return {
        state: this,
        transactions: []
      };
      var trs = [rootTr],
          newState = this.applyInner(rootTr),
          seen = null;

      for (;;) {
        var haveNew = false;

        for (var i = 0; i < this.config.plugins.length; i++) {
          var plugin = this.config.plugins[i];

          if (plugin.spec.appendTransaction) {
            var n = seen ? seen[i].n : 0,
                oldState = seen ? seen[i].state : this;
            var tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);

            if (tr && newState.filterTransaction(tr, i)) {
              tr.setMeta("appendedTransaction", rootTr);

              if (!seen) {
                seen = [];

                for (var j = 0; j < this.config.plugins.length; j++) {
                  seen.push(j < i ? {
                    state: newState,
                    n: trs.length
                  } : {
                    state: this,
                    n: 0
                  });
                }
              }

              trs.push(tr);
              newState = newState.applyInner(tr);
              haveNew = true;
            }

            if (seen) seen[i] = {
              state: newState,
              n: trs.length
            };
          }
        }

        if (!haveNew) return {
          state: newState,
          transactions: trs
        };
      }
    }
  }, {
    key: "applyInner",
    value: function applyInner(tr) {
      if (!tr.before.eq(this.doc)) throw new RangeError("Applying a mismatched transaction");
      var newInstance = new EditorState(this.config),
          fields = this.config.fields;

      for (var i = 0; i < fields.length; i++) {
        var field = fields[i];
        newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
      }

      return newInstance;
    }
  }, {
    key: "tr",
    get: function get() {
      return new Transaction(this);
    }
  }, {
    key: "reconfigure",
    value: function reconfigure(config) {
      var $config = new Configuration(this.schema, config.plugins);
      var fields = $config.fields,
          instance = new EditorState($config);

      for (var i = 0; i < fields.length; i++) {
        var name = fields[i].name;
        instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
      }

      return instance;
    }
  }, {
    key: "toJSON",
    value: function toJSON(pluginFields) {
      var result = {
        doc: this.doc.toJSON(),
        selection: this.selection.toJSON()
      };
      if (this.storedMarks) result.storedMarks = this.storedMarks.map(function (m) {
        return m.toJSON();
      });
      if (pluginFields && _typeof(pluginFields) == 'object') for (var prop in pluginFields) {
        if (prop == "doc" || prop == "selection") throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        var plugin = pluginFields[prop],
            state = plugin.spec.state;
        if (state && state.toJSON) result[prop] = state.toJSON.call(plugin, this[plugin.key]);
      }
      return result;
    }
  }], [{
    key: "create",
    value: function create(config) {
      var $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
      var instance = new EditorState($config);

      for (var i = 0; i < $config.fields.length; i++) {
        instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
      }

      return instance;
    }
  }, {
    key: "fromJSON",
    value: function fromJSON(config, json, pluginFields) {
      if (!json) throw new RangeError("Invalid input for EditorState.fromJSON");
      if (!config.schema) throw new RangeError("Required config field 'schema' missing");
      var $config = new Configuration(config.schema, config.plugins);
      var instance = new EditorState($config);
      $config.fields.forEach(function (field) {
        if (field.name == "doc") {
          instance.doc = prosemirrorModel.Node.fromJSON(config.schema, json.doc);
        } else if (field.name == "selection") {
          instance.selection = Selection.fromJSON(instance.doc, json.selection);
        } else if (field.name == "storedMarks") {
          if (json.storedMarks) instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
        } else {
          if (pluginFields) for (var prop in pluginFields) {
            var plugin = pluginFields[prop],
                state = plugin.spec.state;

            if (plugin.key == field.name && state && state.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);
              return;
            }
          }
          instance[field.name] = field.init(config, instance);
        }
      });
      return instance;
    }
  }]);

  return EditorState;
}();

function bindProps(obj, self, target) {
  for (var prop in obj) {
    var val = obj[prop];
    if (val instanceof Function) val = val.bind(self);else if (prop == "handleDOMEvents") val = bindProps(val, self, {});
    target[prop] = val;
  }

  return target;
}

var Plugin = function () {
  function Plugin(spec) {
    _classCallCheck(this, Plugin);

    this.spec = spec;
    this.props = {};
    if (spec.props) bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }

  _createClass(Plugin, [{
    key: "getState",
    value: function getState(state) {
      return state[this.key];
    }
  }]);

  return Plugin;
}();

var keys = Object.create(null);

function createKey(name) {
  if (name in keys) return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}

var PluginKey = function () {
  function PluginKey() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "key";

    _classCallCheck(this, PluginKey);

    this.key = createKey(name);
  }

  _createClass(PluginKey, [{
    key: "get",
    value: function get(state) {
      return state.config.pluginsByKey[this.key];
    }
  }, {
    key: "getState",
    value: function getState(state) {
      return state[this.key];
    }
  }]);

  return PluginKey;
}();

exports.AllSelection = AllSelection;
exports.EditorState = EditorState;
exports.NodeSelection = NodeSelection;
exports.Plugin = Plugin;
exports.PluginKey = PluginKey;
exports.Selection = Selection;
exports.SelectionRange = SelectionRange;
exports.TextSelection = TextSelection;
exports.Transaction = Transaction;


/***/ }),

/***/ "./node_modules/prosemirror-transform/dist/index.cjs":
/*!***********************************************************!*\
  !*** ./node_modules/prosemirror-transform/dist/index.cjs ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorModel = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.cjs");

var lower16 = 0xffff;
var factor16 = Math.pow(2, 16);

function makeRecover(index, offset) {
  return index + offset * factor16;
}

function recoverIndex(value) {
  return value & lower16;
}

function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}

var DEL_BEFORE = 1,
    DEL_AFTER = 2,
    DEL_ACROSS = 4,
    DEL_SIDE = 8;

var MapResult = function () {
  function MapResult(pos, delInfo, recover) {
    _classCallCheck(this, MapResult);

    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }

  _createClass(MapResult, [{
    key: "deleted",
    get: function get() {
      return (this.delInfo & DEL_SIDE) > 0;
    }
  }, {
    key: "deletedBefore",
    get: function get() {
      return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
    }
  }, {
    key: "deletedAfter",
    get: function get() {
      return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
    }
  }, {
    key: "deletedAcross",
    get: function get() {
      return (this.delInfo & DEL_ACROSS) > 0;
    }
  }]);

  return MapResult;
}();

var StepMap = function () {
  function StepMap(ranges) {
    var inverted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    _classCallCheck(this, StepMap);

    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && StepMap.empty) return StepMap.empty;
  }

  _createClass(StepMap, [{
    key: "recover",
    value: function recover(value) {
      var diff = 0,
          index = recoverIndex(value);
      if (!this.inverted) for (var i = 0; i < index; i++) {
        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
      }
      return this.ranges[index * 3] + diff + recoverOffset(value);
    }
  }, {
    key: "mapResult",
    value: function mapResult(pos) {
      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return this._map(pos, assoc, false);
    }
  }, {
    key: "map",
    value: function map(pos) {
      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return this._map(pos, assoc, true);
    }
  }, {
    key: "_map",
    value: function _map(pos, assoc, simple) {
      var diff = 0,
          oldIndex = this.inverted ? 2 : 1,
          newIndex = this.inverted ? 1 : 2;

      for (var i = 0; i < this.ranges.length; i += 3) {
        var start = this.ranges[i] - (this.inverted ? diff : 0);
        if (start > pos) break;
        var oldSize = this.ranges[i + oldIndex],
            newSize = this.ranges[i + newIndex],
            end = start + oldSize;

        if (pos <= end) {
          var side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
          var result = start + diff + (side < 0 ? 0 : newSize);
          if (simple) return result;
          var recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
          var del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
          if (assoc < 0 ? pos != start : pos != end) del |= DEL_SIDE;
          return new MapResult(result, del, recover);
        }

        diff += newSize - oldSize;
      }

      return simple ? pos + diff : new MapResult(pos + diff, 0, null);
    }
  }, {
    key: "touches",
    value: function touches(pos, recover) {
      var diff = 0,
          index = recoverIndex(recover);
      var oldIndex = this.inverted ? 2 : 1,
          newIndex = this.inverted ? 1 : 2;

      for (var i = 0; i < this.ranges.length; i += 3) {
        var start = this.ranges[i] - (this.inverted ? diff : 0);
        if (start > pos) break;
        var oldSize = this.ranges[i + oldIndex],
            end = start + oldSize;
        if (pos <= end && i == index * 3) return true;
        diff += this.ranges[i + newIndex] - oldSize;
      }

      return false;
    }
  }, {
    key: "forEach",
    value: function forEach(f) {
      var oldIndex = this.inverted ? 2 : 1,
          newIndex = this.inverted ? 1 : 2;

      for (var i = 0, diff = 0; i < this.ranges.length; i += 3) {
        var start = this.ranges[i],
            oldStart = start - (this.inverted ? diff : 0),
            newStart = start + (this.inverted ? 0 : diff);
        var oldSize = this.ranges[i + oldIndex],
            newSize = this.ranges[i + newIndex];
        f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
        diff += newSize - oldSize;
      }
    }
  }, {
    key: "invert",
    value: function invert() {
      return new StepMap(this.ranges, !this.inverted);
    }
  }, {
    key: "toString",
    value: function toString() {
      return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
    }
  }], [{
    key: "offset",
    value: function offset(n) {
      return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
    }
  }]);

  return StepMap;
}();

StepMap.empty = new StepMap([]);

var Mapping = function () {
  function Mapping() {
    var maps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var mirror = arguments.length > 1 ? arguments[1] : undefined;
    var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var to = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : maps.length;

    _classCallCheck(this, Mapping);

    this.maps = maps;
    this.mirror = mirror;
    this.from = from;
    this.to = to;
  }

  _createClass(Mapping, [{
    key: "slice",
    value: function slice() {
      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.maps.length;
      return new Mapping(this.maps, this.mirror, from, to);
    }
  }, {
    key: "copy",
    value: function copy() {
      return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
    }
  }, {
    key: "appendMap",
    value: function appendMap(map, mirrors) {
      this.to = this.maps.push(map);
      if (mirrors != null) this.setMirror(this.maps.length - 1, mirrors);
    }
  }, {
    key: "appendMapping",
    value: function appendMapping(mapping) {
      for (var i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {
        var mirr = mapping.getMirror(i);
        this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : undefined);
      }
    }
  }, {
    key: "getMirror",
    value: function getMirror(n) {
      if (this.mirror) for (var i = 0; i < this.mirror.length; i++) {
        if (this.mirror[i] == n) return this.mirror[i + (i % 2 ? -1 : 1)];
      }
    }
  }, {
    key: "setMirror",
    value: function setMirror(n, m) {
      if (!this.mirror) this.mirror = [];
      this.mirror.push(n, m);
    }
  }, {
    key: "appendMappingInverted",
    value: function appendMappingInverted(mapping) {
      for (var i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {
        var mirr = mapping.getMirror(i);
        this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : undefined);
      }
    }
  }, {
    key: "invert",
    value: function invert() {
      var inverse = new Mapping();
      inverse.appendMappingInverted(this);
      return inverse;
    }
  }, {
    key: "map",
    value: function map(pos) {
      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      if (this.mirror) return this._map(pos, assoc, true);

      for (var i = this.from; i < this.to; i++) {
        pos = this.maps[i].map(pos, assoc);
      }

      return pos;
    }
  }, {
    key: "mapResult",
    value: function mapResult(pos) {
      var assoc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return this._map(pos, assoc, false);
    }
  }, {
    key: "_map",
    value: function _map(pos, assoc, simple) {
      var delInfo = 0;

      for (var i = this.from; i < this.to; i++) {
        var map = this.maps[i],
            result = map.mapResult(pos, assoc);

        if (result.recover != null) {
          var corr = this.getMirror(i);

          if (corr != null && corr > i && corr < this.to) {
            i = corr;
            pos = this.maps[corr].recover(result.recover);
            continue;
          }
        }

        delInfo |= result.delInfo;
        pos = result.pos;
      }

      return simple ? pos : new MapResult(pos, delInfo, null);
    }
  }]);

  return Mapping;
}();

var stepsByID = Object.create(null);

var Step = function () {
  function Step() {
    _classCallCheck(this, Step);
  }

  _createClass(Step, [{
    key: "getMap",
    value: function getMap() {
      return StepMap.empty;
    }
  }, {
    key: "merge",
    value: function merge(other) {
      return null;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (!json || !json.stepType) throw new RangeError("Invalid input for Step.fromJSON");
      var type = stepsByID[json.stepType];
      if (!type) throw new RangeError("No step type ".concat(json.stepType, " defined"));
      return type.fromJSON(schema, json);
    }
  }, {
    key: "jsonID",
    value: function jsonID(id, stepClass) {
      if (id in stepsByID) throw new RangeError("Duplicate use of step JSON ID " + id);
      stepsByID[id] = stepClass;
      stepClass.prototype.jsonID = id;
      return stepClass;
    }
  }]);

  return Step;
}();

var StepResult = function () {
  function StepResult(doc, failed) {
    _classCallCheck(this, StepResult);

    this.doc = doc;
    this.failed = failed;
  }

  _createClass(StepResult, null, [{
    key: "ok",
    value: function ok(doc) {
      return new StepResult(doc, null);
    }
  }, {
    key: "fail",
    value: function fail(message) {
      return new StepResult(null, message);
    }
  }, {
    key: "fromReplace",
    value: function fromReplace(doc, from, to, slice) {
      try {
        return StepResult.ok(doc.replace(from, to, slice));
      } catch (e) {
        if (e instanceof prosemirrorModel.ReplaceError) return StepResult.fail(e.message);
        throw e;
      }
    }
  }]);

  return StepResult;
}();

function mapFragment(fragment, f, parent) {
  var mapped = [];

  for (var i = 0; i < fragment.childCount; i++) {
    var child = fragment.child(i);
    if (child.content.size) child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline) child = f(child, parent, i);
    mapped.push(child);
  }

  return prosemirrorModel.Fragment.fromArray(mapped);
}

var AddMarkStep = function (_Step) {
  _inherits(AddMarkStep, _Step);

  var _super = _createSuper(AddMarkStep);

  function AddMarkStep(from, to, mark) {
    var _this;

    _classCallCheck(this, AddMarkStep);

    _this = _super.call(this);
    _this.from = from;
    _this.to = to;
    _this.mark = mark;
    return _this;
  }

  _createClass(AddMarkStep, [{
    key: "apply",
    value: function apply(doc) {
      var _this2 = this;

      var oldSlice = doc.slice(this.from, this.to),
          $from = doc.resolve(this.from);
      var parent = $from.node($from.sharedDepth(this.to));
      var slice = new prosemirrorModel.Slice(mapFragment(oldSlice.content, function (node, parent) {
        if (!node.isAtom || !parent.type.allowsMarkType(_this2.mark.type)) return node;
        return node.mark(_this2.mark.addToSet(node.marks));
      }, parent), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc, this.from, this.to, slice);
    }
  }, {
    key: "invert",
    value: function invert() {
      return new RemoveMarkStep(this.from, this.to, this.mark);
    }
  }, {
    key: "map",
    value: function map(mapping) {
      var from = mapping.mapResult(this.from, 1),
          to = mapping.mapResult(this.to, -1);
      if (from.deleted && to.deleted || from.pos >= to.pos) return null;
      return new AddMarkStep(from.pos, to.pos, this.mark);
    }
  }, {
    key: "merge",
    value: function merge(other) {
      if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      return null;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        stepType: "addMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number") throw new RangeError("Invalid input for AddMarkStep.fromJSON");
      return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
    }
  }]);

  return AddMarkStep;
}(Step);

Step.jsonID("addMark", AddMarkStep);

var RemoveMarkStep = function (_Step2) {
  _inherits(RemoveMarkStep, _Step2);

  var _super2 = _createSuper(RemoveMarkStep);

  function RemoveMarkStep(from, to, mark) {
    var _this3;

    _classCallCheck(this, RemoveMarkStep);

    _this3 = _super2.call(this);
    _this3.from = from;
    _this3.to = to;
    _this3.mark = mark;
    return _this3;
  }

  _createClass(RemoveMarkStep, [{
    key: "apply",
    value: function apply(doc) {
      var _this4 = this;

      var oldSlice = doc.slice(this.from, this.to);
      var slice = new prosemirrorModel.Slice(mapFragment(oldSlice.content, function (node) {
        return node.mark(_this4.mark.removeFromSet(node.marks));
      }, doc), oldSlice.openStart, oldSlice.openEnd);
      return StepResult.fromReplace(doc, this.from, this.to, slice);
    }
  }, {
    key: "invert",
    value: function invert() {
      return new AddMarkStep(this.from, this.to, this.mark);
    }
  }, {
    key: "map",
    value: function map(mapping) {
      var from = mapping.mapResult(this.from, 1),
          to = mapping.mapResult(this.to, -1);
      if (from.deleted && to.deleted || from.pos >= to.pos) return null;
      return new RemoveMarkStep(from.pos, to.pos, this.mark);
    }
  }, {
    key: "merge",
    value: function merge(other) {
      if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
      return null;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        stepType: "removeMark",
        mark: this.mark.toJSON(),
        from: this.from,
        to: this.to
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number") throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
      return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
    }
  }]);

  return RemoveMarkStep;
}(Step);

Step.jsonID("removeMark", RemoveMarkStep);

var AddNodeMarkStep = function (_Step3) {
  _inherits(AddNodeMarkStep, _Step3);

  var _super3 = _createSuper(AddNodeMarkStep);

  function AddNodeMarkStep(pos, mark) {
    var _this5;

    _classCallCheck(this, AddNodeMarkStep);

    _this5 = _super3.call(this);
    _this5.pos = pos;
    _this5.mark = mark;
    return _this5;
  }

  _createClass(AddNodeMarkStep, [{
    key: "apply",
    value: function apply(doc) {
      var node = doc.nodeAt(this.pos);
      if (!node) return StepResult.fail("No node at mark step's position");
      var updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
      return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
    }
  }, {
    key: "invert",
    value: function invert(doc) {
      var node = doc.nodeAt(this.pos);

      if (node) {
        var newSet = this.mark.addToSet(node.marks);

        if (newSet.length == node.marks.length) {
          for (var i = 0; i < node.marks.length; i++) {
            if (!node.marks[i].isInSet(newSet)) return new AddNodeMarkStep(this.pos, node.marks[i]);
          }

          return new AddNodeMarkStep(this.pos, this.mark);
        }
      }

      return new RemoveNodeMarkStep(this.pos, this.mark);
    }
  }, {
    key: "map",
    value: function map(mapping) {
      var pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        stepType: "addNodeMark",
        pos: this.pos,
        mark: this.mark.toJSON()
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (typeof json.pos != "number") throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
      return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
    }
  }]);

  return AddNodeMarkStep;
}(Step);

Step.jsonID("addNodeMark", AddNodeMarkStep);

var RemoveNodeMarkStep = function (_Step4) {
  _inherits(RemoveNodeMarkStep, _Step4);

  var _super4 = _createSuper(RemoveNodeMarkStep);

  function RemoveNodeMarkStep(pos, mark) {
    var _this6;

    _classCallCheck(this, RemoveNodeMarkStep);

    _this6 = _super4.call(this);
    _this6.pos = pos;
    _this6.mark = mark;
    return _this6;
  }

  _createClass(RemoveNodeMarkStep, [{
    key: "apply",
    value: function apply(doc) {
      var node = doc.nodeAt(this.pos);
      if (!node) return StepResult.fail("No node at mark step's position");
      var updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
      return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
    }
  }, {
    key: "invert",
    value: function invert(doc) {
      var node = doc.nodeAt(this.pos);
      if (!node || !this.mark.isInSet(node.marks)) return this;
      return new AddNodeMarkStep(this.pos, this.mark);
    }
  }, {
    key: "map",
    value: function map(mapping) {
      var pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        stepType: "removeNodeMark",
        pos: this.pos,
        mark: this.mark.toJSON()
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (typeof json.pos != "number") throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
      return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
    }
  }]);

  return RemoveNodeMarkStep;
}(Step);

Step.jsonID("removeNodeMark", RemoveNodeMarkStep);

var ReplaceStep = function (_Step5) {
  _inherits(ReplaceStep, _Step5);

  var _super5 = _createSuper(ReplaceStep);

  function ReplaceStep(from, to, slice) {
    var _this7;

    var structure = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    _classCallCheck(this, ReplaceStep);

    _this7 = _super5.call(this);
    _this7.from = from;
    _this7.to = to;
    _this7.slice = slice;
    _this7.structure = structure;
    return _this7;
  }

  _createClass(ReplaceStep, [{
    key: "apply",
    value: function apply(doc) {
      if (this.structure && contentBetween(doc, this.from, this.to)) return StepResult.fail("Structure replace would overwrite content");
      return StepResult.fromReplace(doc, this.from, this.to, this.slice);
    }
  }, {
    key: "getMap",
    value: function getMap() {
      return new StepMap([this.from, this.to - this.from, this.slice.size]);
    }
  }, {
    key: "invert",
    value: function invert(doc) {
      return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));
    }
  }, {
    key: "map",
    value: function map(mapping) {
      var from = mapping.mapResult(this.from, 1),
          to = mapping.mapResult(this.to, -1);
      if (from.deletedAcross && to.deletedAcross) return null;
      return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice);
    }
  }, {
    key: "merge",
    value: function merge(other) {
      if (!(other instanceof ReplaceStep) || other.structure || this.structure) return null;

      if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
        var slice = this.slice.size + other.slice.size == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
        return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);
      } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
        var _slice = this.slice.size + other.slice.size == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);

        return new ReplaceStep(other.from, this.to, _slice, this.structure);
      } else {
        return null;
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = {
        stepType: "replace",
        from: this.from,
        to: this.to
      };
      if (this.slice.size) json.slice = this.slice.toJSON();
      if (this.structure) json.structure = true;
      return json;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number") throw new RangeError("Invalid input for ReplaceStep.fromJSON");
      return new ReplaceStep(json.from, json.to, prosemirrorModel.Slice.fromJSON(schema, json.slice), !!json.structure);
    }
  }]);

  return ReplaceStep;
}(Step);

Step.jsonID("replace", ReplaceStep);

var ReplaceAroundStep = function (_Step6) {
  _inherits(ReplaceAroundStep, _Step6);

  var _super6 = _createSuper(ReplaceAroundStep);

  function ReplaceAroundStep(from, to, gapFrom, gapTo, slice, insert) {
    var _this8;

    var structure = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;

    _classCallCheck(this, ReplaceAroundStep);

    _this8 = _super6.call(this);
    _this8.from = from;
    _this8.to = to;
    _this8.gapFrom = gapFrom;
    _this8.gapTo = gapTo;
    _this8.slice = slice;
    _this8.insert = insert;
    _this8.structure = structure;
    return _this8;
  }

  _createClass(ReplaceAroundStep, [{
    key: "apply",
    value: function apply(doc) {
      if (this.structure && (contentBetween(doc, this.from, this.gapFrom) || contentBetween(doc, this.gapTo, this.to))) return StepResult.fail("Structure gap-replace would overwrite content");
      var gap = doc.slice(this.gapFrom, this.gapTo);
      if (gap.openStart || gap.openEnd) return StepResult.fail("Gap is not a flat range");
      var inserted = this.slice.insertAt(this.insert, gap.content);
      if (!inserted) return StepResult.fail("Content does not fit in gap");
      return StepResult.fromReplace(doc, this.from, this.to, inserted);
    }
  }, {
    key: "getMap",
    value: function getMap() {
      return new StepMap([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);
    }
  }, {
    key: "invert",
    value: function invert(doc) {
      var gap = this.gapTo - this.gapFrom;
      return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
    }
  }, {
    key: "map",
    value: function map(mapping) {
      var from = mapping.mapResult(this.from, 1),
          to = mapping.mapResult(this.to, -1);
      var gapFrom = mapping.map(this.gapFrom, -1),
          gapTo = mapping.map(this.gapTo, 1);
      if (from.deletedAcross && to.deletedAcross || gapFrom < from.pos || gapTo > to.pos) return null;
      return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = {
        stepType: "replaceAround",
        from: this.from,
        to: this.to,
        gapFrom: this.gapFrom,
        gapTo: this.gapTo,
        insert: this.insert
      };
      if (this.slice.size) json.slice = this.slice.toJSON();
      if (this.structure) json.structure = true;
      return json;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number") throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
      return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, prosemirrorModel.Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
    }
  }]);

  return ReplaceAroundStep;
}(Step);

Step.jsonID("replaceAround", ReplaceAroundStep);

function contentBetween(doc, from, to) {
  var $from = doc.resolve(from),
      dist = to - from,
      depth = $from.depth;

  while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist--;
  }

  if (dist > 0) {
    var next = $from.node(depth).maybeChild($from.indexAfter(depth));

    while (dist > 0) {
      if (!next || next.isLeaf) return true;
      next = next.firstChild;
      dist--;
    }
  }

  return false;
}

function _addMark(tr, from, to, mark) {
  var removed = [],
      added = [];
  var removing, adding;
  tr.doc.nodesBetween(from, to, function (node, pos, parent) {
    if (!node.isInline) return;
    var marks = node.marks;

    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      var start = Math.max(pos, from),
          end = Math.min(pos + node.nodeSize, to);
      var newSet = mark.addToSet(marks);

      for (var i = 0; i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start && removing.mark.eq(marks[i])) removing.to = end;else removed.push(removing = new RemoveMarkStep(start, end, marks[i]));
        }
      }

      if (adding && adding.to == start) adding.to = end;else added.push(adding = new AddMarkStep(start, end, mark));
    }
  });
  removed.forEach(function (s) {
    return tr.step(s);
  });
  added.forEach(function (s) {
    return tr.step(s);
  });
}

function _removeMark(tr, from, to, mark) {
  var matched = [],
      step = 0;
  tr.doc.nodesBetween(from, to, function (node, pos) {
    if (!node.isInline) return;
    step++;
    var toRemove = null;

    if (mark instanceof prosemirrorModel.MarkType) {
      var set = node.marks,
          found;

      while (found = mark.isInSet(set)) {
        (toRemove || (toRemove = [])).push(found);
        set = found.removeFromSet(set);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks)) toRemove = [mark];
    } else {
      toRemove = node.marks;
    }

    if (toRemove && toRemove.length) {
      var end = Math.min(pos + node.nodeSize, to);

      for (var i = 0; i < toRemove.length; i++) {
        var style = toRemove[i],
            _found = void 0;

        for (var j = 0; j < matched.length; j++) {
          var m = matched[j];
          if (m.step == step - 1 && style.eq(matched[j].style)) _found = m;
        }

        if (_found) {
          _found.to = end;
          _found.step = step;
        } else {
          matched.push({
            style: style,
            from: Math.max(pos, from),
            to: end,
            step: step
          });
        }
      }
    }
  });
  matched.forEach(function (m) {
    return tr.step(new RemoveMarkStep(m.from, m.to, m.style));
  });
}

function _clearIncompatible(tr, pos, parentType) {
  var match = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : parentType.contentMatch;
  var node = tr.doc.nodeAt(pos);
  var delSteps = [],
      cur = pos + 1;

  for (var i = 0; i < node.childCount; i++) {
    var child = node.child(i),
        end = cur + child.nodeSize;
    var allowed = match.matchType(child.type);

    if (!allowed) {
      delSteps.push(new ReplaceStep(cur, end, prosemirrorModel.Slice.empty));
    } else {
      match = allowed;

      for (var j = 0; j < child.marks.length; j++) {
        if (!parentType.allowsMarkType(child.marks[j].type)) tr.step(new RemoveMarkStep(cur, end, child.marks[j]));
      }
    }

    cur = end;
  }

  if (!match.validEnd) {
    var fill = match.fillBefore(prosemirrorModel.Fragment.empty, true);
    tr.replace(cur, cur, new prosemirrorModel.Slice(fill, 0, 0));
  }

  for (var _i = delSteps.length - 1; _i >= 0; _i--) {
    tr.step(delSteps[_i]);
  }
}

function canCut(node, start, end) {
  return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
}

function liftTarget(range) {
  var parent = range.parent;
  var content = parent.content.cutByIndex(range.startIndex, range.endIndex);

  for (var depth = range.depth;; --depth) {
    var node = range.$from.node(depth);
    var index = range.$from.index(depth),
        endIndex = range.$to.indexAfter(depth);
    if (depth < range.depth && node.canReplace(index, endIndex, content)) return depth;
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) break;
  }

  return null;
}

function _lift(tr, range, target) {
  var $from = range.$from,
      $to = range.$to,
      depth = range.depth;
  var gapStart = $from.before(depth + 1),
      gapEnd = $to.after(depth + 1);
  var start = gapStart,
      end = gapEnd;
  var before = prosemirrorModel.Fragment.empty,
      openStart = 0;

  for (var d = depth, splitting = false; d > target; d--) {
    if (splitting || $from.index(d) > 0) {
      splitting = true;
      before = prosemirrorModel.Fragment.from($from.node(d).copy(before));
      openStart++;
    } else {
      start--;
    }
  }

  var after = prosemirrorModel.Fragment.empty,
      openEnd = 0;

  for (var _d = depth, _splitting = false; _d > target; _d--) {
    if (_splitting || $to.after(_d + 1) < $to.end(_d)) {
      _splitting = true;
      after = prosemirrorModel.Fragment.from($to.node(_d).copy(after));
      openEnd++;
    } else {
      end++;
    }
  }

  tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new prosemirrorModel.Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}

function findWrapping(range, nodeType) {
  var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var innerRange = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : range;
  var around = findWrappingOutside(range, nodeType);
  var inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner) return null;
  return around.map(withAttrs).concat({
    type: nodeType,
    attrs: attrs
  }).concat(inner.map(withAttrs));
}

function withAttrs(type) {
  return {
    type: type,
    attrs: null
  };
}

function findWrappingOutside(range, type) {
  var parent = range.parent,
      startIndex = range.startIndex,
      endIndex = range.endIndex;
  var around = parent.contentMatchAt(startIndex).findWrapping(type);
  if (!around) return null;
  var outer = around.length ? around[0] : type;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}

function findWrappingInside(range, type) {
  var parent = range.parent,
      startIndex = range.startIndex,
      endIndex = range.endIndex;
  var inner = parent.child(startIndex);
  var inside = type.contentMatch.findWrapping(inner.type);
  if (!inside) return null;
  var lastType = inside.length ? inside[inside.length - 1] : type;
  var innerMatch = lastType.contentMatch;

  for (var i = startIndex; innerMatch && i < endIndex; i++) {
    innerMatch = innerMatch.matchType(parent.child(i).type);
  }

  if (!innerMatch || !innerMatch.validEnd) return null;
  return inside;
}

function _wrap2(tr, range, wrappers) {
  var content = prosemirrorModel.Fragment.empty;

  for (var i = wrappers.length - 1; i >= 0; i--) {
    if (content.size) {
      var match = wrappers[i].type.contentMatch.matchFragment(content);
      if (!match || !match.validEnd) throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }

    content = prosemirrorModel.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  }

  var start = range.start,
      end = range.end;
  tr.step(new ReplaceAroundStep(start, end, start, end, new prosemirrorModel.Slice(content, 0, 0), wrappers.length, true));
}

function _setBlockType(tr, from, to, type, attrs) {
  if (!type.isTextblock) throw new RangeError("Type given to setBlockType should be a textblock");
  var mapFrom = tr.steps.length;
  tr.doc.nodesBetween(from, to, function (node, pos) {
    if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {
      tr.clearIncompatible(tr.mapping.slice(mapFrom).map(pos, 1), type);
      var mapping = tr.mapping.slice(mapFrom);
      var startM = mapping.map(pos, 1),
          endM = mapping.map(pos + node.nodeSize, 1);
      tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));
      return false;
    }
  });
}

function canChangeType(doc, pos, type) {
  var $pos = doc.resolve(pos),
      index = $pos.index();
  return $pos.parent.canReplaceWith(index, index + 1, type);
}

function _setNodeMarkup(tr, pos, type, attrs, marks) {
  var node = tr.doc.nodeAt(pos);
  if (!node) throw new RangeError("No node at given position");
  if (!type) type = node.type;
  var newNode = type.create(attrs, null, marks || node.marks);
  if (node.isLeaf) return tr.replaceWith(pos, pos + node.nodeSize, newNode);
  if (!type.validContent(node.content)) throw new RangeError("Invalid content for node type " + type.name);
  tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(newNode), 0, 0), 1, true));
}

function canSplit(doc, pos) {
  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var typesAfter = arguments.length > 3 ? arguments[3] : undefined;
  var $pos = doc.resolve(pos),
      base = $pos.depth - depth;
  var innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) return false;

  for (var d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {
    var node = $pos.node(d),
        _index = $pos.index(d);

    if (node.type.spec.isolating) return false;
    var rest = node.content.cutByIndex(_index, node.childCount);
    var overrideChild = typesAfter && typesAfter[i + 1];
    if (overrideChild) rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
    var after = typesAfter && typesAfter[i] || node;
    if (!node.canReplace(_index + 1, node.childCount) || !after.type.validContent(rest)) return false;
  }

  var index = $pos.indexAfter(base);
  var baseType = typesAfter && typesAfter[0];
  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);
}

function _split(tr, pos) {
  var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var typesAfter = arguments.length > 3 ? arguments[3] : undefined;
  var $pos = tr.doc.resolve(pos),
      before = prosemirrorModel.Fragment.empty,
      after = prosemirrorModel.Fragment.empty;

  for (var d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {
    before = prosemirrorModel.Fragment.from($pos.node(d).copy(before));
    var typeAfter = typesAfter && typesAfter[i];
    after = prosemirrorModel.Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));
  }

  tr.step(new ReplaceStep(pos, pos, new prosemirrorModel.Slice(before.append(after), depth, depth), true));
}

function canJoin(doc, pos) {
  var $pos = doc.resolve(pos),
      index = $pos.index();
  return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
}

function joinable(a, b) {
  return !!(a && b && !a.isLeaf && a.canAppend(b));
}

function joinPoint(doc, pos) {
  var dir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
  var $pos = doc.resolve(pos);

  for (var d = $pos.depth;; d--) {
    var before = void 0,
        after = void 0,
        index = $pos.index(d);

    if (d == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d + 1);
      index++;
      after = $pos.node(d).maybeChild(index);
    } else {
      before = $pos.node(d).maybeChild(index - 1);
      after = $pos.node(d + 1);
    }

    if (before && !before.isTextblock && joinable(before, after) && $pos.node(d).canReplace(index, index + 1)) return pos;
    if (d == 0) break;
    pos = dir < 0 ? $pos.before(d) : $pos.after(d);
  }
}

function _join(tr, pos, depth) {
  var step = new ReplaceStep(pos - depth, pos + depth, prosemirrorModel.Slice.empty, true);
  tr.step(step);
}

function insertPoint(doc, pos, nodeType) {
  var $pos = doc.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) return pos;
  if ($pos.parentOffset == 0) for (var d = $pos.depth - 1; d >= 0; d--) {
    var index = $pos.index(d);
    if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.before(d + 1);
    if (index > 0) return null;
  }
  if ($pos.parentOffset == $pos.parent.content.size) for (var _d2 = $pos.depth - 1; _d2 >= 0; _d2--) {
    var _index2 = $pos.indexAfter(_d2);

    if ($pos.node(_d2).canReplaceWith(_index2, _index2, nodeType)) return $pos.after(_d2 + 1);
    if (_index2 < $pos.node(_d2).childCount) return null;
  }
  return null;
}

function dropPoint(doc, pos, slice) {
  var $pos = doc.resolve(pos);
  if (!slice.content.size) return pos;
  var content = slice.content;

  for (var i = 0; i < slice.openStart; i++) {
    content = content.firstChild.content;
  }

  for (var pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {
    for (var d = $pos.depth; d >= 0; d--) {
      var bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;
      var insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);
      var parent = $pos.node(d),
          fits = false;

      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        var wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }

      if (fits) return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);
    }
  }

  return null;
}

function replaceStep(doc, from) {
  var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : from;
  var slice = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : prosemirrorModel.Slice.empty;
  if (from == to && !slice.size) return null;
  var $from = doc.resolve(from),
      $to = doc.resolve(to);
  if (fitsTrivially($from, $to, slice)) return new ReplaceStep(from, to, slice);
  return new Fitter($from, $to, slice).fit();
}

function fitsTrivially($from, $to, slice) {
  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);
}

var Fitter = function () {
  function Fitter($from, $to, unplaced) {
    _classCallCheck(this, Fitter);

    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = prosemirrorModel.Fragment.empty;

    for (var i = 0; i <= $from.depth; i++) {
      var node = $from.node(i);
      this.frontier.push({
        type: node.type,
        match: node.contentMatchAt($from.indexAfter(i))
      });
    }

    for (var _i2 = $from.depth; _i2 > 0; _i2--) {
      this.placed = prosemirrorModel.Fragment.from($from.node(_i2).copy(this.placed));
    }
  }

  _createClass(Fitter, [{
    key: "depth",
    get: function get() {
      return this.frontier.length - 1;
    }
  }, {
    key: "fit",
    value: function fit() {
      while (this.unplaced.size) {
        var fit = this.findFittable();
        if (fit) this.placeNodes(fit);else this.openMore() || this.dropNode();
      }

      var moveInline = this.mustMoveInline(),
          placedSize = this.placed.size - this.depth - this.$from.depth;
      var $from = this.$from,
          $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
      if (!$to) return null;
      var content = this.placed,
          openStart = $from.depth,
          openEnd = $to.depth;

      while (openStart && openEnd && content.childCount == 1) {
        content = content.firstChild.content;
        openStart--;
        openEnd--;
      }

      var slice = new prosemirrorModel.Slice(content, openStart, openEnd);
      if (moveInline > -1) return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);
      if (slice.size || $from.pos != this.$to.pos) return new ReplaceStep($from.pos, $to.pos, slice);
      return null;
    }
  }, {
    key: "findFittable",
    value: function findFittable() {
      var startDepth = this.unplaced.openStart;

      for (var cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {
        var node = cur.firstChild;
        if (cur.childCount > 1) openEnd = 0;

        if (node.type.spec.isolating && openEnd <= d) {
          startDepth = d;
          break;
        }

        cur = node.content;
      }

      for (var pass = 1; pass <= 2; pass++) {
        for (var sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
          var fragment = void 0,
              parent = null;

          if (sliceDepth) {
            parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
            fragment = parent.content;
          } else {
            fragment = this.unplaced.content;
          }

          var first = fragment.firstChild;

          for (var frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
            var _this$frontier$fronti = this.frontier[frontierDepth],
                type = _this$frontier$fronti.type,
                match = _this$frontier$fronti.match,
                _wrap = void 0,
                inject = null;

            if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(prosemirrorModel.Fragment.from(first), false)) : parent && type.compatibleContent(parent.type))) return {
              sliceDepth: sliceDepth,
              frontierDepth: frontierDepth,
              parent: parent,
              inject: inject
            };else if (pass == 2 && first && (_wrap = match.findWrapping(first.type))) return {
              sliceDepth: sliceDepth,
              frontierDepth: frontierDepth,
              parent: parent,
              wrap: _wrap
            };
            if (parent && match.matchType(parent.type)) break;
          }
        }
      }
    }
  }, {
    key: "openMore",
    value: function openMore() {
      var _this$unplaced = this.unplaced,
          content = _this$unplaced.content,
          openStart = _this$unplaced.openStart,
          openEnd = _this$unplaced.openEnd;
      var inner = contentAt(content, openStart);
      if (!inner.childCount || inner.firstChild.isLeaf) return false;
      this.unplaced = new prosemirrorModel.Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
      return true;
    }
  }, {
    key: "dropNode",
    value: function dropNode() {
      var _this$unplaced2 = this.unplaced,
          content = _this$unplaced2.content,
          openStart = _this$unplaced2.openStart,
          openEnd = _this$unplaced2.openEnd;
      var inner = contentAt(content, openStart);

      if (inner.childCount <= 1 && openStart > 0) {
        var openAtEnd = content.size - openStart <= openStart + inner.size;
        this.unplaced = new prosemirrorModel.Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
      } else {
        this.unplaced = new prosemirrorModel.Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
      }
    }
  }, {
    key: "placeNodes",
    value: function placeNodes(_ref) {
      var sliceDepth = _ref.sliceDepth,
          frontierDepth = _ref.frontierDepth,
          parent = _ref.parent,
          inject = _ref.inject,
          wrap = _ref.wrap;

      while (this.depth > frontierDepth) {
        this.closeFrontierNode();
      }

      if (wrap) for (var i = 0; i < wrap.length; i++) {
        this.openFrontierNode(wrap[i]);
      }
      var slice = this.unplaced,
          fragment = parent ? parent.content : slice.content;
      var openStart = slice.openStart - sliceDepth;
      var taken = 0,
          add = [];
      var _this$frontier$fronti2 = this.frontier[frontierDepth],
          match = _this$frontier$fronti2.match,
          type = _this$frontier$fronti2.type;

      if (inject) {
        for (var i = 0; i < inject.childCount; i++) {
          add.push(inject.child(i));
        }

        match = match.matchFragment(inject);
      }

      var openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd);

      while (taken < fragment.childCount) {
        var next = fragment.child(taken),
            matches = match.matchType(next.type);
        if (!matches) break;
        taken++;

        if (taken > 1 || openStart == 0 || next.content.size) {
          match = matches;
          add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
        }
      }

      var toEnd = taken == fragment.childCount;
      if (!toEnd) openEndCount = -1;
      this.placed = addToFragment(this.placed, frontierDepth, prosemirrorModel.Fragment.from(add));
      this.frontier[frontierDepth].match = match;
      if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) this.closeFrontierNode();

      for (var _i3 = 0, cur = fragment; _i3 < openEndCount; _i3++) {
        var node = cur.lastChild;
        this.frontier.push({
          type: node.type,
          match: node.contentMatchAt(node.childCount)
        });
        cur = node.content;
      }

      this.unplaced = !toEnd ? new prosemirrorModel.Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? prosemirrorModel.Slice.empty : new prosemirrorModel.Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);
    }
  }, {
    key: "mustMoveInline",
    value: function mustMoveInline() {
      if (!this.$to.parent.isTextblock) return -1;
      var top = this.frontier[this.depth],
          level;
      if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) return -1;
      var depth = this.$to.depth,
          after = this.$to.after(depth);

      while (depth > 1 && after == this.$to.end(--depth)) {
        ++after;
      }

      return after;
    }
  }, {
    key: "findCloseLevel",
    value: function findCloseLevel($to) {
      scan: for (var i = Math.min(this.depth, $to.depth); i >= 0; i--) {
        var _this$frontier$i = this.frontier[i],
            match = _this$frontier$i.match,
            type = _this$frontier$i.type;
        var dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
        var fit = contentAfterFits($to, i, type, match, dropInner);
        if (!fit) continue;

        for (var d = i - 1; d >= 0; d--) {
          var _this$frontier$d = this.frontier[d],
              _match = _this$frontier$d.match,
              _type = _this$frontier$d.type;
          var matches = contentAfterFits($to, d, _type, _match, true);
          if (!matches || matches.childCount) continue scan;
        }

        return {
          depth: i,
          fit: fit,
          move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to
        };
      }
    }
  }, {
    key: "close",
    value: function close($to) {
      var close = this.findCloseLevel($to);
      if (!close) return null;

      while (this.depth > close.depth) {
        this.closeFrontierNode();
      }

      if (close.fit.childCount) this.placed = addToFragment(this.placed, close.depth, close.fit);
      $to = close.move;

      for (var d = close.depth + 1; d <= $to.depth; d++) {
        var node = $to.node(d),
            add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));
        this.openFrontierNode(node.type, node.attrs, add);
      }

      return $to;
    }
  }, {
    key: "openFrontierNode",
    value: function openFrontierNode(type) {
      var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var content = arguments.length > 2 ? arguments[2] : undefined;
      var top = this.frontier[this.depth];
      top.match = top.match.matchType(type);
      this.placed = addToFragment(this.placed, this.depth, prosemirrorModel.Fragment.from(type.create(attrs, content)));
      this.frontier.push({
        type: type,
        match: type.contentMatch
      });
    }
  }, {
    key: "closeFrontierNode",
    value: function closeFrontierNode() {
      var open = this.frontier.pop();
      var add = open.match.fillBefore(prosemirrorModel.Fragment.empty, true);
      if (add.childCount) this.placed = addToFragment(this.placed, this.frontier.length, add);
    }
  }]);

  return Fitter;
}();

function dropFromFragment(fragment, depth, count) {
  if (depth == 0) return fragment.cutByIndex(count, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}

function addToFragment(fragment, depth, content) {
  if (depth == 0) return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}

function contentAt(fragment, depth) {
  for (var i = 0; i < depth; i++) {
    fragment = fragment.firstChild.content;
  }

  return fragment;
}

function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0) return node;
  var frag = node.content;
  if (openStart > 1) frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));

  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0) frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(prosemirrorModel.Fragment.empty, true));
  }

  return node.copy(frag);
}

function contentAfterFits($to, depth, type, match, open) {
  var node = $to.node(depth),
      index = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index == node.childCount && !type.compatibleContent(node.type)) return null;
  var fit = match.fillBefore(node.content, true, index);
  return fit && !invalidMarks(type, node.content, index) ? fit : null;
}

function invalidMarks(type, fragment, start) {
  for (var i = start; i < fragment.childCount; i++) {
    if (!type.allowsMarks(fragment.child(i).marks)) return true;
  }

  return false;
}

function definesContent(type) {
  return type.spec.defining || type.spec.definingForContent;
}

function _replaceRange(tr, from, to, slice) {
  if (!slice.size) return tr.deleteRange(from, to);
  var $from = tr.doc.resolve(from),
      $to = tr.doc.resolve(to);
  if (fitsTrivially($from, $to, slice)) return tr.step(new ReplaceStep(from, to, slice));
  var targetDepths = coveredDepths($from, tr.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0) targetDepths.pop();
  var preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);

  for (var d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {
    var spec = $from.node(d).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating) break;
    if (targetDepths.indexOf(d) > -1) preferredTarget = d;else if ($from.before(d) == pos) targetDepths.splice(1, 0, -d);
  }

  var preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  var leftNodes = [],
      preferredDepth = slice.openStart;

  for (var content = slice.content, i = 0;; i++) {
    var node = content.firstChild;
    leftNodes.push(node);
    if (i == slice.openStart) break;
    content = node.content;
  }

  for (var _d3 = preferredDepth - 1; _d3 >= 0; _d3--) {
    var type = leftNodes[_d3].type,
        def = definesContent(type);
    if (def && $from.node(preferredTargetIndex).type != type) preferredDepth = _d3;else if (def || !type.isTextblock) break;
  }

  for (var j = slice.openStart; j >= 0; j--) {
    var openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);
    var insert = leftNodes[openDepth];
    if (!insert) continue;

    for (var _i4 = 0; _i4 < targetDepths.length; _i4++) {
      var targetDepth = targetDepths[(_i4 + preferredTargetIndex) % targetDepths.length],
          expand = true;

      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }

      var parent = $from.node(targetDepth - 1),
          index = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index, index, insert.type, insert.marks)) return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new prosemirrorModel.Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));
    }
  }

  var startSteps = tr.steps.length;

  for (var _i5 = targetDepths.length - 1; _i5 >= 0; _i5--) {
    tr.replace(from, to, slice);
    if (tr.steps.length > startSteps) break;
    var depth = targetDepths[_i5];
    if (depth < 0) continue;
    from = $from.before(depth);
    to = $to.after(depth);
  }
}

function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    var first = fragment.firstChild;
    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
  }

  if (depth > newOpen) {
    var match = parent.contentMatchAt(0);
    var start = match.fillBefore(fragment).append(fragment);
    fragment = start.append(match.matchFragment(start).fillBefore(prosemirrorModel.Fragment.empty, true));
  }

  return fragment;
}

function _replaceRangeWith(tr, from, to, node) {
  if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {
    var point = insertPoint(tr.doc, from, node.type);
    if (point != null) from = to = point;
  }

  tr.replaceRange(from, to, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(node), 0, 0));
}

function _deleteRange(tr, from, to) {
  var $from = tr.doc.resolve(from),
      $to = tr.doc.resolve(to);
  var covered = coveredDepths($from, $to);

  for (var i = 0; i < covered.length; i++) {
    var depth = covered[i],
        last = i == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) return tr["delete"]($from.start(depth), $to.end(depth));
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) return tr["delete"]($from.before(depth), $to.after(depth));
  }

  for (var d = 1; d <= $from.depth && d <= $to.depth; d++) {
    if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d) return tr["delete"]($from.before(d), to);
  }

  tr["delete"](from, to);
}

function coveredDepths($from, $to) {
  var result = [],
      minDepth = Math.min($from.depth, $to.depth);

  for (var d = minDepth; d >= 0; d--) {
    var start = $from.start(d);
    if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating) break;
    if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1) result.push(d);
  }

  return result;
}

var AttrStep = function (_Step7) {
  _inherits(AttrStep, _Step7);

  var _super7 = _createSuper(AttrStep);

  function AttrStep(pos, attr, value) {
    var _this9;

    _classCallCheck(this, AttrStep);

    _this9 = _super7.call(this);
    _this9.pos = pos;
    _this9.attr = attr;
    _this9.value = value;
    return _this9;
  }

  _createClass(AttrStep, [{
    key: "apply",
    value: function apply(doc) {
      var node = doc.nodeAt(this.pos);
      if (!node) return StepResult.fail("No node at attribute step's position");
      var attrs = Object.create(null);

      for (var name in node.attrs) {
        attrs[name] = node.attrs[name];
      }

      attrs[this.attr] = this.value;
      var updated = node.type.create(attrs, null, node.marks);
      return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
    }
  }, {
    key: "getMap",
    value: function getMap() {
      return StepMap.empty;
    }
  }, {
    key: "invert",
    value: function invert(doc) {
      return new AttrStep(this.pos, this.attr, doc.nodeAt(this.pos).attrs[this.attr]);
    }
  }, {
    key: "map",
    value: function map(mapping) {
      var pos = mapping.mapResult(this.pos, 1);
      return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        stepType: "attr",
        pos: this.pos,
        attr: this.attr,
        value: this.value
      };
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(schema, json) {
      if (typeof json.pos != "number" || typeof json.attr != "string") throw new RangeError("Invalid input for AttrStep.fromJSON");
      return new AttrStep(json.pos, json.attr, json.value);
    }
  }]);

  return AttrStep;
}(Step);

Step.jsonID("attr", AttrStep);

exports.TransformError = function (_Error) {
  _inherits(_class, _Error);

  var _super8 = _createSuper(_class);

  function _class() {
    _classCallCheck(this, _class);

    return _super8.apply(this, arguments);
  }

  return _createClass(_class);
}(_wrapNativeSuper(Error));

exports.TransformError = function TransformError(message) {
  var err = Error.call(this, message);
  err.__proto__ = TransformError.prototype;
  return err;
};

exports.TransformError.prototype = Object.create(Error.prototype);
exports.TransformError.prototype.constructor = exports.TransformError;
exports.TransformError.prototype.name = "TransformError";

var Transform = function () {
  function Transform(doc) {
    _classCallCheck(this, Transform);

    this.doc = doc;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  }

  _createClass(Transform, [{
    key: "before",
    get: function get() {
      return this.docs.length ? this.docs[0] : this.doc;
    }
  }, {
    key: "step",
    value: function step(_step) {
      var result = this.maybeStep(_step);
      if (result.failed) throw new exports.TransformError(result.failed);
      return this;
    }
  }, {
    key: "maybeStep",
    value: function maybeStep(step) {
      var result = step.apply(this.doc);
      if (!result.failed) this.addStep(step, result.doc);
      return result;
    }
  }, {
    key: "docChanged",
    get: function get() {
      return this.steps.length > 0;
    }
  }, {
    key: "addStep",
    value: function addStep(step, doc) {
      this.docs.push(this.doc);
      this.steps.push(step);
      this.mapping.appendMap(step.getMap());
      this.doc = doc;
    }
  }, {
    key: "replace",
    value: function replace(from) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;
      var slice = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : prosemirrorModel.Slice.empty;
      var step = replaceStep(this.doc, from, to, slice);
      if (step) this.step(step);
      return this;
    }
  }, {
    key: "replaceWith",
    value: function replaceWith(from, to, content) {
      return this.replace(from, to, new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(content), 0, 0));
    }
  }, {
    key: "delete",
    value: function _delete(from, to) {
      return this.replace(from, to, prosemirrorModel.Slice.empty);
    }
  }, {
    key: "insert",
    value: function insert(pos, content) {
      return this.replaceWith(pos, pos, content);
    }
  }, {
    key: "replaceRange",
    value: function replaceRange(from, to, slice) {
      _replaceRange(this, from, to, slice);

      return this;
    }
  }, {
    key: "replaceRangeWith",
    value: function replaceRangeWith(from, to, node) {
      _replaceRangeWith(this, from, to, node);

      return this;
    }
  }, {
    key: "deleteRange",
    value: function deleteRange(from, to) {
      _deleteRange(this, from, to);

      return this;
    }
  }, {
    key: "lift",
    value: function lift(range, target) {
      _lift(this, range, target);

      return this;
    }
  }, {
    key: "join",
    value: function join(pos) {
      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      _join(this, pos, depth);

      return this;
    }
  }, {
    key: "wrap",
    value: function wrap(range, wrappers) {
      _wrap2(this, range, wrappers);

      return this;
    }
  }, {
    key: "setBlockType",
    value: function setBlockType(from) {
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;
      var type = arguments.length > 2 ? arguments[2] : undefined;
      var attrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

      _setBlockType(this, from, to, type, attrs);

      return this;
    }
  }, {
    key: "setNodeMarkup",
    value: function setNodeMarkup(pos, type) {
      var attrs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var marks = arguments.length > 3 ? arguments[3] : undefined;

      _setNodeMarkup(this, pos, type, attrs, marks);

      return this;
    }
  }, {
    key: "setNodeAttribute",
    value: function setNodeAttribute(pos, attr, value) {
      this.step(new AttrStep(pos, attr, value));
      return this;
    }
  }, {
    key: "addNodeMark",
    value: function addNodeMark(pos, mark) {
      this.step(new AddNodeMarkStep(pos, mark));
      return this;
    }
  }, {
    key: "removeNodeMark",
    value: function removeNodeMark(pos, mark) {
      if (!(mark instanceof prosemirrorModel.Mark)) {
        var node = this.doc.nodeAt(pos);
        if (!node) throw new RangeError("No node at position " + pos);
        mark = mark.isInSet(node.marks);
        if (!mark) return this;
      }

      this.step(new RemoveNodeMarkStep(pos, mark));
      return this;
    }
  }, {
    key: "split",
    value: function split(pos) {
      var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var typesAfter = arguments.length > 2 ? arguments[2] : undefined;

      _split(this, pos, depth, typesAfter);

      return this;
    }
  }, {
    key: "addMark",
    value: function addMark(from, to, mark) {
      _addMark(this, from, to, mark);

      return this;
    }
  }, {
    key: "removeMark",
    value: function removeMark(from, to, mark) {
      _removeMark(this, from, to, mark);

      return this;
    }
  }, {
    key: "clearIncompatible",
    value: function clearIncompatible(pos, parentType, match) {
      _clearIncompatible(this, pos, parentType, match);

      return this;
    }
  }]);

  return Transform;
}();

exports.AddMarkStep = AddMarkStep;
exports.AddNodeMarkStep = AddNodeMarkStep;
exports.AttrStep = AttrStep;
exports.MapResult = MapResult;
exports.Mapping = Mapping;
exports.RemoveMarkStep = RemoveMarkStep;
exports.RemoveNodeMarkStep = RemoveNodeMarkStep;
exports.ReplaceAroundStep = ReplaceAroundStep;
exports.ReplaceStep = ReplaceStep;
exports.Step = Step;
exports.StepMap = StepMap;
exports.StepResult = StepResult;
exports.Transform = Transform;
exports.canJoin = canJoin;
exports.canSplit = canSplit;
exports.dropPoint = dropPoint;
exports.findWrapping = findWrapping;
exports.insertPoint = insertPoint;
exports.joinPoint = joinPoint;
exports.liftTarget = liftTarget;
exports.replaceStep = replaceStep;


/***/ }),

/***/ "./node_modules/prosemirror-view/dist/index.cjs":
/*!******************************************************!*\
  !*** ./node_modules/prosemirror-view/dist/index.cjs ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var prosemirrorState = __webpack_require__(/*! prosemirror-state */ "./node_modules/prosemirror-state/dist/index.cjs");

var prosemirrorModel = __webpack_require__(/*! prosemirror-model */ "./node_modules/prosemirror-model/dist/index.cjs");

var prosemirrorTransform = __webpack_require__(/*! prosemirror-transform */ "./node_modules/prosemirror-transform/dist/index.cjs");

var domIndex = function domIndex(node) {
  for (var index = 0;; index++) {
    node = node.previousSibling;
    if (!node) return index;
  }
};

var parentNode = function parentNode(node) {
  var parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};

var reusedRange = null;

var textRange = function textRange(node, from, to) {
  var range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from || 0);
  return range;
};

var isEquivalentPosition = function isEquivalentPosition(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
};

var atomElements = /^(img|br|input|textarea|hr)$/i;

function scanFor(node, off, targetNode, targetOff, dir) {
  for (;;) {
    if (node == targetNode && off == targetOff) return true;

    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      var parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false") return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      node = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (node.contentEditable == "false") return false;
      off = dir < 0 ? nodeSize(node) : 0;
    } else {
      return false;
    }
  }
}

function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}

function isOnEdge(node, offset, parent) {
  for (var atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;) {
    if (node == parent) return true;
    var index = domIndex(node);
    node = node.parentNode;
    if (!node) return false;
    atStart = atStart && index == 0;
    atEnd = atEnd && index == nodeSize(node);
  }
}

function hasBlockDesc(dom) {
  var desc;

  for (var cur = dom; cur; cur = cur.parentNode) {
    if (desc = cur.pmViewDesc) break;
  }

  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}

var selectionCollapsed = function selectionCollapsed(domSel) {
  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
};

function keyEvent(keyCode, key) {
  var event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}

function deepActiveElement(doc) {
  var elt = doc.activeElement;

  while (elt && elt.shadowRoot) {
    elt = elt.shadowRoot.activeElement;
  }

  return elt;
}

function caretFromPoint(doc, x, y) {
  if (doc.caretPositionFromPoint) {
    try {
      var pos = doc.caretPositionFromPoint(x, y);
      if (pos) return {
        node: pos.offsetNode,
        offset: pos.offset
      };
    } catch (_) {}
  }

  if (doc.caretRangeFromPoint) {
    var range = doc.caretRangeFromPoint(x, y);
    if (range) return {
      node: range.startContainer,
      offset: range.startOffset
    };
  }
}

var nav = typeof navigator != "undefined" ? navigator : null;
var doc = typeof document != "undefined" ? document : null;
var agent = nav && nav.userAgent || "";
var ie_edge = /Edge\/(\d+)/.exec(agent);
var ie_upto10 = /MSIE \d/.exec(agent);
var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
var ie = !!(ie_upto10 || ie_11up || ie_edge);
var ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
var gecko = !ie && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];

var _chrome = !ie && /Chrome\/(\d+)/.exec(agent);

var chrome = !!_chrome;
var chrome_version = _chrome ? +_chrome[1] : 0;
var safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);
var ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
var mac = ios || (nav ? /Mac/.test(nav.platform) : false);
var windows = nav ? /Win/.test(nav.platform) : false;
var android = /Android \d/.test(agent);
var webkit = !!doc && "webkitFontSmoothing" in doc.documentElement.style;
var webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;

function windowRect(doc) {
  return {
    left: 0,
    right: doc.documentElement.clientWidth,
    top: 0,
    bottom: doc.documentElement.clientHeight
  };
}

function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}

function clientRect(node) {
  var rect = node.getBoundingClientRect();
  var scaleX = rect.width / node.offsetWidth || 1;
  var scaleY = rect.height / node.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node.clientHeight * scaleY
  };
}

function scrollRectIntoView(view, rect, startDOM) {
  var scrollThreshold = view.someProp("scrollThreshold") || 0,
      scrollMargin = view.someProp("scrollMargin") || 5;
  var doc = view.dom.ownerDocument;

  for (var parent = startDOM || view.dom;; parent = parentNode(parent)) {
    if (!parent) break;
    if (parent.nodeType != 1) continue;
    var elt = parent;
    var atTop = elt == doc.body;
    var bounding = atTop ? windowRect(doc) : clientRect(elt);
    var moveX = 0,
        moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top")) moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom")) moveY = rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide(scrollThreshold, "left")) moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));else if (rect.right > bounding.right - getSide(scrollThreshold, "right")) moveX = rect.right - bounding.right + getSide(scrollMargin, "right");

    if (moveX || moveY) {
      if (atTop) {
        doc.defaultView.scrollBy(moveX, moveY);
      } else {
        var startX = elt.scrollLeft,
            startY = elt.scrollTop;
        if (moveY) elt.scrollTop += moveY;
        if (moveX) elt.scrollLeft += moveX;
        var dX = elt.scrollLeft - startX,
            dY = elt.scrollTop - startY;
        rect = {
          left: rect.left - dX,
          top: rect.top - dY,
          right: rect.right - dX,
          bottom: rect.bottom - dY
        };
      }
    }

    if (atTop) break;
  }
}

function storeScrollPos(view) {
  var rect = view.dom.getBoundingClientRect(),
      startY = Math.max(0, rect.top);
  var refDOM, refTop;

  for (var x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
    var dom = view.root.elementFromPoint(x, y);
    if (!dom || dom == view.dom || !view.dom.contains(dom)) continue;
    var localRect = dom.getBoundingClientRect();

    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }

  return {
    refDOM: refDOM,
    refTop: refTop,
    stack: scrollStack(view.dom)
  };
}

function scrollStack(dom) {
  var stack = [],
      doc = dom.ownerDocument;

  for (var cur = dom; cur; cur = parentNode(cur)) {
    stack.push({
      dom: cur,
      top: cur.scrollTop,
      left: cur.scrollLeft
    });
    if (dom == doc) break;
  }

  return stack;
}

function resetScrollPos(_ref) {
  var refDOM = _ref.refDOM,
      refTop = _ref.refTop,
      stack = _ref.stack;
  var newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}

function restoreScrollStack(stack, dTop) {
  for (var i = 0; i < stack.length; i++) {
    var _stack$i = stack[i],
        dom = _stack$i.dom,
        top = _stack$i.top,
        left = _stack$i.left;
    if (dom.scrollTop != top + dTop) dom.scrollTop = top + dTop;
    if (dom.scrollLeft != left) dom.scrollLeft = left;
  }
}

var preventScrollSupported = null;

function focusPreventScroll(dom) {
  if (dom.setActive) return dom.setActive();
  if (preventScrollSupported) return dom.focus(preventScrollSupported);
  var stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = {
        preventScroll: true
      };
      return true;
    }

  } : undefined);

  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}

function findOffsetInNode(node, coords) {
  var closest,
      dxClosest = 2e8,
      coordsClosest,
      offset = 0;
  var rowBot = coords.top,
      rowTop = coords.top;
  var firstBelow, coordsBelow;

  for (var child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    var rects = void 0;
    if (child.nodeType == 1) rects = child.getClientRects();else if (child.nodeType == 3) rects = textRange(child).getClientRects();else continue;

    for (var i = 0; i < rects.length; i++) {
      var rect = rects[i];

      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        var dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;

        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx) offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
        firstBelow = child;
        coordsBelow = {
          left: Math.max(rect.left, Math.min(rect.right, coords.left)),
          top: rect.top
        };
      }

      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom)) offset = childIndex + 1;
    }
  }

  if (!closest && firstBelow) {
    closest = firstBelow;
    coordsClosest = coordsBelow;
    dxClosest = 0;
  }

  if (closest && closest.nodeType == 3) return findOffsetInText(closest, coordsClosest);
  if (!closest || dxClosest && closest.nodeType == 1) return {
    node: node,
    offset: offset
  };
  return findOffsetInNode(closest, coordsClosest);
}

function findOffsetInText(node, coords) {
  var len = node.nodeValue.length;
  var range = document.createRange();

  for (var i = 0; i < len; i++) {
    range.setEnd(node, i + 1);
    range.setStart(node, i);
    var rect = singleRect(range, 1);
    if (rect.top == rect.bottom) continue;
    if (inRect(coords, rect)) return {
      node: node,
      offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0)
    };
  }

  return {
    node: node,
    offset: 0
  };
}

function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}

function targetKludge(dom, coords) {
  var parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left) return parent;
  return dom;
}

function posFromElement(view, elt, coords) {
  var _findOffsetInNode = findOffsetInNode(elt, coords),
      node = _findOffsetInNode.node,
      offset = _findOffsetInNode.offset,
      bias = -1;

  if (node.nodeType == 1 && !node.firstChild) {
    var rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }

  return view.docView.posFromDOM(node, offset, bias);
}

function posFromCaret(view, node, offset, coords) {
  var outsideBlock = -1;

  for (var cur = node, sawBlock = false;;) {
    if (cur == view.dom) break;
    var desc = view.docView.nearestDesc(cur, true);
    if (!desc) return null;

    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent && !sawBlock || !desc.contentDOM)) {
      var rect = desc.dom.getBoundingClientRect();

      if (desc.node.isBlock && desc.parent && !sawBlock) {
        sawBlock = true;
        if (rect.left > coords.left || rect.top > coords.top) outsideBlock = desc.posBefore;else if (rect.right < coords.left || rect.bottom < coords.top) outsideBlock = desc.posAfter;
      }

      if (!desc.contentDOM && outsideBlock < 0) {
        var before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
        return before ? desc.posBefore : desc.posAfter;
      }
    }

    cur = desc.dom.parentNode;
  }

  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset, -1);
}

function elementFromPoint(element, coords, box) {
  var len = element.childNodes.length;

  if (len && box.top < box.bottom) {
    for (var startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;) {
      var child = element.childNodes[i];

      if (child.nodeType == 1) {
        var rects = child.getClientRects();

        for (var j = 0; j < rects.length; j++) {
          var rect = rects[j];
          if (inRect(coords, rect)) return elementFromPoint(child, coords, rect);
        }
      }

      if ((i = (i + 1) % len) == startI) break;
    }
  }

  return element;
}

function _posAtCoords(view, coords) {
  var doc = view.dom.ownerDocument,
      node,
      offset = 0;
  var caret = caretFromPoint(doc, coords.left, coords.top);

  if (caret) {
    node = caret.node;
    offset = caret.offset;
  }

  var elt = (view.root.elementFromPoint ? view.root : doc).elementFromPoint(coords.left, coords.top);
  var pos;

  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    var box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box)) return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt) return null;
  }

  if (safari) {
    for (var p = elt; node && p; p = parentNode(p)) {
      if (p.draggable) node = undefined;
    }
  }

  elt = targetKludge(elt, coords);

  if (node) {
    if (gecko && node.nodeType == 1) {
      offset = Math.min(offset, node.childNodes.length);

      if (offset < node.childNodes.length) {
        var next = node.childNodes[offset],
            _box;

        if (next.nodeName == "IMG" && (_box = next.getBoundingClientRect()).right <= coords.left && _box.bottom > coords.top) offset++;
      }
    }

    if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom) pos = view.state.doc.content.size;else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != "BR") pos = posFromCaret(view, node, offset, coords);
  }

  if (pos == null) pos = posFromElement(view, elt, coords);
  var desc = view.docView.nearestDesc(elt, true);
  return {
    pos: pos,
    inside: desc ? desc.posAtStart - desc.border : -1
  };
}

function nonZero(rect) {
  return rect.top < rect.bottom || rect.left < rect.right;
}

function singleRect(target, bias) {
  var rects = target.getClientRects();

  if (rects.length) {
    var first = rects[bias < 0 ? 0 : rects.length - 1];
    if (nonZero(first)) return first;
  }

  return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
}

var BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;

function _coordsAtPos(view, pos, side) {
  var _view$docView$domFrom = view.docView.domFromPos(pos, side < 0 ? -1 : 1),
      node = _view$docView$domFrom.node,
      offset = _view$docView$domFrom.offset,
      atom = _view$docView$domFrom.atom;

  var supportEmptyRange = webkit || gecko;

  if (node.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {
      var rect = singleRect(textRange(node, offset, offset), side);

      if (gecko && offset && /\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {
        var rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);

        if (rectBefore.top == rect.top) {
          var rectAfter = singleRect(textRange(node, offset, offset + 1), -1);
          if (rectAfter.top != rect.top) return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }

      return rect;
    } else {
      var from = offset,
          to = offset,
          takeSide = side < 0 ? 1 : -1;

      if (side < 0 && !offset) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset == node.nodeValue.length) {
        from--;
        takeSide = 1;
      } else if (side < 0) {
        from--;
      } else {
        to++;
      }

      return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0);
    }
  }

  var $dom = view.state.doc.resolve(pos - (atom || 0));

  if (!$dom.parent.inlineContent) {
    if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {
      var before = node.childNodes[offset - 1];
      if (before.nodeType == 1) return flattenH(before.getBoundingClientRect(), false);
    }

    if (atom == null && offset < nodeSize(node)) {
      var after = node.childNodes[offset];
      if (after.nodeType == 1) return flattenH(after.getBoundingClientRect(), true);
    }

    return flattenH(node.getBoundingClientRect(), side >= 0);
  }

  if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {
    var _before = node.childNodes[offset - 1];
    var target = _before.nodeType == 3 ? textRange(_before, nodeSize(_before) - (supportEmptyRange ? 0 : 1)) : _before.nodeType == 1 && (_before.nodeName != "BR" || !_before.nextSibling) ? _before : null;
    if (target) return flattenV(singleRect(target, 1), false);
  }

  if (atom == null && offset < nodeSize(node)) {
    var _after = node.childNodes[offset];

    while (_after.pmViewDesc && _after.pmViewDesc.ignoreForCoords) {
      _after = _after.nextSibling;
    }

    var _target = !_after ? null : _after.nodeType == 3 ? textRange(_after, 0, supportEmptyRange ? 0 : 1) : _after.nodeType == 1 ? _after : null;

    if (_target) return flattenV(singleRect(_target, -1), true);
  }

  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}

function flattenV(rect, left) {
  if (rect.width == 0) return rect;
  var x = left ? rect.left : rect.right;
  return {
    top: rect.top,
    bottom: rect.bottom,
    left: x,
    right: x
  };
}

function flattenH(rect, top) {
  if (rect.height == 0) return rect;
  var y = top ? rect.top : rect.bottom;
  return {
    top: y,
    bottom: y,
    left: rect.left,
    right: rect.right
  };
}

function withFlushedState(view, state, f) {
  var viewState = view.state,
      active = view.root.activeElement;
  if (viewState != state) view.updateState(state);
  if (active != view.dom) view.focus();

  try {
    return f();
  } finally {
    if (viewState != state) view.updateState(viewState);
    if (active != view.dom && active) active.focus();
  }
}

function endOfTextblockVertical(view, state, dir) {
  var sel = state.selection;
  var $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, function () {
    var _view$docView$domFrom2 = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1),
        dom = _view$docView$domFrom2.node;

    for (;;) {
      var nearest = view.docView.nearestDesc(dom, true);
      if (!nearest) break;

      if (nearest.node.isBlock) {
        dom = nearest.contentDOM || nearest.dom;
        break;
      }

      dom = nearest.dom.parentNode;
    }

    var coords = _coordsAtPos(view, $pos.pos, 1);

    for (var child = dom.firstChild; child; child = child.nextSibling) {
      var boxes = void 0;
      if (child.nodeType == 1) boxes = child.getClientRects();else if (child.nodeType == 3) boxes = textRange(child, 0, child.nodeValue.length).getClientRects();else continue;

      for (var i = 0; i < boxes.length; i++) {
        var box = boxes[i];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2)) return false;
      }
    }

    return true;
  });
}

var maybeRTL = /[\u0590-\u08ac]/;

function endOfTextblockHorizontal(view, state, dir) {
  var $head = state.selection.$head;
  if (!$head.parent.isTextblock) return false;
  var offset = $head.parentOffset,
      atStart = !offset,
      atEnd = offset == $head.parent.content.size;
  var sel = view.domSelection();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify) return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state, function () {
    var _view$domSelectionRan = view.domSelectionRange(),
        oldNode = _view$domSelectionRan.focusNode,
        oldOff = _view$domSelectionRan.focusOffset,
        anchorNode = _view$domSelectionRan.anchorNode,
        anchorOffset = _view$domSelectionRan.anchorOffset;

    var oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    var parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;

    var _view$domSelectionRan2 = view.domSelectionRange(),
        newNode = _view$domSelectionRan2.focusNode,
        newOff = _view$domSelectionRan2.focusOffset;

    var result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;

    try {
      sel.collapse(anchorNode, anchorOffset);
      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend) sel.extend(oldNode, oldOff);
    } catch (_) {}

    if (oldBidiLevel != null) sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}

var cachedState = null;
var cachedDir = null;
var cachedResult = false;

function _endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir) return cachedResult;
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}

var NOT_DIRTY = 0,
    CHILD_DIRTY = 1,
    CONTENT_DIRTY = 2,
    NODE_DIRTY = 3;

var ViewDesc = function () {
  function ViewDesc(parent, children, dom, contentDOM) {
    _classCallCheck(this, ViewDesc);

    this.parent = parent;
    this.children = children;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom.pmViewDesc = this;
  }

  _createClass(ViewDesc, [{
    key: "matchesWidget",
    value: function matchesWidget(widget) {
      return false;
    }
  }, {
    key: "matchesMark",
    value: function matchesMark(mark) {
      return false;
    }
  }, {
    key: "matchesNode",
    value: function matchesNode(node, outerDeco, innerDeco) {
      return false;
    }
  }, {
    key: "matchesHack",
    value: function matchesHack(nodeName) {
      return false;
    }
  }, {
    key: "parseRule",
    value: function parseRule() {
      return null;
    }
  }, {
    key: "stopEvent",
    value: function stopEvent(event) {
      return false;
    }
  }, {
    key: "size",
    get: function get() {
      var size = 0;

      for (var i = 0; i < this.children.length; i++) {
        size += this.children[i].size;
      }

      return size;
    }
  }, {
    key: "border",
    get: function get() {
      return 0;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.parent = undefined;
      if (this.dom.pmViewDesc == this) this.dom.pmViewDesc = undefined;

      for (var i = 0; i < this.children.length; i++) {
        this.children[i].destroy();
      }
    }
  }, {
    key: "posBeforeChild",
    value: function posBeforeChild(child) {
      for (var i = 0, pos = this.posAtStart;; i++) {
        var cur = this.children[i];
        if (cur == child) return pos;
        pos += cur.size;
      }
    }
  }, {
    key: "posBefore",
    get: function get() {
      return this.parent.posBeforeChild(this);
    }
  }, {
    key: "posAtStart",
    get: function get() {
      return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
    }
  }, {
    key: "posAfter",
    get: function get() {
      return this.posBefore + this.size;
    }
  }, {
    key: "posAtEnd",
    get: function get() {
      return this.posAtStart + this.size - 2 * this.border;
    }
  }, {
    key: "localPosFromDOM",
    value: function localPosFromDOM(dom, offset, bias) {
      if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
        if (bias < 0) {
          var domBefore, desc;

          if (dom == this.contentDOM) {
            domBefore = dom.childNodes[offset - 1];
          } else {
            while (dom.parentNode != this.contentDOM) {
              dom = dom.parentNode;
            }

            domBefore = dom.previousSibling;
          }

          while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this)) {
            domBefore = domBefore.previousSibling;
          }

          return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
        } else {
          var domAfter, _desc;

          if (dom == this.contentDOM) {
            domAfter = dom.childNodes[offset];
          } else {
            while (dom.parentNode != this.contentDOM) {
              dom = dom.parentNode;
            }

            domAfter = dom.nextSibling;
          }

          while (domAfter && !((_desc = domAfter.pmViewDesc) && _desc.parent == this)) {
            domAfter = domAfter.nextSibling;
          }

          return domAfter ? this.posBeforeChild(_desc) : this.posAtEnd;
        }
      }

      var atEnd;

      if (dom == this.dom && this.contentDOM) {
        atEnd = offset > domIndex(this.contentDOM);
      } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
        atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
      } else if (this.dom.firstChild) {
        if (offset == 0) for (var search = dom;; search = search.parentNode) {
          if (search == this.dom) {
            atEnd = false;
            break;
          }

          if (search.previousSibling) break;
        }
        if (atEnd == null && offset == dom.childNodes.length) for (var _search = dom;; _search = _search.parentNode) {
          if (_search == this.dom) {
            atEnd = true;
            break;
          }

          if (_search.nextSibling) break;
        }
      }

      return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
    }
  }, {
    key: "nearestDesc",
    value: function nearestDesc(dom) {
      var onlyNodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      for (var first = true, cur = dom; cur; cur = cur.parentNode) {
        var desc = this.getDesc(cur),
            nodeDOM = void 0;

        if (desc && (!onlyNodes || desc.node)) {
          if (first && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom)) first = false;else return desc;
        }
      }
    }
  }, {
    key: "getDesc",
    value: function getDesc(dom) {
      var desc = dom.pmViewDesc;

      for (var cur = desc; cur; cur = cur.parent) {
        if (cur == this) return desc;
      }
    }
  }, {
    key: "posFromDOM",
    value: function posFromDOM(dom, offset, bias) {
      for (var scan = dom; scan; scan = scan.parentNode) {
        var desc = this.getDesc(scan);
        if (desc) return desc.localPosFromDOM(dom, offset, bias);
      }

      return -1;
    }
  }, {
    key: "descAt",
    value: function descAt(pos) {
      for (var i = 0, offset = 0; i < this.children.length; i++) {
        var child = this.children[i],
            end = offset + child.size;

        if (offset == pos && end != offset) {
          while (!child.border && child.children.length) {
            child = child.children[0];
          }

          return child;
        }

        if (pos < end) return child.descAt(pos - offset - child.border);
        offset = end;
      }
    }
  }, {
    key: "domFromPos",
    value: function domFromPos(pos, side) {
      if (!this.contentDOM) return {
        node: this.dom,
        offset: 0,
        atom: pos + 1
      };
      var i = 0,
          offset = 0;

      for (var curPos = 0; i < this.children.length; i++) {
        var child = this.children[i],
            end = curPos + child.size;

        if (end > pos || child instanceof TrailingHackViewDesc) {
          offset = pos - curPos;
          break;
        }

        curPos = end;
      }

      if (offset) return this.children[i].domFromPos(offset - this.children[i].border, side);

      for (var prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {}

      if (side <= 0) {
        var _prev,
            enter = true;

        for (;; i--, enter = false) {
          _prev = i ? this.children[i - 1] : null;
          if (!_prev || _prev.dom.parentNode == this.contentDOM) break;
        }

        if (_prev && side && enter && !_prev.border && !_prev.domAtom) return _prev.domFromPos(_prev.size, side);
        return {
          node: this.contentDOM,
          offset: _prev ? domIndex(_prev.dom) + 1 : 0
        };
      } else {
        var next,
            _enter = true;

        for (;; i++, _enter = false) {
          next = i < this.children.length ? this.children[i] : null;
          if (!next || next.dom.parentNode == this.contentDOM) break;
        }

        if (next && _enter && !next.border && !next.domAtom) return next.domFromPos(0, side);
        return {
          node: this.contentDOM,
          offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length
        };
      }
    }
  }, {
    key: "parseRange",
    value: function parseRange(from, to) {
      var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      if (this.children.length == 0) return {
        node: this.contentDOM,
        from: from,
        to: to,
        fromOffset: 0,
        toOffset: this.contentDOM.childNodes.length
      };
      var fromOffset = -1,
          toOffset = -1;

      for (var offset = base, i = 0;; i++) {
        var child = this.children[i],
            end = offset + child.size;

        if (fromOffset == -1 && from <= end) {
          var childBase = offset + child.border;
          if (from >= childBase && to <= end - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM)) return child.parseRange(from, to, childBase);
          from = offset;

          for (var j = i; j > 0; j--) {
            var prev = this.children[j - 1];

            if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
              fromOffset = domIndex(prev.dom) + 1;
              break;
            }

            from -= prev.size;
          }

          if (fromOffset == -1) fromOffset = 0;
        }

        if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {
          to = end;

          for (var _j = i + 1; _j < this.children.length; _j++) {
            var next = this.children[_j];

            if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
              toOffset = domIndex(next.dom);
              break;
            }

            to += next.size;
          }

          if (toOffset == -1) toOffset = this.contentDOM.childNodes.length;
          break;
        }

        offset = end;
      }

      return {
        node: this.contentDOM,
        from: from,
        to: to,
        fromOffset: fromOffset,
        toOffset: toOffset
      };
    }
  }, {
    key: "emptyChildAt",
    value: function emptyChildAt(side) {
      if (this.border || !this.contentDOM || !this.children.length) return false;
      var child = this.children[side < 0 ? 0 : this.children.length - 1];
      return child.size == 0 || child.emptyChildAt(side);
    }
  }, {
    key: "domAfterPos",
    value: function domAfterPos(pos) {
      var _this$domFromPos = this.domFromPos(pos, 0),
          node = _this$domFromPos.node,
          offset = _this$domFromPos.offset;

      if (node.nodeType != 1 || offset == node.childNodes.length) throw new RangeError("No node after pos " + pos);
      return node.childNodes[offset];
    }
  }, {
    key: "setSelection",
    value: function setSelection(anchor, head, root) {
      var force = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var from = Math.min(anchor, head),
          to = Math.max(anchor, head);

      for (var i = 0, offset = 0; i < this.children.length; i++) {
        var child = this.children[i],
            end = offset + child.size;
        if (from > offset && to < end) return child.setSelection(anchor - offset - child.border, head - offset - child.border, root, force);
        offset = end;
      }

      var anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
      var headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
      var domSel = root.getSelection();
      var brKludge = false;

      if ((gecko || safari) && anchor == head) {
        var _anchorDOM = anchorDOM,
            node = _anchorDOM.node,
            _offset = _anchorDOM.offset;

        if (node.nodeType == 3) {
          brKludge = !!(_offset && node.nodeValue[_offset - 1] == "\n");
        } else {
          var prev = node.childNodes[_offset - 1];
          brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
        }
      }

      if (gecko && domSel.focusNode && domSel.focusNode != headDOM.node && domSel.focusNode.nodeType == 1) {
        var after = domSel.focusNode.childNodes[domSel.focusOffset];
        if (after && after.contentEditable == "false") force = true;
      }

      if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, domSel.focusNode, domSel.focusOffset)) return;
      var domSelExtended = false;

      if ((domSel.extend || anchor == head) && !brKludge) {
        domSel.collapse(anchorDOM.node, anchorDOM.offset);

        try {
          if (anchor != head) domSel.extend(headDOM.node, headDOM.offset);
          domSelExtended = true;
        } catch (_) {}
      }

      if (!domSelExtended) {
        if (anchor > head) {
          var tmp = anchorDOM;
          anchorDOM = headDOM;
          headDOM = tmp;
        }

        var range = document.createRange();
        range.setEnd(headDOM.node, headDOM.offset);
        range.setStart(anchorDOM.node, anchorDOM.offset);
        domSel.removeAllRanges();
        domSel.addRange(range);
      }
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mutation) {
      return !this.contentDOM && mutation.type != "selection";
    }
  }, {
    key: "contentLost",
    get: function get() {
      return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
    }
  }, {
    key: "markDirty",
    value: function markDirty(from, to) {
      for (var offset = 0, i = 0; i < this.children.length; i++) {
        var child = this.children[i],
            end = offset + child.size;

        if (offset == end ? from <= end && to >= offset : from < end && to > offset) {
          var startInside = offset + child.border,
              endInside = end - child.border;

          if (from >= startInside && to <= endInside) {
            this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;
            if (from == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM)) child.dirty = NODE_DIRTY;else child.markDirty(from - startInside, to - startInside);
            return;
          } else {
            child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
          }
        }

        offset = end;
      }

      this.dirty = CONTENT_DIRTY;
    }
  }, {
    key: "markParentsDirty",
    value: function markParentsDirty() {
      var level = 1;

      for (var node = this.parent; node; node = node.parent, level++) {
        var dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
        if (node.dirty < dirty) node.dirty = dirty;
      }
    }
  }, {
    key: "domAtom",
    get: function get() {
      return false;
    }
  }, {
    key: "ignoreForCoords",
    get: function get() {
      return false;
    }
  }]);

  return ViewDesc;
}();

var WidgetViewDesc = function (_ViewDesc) {
  _inherits(WidgetViewDesc, _ViewDesc);

  var _super = _createSuper(WidgetViewDesc);

  function WidgetViewDesc(parent, widget, view, pos) {
    var _this;

    _classCallCheck(this, WidgetViewDesc);

    var self,
        dom = widget.type.toDOM;
    if (typeof dom == "function") dom = dom(view, function () {
      if (!self) return pos;
      if (self.parent) return self.parent.posBeforeChild(self);
    });

    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        var wrap = document.createElement("span");
        wrap.appendChild(dom);
        dom = wrap;
      }

      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }

    _this = _super.call(this, parent, [], dom, null);
    _this.widget = widget;
    _this.widget = widget;
    self = _assertThisInitialized(_this);
    return _this;
  }

  _createClass(WidgetViewDesc, [{
    key: "matchesWidget",
    value: function matchesWidget(widget) {
      return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
    }
  }, {
    key: "parseRule",
    value: function parseRule() {
      return {
        ignore: true
      };
    }
  }, {
    key: "stopEvent",
    value: function stopEvent(event) {
      var stop = this.widget.spec.stopEvent;
      return stop ? stop(event) : false;
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mutation) {
      return mutation.type != "selection" || this.widget.spec.ignoreSelection;
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.widget.type.destroy(this.dom);

      _get(_getPrototypeOf(WidgetViewDesc.prototype), "destroy", this).call(this);
    }
  }, {
    key: "domAtom",
    get: function get() {
      return true;
    }
  }, {
    key: "side",
    get: function get() {
      return this.widget.type.side;
    }
  }]);

  return WidgetViewDesc;
}(ViewDesc);

var CompositionViewDesc = function (_ViewDesc2) {
  _inherits(CompositionViewDesc, _ViewDesc2);

  var _super2 = _createSuper(CompositionViewDesc);

  function CompositionViewDesc(parent, dom, textDOM, text) {
    var _this2;

    _classCallCheck(this, CompositionViewDesc);

    _this2 = _super2.call(this, parent, [], dom, null);
    _this2.textDOM = textDOM;
    _this2.text = text;
    return _this2;
  }

  _createClass(CompositionViewDesc, [{
    key: "size",
    get: function get() {
      return this.text.length;
    }
  }, {
    key: "localPosFromDOM",
    value: function localPosFromDOM(dom, offset) {
      if (dom != this.textDOM) return this.posAtStart + (offset ? this.size : 0);
      return this.posAtStart + offset;
    }
  }, {
    key: "domFromPos",
    value: function domFromPos(pos) {
      return {
        node: this.textDOM,
        offset: pos
      };
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mut) {
      return mut.type === 'characterData' && mut.target.nodeValue == mut.oldValue;
    }
  }]);

  return CompositionViewDesc;
}(ViewDesc);

var MarkViewDesc = function (_ViewDesc3) {
  _inherits(MarkViewDesc, _ViewDesc3);

  var _super3 = _createSuper(MarkViewDesc);

  function MarkViewDesc(parent, mark, dom, contentDOM) {
    var _this3;

    _classCallCheck(this, MarkViewDesc);

    _this3 = _super3.call(this, parent, [], dom, contentDOM);
    _this3.mark = mark;
    return _this3;
  }

  _createClass(MarkViewDesc, [{
    key: "parseRule",
    value: function parseRule() {
      if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView) return null;
      return {
        mark: this.mark.type.name,
        attrs: this.mark.attrs,
        contentElement: this.contentDOM || undefined
      };
    }
  }, {
    key: "matchesMark",
    value: function matchesMark(mark) {
      return this.dirty != NODE_DIRTY && this.mark.eq(mark);
    }
  }, {
    key: "markDirty",
    value: function markDirty(from, to) {
      _get(_getPrototypeOf(MarkViewDesc.prototype), "markDirty", this).call(this, from, to);

      if (this.dirty != NOT_DIRTY) {
        var parent = this.parent;

        while (!parent.node) {
          parent = parent.parent;
        }

        if (parent.dirty < this.dirty) parent.dirty = this.dirty;
        this.dirty = NOT_DIRTY;
      }
    }
  }, {
    key: "slice",
    value: function slice(from, to, view) {
      var copy = MarkViewDesc.create(this.parent, this.mark, true, view);
      var nodes = this.children,
          size = this.size;
      if (to < size) nodes = replaceNodes(nodes, to, size, view);
      if (from > 0) nodes = replaceNodes(nodes, 0, from, view);

      for (var i = 0; i < nodes.length; i++) {
        nodes[i].parent = copy;
      }

      copy.children = nodes;
      return copy;
    }
  }], [{
    key: "create",
    value: function create(parent, mark, inline, view) {
      var custom = view.nodeViews[mark.type.name];
      var spec = custom && custom(mark, view, inline);
      if (!spec || !spec.dom) spec = prosemirrorModel.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline));
      return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom);
    }
  }]);

  return MarkViewDesc;
}(ViewDesc);

var NodeViewDesc = function (_ViewDesc4) {
  _inherits(NodeViewDesc, _ViewDesc4);

  var _super4 = _createSuper(NodeViewDesc);

  function NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    var _this4;

    _classCallCheck(this, NodeViewDesc);

    _this4 = _super4.call(this, parent, [], dom, contentDOM);
    _this4.node = node;
    _this4.outerDeco = outerDeco;
    _this4.innerDeco = innerDeco;
    _this4.nodeDOM = nodeDOM;
    return _this4;
  }

  _createClass(NodeViewDesc, [{
    key: "parseRule",
    value: function parseRule() {
      var _this5 = this;

      if (this.node.type.spec.reparseInView) return null;
      var rule = {
        node: this.node.type.name,
        attrs: this.node.attrs
      };
      if (this.node.type.whitespace == "pre") rule.preserveWhitespace = "full";

      if (!this.contentDOM) {
        rule.getContent = function () {
          return _this5.node.content;
        };
      } else if (!this.contentLost) {
        rule.contentElement = this.contentDOM;
      } else {
        for (var i = this.children.length - 1; i >= 0; i--) {
          var child = this.children[i];

          if (this.dom.contains(child.dom.parentNode)) {
            rule.contentElement = child.dom.parentNode;
            break;
          }
        }

        if (!rule.contentElement) rule.getContent = function () {
          return prosemirrorModel.Fragment.empty;
        };
      }

      return rule;
    }
  }, {
    key: "matchesNode",
    value: function matchesNode(node, outerDeco, innerDeco) {
      return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
    }
  }, {
    key: "size",
    get: function get() {
      return this.node.nodeSize;
    }
  }, {
    key: "border",
    get: function get() {
      return this.node.isLeaf ? 0 : 1;
    }
  }, {
    key: "updateChildren",
    value: function updateChildren(view, pos) {
      var _this6 = this;

      var inline = this.node.inlineContent,
          off = pos;
      var composition = view.composing ? this.localCompositionInfo(view, pos) : null;
      var localComposition = composition && composition.pos > -1 ? composition : null;
      var compositionInChild = composition && composition.pos < 0;
      var updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
      iterDeco(this.node, this.innerDeco, function (widget, i, insideNode) {
        if (widget.spec.marks) updater.syncToMarks(widget.spec.marks, inline, view);else if (widget.type.side >= 0 && !insideNode) updater.syncToMarks(i == _this6.node.childCount ? prosemirrorModel.Mark.none : _this6.node.child(i).marks, inline, view);
        updater.placeWidget(widget, view, off);
      }, function (child, outerDeco, innerDeco, i) {
        updater.syncToMarks(child.marks, inline, view);
        var compIndex;
        if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;else {
          updater.addNode(child, outerDeco, innerDeco, view, off);
        }
        off += child.nodeSize;
      });
      updater.syncToMarks([], inline, view);
      if (this.node.isTextblock) updater.addTextblockHacks();
      updater.destroyRest();

      if (updater.changed || this.dirty == CONTENT_DIRTY) {
        if (localComposition) this.protectLocalComposition(view, localComposition);
        renderDescs(this.contentDOM, this.children, view);
        if (ios) iosHacks(this.dom);
      }
    }
  }, {
    key: "localCompositionInfo",
    value: function localCompositionInfo(view, pos) {
      var _view$state$selection = view.state.selection,
          from = _view$state$selection.from,
          to = _view$state$selection.to;
      if (!(view.state.selection instanceof prosemirrorState.TextSelection) || from < pos || to > pos + this.node.content.size) return null;
      var sel = view.domSelectionRange();
      var textNode = nearbyTextNode(sel.focusNode, sel.focusOffset);
      if (!textNode || !this.dom.contains(textNode.parentNode)) return null;

      if (this.node.inlineContent) {
        var text = textNode.nodeValue;
        var textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);
        return textPos < 0 ? null : {
          node: textNode,
          pos: textPos,
          text: text
        };
      } else {
        return {
          node: textNode,
          pos: -1,
          text: ""
        };
      }
    }
  }, {
    key: "protectLocalComposition",
    value: function protectLocalComposition(view, _ref2) {
      var node = _ref2.node,
          pos = _ref2.pos,
          text = _ref2.text;
      if (this.getDesc(node)) return;
      var topNode = node;

      for (;; topNode = topNode.parentNode) {
        if (topNode.parentNode == this.contentDOM) break;

        while (topNode.previousSibling) {
          topNode.parentNode.removeChild(topNode.previousSibling);
        }

        while (topNode.nextSibling) {
          topNode.parentNode.removeChild(topNode.nextSibling);
        }

        if (topNode.pmViewDesc) topNode.pmViewDesc = undefined;
      }

      var desc = new CompositionViewDesc(this, topNode, node, text);
      view.input.compositionNodes.push(desc);
      this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
    }
  }, {
    key: "update",
    value: function update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node)) return false;
      this.updateInner(node, outerDeco, innerDeco, view);
      return true;
    }
  }, {
    key: "updateInner",
    value: function updateInner(node, outerDeco, innerDeco, view) {
      this.updateOuterDeco(outerDeco);
      this.node = node;
      this.innerDeco = innerDeco;
      if (this.contentDOM) this.updateChildren(view, this.posAtStart);
      this.dirty = NOT_DIRTY;
    }
  }, {
    key: "updateOuterDeco",
    value: function updateOuterDeco(outerDeco) {
      if (sameOuterDeco(outerDeco, this.outerDeco)) return;
      var needsWrap = this.nodeDOM.nodeType != 1;
      var oldDOM = this.dom;
      this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));

      if (this.dom != oldDOM) {
        oldDOM.pmViewDesc = undefined;
        this.dom.pmViewDesc = this;
      }

      this.outerDeco = outerDeco;
    }
  }, {
    key: "selectNode",
    value: function selectNode() {
      if (this.nodeDOM.nodeType == 1) this.nodeDOM.classList.add("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable) this.dom.draggable = true;
    }
  }, {
    key: "deselectNode",
    value: function deselectNode() {
      if (this.nodeDOM.nodeType == 1) this.nodeDOM.classList.remove("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable) this.dom.removeAttribute("draggable");
    }
  }, {
    key: "domAtom",
    get: function get() {
      return this.node.isAtom;
    }
  }], [{
    key: "create",
    value: function create(parent, node, outerDeco, innerDeco, view, pos) {
      var custom = view.nodeViews[node.type.name],
          descObj;
      var spec = custom && custom(node, view, function () {
        if (!descObj) return pos;
        if (descObj.parent) return descObj.parent.posBeforeChild(descObj);
      }, outerDeco, innerDeco);
      var dom = spec && spec.dom,
          contentDOM = spec && spec.contentDOM;

      if (node.isText) {
        if (!dom) dom = document.createTextNode(node.text);else if (dom.nodeType != 3) throw new RangeError("Text must be rendered as a DOM text node");
      } else if (!dom) {
        var _prosemirrorModel$DOM = prosemirrorModel.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node));

        dom = _prosemirrorModel$DOM.dom;
        contentDOM = _prosemirrorModel$DOM.contentDOM;
      }

      if (!contentDOM && !node.isText && dom.nodeName != "BR") {
        if (!dom.hasAttribute("contenteditable")) dom.contentEditable = "false";
        if (node.type.spec.draggable) dom.draggable = true;
      }

      var nodeDOM = dom;
      dom = applyOuterDeco(dom, outerDeco, node);
      if (spec) return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);else if (node.isText) return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);else return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
    }
  }]);

  return NodeViewDesc;
}(ViewDesc);

function docViewDesc(doc, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc);
  var docView = new NodeViewDesc(undefined, doc, outerDeco, innerDeco, dom, dom, dom, view, 0);
  if (docView.contentDOM) docView.updateChildren(view, 0);
  return docView;
}

var TextViewDesc = function (_NodeViewDesc) {
  _inherits(TextViewDesc, _NodeViewDesc);

  var _super5 = _createSuper(TextViewDesc);

  function TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    _classCallCheck(this, TextViewDesc);

    return _super5.call(this, parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
  }

  _createClass(TextViewDesc, [{
    key: "parseRule",
    value: function parseRule() {
      var skip = this.nodeDOM.parentNode;

      while (skip && skip != this.dom && !skip.pmIsDeco) {
        skip = skip.parentNode;
      }

      return {
        skip: skip || true
      };
    }
  }, {
    key: "update",
    value: function update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node)) return false;
      this.updateOuterDeco(outerDeco);

      if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
        this.nodeDOM.nodeValue = node.text;
        if (view.trackWrites == this.nodeDOM) view.trackWrites = null;
      }

      this.node = node;
      this.dirty = NOT_DIRTY;
      return true;
    }
  }, {
    key: "inParent",
    value: function inParent() {
      var parentDOM = this.parent.contentDOM;

      for (var n = this.nodeDOM; n; n = n.parentNode) {
        if (n == parentDOM) return true;
      }

      return false;
    }
  }, {
    key: "domFromPos",
    value: function domFromPos(pos) {
      return {
        node: this.nodeDOM,
        offset: pos
      };
    }
  }, {
    key: "localPosFromDOM",
    value: function localPosFromDOM(dom, offset, bias) {
      if (dom == this.nodeDOM) return this.posAtStart + Math.min(offset, this.node.text.length);
      return _get(_getPrototypeOf(TextViewDesc.prototype), "localPosFromDOM", this).call(this, dom, offset, bias);
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mutation) {
      return mutation.type != "characterData" && mutation.type != "selection";
    }
  }, {
    key: "slice",
    value: function slice(from, to, view) {
      var node = this.node.cut(from, to),
          dom = document.createTextNode(node.text);
      return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
    }
  }, {
    key: "markDirty",
    value: function markDirty(from, to) {
      _get(_getPrototypeOf(TextViewDesc.prototype), "markDirty", this).call(this, from, to);

      if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length)) this.dirty = NODE_DIRTY;
    }
  }, {
    key: "domAtom",
    get: function get() {
      return false;
    }
  }]);

  return TextViewDesc;
}(NodeViewDesc);

var TrailingHackViewDesc = function (_ViewDesc5) {
  _inherits(TrailingHackViewDesc, _ViewDesc5);

  var _super6 = _createSuper(TrailingHackViewDesc);

  function TrailingHackViewDesc() {
    _classCallCheck(this, TrailingHackViewDesc);

    return _super6.apply(this, arguments);
  }

  _createClass(TrailingHackViewDesc, [{
    key: "parseRule",
    value: function parseRule() {
      return {
        ignore: true
      };
    }
  }, {
    key: "matchesHack",
    value: function matchesHack(nodeName) {
      return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
    }
  }, {
    key: "domAtom",
    get: function get() {
      return true;
    }
  }, {
    key: "ignoreForCoords",
    get: function get() {
      return this.dom.nodeName == "IMG";
    }
  }]);

  return TrailingHackViewDesc;
}(ViewDesc);

var CustomNodeViewDesc = function (_NodeViewDesc2) {
  _inherits(CustomNodeViewDesc, _NodeViewDesc2);

  var _super7 = _createSuper(CustomNodeViewDesc);

  function CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    var _this7;

    _classCallCheck(this, CustomNodeViewDesc);

    _this7 = _super7.call(this, parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    _this7.spec = spec;
    return _this7;
  }

  _createClass(CustomNodeViewDesc, [{
    key: "update",
    value: function update(node, outerDeco, innerDeco, view) {
      if (this.dirty == NODE_DIRTY) return false;

      if (this.spec.update) {
        var result = this.spec.update(node, outerDeco, innerDeco);
        if (result) this.updateInner(node, outerDeco, innerDeco, view);
        return result;
      } else if (!this.contentDOM && !node.isLeaf) {
        return false;
      } else {
        return _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "update", this).call(this, node, outerDeco, innerDeco, view);
      }
    }
  }, {
    key: "selectNode",
    value: function selectNode() {
      this.spec.selectNode ? this.spec.selectNode() : _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "selectNode", this).call(this);
    }
  }, {
    key: "deselectNode",
    value: function deselectNode() {
      this.spec.deselectNode ? this.spec.deselectNode() : _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "deselectNode", this).call(this);
    }
  }, {
    key: "setSelection",
    value: function setSelection(anchor, head, root, force) {
      this.spec.setSelection ? this.spec.setSelection(anchor, head, root) : _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "setSelection", this).call(this, anchor, head, root, force);
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (this.spec.destroy) this.spec.destroy();

      _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "destroy", this).call(this);
    }
  }, {
    key: "stopEvent",
    value: function stopEvent(event) {
      return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
    }
  }, {
    key: "ignoreMutation",
    value: function ignoreMutation(mutation) {
      return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : _get(_getPrototypeOf(CustomNodeViewDesc.prototype), "ignoreMutation", this).call(this, mutation);
    }
  }]);

  return CustomNodeViewDesc;
}(NodeViewDesc);

function renderDescs(parentDOM, descs, view) {
  var dom = parentDOM.firstChild,
      written = false;

  for (var i = 0; i < descs.length; i++) {
    var desc = descs[i],
        childDOM = desc.dom;

    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }

      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }

    if (desc instanceof MarkViewDesc) {
      var pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }

  while (dom) {
    dom = rm(dom);
    written = true;
  }

  if (written && view.trackWrites == parentDOM) view.trackWrites = null;
}

var OuterDecoLevel = function OuterDecoLevel(nodeName) {
  if (nodeName) this.nodeName = nodeName;
};

OuterDecoLevel.prototype = Object.create(null);
var noDeco = [new OuterDecoLevel()];

function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0) return noDeco;
  var top = needsWrap ? noDeco[0] : new OuterDecoLevel(),
      result = [top];

  for (var i = 0; i < outerDeco.length; i++) {
    var attrs = outerDeco[i].type.attrs;
    if (!attrs) continue;
    if (attrs.nodeName) result.push(top = new OuterDecoLevel(attrs.nodeName));

    for (var name in attrs) {
      var val = attrs[name];
      if (val == null) continue;
      if (needsWrap && result.length == 1) result.push(top = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class") top["class"] = (top["class"] ? top["class"] + " " : "") + val;else if (name == "style") top.style = (top.style ? top.style + ";" : "") + val;else if (name != "nodeName") top[name] = val;
    }
  }

  return result;
}

function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco) return nodeDOM;
  var curDOM = nodeDOM;

  for (var i = 0; i < curComputed.length; i++) {
    var deco = curComputed[i],
        prev = prevComputed[i];

    if (i) {
      var parent = void 0;

      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }

    patchAttributes(curDOM, prev || noDeco[0], deco);
  }

  return curDOM;
}

function patchAttributes(dom, prev, cur) {
  for (var name in prev) {
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur)) dom.removeAttribute(name);
  }

  for (var _name in cur) {
    if (_name != "class" && _name != "style" && _name != "nodeName" && cur[_name] != prev[_name]) dom.setAttribute(_name, cur[_name]);
  }

  if (prev["class"] != cur["class"]) {
    var prevList = prev["class"] ? prev["class"].split(" ").filter(Boolean) : [];
    var curList = cur["class"] ? cur["class"].split(" ").filter(Boolean) : [];

    for (var i = 0; i < prevList.length; i++) {
      if (curList.indexOf(prevList[i]) == -1) dom.classList.remove(prevList[i]);
    }

    for (var _i = 0; _i < curList.length; _i++) {
      if (prevList.indexOf(curList[_i]) == -1) dom.classList.add(curList[_i]);
    }

    if (dom.classList.length == 0) dom.removeAttribute("class");
  }

  if (prev.style != cur.style) {
    if (prev.style) {
      var prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g,
          m;

      while (m = prop.exec(prev.style)) {
        dom.style.removeProperty(m[1]);
      }
    }

    if (cur.style) dom.style.cssText += cur.style;
  }
}

function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
}

function sameOuterDeco(a, b) {
  if (a.length != b.length) return false;

  for (var i = 0; i < a.length; i++) {
    if (!a[i].type.eq(b[i].type)) return false;
  }

  return true;
}

function rm(dom) {
  var next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}

var ViewTreeUpdater = function () {
  function ViewTreeUpdater(top, lock, view) {
    _classCallCheck(this, ViewTreeUpdater);

    this.lock = lock;
    this.view = view;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top;
    this.preMatch = preMatch(top.node.content, top);
  }

  _createClass(ViewTreeUpdater, [{
    key: "destroyBetween",
    value: function destroyBetween(start, end) {
      if (start == end) return;

      for (var i = start; i < end; i++) {
        this.top.children[i].destroy();
      }

      this.top.children.splice(start, end - start);
      this.changed = true;
    }
  }, {
    key: "destroyRest",
    value: function destroyRest() {
      this.destroyBetween(this.index, this.top.children.length);
    }
  }, {
    key: "syncToMarks",
    value: function syncToMarks(marks, inline, view) {
      var keep = 0,
          depth = this.stack.length >> 1;
      var maxKeep = Math.min(depth, marks.length);

      while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false) {
        keep++;
      }

      while (keep < depth) {
        this.destroyRest();
        this.top.dirty = NOT_DIRTY;
        this.index = this.stack.pop();
        this.top = this.stack.pop();
        depth--;
      }

      while (depth < marks.length) {
        this.stack.push(this.top, this.index + 1);
        var found = -1;

        for (var i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
          var next = this.top.children[i];

          if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
            found = i;
            break;
          }
        }

        if (found > -1) {
          if (found > this.index) {
            this.changed = true;
            this.destroyBetween(this.index, found);
          }

          this.top = this.top.children[this.index];
        } else {
          var markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
          this.top.children.splice(this.index, 0, markDesc);
          this.top = markDesc;
          this.changed = true;
        }

        this.index = 0;
        depth++;
      }
    }
  }, {
    key: "findNodeMatch",
    value: function findNodeMatch(node, outerDeco, innerDeco, index) {
      var found = -1,
          targetDesc;

      if (index >= this.preMatch.index && (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
        found = this.top.children.indexOf(targetDesc, this.index);
      } else {
        for (var i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
          var child = this.top.children[i];

          if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
            found = i;
            break;
          }
        }
      }

      if (found < 0) return false;
      this.destroyBetween(this.index, found);
      this.index++;
      return true;
    }
  }, {
    key: "updateNodeAt",
    value: function updateNodeAt(node, outerDeco, innerDeco, index, view) {
      var child = this.top.children[index];
      if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM) child.dirty = CONTENT_DIRTY;
      if (!child.update(node, outerDeco, innerDeco, view)) return false;
      this.destroyBetween(this.index, index);
      this.index++;
      return true;
    }
  }, {
    key: "findIndexWithChild",
    value: function findIndexWithChild(domNode) {
      for (;;) {
        var parent = domNode.parentNode;
        if (!parent) return -1;

        if (parent == this.top.contentDOM) {
          var desc = domNode.pmViewDesc;
          if (desc) for (var i = this.index; i < this.top.children.length; i++) {
            if (this.top.children[i] == desc) return i;
          }
          return -1;
        }

        domNode = parent;
      }
    }
  }, {
    key: "updateNextNode",
    value: function updateNextNode(node, outerDeco, innerDeco, view, index, pos) {
      for (var i = this.index; i < this.top.children.length; i++) {
        var next = this.top.children[i];

        if (next instanceof NodeViewDesc) {
          var _preMatch = this.preMatch.matched.get(next);

          if (_preMatch != null && _preMatch != index) return false;
          var nextDOM = next.dom,
              updated = void 0;
          var locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));

          if (!locked && next.update(node, outerDeco, innerDeco, view)) {
            this.destroyBetween(this.index, i);
            if (next.dom != nextDOM) this.changed = true;
            this.index++;
            return true;
          } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
            this.top.children[this.index] = updated;
            updated.dirty = CONTENT_DIRTY;
            updated.updateChildren(view, pos + 1);
            updated.dirty = NOT_DIRTY;
            this.changed = true;
            this.index++;
            return true;
          }

          break;
        }
      }

      return false;
    }
  }, {
    key: "recreateWrapper",
    value: function recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
      if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content)) return null;
      var wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
      if (!wrapper.contentDOM) return null;
      wrapper.children = next.children;
      next.children = [];
      next.destroy();

      var _iterator = _createForOfIteratorHelper(wrapper.children),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var ch = _step.value;
          ch.parent = wrapper;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return wrapper;
    }
  }, {
    key: "addNode",
    value: function addNode(node, outerDeco, innerDeco, view, pos) {
      var desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
      if (desc.contentDOM) desc.updateChildren(view, pos + 1);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }, {
    key: "placeWidget",
    value: function placeWidget(widget, view, pos) {
      var next = this.index < this.top.children.length ? this.top.children[this.index] : null;

      if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
        this.index++;
      } else {
        var desc = new WidgetViewDesc(this.top, widget, view, pos);
        this.top.children.splice(this.index++, 0, desc);
        this.changed = true;
      }
    }
  }, {
    key: "addTextblockHacks",
    value: function addTextblockHacks() {
      var lastChild = this.top.children[this.index - 1],
          parent = this.top;

      while (lastChild instanceof MarkViewDesc) {
        parent = lastChild;
        lastChild = parent.children[parent.children.length - 1];
      }

      if (!lastChild || !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
        if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false") this.addHackNode("IMG", parent);
        this.addHackNode("BR", this.top);
      }
    }
  }, {
    key: "addHackNode",
    value: function addHackNode(nodeName, parent) {
      if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
        this.index++;
      } else {
        var dom = document.createElement(nodeName);

        if (nodeName == "IMG") {
          dom.className = "ProseMirror-separator";
          dom.alt = "";
        }

        if (nodeName == "BR") dom.className = "ProseMirror-trailingBreak";
        var hack = new TrailingHackViewDesc(this.top, [], dom, null);
        if (parent != this.top) parent.children.push(hack);else parent.children.splice(this.index++, 0, hack);
        this.changed = true;
      }
    }
  }, {
    key: "isLocked",
    value: function isLocked(node) {
      return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
    }
  }]);

  return ViewTreeUpdater;
}();

function preMatch(frag, parentDesc) {
  var curDesc = parentDesc,
      descI = curDesc.children.length;
  var fI = frag.childCount,
      matched = new Map(),
      matches = [];

  outer: while (fI > 0) {
    var desc = void 0;

    for (;;) {
      if (descI) {
        var next = curDesc.children[descI - 1];

        if (next instanceof MarkViewDesc) {
          curDesc = next;
          descI = next.children.length;
        } else {
          desc = next;
          descI--;
          break;
        }
      } else if (curDesc == parentDesc) {
        break outer;
      } else {
        descI = curDesc.parent.children.indexOf(curDesc);
        curDesc = curDesc.parent;
      }
    }

    var node = desc.node;
    if (!node) continue;
    if (node != frag.child(fI - 1)) break;
    --fI;
    matched.set(desc, fI);
    matches.push(desc);
  }

  return {
    index: fI,
    matched: matched,
    matches: matches.reverse()
  };
}

function compareSide(a, b) {
  return a.type.side - b.type.side;
}

function iterDeco(parent, deco, onWidget, onNode) {
  var locals = deco.locals(parent),
      offset = 0;

  if (locals.length == 0) {
    for (var i = 0; i < parent.childCount; i++) {
      var child = parent.child(i);
      onNode(child, locals, deco.forChild(offset, child), i);
      offset += child.nodeSize;
    }

    return;
  }

  var decoIndex = 0,
      active = [],
      restNode = null;

  for (var parentIndex = 0;;) {
    if (decoIndex < locals.length && locals[decoIndex].to == offset) {
      var widget = locals[decoIndex++],
          widgets = void 0;

      while (decoIndex < locals.length && locals[decoIndex].to == offset) {
        (widgets || (widgets = [widget])).push(locals[decoIndex++]);
      }

      if (widgets) {
        widgets.sort(compareSide);

        for (var _i2 = 0; _i2 < widgets.length; _i2++) {
          onWidget(widgets[_i2], parentIndex, !!restNode);
        }
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }

    var _child = void 0,
        index = void 0;

    if (restNode) {
      index = -1;
      _child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index = parentIndex;
      _child = parent.child(parentIndex++);
    } else {
      break;
    }

    for (var _i3 = 0; _i3 < active.length; _i3++) {
      if (active[_i3].to <= offset) active.splice(_i3--, 1);
    }

    while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset) {
      active.push(locals[decoIndex++]);
    }

    var end = offset + _child.nodeSize;

    if (_child.isText) {
      var cutAt = end;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt) cutAt = locals[decoIndex].from;

      for (var _i4 = 0; _i4 < active.length; _i4++) {
        if (active[_i4].to < cutAt) cutAt = active[_i4].to;
      }

      if (cutAt < end) {
        restNode = _child.cut(cutAt - offset);
        _child = _child.cut(0, cutAt - offset);
        end = cutAt;
        index = -1;
      }
    }

    var outerDeco = _child.isInline && !_child.isLeaf ? active.filter(function (d) {
      return !d.inline;
    }) : active.slice();
    onNode(_child, outerDeco, deco.forChild(offset, _child), index);
    offset = end;
  }
}

function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    var oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}

function nearbyTextNode(node, offset) {
  for (;;) {
    if (node.nodeType == 3) return node;

    if (node.nodeType == 1 && offset > 0) {
      if (node.childNodes.length > offset && node.childNodes[offset].nodeType == 3) return node.childNodes[offset];
      node = node.childNodes[offset - 1];
      offset = nodeSize(node);
    } else if (node.nodeType == 1 && offset < node.childNodes.length) {
      node = node.childNodes[offset];
      offset = 0;
    } else {
      return null;
    }
  }
}

function findTextInFragment(frag, text, from, to) {
  for (var i = 0, pos = 0; i < frag.childCount && pos <= to;) {
    var child = frag.child(i++),
        childStart = pos;
    pos += child.nodeSize;
    if (!child.isText) continue;
    var str = child.text;

    while (i < frag.childCount) {
      var next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText) break;
      str += next.text;
    }

    if (pos >= from) {
      var found = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
      if (found >= 0 && found + text.length + childStart >= from) return childStart + found;
      if (from == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text) return to;
    }
  }

  return -1;
}

function replaceNodes(nodes, from, to, view, replacement) {
  var result = [];

  for (var i = 0, off = 0; i < nodes.length; i++) {
    var child = nodes[i],
        start = off,
        end = off += child.size;

    if (start >= to || end <= from) {
      result.push(child);
    } else {
      if (start < from) result.push(child.slice(0, from - start, view));

      if (replacement) {
        result.push(replacement);
        replacement = undefined;
      }

      if (end > to) result.push(child.slice(to - start, child.size, view));
    }
  }

  return result;
}

function selectionFromDOM(view) {
  var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var domSel = view.domSelectionRange(),
      doc = view.state.doc;
  if (!domSel.focusNode) return null;
  var nearestDesc = view.docView.nearestDesc(domSel.focusNode),
      inWidget = nearestDesc && nearestDesc.size == 0;
  var head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0) return null;
  var $head = doc.resolve(head),
      $anchor,
      selection;

  if (selectionCollapsed(domSel)) {
    $anchor = $head;

    while (nearestDesc && !nearestDesc.node) {
      nearestDesc = nearestDesc.parent;
    }

    var nearestDescNode = nearestDesc.node;

    if (nearestDesc && nearestDescNode.isAtom && prosemirrorState.NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      var pos = nearestDesc.posBefore;
      selection = new prosemirrorState.NodeSelection(head == pos ? $head : doc.resolve(pos));
    }
  } else {
    var anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    if (anchor < 0) return null;
    $anchor = doc.resolve(anchor);
  }

  if (!selection) {
    var bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }

  return selection;
}

function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}

function selectionToDOM(view) {
  var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view)) return;

  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    var domSel = view.domSelectionRange(),
        curSel = view.domObserver.currentSelection;

    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }

  view.domObserver.disconnectSelection();

  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    var anchor = sel.anchor,
        head = sel.head,
        resetEditableFrom,
        resetEditableTo;

    if (brokenSelectBetweenUneditable && !(sel instanceof prosemirrorState.TextSelection)) {
      if (!sel.$from.parent.inlineContent) resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent) resetEditableTo = temporarilyEditableNear(view, sel.to);
    }

    view.docView.setSelection(anchor, head, view.root, force);

    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom) resetEditable(resetEditableFrom);
      if (resetEditableTo) resetEditable(resetEditableTo);
    }

    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document) removeClassOnSelectionChange(view);
    }
  }

  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}

var brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;

function temporarilyEditableNear(view, pos) {
  var _view$docView$domFrom3 = view.docView.domFromPos(pos, 0),
      node = _view$docView$domFrom3.node,
      offset = _view$docView$domFrom3.offset;

  var after = offset < node.childNodes.length ? node.childNodes[offset] : null;
  var before = offset ? node.childNodes[offset - 1] : null;
  if (safari && after && after.contentEditable == "false") return setEditable(after);

  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after) return setEditable(after);else if (before) return setEditable(before);
  }
}

function setEditable(element) {
  element.contentEditable = "true";

  if (safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }

  return element;
}

function resetEditable(element) {
  element.contentEditable = "false";

  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}

function removeClassOnSelectionChange(view) {
  var doc = view.dom.ownerDocument;
  doc.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  var domSel = view.domSelectionRange();
  var node = domSel.anchorNode,
      offset = domSel.anchorOffset;
  doc.addEventListener("selectionchange", view.input.hideSelectionGuard = function () {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset) {
      doc.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(function () {
        if (!editorOwnsSelection(view) || view.state.selection.visible) view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}

function selectCursorWrapper(view) {
  var domSel = view.domSelection(),
      range = document.createRange();
  var node = view.cursorWrapper.dom,
      img = node.nodeName == "IMG";
  if (img) range.setEnd(node.parentNode, domIndex(node) + 1);else range.setEnd(node, 0);
  range.collapse(false);
  domSel.removeAllRanges();
  domSel.addRange(range);

  if (!img && !view.state.selection.visible && ie && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}

function syncNodeSelection(view, sel) {
  if (sel instanceof prosemirrorState.NodeSelection) {
    var desc = view.docView.descAt(sel.from);

    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc) desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}

function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent) view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = undefined;
  }
}

function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", function (f) {
    return f(view, $anchor, $head);
  }) || prosemirrorState.TextSelection.between($anchor, $head, bias);
}

function hasFocusAndSelection(view) {
  if (view.editable && !view.hasFocus()) return false;
  return hasSelection(view);
}

function hasSelection(view) {
  var sel = view.domSelectionRange();
  if (!sel.anchorNode) return false;

  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}

function anchorInRightPlace(view) {
  var anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  var domSel = view.domSelectionRange();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}

function moveSelectionBlock(state, dir) {
  var _state$selection = state.selection,
      $anchor = _state$selection.$anchor,
      $head = _state$selection.$head;
  var $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  var $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && prosemirrorState.Selection.findFrom($start, dir);
}

function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}

function selectHorizontally(view, dir, mods) {
  var sel = view.state.selection;

  if (sel instanceof prosemirrorState.TextSelection) {
    if (!sel.empty || mods.indexOf("s") > -1) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      var next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof prosemirrorState.NodeSelection) return apply(view, next);
      return false;
    } else if (!(mac && mods.indexOf("m") > -1)) {
      var $head = sel.$head,
          node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter,
          desc;
      if (!node || node.isText) return false;
      var nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM)) return false;

      if (prosemirrorState.NodeSelection.isSelectable(node)) {
        return apply(view, new prosemirrorState.NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
      } else if (webkit) {
        return apply(view, new prosemirrorState.TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof prosemirrorState.NodeSelection && sel.node.isInline) {
    return apply(view, new prosemirrorState.TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    var _next = moveSelectionBlock(view.state, dir);

    if (_next) return apply(view, _next);
    return false;
  }
}

function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}

function isIgnorable(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dom.nextSibling || dom.nodeName != "BR");
}

function skipIgnoredNodes(view, dir) {
  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
}

function skipIgnoredNodesBefore(view) {
  var sel = view.domSelectionRange();
  var node = sel.focusNode,
      offset = sel.focusOffset;
  if (!node) return;
  var moveNode,
      moveOffset,
      force = false;
  if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset])) force = true;

  for (;;) {
    if (offset > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        var before = node.childNodes[offset - 1];

        if (isIgnorable(before)) {
          moveNode = node;
          moveOffset = --offset;
        } else if (before.nodeType == 3) {
          node = before;
          offset = node.nodeValue.length;
        } else break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      var prev = node.previousSibling;

      while (prev && isIgnorable(prev)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }

      if (!prev) {
        node = node.parentNode;
        if (node == view.dom) break;
        offset = 0;
      } else {
        node = prev;
        offset = nodeLen(node);
      }
    }
  }

  if (force) setSelFocus(view, node, offset);else if (moveNode) setSelFocus(view, moveNode, moveOffset);
}

function skipIgnoredNodesAfter(view) {
  var sel = view.domSelectionRange();
  var node = sel.focusNode,
      offset = sel.focusOffset;
  if (!node) return;
  var len = nodeLen(node);
  var moveNode, moveOffset;

  for (;;) {
    if (offset < len) {
      if (node.nodeType != 1) break;
      var after = node.childNodes[offset];

      if (isIgnorable(after)) {
        moveNode = node;
        moveOffset = ++offset;
      } else break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      var next = node.nextSibling;

      while (next && isIgnorable(next)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }

      if (!next) {
        node = node.parentNode;
        if (node == view.dom) break;
        offset = len = 0;
      } else {
        node = next;
        offset = 0;
        len = nodeLen(node);
      }
    }
  }

  if (moveNode) setSelFocus(view, moveNode, moveOffset);
}

function isBlockNode(dom) {
  var desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}

function setSelFocus(view, node, offset) {
  var sel = view.domSelection();

  if (selectionCollapsed(sel)) {
    var range = document.createRange();
    range.setEnd(node, offset);
    range.setStart(node, offset);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset);
  }

  view.domObserver.setCurSelection();
  var state = view.state;
  setTimeout(function () {
    if (view.state == state) selectionToDOM(view);
  }, 50);
}

function findDirection(view, pos) {
  var $pos = view.state.doc.resolve(pos);

  if (!(chrome || windows) && $pos.parent.inlineContent) {
    var coords = view.coordsAtPos(pos);

    if (pos > $pos.start()) {
      var before = view.coordsAtPos(pos - 1);
      var mid = (before.top + before.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1) return before.left < coords.left ? "ltr" : "rtl";
    }

    if (pos < $pos.end()) {
      var after = view.coordsAtPos(pos + 1);

      var _mid = (after.top + after.bottom) / 2;

      if (_mid > coords.top && _mid < coords.bottom && Math.abs(after.left - coords.left) > 1) return after.left > coords.left ? "ltr" : "rtl";
    }
  }

  var computed = getComputedStyle(view.dom).direction;
  return computed == "rtl" ? "rtl" : "ltr";
}

function selectVertically(view, dir, mods) {
  var sel = view.state.selection;
  if (sel instanceof prosemirrorState.TextSelection && !sel.empty || mods.indexOf("s") > -1) return false;
  if (mac && mods.indexOf("m") > -1) return false;
  var $from = sel.$from,
      $to = sel.$to;

  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    var next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof prosemirrorState.NodeSelection) return apply(view, next);
  }

  if (!$from.parent.inlineContent) {
    var side = dir < 0 ? $from : $to;
    var beyond = sel instanceof prosemirrorState.AllSelection ? prosemirrorState.Selection.near(side, dir) : prosemirrorState.Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }

  return false;
}

function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof prosemirrorState.TextSelection)) return true;
  var _view$state$selection2 = view.state.selection,
      $head = _view$state$selection2.$head,
      $anchor = _view$state$selection2.$anchor,
      empty = _view$state$selection2.empty;
  if (!$head.sameParent($anchor)) return true;
  if (!empty) return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) return true;
  var nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);

  if (nextNode && !nextNode.isText) {
    var tr = view.state.tr;
    if (dir < 0) tr["delete"]($head.pos - nextNode.nodeSize, $head.pos);else tr["delete"]($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr);
    return true;
  }

  return false;
}

function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}

function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0) return false;

  var _view$domSelectionRan3 = view.domSelectionRange(),
      focusNode = _view$domSelectionRan3.focusNode,
      focusOffset = _view$domSelectionRan3.focusOffset;

  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    var child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(function () {
      return switchEditable(view, child, "false");
    }, 20);
  }

  return false;
}

function getMods(event) {
  var result = "";
  if (event.ctrlKey) result += "c";
  if (event.metaKey) result += "m";
  if (event.altKey) result += "a";
  if (event.shiftKey) result += "s";
  return result;
}

function captureKeyDown(view, event) {
  var code = event.keyCode,
      mods = getMods(event);

  if (code == 8 || mac && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
  } else if (code == 46 || mac && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37 || mac && code == 66 && mods == "c") {
    var dir = code == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 39 || mac && code == 70 && mods == "c") {
    var _dir = code == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;

    return selectHorizontally(view, _dir, mods) || skipIgnoredNodes(view, _dir);
  } else if (code == 38 || mac && code == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
  } else if (code == 40 || mac && code == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodesAfter(view);
  } else if (mods == (mac ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }

  return false;
}

function serializeForClipboard(view, slice) {
  view.someProp("transformCopied", function (f) {
    slice = f(slice, view);
  });
  var context = [],
      _slice = slice,
      content = _slice.content,
      openStart = _slice.openStart,
      openEnd = _slice.openEnd;

  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    var node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }

  var serializer = view.someProp("clipboardSerializer") || prosemirrorModel.DOMSerializer.fromSchema(view.state.schema);
  var doc = detachedDoc(),
      wrap = doc.createElement("div");
  wrap.appendChild(serializer.serializeFragment(content, {
    document: doc
  }));
  var firstChild = wrap.firstChild,
      needsWrap,
      wrappers = 0;

  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (var i = needsWrap.length - 1; i >= 0; i--) {
      var wrapper = doc.createElement(needsWrap[i]);

      while (wrap.firstChild) {
        wrapper.appendChild(wrap.firstChild);
      }

      wrap.appendChild(wrapper);
      wrappers++;
    }

    firstChild = wrap.firstChild;
  }

  if (firstChild && firstChild.nodeType == 1) firstChild.setAttribute("data-pm-slice", "".concat(openStart, " ").concat(openEnd).concat(wrappers ? " -".concat(wrappers) : "", " ").concat(JSON.stringify(context)));
  var text = view.someProp("clipboardTextSerializer", function (f) {
    return f(slice, view);
  }) || slice.content.textBetween(0, slice.content.size, "\n\n");
  return {
    dom: wrap,
    text: text
  };
}

function parseFromClipboard(view, text, html, plainText, $context) {
  var inCode = $context.parent.type.spec.code;
  var dom, slice;
  if (!html && !text) return null;
  var asText = text && (plainText || inCode || !html);

  if (asText) {
    view.someProp("transformPastedText", function (f) {
      text = f(text, inCode || plainText, view);
    });
    if (inCode) return text ? new prosemirrorModel.Slice(prosemirrorModel.Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : prosemirrorModel.Slice.empty;
    var parsed = view.someProp("clipboardTextParser", function (f) {
      return f(text, $context, plainText, view);
    });

    if (parsed) {
      slice = parsed;
    } else {
      var marks = $context.marks();
      var schema = view.state.schema,
          serializer = prosemirrorModel.DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text.split(/(?:\r\n?|\n)+/).forEach(function (block) {
        var p = dom.appendChild(document.createElement("p"));
        if (block) p.appendChild(serializer.serializeNode(schema.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", function (f) {
      html = f(html, view);
    });
    dom = readHTML(html);
    if (webkit) restoreReplacedSpaces(dom);
  }

  var contextNode = dom && dom.querySelector("[data-pm-slice]");
  var sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3]) for (var i = +sliceData[3]; i > 0; i--) {
    var child = dom.firstChild;

    while (child && child.nodeType != 1) {
      child = child.nextSibling;
    }

    if (!child) break;
    dom = child;
  }

  if (!slice) {
    var parser = view.someProp("clipboardParser") || view.someProp("domParser") || prosemirrorModel.DOMParser.fromSchema(view.state.schema);
    slice = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode: function ruleFromNode(dom) {
        if (dom.nodeName == "BR" && !dom.nextSibling && dom.parentNode && !inlineParents.test(dom.parentNode.nodeName)) return {
          ignore: true
        };
        return null;
      }
    });
  }

  if (sliceData) {
    slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice = prosemirrorModel.Slice.maxOpen(normalizeSiblings(slice.content, $context), true);

    if (slice.openStart || slice.openEnd) {
      var openStart = 0,
          openEnd = 0;

      for (var node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {}

      for (var _node = slice.content.lastChild; openEnd < slice.openEnd && !_node.type.spec.isolating; openEnd++, _node = _node.lastChild) {}

      slice = closeSlice(slice, openStart, openEnd);
    }
  }

  view.someProp("transformPasted", function (f) {
    slice = f(slice, view);
  });
  return slice;
}

var inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;

function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2) return fragment;

  var _loop = function _loop(d) {
    var parent = $context.node(d);
    var match = parent.contentMatchAt($context.index(d));
    var lastWrap = void 0,
        result = [];
    fragment.forEach(function (node) {
      if (!result) return;
      var wrap = match.findWrapping(node.type),
          inLast;
      if (!wrap) return result = null;

      if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length) result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        var wrapped = withWrappers(node, wrap);
        result.push(wrapped);
        match = match.matchType(wrapped.type);
        lastWrap = wrap;
      }
    });
    if (result) return {
      v: prosemirrorModel.Fragment.from(result)
    };
  };

  for (var d = $context.depth; d >= 0; d--) {
    var _ret = _loop(d);

    if (_typeof(_ret) === "object") return _ret.v;
  }

  return fragment;
}

function withWrappers(node, wrap) {
  var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

  for (var i = wrap.length - 1; i >= from; i--) {
    node = wrap[i].create(null, prosemirrorModel.Fragment.from(node));
  }

  return node;
}

function addToSibling(wrap, lastWrap, node, sibling, depth) {
  if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {
    var inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner) return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    var match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1])) return sibling.copy(sibling.content.append(prosemirrorModel.Fragment.from(withWrappers(node, wrap, depth + 1))));
  }
}

function closeRight(node, depth) {
  if (depth == 0) return node;
  var fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  var fill = node.contentMatchAt(node.childCount).fillBefore(prosemirrorModel.Fragment.empty, true);
  return node.copy(fragment.append(fill));
}

function closeRange(fragment, side, from, to, depth, openEnd) {
  var node = side < 0 ? fragment.firstChild : fragment.lastChild,
      inner = node.content;
  if (fragment.childCount > 1) openEnd = 0;
  if (depth < to - 1) inner = closeRange(inner, side, from, to, depth + 1, openEnd);
  if (depth >= from) inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(prosemirrorModel.Fragment.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}

function closeSlice(slice, openStart, openEnd) {
  if (openStart < slice.openStart) slice = new prosemirrorModel.Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);
  if (openEnd < slice.openEnd) slice = new prosemirrorModel.Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);
  return slice;
}

var wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
var _detachedDoc = null;

function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}

function readHTML(html) {
  var metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas) html = html.slice(metas[0].length);
  var elt = detachedDoc().createElement("div");
  var firstTag = /<([a-z][^>\s]+)/i.exec(html),
      wrap;
  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()]) html = wrap.map(function (n) {
    return "<" + n + ">";
  }).join("") + html + wrap.map(function (n) {
    return "</" + n + ">";
  }).reverse().join("");
  elt.innerHTML = html;
  if (wrap) for (var i = 0; i < wrap.length; i++) {
    elt = elt.querySelector(wrap[i]) || elt;
  }
  return elt;
}

function restoreReplacedSpaces(dom) {
  var nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");

  for (var i = 0; i < nodes.length; i++) {
    var node = nodes[i];
    if (node.childNodes.length == 1 && node.textContent == "\xA0" && node.parentNode) node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
  }
}

function addContext(slice, context) {
  if (!slice.size) return slice;
  var schema = slice.content.firstChild.type.schema,
      array;

  try {
    array = JSON.parse(context);
  } catch (e) {
    return slice;
  }

  var content = slice.content,
      openStart = slice.openStart,
      openEnd = slice.openEnd;

  for (var i = array.length - 2; i >= 0; i -= 2) {
    var type = schema.nodes[array[i]];
    if (!type || type.hasRequiredAttrs()) break;
    content = prosemirrorModel.Fragment.from(type.create(array[i + 1], content));
    openStart++;
    openEnd++;
  }

  return new prosemirrorModel.Slice(content, openStart, openEnd);
}

var handlers = {};
var editHandlers = {};
var passiveHandlers = {
  touchstart: true,
  touchmove: true
};

var InputState = _createClass(function InputState() {
  _classCallCheck(this, InputState);

  this.shiftKey = false;
  this.mouseDown = null;
  this.lastKeyCode = null;
  this.lastKeyCodeTime = 0;
  this.lastClick = {
    time: 0,
    x: 0,
    y: 0,
    type: ""
  };
  this.lastSelectionOrigin = null;
  this.lastSelectionTime = 0;
  this.lastIOSEnter = 0;
  this.lastIOSEnterFallbackTimeout = -1;
  this.lastFocus = 0;
  this.lastTouch = 0;
  this.lastAndroidDelete = 0;
  this.composing = false;
  this.composingTimeout = -1;
  this.compositionNodes = [];
  this.compositionEndedAt = -2e8;
  this.compositionID = 1;
  this.domChangeCount = 0;
  this.eventHandlers = Object.create(null);
  this.hideSelectionGuard = null;
});

function initInput(view) {
  var _loop2 = function _loop2(event) {
    var handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = function (event) {
      if (eventBelongsToView(view, event) && !runCustomHandler(view, event) && (view.editable || !(event.type in editHandlers))) handler(view, event);
    }, passiveHandlers[event] ? {
      passive: true
    } : undefined);
  };

  for (var event in handlers) {
    _loop2(event);
  }

  if (safari) view.dom.addEventListener("input", function () {
    return null;
  });
  ensureListeners(view);
}

function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}

function destroyInput(view) {
  view.domObserver.stop();

  for (var type in view.input.eventHandlers) {
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  }

  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}

function ensureListeners(view) {
  view.someProp("handleDOMEvents", function (currentHandlers) {
    for (var type in currentHandlers) {
      if (!view.input.eventHandlers[type]) view.dom.addEventListener(type, view.input.eventHandlers[type] = function (event) {
        return runCustomHandler(view, event);
      });
    }
  });
}

function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", function (handlers) {
    var handler = handlers[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}

function eventBelongsToView(view, event) {
  if (!event.bubbles) return true;
  if (event.defaultPrevented) return false;

  for (var node = event.target; node != view.dom; node = node.parentNode) {
    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event)) return false;
  }

  return true;
}

function _dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers))) handlers[event.type](view, event);
}

editHandlers.keydown = function (view, _event) {
  var event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event)) return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome && event.keyCode == 13) return;
  if (event.keyCode != 229) view.domObserver.forceFlush();

  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    var now = Date.now();
    view.input.lastIOSEnter = now;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(function () {
      if (view.input.lastIOSEnter == now) {
        view.someProp("handleKeyDown", function (f) {
          return f(view, keyEvent(13, "Enter"));
        });
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", function (f) {
    return f(view, event);
  }) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};

editHandlers.keyup = function (view, event) {
  if (event.keyCode == 16) view.input.shiftKey = false;
};

editHandlers.keypress = function (view, _event) {
  var event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac && event.metaKey) return;

  if (view.someProp("handleKeyPress", function (f) {
    return f(view, event);
  })) {
    event.preventDefault();
    return;
  }

  var sel = view.state.selection;

  if (!(sel instanceof prosemirrorState.TextSelection) || !sel.$from.sameParent(sel.$to)) {
    var text = String.fromCharCode(event.charCode);
    if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", function (f) {
      return f(view, sel.$from.pos, sel.$to.pos, text);
    })) view.dispatch(view.state.tr.insertText(text).scrollIntoView());
    event.preventDefault();
  }
};

function eventCoords(event) {
  return {
    left: event.clientX,
    top: event.clientY
  };
}

function isNear(event, click) {
  var dx = click.x - event.clientX,
      dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}

function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1) return false;
  var $pos = view.state.doc.resolve(inside);

  var _loop3 = function _loop3(i) {
    if (view.someProp(propName, function (f) {
      return i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false);
    })) return {
      v: true
    };
  };

  for (var i = $pos.depth + 1; i > 0; i--) {
    var _ret2 = _loop3(i);

    if (_typeof(_ret2) === "object") return _ret2.v;
  }

  return false;
}

function updateSelection(view, selection, origin) {
  if (!view.focused) view.focus();
  var tr = view.state.tr.setSelection(selection);
  if (origin == "pointer") tr.setMeta("pointer", true);
  view.dispatch(tr);
}

function selectClickedLeaf(view, inside) {
  if (inside == -1) return false;
  var $pos = view.state.doc.resolve(inside),
      node = $pos.nodeAfter;

  if (node && node.isAtom && prosemirrorState.NodeSelection.isSelectable(node)) {
    updateSelection(view, new prosemirrorState.NodeSelection($pos), "pointer");
    return true;
  }

  return false;
}

function selectClickedNode(view, inside) {
  if (inside == -1) return false;
  var sel = view.state.selection,
      selectedNode,
      selectAt;
  if (sel instanceof prosemirrorState.NodeSelection) selectedNode = sel.node;
  var $pos = view.state.doc.resolve(inside);

  for (var i = $pos.depth + 1; i > 0; i--) {
    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);

    if (prosemirrorState.NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos) selectAt = $pos.before(sel.$from.depth);else selectAt = $pos.before(i);
      break;
    }
  }

  if (selectAt != null) {
    updateSelection(view, prosemirrorState.NodeSelection.create(view.state.doc, selectAt), "pointer");
    return true;
  } else {
    return false;
  }
}

function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", function (f) {
    return f(view, pos, event);
  }) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}

function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", function (f) {
    return f(view, pos, event);
  });
}

function handleTripleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", function (f) {
    return f(view, pos, event);
  }) || defaultTripleClick(view, inside, event);
}

function defaultTripleClick(view, inside, event) {
  if (event.button != 0) return false;
  var doc = view.state.doc;

  if (inside == -1) {
    if (doc.inlineContent) {
      updateSelection(view, prosemirrorState.TextSelection.create(doc, 0, doc.content.size), "pointer");
      return true;
    }

    return false;
  }

  var $pos = doc.resolve(inside);

  for (var i = $pos.depth + 1; i > 0; i--) {
    var node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    var nodePos = $pos.before(i);
    if (node.inlineContent) updateSelection(view, prosemirrorState.TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), "pointer");else if (prosemirrorState.NodeSelection.isSelectable(node)) updateSelection(view, prosemirrorState.NodeSelection.create(doc, nodePos), "pointer");else continue;
    return true;
  }
}

function forceDOMFlush(view) {
  return endComposition(view);
}

var selectNodeModifier = mac ? "metaKey" : "ctrlKey";

handlers.mousedown = function (view, _event) {
  var event = _event;
  view.input.shiftKey = event.shiftKey;
  var flushed = forceDOMFlush(view);
  var now = Date.now(),
      type = "singleClick";

  if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier]) {
    if (view.input.lastClick.type == "singleClick") type = "doubleClick";else if (view.input.lastClick.type == "doubleClick") type = "tripleClick";
  }

  view.input.lastClick = {
    time: now,
    x: event.clientX,
    y: event.clientY,
    type: type
  };
  var pos = view.posAtCoords(eventCoords(event));
  if (!pos) return;

  if (type == "singleClick") {
    if (view.input.mouseDown) view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};

var MouseDown = function () {
  function MouseDown(view, pos, event, flushed) {
    var _this8 = this;

    _classCallCheck(this, MouseDown);

    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    var targetNode, targetPos;

    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      var $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }

    var target = flushed ? null : event.target;
    var targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc ? targetDesc.dom : null;
    var selection = view.state.selection;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof prosemirrorState.NodeSelection && selection.from <= targetPos && selection.to > targetPos) this.mightDrag = {
      node: targetNode,
      pos: targetPos,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
    };

    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr) this.target.draggable = true;
      if (this.mightDrag.setUneditable) setTimeout(function () {
        if (_this8.view.input.mouseDown == _this8) _this8.target.setAttribute("contentEditable", "false");
      }, 20);
      this.view.domObserver.start();
    }

    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }

  _createClass(MouseDown, [{
    key: "done",
    value: function done() {
      var _this9 = this;

      this.view.root.removeEventListener("mouseup", this.up);
      this.view.root.removeEventListener("mousemove", this.move);

      if (this.mightDrag && this.target) {
        this.view.domObserver.stop();
        if (this.mightDrag.addAttr) this.target.removeAttribute("draggable");
        if (this.mightDrag.setUneditable) this.target.removeAttribute("contentEditable");
        this.view.domObserver.start();
      }

      if (this.delayedSelectionSync) setTimeout(function () {
        return selectionToDOM(_this9.view);
      });
      this.view.input.mouseDown = null;
    }
  }, {
    key: "up",
    value: function up(event) {
      this.done();
      if (!this.view.dom.contains(event.target)) return;
      var pos = this.pos;
      if (this.view.state.doc != this.startDoc) pos = this.view.posAtCoords(eventCoords(event));
      this.updateAllowDefault(event);

      if (this.allowDefault || !pos) {
        setSelectionOrigin(this.view, "pointer");
      } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
        event.preventDefault();
      } else if (event.button == 0 && (this.flushed || safari && this.mightDrag && !this.mightDrag.node.isAtom || chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
        updateSelection(this.view, prosemirrorState.Selection.near(this.view.state.doc.resolve(pos.pos)), "pointer");
        event.preventDefault();
      } else {
        setSelectionOrigin(this.view, "pointer");
      }
    }
  }, {
    key: "move",
    value: function move(event) {
      this.updateAllowDefault(event);
      setSelectionOrigin(this.view, "pointer");
      if (event.buttons == 0) this.done();
    }
  }, {
    key: "updateAllowDefault",
    value: function updateAllowDefault(event) {
      if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4)) this.allowDefault = true;
    }
  }]);

  return MouseDown;
}();

handlers.touchstart = function (view) {
  view.input.lastTouch = Date.now();
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};

handlers.touchmove = function (view) {
  view.input.lastTouch = Date.now();
  setSelectionOrigin(view, "pointer");
};

handlers.contextmenu = function (view) {
  return forceDOMFlush(view);
};

function inOrNearComposition(view, event) {
  if (view.composing) return true;

  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }

  return false;
}

var timeoutComposition = android ? 5000 : -1;

editHandlers.compositionstart = editHandlers.compositionupdate = function (view) {
  if (!view.composing) {
    view.domObserver.flush();
    var state = view.state,
        $pos = state.selection.$from;

    if (state.selection.empty && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(function (m) {
      return m.type.spec.inclusive === false;
    }))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view);

      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        var sel = view.domSelectionRange();

        for (var node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;) {
          var before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];
          if (!before) break;

          if (before.nodeType == 3) {
            view.domSelection().collapse(before, before.nodeValue.length);
            break;
          } else {
            node = before;
            offset = -1;
          }
        }
      }
    }

    view.input.composing = true;
  }

  scheduleComposeEnd(view, timeoutComposition);
};

editHandlers.compositionend = function (view, event) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    view.input.compositionID++;
    scheduleComposeEnd(view, 20);
  }
};

function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1) view.input.composingTimeout = setTimeout(function () {
    return endComposition(view);
  }, delay);
}

function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }

  while (view.input.compositionNodes.length > 0) {
    view.input.compositionNodes.pop().markParentsDirty();
  }
}

function timestampFromCustomEvent() {
  var event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}

function endComposition(view) {
  var forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  if (android && view.domObserver.flushingSoon >= 0) return;
  view.domObserver.forceFlush();
  clearComposition(view);

  if (forceUpdate || view.docView && view.docView.dirty) {
    var sel = selectionFromDOM(view);
    if (sel && !sel.eq(view.state.selection)) view.dispatch(view.state.tr.setSelection(sel));else view.updateState(view.state);
    return true;
  }

  return false;
}

function captureCopy(view, dom) {
  if (!view.dom.parentNode) return;
  var wrap = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap.appendChild(dom);
  wrap.style.cssText = "position: fixed; left: -10000px; top: 10px";
  var sel = getSelection(),
      range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(function () {
    if (wrap.parentNode) wrap.parentNode.removeChild(wrap);
    view.focus();
  }, 50);
}

var brokenClipboardAPI = ie && ie_version < 15 || ios && webkit_version < 604;

handlers.copy = editHandlers.cut = function (view, _event) {
  var event = _event;
  var sel = view.state.selection,
      cut = event.type == "cut";
  if (sel.empty) return;
  var data = brokenClipboardAPI ? null : event.clipboardData;

  var slice = sel.content(),
      _serializeForClipboar = serializeForClipboard(view, slice),
      dom = _serializeForClipboar.dom,
      text = _serializeForClipboar.text;

  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text);
  } else {
    captureCopy(view, dom);
  }

  if (cut) view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};

function sliceSingleNode(slice) {
  return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;
}

function capturePaste(view, event) {
  if (!view.dom.parentNode) return;
  var plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  var target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText) target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  setTimeout(function () {
    view.focus();
    if (target.parentNode) target.parentNode.removeChild(target);
    if (plainText) doPaste(view, target.value, null, view.input.shiftKey, event);else doPaste(view, target.textContent, target.innerHTML, view.input.shiftKey, event);
  }, 50);
}

function doPaste(view, text, html, preferPlain, event) {
  var slice = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", function (f) {
    return f(view, event, slice || prosemirrorModel.Slice.empty);
  })) return true;
  if (!slice) return false;
  var singleNode = sliceSingleNode(slice);
  var tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, view.input.shiftKey) : view.state.tr.replaceSelection(slice);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}

editHandlers.paste = function (view, _event) {
  var event = _event;
  if (view.composing && !android) return;
  var data = brokenClipboardAPI ? null : event.clipboardData;
  if (data && doPaste(view, data.getData("text/plain"), data.getData("text/html"), view.input.shiftKey, event)) event.preventDefault();else capturePaste(view, event);
};

var Dragging = _createClass(function Dragging(slice, move) {
  _classCallCheck(this, Dragging);

  this.slice = slice;
  this.move = move;
});

var dragCopyModifier = mac ? "altKey" : "ctrlKey";

handlers.dragstart = function (view, _event) {
  var event = _event;
  var mouseDown = view.input.mouseDown;
  if (mouseDown) mouseDown.done();
  if (!event.dataTransfer) return;
  var sel = view.state.selection;
  var pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirrorState.NodeSelection ? sel.to - 1 : sel.to)) ;else if (mouseDown && mouseDown.mightDrag) {
    view.dispatch(view.state.tr.setSelection(prosemirrorState.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos)));
  } else if (event.target && event.target.nodeType == 1) {
    var desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView) view.dispatch(view.state.tr.setSelection(prosemirrorState.NodeSelection.create(view.state.doc, desc.posBefore)));
  }

  var slice = view.state.selection.content(),
      _serializeForClipboar2 = serializeForClipboard(view, slice),
      dom = _serializeForClipboar2.dom,
      text = _serializeForClipboar2.text;

  event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI) event.dataTransfer.setData("text/plain", text);
  view.dragging = new Dragging(slice, !event[dragCopyModifier]);
};

handlers.dragend = function (view) {
  var dragging = view.dragging;
  window.setTimeout(function () {
    if (view.dragging == dragging) view.dragging = null;
  }, 50);
};

editHandlers.dragover = editHandlers.dragenter = function (_, e) {
  return e.preventDefault();
};

editHandlers.drop = function (view, _event) {
  var event = _event;
  var dragging = view.dragging;
  view.dragging = null;
  if (!event.dataTransfer) return;
  var eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos) return;
  var $mouse = view.state.doc.resolve(eventPos.pos);
  var slice = dragging && dragging.slice;

  if (slice) {
    view.someProp("transformPasted", function (f) {
      slice = f(slice, view);
    });
  } else {
    slice = parseFromClipboard(view, event.dataTransfer.getData(brokenClipboardAPI ? "Text" : "text/plain"), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }

  var move = !!(dragging && !event[dragCopyModifier]);

  if (view.someProp("handleDrop", function (f) {
    return f(view, event, slice || prosemirrorModel.Slice.empty, move);
  })) {
    event.preventDefault();
    return;
  }

  if (!slice) return;
  event.preventDefault();
  var insertPos = slice ? prosemirrorTransform.dropPoint(view.state.doc, $mouse.pos, slice) : $mouse.pos;
  if (insertPos == null) insertPos = $mouse.pos;
  var tr = view.state.tr;
  if (move) tr.deleteSelection();
  var pos = tr.mapping.map(insertPos);
  var isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;
  var beforeInsert = tr.doc;
  if (isNode) tr.replaceRangeWith(pos, pos, slice.content.firstChild);else tr.replaceRange(pos, pos, slice);
  if (tr.doc.eq(beforeInsert)) return;
  var $pos = tr.doc.resolve(pos);

  if (isNode && prosemirrorState.NodeSelection.isSelectable(slice.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {
    tr.setSelection(new prosemirrorState.NodeSelection($pos));
  } else {
    var end = tr.mapping.map(insertPos);
    tr.mapping.maps[tr.mapping.maps.length - 1].forEach(function (_from, _to, _newFrom, newTo) {
      return end = newTo;
    });
    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));
  }

  view.focus();
  view.dispatch(tr.setMeta("uiEvent", "drop"));
};

handlers.focus = function (view) {
  view.input.lastFocus = Date.now();

  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(function () {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange())) selectionToDOM(view);
    }, 20);
  }
};

handlers.blur = function (view, _event) {
  var event = _event;

  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget)) view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};

handlers.beforeinput = function (view, _event) {
  var event = _event;

  if (chrome && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    var domChangeCount = view.input.domChangeCount;
    setTimeout(function () {
      if (view.input.domChangeCount != domChangeCount) return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", function (f) {
        return f(view, keyEvent(8, "Backspace"));
      })) return;
      var $cursor = view.state.selection.$cursor;
      if ($cursor && $cursor.pos > 0) view.dispatch(view.state.tr["delete"]($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};

for (var prop in editHandlers) {
  handlers[prop] = editHandlers[prop];
}

function compareObjs(a, b) {
  if (a == b) return true;

  for (var p in a) {
    if (a[p] !== b[p]) return false;
  }

  for (var _p in b) {
    if (!(_p in a)) return false;
  }

  return true;
}

var WidgetType = function () {
  function WidgetType(toDOM, spec) {
    _classCallCheck(this, WidgetType);

    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }

  _createClass(WidgetType, [{
    key: "map",
    value: function map(mapping, span, offset, oldOffset) {
      var _mapping$mapResult = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1),
          pos = _mapping$mapResult.pos,
          deleted = _mapping$mapResult.deleted;

      return deleted ? null : new Decoration(pos - offset, pos - offset, this);
    }
  }, {
    key: "valid",
    value: function valid() {
      return true;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
    }
  }, {
    key: "destroy",
    value: function destroy(node) {
      if (this.spec.destroy) this.spec.destroy(node);
    }
  }]);

  return WidgetType;
}();

var InlineType = function () {
  function InlineType(attrs, spec) {
    _classCallCheck(this, InlineType);

    this.attrs = attrs;
    this.spec = spec || noSpec;
  }

  _createClass(InlineType, [{
    key: "map",
    value: function map(mapping, span, offset, oldOffset) {
      var from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;
      var to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;
      return from >= to ? null : new Decoration(from, to, this);
    }
  }, {
    key: "valid",
    value: function valid(_, span) {
      return span.from < span.to;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    }
  }, {
    key: "destroy",
    value: function destroy() {}
  }], [{
    key: "is",
    value: function is(span) {
      return span.type instanceof InlineType;
    }
  }]);

  return InlineType;
}();

var NodeType = function () {
  function NodeType(attrs, spec) {
    _classCallCheck(this, NodeType);

    this.attrs = attrs;
    this.spec = spec || noSpec;
  }

  _createClass(NodeType, [{
    key: "map",
    value: function map(mapping, span, offset, oldOffset) {
      var from = mapping.mapResult(span.from + oldOffset, 1);
      if (from.deleted) return null;
      var to = mapping.mapResult(span.to + oldOffset, -1);
      if (to.deleted || to.pos <= from.pos) return null;
      return new Decoration(from.pos - offset, to.pos - offset, this);
    }
  }, {
    key: "valid",
    value: function valid(node, span) {
      var _node$content$findInd = node.content.findIndex(span.from),
          index = _node$content$findInd.index,
          offset = _node$content$findInd.offset,
          child;

      return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      return this == other || other instanceof NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
    }
  }, {
    key: "destroy",
    value: function destroy() {}
  }]);

  return NodeType;
}();

var Decoration = function () {
  function Decoration(from, to, type) {
    _classCallCheck(this, Decoration);

    this.from = from;
    this.to = to;
    this.type = type;
  }

  _createClass(Decoration, [{
    key: "copy",
    value: function copy(from, to) {
      return new Decoration(from, to, this.type);
    }
  }, {
    key: "eq",
    value: function eq(other) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;
    }
  }, {
    key: "map",
    value: function map(mapping, offset, oldOffset) {
      return this.type.map(mapping, this, offset, oldOffset);
    }
  }, {
    key: "spec",
    get: function get() {
      return this.type.spec;
    }
  }, {
    key: "inline",
    get: function get() {
      return this.type instanceof InlineType;
    }
  }], [{
    key: "widget",
    value: function widget(pos, toDOM, spec) {
      return new Decoration(pos, pos, new WidgetType(toDOM, spec));
    }
  }, {
    key: "inline",
    value: function inline(from, to, attrs, spec) {
      return new Decoration(from, to, new InlineType(attrs, spec));
    }
  }, {
    key: "node",
    value: function node(from, to, attrs, spec) {
      return new Decoration(from, to, new NodeType(attrs, spec));
    }
  }]);

  return Decoration;
}();

var none = [],
    noSpec = {};

var DecorationSet = function () {
  function DecorationSet(local, children) {
    _classCallCheck(this, DecorationSet);

    this.local = local.length ? local : none;
    this.children = children.length ? children : none;
  }

  _createClass(DecorationSet, [{
    key: "find",
    value: function find(start, end, predicate) {
      var result = [];
      this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);
      return result;
    }
  }, {
    key: "findInner",
    value: function findInner(start, end, result, offset, predicate) {
      for (var i = 0; i < this.local.length; i++) {
        var span = this.local[i];
        if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec))) result.push(span.copy(span.from + offset, span.to + offset));
      }

      for (var _i5 = 0; _i5 < this.children.length; _i5 += 3) {
        if (this.children[_i5] < end && this.children[_i5 + 1] > start) {
          var childOff = this.children[_i5] + 1;

          this.children[_i5 + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);
        }
      }
    }
  }, {
    key: "map",
    value: function map(mapping, doc, options) {
      if (this == empty || mapping.maps.length == 0) return this;
      return this.mapInner(mapping, doc, 0, 0, options || noSpec);
    }
  }, {
    key: "mapInner",
    value: function mapInner(mapping, node, offset, oldOffset, options) {
      var newLocal;

      for (var i = 0; i < this.local.length; i++) {
        var mapped = this.local[i].map(mapping, offset, oldOffset);
        if (mapped && mapped.type.valid(node, mapped)) (newLocal || (newLocal = [])).push(mapped);else if (options.onRemove) options.onRemove(this.local[i].spec);
      }

      if (this.children.length) return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);else return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;
    }
  }, {
    key: "add",
    value: function add(doc, decorations) {
      if (!decorations.length) return this;
      if (this == empty) return DecorationSet.create(doc, decorations);
      return this.addInner(doc, decorations, 0);
    }
  }, {
    key: "addInner",
    value: function addInner(doc, decorations, offset) {
      var _this10 = this;

      var children,
          childIndex = 0;
      doc.forEach(function (childNode, childOffset) {
        var baseOffset = childOffset + offset,
            found;
        if (!(found = takeSpansForNode(decorations, childNode, baseOffset))) return;
        if (!children) children = _this10.children.slice();

        while (childIndex < children.length && children[childIndex] < childOffset) {
          childIndex += 3;
        }

        if (children[childIndex] == childOffset) children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);else children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));
        childIndex += 3;
      });
      var local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);

      for (var i = 0; i < local.length; i++) {
        if (!local[i].type.valid(doc, local[i])) local.splice(i--, 1);
      }

      return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
    }
  }, {
    key: "remove",
    value: function remove(decorations) {
      if (decorations.length == 0 || this == empty) return this;
      return this.removeInner(decorations, 0);
    }
  }, {
    key: "removeInner",
    value: function removeInner(decorations, offset) {
      var children = this.children,
          local = this.local;

      for (var i = 0; i < children.length; i += 3) {
        var found = void 0;
        var from = children[i] + offset,
            to = children[i + 1] + offset;

        for (var j = 0, span; j < decorations.length; j++) {
          if (span = decorations[j]) {
            if (span.from > from && span.to < to) {
              decorations[j] = null;
              (found || (found = [])).push(span);
            }
          }
        }

        if (!found) continue;
        if (children == this.children) children = this.children.slice();
        var removed = children[i + 2].removeInner(found, from + 1);

        if (removed != empty) {
          children[i + 2] = removed;
        } else {
          children.splice(i, 3);
          i -= 3;
        }
      }

      if (local.length) for (var _i6 = 0, _span; _i6 < decorations.length; _i6++) {
        if (_span = decorations[_i6]) {
          for (var _j2 = 0; _j2 < local.length; _j2++) {
            if (local[_j2].eq(_span, offset)) {
              if (local == this.local) local = this.local.slice();
              local.splice(_j2--, 1);
            }
          }
        }
      }
      if (children == this.children && local == this.local) return this;
      return local.length || children.length ? new DecorationSet(local, children) : empty;
    }
  }, {
    key: "forChild",
    value: function forChild(offset, node) {
      if (this == empty) return this;
      if (node.isLeaf) return DecorationSet.empty;
      var child, local;

      for (var i = 0; i < this.children.length; i += 3) {
        if (this.children[i] >= offset) {
          if (this.children[i] == offset) child = this.children[i + 2];
          break;
        }
      }

      var start = offset + 1,
          end = start + node.content.size;

      for (var _i7 = 0; _i7 < this.local.length; _i7++) {
        var dec = this.local[_i7];

        if (dec.from < end && dec.to > start && dec.type instanceof InlineType) {
          var from = Math.max(start, dec.from) - start,
              to = Math.min(end, dec.to) - start;
          if (from < to) (local || (local = [])).push(dec.copy(from, to));
        }
      }

      if (local) {
        var localSet = new DecorationSet(local.sort(byPos), none);
        return child ? new DecorationGroup([localSet, child]) : localSet;
      }

      return child || empty;
    }
  }, {
    key: "eq",
    value: function eq(other) {
      if (this == other) return true;
      if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length) return false;

      for (var i = 0; i < this.local.length; i++) {
        if (!this.local[i].eq(other.local[i])) return false;
      }

      for (var _i8 = 0; _i8 < this.children.length; _i8 += 3) {
        if (this.children[_i8] != other.children[_i8] || this.children[_i8 + 1] != other.children[_i8 + 1] || !this.children[_i8 + 2].eq(other.children[_i8 + 2])) return false;
      }

      return true;
    }
  }, {
    key: "locals",
    value: function locals(node) {
      return removeOverlap(this.localsInner(node));
    }
  }, {
    key: "localsInner",
    value: function localsInner(node) {
      if (this == empty) return none;
      if (node.inlineContent || !this.local.some(InlineType.is)) return this.local;
      var result = [];

      for (var i = 0; i < this.local.length; i++) {
        if (!(this.local[i].type instanceof InlineType)) result.push(this.local[i]);
      }

      return result;
    }
  }], [{
    key: "create",
    value: function create(doc, decorations) {
      return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty;
    }
  }]);

  return DecorationSet;
}();

DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
var empty = DecorationSet.empty;

var DecorationGroup = function () {
  function DecorationGroup(members) {
    _classCallCheck(this, DecorationGroup);

    this.members = members;
  }

  _createClass(DecorationGroup, [{
    key: "map",
    value: function map(mapping, doc) {
      var mappedDecos = this.members.map(function (member) {
        return member.map(mapping, doc, noSpec);
      });
      return DecorationGroup.from(mappedDecos);
    }
  }, {
    key: "forChild",
    value: function forChild(offset, child) {
      if (child.isLeaf) return DecorationSet.empty;
      var found = [];

      for (var i = 0; i < this.members.length; i++) {
        var result = this.members[i].forChild(offset, child);
        if (result == empty) continue;
        if (result instanceof DecorationGroup) found = found.concat(result.members);else found.push(result);
      }

      return DecorationGroup.from(found);
    }
  }, {
    key: "eq",
    value: function eq(other) {
      if (!(other instanceof DecorationGroup) || other.members.length != this.members.length) return false;

      for (var i = 0; i < this.members.length; i++) {
        if (!this.members[i].eq(other.members[i])) return false;
      }

      return true;
    }
  }, {
    key: "locals",
    value: function locals(node) {
      var result,
          sorted = true;

      for (var i = 0; i < this.members.length; i++) {
        var locals = this.members[i].localsInner(node);
        if (!locals.length) continue;

        if (!result) {
          result = locals;
        } else {
          if (sorted) {
            result = result.slice();
            sorted = false;
          }

          for (var j = 0; j < locals.length; j++) {
            result.push(locals[j]);
          }
        }
      }

      return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
    }
  }], [{
    key: "from",
    value: function from(members) {
      switch (members.length) {
        case 0:
          return empty;

        case 1:
          return members[0];

        default:
          return new DecorationGroup(members.every(function (m) {
            return m instanceof DecorationSet;
          }) ? members : members.reduce(function (r, m) {
            return r.concat(m instanceof DecorationSet ? m : m.members);
          }, []));
      }
    }
  }]);

  return DecorationGroup;
}();

function mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {
  var children = oldChildren.slice();

  var _loop4 = function _loop4(i, _baseOffset) {
    var moved = 0;
    mapping.maps[i].forEach(function (oldStart, oldEnd, newStart, newEnd) {
      var dSize = newEnd - newStart - (oldEnd - oldStart);

      for (var _i12 = 0; _i12 < children.length; _i12 += 3) {
        var end = children[_i12 + 1];
        if (end < 0 || oldStart > end + _baseOffset - moved) continue;
        var start = children[_i12] + _baseOffset - moved;

        if (oldEnd >= start) {
          children[_i12 + 1] = oldStart <= start ? -2 : -1;
        } else if (newStart >= offset && dSize) {
          children[_i12] += dSize;
          children[_i12 + 1] += dSize;
        }
      }

      moved += dSize;
    });
    _baseOffset = mapping.maps[i].map(_baseOffset, -1);
    baseOffset = _baseOffset;
  };

  for (var i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {
    _loop4(i, baseOffset);
  }

  var mustRebuild = false;

  for (var _i9 = 0; _i9 < children.length; _i9 += 3) {
    if (children[_i9 + 1] < 0) {
      if (children[_i9 + 1] == -2) {
        mustRebuild = true;
        children[_i9 + 1] = -1;
        continue;
      }

      var from = mapping.map(oldChildren[_i9] + oldOffset),
          fromLocal = from - offset;

      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }

      var to = mapping.map(oldChildren[_i9 + 1] + oldOffset, -1),
          toLocal = to - offset;

      var _node$content$findInd2 = node.content.findIndex(fromLocal),
          index = _node$content$findInd2.index,
          childOffset = _node$content$findInd2.offset;

      var childNode = node.maybeChild(index);

      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        var mapped = children[_i9 + 2].mapInner(mapping, childNode, from + 1, oldChildren[_i9] + oldOffset + 1, options);

        if (mapped != empty) {
          children[_i9] = fromLocal;
          children[_i9 + 1] = toLocal;
          children[_i9 + 2] = mapped;
        } else {
          children[_i9 + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  }

  if (mustRebuild) {
    var decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);
    var built = buildTree(decorations, node, 0, options);
    newLocal = built.local;

    for (var _i10 = 0; _i10 < children.length; _i10 += 3) {
      if (children[_i10 + 1] < 0) {
        children.splice(_i10, 3);
        _i10 -= 3;
      }
    }

    for (var _i11 = 0, j = 0; _i11 < built.children.length; _i11 += 3) {
      var _from2 = built.children[_i11];

      while (j < children.length && children[j] < _from2) {
        j += 3;
      }

      children.splice(j, 0, built.children[_i11], built.children[_i11 + 1], built.children[_i11 + 2]);
    }
  }

  return new DecorationSet(newLocal.sort(byPos), children);
}

function moveSpans(spans, offset) {
  if (!offset || !spans.length) return spans;
  var result = [];

  for (var i = 0; i < spans.length; i++) {
    var span = spans[i];
    result.push(new Decoration(span.from + offset, span.to + offset, span.type));
  }

  return result;
}

function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {
  function gather(set, oldOffset) {
    for (var i = 0; i < set.local.length; i++) {
      var mapped = set.local[i].map(mapping, offset, oldOffset);
      if (mapped) decorations.push(mapped);else if (options.onRemove) options.onRemove(set.local[i].spec);
    }

    for (var _i13 = 0; _i13 < set.children.length; _i13 += 3) {
      gather(set.children[_i13 + 2], set.children[_i13] + oldOffset + 1);
    }
  }

  for (var i = 0; i < children.length; i += 3) {
    if (children[i + 1] == -1) gather(children[i + 2], oldChildren[i] + oldOffset + 1);
  }

  return decorations;
}

function takeSpansForNode(spans, node, offset) {
  if (node.isLeaf) return null;
  var end = offset + node.nodeSize,
      found = null;

  for (var i = 0, span; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset && span.to < end) {
      (found || (found = [])).push(span);
      spans[i] = null;
    }
  }

  return found;
}

function withoutNulls(array) {
  var result = [];

  for (var i = 0; i < array.length; i++) {
    if (array[i] != null) result.push(array[i]);
  }

  return result;
}

function buildTree(spans, node, offset, options) {
  var children = [],
      hasNulls = false;
  node.forEach(function (childNode, localStart) {
    var found = takeSpansForNode(spans, childNode, localStart + offset);

    if (found) {
      hasNulls = true;
      var subtree = buildTree(found, childNode, offset + localStart + 1, options);
      if (subtree != empty) children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  var locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);

  for (var i = 0; i < locals.length; i++) {
    if (!locals[i].type.valid(node, locals[i])) {
      if (options.onRemove) options.onRemove(locals[i].spec);
      locals.splice(i--, 1);
    }
  }

  return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}

function byPos(a, b) {
  return a.from - b.from || a.to - b.to;
}

function removeOverlap(spans) {
  var working = spans;

  for (var i = 0; i < working.length - 1; i++) {
    var span = working[i];
    if (span.from != span.to) for (var j = i + 1; j < working.length; j++) {
      var next = working[j];

      if (next.from == span.from) {
        if (next.to != span.to) {
          if (working == spans) working = spans.slice();
          working[j] = next.copy(next.from, span.to);
          insertAhead(working, j + 1, next.copy(span.to, next.to));
        }

        continue;
      } else {
        if (next.from < span.to) {
          if (working == spans) working = spans.slice();
          working[i] = span.copy(span.from, next.from);
          insertAhead(working, j, span.copy(next.from, span.to));
        }

        break;
      }
    }
  }

  return working;
}

function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0) {
    i++;
  }

  array.splice(i, 0, deco);
}

function viewDecorations(view) {
  var found = [];
  view.someProp("decorations", function (f) {
    var result = f(view.state);
    if (result && result != empty) found.push(result);
  });
  if (view.cursorWrapper) found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found);
}

var observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
var useCharData = ie && ie_version <= 11;

var SelectionState = function () {
  function SelectionState() {
    _classCallCheck(this, SelectionState);

    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }

  _createClass(SelectionState, [{
    key: "set",
    value: function set(sel) {
      this.anchorNode = sel.anchorNode;
      this.anchorOffset = sel.anchorOffset;
      this.focusNode = sel.focusNode;
      this.focusOffset = sel.focusOffset;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.anchorNode = this.focusNode = null;
    }
  }, {
    key: "eq",
    value: function eq(sel) {
      return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
    }
  }]);

  return SelectionState;
}();

var DOMObserver = function () {
  function DOMObserver(view, handleDOMChange) {
    var _this11 = this;

    _classCallCheck(this, DOMObserver);

    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.observer = window.MutationObserver && new window.MutationObserver(function (mutations) {
      for (var i = 0; i < mutations.length; i++) {
        _this11.queue.push(mutations[i]);
      }

      if (ie && ie_version <= 11 && mutations.some(function (m) {
        return m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length;
      })) _this11.flushSoon();else _this11.flush();
    });

    if (useCharData) {
      this.onCharData = function (e) {
        _this11.queue.push({
          target: e.target,
          type: "characterData",
          oldValue: e.prevValue
        });

        _this11.flushSoon();
      };
    }

    this.onSelectionChange = this.onSelectionChange.bind(this);
  }

  _createClass(DOMObserver, [{
    key: "flushSoon",
    value: function flushSoon() {
      var _this12 = this;

      if (this.flushingSoon < 0) this.flushingSoon = window.setTimeout(function () {
        _this12.flushingSoon = -1;

        _this12.flush();
      }, 20);
    }
  }, {
    key: "forceFlush",
    value: function forceFlush() {
      if (this.flushingSoon > -1) {
        window.clearTimeout(this.flushingSoon);
        this.flushingSoon = -1;
        this.flush();
      }
    }
  }, {
    key: "start",
    value: function start() {
      if (this.observer) {
        this.observer.takeRecords();
        this.observer.observe(this.view.dom, observeOptions);
      }

      if (this.onCharData) this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
      this.connectSelection();
    }
  }, {
    key: "stop",
    value: function stop() {
      var _this13 = this;

      if (this.observer) {
        var take = this.observer.takeRecords();

        if (take.length) {
          for (var i = 0; i < take.length; i++) {
            this.queue.push(take[i]);
          }

          window.setTimeout(function () {
            return _this13.flush();
          }, 20);
        }

        this.observer.disconnect();
      }

      if (this.onCharData) this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
      this.disconnectSelection();
    }
  }, {
    key: "connectSelection",
    value: function connectSelection() {
      this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
    }
  }, {
    key: "disconnectSelection",
    value: function disconnectSelection() {
      this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
    }
  }, {
    key: "suppressSelectionUpdates",
    value: function suppressSelectionUpdates() {
      var _this14 = this;

      this.suppressingSelectionUpdates = true;
      setTimeout(function () {
        return _this14.suppressingSelectionUpdates = false;
      }, 50);
    }
  }, {
    key: "onSelectionChange",
    value: function onSelectionChange() {
      if (!hasFocusAndSelection(this.view)) return;
      if (this.suppressingSelectionUpdates) return selectionToDOM(this.view);

      if (ie && ie_version <= 11 && !this.view.state.selection.empty) {
        var sel = this.view.domSelectionRange();
        if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset)) return this.flushSoon();
      }

      this.flush();
    }
  }, {
    key: "setCurSelection",
    value: function setCurSelection() {
      this.currentSelection.set(this.view.domSelectionRange());
    }
  }, {
    key: "ignoreSelectionChange",
    value: function ignoreSelectionChange(sel) {
      if (!sel.focusNode) return true;
      var ancestors = new Set(),
          container;

      for (var scan = sel.focusNode; scan; scan = parentNode(scan)) {
        ancestors.add(scan);
      }

      for (var _scan = sel.anchorNode; _scan; _scan = parentNode(_scan)) {
        if (ancestors.has(_scan)) {
          container = _scan;
          break;
        }
      }

      var desc = container && this.view.docView.nearestDesc(container);

      if (desc && desc.ignoreMutation({
        type: "selection",
        target: container.nodeType == 3 ? container.parentNode : container
      })) {
        this.setCurSelection();
        return true;
      }
    }
  }, {
    key: "flush",
    value: function flush() {
      var view = this.view;
      if (!view.docView || this.flushingSoon > -1) return;
      var mutations = this.observer ? this.observer.takeRecords() : [];

      if (this.queue.length) {
        mutations = this.queue.concat(mutations);
        this.queue.length = 0;
      }

      var sel = view.domSelectionRange();
      var newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
      var from = -1,
          to = -1,
          typeOver = false,
          added = [];

      if (view.editable) {
        for (var i = 0; i < mutations.length; i++) {
          var result = this.registerMutation(mutations[i], added);

          if (result) {
            from = from < 0 ? result.from : Math.min(result.from, from);
            to = to < 0 ? result.to : Math.max(result.to, to);
            if (result.typeOver) typeOver = true;
          }
        }
      }

      if (gecko && added.length > 1) {
        var brs = added.filter(function (n) {
          return n.nodeName == "BR";
        });

        if (brs.length == 2) {
          var a = brs[0],
              b = brs[1];
          if (a.parentNode && a.parentNode.parentNode == b.parentNode) b.remove();else a.remove();
        }
      }

      var readSel = null;

      if (from < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(prosemirrorState.Selection.near(view.state.doc.resolve(0), 1))) {
        view.input.lastFocus = 0;
        selectionToDOM(view);
        this.currentSelection.set(sel);
        view.scrollToSelection();
      } else if (from > -1 || newSel) {
        if (from > -1) {
          view.docView.markDirty(from, to);
          checkCSS(view);
        }

        this.handleDOMChange(from, to, typeOver, added);
        if (view.docView && view.docView.dirty) view.updateState(view.state);else if (!this.currentSelection.eq(sel)) selectionToDOM(view);
        this.currentSelection.set(sel);
      }
    }
  }, {
    key: "registerMutation",
    value: function registerMutation(mut, added) {
      if (added.indexOf(mut.target) > -1) return null;
      var desc = this.view.docView.nearestDesc(mut.target);
      if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style"))) return null;
      if (!desc || desc.ignoreMutation(mut)) return null;

      if (mut.type == "childList") {
        for (var i = 0; i < mut.addedNodes.length; i++) {
          added.push(mut.addedNodes[i]);
        }

        if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target)) return {
          from: desc.posBefore,
          to: desc.posAfter
        };
        var prev = mut.previousSibling,
            next = mut.nextSibling;

        if (ie && ie_version <= 11 && mut.addedNodes.length) {
          for (var _i14 = 0; _i14 < mut.addedNodes.length; _i14++) {
            var _mut$addedNodes$_i = mut.addedNodes[_i14],
                previousSibling = _mut$addedNodes$_i.previousSibling,
                nextSibling = _mut$addedNodes$_i.nextSibling;
            if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0) prev = previousSibling;
            if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0) next = nextSibling;
          }
        }

        var fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
        var from = desc.localPosFromDOM(mut.target, fromOffset, -1);
        var toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
        var to = desc.localPosFromDOM(mut.target, toOffset, 1);
        return {
          from: from,
          to: to
        };
      } else if (mut.type == "attributes") {
        return {
          from: desc.posAtStart - desc.border,
          to: desc.posAtEnd + desc.border
        };
      } else {
        return {
          from: desc.posAtStart,
          to: desc.posAtEnd,
          typeOver: mut.target.nodeValue == mut.oldValue
        };
      }
    }
  }]);

  return DOMObserver;
}();

var cssChecked = new WeakMap();
var cssCheckWarned = false;

function checkCSS(view) {
  if (cssChecked.has(view)) return;
  cssChecked.set(view, null);

  if (['normal', 'nowrap', 'pre-line'].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
    view.requiresGeckoHackNode = gecko;
    if (cssCheckWarned) return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}

function safariShadowSelectionRange(view) {
  var found;

  function read(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found = event.getTargetRanges()[0];
  }

  view.dom.addEventListener("beforeinput", read, true);
  document.execCommand("indent");
  view.dom.removeEventListener("beforeinput", read, true);
  var anchorNode = found.startContainer,
      anchorOffset = found.startOffset;
  var focusNode = found.endContainer,
      focusOffset = found.endOffset;
  var currentAnchor = view.domAtPos(view.state.selection.anchor);

  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset)) {
    var _ref3 = [focusNode, focusOffset, anchorNode, anchorOffset];
    anchorNode = _ref3[0];
    anchorOffset = _ref3[1];
    focusNode = _ref3[2];
    focusOffset = _ref3[3];
  }

  return {
    anchorNode: anchorNode,
    anchorOffset: anchorOffset,
    focusNode: focusNode,
    focusOffset: focusOffset
  };
}

function parseBetween(view, from_, to_) {
  var _view$docView$parseRa = view.docView.parseRange(from_, to_),
      parent = _view$docView$parseRa.node,
      fromOffset = _view$docView$parseRa.fromOffset,
      toOffset = _view$docView$parseRa.toOffset,
      from = _view$docView$parseRa.from,
      to = _view$docView$parseRa.to;

  var domSel = view.domSelectionRange();
  var find;
  var anchor = domSel.anchorNode;

  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find = [{
      node: anchor,
      offset: domSel.anchorOffset
    }];
    if (!selectionCollapsed(domSel)) find.push({
      node: domSel.focusNode,
      offset: domSel.focusOffset
    });
  }

  if (chrome && view.input.lastKeyCode === 8) {
    for (var off = toOffset; off > fromOffset; off--) {
      var node = parent.childNodes[off - 1],
          desc = node.pmViewDesc;

      if (node.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }

      if (!desc || desc.size) break;
    }
  }

  var startDoc = view.state.doc;
  var parser = view.someProp("domParser") || prosemirrorModel.DOMParser.fromSchema(view.state.schema);
  var $from = startDoc.resolve(from);
  var sel = null,
      doc = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find,
    ruleFromNode: ruleFromNode,
    context: $from
  });

  if (find && find[0].pos != null) {
    var _anchor = find[0].pos,
        head = find[1] && find[1].pos;
    if (head == null) head = _anchor;
    sel = {
      anchor: _anchor + from,
      head: head + from
    };
  }

  return {
    doc: doc,
    sel: sel,
    from: from,
    to: to
  };
}

function ruleFromNode(dom) {
  var desc = dom.pmViewDesc;

  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      var skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return {
        skip: skip
      };
    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return {
        ignore: true
      };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return {
      ignore: true
    };
  }

  return null;
}

var isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;

function readDOMChange(view, from, to, typeOver, addedNodes) {
  if (from < 0) {
    var origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    var newSel = selectionFromDOM(view, origin);

    if (newSel && !view.state.selection.eq(newSel)) {
      if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", function (f) {
        return f(view, keyEvent(13, "Enter"));
      })) return;

      var _tr = view.state.tr.setSelection(newSel);

      if (origin == "pointer") _tr.setMeta("pointer", true);else if (origin == "key") _tr.scrollIntoView();
      if (view.composing) _tr.setMeta("composition", view.input.compositionID);
      view.dispatch(_tr);
    }

    return;
  }

  var $before = view.state.doc.resolve(from);
  var shared = $before.sharedDepth(to);
  from = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  var sel = view.state.selection;
  var parse = parseBetween(view, from, to);
  var doc = view.state.doc,
      compare = doc.slice(parse.from, parse.to);
  var preferredPos, preferredSide;

  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }

  view.input.lastKeyCode = null;
  var change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);

  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some(function (n) {
    return n.nodeType == 1 && !isInline.test(n.nodeName);
  }) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", function (f) {
    return f(view, keyEvent(13, "Enter"));
  })) {
    view.input.lastIOSEnter = 0;
    return;
  }

  if (!change) {
    if (typeOver && sel instanceof prosemirrorState.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
      change = {
        start: sel.from,
        endA: sel.to,
        endB: sel.to
      };
    } else {
      if (parse.sel) {
        var _sel = resolveSelection(view, view.state.doc, parse.sel);

        if (_sel && !_sel.eq(view.state.selection)) {
          var _tr2 = view.state.tr.setSelection(_sel);

          if (view.composing) _tr2.setMeta("composition", view.input.compositionID);
          view.dispatch(_tr2);
        }
      }

      return;
    }
  }

  if (chrome && view.cursorWrapper && parse.sel && parse.sel.anchor == view.cursorWrapper.deco.from && parse.sel.head == parse.sel.anchor) {
    var size = change.endB - change.start;
    parse.sel = {
      anchor: parse.sel.anchor + size,
      head: parse.sel.anchor + size
    };
  }

  view.input.domChangeCount++;

  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof prosemirrorState.TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }

  if (ie && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " \xA0") {
    change.start--;
    change.endA--;
    change.endB--;
  }

  var $from = parse.doc.resolveNoCache(change.start - parse.from);
  var $to = parse.doc.resolveNoCache(change.endB - parse.from);
  var $fromA = doc.resolve(change.start);
  var inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  var nextSel;

  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some(function (n) {
    return n.nodeName == "DIV" || n.nodeName == "P";
  })) || !inlineChange && $from.pos < parse.doc.content.size && (nextSel = prosemirrorState.Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head == $to.pos) && view.someProp("handleKeyDown", function (f) {
    return f(view, keyEvent(13, "Enter"));
  })) {
    view.input.lastIOSEnter = 0;
    return;
  }

  if (view.state.selection.anchor > change.start && looksLikeJoin(doc, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", function (f) {
    return f(view, keyEvent(8, "Backspace"));
  })) {
    if (android && chrome) view.domObserver.suppressSelectionUpdates();
    return;
  }

  if (chrome && android && change.endB == change.start) view.input.lastAndroidDelete = Date.now();

  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse.doc.resolveNoCache(change.endB - parse.from);
    setTimeout(function () {
      view.someProp("handleKeyDown", function (f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }

  var chFrom = change.start,
      chTo = change.endA;
  var tr, storedMarks, markChange;

  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(function () {
          return selectionToDOM(view);
        }, 20);
      }

      tr = view.state.tr["delete"](chFrom, chTo);
      storedMarks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));
    } else if (change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {
      tr = view.state.tr;
      if (markChange.type == "add") tr.addMark(chFrom, chTo, markChange.mark);else tr.removeMark(chFrom, chTo, markChange.mark);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      var text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      if (view.someProp("handleTextInput", function (f) {
        return f(view, chFrom, chTo, text);
      })) return;
      tr = view.state.tr.insertText(text, chFrom, chTo);
    }
  }

  if (!tr) tr = view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));

  if (parse.sel) {
    var _sel2 = resolveSelection(view, tr.doc, parse.sel);

    if (_sel2 && !(chrome && android && view.composing && _sel2.empty && (change.start != change.endB || view.input.lastAndroidDelete < Date.now() - 100) && (_sel2.head == chFrom || _sel2.head == tr.mapping.map(chTo) - 1) || ie && _sel2.empty && _sel2.head == chFrom)) tr.setSelection(_sel2);
  }

  if (storedMarks) tr.ensureMarks(storedMarks);
  if (view.composing) tr.setMeta("composition", view.input.compositionID);
  view.dispatch(tr.scrollIntoView());
}

function resolveSelection(view, doc, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size) return null;
  return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head));
}

function isMarkChange(cur, prev) {
  var curMarks = cur.firstChild.marks,
      prevMarks = prev.firstChild.marks;
  var added = curMarks,
      removed = prevMarks,
      type,
      mark,
      update;

  for (var i = 0; i < prevMarks.length; i++) {
    added = prevMarks[i].removeFromSet(added);
  }

  for (var _i15 = 0; _i15 < curMarks.length; _i15++) {
    removed = curMarks[_i15].removeFromSet(removed);
  }

  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";

    update = function update(node) {
      return node.mark(mark.addToSet(node.marks));
    };
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";

    update = function update(node) {
      return node.mark(mark.removeFromSet(node.marks));
    };
  } else {
    return null;
  }

  var updated = [];

  for (var _i16 = 0; _i16 < prev.childCount; _i16++) {
    updated.push(update(prev.child(_i16)));
  }

  if (prosemirrorModel.Fragment.from(updated).eq(cur)) return {
    mark: mark,
    type: type
  };
}

function looksLikeJoin(old, start, end, $newStart, $newEnd) {
  if (!$newStart.parent.isTextblock || end - start <= $newEnd.pos - $newStart.pos || skipClosingAndOpening($newStart, true, false) < $newEnd.pos) return false;
  var $start = old.resolve(start);
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock) return false;
  var $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end || skipClosingAndOpening($next, true, false) < end) return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}

function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  var depth = $pos.depth,
      end = fromEnd ? $pos.end() : $pos.pos;

  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end++;
    fromEnd = false;
  }

  if (mayOpen) {
    var next = $pos.node(depth).maybeChild($pos.indexAfter(depth));

    while (next && !next.isLeaf) {
      next = next.firstChild;
      end++;
    }
  }

  return end;
}

function findDiff(a, b, pos, preferredPos, preferredSide) {
  var start = a.findDiffStart(b, pos);
  if (start == null) return null;

  var _a$findDiffEnd = a.findDiffEnd(b, pos + a.size, pos + b.size),
      endA = _a$findDiffEnd.a,
      endB = _a$findDiffEnd.b;

  if (preferredSide == "end") {
    var adjust = Math.max(0, start - Math.min(endA, endB));
    preferredPos -= endA + adjust - start;
  }

  if (endA < start && a.size < b.size) {
    var move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;
    start -= move;
    endB = start + (endB - endA);
    endA = start;
  } else if (endB < start) {
    var _move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;

    start -= _move;
    endA = start + (endA - endB);
    endB = start;
  }

  return {
    start: start,
    endA: endA,
    endB: endB
  };
}

var __serializeForClipboard = serializeForClipboard;
var __parseFromClipboard = parseFromClipboard;
var __endComposition = endComposition;

var EditorView = function () {
  function EditorView(place, props) {
    var _this15 = this;

    _classCallCheck(this, EditorView);

    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = undefined;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.requiresGeckoHackNode = false;
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");

    if (place) {
      if (place.appendChild) place.appendChild(this.dom);else if (typeof place == "function") place(this.dom);else if (place.mount) this.mounted = true;
    }

    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, function (from, to, typeOver, added) {
      return readDOMChange(_this15, from, to, typeOver, added);
    });
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }

  _createClass(EditorView, [{
    key: "composing",
    get: function get() {
      return this.input.composing;
    }
  }, {
    key: "props",
    get: function get() {
      if (this._props.state != this.state) {
        var prev = this._props;
        this._props = {};

        for (var name in prev) {
          this._props[name] = prev[name];
        }

        this._props.state = this.state;
      }

      return this._props;
    }
  }, {
    key: "update",
    value: function update(props) {
      if (props.handleDOMEvents != this._props.handleDOMEvents) ensureListeners(this);
      var prevProps = this._props;
      this._props = props;

      if (props.plugins) {
        props.plugins.forEach(checkStateComponent);
        this.directPlugins = props.plugins;
      }

      this.updateStateInner(props.state, prevProps);
    }
  }, {
    key: "setProps",
    value: function setProps(props) {
      var updated = {};

      for (var name in this._props) {
        updated[name] = this._props[name];
      }

      updated.state = this.state;

      for (var _name2 in props) {
        updated[_name2] = props[_name2];
      }

      this.update(updated);
    }
  }, {
    key: "updateState",
    value: function updateState(state) {
      this.updateStateInner(state, this._props);
    }
  }, {
    key: "updateStateInner",
    value: function updateStateInner(state, prevProps) {
      var prev = this.state,
          redraw = false,
          updateSel = false;

      if (state.storedMarks && this.composing) {
        clearComposition(this);
        updateSel = true;
      }

      this.state = state;
      var pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;

      if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
        var nodeViews = buildNodeViews(this);

        if (changedNodeViews(nodeViews, this.nodeViews)) {
          this.nodeViews = nodeViews;
          redraw = true;
        }
      }

      if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
        ensureListeners(this);
      }

      this.editable = getEditable(this);
      updateCursorWrapper(this);
      var innerDeco = viewDecorations(this),
          outerDeco = computeDocDeco(this);
      var scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
      var updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
      if (updateDoc || !state.selection.eq(prev.selection)) updateSel = true;
      var oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);

      if (updateSel) {
        this.domObserver.stop();
        var forceSelUpdate = updateDoc && (ie || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);

        if (updateDoc) {
          var chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;

          if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
            this.docView.updateOuterDeco([]);
            this.docView.destroy();
            this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
          }

          if (chromeKludge && !this.trackWrites) forceSelUpdate = true;
        }

        if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
          selectionToDOM(this, forceSelUpdate);
        } else {
          syncNodeSelection(this, state.selection);
          this.domObserver.setCurSelection();
        }

        this.domObserver.start();
      }

      this.updatePluginViews(prev);

      if (scroll == "reset") {
        this.dom.scrollTop = 0;
      } else if (scroll == "to selection") {
        this.scrollToSelection();
      } else if (oldScrollPos) {
        resetScrollPos(oldScrollPos);
      }
    }
  }, {
    key: "scrollToSelection",
    value: function scrollToSelection() {
      var _this16 = this;

      var startDOM = this.domSelectionRange().focusNode;
      if (this.someProp("handleScrollToSelection", function (f) {
        return f(_this16);
      })) ;else if (this.state.selection instanceof prosemirrorState.NodeSelection) {
        var target = this.docView.domAfterPos(this.state.selection.from);
        if (target.nodeType == 1) scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
      } else {
        scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
      }
    }
  }, {
    key: "destroyPluginViews",
    value: function destroyPluginViews() {
      var view;

      while (view = this.pluginViews.pop()) {
        if (view.destroy) view.destroy();
      }
    }
  }, {
    key: "updatePluginViews",
    value: function updatePluginViews(prevState) {
      if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
        this.prevDirectPlugins = this.directPlugins;
        this.destroyPluginViews();

        for (var i = 0; i < this.directPlugins.length; i++) {
          var plugin = this.directPlugins[i];
          if (plugin.spec.view) this.pluginViews.push(plugin.spec.view(this));
        }

        for (var _i17 = 0; _i17 < this.state.plugins.length; _i17++) {
          var _plugin = this.state.plugins[_i17];
          if (_plugin.spec.view) this.pluginViews.push(_plugin.spec.view(this));
        }
      } else {
        for (var _i18 = 0; _i18 < this.pluginViews.length; _i18++) {
          var pluginView = this.pluginViews[_i18];
          if (pluginView.update) pluginView.update(this, prevState);
        }
      }
    }
  }, {
    key: "someProp",
    value: function someProp(propName, f) {
      var prop = this._props && this._props[propName],
          value;
      if (prop != null && (value = f ? f(prop) : prop)) return value;

      for (var i = 0; i < this.directPlugins.length; i++) {
        var _prop = this.directPlugins[i].props[propName];
        if (_prop != null && (value = f ? f(_prop) : _prop)) return value;
      }

      var plugins = this.state.plugins;
      if (plugins) for (var _i19 = 0; _i19 < plugins.length; _i19++) {
        var _prop2 = plugins[_i19].props[propName];
        if (_prop2 != null && (value = f ? f(_prop2) : _prop2)) return value;
      }
    }
  }, {
    key: "hasFocus",
    value: function hasFocus() {
      if (ie) {
        var node = this.root.activeElement;
        if (node == this.dom) return true;
        if (!node || !this.dom.contains(node)) return false;

        while (node && this.dom != node && this.dom.contains(node)) {
          if (node.contentEditable == 'false') return false;
          node = node.parentElement;
        }

        return true;
      }

      return this.root.activeElement == this.dom;
    }
  }, {
    key: "focus",
    value: function focus() {
      this.domObserver.stop();
      if (this.editable) focusPreventScroll(this.dom);
      selectionToDOM(this);
      this.domObserver.start();
    }
  }, {
    key: "root",
    get: function get() {
      var _this17 = this;

      var cached = this._root;

      if (cached == null) {
        var _loop5 = function _loop5(search) {
          if (search.nodeType == 9 || search.nodeType == 11 && search.host) {
            if (!search.getSelection) Object.getPrototypeOf(search).getSelection = function () {
              return search.ownerDocument.getSelection();
            };
            return {
              v: _this17._root = search
            };
          }
        };

        for (var search = this.dom.parentNode; search; search = search.parentNode) {
          var _ret3 = _loop5(search);

          if (_typeof(_ret3) === "object") return _ret3.v;
        }
      }

      return cached || document;
    }
  }, {
    key: "posAtCoords",
    value: function posAtCoords(coords) {
      return _posAtCoords(this, coords);
    }
  }, {
    key: "coordsAtPos",
    value: function coordsAtPos(pos) {
      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return _coordsAtPos(this, pos, side);
    }
  }, {
    key: "domAtPos",
    value: function domAtPos(pos) {
      var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      return this.docView.domFromPos(pos, side);
    }
  }, {
    key: "nodeDOM",
    value: function nodeDOM(pos) {
      var desc = this.docView.descAt(pos);
      return desc ? desc.nodeDOM : null;
    }
  }, {
    key: "posAtDOM",
    value: function posAtDOM(node, offset) {
      var bias = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      var pos = this.docView.posFromDOM(node, offset, bias);
      if (pos == null) throw new RangeError("DOM position not inside the editor");
      return pos;
    }
  }, {
    key: "endOfTextblock",
    value: function endOfTextblock(dir, state) {
      return _endOfTextblock(this, state || this.state, dir);
    }
  }, {
    key: "pasteHTML",
    value: function pasteHTML(html, event) {
      return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
    }
  }, {
    key: "pasteText",
    value: function pasteText(text, event) {
      return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
    }
  }, {
    key: "destroy",
    value: function destroy() {
      if (!this.docView) return;
      destroyInput(this);
      this.destroyPluginViews();

      if (this.mounted) {
        this.docView.update(this.state.doc, [], viewDecorations(this), this);
        this.dom.textContent = "";
      } else if (this.dom.parentNode) {
        this.dom.parentNode.removeChild(this.dom);
      }

      this.docView.destroy();
      this.docView = null;
    }
  }, {
    key: "isDestroyed",
    get: function get() {
      return this.docView == null;
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      return _dispatchEvent(this, event);
    }
  }, {
    key: "dispatch",
    value: function dispatch(tr) {
      var dispatchTransaction = this._props.dispatchTransaction;
      if (dispatchTransaction) dispatchTransaction.call(this, tr);else this.updateState(this.state.apply(tr));
    }
  }, {
    key: "domSelectionRange",
    value: function domSelectionRange() {
      return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom ? safariShadowSelectionRange(this) : this.domSelection();
    }
  }, {
    key: "domSelection",
    value: function domSelection() {
      return this.root.getSelection();
    }
  }]);

  return EditorView;
}();

function computeDocDeco(view) {
  var attrs = Object.create(null);
  attrs["class"] = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  view.someProp("attributes", function (value) {
    if (typeof value == "function") value = value(view.state);
    if (value) for (var attr in value) {
      if (attr == "class") attrs["class"] += " " + value[attr];else if (attr == "style") attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName") attrs[attr] = String(value[attr]);
    }
  });
  if (!attrs.translate) attrs.translate = "no";
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}

function updateCursorWrapper(view) {
  if (view.markCursor) {
    var dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = {
      dom: dom,
      deco: Decoration.widget(view.state.selection.head, dom, {
        raw: true,
        marks: view.markCursor
      })
    };
  } else {
    view.cursorWrapper = null;
  }
}

function getEditable(view) {
  return !view.someProp("editable", function (value) {
    return value(view.state) === false;
  });
}

function selectionContextChanged(sel1, sel2) {
  var depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}

function buildNodeViews(view) {
  var result = Object.create(null);

  function add(obj) {
    for (var _prop3 in obj) {
      if (!Object.prototype.hasOwnProperty.call(result, _prop3)) result[_prop3] = obj[_prop3];
    }
  }

  view.someProp("nodeViews", add);
  view.someProp("markViews", add);
  return result;
}

function changedNodeViews(a, b) {
  var nA = 0,
      nB = 0;

  for (var _prop4 in a) {
    if (a[_prop4] != b[_prop4]) return true;
    nA++;
  }

  for (var _ in b) {
    nB++;
  }

  return nA != nB;
}

function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction) throw new RangeError("Plugins passed directly to the view must not have a state component");
}

exports.Decoration = Decoration;
exports.DecorationSet = DecorationSet;
exports.EditorView = EditorView;
exports.__endComposition = __endComposition;
exports.__parseFromClipboard = __parseFromClipboard;
exports.__serializeForClipboard = __serializeForClipboard;


/***/ }),

/***/ "./node_modules/rope-sequence/dist/index.cjs":
/*!***************************************************!*\
  !*** ./node_modules/rope-sequence/dist/index.cjs ***!
  \***************************************************/
/***/ ((module) => {

"use strict";


var GOOD_LEAF_SIZE = 200;

// :: class<T> A rope sequence is a persistent sequence data structure
// that supports appending, prepending, and slicing without doing a
// full copy. It is represented as a mostly-balanced tree.
var RopeSequence = function RopeSequence () {};

RopeSequence.prototype.append = function append (other) {
  if (!other.length) { return this }
  other = RopeSequence.from(other);

  return (!this.length && other) ||
    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||
    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||
    this.appendInner(other)
};

// :: (union<[T], RopeSequence<T>>)  RopeSequence<T>
// Prepend an array or other rope to this one, returning a new rope.
RopeSequence.prototype.prepend = function prepend (other) {
  if (!other.length) { return this }
  return RopeSequence.from(other).append(this)
};

RopeSequence.prototype.appendInner = function appendInner (other) {
  return new Append(this, other)
};

// :: (?number, ?number)  RopeSequence<T>
// Create a rope repesenting a sub-sequence of this rope.
RopeSequence.prototype.slice = function slice (from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.length;

  if (from >= to) { return RopeSequence.empty }
  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))
};

// :: (number)  T
// Retrieve the element at the given position from this rope.
RopeSequence.prototype.get = function get (i) {
  if (i < 0 || i >= this.length) { return undefined }
  return this.getInner(i)
};

// :: ((element: T, index: number)  ?bool, ?number, ?number)
// Call the given function for each element between the given
// indices. This tends to be more efficient than looping over the
// indices and calling `get`, because it doesn't have to descend the
// tree for every element.
RopeSequence.prototype.forEach = function forEach (f, from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.length;

  if (from <= to)
    { this.forEachInner(f, from, to, 0); }
  else
    { this.forEachInvertedInner(f, from, to, 0); }
};

// :: ((element: T, index: number)  U, ?number, ?number)  [U]
// Map the given functions over the elements of the rope, producing
// a flat array.
RopeSequence.prototype.map = function map (f, from, to) {
    if ( from === void 0 ) from = 0;
    if ( to === void 0 ) to = this.length;

  var result = [];
  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);
  return result
};

// :: (?union<[T], RopeSequence<T>>)  RopeSequence<T>
// Create a rope representing the given array, or return the rope
// itself if a rope was given.
RopeSequence.from = function from (values) {
  if (values instanceof RopeSequence) { return values }
  return values && values.length ? new Leaf(values) : RopeSequence.empty
};

var Leaf = /*@__PURE__*/(function (RopeSequence) {
  function Leaf(values) {
    RopeSequence.call(this);
    this.values = values;
  }

  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;
  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );
  Leaf.prototype.constructor = Leaf;

  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };

  Leaf.prototype.flatten = function flatten () {
    return this.values
  };

  Leaf.prototype.sliceInner = function sliceInner (from, to) {
    if (from == 0 && to == this.length) { return this }
    return new Leaf(this.values.slice(from, to))
  };

  Leaf.prototype.getInner = function getInner (i) {
    return this.values[i]
  };

  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {
    for (var i = from; i < to; i++)
      { if (f(this.values[i], start + i) === false) { return false } }
  };

  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {
    for (var i = from - 1; i >= to; i--)
      { if (f(this.values[i], start + i) === false) { return false } }
  };

  Leaf.prototype.leafAppend = function leafAppend (other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE)
      { return new Leaf(this.values.concat(other.flatten())) }
  };

  Leaf.prototype.leafPrepend = function leafPrepend (other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE)
      { return new Leaf(other.flatten().concat(this.values)) }
  };

  prototypeAccessors.length.get = function () { return this.values.length };

  prototypeAccessors.depth.get = function () { return 0 };

  Object.defineProperties( Leaf.prototype, prototypeAccessors );

  return Leaf;
}(RopeSequence));

// :: RopeSequence
// The empty rope sequence.
RopeSequence.empty = new Leaf([]);

var Append = /*@__PURE__*/(function (RopeSequence) {
  function Append(left, right) {
    RopeSequence.call(this);
    this.left = left;
    this.right = right;
    this.length = left.length + right.length;
    this.depth = Math.max(left.depth, right.depth) + 1;
  }

  if ( RopeSequence ) Append.__proto__ = RopeSequence;
  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );
  Append.prototype.constructor = Append;

  Append.prototype.flatten = function flatten () {
    return this.left.flatten().concat(this.right.flatten())
  };

  Append.prototype.getInner = function getInner (i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)
  };

  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {
    var leftLen = this.left.length;
    if (from < leftLen &&
        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)
      { return false }
    if (to > leftLen &&
        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)
      { return false }
  };

  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {
    var leftLen = this.left.length;
    if (from > leftLen &&
        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)
      { return false }
    if (to < leftLen &&
        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)
      { return false }
  };

  Append.prototype.sliceInner = function sliceInner (from, to) {
    if (from == 0 && to == this.length) { return this }
    var leftLen = this.left.length;
    if (to <= leftLen) { return this.left.slice(from, to) }
    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }
    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))
  };

  Append.prototype.leafAppend = function leafAppend (other) {
    var inner = this.right.leafAppend(other);
    if (inner) { return new Append(this.left, inner) }
  };

  Append.prototype.leafPrepend = function leafPrepend (other) {
    var inner = this.left.leafPrepend(other);
    if (inner) { return new Append(inner, this.right) }
  };

  Append.prototype.appendInner = function appendInner (other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)
      { return new Append(this.left, new Append(this.right, other)) }
    return new Append(this, other)
  };

  return Append;
}(RopeSequence));

module.exports = RopeSequence;


/***/ }),

/***/ "./node_modules/w3c-keyname/index.cjs":
/*!********************************************!*\
  !*** ./node_modules/w3c-keyname/index.cjs ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};

var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: "\""
};

var mac = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);

// Fill in the digit keys
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);

// The function keys
for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;

// And the alphabetic keys
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}

// For each code that doesn't have a shift-equivalent, copy the base name
for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];

function keyName(event) {
  // On macOS, keys held with Shift and Cmd don't reflect the effect of Shift in `.key`.
  // On IE, shift effect is never included in `.key`.
  var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey ||
      ie && event.shiftKey && event.key && event.key.length == 1 ||
      event.key == "Unidentified";
  var name = (!ignoreKey && event.key) ||
    (event.shiftKey ? shift : base)[event.keyCode] ||
    event.key || "Unidentified";
  // Edge sometimes produces wrong names (Issue #3)
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name
}

exports.base = base;
exports.keyName = keyName;
exports.shift = shift;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/entry": 0,
/******/ 			"css/entry": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunklyhty_nova_tui_editor"] = self["webpackChunklyhty_nova_tui_editor"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/entry"], () => (__webpack_require__("./resources/js/entry.ts")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/entry"], () => (__webpack_require__("./resources/css/entry.pcss")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;