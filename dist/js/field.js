/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@vue/devtools-api/lib/esm/const.js":
/*!*********************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/const.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HOOK_PLUGIN_SETTINGS_SET: () => (/* binding */ HOOK_PLUGIN_SETTINGS_SET),
/* harmony export */   HOOK_SETUP: () => (/* binding */ HOOK_SETUP)
/* harmony export */ });
const HOOK_SETUP = 'devtools-plugin:setup';
const HOOK_PLUGIN_SETTINGS_SET = 'plugin:settings:set';


/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/env.js":
/*!*******************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/env.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getDevtoolsGlobalHook: () => (/* binding */ getDevtoolsGlobalHook),
/* harmony export */   getTarget: () => (/* binding */ getTarget),
/* harmony export */   isProxyAvailable: () => (/* binding */ isProxyAvailable)
/* harmony export */ });
function getDevtoolsGlobalHook() {
    return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
    // @ts-expect-error navigator and windows are not available in all environments
    return (typeof navigator !== 'undefined' && typeof window !== 'undefined')
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : {};
}
const isProxyAvailable = typeof Proxy === 'function';


/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isPerformanceSupported: () => (/* reexport safe */ _time_js__WEBPACK_IMPORTED_MODULE_0__.isPerformanceSupported),
/* harmony export */   now: () => (/* reexport safe */ _time_js__WEBPACK_IMPORTED_MODULE_0__.now),
/* harmony export */   setupDevtoolsPlugin: () => (/* binding */ setupDevtoolsPlugin)
/* harmony export */ });
/* harmony import */ var _env_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./env.js */ "./node_modules/@vue/devtools-api/lib/esm/env.js");
/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./const.js */ "./node_modules/@vue/devtools-api/lib/esm/const.js");
/* harmony import */ var _proxy_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./proxy.js */ "./node_modules/@vue/devtools-api/lib/esm/proxy.js");
/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time.js */ "./node_modules/@vue/devtools-api/lib/esm/time.js");






function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
    const descriptor = pluginDescriptor;
    const target = (0,_env_js__WEBPACK_IMPORTED_MODULE_1__.getTarget)();
    const hook = (0,_env_js__WEBPACK_IMPORTED_MODULE_1__.getDevtoolsGlobalHook)();
    const enableProxy = _env_js__WEBPACK_IMPORTED_MODULE_1__.isProxyAvailable && descriptor.enableEarlyProxy;
    if (hook && (target.__VUE_DEVTOOLS_PLUGIN_API_AVAILABLE__ || !enableProxy)) {
        hook.emit(_const_js__WEBPACK_IMPORTED_MODULE_2__.HOOK_SETUP, pluginDescriptor, setupFn);
    }
    else {
        const proxy = enableProxy ? new _proxy_js__WEBPACK_IMPORTED_MODULE_3__.ApiProxy(descriptor, hook) : null;
        const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
        list.push({
            pluginDescriptor: descriptor,
            setupFn,
            proxy,
        });
        if (proxy) {
            setupFn(proxy.proxiedTarget);
        }
    }
}


/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/proxy.js":
/*!*********************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/proxy.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ApiProxy: () => (/* binding */ ApiProxy)
/* harmony export */ });
/* harmony import */ var _const_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./const.js */ "./node_modules/@vue/devtools-api/lib/esm/const.js");
/* harmony import */ var _time_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time.js */ "./node_modules/@vue/devtools-api/lib/esm/time.js");


class ApiProxy {
    constructor(plugin, hook) {
        this.target = null;
        this.targetQueue = [];
        this.onQueue = [];
        this.plugin = plugin;
        this.hook = hook;
        const defaultSettings = {};
        if (plugin.settings) {
            for (const id in plugin.settings) {
                const item = plugin.settings[id];
                defaultSettings[id] = item.defaultValue;
            }
        }
        const localSettingsSaveId = `__vue-devtools-plugin-settings__${plugin.id}`;
        let currentSettings = Object.assign({}, defaultSettings);
        try {
            const raw = localStorage.getItem(localSettingsSaveId);
            const data = JSON.parse(raw);
            Object.assign(currentSettings, data);
        }
        catch (e) {
            // noop
        }
        this.fallbacks = {
            getSettings() {
                return currentSettings;
            },
            setSettings(value) {
                try {
                    localStorage.setItem(localSettingsSaveId, JSON.stringify(value));
                }
                catch (e) {
                    // noop
                }
                currentSettings = value;
            },
            now() {
                return (0,_time_js__WEBPACK_IMPORTED_MODULE_0__.now)();
            },
        };
        if (hook) {
            hook.on(_const_js__WEBPACK_IMPORTED_MODULE_1__.HOOK_PLUGIN_SETTINGS_SET, (pluginId, value) => {
                if (pluginId === this.plugin.id) {
                    this.fallbacks.setSettings(value);
                }
            });
        }
        this.proxiedOn = new Proxy({}, {
            get: (_target, prop) => {
                if (this.target) {
                    return this.target.on[prop];
                }
                else {
                    return (...args) => {
                        this.onQueue.push({
                            method: prop,
                            args,
                        });
                    };
                }
            },
        });
        this.proxiedTarget = new Proxy({}, {
            get: (_target, prop) => {
                if (this.target) {
                    return this.target[prop];
                }
                else if (prop === 'on') {
                    return this.proxiedOn;
                }
                else if (Object.keys(this.fallbacks).includes(prop)) {
                    return (...args) => {
                        this.targetQueue.push({
                            method: prop,
                            args,
                            resolve: () => { },
                        });
                        return this.fallbacks[prop](...args);
                    };
                }
                else {
                    return (...args) => {
                        return new Promise((resolve) => {
                            this.targetQueue.push({
                                method: prop,
                                args,
                                resolve,
                            });
                        });
                    };
                }
            },
        });
    }
    async setRealTarget(target) {
        this.target = target;
        for (const item of this.onQueue) {
            this.target.on[item.method](...item.args);
        }
        for (const item of this.targetQueue) {
            item.resolve(await this.target[item.method](...item.args));
        }
    }
}


/***/ }),

/***/ "./node_modules/@vue/devtools-api/lib/esm/time.js":
/*!********************************************************!*\
  !*** ./node_modules/@vue/devtools-api/lib/esm/time.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isPerformanceSupported: () => (/* binding */ isPerformanceSupported),
/* harmony export */   now: () => (/* binding */ now)
/* harmony export */ });
let supported;
let perf;
function isPerformanceSupported() {
    var _a;
    if (supported !== undefined) {
        return supported;
    }
    if (typeof window !== 'undefined' && window.performance) {
        supported = true;
        perf = window.performance;
    }
    else if (typeof globalThis !== 'undefined' && ((_a = globalThis.perf_hooks) === null || _a === void 0 ? void 0 : _a.performance)) {
        supported = true;
        perf = globalThis.perf_hooks.performance;
    }
    else {
        supported = false;
    }
    return supported;
}
function now() {
    return isPerformanceSupported() ? perf.now() : Date.now();
}


/***/ }),

/***/ "./node_modules/axios/dist/browser/axios.cjs":
/*!***************************************************!*\
  !*** ./node_modules/axios/dist/browser/axios.cjs ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ "./node_modules/process/browser.js");
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
/*! Axios v1.9.0 Copyright (c) 2025 Matt Zabriskie and contributors */


function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// utils is a library of generic helper functions non-specific to axios

const {toString} = Object.prototype;
const {getPrototypeOf} = Object;
const {iterator, toStringTag} = Symbol;

const kindOf = (cache => thing => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
};

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);
};

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
};

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : __webpack_require__.g)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
};

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
};

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
};

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];

  const _iterator = generator.call(obj);

  let result;

  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
};

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
};

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
};

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  };

  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
};

const noop = () => {};

const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === 'FormData' && thing[iterator]);
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  };

  return visit(obj, 0);
};

const isAsyncFn = kindOfTest('AsyncFunction');

const isThenable = (thing) =>
  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

// original code
// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }

  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({source, data}) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);

    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    }
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === 'function',
  isFunction(_global.postMessage)
);

const asap = typeof queueMicrotask !== 'undefined' ?
  queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);

// *********************


const isIterable = (thing) => thing != null && isFunction(thing[iterator]);


var utils$1 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}

utils$1.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});

const prototype$1 = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);

  utils$1.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

// eslint-disable-next-line strict
var httpAdapter = null;

/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils$1.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}

const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (FormData)();

  // eslint-disable-next-line no-param-reassign
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils$1.isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);

  if (!utils$1.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (utils$1.isDate(value)) {
      return value.toISOString();
    }

    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError('Blob is not supported. Use a Buffer instead.');
    }

    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (utils$1.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (utils$1.isArray(value) && isFlatArray(value)) ||
        ((utils$1.isFileList(value) || utils$1.endsWith(key, '[]')) && (arr = utils$1.toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (utils$1.isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    utils$1.forEach(value, function each(el, key) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
        formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!utils$1.isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode$1(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && toFormData(params, this, options);
}

const prototype = AxiosURLSearchParams.prototype;

prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?(object|Function)} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || encode;

  if (utils$1.isFunction(options)) {
    options = {
      serialize: options
    };
  } 

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ?
      params.toString() :
      new AxiosURLSearchParams(params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}

class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

var InterceptorManager$1 = InterceptorManager;

var transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

var URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;

var FormData$1 = typeof FormData !== 'undefined' ? FormData : null;

var Blob$1 = typeof Blob !== 'undefined' ? Blob : null;

var platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
};

const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

const _navigator = typeof navigator === 'object' && navigator || undefined;

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const hasStandardBrowserEnv = hasBrowserEnv &&
  (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
const hasStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === 'function'
  );
})();

const origin = hasBrowserEnv && window.location.href || 'http://localhost';

var utils = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hasBrowserEnv: hasBrowserEnv,
  hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,
  hasStandardBrowserEnv: hasStandardBrowserEnv,
  navigator: _navigator,
  origin: origin
});

var platform = {
  ...utils,
  ...platform$1
};

function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils$1.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];

    if (name === '__proto__') return true;

    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils$1.isArray(target) ? target.length : name;

    if (isLast) {
      if (utils$1.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !utils$1.isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && utils$1.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};

    utils$1.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults = {

  transitional: transitionalDefaults,

  adapter: ['xhr', 'http', 'fetch'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils$1.isObject(data);

    if (isObjectPayload && utils$1.isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = utils$1.isFormData(data);

    if (isFormData) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }

    if (utils$1.isArrayBuffer(data) ||
      utils$1.isBuffer(data) ||
      utils$1.isStream(data) ||
      utils$1.isFile(data) ||
      utils$1.isBlob(data) ||
      utils$1.isReadableStream(data)
    ) {
      return data;
    }
    if (utils$1.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$1.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }

      if ((isFileList = utils$1.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return toFormData(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
      return data;
    }

    if (data && utils$1.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*',
      'Content-Type': undefined
    }
  }
};

utils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
  defaults.headers[method] = {};
});

var defaults$1 = defaults;

// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = utils$1.toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
var parseHeaders = rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
};

const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (utils$1.isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (isHeaderNameFilter) {
    value = header;
  }

  if (!utils$1.isString(value)) return;

  if (utils$1.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (utils$1.isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = utils$1.findKey(self, lHeader);

      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
        self[key || _header] = normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) =>
      utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if(utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils$1.isArray(entry)) {
          throw TypeError('Object iterator must return a key-value pair');
        }

        obj[key = entry[0]] = (dest = obj[key]) ?
          (utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]]) : entry[1];
      }

      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils$1.findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils$1.findKey(this, header);

      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = utils$1.findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;

    while (i--) {
      const key = keys[i];
      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }

    return deleted;
  }

  normalize(format) {
    const self = this;
    const headers = {};

    utils$1.forEach(this, (value, header) => {
      const key = utils$1.findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    utils$1.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  getSetCookie() {
    return this.get("set-cookie") || [];
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach((target) => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
}

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

// reserved names hotfix
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  }
});

utils$1.freezeMethods(AxiosHeaders);

var AxiosHeaders$1 = AxiosHeaders;

/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;

  utils$1.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}

function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      'Request failed with status code ' + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}

/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

/**
 * Throttle decorator
 * @param {Function} fn
 * @param {Number} freq
 * @return {Function}
 */
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1000 / freq;
  let lastArgs;
  let timer;

  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };

  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if ( passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };

  const flush = () => lastArgs && invoke(lastArgs);

  return [throttled, flush];
}

const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);

  return throttle(e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? 'download' : 'upload']: true
    };

    listener(data);
  }, freq);
};

const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;

  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};

const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));

var isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin, isMSIE) => (url) => {
  url = new URL(url, platform.origin);

  return (
    origin.protocol === url.protocol &&
    origin.host === url.host &&
    (isMSIE || origin.port === url.port)
  );
})(
  new URL(platform.origin),
  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
) : () => true;

var cookies = platform.hasStandardBrowserEnv ?

  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + '=' + encodeURIComponent(value)];

      utils$1.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());

      utils$1.isString(path) && cookie.push('path=' + path);

      utils$1.isString(domain) && cookie.push('domain=' + domain);

      secure === true && cookie.push('secure');

      document.cookie = cookie.join('; ');
    },

    read(name) {
      const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return (match ? decodeURIComponent(match[3]) : null);
    },

    remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  }

  :

  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {},
    read() {
      return null;
    },
    remove() {}
  };

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, prop, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({caseless}, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, prop , caseless) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(a, b, prop , caseless);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(undefined, a, prop , caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b , prop) => mergeDeepProperties(headersToObject(a), headersToObject(b),prop, true)
  };

  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (utils$1.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}

var resolveConfig = (config) => {
  const newConfig = mergeConfig({}, config);

  let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;

  newConfig.headers = headers = AxiosHeaders$1.from(headers);

  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);

  // HTTP basic authentication
  if (auth) {
    headers.set('Authorization', 'Basic ' +
      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))
    );
  }

  let contentType;

  if (utils$1.isFormData(data)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(undefined); // Let the browser set it
    } else if ((contentType = headers.getContentType()) !== false) {
      // fix semicolon duplication issue for ReactNative FormData implementation
      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
    }
  }

  // Add xsrf header
  // This is only done if running in a standard browser environment.
  // Specifically not if we're in a web worker, or react-native.

  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));

    if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(newConfig.url))) {
      // Add xsrf header
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);

      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }

  return newConfig;
};

const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

var xhrAdapter = isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let {responseType, onUploadProgress, onDownloadProgress} = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;

    function done() {
      flushUpload && flushUpload(); // flush events
      flushDownload && flushDownload(); // flush events

      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);

      _config.signal && _config.signal.removeEventListener('abort', onCanceled);
    }

    let request = new XMLHttpRequest();

    request.open(_config.method.toUpperCase(), _config.url, true);

    // Set the request timeout in MS
    request.timeout = _config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = AxiosHeaders$1.from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils$1.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = _config.responseType;
    }

    // Handle progress if needed
    if (onDownloadProgress) {
      ([downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true));
      request.addEventListener('progress', downloadThrottled);
    }

    // Not all browsers support upload events
    if (onUploadProgress && request.upload) {
      ([uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress));

      request.upload.addEventListener('progress', uploadThrottled);

      request.upload.addEventListener('loadend', flushUpload);
    }

    if (_config.cancelToken || _config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };

      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = parseProtocol(_config.url);

    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
};

const composeSignals = (signals, timeout) => {
  const {length} = (signals = signals ? signals.filter(Boolean) : []);

  if (timeout || length) {
    let controller = new AbortController();

    let aborted;

    const onabort = function (reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
      }
    };

    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
    }, timeout);

    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach(signal => {
          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);
        });
        signals = null;
      }
    };

    signals.forEach((signal) => signal.addEventListener('abort', onabort));

    const {signal} = controller;

    signal.unsubscribe = () => utils$1.asap(unsubscribe);

    return signal;
  }
};

var composeSignals$1 = composeSignals;

const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;

  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }

  let pos = 0;
  let end;

  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};

const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};

const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }

  const reader = stream.getReader();
  try {
    for (;;) {
      const {done, value} = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};

const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);

  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };

  return new ReadableStream({
    async pull(controller) {
      try {
        const {done, value} = await iterator.next();

        if (done) {
         _onFinish();
          controller.close();
          return;
        }

        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  })
};

const isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';

// used only inside the fetch adapter
const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?
    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :
    async (str) => new Uint8Array(await new Response(str).arrayBuffer())
);

const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false
  }
};

const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;

  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: 'POST',
    get duplex() {
      duplexAccessed = true;
      return 'half';
    },
  }).headers.has('Content-Type');

  return duplexAccessed && !hasContentType;
});

const DEFAULT_CHUNK_SIZE = 64 * 1024;

const supportsResponseStream = isReadableStreamSupported &&
  test(() => utils$1.isReadableStream(new Response('').body));


const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};

isFetchSupported && (((res) => {
  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res) => res[type]() :
      (_, config) => {
        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
      });
  });
})(new Response));

const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }

  if(utils$1.isBlob(body)) {
    return body.size;
  }

  if(utils$1.isSpecCompliantForm(body)) {
    const _request = new Request(platform.origin, {
      method: 'POST',
      body,
    });
    return (await _request.arrayBuffer()).byteLength;
  }

  if(utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
    return body.byteLength;
  }

  if(utils$1.isURLSearchParams(body)) {
    body = body + '';
  }

  if(utils$1.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};

const resolveBodyLength = async (headers, body) => {
  const length = utils$1.toFiniteNumber(headers.getContentLength());

  return length == null ? getBodyLength(body) : length;
};

var fetchAdapter = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = 'same-origin',
    fetchOptions
  } = resolveConfig(config);

  responseType = responseType ? (responseType + '').toLowerCase() : 'text';

  let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);

  let request;

  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
  });

  let requestContentLength;

  try {
    if (
      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&
      (requestContentLength = await resolveBodyLength(headers, data)) !== 0
    ) {
      let _request = new Request(url, {
        method: 'POST',
        body: data,
        duplex: "half"
      });

      let contentTypeHeader;

      if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
        headers.setContentType(contentTypeHeader);
      }

      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );

        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }

    if (!utils$1.isString(withCredentials)) {
      withCredentials = withCredentials ? 'include' : 'omit';
    }

    // Cloudflare Workers throws when credentials are defined
    // see https://github.com/cloudflare/workerd/issues/902
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : undefined
    });

    let response = await fetch(request);

    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');

    if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {
      const options = {};

      ['status', 'statusText', 'headers'].forEach(prop => {
        options[prop] = response[prop];
      });

      const responseContentLength = utils$1.toFiniteNumber(response.headers.get('content-length'));

      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];

      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }

    responseType = responseType || 'text';

    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || 'text'](response, config);

    !isStreamResponse && unsubscribe && unsubscribe();

    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders$1.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    })
  } catch (err) {
    unsubscribe && unsubscribe();

    if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      )
    }

    throw AxiosError.from(err, err && err.code, config, request);
  }
});

const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};

utils$1.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', {value});
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {value});
  }
});

const renderReason = (reason) => `- ${reason}`;

const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;

var adapters = {
  getAdapter: (adapters) => {
    adapters = utils$1.isArray(adapters) ? adapters : [adapters];

    const {length} = adapters;
    let nameOrAdapter;
    let adapter;

    const rejectedReasons = {};

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;

      adapter = nameOrAdapter;

      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

        if (adapter === undefined) {
          throw new AxiosError(`Unknown adapter '${id}'`);
        }
      }

      if (adapter) {
        break;
      }

      rejectedReasons[id || '#' + i] = adapter;
    }

    if (!adapter) {

      const reasons = Object.entries(rejectedReasons)
        .map(([id, state]) => `adapter ${id} ` +
          (state === false ? 'is not supported by the environment' : 'is not available in the build')
        );

      let s = length ?
        (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
        'as no adapter specified';

      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s,
        'ERR_NOT_SUPPORT'
      );
    }

    return adapter;
  },
  adapters: knownAdapters
};

/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = AxiosHeaders$1.from(config.headers);

  // Transform request data
  config.data = transformData.call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );

    response.headers = AxiosHeaders$1.from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}

const VERSION = "1.9.0";

const validators$1 = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators$1[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators$1.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

validators$1.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    // eslint-disable-next-line no-console
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  }
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

var validator = {
  assertOptions,
  validators: validators$1
};

const validators = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};

        Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());

        // slice off the Error: ... line
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
        try {
          if (!err.stack) {
            err.stack = stack;
            // match without the 2 top stack lines
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
            err.stack += '\n' + stack;
          }
        } catch (e) {
          // ignore the case where "stack" is an un-writable property
        }
      }

      throw err;
    }
  }

  _request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = mergeConfig(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }

    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }

    // Set config.allowAbsoluteUrls
    if (config.allowAbsoluteUrls !== undefined) ; else if (this.defaults.allowAbsoluteUrls !== undefined) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }

    validator.assertOptions(config, {
      baseUrl: validators.spelling('baseURL'),
      withXsrfToken: validators.spelling('withXSRFToken')
    }, true);

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    // Flatten headers
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config.method]
    );

    headers && utils$1.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

var Axios$1 = Axios;

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  toAbortSignal() {
    const controller = new AbortController();

    const abort = (err) => {
      controller.abort(err);
    };

    this.subscribe(abort);

    controller.signal.unsubscribe = () => this.unsubscribe(abort);

    return controller.signal;
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

var CancelToken$1 = CancelToken;

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return utils$1.isObject(payload) && (payload.isAxiosError === true);
}

const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};

Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});

var HttpStatusCode$1 = HttpStatusCode;

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);

  // Copy axios.prototype to instance
  utils$1.extend(instance, Axios$1.prototype, context, {allOwnKeys: true});

  // Copy context to instance
  utils$1.extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(defaults$1);

// Expose Axios class to allow class inheritance
axios.Axios = Axios$1;

// Expose Cancel & CancelToken
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;

// Expose AxiosError class
axios.AxiosError = AxiosError;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = spread;

// Expose isAxiosError
axios.isAxiosError = isAxiosError;

// Expose mergeConfig
axios.mergeConfig = mergeConfig;

axios.AxiosHeaders = AxiosHeaders$1;

axios.formToJSON = thing => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);

axios.getAdapter = adapters.getAdapter;

axios.HttpStatusCode = HttpStatusCode$1;

axios.default = axios;

module.exports = axios;
//# sourceMappingURL=axios.cjs.map


/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Axios: () => (/* binding */ Axios),
/* harmony export */   AxiosError: () => (/* binding */ AxiosError),
/* harmony export */   AxiosHeaders: () => (/* binding */ AxiosHeaders),
/* harmony export */   Cancel: () => (/* binding */ Cancel),
/* harmony export */   CancelToken: () => (/* binding */ CancelToken),
/* harmony export */   CanceledError: () => (/* binding */ CanceledError),
/* harmony export */   HttpStatusCode: () => (/* binding */ HttpStatusCode),
/* harmony export */   VERSION: () => (/* binding */ VERSION),
/* harmony export */   all: () => (/* binding */ all),
/* harmony export */   "default": () => (/* reexport safe */ _lib_axios_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   formToJSON: () => (/* binding */ formToJSON),
/* harmony export */   getAdapter: () => (/* binding */ getAdapter),
/* harmony export */   isAxiosError: () => (/* binding */ isAxiosError),
/* harmony export */   isCancel: () => (/* binding */ isCancel),
/* harmony export */   mergeConfig: () => (/* binding */ mergeConfig),
/* harmony export */   spread: () => (/* binding */ spread),
/* harmony export */   toFormData: () => (/* binding */ toFormData)
/* harmony export */ });
/* harmony import */ var _lib_axios_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/axios.js */ "./node_modules/axios/lib/axios.js");


// This module is intended to unwrap Axios default export as named.
// Keep top-level export same with static properties
// so that it can keep same with es module or cjs
const {
  Axios,
  AxiosError,
  CanceledError,
  isCancel,
  CancelToken,
  VERSION,
  all,
  Cancel,
  isAxiosError,
  spread,
  toFormData,
  AxiosHeaders,
  HttpStatusCode,
  formToJSON,
  getAdapter,
  mergeConfig
} = _lib_axios_js__WEBPACK_IMPORTED_MODULE_0__["default"];




/***/ }),

/***/ "./node_modules/axios/lib/adapters/adapters.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/adapters/adapters.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _http_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./http.js */ "./node_modules/axios/lib/helpers/null.js");
/* harmony import */ var _xhr_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xhr.js */ "./node_modules/axios/lib/adapters/xhr.js");
/* harmony import */ var _fetch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fetch.js */ "./node_modules/axios/lib/adapters/fetch.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");






const knownAdapters = {
  http: _http_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  xhr: _xhr_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  fetch: _fetch_js__WEBPACK_IMPORTED_MODULE_2__["default"]
}

_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', {value});
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {value});
  }
});

const renderReason = (reason) => `- ${reason}`;

const isResolvedHandle = (adapter) => _utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].isFunction(adapter) || adapter === null || adapter === false;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  getAdapter: (adapters) => {
    adapters = _utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].isArray(adapters) ? adapters : [adapters];

    const {length} = adapters;
    let nameOrAdapter;
    let adapter;

    const rejectedReasons = {};

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;

      adapter = nameOrAdapter;

      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

        if (adapter === undefined) {
          throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_4__["default"](`Unknown adapter '${id}'`);
        }
      }

      if (adapter) {
        break;
      }

      rejectedReasons[id || '#' + i] = adapter;
    }

    if (!adapter) {

      const reasons = Object.entries(rejectedReasons)
        .map(([id, state]) => `adapter ${id} ` +
          (state === false ? 'is not supported by the environment' : 'is not available in the build')
        );

      let s = length ?
        (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
        'as no adapter specified';

      throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_4__["default"](
        `There is no suitable adapter to dispatch the request ` + s,
        'ERR_NOT_SUPPORT'
      );
    }

    return adapter;
  },
  adapters: knownAdapters
});


/***/ }),

/***/ "./node_modules/axios/lib/adapters/fetch.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/adapters/fetch.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _helpers_composeSignals_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/composeSignals.js */ "./node_modules/axios/lib/helpers/composeSignals.js");
/* harmony import */ var _helpers_trackStream_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/trackStream.js */ "./node_modules/axios/lib/helpers/trackStream.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");
/* harmony import */ var _helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/progressEventReducer.js */ "./node_modules/axios/lib/helpers/progressEventReducer.js");
/* harmony import */ var _helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/resolveConfig.js */ "./node_modules/axios/lib/helpers/resolveConfig.js");
/* harmony import */ var _core_settle_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/settle.js */ "./node_modules/axios/lib/core/settle.js");










const isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';

// used only inside the fetch adapter
const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?
    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :
    async (str) => new Uint8Array(await new Response(str).arrayBuffer())
);

const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false
  }
}

const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;

  const hasContentType = new Request(_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].origin, {
    body: new ReadableStream(),
    method: 'POST',
    get duplex() {
      duplexAccessed = true;
      return 'half';
    },
  }).headers.has('Content-Type');

  return duplexAccessed && !hasContentType;
});

const DEFAULT_CHUNK_SIZE = 64 * 1024;

const supportsResponseStream = isReadableStreamSupported &&
  test(() => _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isReadableStream(new Response('').body));


const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};

isFetchSupported && (((res) => {
  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
    !resolvers[type] && (resolvers[type] = _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isFunction(res[type]) ? (res) => res[type]() :
      (_, config) => {
        throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"](`Response type '${type}' is not supported`, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERR_NOT_SUPPORT, config);
      })
  });
})(new Response));

const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }

  if(_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isBlob(body)) {
    return body.size;
  }

  if(_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isSpecCompliantForm(body)) {
    const _request = new Request(_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].origin, {
      method: 'POST',
      body,
    });
    return (await _request.arrayBuffer()).byteLength;
  }

  if(_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isArrayBufferView(body) || _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isArrayBuffer(body)) {
    return body.byteLength;
  }

  if(_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isURLSearchParams(body)) {
    body = body + '';
  }

  if(_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isString(body)) {
    return (await encodeText(body)).byteLength;
  }
}

const resolveBodyLength = async (headers, body) => {
  const length = _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].toFiniteNumber(headers.getContentLength());

  return length == null ? getBodyLength(body) : length;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = 'same-origin',
    fetchOptions
  } = (0,_helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_3__["default"])(config);

  responseType = responseType ? (responseType + '').toLowerCase() : 'text';

  let composedSignal = (0,_helpers_composeSignals_js__WEBPACK_IMPORTED_MODULE_4__["default"])([signal, cancelToken && cancelToken.toAbortSignal()], timeout);

  let request;

  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
  });

  let requestContentLength;

  try {
    if (
      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&
      (requestContentLength = await resolveBodyLength(headers, data)) !== 0
    ) {
      let _request = new Request(url, {
        method: 'POST',
        body: data,
        duplex: "half"
      });

      let contentTypeHeader;

      if (_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
        headers.setContentType(contentTypeHeader)
      }

      if (_request.body) {
        const [onProgress, flush] = (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.progressEventDecorator)(
          requestContentLength,
          (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.progressEventReducer)((0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.asyncDecorator)(onUploadProgress))
        );

        data = (0,_helpers_trackStream_js__WEBPACK_IMPORTED_MODULE_6__.trackStream)(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }

    if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isString(withCredentials)) {
      withCredentials = withCredentials ? 'include' : 'omit';
    }

    // Cloudflare Workers throws when credentials are defined
    // see https://github.com/cloudflare/workerd/issues/902
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : undefined
    });

    let response = await fetch(request);

    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');

    if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {
      const options = {};

      ['status', 'statusText', 'headers'].forEach(prop => {
        options[prop] = response[prop];
      });

      const responseContentLength = _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].toFiniteNumber(response.headers.get('content-length'));

      const [onProgress, flush] = onDownloadProgress && (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.progressEventDecorator)(
        responseContentLength,
        (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.progressEventReducer)((0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.asyncDecorator)(onDownloadProgress), true)
      ) || [];

      response = new Response(
        (0,_helpers_trackStream_js__WEBPACK_IMPORTED_MODULE_6__.trackStream)(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }

    responseType = responseType || 'text';

    let responseData = await resolvers[_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].findKey(resolvers, responseType) || 'text'](response, config);

    !isStreamResponse && unsubscribe && unsubscribe();

    return await new Promise((resolve, reject) => {
      (0,_core_settle_js__WEBPACK_IMPORTED_MODULE_7__["default"])(resolve, reject, {
        data: responseData,
        headers: _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_8__["default"].from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      })
    })
  } catch (err) {
    unsubscribe && unsubscribe();

    if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {
      throw Object.assign(
        new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"]('Network Error', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      )
    }

    throw _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"].from(err, err && err.code, config, request);
  }
}));




/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _core_settle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./../core/settle.js */ "./node_modules/axios/lib/core/settle.js");
/* harmony import */ var _defaults_transitional_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../defaults/transitional.js */ "./node_modules/axios/lib/defaults/transitional.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../cancel/CanceledError.js */ "./node_modules/axios/lib/cancel/CanceledError.js");
/* harmony import */ var _helpers_parseProtocol_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../helpers/parseProtocol.js */ "./node_modules/axios/lib/helpers/parseProtocol.js");
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");
/* harmony import */ var _helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/progressEventReducer.js */ "./node_modules/axios/lib/helpers/progressEventReducer.js");
/* harmony import */ var _helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/resolveConfig.js */ "./node_modules/axios/lib/helpers/resolveConfig.js");











const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = (0,_helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_0__["default"])(config);
    let requestData = _config.data;
    const requestHeaders = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"].from(_config.headers).normalize();
    let {responseType, onUploadProgress, onDownloadProgress} = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;

    function done() {
      flushUpload && flushUpload(); // flush events
      flushDownload && flushDownload(); // flush events

      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);

      _config.signal && _config.signal.removeEventListener('abort', onCanceled);
    }

    let request = new XMLHttpRequest();

    request.open(_config.method.toUpperCase(), _config.url, true);

    // Set the request timeout in MS
    request.timeout = _config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"].from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      (0,_core_settle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"]('Request aborted', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"].ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"]('Network Error', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = _config.transitional || _defaults_transitional_js__WEBPACK_IMPORTED_MODULE_4__["default"];
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"](
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"].ETIMEDOUT : _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"].ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      _utils_js__WEBPACK_IMPORTED_MODULE_5__["default"].forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"].isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = _config.responseType;
    }

    // Handle progress if needed
    if (onDownloadProgress) {
      ([downloadThrottled, flushDownload] = (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_6__.progressEventReducer)(onDownloadProgress, true));
      request.addEventListener('progress', downloadThrottled);
    }

    // Not all browsers support upload events
    if (onUploadProgress && request.upload) {
      ([uploadThrottled, flushUpload] = (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_6__.progressEventReducer)(onUploadProgress));

      request.upload.addEventListener('progress', uploadThrottled);

      request.upload.addEventListener('loadend', flushUpload);
    }

    if (_config.cancelToken || _config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_7__["default"](null, config, request) : cancel);
        request.abort();
        request = null;
      };

      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = (0,_helpers_parseProtocol_js__WEBPACK_IMPORTED_MODULE_8__["default"])(_config.url);

    if (protocol && _platform_index_js__WEBPACK_IMPORTED_MODULE_9__["default"].protocols.indexOf(protocol) === -1) {
      reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"]('Unsupported protocol ' + protocol + ':', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
});


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _helpers_bind_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers/bind.js */ "./node_modules/axios/lib/helpers/bind.js");
/* harmony import */ var _core_Axios_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/Axios.js */ "./node_modules/axios/lib/core/Axios.js");
/* harmony import */ var _core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/mergeConfig.js */ "./node_modules/axios/lib/core/mergeConfig.js");
/* harmony import */ var _defaults_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./defaults/index.js */ "./node_modules/axios/lib/defaults/index.js");
/* harmony import */ var _helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./helpers/formDataToJSON.js */ "./node_modules/axios/lib/helpers/formDataToJSON.js");
/* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cancel/CanceledError.js */ "./node_modules/axios/lib/cancel/CanceledError.js");
/* harmony import */ var _cancel_CancelToken_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cancel/CancelToken.js */ "./node_modules/axios/lib/cancel/CancelToken.js");
/* harmony import */ var _cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cancel/isCancel.js */ "./node_modules/axios/lib/cancel/isCancel.js");
/* harmony import */ var _env_data_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./env/data.js */ "./node_modules/axios/lib/env/data.js");
/* harmony import */ var _helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./helpers/toFormData.js */ "./node_modules/axios/lib/helpers/toFormData.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _helpers_spread_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./helpers/spread.js */ "./node_modules/axios/lib/helpers/spread.js");
/* harmony import */ var _helpers_isAxiosError_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./helpers/isAxiosError.js */ "./node_modules/axios/lib/helpers/isAxiosError.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");
/* harmony import */ var _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./adapters/adapters.js */ "./node_modules/axios/lib/adapters/adapters.js");
/* harmony import */ var _helpers_HttpStatusCode_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./helpers/HttpStatusCode.js */ "./node_modules/axios/lib/helpers/HttpStatusCode.js");




















/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new _core_Axios_js__WEBPACK_IMPORTED_MODULE_0__["default"](defaultConfig);
  const instance = (0,_helpers_bind_js__WEBPACK_IMPORTED_MODULE_1__["default"])(_core_Axios_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.request, context);

  // Copy axios.prototype to instance
  _utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].extend(instance, _core_Axios_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype, context, {allOwnKeys: true});

  // Copy context to instance
  _utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance((0,_core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_3__["default"])(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(_defaults_index_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

// Expose Axios class to allow class inheritance
axios.Axios = _core_Axios_js__WEBPACK_IMPORTED_MODULE_0__["default"];

// Expose Cancel & CancelToken
axios.CanceledError = _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_5__["default"];
axios.CancelToken = _cancel_CancelToken_js__WEBPACK_IMPORTED_MODULE_6__["default"];
axios.isCancel = _cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_7__["default"];
axios.VERSION = _env_data_js__WEBPACK_IMPORTED_MODULE_8__.VERSION;
axios.toFormData = _helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_9__["default"];

// Expose AxiosError class
axios.AxiosError = _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_10__["default"];

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = _helpers_spread_js__WEBPACK_IMPORTED_MODULE_11__["default"];

// Expose isAxiosError
axios.isAxiosError = _helpers_isAxiosError_js__WEBPACK_IMPORTED_MODULE_12__["default"];

// Expose mergeConfig
axios.mergeConfig = _core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_3__["default"];

axios.AxiosHeaders = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_13__["default"];

axios.formToJSON = thing => (0,_helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_14__["default"])(_utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].isHTMLForm(thing) ? new FormData(thing) : thing);

axios.getAdapter = _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_15__["default"].getAdapter;

axios.HttpStatusCode = _helpers_HttpStatusCode_js__WEBPACK_IMPORTED_MODULE_16__["default"];

axios.default = axios;

// this module should only have a default export
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (axios);


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CanceledError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CanceledError.js */ "./node_modules/axios/lib/cancel/CanceledError.js");




/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new _CanceledError_js__WEBPACK_IMPORTED_MODULE_0__["default"](message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  toAbortSignal() {
    const controller = new AbortController();

    const abort = (err) => {
      controller.abort(err);
    };

    this.subscribe(abort);

    controller.signal.unsubscribe = () => this.unsubscribe(abort);

    return controller.signal;
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CancelToken);


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CanceledError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CanceledError.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");





/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"].call(this, message == null ? 'canceled' : message, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].inherits(CanceledError, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"], {
  __CANCEL__: true
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanceledError);


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isCancel)
/* harmony export */ });


function isCancel(value) {
  return !!(value && value.__CANCEL__);
}


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _helpers_buildURL_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/buildURL.js */ "./node_modules/axios/lib/helpers/buildURL.js");
/* harmony import */ var _InterceptorManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./InterceptorManager.js */ "./node_modules/axios/lib/core/InterceptorManager.js");
/* harmony import */ var _dispatchRequest_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dispatchRequest.js */ "./node_modules/axios/lib/core/dispatchRequest.js");
/* harmony import */ var _mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mergeConfig.js */ "./node_modules/axios/lib/core/mergeConfig.js");
/* harmony import */ var _buildFullPath_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./buildFullPath.js */ "./node_modules/axios/lib/core/buildFullPath.js");
/* harmony import */ var _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/validator.js */ "./node_modules/axios/lib/helpers/validator.js");
/* harmony import */ var _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");











const validators = _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__["default"].validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new _InterceptorManager_js__WEBPACK_IMPORTED_MODULE_1__["default"](),
      response: new _InterceptorManager_js__WEBPACK_IMPORTED_MODULE_1__["default"]()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};

        Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());

        // slice off the Error: ... line
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
        try {
          if (!err.stack) {
            err.stack = stack;
            // match without the 2 top stack lines
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
            err.stack += '\n' + stack
          }
        } catch (e) {
          // ignore the case where "stack" is an un-writable property
        }
      }

      throw err;
    }
  }

  _request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = (0,_mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__["default"])(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__["default"].assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }

    if (paramsSerializer != null) {
      if (_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        }
      } else {
        _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__["default"].assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }

    // Set config.allowAbsoluteUrls
    if (config.allowAbsoluteUrls !== undefined) {
      // do nothing
    } else if (this.defaults.allowAbsoluteUrls !== undefined) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }

    _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__["default"].assertOptions(config, {
      baseUrl: validators.spelling('baseURL'),
      withXsrfToken: validators.spelling('withXSRFToken')
    }, true);

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    // Flatten headers
    let contextHeaders = headers && _utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].merge(
      headers.common,
      headers[config.method]
    );

    headers && _utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_4__["default"].concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [_dispatchRequest_js__WEBPACK_IMPORTED_MODULE_5__["default"].bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = _dispatchRequest_js__WEBPACK_IMPORTED_MODULE_5__["default"].call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = (0,_mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__["default"])(this.defaults, config);
    const fullPath = (0,_buildFullPath_js__WEBPACK_IMPORTED_MODULE_6__["default"])(config.baseURL, config.url, config.allowAbsoluteUrls);
    return (0,_helpers_buildURL_js__WEBPACK_IMPORTED_MODULE_7__["default"])(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request((0,_mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__["default"])(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request((0,_mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__["default"])(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Axios);


/***/ }),

/***/ "./node_modules/axios/lib/core/AxiosError.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/core/AxiosError.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");




/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}

_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});

const prototype = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);

  _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxiosError);


/***/ }),

/***/ "./node_modules/axios/lib/core/AxiosHeaders.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/AxiosHeaders.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _helpers_parseHeaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/parseHeaders.js */ "./node_modules/axios/lib/helpers/parseHeaders.js");





const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (isHeaderNameFilter) {
    value = header;
  }

  if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(value)) return;

  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].findKey(self, lHeader);

      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
        self[key || _header] = normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) =>
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite)
    } else if(_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders((0,_helpers_parseHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"])(header), valueOrRewrite);
    } else if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(header) && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(entry)) {
          throw TypeError('Object iterator must return a key-value pair');
        }

        obj[key = entry[0]] = (dest = obj[key]) ?
          (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]]) : entry[1];
      }

      setHeaders(obj, valueOrRewrite)
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].findKey(this, header);

      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;

    while (i--) {
      const key = keys[i];
      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }

    return deleted;
  }

  normalize(format) {
    const self = this;
    const headers = {};

    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(this, (value, header) => {
      const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  getSetCookie() {
    return this.get("set-cookie") || [];
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach((target) => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
}

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

// reserved names hotfix
_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  }
});

_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].freezeMethods(AxiosHeaders);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxiosHeaders);


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");




class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InterceptorManager);


/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ buildFullPath)
/* harmony export */ });
/* harmony import */ var _helpers_isAbsoluteURL_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/isAbsoluteURL.js */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
/* harmony import */ var _helpers_combineURLs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/combineURLs.js */ "./node_modules/axios/lib/helpers/combineURLs.js");





/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !(0,_helpers_isAbsoluteURL_js__WEBPACK_IMPORTED_MODULE_0__["default"])(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return (0,_helpers_combineURLs_js__WEBPACK_IMPORTED_MODULE_1__["default"])(baseURL, requestedURL);
  }
  return requestedURL;
}


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ dispatchRequest)
/* harmony export */ });
/* harmony import */ var _transformData_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transformData.js */ "./node_modules/axios/lib/core/transformData.js");
/* harmony import */ var _cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../cancel/isCancel.js */ "./node_modules/axios/lib/cancel/isCancel.js");
/* harmony import */ var _defaults_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../defaults/index.js */ "./node_modules/axios/lib/defaults/index.js");
/* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cancel/CanceledError.js */ "./node_modules/axios/lib/cancel/CanceledError.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");
/* harmony import */ var _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../adapters/adapters.js */ "./node_modules/axios/lib/adapters/adapters.js");









/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_0__["default"](null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"].from(config.headers);

  // Transform request data
  config.data = _transformData_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_3__["default"].getAdapter(config.adapter || _defaults_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = _transformData_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(
      config,
      config.transformResponse,
      response
    );

    response.headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"].from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!(0,_cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_5__["default"])(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = _transformData_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"].from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}


/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mergeConfig)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");





const headersToObject = (thing) => thing instanceof _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? { ...thing } : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, prop, caseless) {
    if (_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isPlainObject(target) && _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isPlainObject(source)) {
      return _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].merge.call({caseless}, target, source);
    } else if (_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isPlainObject(source)) {
      return _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].merge({}, source);
    } else if (_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, prop , caseless) {
    if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isUndefined(b)) {
      return getMergedValue(a, b, prop , caseless);
    } else if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isUndefined(a)) {
      return getMergedValue(undefined, a, prop , caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b , prop) => mergeDeepProperties(headersToObject(a), headersToObject(b),prop, true)
  };

  _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ settle)
/* harmony export */ });
/* harmony import */ var _AxiosError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");




/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new _AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"](
      'Request failed with status code ' + response.status,
      [_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERR_BAD_REQUEST, _AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ transformData)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _defaults_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../defaults/index.js */ "./node_modules/axios/lib/defaults/index.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");






/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || _defaults_index_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  const context = response || config;
  const headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"].from(context.headers);
  let data = context.data;

  _utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}


/***/ }),

/***/ "./node_modules/axios/lib/defaults/index.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/defaults/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _transitional_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transitional.js */ "./node_modules/axios/lib/defaults/transitional.js");
/* harmony import */ var _helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/toFormData.js */ "./node_modules/axios/lib/helpers/toFormData.js");
/* harmony import */ var _helpers_toURLEncodedForm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/toURLEncodedForm.js */ "./node_modules/axios/lib/helpers/toURLEncodedForm.js");
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");
/* harmony import */ var _helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/formDataToJSON.js */ "./node_modules/axios/lib/helpers/formDataToJSON.js");










/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults = {

  transitional: _transitional_js__WEBPACK_IMPORTED_MODULE_1__["default"],

  adapter: ['xhr', 'http', 'fetch'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(data);

    if (isObjectPayload && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFormData(data);

    if (isFormData) {
      return hasJSONContentType ? JSON.stringify((0,_helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_2__["default"])(data)) : data;
    }

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArrayBuffer(data) ||
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isBuffer(data) ||
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isStream(data) ||
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFile(data) ||
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isBlob(data) ||
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isReadableStream(data)
    ) {
      return data;
    }
    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArrayBufferView(data)) {
      return data.buffer;
    }
    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return (0,_helpers_toURLEncodedForm_js__WEBPACK_IMPORTED_MODULE_3__["default"])(data, this.formSerializer).toString();
      }

      if ((isFileList = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return (0,_helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_4__["default"])(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isResponse(data) || _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isReadableStream(data)) {
      return data;
    }

    if (data && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_5__["default"].from(e, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_5__["default"].ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: _platform_index_js__WEBPACK_IMPORTED_MODULE_6__["default"].classes.FormData,
    Blob: _platform_index_js__WEBPACK_IMPORTED_MODULE_6__["default"].classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*',
      'Content-Type': undefined
    }
  }
};

_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
  defaults.headers[method] = {};
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (defaults);


/***/ }),

/***/ "./node_modules/axios/lib/defaults/transitional.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/defaults/transitional.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
});


/***/ }),

/***/ "./node_modules/axios/lib/env/data.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/env/data.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VERSION: () => (/* binding */ VERSION)
/* harmony export */ });
const VERSION = "1.9.0";

/***/ }),

/***/ "./node_modules/axios/lib/helpers/AxiosURLSearchParams.js":
/*!****************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/AxiosURLSearchParams.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toFormData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toFormData.js */ "./node_modules/axios/lib/helpers/toFormData.js");




/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && (0,_toFormData_js__WEBPACK_IMPORTED_MODULE_0__["default"])(params, this, options);
}

const prototype = AxiosURLSearchParams.prototype;

prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxiosURLSearchParams);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/HttpStatusCode.js":
/*!**********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/HttpStatusCode.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};

Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HttpStatusCode);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ bind)
/* harmony export */ });


function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ buildURL)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _helpers_AxiosURLSearchParams_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/AxiosURLSearchParams.js */ "./node_modules/axios/lib/helpers/AxiosURLSearchParams.js");





/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?(object|Function)} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || encode;

  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(options)) {
    options = {
      serialize: options
    };
  } 

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isURLSearchParams(params) ?
      params.toString() :
      new _helpers_AxiosURLSearchParams_js__WEBPACK_IMPORTED_MODULE_1__["default"](params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ combineURLs)
/* harmony export */ });


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/composeSignals.js":
/*!**********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/composeSignals.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cancel/CanceledError.js */ "./node_modules/axios/lib/cancel/CanceledError.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");




const composeSignals = (signals, timeout) => {
  const {length} = (signals = signals ? signals.filter(Boolean) : []);

  if (timeout || length) {
    let controller = new AbortController();

    let aborted;

    const onabort = function (reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? err : new _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_1__["default"](err instanceof Error ? err.message : err));
      }
    }

    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"](`timeout ${timeout} of ms exceeded`, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"].ETIMEDOUT))
    }, timeout)

    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach(signal => {
          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);
        });
        signals = null;
      }
    }

    signals.forEach((signal) => signal.addEventListener('abort', onabort));

    const {signal} = controller;

    signal.unsubscribe = () => _utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].asap(unsubscribe);

    return signal;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (composeSignals);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasStandardBrowserEnv ?

  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + '=' + encodeURIComponent(value)];

      _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());

      _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isString(path) && cookie.push('path=' + path);

      _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isString(domain) && cookie.push('domain=' + domain);

      secure === true && cookie.push('secure');

      document.cookie = cookie.join('; ');
    },

    read(name) {
      const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return (match ? decodeURIComponent(match[3]) : null);
    },

    remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  }

  :

  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {},
    read() {
      return null;
    },
    remove() {}
  });



/***/ }),

/***/ "./node_modules/axios/lib/helpers/formDataToJSON.js":
/*!**********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/formDataToJSON.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");




/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];

    if (name === '__proto__') return true;

    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(target) ? target.length : name;

    if (isLast) {
      if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFormData(formData) && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(formData.entries)) {
    const obj = {};

    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formDataToJSON);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isAbsoluteURL)
/* harmony export */ });


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isAxiosError)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");




/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(payload) && (payload.isAxiosError === true);
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasStandardBrowserEnv ? ((origin, isMSIE) => (url) => {
  url = new URL(url, _platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].origin);

  return (
    origin.protocol === url.protocol &&
    origin.host === url.host &&
    (isMSIE || origin.port === url.port)
  );
})(
  new URL(_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].origin),
  _platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].navigator && /(msie|trident)/i.test(_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].navigator.userAgent)
) : () => true);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/null.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/null.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// eslint-disable-next-line strict
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (null);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");




// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
});


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseProtocol.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseProtocol.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ parseProtocol)
/* harmony export */ });


function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/progressEventReducer.js":
/*!****************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/progressEventReducer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   asyncDecorator: () => (/* binding */ asyncDecorator),
/* harmony export */   progressEventDecorator: () => (/* binding */ progressEventDecorator),
/* harmony export */   progressEventReducer: () => (/* binding */ progressEventReducer)
/* harmony export */ });
/* harmony import */ var _speedometer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./speedometer.js */ "./node_modules/axios/lib/helpers/speedometer.js");
/* harmony import */ var _throttle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./throttle.js */ "./node_modules/axios/lib/helpers/throttle.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");




const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = (0,_speedometer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(50, 250);

  return (0,_throttle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? 'download' : 'upload']: true
    };

    listener(data);
  }, freq);
}

const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;

  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
}

const asyncDecorator = (fn) => (...args) => _utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].asap(() => fn(...args));


/***/ }),

/***/ "./node_modules/axios/lib/helpers/resolveConfig.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/resolveConfig.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _isURLSameOrigin_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isURLSameOrigin.js */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
/* harmony import */ var _cookies_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cookies.js */ "./node_modules/axios/lib/helpers/cookies.js");
/* harmony import */ var _core_buildFullPath_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/buildFullPath.js */ "./node_modules/axios/lib/core/buildFullPath.js");
/* harmony import */ var _core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/mergeConfig.js */ "./node_modules/axios/lib/core/mergeConfig.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");
/* harmony import */ var _buildURL_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./buildURL.js */ "./node_modules/axios/lib/helpers/buildURL.js");









/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((config) => {
  const newConfig = (0,_core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_0__["default"])({}, config);

  let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;

  newConfig.headers = headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"].from(headers);

  newConfig.url = (0,_buildURL_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_core_buildFullPath_js__WEBPACK_IMPORTED_MODULE_3__["default"])(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);

  // HTTP basic authentication
  if (auth) {
    headers.set('Authorization', 'Basic ' +
      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))
    );
  }

  let contentType;

  if (_utils_js__WEBPACK_IMPORTED_MODULE_4__["default"].isFormData(data)) {
    if (_platform_index_js__WEBPACK_IMPORTED_MODULE_5__["default"].hasStandardBrowserEnv || _platform_index_js__WEBPACK_IMPORTED_MODULE_5__["default"].hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(undefined); // Let the browser set it
    } else if ((contentType = headers.getContentType()) !== false) {
      // fix semicolon duplication issue for ReactNative FormData implementation
      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
    }
  }

  // Add xsrf header
  // This is only done if running in a standard browser environment.
  // Specifically not if we're in a web worker, or react-native.

  if (_platform_index_js__WEBPACK_IMPORTED_MODULE_5__["default"].hasStandardBrowserEnv) {
    withXSRFToken && _utils_js__WEBPACK_IMPORTED_MODULE_4__["default"].isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));

    if (withXSRFToken || (withXSRFToken !== false && (0,_isURLSameOrigin_js__WEBPACK_IMPORTED_MODULE_6__["default"])(newConfig.url))) {
      // Add xsrf header
      const xsrfValue = xsrfHeaderName && xsrfCookieName && _cookies_js__WEBPACK_IMPORTED_MODULE_7__["default"].read(xsrfCookieName);

      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }

  return newConfig;
});



/***/ }),

/***/ "./node_modules/axios/lib/helpers/speedometer.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/speedometer.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (speedometer);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ spread)
/* harmony export */ });


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/throttle.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/throttle.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Throttle decorator
 * @param {Function} fn
 * @param {Number} freq
 * @return {Function}
 */
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1000 / freq;
  let lastArgs;
  let timer;

  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  }

  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if ( passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs)
        }, threshold - passed);
      }
    }
  }

  const flush = () => lastArgs && invoke(lastArgs);

  return [throttled, flush];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (throttle);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/toFormData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/toFormData.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _platform_node_classes_FormData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/node/classes/FormData.js */ "./node_modules/axios/lib/helpers/null.js");
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];




// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored


/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isPlainObject(thing) || _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(arr) && !arr.some(isVisitable);
}

const predicates = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toFlatObject(_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"], {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (_platform_node_classes_FormData_js__WEBPACK_IMPORTED_MODULE_1__["default"] || FormData)();

  // eslint-disable-next-line no-param-reassign
  options = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isSpecCompliantForm(formData);

  if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isDate(value)) {
      return value.toISOString();
    }

    if (!useBlob && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isBlob(value)) {
      throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"]('Blob is not supported. Use a Buffer instead.');
    }

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArrayBuffer(value) || _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(value) && isFlatArray(value)) ||
        ((_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFileList(value) || _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].endsWith(key, '[]')) && (arr = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(value, function each(el, key) {
      const result = !(_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isUndefined(el) || el === null) && visitor.call(
        formData, el, _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toFormData);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/toURLEncodedForm.js":
/*!************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/toURLEncodedForm.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toURLEncodedForm)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _toFormData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toFormData.js */ "./node_modules/axios/lib/helpers/toFormData.js");
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");






function toURLEncodedForm(data, options) {
  return (0,_toFormData_js__WEBPACK_IMPORTED_MODULE_0__["default"])(data, new _platform_index_js__WEBPACK_IMPORTED_MODULE_1__["default"].classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (_platform_index_js__WEBPACK_IMPORTED_MODULE_1__["default"].isNode && _utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/trackStream.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/trackStream.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readBytes: () => (/* binding */ readBytes),
/* harmony export */   streamChunk: () => (/* binding */ streamChunk),
/* harmony export */   trackStream: () => (/* binding */ trackStream)
/* harmony export */ });

const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;

  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }

  let pos = 0;
  let end;

  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
}

const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
}

const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }

  const reader = stream.getReader();
  try {
    for (;;) {
      const {done, value} = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
}

const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);

  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  }

  return new ReadableStream({
    async pull(controller) {
      try {
        const {done, value} = await iterator.next();

        if (done) {
         _onFinish();
          controller.close();
          return;
        }

        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  })
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _env_data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env/data.js */ "./node_modules/axios/lib/env/data.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");





const validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + _env_data_js__WEBPACK_IMPORTED_MODULE_0__.VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"](
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    // eslint-disable-next-line no-console
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  }
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"]('options must be an object', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"]('option ' + opt + ' must be ' + result, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"]('Unknown option ' + opt, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERR_BAD_OPTION);
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  assertOptions,
  validators
});


/***/ }),

/***/ "./node_modules/axios/lib/platform/browser/classes/Blob.js":
/*!*****************************************************************!*\
  !*** ./node_modules/axios/lib/platform/browser/classes/Blob.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (typeof Blob !== 'undefined' ? Blob : null);


/***/ }),

/***/ "./node_modules/axios/lib/platform/browser/classes/FormData.js":
/*!*********************************************************************!*\
  !*** ./node_modules/axios/lib/platform/browser/classes/FormData.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (typeof FormData !== 'undefined' ? FormData : null);


/***/ }),

/***/ "./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js":
/*!****************************************************************************!*\
  !*** ./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers_AxiosURLSearchParams_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../helpers/AxiosURLSearchParams.js */ "./node_modules/axios/lib/helpers/AxiosURLSearchParams.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (typeof URLSearchParams !== 'undefined' ? URLSearchParams : _helpers_AxiosURLSearchParams_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./node_modules/axios/lib/platform/browser/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/axios/lib/platform/browser/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _classes_URLSearchParams_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./classes/URLSearchParams.js */ "./node_modules/axios/lib/platform/browser/classes/URLSearchParams.js");
/* harmony import */ var _classes_FormData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classes/FormData.js */ "./node_modules/axios/lib/platform/browser/classes/FormData.js");
/* harmony import */ var _classes_Blob_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./classes/Blob.js */ "./node_modules/axios/lib/platform/browser/classes/Blob.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  isBrowser: true,
  classes: {
    URLSearchParams: _classes_URLSearchParams_js__WEBPACK_IMPORTED_MODULE_0__["default"],
    FormData: _classes_FormData_js__WEBPACK_IMPORTED_MODULE_1__["default"],
    Blob: _classes_Blob_js__WEBPACK_IMPORTED_MODULE_2__["default"]
  },
  protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
});


/***/ }),

/***/ "./node_modules/axios/lib/platform/common/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/platform/common/utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hasBrowserEnv: () => (/* binding */ hasBrowserEnv),
/* harmony export */   hasStandardBrowserEnv: () => (/* binding */ hasStandardBrowserEnv),
/* harmony export */   hasStandardBrowserWebWorkerEnv: () => (/* binding */ hasStandardBrowserWebWorkerEnv),
/* harmony export */   navigator: () => (/* binding */ _navigator),
/* harmony export */   origin: () => (/* binding */ origin)
/* harmony export */ });
const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

const _navigator = typeof navigator === 'object' && navigator || undefined;

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const hasStandardBrowserEnv = hasBrowserEnv &&
  (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
const hasStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === 'function'
  );
})();

const origin = hasBrowserEnv && window.location.href || 'http://localhost';




/***/ }),

/***/ "./node_modules/axios/lib/platform/index.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/platform/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node/index.js */ "./node_modules/axios/lib/platform/browser/index.js");
/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common/utils.js */ "./node_modules/axios/lib/platform/common/utils.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  ..._common_utils_js__WEBPACK_IMPORTED_MODULE_0__,
  ..._node_index_js__WEBPACK_IMPORTED_MODULE_1__["default"]
});


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers_bind_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers/bind.js */ "./node_modules/axios/lib/helpers/bind.js");
/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ "./node_modules/process/browser.js");




// utils is a library of generic helper functions non-specific to axios

const {toString} = Object.prototype;
const {getPrototypeOf} = Object;
const {iterator, toStringTag} = Symbol;

const kindOf = (cache => thing => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
}

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);
}

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  }

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = (0,_helpers_bind_js__WEBPACK_IMPORTED_MODULE_0__["default"])(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
}

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
}

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];

  const _iterator = generator.call(obj);

  let result;

  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
}

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
}

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
}

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
}

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  }

  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
}

const noop = () => {}

const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
}

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === 'FormData' && thing[iterator]);
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  }

  return visit(obj, 0);
}

const isAsyncFn = kindOfTest('AsyncFunction');

const isThenable = (thing) =>
  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

// original code
// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }

  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({source, data}) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);

    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    }
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === 'function',
  isFunction(_global.postMessage)
);

const asap = typeof queueMicrotask !== 'undefined' ?
  queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);

// *********************


const isIterable = (thing) => thing != null && isFunction(thing[iterator]);


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
});


/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/components/DetailField.vue?vue&type=script&lang=js":
/*!**************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/components/DetailField.vue?vue&type=script&lang=js ***!
  \**************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var tui_editor_vue3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tui-editor-vue3 */ "./node_modules/tui-editor-vue3/dist/tui-editor-vue3.es.js");
/* harmony import */ var _utils_novaDarkMode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/novaDarkMode */ "./resources/utils/novaDarkMode.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: ['index', 'resource', 'resourceName', 'resourceId', 'field'],
  components: {
    Viewer: tui_editor_vue3__WEBPACK_IMPORTED_MODULE_0__.Viewer
  },
  data: function data() {
    return {
      marginTop: null,
      darkMode: false,
      observer: null
    };
  },
  mounted: function mounted() {
    var _this = this;
    this.$nextTick(function () {
      return _this.marginTop = _this.grabMarginTop();
    });
    (0,_utils_novaDarkMode__WEBPACK_IMPORTED_MODULE_1__.resolveNovaDarkMode)(this, 'darkMode')();
    this.observer = (0,_utils_novaDarkMode__WEBPACK_IMPORTED_MODULE_1__.makeObserver)(this, 'darkMode', document.documentElement);
  },
  beforeUnmount: function beforeUnmount() {
    var _this$observer;
    (_this$observer = this.observer) === null || _this$observer === void 0 || _this$observer.disconnect();
  },
  methods: {
    grabMarginTop: function grabMarginTop() {
      var _this$$refs$viewer;
      var el = (_this$$refs$viewer = this.$refs.viewer) === null || _this$$refs$viewer === void 0 ? void 0 : _this$$refs$viewer.$el;
      if (!(el instanceof HTMLElement)) {
        return null;
      }
      var child = el.querySelector('.toastui-editor-contents > *');
      if (!(child instanceof HTMLElement)) {
        return null;
      }
      return '-' + window.getComputedStyle(child).getPropertyValue('margin-top');
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/components/FormField.vue?vue&type=script&lang=js":
/*!************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/components/FormField.vue?vue&type=script&lang=js ***!
  \************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var laravel_nova__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! laravel-nova */ "./vendor/laravel/nova/resources/js/mixins/packages.js");
/* harmony import */ var _utils_novaDarkMode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/novaDarkMode */ "./resources/utils/novaDarkMode.js");
/* harmony import */ var tui_editor_vue3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tui-editor-vue3 */ "./node_modules/tui-editor-vue3/dist/tui-editor-vue3.es.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  emits: ['field-changed'],
  mixins: [laravel_nova__WEBPACK_IMPORTED_MODULE_0__.HandlesValidationErrors, laravel_nova__WEBPACK_IMPORTED_MODULE_0__.HandlesFieldAttachments, laravel_nova__WEBPACK_IMPORTED_MODULE_0__.FormField],
  props: ['resourceName', 'resourceId', 'field'],
  data: function data() {
    return {
      value: '',
      fullScreen: false,
      darkMode: false,
      observer: null
    };
  },
  components: {
    Editor: tui_editor_vue3__WEBPACK_IMPORTED_MODULE_2__.Editor
  },
  mounted: function mounted() {
    console.log('[nova-tui-editor] Mounted');
    Nova.$on(this.fieldAttributeValueEventName, this.listenToValueChanges);
    (0,_utils_novaDarkMode__WEBPACK_IMPORTED_MODULE_1__.resolveNovaDarkMode)(this, 'darkMode')();
    this.observer = (0,_utils_novaDarkMode__WEBPACK_IMPORTED_MODULE_1__.makeObserver)(this, 'darkMode', document.documentElement);
  },
  beforeUnmount: function beforeUnmount() {
    var _this$observer;
    Nova.$off(this.fieldAttributeValueEventName, this.listenToValueChanges);
    this.clearAttachments();
    (_this$observer = this.observer) === null || _this$observer === void 0 || _this$observer.disconnect();
  },
  computed: {
    decodedFieldValue: function decodedFieldValue() {
      var _this$field$value;
      return this.decodeEntities((_this$field$value = this.field.value) !== null && _this$field$value !== void 0 ? _this$field$value : '');
    }
  },
  methods: {
    decodeEntities: function decodeEntities(value) {
      value = value.replace(/%7B/g, '{');
      value = value.replace(/%7D/g, '}');
      return value;
    },
    setInitialValue: function setInitialValue() {
      this.value = this.decodedFieldValue;
    },
    fill: function fill(formData) {
      this.fillIfVisible(formData, this.fieldAttribute, this.value || '');
      this.fillAttachmentDraftId(formData);
    },
    handleChange: function handleChange(value) {
      this.value = value;
    },
    handleFileAdded: function handleFileAdded(_ref) {
      var blob = _ref.blob,
        callback = _ref.callback;
      this.uploadAttachment(blob, {
        onCompleted: function onCompleted(path, url) {
          return callback(url);
        }
      });
    }
  }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/components/DetailField.vue?vue&type=template&id=70611348":
/*!******************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/components/DetailField.vue?vue&type=template&id=70611348 ***!
  \******************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);

function render(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_Viewer = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("Viewer");
  var _component_PanelItem = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("PanelItem");
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_PanelItem, {
    index: $props.index,
    field: $props.field
  }, {
    value: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(function () {
      return [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_Viewer, {
        ref: "viewer",
        style: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle)({
          marginTop: $data.marginTop
        }),
        "dark-mode": $data.darkMode,
        value: $props.field.value
      }, null, 8 /* PROPS */, ["style", "dark-mode", "value"])];
    }),
    _: 1 /* STABLE */
  }, 8 /* PROPS */, ["index", "field"]);
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/components/FormField.vue?vue&type=template&id=c97f7416":
/*!****************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/components/FormField.vue?vue&type=template&id=c97f7416 ***!
  \****************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* binding */ render)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);

function render(_ctx, _cache, $props, $setup, $data, $options) {
  var _component_Editor = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("Editor");
  var _component_DefaultField = (0,vue__WEBPACK_IMPORTED_MODULE_0__.resolveComponent)("DefaultField");
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(_component_DefaultField, {
    field: $props.field,
    errors: _ctx.errors,
    "full-width-content": _ctx.fullWidthContent,
    key: _ctx.index,
    "show-help-text": _ctx.showHelpText
  }, {
    field: (0,vue__WEBPACK_IMPORTED_MODULE_0__.withCtx)(function () {
      return [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(_component_Editor, (0,vue__WEBPACK_IMPORTED_MODULE_0__.mergeProps)({
        ref: "toastUiEditor",
        "model-value": $data.value,
        enhanced: $props.field.enhanced,
        "editor-classes": {
          'form-input form-input-bordered': !$data.fullScreen
        },
        "dark-mode": $data.darkMode
      }, $props.field.editor, {
        "onUpdate:modelValue": $options.handleChange,
        onAddImage: $options.handleFileAdded,
        onFullScreenChange: _cache[0] || (_cache[0] = function ($event) {
          return $data.fullScreen = $event;
        })
      }), null, 16 /* FULL_PROPS */, ["model-value", "enhanced", "editor-classes", "dark-mode", "onUpdate:modelValue", "onAddImage"])];
    }),
    _: 1 /* STABLE */
  }, 8 /* PROPS */, ["field", "errors", "full-width-content", "show-help-text"]);
}

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "./node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = __webpack_require__.g.TYPED_ARRAY_SUPPORT !== undefined
  ? __webpack_require__.g.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/***/ ((module) => {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "./node_modules/lodash/_DataView.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_DataView.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),

/***/ "./node_modules/lodash/_Hash.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_Hash.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hashClear = __webpack_require__(/*! ./_hashClear */ "./node_modules/lodash/_hashClear.js"),
    hashDelete = __webpack_require__(/*! ./_hashDelete */ "./node_modules/lodash/_hashDelete.js"),
    hashGet = __webpack_require__(/*! ./_hashGet */ "./node_modules/lodash/_hashGet.js"),
    hashHas = __webpack_require__(/*! ./_hashHas */ "./node_modules/lodash/_hashHas.js"),
    hashSet = __webpack_require__(/*! ./_hashSet */ "./node_modules/lodash/_hashSet.js");

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ "./node_modules/lodash/_ListCache.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_ListCache.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var listCacheClear = __webpack_require__(/*! ./_listCacheClear */ "./node_modules/lodash/_listCacheClear.js"),
    listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ "./node_modules/lodash/_listCacheDelete.js"),
    listCacheGet = __webpack_require__(/*! ./_listCacheGet */ "./node_modules/lodash/_listCacheGet.js"),
    listCacheHas = __webpack_require__(/*! ./_listCacheHas */ "./node_modules/lodash/_listCacheHas.js"),
    listCacheSet = __webpack_require__(/*! ./_listCacheSet */ "./node_modules/lodash/_listCacheSet.js");

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ "./node_modules/lodash/_Map.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Map.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ "./node_modules/lodash/_MapCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_MapCache.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ "./node_modules/lodash/_mapCacheClear.js"),
    mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ "./node_modules/lodash/_mapCacheDelete.js"),
    mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ "./node_modules/lodash/_mapCacheGet.js"),
    mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ "./node_modules/lodash/_mapCacheHas.js"),
    mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ "./node_modules/lodash/_mapCacheSet.js");

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ "./node_modules/lodash/_Promise.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_Promise.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),

/***/ "./node_modules/lodash/_Set.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Set.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),

/***/ "./node_modules/lodash/_SetCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_SetCache.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js"),
    setCacheAdd = __webpack_require__(/*! ./_setCacheAdd */ "./node_modules/lodash/_setCacheAdd.js"),
    setCacheHas = __webpack_require__(/*! ./_setCacheHas */ "./node_modules/lodash/_setCacheHas.js");

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),

/***/ "./node_modules/lodash/_Stack.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_Stack.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    stackClear = __webpack_require__(/*! ./_stackClear */ "./node_modules/lodash/_stackClear.js"),
    stackDelete = __webpack_require__(/*! ./_stackDelete */ "./node_modules/lodash/_stackDelete.js"),
    stackGet = __webpack_require__(/*! ./_stackGet */ "./node_modules/lodash/_stackGet.js"),
    stackHas = __webpack_require__(/*! ./_stackHas */ "./node_modules/lodash/_stackHas.js"),
    stackSet = __webpack_require__(/*! ./_stackSet */ "./node_modules/lodash/_stackSet.js");

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "./node_modules/lodash/_Uint8Array.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_Uint8Array.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),

/***/ "./node_modules/lodash/_WeakMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_WeakMap.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),

/***/ "./node_modules/lodash/_apply.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_apply.js ***!
  \***************************************/
/***/ ((module) => {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),

/***/ "./node_modules/lodash/_arrayFilter.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayFilter.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),

/***/ "./node_modules/lodash/_arrayLikeKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayLikeKeys.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTimes = __webpack_require__(/*! ./_baseTimes */ "./node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ "./node_modules/lodash/_arrayMap.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_arrayMap.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),

/***/ "./node_modules/lodash/_arrayPush.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayPush.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),

/***/ "./node_modules/lodash/_arraySome.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arraySome.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),

/***/ "./node_modules/lodash/_assignValue.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_assignValue.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),

/***/ "./node_modules/lodash/_assocIndexOf.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_assocIndexOf.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_baseAssignValue.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseAssignValue.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js");

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),

/***/ "./node_modules/lodash/_baseFlatten.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseFlatten.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    isFlattenable = __webpack_require__(/*! ./_isFlattenable */ "./node_modules/lodash/_isFlattenable.js");

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;


/***/ }),

/***/ "./node_modules/lodash/_baseFor.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseFor.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createBaseFor = __webpack_require__(/*! ./_createBaseFor */ "./node_modules/lodash/_createBaseFor.js");

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),

/***/ "./node_modules/lodash/_baseGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseGet.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),

/***/ "./node_modules/lodash/_baseGetAllKeys.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_baseGetAllKeys.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "./node_modules/lodash/_baseHasIn.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseHasIn.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),

/***/ "./node_modules/lodash/_baseIsArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsArguments.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ "./node_modules/lodash/_baseIsEqual.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsEqual.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqualDeep = __webpack_require__(/*! ./_baseIsEqualDeep */ "./node_modules/lodash/_baseIsEqualDeep.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),

/***/ "./node_modules/lodash/_baseIsEqualDeep.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsEqualDeep.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    equalByTag = __webpack_require__(/*! ./_equalByTag */ "./node_modules/lodash/_equalByTag.js"),
    equalObjects = __webpack_require__(/*! ./_equalObjects */ "./node_modules/lodash/_equalObjects.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),

/***/ "./node_modules/lodash/_baseIsMatch.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsMatch.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;


/***/ }),

/***/ "./node_modules/lodash/_baseIsNative.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIsNative.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isMasked = __webpack_require__(/*! ./_isMasked */ "./node_modules/lodash/_isMasked.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ "./node_modules/lodash/_baseIsTypedArray.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_baseIsTypedArray.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ "./node_modules/lodash/_baseIteratee.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIteratee.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseMatches = __webpack_require__(/*! ./_baseMatches */ "./node_modules/lodash/_baseMatches.js"),
    baseMatchesProperty = __webpack_require__(/*! ./_baseMatchesProperty */ "./node_modules/lodash/_baseMatchesProperty.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    property = __webpack_require__(/*! ./property */ "./node_modules/lodash/property.js");

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;


/***/ }),

/***/ "./node_modules/lodash/_baseKeys.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseKeys.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ "./node_modules/lodash/_nativeKeys.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),

/***/ "./node_modules/lodash/_baseKeysIn.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseKeysIn.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeysIn = __webpack_require__(/*! ./_nativeKeysIn */ "./node_modules/lodash/_nativeKeysIn.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_baseMatches.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseMatches.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMatch = __webpack_require__(/*! ./_baseIsMatch */ "./node_modules/lodash/_baseIsMatch.js"),
    getMatchData = __webpack_require__(/*! ./_getMatchData */ "./node_modules/lodash/_getMatchData.js"),
    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js");

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;


/***/ }),

/***/ "./node_modules/lodash/_baseMatchesProperty.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash/_baseMatchesProperty.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js"),
    get = __webpack_require__(/*! ./get */ "./node_modules/lodash/get.js"),
    hasIn = __webpack_require__(/*! ./hasIn */ "./node_modules/lodash/hasIn.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"),
    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;


/***/ }),

/***/ "./node_modules/lodash/_basePick.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_basePick.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var basePickBy = __webpack_require__(/*! ./_basePickBy */ "./node_modules/lodash/_basePickBy.js"),
    hasIn = __webpack_require__(/*! ./hasIn */ "./node_modules/lodash/hasIn.js");

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;


/***/ }),

/***/ "./node_modules/lodash/_basePickBy.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_basePickBy.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js"),
    baseSet = __webpack_require__(/*! ./_baseSet */ "./node_modules/lodash/_baseSet.js"),
    castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js");

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

module.exports = basePickBy;


/***/ }),

/***/ "./node_modules/lodash/_baseProperty.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseProperty.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;


/***/ }),

/***/ "./node_modules/lodash/_basePropertyDeep.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_basePropertyDeep.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js");

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;


/***/ }),

/***/ "./node_modules/lodash/_baseSet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseSet.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;


/***/ }),

/***/ "./node_modules/lodash/_baseSetToString.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseSetToString.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var constant = __webpack_require__(/*! ./constant */ "./node_modules/lodash/constant.js"),
    defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),

/***/ "./node_modules/lodash/_baseTimes.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseTimes.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ "./node_modules/lodash/_baseToString.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseToString.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),

/***/ "./node_modules/lodash/_baseTrim.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseTrim.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var trimmedEndIndex = __webpack_require__(/*! ./_trimmedEndIndex */ "./node_modules/lodash/_trimmedEndIndex.js");

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

module.exports = baseTrim;


/***/ }),

/***/ "./node_modules/lodash/_baseUnary.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnary.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ "./node_modules/lodash/_cacheHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_cacheHas.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),

/***/ "./node_modules/lodash/_castFunction.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_castFunction.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;


/***/ }),

/***/ "./node_modules/lodash/_castPath.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_castPath.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    stringToPath = __webpack_require__(/*! ./_stringToPath */ "./node_modules/lodash/_stringToPath.js"),
    toString = __webpack_require__(/*! ./toString */ "./node_modules/lodash/toString.js");

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),

/***/ "./node_modules/lodash/_coreJsData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_coreJsData.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ "./node_modules/lodash/_createBaseFor.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_createBaseFor.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),

/***/ "./node_modules/lodash/_defineProperty.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_defineProperty.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),

/***/ "./node_modules/lodash/_equalArrays.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_equalArrays.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SetCache = __webpack_require__(/*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"),
    arraySome = __webpack_require__(/*! ./_arraySome */ "./node_modules/lodash/_arraySome.js"),
    cacheHas = __webpack_require__(/*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),

/***/ "./node_modules/lodash/_equalByTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_equalByTag.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    mapToArray = __webpack_require__(/*! ./_mapToArray */ "./node_modules/lodash/_mapToArray.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),

/***/ "./node_modules/lodash/_equalObjects.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_equalObjects.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),

/***/ "./node_modules/lodash/_flatRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_flatRest.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var flatten = __webpack_require__(/*! ./flatten */ "./node_modules/lodash/flatten.js"),
    overRest = __webpack_require__(/*! ./_overRest */ "./node_modules/lodash/_overRest.js"),
    setToString = __webpack_require__(/*! ./_setToString */ "./node_modules/lodash/_setToString.js");

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;


/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

module.exports = freeGlobal;


/***/ }),

/***/ "./node_modules/lodash/_getAllKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getAllKeys.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),

/***/ "./node_modules/lodash/_getAllKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getAllKeysIn.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_getMapData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getMapData.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isKeyable = __webpack_require__(/*! ./_isKeyable */ "./node_modules/lodash/_isKeyable.js");

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ "./node_modules/lodash/_getMatchData.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getMatchData.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;


/***/ }),

/***/ "./node_modules/lodash/_getNative.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getNative.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ "./node_modules/lodash/_baseIsNative.js"),
    getValue = __webpack_require__(/*! ./_getValue */ "./node_modules/lodash/_getValue.js");

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ "./node_modules/lodash/_getPrototype.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getPrototype.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "./node_modules/lodash/_getSymbols.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getSymbols.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "./node_modules/lodash/_arrayFilter.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),

/***/ "./node_modules/lodash/_getSymbolsIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getSymbolsIn.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),

/***/ "./node_modules/lodash/_getTag.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_getTag.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DataView = __webpack_require__(/*! ./_DataView */ "./node_modules/lodash/_DataView.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    Promise = __webpack_require__(/*! ./_Promise */ "./node_modules/lodash/_Promise.js"),
    Set = __webpack_require__(/*! ./_Set */ "./node_modules/lodash/_Set.js"),
    WeakMap = __webpack_require__(/*! ./_WeakMap */ "./node_modules/lodash/_WeakMap.js"),
    baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),

/***/ "./node_modules/lodash/_getValue.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_getValue.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ "./node_modules/lodash/_hasPath.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hasPath.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),

/***/ "./node_modules/lodash/_hashClear.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_hashClear.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ "./node_modules/lodash/_hashDelete.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_hashDelete.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ "./node_modules/lodash/_hashGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashGet.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ "./node_modules/lodash/_hashHas.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashHas.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ "./node_modules/lodash/_hashSet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashSet.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ "./node_modules/lodash/_isFlattenable.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_isFlattenable.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;


/***/ }),

/***/ "./node_modules/lodash/_isIndex.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_isIndex.js ***!
  \*****************************************/
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ "./node_modules/lodash/_isKey.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_isKey.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),

/***/ "./node_modules/lodash/_isKeyable.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_isKeyable.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ "./node_modules/lodash/_isMasked.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_isMasked.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var coreJsData = __webpack_require__(/*! ./_coreJsData */ "./node_modules/lodash/_coreJsData.js");

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ "./node_modules/lodash/_isPrototype.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_isPrototype.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ "./node_modules/lodash/_isStrictComparable.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash/_isStrictComparable.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;


/***/ }),

/***/ "./node_modules/lodash/_listCacheClear.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_listCacheClear.js ***!
  \************************************************/
/***/ ((module) => {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_listCacheDelete.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_listCacheDelete.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_listCacheGet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheGet.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_listCacheHas.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheHas.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_listCacheSet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheSet.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheClear.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_mapCacheClear.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Hash = __webpack_require__(/*! ./_Hash */ "./node_modules/lodash/_Hash.js"),
    ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js");

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheDelete.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_mapCacheDelete.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheGet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheGet.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheHas.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheSet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheSet.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_mapToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_mapToArray.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),

/***/ "./node_modules/lodash/_matchesStrictComparable.js":
/*!*********************************************************!*\
  !*** ./node_modules/lodash/_matchesStrictComparable.js ***!
  \*********************************************************/
/***/ ((module) => {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;


/***/ }),

/***/ "./node_modules/lodash/_memoizeCapped.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_memoizeCapped.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoize = __webpack_require__(/*! ./memoize */ "./node_modules/lodash/memoize.js");

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),

/***/ "./node_modules/lodash/_nativeCreate.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeCreate.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ "./node_modules/lodash/_nativeKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_nativeKeys.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ "./node_modules/lodash/_nativeKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeKeysIn.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_nodeUtil.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_nodeUtil.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;


/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "./node_modules/lodash/_overArg.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ "./node_modules/lodash/_overRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_overRest.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var apply = __webpack_require__(/*! ./_apply */ "./node_modules/lodash/_apply.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "./node_modules/lodash/_setCacheAdd.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheAdd.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),

/***/ "./node_modules/lodash/_setCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheHas.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_setToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_setToArray.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),

/***/ "./node_modules/lodash/_setToString.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setToString.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseSetToString = __webpack_require__(/*! ./_baseSetToString */ "./node_modules/lodash/_baseSetToString.js"),
    shortOut = __webpack_require__(/*! ./_shortOut */ "./node_modules/lodash/_shortOut.js");

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),

/***/ "./node_modules/lodash/_shortOut.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_shortOut.js ***!
  \******************************************/
/***/ ((module) => {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),

/***/ "./node_modules/lodash/_stackClear.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_stackClear.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js");

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),

/***/ "./node_modules/lodash/_stackDelete.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_stackDelete.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),

/***/ "./node_modules/lodash/_stackGet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackGet.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),

/***/ "./node_modules/lodash/_stackHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackHas.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),

/***/ "./node_modules/lodash/_stackSet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackSet.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),

/***/ "./node_modules/lodash/_stringToPath.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_stringToPath.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoizeCapped = __webpack_require__(/*! ./_memoizeCapped */ "./node_modules/lodash/_memoizeCapped.js");

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),

/***/ "./node_modules/lodash/_toKey.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_toKey.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),

/***/ "./node_modules/lodash/_toSource.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_toSource.js ***!
  \******************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ "./node_modules/lodash/_trimmedEndIndex.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_trimmedEndIndex.js ***!
  \*************************************************/
/***/ ((module) => {

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

module.exports = trimmedEndIndex;


/***/ }),

/***/ "./node_modules/lodash/constant.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/constant.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),

/***/ "./node_modules/lodash/debounce.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/debounce.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    now = __webpack_require__(/*! ./now */ "./node_modules/lodash/now.js"),
    toNumber = __webpack_require__(/*! ./toNumber */ "./node_modules/lodash/toNumber.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;


/***/ }),

/***/ "./node_modules/lodash/eq.js":
/*!***********************************!*\
  !*** ./node_modules/lodash/eq.js ***!
  \***********************************/
/***/ ((module) => {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ "./node_modules/lodash/flatten.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/flatten.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFlatten = __webpack_require__(/*! ./_baseFlatten */ "./node_modules/lodash/_baseFlatten.js");

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;


/***/ }),

/***/ "./node_modules/lodash/forIn.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/forIn.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFor = __webpack_require__(/*! ./_baseFor */ "./node_modules/lodash/_baseFor.js"),
    castFunction = __webpack_require__(/*! ./_castFunction */ "./node_modules/lodash/_castFunction.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * Iterates over own and inherited enumerable string keyed properties of an
 * object and invokes `iteratee` for each property. The iteratee is invoked
 * with three arguments: (value, key, object). Iteratee functions may exit
 * iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 0.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forInRight
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forIn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
 */
function forIn(object, iteratee) {
  return object == null
    ? object
    : baseFor(object, castFunction(iteratee), keysIn);
}

module.exports = forIn;


/***/ }),

/***/ "./node_modules/lodash/get.js":
/*!************************************!*\
  !*** ./node_modules/lodash/get.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js");

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),

/***/ "./node_modules/lodash/hasIn.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/hasIn.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseHasIn = __webpack_require__(/*! ./_baseHasIn */ "./node_modules/lodash/_baseHasIn.js"),
    hasPath = __webpack_require__(/*! ./_hasPath */ "./node_modules/lodash/_hasPath.js");

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),

/***/ "./node_modules/lodash/identity.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/identity.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "./node_modules/lodash/isArguments.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArguments.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "./node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ "./node_modules/lodash/isArray.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ "./node_modules/lodash/isArrayLike.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArrayLike.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js");

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ "./node_modules/lodash/isBuffer.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isBuffer.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__(/*! ./stubFalse */ "./node_modules/lodash/stubFalse.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;


/***/ }),

/***/ "./node_modules/lodash/isEmpty.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isEmpty.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) &&
      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

module.exports = isEmpty;


/***/ }),

/***/ "./node_modules/lodash/isFunction.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/isFunction.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ "./node_modules/lodash/isLength.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "./node_modules/lodash/isSymbol.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isSymbol.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),

/***/ "./node_modules/lodash/isTypedArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "./node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ "./node_modules/lodash/keys.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/keys.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),

/***/ "./node_modules/lodash/keysIn.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/keysIn.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeysIn = __webpack_require__(/*! ./_baseKeysIn */ "./node_modules/lodash/_baseKeysIn.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),

/***/ "./node_modules/lodash/memoize.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/memoize.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),

/***/ "./node_modules/lodash/now.js":
/*!************************************!*\
  !*** ./node_modules/lodash/now.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;


/***/ }),

/***/ "./node_modules/lodash/pick.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/pick.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var basePick = __webpack_require__(/*! ./_basePick */ "./node_modules/lodash/_basePick.js"),
    flatRest = __webpack_require__(/*! ./_flatRest */ "./node_modules/lodash/_flatRest.js");

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

module.exports = pick;


/***/ }),

/***/ "./node_modules/lodash/pickBy.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/pickBy.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    basePickBy = __webpack_require__(/*! ./_basePickBy */ "./node_modules/lodash/_basePickBy.js"),
    getAllKeysIn = __webpack_require__(/*! ./_getAllKeysIn */ "./node_modules/lodash/_getAllKeysIn.js");

/**
 * Creates an object composed of the `object` properties `predicate` returns
 * truthy for. The predicate is invoked with two arguments: (value, key).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The source object.
 * @param {Function} [predicate=_.identity] The function invoked per property.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pickBy(object, _.isNumber);
 * // => { 'a': 1, 'c': 3 }
 */
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = arrayMap(getAllKeysIn(object), function(prop) {
    return [prop];
  });
  predicate = baseIteratee(predicate);
  return basePickBy(object, props, function(value, path) {
    return predicate(value, path[0]);
  });
}

module.exports = pickBy;


/***/ }),

/***/ "./node_modules/lodash/property.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/property.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseProperty = __webpack_require__(/*! ./_baseProperty */ "./node_modules/lodash/_baseProperty.js"),
    basePropertyDeep = __webpack_require__(/*! ./_basePropertyDeep */ "./node_modules/lodash/_basePropertyDeep.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;


/***/ }),

/***/ "./node_modules/lodash/stubArray.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubArray.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ "./node_modules/lodash/stubFalse.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubFalse.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "./node_modules/lodash/toNumber.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toNumber.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTrim = __webpack_require__(/*! ./_baseTrim */ "./node_modules/lodash/_baseTrim.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),

/***/ "./node_modules/lodash/toString.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toString.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseToString = __webpack_require__(/*! ./_baseToString */ "./node_modules/lodash/_baseToString.js");

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/tui-editor-vue3/dist/tui-editor-vue3.es.js":
/*!*****************************************************************!*\
  !*** ./node_modules/tui-editor-vue3/dist/tui-editor-vue3.es.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Editor: () => (/* binding */ bGe),
/* harmony export */   Viewer: () => (/* binding */ MGe),
/* harmony export */   "default": () => (/* binding */ PGe)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");
/* provided dependency */ var process = __webpack_require__(/*! process/browser.js */ "./node_modules/process/browser.js");

function Ci(i) {
  this.content = i;
}
Ci.prototype = {
  constructor: Ci,
  find: function(i) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === i) return e;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(i) {
    var e = this.find(i);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(i, e, r) {
    var s = r && r != i ? this.remove(r) : this, l = s.find(i), c = s.content.slice();
    return l == -1 ? c.push(r || i, e) : (c[l + 1] = e, r && (c[l] = r)), new Ci(c);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(i) {
    var e = this.find(i);
    if (e == -1) return this;
    var r = this.content.slice();
    return r.splice(e, 2), new Ci(r);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(i, e) {
    return new Ci([i, e].concat(this.remove(i).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(i, e) {
    var r = this.remove(i).content.slice();
    return r.push(i, e), new Ci(r);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(i, e, r) {
    var s = this.remove(e), l = s.content.slice(), c = s.find(i);
    return l.splice(c == -1 ? l.length : c, 0, e, r), new Ci(l);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(i) {
    for (var e = 0; e < this.content.length; e += 2)
      i(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(i) {
    return i = Ci.from(i), i.size ? new Ci(i.content.concat(this.subtract(i).content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(i) {
    return i = Ci.from(i), i.size ? new Ci(this.subtract(i).content.concat(i.content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(i) {
    var e = this;
    i = Ci.from(i);
    for (var r = 0; r < i.content.length; r += 2)
      e = e.remove(i.content[r]);
    return e;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var i = {};
    return this.forEach(function(e, r) {
      i[e] = r;
    }), i;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
Ci.from = function(i) {
  if (i instanceof Ci) return i;
  var e = [];
  if (i) for (var r in i) e.push(r, i[r]);
  return new Ci(e);
};
function MV(i, e, r) {
  for (let s = 0; ; s++) {
    if (s == i.childCount || s == e.childCount)
      return i.childCount == e.childCount ? null : r;
    let l = i.child(s), c = e.child(s);
    if (l == c) {
      r += l.nodeSize;
      continue;
    }
    if (!l.sameMarkup(c))
      return r;
    if (l.isText && l.text != c.text) {
      for (let f = 0; l.text[f] == c.text[f]; f++)
        r++;
      return r;
    }
    if (l.content.size || c.content.size) {
      let f = MV(l.content, c.content, r + 1);
      if (f != null)
        return f;
    }
    r += l.nodeSize;
  }
}
function RV(i, e, r, s) {
  for (let l = i.childCount, c = e.childCount; ; ) {
    if (l == 0 || c == 0)
      return l == c ? null : { a: r, b: s };
    let f = i.child(--l), p = e.child(--c), d = f.nodeSize;
    if (f == p) {
      r -= d, s -= d;
      continue;
    }
    if (!f.sameMarkup(p))
      return { a: r, b: s };
    if (f.isText && f.text != p.text) {
      let m = 0, y = Math.min(f.text.length, p.text.length);
      for (; m < y && f.text[f.text.length - m - 1] == p.text[p.text.length - m - 1]; )
        m++, r--, s--;
      return { a: r, b: s };
    }
    if (f.content.size || p.content.size) {
      let m = RV(f.content, p.content, r - 1, s - 1);
      if (m)
        return m;
    }
    r -= d, s -= d;
  }
}
class qt {
  /**
  @internal
  */
  constructor(e, r) {
    if (this.content = e, this.size = r || 0, r == null)
      for (let s = 0; s < e.length; s++)
        this.size += e[s].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, r, s, l = 0, c) {
    for (let f = 0, p = 0; p < r; f++) {
      let d = this.content[f], m = p + d.nodeSize;
      if (m > e && s(d, l + p, c || null, f) !== !1 && d.content.size) {
        let y = p + 1;
        d.nodesBetween(Math.max(0, e - y), Math.min(d.content.size, r - y), s, l + y);
      }
      p = m;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, r, s, l) {
    let c = "", f = !0;
    return this.nodesBetween(e, r, (p, d) => {
      p.isText ? (c += p.text.slice(Math.max(e, d) - d, r - d), f = !s) : p.isLeaf ? (l ? c += typeof l == "function" ? l(p) : l : p.type.spec.leafText && (c += p.type.spec.leafText(p)), f = !s) : !f && p.isBlock && (c += s, f = !0);
    }, 0), c;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let r = this.lastChild, s = e.firstChild, l = this.content.slice(), c = 0;
    for (r.isText && r.sameMarkup(s) && (l[l.length - 1] = r.withText(r.text + s.text), c = 1); c < e.content.length; c++)
      l.push(e.content[c]);
    return new qt(l, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, r = this.size) {
    if (e == 0 && r == this.size)
      return this;
    let s = [], l = 0;
    if (r > e)
      for (let c = 0, f = 0; f < r; c++) {
        let p = this.content[c], d = f + p.nodeSize;
        d > e && ((f < e || d > r) && (p.isText ? p = p.cut(Math.max(0, e - f), Math.min(p.text.length, r - f)) : p = p.cut(Math.max(0, e - f - 1), Math.min(p.content.size, r - f - 1))), s.push(p), l += p.nodeSize), f = d;
      }
    return new qt(s, l);
  }
  /**
  @internal
  */
  cutByIndex(e, r) {
    return e == r ? qt.empty : e == 0 && r == this.content.length ? this : new qt(this.content.slice(e, r));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, r) {
    let s = this.content[e];
    if (s == r)
      return this;
    let l = this.content.slice(), c = this.size + r.nodeSize - s.nodeSize;
    return l[e] = r, new qt(l, c);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new qt([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new qt(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let r = 0; r < this.content.length; r++)
      if (!this.content[r].eq(e.content[r]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let r = this.content[e];
    if (!r)
      throw new RangeError("Index " + e + " out of range for " + this);
    return r;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let r = 0, s = 0; r < this.content.length; r++) {
      let l = this.content[r];
      e(l, s, r), s += l.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, r = 0) {
    return MV(this, e, r);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, r = this.size, s = e.size) {
    return RV(this, e, r, s);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. (Not public.)
  */
  findIndex(e, r = -1) {
    if (e == 0)
      return Iw(0, e);
    if (e == this.size)
      return Iw(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let s = 0, l = 0; ; s++) {
      let c = this.child(s), f = l + c.nodeSize;
      if (f >= e)
        return f == e || r > 0 ? Iw(s + 1, f) : Iw(s, l);
      l = f;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, r) {
    if (!r)
      return qt.empty;
    if (!Array.isArray(r))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new qt(r.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return qt.empty;
    let r, s = 0;
    for (let l = 0; l < e.length; l++) {
      let c = e[l];
      s += c.nodeSize, l && c.isText && e[l - 1].sameMarkup(c) ? (r || (r = e.slice(0, l)), r[r.length - 1] = c.withText(r[r.length - 1].text + c.text)) : r && r.push(c);
    }
    return new qt(r || e, s);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return qt.empty;
    if (e instanceof qt)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new qt([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
qt.empty = new qt([], 0);
const NH = { index: 0, offset: 0 };
function Iw(i, e) {
  return NH.index = i, NH.offset = e, NH;
}
function nx(i, e) {
  if (i === e)
    return !0;
  if (!(i && typeof i == "object") || !(e && typeof e == "object"))
    return !1;
  let r = Array.isArray(i);
  if (Array.isArray(e) != r)
    return !1;
  if (r) {
    if (i.length != e.length)
      return !1;
    for (let s = 0; s < i.length; s++)
      if (!nx(i[s], e[s]))
        return !1;
  } else {
    for (let s in i)
      if (!(s in e) || !nx(i[s], e[s]))
        return !1;
    for (let s in e)
      if (!(s in i))
        return !1;
  }
  return !0;
}
let Qr = class Hj {
  /**
  @internal
  */
  constructor(e, r) {
    this.type = e, this.attrs = r;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let r, s = !1;
    for (let l = 0; l < e.length; l++) {
      let c = e[l];
      if (this.eq(c))
        return e;
      if (this.type.excludes(c.type))
        r || (r = e.slice(0, l));
      else {
        if (c.type.excludes(this.type))
          return e;
        !s && c.type.rank > this.type.rank && (r || (r = e.slice(0, l)), r.push(this), s = !0), r && r.push(c);
      }
    }
    return r || (r = e.slice()), s || r.push(this), r;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let r = 0; r < e.length; r++)
      if (this.eq(e[r]))
        return e.slice(0, r).concat(e.slice(r + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let r = 0; r < e.length; r++)
      if (this.eq(e[r]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && nx(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let r in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, r) {
    if (!r)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let s = e.marks[r.type];
    if (!s)
      throw new RangeError(`There is no mark type ${r.type} in this schema`);
    return s.create(r.attrs);
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, r) {
    if (e == r)
      return !0;
    if (e.length != r.length)
      return !1;
    for (let s = 0; s < e.length; s++)
      if (!e[s].eq(r[s]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return Hj.none;
    if (e instanceof Hj)
      return [e];
    let r = e.slice();
    return r.sort((s, l) => s.type.rank - l.type.rank), r;
  }
};
Qr.none = [];
class ix extends Error {
}
class ur {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, r, s) {
    this.content = e, this.openStart = r, this.openEnd = s;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, r) {
    let s = PV(this.content, e + this.openStart, r);
    return s && new ur(s, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, r) {
    return new ur(DV(this.content, e + this.openStart, r + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, r) {
    if (!r)
      return ur.empty;
    let s = r.openStart || 0, l = r.openEnd || 0;
    if (typeof s != "number" || typeof l != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new ur(qt.fromJSON(e, r.content), s, l);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, r = !0) {
    let s = 0, l = 0;
    for (let c = e.firstChild; c && !c.isLeaf && (r || !c.type.spec.isolating); c = c.firstChild)
      s++;
    for (let c = e.lastChild; c && !c.isLeaf && (r || !c.type.spec.isolating); c = c.lastChild)
      l++;
    return new ur(e, s, l);
  }
}
ur.empty = new ur(qt.empty, 0, 0);
function DV(i, e, r) {
  let { index: s, offset: l } = i.findIndex(e), c = i.maybeChild(s), { index: f, offset: p } = i.findIndex(r);
  if (l == e || c.isText) {
    if (p != r && !i.child(f).isText)
      throw new RangeError("Removing non-flat range");
    return i.cut(0, e).append(i.cut(r));
  }
  if (s != f)
    throw new RangeError("Removing non-flat range");
  return i.replaceChild(s, c.copy(DV(c.content, e - l - 1, r - l - 1)));
}
function PV(i, e, r, s) {
  let { index: l, offset: c } = i.findIndex(e), f = i.maybeChild(l);
  if (c == e || f.isText)
    return i.cut(0, e).append(r).append(i.cut(e));
  let p = PV(f.content, e - c - 1, r);
  return p && i.replaceChild(l, f.copy(p));
}
function gQ(i, e, r) {
  if (r.openStart > i.depth)
    throw new ix("Inserted content deeper than insertion position");
  if (i.depth - r.openStart != e.depth - r.openEnd)
    throw new ix("Inconsistent open depths");
  return LV(i, e, r, 0);
}
function LV(i, e, r, s) {
  let l = i.index(s), c = i.node(s);
  if (l == e.index(s) && s < i.depth - r.openStart) {
    let f = LV(i, e, r, s + 1);
    return c.copy(c.content.replaceChild(l, f));
  } else if (r.content.size)
    if (!r.openStart && !r.openEnd && i.depth == s && e.depth == s) {
      let f = i.parent, p = f.content;
      return Ic(f, p.cut(0, i.parentOffset).append(r.content).append(p.cut(e.parentOffset)));
    } else {
      let { start: f, end: p } = yQ(r, i);
      return Ic(c, _V(i, f, p, e, s));
    }
  else return Ic(c, ax(i, e, s));
}
function IV(i, e) {
  if (!e.type.compatibleContent(i.type))
    throw new ix("Cannot join " + e.type.name + " onto " + i.type.name);
}
function jj(i, e, r) {
  let s = i.node(r);
  return IV(s, e.node(r)), s;
}
function Lc(i, e) {
  let r = e.length - 1;
  r >= 0 && i.isText && i.sameMarkup(e[r]) ? e[r] = i.withText(e[r].text + i.text) : e.push(i);
}
function $g(i, e, r, s) {
  let l = (e || i).node(r), c = 0, f = e ? e.index(r) : l.childCount;
  i && (c = i.index(r), i.depth > r ? c++ : i.textOffset && (Lc(i.nodeAfter, s), c++));
  for (let p = c; p < f; p++)
    Lc(l.child(p), s);
  e && e.depth == r && e.textOffset && Lc(e.nodeBefore, s);
}
function Ic(i, e) {
  return i.type.checkContent(e), i.copy(e);
}
function _V(i, e, r, s, l) {
  let c = i.depth > l && jj(i, e, l + 1), f = s.depth > l && jj(r, s, l + 1), p = [];
  return $g(null, i, l, p), c && f && e.index(l) == r.index(l) ? (IV(c, f), Lc(Ic(c, _V(i, e, r, s, l + 1)), p)) : (c && Lc(Ic(c, ax(i, e, l + 1)), p), $g(e, r, l, p), f && Lc(Ic(f, ax(r, s, l + 1)), p)), $g(s, null, l, p), new qt(p);
}
function ax(i, e, r) {
  let s = [];
  if ($g(null, i, r, s), i.depth > r) {
    let l = jj(i, e, r + 1);
    Lc(Ic(l, ax(i, e, r + 1)), s);
  }
  return $g(e, null, r, s), new qt(s);
}
function yQ(i, e) {
  let r = e.depth - i.openStart, l = e.node(r).copy(i.content);
  for (let c = r - 1; c >= 0; c--)
    l = e.node(c).copy(qt.from(l));
  return {
    start: l.resolveNoCache(i.openStart + r),
    end: l.resolveNoCache(l.content.size - i.openEnd - r)
  };
}
class qg {
  /**
  @internal
  */
  constructor(e, r, s) {
    this.pos = e, this.path = r, this.parentOffset = s, this.depth = r.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, r = this.index(this.depth);
    if (r == e.childCount)
      return null;
    let s = this.pos - this.path[this.path.length - 1], l = e.child(r);
    return s ? e.child(r).cut(s) : l;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), r = this.pos - this.path[this.path.length - 1];
    return r ? this.parent.child(e).cut(0, r) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, r) {
    r = this.resolveDepth(r);
    let s = this.path[r * 3], l = r == 0 ? 0 : this.path[r * 3 - 1] + 1;
    for (let c = 0; c < e; c++)
      l += s.child(c).nodeSize;
    return l;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, r = this.index();
    if (e.content.size == 0)
      return Qr.none;
    if (this.textOffset)
      return e.child(r).marks;
    let s = e.maybeChild(r - 1), l = e.maybeChild(r);
    if (!s) {
      let p = s;
      s = l, l = p;
    }
    let c = s.marks;
    for (var f = 0; f < c.length; f++)
      c[f].type.spec.inclusive === !1 && (!l || !c[f].isInSet(l.marks)) && (c = c[f--].removeFromSet(c));
    return c;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let r = this.parent.maybeChild(this.index());
    if (!r || !r.isInline)
      return null;
    let s = r.marks, l = e.parent.maybeChild(e.index());
    for (var c = 0; c < s.length; c++)
      s[c].type.spec.inclusive === !1 && (!l || !s[c].isInSet(l.marks)) && (s = s[c--].removeFromSet(s));
    return s;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let r = this.depth; r > 0; r--)
      if (this.start(r) <= e && this.end(r) >= e)
        return r;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, r) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let s = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); s >= 0; s--)
      if (e.pos <= this.end(s) && (!r || r(this.node(s))))
        return new ox(this, e, s);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let r = 1; r <= this.depth; r++)
      e += (e ? "/" : "") + this.node(r).type.name + "_" + this.index(r - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, r) {
    if (!(r >= 0 && r <= e.content.size))
      throw new RangeError("Position " + r + " out of range");
    let s = [], l = 0, c = r;
    for (let f = e; ; ) {
      let { index: p, offset: d } = f.content.findIndex(c), m = c - d;
      if (s.push(f, p, l + d), !m || (f = f.child(p), f.isText))
        break;
      c = m - 1, l += d + 1;
    }
    return new qg(r, s, c);
  }
  /**
  @internal
  */
  static resolveCached(e, r) {
    for (let l = 0; l < BH.length; l++) {
      let c = BH[l];
      if (c.pos == r && c.doc == e)
        return c;
    }
    let s = BH[FH] = qg.resolve(e, r);
    return FH = (FH + 1) % bQ, s;
  }
}
let BH = [], FH = 0, bQ = 12;
class ox {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, r, s) {
    this.$from = e, this.$to = r, this.depth = s;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const SQ = /* @__PURE__ */ Object.create(null);
let Au = class Wj {
  /**
  @internal
  */
  constructor(e, r, s, l = Qr.none) {
    this.type = e, this.attrs = r, this.marks = l, this.content = s || qt.empty;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, r, s, l = 0) {
    this.content.nodesBetween(e, r, s, l, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(e, r, s, l) {
    return this.content.textBetween(e, r, s, l);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, r, s) {
    return this.type == e && nx(this.attrs, r || e.defaultAttrs || SQ) && Qr.sameSet(this.marks, s || Qr.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new Wj(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new Wj(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, r = this.content.size) {
    return e == 0 && r == this.content.size ? this : this.copy(this.content.cut(e, r));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, r = this.content.size, s = !1) {
    if (e == r)
      return ur.empty;
    let l = this.resolve(e), c = this.resolve(r), f = s ? 0 : l.sharedDepth(r), p = l.start(f), m = l.node(f).content.cut(l.pos - p, c.pos - p);
    return new ur(m, l.depth - f, c.depth - f);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, r, s) {
    return gQ(this.resolve(e), this.resolve(r), s);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let r = this; ; ) {
      let { index: s, offset: l } = r.content.findIndex(e);
      if (r = r.maybeChild(s), !r)
        return null;
      if (l == e || r.isText)
        return r;
      e -= l + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: r, offset: s } = this.content.findIndex(e);
    return { node: this.content.maybeChild(r), index: r, offset: s };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: r, offset: s } = this.content.findIndex(e);
    if (s < e)
      return { node: this.content.child(r), index: r, offset: s };
    let l = this.content.child(r - 1);
    return { node: l, index: r - 1, offset: s - l.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return qg.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return qg.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, r, s) {
    let l = !1;
    return r > e && this.nodesBetween(e, r, (c) => (s.isInSet(c.marks) && (l = !0), !l)), l;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), NV(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let r = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!r)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return r;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, r, s = qt.empty, l = 0, c = s.childCount) {
    let f = this.contentMatchAt(e).matchFragment(s, l, c), p = f && f.matchFragment(this.content, r);
    if (!p || !p.validEnd)
      return !1;
    for (let d = l; d < c; d++)
      if (!this.type.allowsMarks(s.child(d).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, r, s, l) {
    if (l && !this.type.allowsMarks(l))
      return !1;
    let c = this.contentMatchAt(e).matchType(s), f = c && c.matchFragment(this.content, r);
    return f ? f.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise error when they do not.
  */
  check() {
    this.type.checkContent(this.content);
    let e = Qr.none;
    for (let r = 0; r < this.marks.length; r++)
      e = this.marks[r].addToSet(e);
    if (!Qr.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((r) => r.type.name)}`);
    this.content.forEach((r) => r.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let r in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((r) => r.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, r) {
    if (!r)
      throw new RangeError("Invalid input for Node.fromJSON");
    let s = null;
    if (r.marks) {
      if (!Array.isArray(r.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      s = r.marks.map(e.markFromJSON);
    }
    if (r.type == "text") {
      if (typeof r.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(r.text, s);
    }
    let l = qt.fromJSON(e, r.content);
    return e.nodeType(r.type).create(r.attrs, l, s);
  }
};
Au.prototype.text = void 0;
class sx extends Au {
  /**
  @internal
  */
  constructor(e, r, s, l) {
    if (super(e, r, null, l), !s)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = s;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : NV(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, r) {
    return this.text.slice(e, r);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new sx(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new sx(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, r = this.text.length) {
    return e == 0 && r == this.text.length ? this : this.withText(this.text.slice(e, r));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
}
function NV(i, e) {
  for (let r = i.length - 1; r >= 0; r--)
    e = i[r].type.name + "(" + e + ")";
  return e;
}
class Fc {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, r) {
    let s = new wQ(e, r);
    if (s.next == null)
      return Fc.empty;
    let l = BV(s);
    s.next && s.err("Unexpected trailing text");
    let c = EQ(AQ(l));
    return MQ(c, s), c;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let r = 0; r < this.next.length; r++)
      if (this.next[r].type == e)
        return this.next[r].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, r = 0, s = e.childCount) {
    let l = this;
    for (let c = r; l && c < s; c++)
      l = l.matchType(e.child(c).type);
    return l;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: r } = this.next[e];
      if (!(r.isText || r.hasRequiredAttrs()))
        return r;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let r = 0; r < this.next.length; r++)
      for (let s = 0; s < e.next.length; s++)
        if (this.next[r].type == e.next[s].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, r = !1, s = 0) {
    let l = [this];
    function c(f, p) {
      let d = f.matchFragment(e, s);
      if (d && (!r || d.validEnd))
        return qt.from(p.map((m) => m.createAndFill()));
      for (let m = 0; m < f.next.length; m++) {
        let { type: y, next: S } = f.next[m];
        if (!(y.isText || y.hasRequiredAttrs()) && l.indexOf(S) == -1) {
          l.push(S);
          let x = c(S, p.concat(y));
          if (x)
            return x;
        }
      }
      return null;
    }
    return c(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let s = 0; s < this.wrapCache.length; s += 2)
      if (this.wrapCache[s] == e)
        return this.wrapCache[s + 1];
    let r = this.computeWrapping(e);
    return this.wrapCache.push(e, r), r;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let r = /* @__PURE__ */ Object.create(null), s = [{ match: this, type: null, via: null }];
    for (; s.length; ) {
      let l = s.shift(), c = l.match;
      if (c.matchType(e)) {
        let f = [];
        for (let p = l; p.type; p = p.via)
          f.push(p.type);
        return f.reverse();
      }
      for (let f = 0; f < c.next.length; f++) {
        let { type: p, next: d } = c.next[f];
        !p.isLeaf && !p.hasRequiredAttrs() && !(p.name in r) && (!l.type || d.validEnd) && (s.push({ match: p.contentMatch, type: p, via: l }), r[p.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function r(s) {
      e.push(s);
      for (let l = 0; l < s.next.length; l++)
        e.indexOf(s.next[l].next) == -1 && r(s.next[l].next);
    }
    return r(this), e.map((s, l) => {
      let c = l + (s.validEnd ? "*" : " ") + " ";
      for (let f = 0; f < s.next.length; f++)
        c += (f ? ", " : "") + s.next[f].type.name + "->" + e.indexOf(s.next[f].next);
      return c;
    }).join(`
`);
  }
}
Fc.empty = new Fc(!0);
class wQ {
  constructor(e, r) {
    this.string = e, this.nodeTypes = r, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function BV(i) {
  let e = [];
  do
    e.push(xQ(i));
  while (i.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function xQ(i) {
  let e = [];
  do
    e.push(kQ(i));
  while (i.next && i.next != ")" && i.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function kQ(i) {
  let e = TQ(i);
  for (; ; )
    if (i.eat("+"))
      e = { type: "plus", expr: e };
    else if (i.eat("*"))
      e = { type: "star", expr: e };
    else if (i.eat("?"))
      e = { type: "opt", expr: e };
    else if (i.eat("{"))
      e = OQ(i, e);
    else
      break;
  return e;
}
function q$(i) {
  /\D/.test(i.next) && i.err("Expected number, got '" + i.next + "'");
  let e = Number(i.next);
  return i.pos++, e;
}
function OQ(i, e) {
  let r = q$(i), s = r;
  return i.eat(",") && (i.next != "}" ? s = q$(i) : s = -1), i.eat("}") || i.err("Unclosed braced range"), { type: "range", min: r, max: s, expr: e };
}
function CQ(i, e) {
  let r = i.nodeTypes, s = r[e];
  if (s)
    return [s];
  let l = [];
  for (let c in r) {
    let f = r[c];
    f.groups.indexOf(e) > -1 && l.push(f);
  }
  return l.length == 0 && i.err("No node type or group '" + e + "' found"), l;
}
function TQ(i) {
  if (i.eat("(")) {
    let e = BV(i);
    return i.eat(")") || i.err("Missing closing paren"), e;
  } else if (/\W/.test(i.next))
    i.err("Unexpected token '" + i.next + "'");
  else {
    let e = CQ(i, i.next).map((r) => (i.inline == null ? i.inline = r.isInline : i.inline != r.isInline && i.err("Mixing inline and block content"), { type: "name", value: r }));
    return i.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function AQ(i) {
  let e = [[]];
  return l(c(i, 0), r()), e;
  function r() {
    return e.push([]) - 1;
  }
  function s(f, p, d) {
    let m = { term: d, to: p };
    return e[f].push(m), m;
  }
  function l(f, p) {
    f.forEach((d) => d.to = p);
  }
  function c(f, p) {
    if (f.type == "choice")
      return f.exprs.reduce((d, m) => d.concat(c(m, p)), []);
    if (f.type == "seq")
      for (let d = 0; ; d++) {
        let m = c(f.exprs[d], p);
        if (d == f.exprs.length - 1)
          return m;
        l(m, p = r());
      }
    else if (f.type == "star") {
      let d = r();
      return s(p, d), l(c(f.expr, d), d), [s(d)];
    } else if (f.type == "plus") {
      let d = r();
      return l(c(f.expr, p), d), l(c(f.expr, d), d), [s(d)];
    } else {
      if (f.type == "opt")
        return [s(p)].concat(c(f.expr, p));
      if (f.type == "range") {
        let d = p;
        for (let m = 0; m < f.min; m++) {
          let y = r();
          l(c(f.expr, d), y), d = y;
        }
        if (f.max == -1)
          l(c(f.expr, d), d);
        else
          for (let m = f.min; m < f.max; m++) {
            let y = r();
            s(d, y), l(c(f.expr, d), y), d = y;
          }
        return [s(d)];
      } else {
        if (f.type == "name")
          return [s(p, void 0, f.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function FV(i, e) {
  return e - i;
}
function K$(i, e) {
  let r = [];
  return s(e), r.sort(FV);
  function s(l) {
    let c = i[l];
    if (c.length == 1 && !c[0].term)
      return s(c[0].to);
    r.push(l);
    for (let f = 0; f < c.length; f++) {
      let { term: p, to: d } = c[f];
      !p && r.indexOf(d) == -1 && s(d);
    }
  }
}
function EQ(i) {
  let e = /* @__PURE__ */ Object.create(null);
  return r(K$(i, 0));
  function r(s) {
    let l = [];
    s.forEach((f) => {
      i[f].forEach(({ term: p, to: d }) => {
        if (!p)
          return;
        let m;
        for (let y = 0; y < l.length; y++)
          l[y][0] == p && (m = l[y][1]);
        K$(i, d).forEach((y) => {
          m || l.push([p, m = []]), m.indexOf(y) == -1 && m.push(y);
        });
      });
    });
    let c = e[s.join(",")] = new Fc(s.indexOf(i.length - 1) > -1);
    for (let f = 0; f < l.length; f++) {
      let p = l[f][1].sort(FV);
      c.next.push({ type: l[f][0], next: e[p.join(",")] || r(p) });
    }
    return c;
  }
}
function MQ(i, e) {
  for (let r = 0, s = [i]; r < s.length; r++) {
    let l = s[r], c = !l.validEnd, f = [];
    for (let p = 0; p < l.next.length; p++) {
      let { type: d, next: m } = l.next[p];
      f.push(d.name), c && !(d.isText || d.hasRequiredAttrs()) && (c = !1), s.indexOf(m) == -1 && s.push(m);
    }
    c && e.err("Only non-generatable nodes (" + f.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function zV(i) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r in i) {
    let s = i[r];
    if (!s.hasDefault)
      return null;
    e[r] = s.default;
  }
  return e;
}
function HV(i, e) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let s in i) {
    let l = e && e[s];
    if (l === void 0) {
      let c = i[s];
      if (c.hasDefault)
        l = c.default;
      else
        throw new RangeError("No value supplied for attribute " + s);
    }
    r[s] = l;
  }
  return r;
}
function jV(i) {
  let e = /* @__PURE__ */ Object.create(null);
  if (i)
    for (let r in i)
      e[r] = new RQ(i[r]);
  return e;
}
let X$ = class WV {
  /**
  @internal
  */
  constructor(e, r, s) {
    this.name = e, this.schema = r, this.spec = s, this.markSet = null, this.groups = s.group ? s.group.split(" ") : [], this.attrs = jV(s.attrs), this.defaultAttrs = zV(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(s.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == Fc.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : HV(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, r, s) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Au(this, this.computeAttrs(e), qt.from(r), Qr.setFrom(s));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, r, s) {
    return r = qt.from(r), this.checkContent(r), new Au(this, this.computeAttrs(e), r, Qr.setFrom(s));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, r, s) {
    if (e = this.computeAttrs(e), r = qt.from(r), r.size) {
      let f = this.contentMatch.fillBefore(r);
      if (!f)
        return null;
      r = f.append(r);
    }
    let l = this.contentMatch.matchFragment(r), c = l && l.fillBefore(qt.empty, !0);
    return c ? new Au(this, e, r.append(c), Qr.setFrom(s)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type with the given attributes.
  */
  validContent(e) {
    let r = this.contentMatch.matchFragment(e);
    if (!r || !r.validEnd)
      return !1;
    for (let s = 0; s < e.childCount; s++)
      if (!this.allowsMarks(e.child(s).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let r = 0; r < e.length; r++)
      if (!this.allowsMarkType(e[r].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let r;
    for (let s = 0; s < e.length; s++)
      this.allowsMarkType(e[s].type) ? r && r.push(e[s]) : r || (r = e.slice(0, s));
    return r ? r.length ? r : Qr.none : e;
  }
  /**
  @internal
  */
  static compile(e, r) {
    let s = /* @__PURE__ */ Object.create(null);
    e.forEach((c, f) => s[c] = new WV(c, r, f));
    let l = r.spec.topNode || "doc";
    if (!s[l])
      throw new RangeError("Schema is missing its top node type ('" + l + "')");
    if (!s.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let c in s.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return s;
  }
};
class RQ {
  constructor(e) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(e, "default"), this.default = e.default;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class Lx {
  /**
  @internal
  */
  constructor(e, r, s, l) {
    this.name = e, this.rank = r, this.schema = s, this.spec = l, this.attrs = jV(l.attrs), this.excluded = null;
    let c = zV(this.attrs);
    this.instance = c ? new Qr(this, c) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new Qr(this, HV(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, r) {
    let s = /* @__PURE__ */ Object.create(null), l = 0;
    return e.forEach((c, f) => s[c] = new Lx(c, l++, r, f)), s;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var r = 0; r < e.length; r++)
      e[r].type == this && (e = e.slice(0, r).concat(e.slice(r + 1)), r--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let r = 0; r < e.length; r++)
      if (e[r].type == this)
        return e[r];
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class $V {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.cached = /* @__PURE__ */ Object.create(null);
    let r = this.spec = {};
    for (let l in e)
      r[l] = e[l];
    r.nodes = Ci.from(e.nodes), r.marks = Ci.from(e.marks || {}), this.nodes = X$.compile(this.spec.nodes, this), this.marks = Lx.compile(this.spec.marks, this);
    let s = /* @__PURE__ */ Object.create(null);
    for (let l in this.nodes) {
      if (l in this.marks)
        throw new RangeError(l + " can not be both a node and a mark");
      let c = this.nodes[l], f = c.spec.content || "", p = c.spec.marks;
      c.contentMatch = s[f] || (s[f] = Fc.parse(f, this.nodes)), c.inlineContent = c.contentMatch.inlineContent, c.markSet = p == "_" ? null : p ? J$(this, p.split(" ")) : p == "" || !c.inlineContent ? [] : null;
    }
    for (let l in this.marks) {
      let c = this.marks[l], f = c.spec.excludes;
      c.excluded = f == null ? [c] : f == "" ? [] : J$(this, f.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, r = null, s, l) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof X$) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else throw new RangeError("Invalid node type: " + e);
    return e.createChecked(r, s, l);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, r) {
    let s = this.nodes.text;
    return new sx(s, s.defaultAttrs, e, Qr.setFrom(r));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, r) {
    return typeof e == "string" && (e = this.marks[e]), e.create(r);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(e) {
    return Au.fromJSON(this, e);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(e) {
    return Qr.fromJSON(this, e);
  }
  /**
  @internal
  */
  nodeType(e) {
    let r = this.nodes[e];
    if (!r)
      throw new RangeError("Unknown node type: " + e);
    return r;
  }
}
function J$(i, e) {
  let r = [];
  for (let s = 0; s < e.length; s++) {
    let l = e[s], c = i.marks[l], f = c;
    if (c)
      r.push(c);
    else
      for (let p in i.marks) {
        let d = i.marks[p];
        (l == "_" || d.spec.group && d.spec.group.split(" ").indexOf(l) > -1) && r.push(f = d);
      }
    if (!f)
      throw new SyntaxError("Unknown mark type: '" + e[s] + "'");
  }
  return r;
}
class zc {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, r) {
    this.schema = e, this.rules = r, this.tags = [], this.styles = [], r.forEach((s) => {
      s.tag ? this.tags.push(s) : s.style && this.styles.push(s);
    }), this.normalizeLists = !this.tags.some((s) => {
      if (!/^(ul|ol)\b/.test(s.tag) || !s.node)
        return !1;
      let l = e.nodes[s.node];
      return l.contentMatch.matchType(l);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, r = {}) {
    let s = new Q$(this, r, !1);
    return s.addAll(e, r.from, r.to), s.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, r = {}) {
    let s = new Q$(this, r, !0);
    return s.addAll(e, r.from, r.to), ur.maxOpen(s.finish());
  }
  /**
  @internal
  */
  matchTag(e, r, s) {
    for (let l = s ? this.tags.indexOf(s) + 1 : 0; l < this.tags.length; l++) {
      let c = this.tags[l];
      if (LQ(e, c.tag) && (c.namespace === void 0 || e.namespaceURI == c.namespace) && (!c.context || r.matchesContext(c.context))) {
        if (c.getAttrs) {
          let f = c.getAttrs(e);
          if (f === !1)
            continue;
          c.attrs = f || void 0;
        }
        return c;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, r, s, l) {
    for (let c = l ? this.styles.indexOf(l) + 1 : 0; c < this.styles.length; c++) {
      let f = this.styles[c], p = f.style;
      if (!(p.indexOf(e) != 0 || f.context && !s.matchesContext(f.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      p.length > e.length && (p.charCodeAt(e.length) != 61 || p.slice(e.length + 1) != r))) {
        if (f.getAttrs) {
          let d = f.getAttrs(r);
          if (d === !1)
            continue;
          f.attrs = d || void 0;
        }
        return f;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let r = [];
    function s(l) {
      let c = l.priority == null ? 50 : l.priority, f = 0;
      for (; f < r.length; f++) {
        let p = r[f];
        if ((p.priority == null ? 50 : p.priority) < c)
          break;
      }
      r.splice(f, 0, l);
    }
    for (let l in e.marks) {
      let c = e.marks[l].spec.parseDOM;
      c && c.forEach((f) => {
        s(f = eU(f)), f.mark || f.ignore || f.clearMark || (f.mark = l);
      });
    }
    for (let l in e.nodes) {
      let c = e.nodes[l].spec.parseDOM;
      c && c.forEach((f) => {
        s(f = eU(f)), f.node || f.ignore || f.mark || (f.node = l);
      });
    }
    return r;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new zc(e, zc.schemaRules(e)));
  }
}
const UV = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, DQ = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, VV = { ol: !0, ul: !0 }, lx = 1, ux = 2, Yw = 4;
function Z$(i, e, r) {
  return e != null ? (e ? lx : 0) | (e === "full" ? ux : 0) : i && i.whitespace == "pre" ? lx | ux : r & -5;
}
class _w {
  constructor(e, r, s, l, c, f, p) {
    this.type = e, this.attrs = r, this.marks = s, this.pendingMarks = l, this.solid = c, this.options = p, this.content = [], this.activeMarks = Qr.none, this.stashMarks = [], this.match = f || (p & Yw ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let r = this.type.contentMatch.fillBefore(qt.from(e));
      if (r)
        this.match = this.type.contentMatch.matchFragment(r);
      else {
        let s = this.type.contentMatch, l;
        return (l = s.findWrapping(e.type)) ? (this.match = s, l) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & lx)) {
      let s = this.content[this.content.length - 1], l;
      if (s && s.isText && (l = /[ \t\r\n\u000c]+$/.exec(s.text))) {
        let c = s;
        s.text.length == l[0].length ? this.content.pop() : this.content[this.content.length - 1] = c.withText(c.text.slice(0, c.text.length - l[0].length));
      }
    }
    let r = qt.from(this.content);
    return !e && this.match && (r = r.append(this.match.fillBefore(qt.empty, !0))), this.type ? this.type.create(this.attrs, r, this.marks) : r;
  }
  popFromStashMark(e) {
    for (let r = this.stashMarks.length - 1; r >= 0; r--)
      if (e.eq(this.stashMarks[r]))
        return this.stashMarks.splice(r, 1)[0];
  }
  applyPending(e) {
    for (let r = 0, s = this.pendingMarks; r < s.length; r++) {
      let l = s[r];
      (this.type ? this.type.allowsMarkType(l.type) : _Q(l.type, e)) && !l.isInSet(this.activeMarks) && (this.activeMarks = l.addToSet(this.activeMarks), this.pendingMarks = l.removeFromSet(this.pendingMarks));
    }
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !UV.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class Q$ {
  constructor(e, r, s) {
    this.parser = e, this.options = r, this.isOpen = s, this.open = 0;
    let l = r.topNode, c, f = Z$(null, r.preserveWhitespace, 0) | (s ? Yw : 0);
    l ? c = new _w(l.type, l.attrs, Qr.none, Qr.none, !0, r.topMatch || l.type.contentMatch, f) : s ? c = new _w(null, null, Qr.none, Qr.none, !0, null, f) : c = new _w(e.schema.topNodeType, null, Qr.none, Qr.none, !0, null, f), this.nodes = [c], this.find = r.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e) {
    e.nodeType == 3 ? this.addTextNode(e) : e.nodeType == 1 && this.addElement(e);
  }
  withStyleRules(e, r) {
    let s = e.getAttribute("style");
    if (!s)
      return r();
    let l = this.readStyles(IQ(s));
    if (!l)
      return;
    let [c, f] = l, p = this.top;
    for (let d = 0; d < f.length; d++)
      this.removePendingMark(f[d], p);
    for (let d = 0; d < c.length; d++)
      this.addPendingMark(c[d]);
    r();
    for (let d = 0; d < c.length; d++)
      this.removePendingMark(c[d], p);
    for (let d = 0; d < f.length; d++)
      this.addPendingMark(f[d]);
  }
  addTextNode(e) {
    let r = e.nodeValue, s = this.top;
    if (s.options & ux || s.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
      if (s.options & lx)
        s.options & ux ? r = r.replace(/\r\n?/g, `
`) : r = r.replace(/\r?\n|\r/g, " ");
      else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) {
        let l = s.content[s.content.length - 1], c = e.previousSibling;
        (!l || c && c.nodeName == "BR" || l.isText && /[ \t\r\n\u000c]$/.test(l.text)) && (r = r.slice(1));
      }
      r && this.insertNode(this.parser.schema.text(r)), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, r) {
    let s = e.nodeName.toLowerCase(), l;
    VV.hasOwnProperty(s) && this.parser.normalizeLists && PQ(e);
    let c = this.options.ruleFromNode && this.options.ruleFromNode(e) || (l = this.parser.matchTag(e, this, r));
    if (c ? c.ignore : DQ.hasOwnProperty(s))
      this.findInside(e), this.ignoreFallback(e);
    else if (!c || c.skip || c.closeParent) {
      c && c.closeParent ? this.open = Math.max(0, this.open - 1) : c && c.skip.nodeType && (e = c.skip);
      let f, p = this.top, d = this.needsBlock;
      if (UV.hasOwnProperty(s))
        p.content.length && p.content[0].isInline && this.open && (this.open--, p = this.top), f = !0, p.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e);
        return;
      }
      c && c.skip ? this.addAll(e) : this.withStyleRules(e, () => this.addAll(e)), f && this.sync(p), this.needsBlock = d;
    } else
      this.withStyleRules(e, () => {
        this.addElementByRule(e, c, c.consuming === !1 ? l : void 0);
      });
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`));
  }
  // Called for ignored nodes
  ignoreFallback(e) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"));
  }
  // Run any style parser associated with the node's styles. Either
  // return an array of marks, or null to indicate some of the styles
  // had a rule with `ignore` set.
  readStyles(e) {
    let r = Qr.none, s = Qr.none;
    for (let l = 0; l < e.length; l += 2)
      for (let c = void 0; ; ) {
        let f = this.parser.matchStyle(e[l], e[l + 1], this, c);
        if (!f)
          break;
        if (f.ignore)
          return null;
        if (f.clearMark ? this.top.pendingMarks.concat(this.top.activeMarks).forEach((p) => {
          f.clearMark(p) && (s = p.addToSet(s));
        }) : r = this.parser.schema.marks[f.mark].create(f.attrs).addToSet(r), f.consuming === !1)
          c = f;
        else
          break;
      }
    return [r, s];
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, r, s) {
    let l, c, f;
    r.node ? (c = this.parser.schema.nodes[r.node], c.isLeaf ? this.insertNode(c.create(r.attrs)) || this.leafFallback(e) : l = this.enter(c, r.attrs || null, r.preserveWhitespace)) : (f = this.parser.schema.marks[r.mark].create(r.attrs), this.addPendingMark(f));
    let p = this.top;
    if (c && c.isLeaf)
      this.findInside(e);
    else if (s)
      this.addElement(e, s);
    else if (r.getContent)
      this.findInside(e), r.getContent(e, this.parser.schema).forEach((d) => this.insertNode(d));
    else {
      let d = e;
      typeof r.contentElement == "string" ? d = e.querySelector(r.contentElement) : typeof r.contentElement == "function" ? d = r.contentElement(e) : r.contentElement && (d = r.contentElement), this.findAround(e, d, !0), this.addAll(d);
    }
    l && this.sync(p) && this.open--, f && this.removePendingMark(f, p);
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, r, s) {
    let l = r || 0;
    for (let c = r ? e.childNodes[r] : e.firstChild, f = s == null ? null : e.childNodes[s]; c != f; c = c.nextSibling, ++l)
      this.findAtPoint(e, l), this.addDOM(c);
    this.findAtPoint(e, l);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e) {
    let r, s;
    for (let l = this.open; l >= 0; l--) {
      let c = this.nodes[l], f = c.findWrapping(e);
      if (f && (!r || r.length > f.length) && (r = f, s = c, !f.length) || c.solid)
        break;
    }
    if (!r)
      return !1;
    this.sync(s);
    for (let l = 0; l < r.length; l++)
      this.enterInner(r[l], null, !1);
    return !0;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let r = this.textblockFromContext();
      r && this.enterInner(r);
    }
    if (this.findPlace(e)) {
      this.closeExtra();
      let r = this.top;
      r.applyPending(e.type), r.match && (r.match = r.match.matchType(e.type));
      let s = r.activeMarks;
      for (let l = 0; l < e.marks.length; l++)
        (!r.type || r.type.allowsMarkType(e.marks[l].type)) && (s = e.marks[l].addToSet(s));
      return r.content.push(e.mark(s)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, r, s) {
    let l = this.findPlace(e.create(r));
    return l && this.enterInner(e, r, !0, s), l;
  }
  // Open a node of the given type
  enterInner(e, r = null, s = !1, l) {
    this.closeExtra();
    let c = this.top;
    c.applyPending(e), c.match = c.match && c.match.matchType(e);
    let f = Z$(e, l, c.options);
    c.options & Yw && c.content.length == 0 && (f |= Yw), this.nodes.push(new _w(e, r, c.activeMarks, c.pendingMarks, s, null, f)), this.open++;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let r = this.nodes.length - 1;
    if (r > this.open) {
      for (; r > this.open; r--)
        this.nodes[r - 1].content.push(this.nodes[r].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(this.isOpen || this.options.topOpen);
  }
  sync(e) {
    for (let r = this.open; r >= 0; r--)
      if (this.nodes[r] == e)
        return this.open = r, !0;
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let r = this.open; r >= 0; r--) {
      let s = this.nodes[r].content;
      for (let l = s.length - 1; l >= 0; l--)
        e += s[l].nodeSize;
      r && e++;
    }
    return e;
  }
  findAtPoint(e, r) {
    if (this.find)
      for (let s = 0; s < this.find.length; s++)
        this.find[s].node == e && this.find[s].offset == r && (this.find[s].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].pos == null && e.nodeType == 1 && e.contains(this.find[r].node) && (this.find[r].pos = this.currentPos);
  }
  findAround(e, r, s) {
    if (e != r && this.find)
      for (let l = 0; l < this.find.length; l++)
        this.find[l].pos == null && e.nodeType == 1 && e.contains(this.find[l].node) && r.compareDocumentPosition(this.find[l].node) & (s ? 2 : 4) && (this.find[l].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e && (this.find[r].pos = this.currentPos - (e.nodeValue.length - this.find[r].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let r = e.split("/"), s = this.options.context, l = !this.isOpen && (!s || s.parent.type == this.nodes[0].type), c = -(s ? s.depth + 1 : 0) + (l ? 0 : 1), f = (p, d) => {
      for (; p >= 0; p--) {
        let m = r[p];
        if (m == "") {
          if (p == r.length - 1 || p == 0)
            continue;
          for (; d >= c; d--)
            if (f(p - 1, d))
              return !0;
          return !1;
        } else {
          let y = d > 0 || d == 0 && l ? this.nodes[d].type : s && d >= c ? s.node(d - c).type : null;
          if (!y || y.name != m && y.groups.indexOf(m) == -1)
            return !1;
          d--;
        }
      }
      return !0;
    };
    return f(r.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let r = e.depth; r >= 0; r--) {
        let s = e.node(r).contentMatchAt(e.indexAfter(r)).defaultType;
        if (s && s.isTextblock && s.defaultAttrs)
          return s;
      }
    for (let r in this.parser.schema.nodes) {
      let s = this.parser.schema.nodes[r];
      if (s.isTextblock && s.defaultAttrs)
        return s;
    }
  }
  addPendingMark(e) {
    let r = NQ(e, this.top.pendingMarks);
    r && this.top.stashMarks.push(r), this.top.pendingMarks = e.addToSet(this.top.pendingMarks);
  }
  removePendingMark(e, r) {
    for (let s = this.open; s >= 0; s--) {
      let l = this.nodes[s];
      if (l.pendingMarks.lastIndexOf(e) > -1)
        l.pendingMarks = e.removeFromSet(l.pendingMarks);
      else {
        l.activeMarks = e.removeFromSet(l.activeMarks);
        let f = l.popFromStashMark(e);
        f && l.type && l.type.allowsMarkType(f.type) && (l.activeMarks = f.addToSet(l.activeMarks));
      }
      if (l == r)
        break;
    }
  }
}
function PQ(i) {
  for (let e = i.firstChild, r = null; e; e = e.nextSibling) {
    let s = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    s && VV.hasOwnProperty(s) && r ? (r.appendChild(e), e = r) : s == "li" ? r = e : s && (r = null);
  }
}
function LQ(i, e) {
  return (i.matches || i.msMatchesSelector || i.webkitMatchesSelector || i.mozMatchesSelector).call(i, e);
}
function IQ(i) {
  let e = /\s*([\w-]+)\s*:\s*([^;]+)/g, r, s = [];
  for (; r = e.exec(i); )
    s.push(r[1], r[2].trim());
  return s;
}
function eU(i) {
  let e = {};
  for (let r in i)
    e[r] = i[r];
  return e;
}
function _Q(i, e) {
  let r = e.schema.nodes;
  for (let s in r) {
    let l = r[s];
    if (!l.allowsMarkType(i))
      continue;
    let c = [], f = (p) => {
      c.push(p);
      for (let d = 0; d < p.edgeCount; d++) {
        let { type: m, next: y } = p.edge(d);
        if (m == e || c.indexOf(y) < 0 && f(y))
          return !0;
      }
    };
    if (f(l.contentMatch))
      return !0;
  }
}
function NQ(i, e) {
  for (let r = 0; r < e.length; r++)
    if (i.eq(e[r]))
      return e[r];
}
class bl {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, r) {
    this.nodes = e, this.marks = r;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, r = {}, s) {
    s || (s = zH(r).createDocumentFragment());
    let l = s, c = [];
    return e.forEach((f) => {
      if (c.length || f.marks.length) {
        let p = 0, d = 0;
        for (; p < c.length && d < f.marks.length; ) {
          let m = f.marks[d];
          if (!this.marks[m.type.name]) {
            d++;
            continue;
          }
          if (!m.eq(c[p][0]) || m.type.spec.spanning === !1)
            break;
          p++, d++;
        }
        for (; p < c.length; )
          l = c.pop()[1];
        for (; d < f.marks.length; ) {
          let m = f.marks[d++], y = this.serializeMark(m, f.isInline, r);
          y && (c.push([m, l]), l.appendChild(y.dom), l = y.contentDOM || y.dom);
        }
      }
      l.appendChild(this.serializeNodeInner(f, r));
    }), s;
  }
  /**
  @internal
  */
  serializeNodeInner(e, r) {
    let { dom: s, contentDOM: l } = bl.renderSpec(zH(r), this.nodes[e.type.name](e));
    if (l) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, r, l);
    }
    return s;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, r = {}) {
    let s = this.serializeNodeInner(e, r);
    for (let l = e.marks.length - 1; l >= 0; l--) {
      let c = this.serializeMark(e.marks[l], e.isInline, r);
      c && ((c.contentDOM || c.dom).appendChild(s), s = c.dom);
    }
    return s;
  }
  /**
  @internal
  */
  serializeMark(e, r, s = {}) {
    let l = this.marks[e.type.name];
    return l && bl.renderSpec(zH(s), l(e, r));
  }
  /**
  Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If
  the spec has a hole (zero) in it, `contentDOM` will point at the
  node with the hole.
  */
  static renderSpec(e, r, s = null) {
    if (typeof r == "string")
      return { dom: e.createTextNode(r) };
    if (r.nodeType != null)
      return { dom: r };
    if (r.dom && r.dom.nodeType != null)
      return r;
    let l = r[0], c = l.indexOf(" ");
    c > 0 && (s = l.slice(0, c), l = l.slice(c + 1));
    let f, p = s ? e.createElementNS(s, l) : e.createElement(l), d = r[1], m = 1;
    if (d && typeof d == "object" && d.nodeType == null && !Array.isArray(d)) {
      m = 2;
      for (let y in d)
        if (d[y] != null) {
          let S = y.indexOf(" ");
          S > 0 ? p.setAttributeNS(y.slice(0, S), y.slice(S + 1), d[y]) : p.setAttribute(y, d[y]);
        }
    }
    for (let y = m; y < r.length; y++) {
      let S = r[y];
      if (S === 0) {
        if (y < r.length - 1 || y > m)
          throw new RangeError("Content hole must be the only child of its parent node");
        return { dom: p, contentDOM: p };
      } else {
        let { dom: x, contentDOM: w } = bl.renderSpec(e, S, s);
        if (p.appendChild(x), w) {
          if (f)
            throw new RangeError("Multiple content holes");
          f = w;
        }
      }
    }
    return { dom: p, contentDOM: f };
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new bl(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let r = tU(e.nodes);
    return r.text || (r.text = (s) => s.text), r;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return tU(e.marks);
  }
}
function tU(i) {
  let e = {};
  for (let r in i) {
    let s = i[r].spec.toDOM;
    s && (e[r] = s);
  }
  return e;
}
function zH(i) {
  return i.document || window.document;
}
const GV = 65535, YV = Math.pow(2, 16);
function BQ(i, e) {
  return i + e * YV;
}
function rU(i) {
  return i & GV;
}
function FQ(i) {
  return (i - (i & GV)) / YV;
}
const qV = 1, KV = 2, qw = 4, XV = 8;
class $j {
  /**
  @internal
  */
  constructor(e, r, s) {
    this.pos = e, this.delInfo = r, this.recover = s;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & XV) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (qV | qw)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (KV | qw)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & qw) > 0;
  }
}
class fo {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, r = !1) {
    if (this.ranges = e, this.inverted = r, !e.length && fo.empty)
      return fo.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let r = 0, s = rU(e);
    if (!this.inverted)
      for (let l = 0; l < s; l++)
        r += this.ranges[l * 3 + 2] - this.ranges[l * 3 + 1];
    return this.ranges[s * 3] + r + FQ(e);
  }
  mapResult(e, r = 1) {
    return this._map(e, r, !1);
  }
  map(e, r = 1) {
    return this._map(e, r, !0);
  }
  /**
  @internal
  */
  _map(e, r, s) {
    let l = 0, c = this.inverted ? 2 : 1, f = this.inverted ? 1 : 2;
    for (let p = 0; p < this.ranges.length; p += 3) {
      let d = this.ranges[p] - (this.inverted ? l : 0);
      if (d > e)
        break;
      let m = this.ranges[p + c], y = this.ranges[p + f], S = d + m;
      if (e <= S) {
        let x = m ? e == d ? -1 : e == S ? 1 : r : r, w = d + l + (x < 0 ? 0 : y);
        if (s)
          return w;
        let k = e == (r < 0 ? d : S) ? null : BQ(p / 3, e - d), O = e == d ? KV : e == S ? qV : qw;
        return (r < 0 ? e != d : e != S) && (O |= XV), new $j(w, O, k);
      }
      l += y - m;
    }
    return s ? e + l : new $j(e + l, 0, null);
  }
  /**
  @internal
  */
  touches(e, r) {
    let s = 0, l = rU(r), c = this.inverted ? 2 : 1, f = this.inverted ? 1 : 2;
    for (let p = 0; p < this.ranges.length; p += 3) {
      let d = this.ranges[p] - (this.inverted ? s : 0);
      if (d > e)
        break;
      let m = this.ranges[p + c], y = d + m;
      if (e <= y && p == l * 3)
        return !0;
      s += this.ranges[p + f] - m;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let r = this.inverted ? 2 : 1, s = this.inverted ? 1 : 2;
    for (let l = 0, c = 0; l < this.ranges.length; l += 3) {
      let f = this.ranges[l], p = f - (this.inverted ? c : 0), d = f + (this.inverted ? 0 : c), m = this.ranges[l + r], y = this.ranges[l + s];
      e(p, p + m, d, d + y), c += y - m;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new fo(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? fo.empty : new fo(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
fo.empty = new fo([]);
class ap {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e = [], r, s = 0, l = e.length) {
    this.maps = e, this.mirror = r, this.from = s, this.to = l;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, r = this.maps.length) {
    return new ap(this.maps, this.mirror, e, r);
  }
  /**
  @internal
  */
  copy() {
    return new ap(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, r) {
    this.to = this.maps.push(e), r != null && this.setMirror(this.maps.length - 1, r);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let r = 0, s = this.maps.length; r < e.maps.length; r++) {
      let l = e.getMirror(r);
      this.appendMap(e.maps[r], l != null && l < r ? s + l : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let r = 0; r < this.mirror.length; r++)
        if (this.mirror[r] == e)
          return this.mirror[r + (r % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, r) {
    this.mirror || (this.mirror = []), this.mirror.push(e, r);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let r = e.maps.length - 1, s = this.maps.length + e.maps.length; r >= 0; r--) {
      let l = e.getMirror(r);
      this.appendMap(e.maps[r].invert(), l != null && l > r ? s - l - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new ap();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, r = 1) {
    if (this.mirror)
      return this._map(e, r, !0);
    for (let s = this.from; s < this.to; s++)
      e = this.maps[s].map(e, r);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, r = 1) {
    return this._map(e, r, !1);
  }
  /**
  @internal
  */
  _map(e, r, s) {
    let l = 0;
    for (let c = this.from; c < this.to; c++) {
      let f = this.maps[c], p = f.mapResult(e, r);
      if (p.recover != null) {
        let d = this.getMirror(c);
        if (d != null && d > c && d < this.to) {
          c = d, e = this.maps[d].recover(p.recover);
          continue;
        }
      }
      l |= p.delInfo, e = p.pos;
    }
    return s ? e : new $j(e, l, null);
  }
}
const HH = /* @__PURE__ */ Object.create(null);
class ja {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return fo.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, r) {
    if (!r || !r.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let s = HH[r.stepType];
    if (!s)
      throw new RangeError(`No step type ${r.stepType} defined`);
    return s.fromJSON(e, r);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, r) {
    if (e in HH)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return HH[e] = r, r.prototype.jsonID = e, r;
  }
}
class fi {
  /**
  @internal
  */
  constructor(e, r) {
    this.doc = e, this.failed = r;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new fi(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new fi(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, r, s, l) {
    try {
      return fi.ok(e.replace(r, s, l));
    } catch (c) {
      if (c instanceof ix)
        return fi.fail(c.message);
      throw c;
    }
  }
}
function A3(i, e, r) {
  let s = [];
  for (let l = 0; l < i.childCount; l++) {
    let c = i.child(l);
    c.content.size && (c = c.copy(A3(c.content, e, c))), c.isInline && (c = e(c, r, l)), s.push(c);
  }
  return qt.fromArray(s);
}
class ku extends ja {
  /**
  Create a mark step.
  */
  constructor(e, r, s) {
    super(), this.from = e, this.to = r, this.mark = s;
  }
  apply(e) {
    let r = e.slice(this.from, this.to), s = e.resolve(this.from), l = s.node(s.sharedDepth(this.to)), c = new ur(A3(r.content, (f, p) => !f.isAtom || !p.type.allowsMarkType(this.mark.type) ? f : f.mark(this.mark.addToSet(f.marks)), l), r.openStart, r.openEnd);
    return fi.fromReplace(e, this.from, this.to, c);
  }
  invert() {
    return new Ns(this.from, this.to, this.mark);
  }
  map(e) {
    let r = e.mapResult(this.from, 1), s = e.mapResult(this.to, -1);
    return r.deleted && s.deleted || r.pos >= s.pos ? null : new ku(r.pos, s.pos, this.mark);
  }
  merge(e) {
    return e instanceof ku && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new ku(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, r) {
    if (typeof r.from != "number" || typeof r.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new ku(r.from, r.to, e.markFromJSON(r.mark));
  }
}
ja.jsonID("addMark", ku);
class Ns extends ja {
  /**
  Create a mark-removing step.
  */
  constructor(e, r, s) {
    super(), this.from = e, this.to = r, this.mark = s;
  }
  apply(e) {
    let r = e.slice(this.from, this.to), s = new ur(A3(r.content, (l) => l.mark(this.mark.removeFromSet(l.marks)), e), r.openStart, r.openEnd);
    return fi.fromReplace(e, this.from, this.to, s);
  }
  invert() {
    return new ku(this.from, this.to, this.mark);
  }
  map(e) {
    let r = e.mapResult(this.from, 1), s = e.mapResult(this.to, -1);
    return r.deleted && s.deleted || r.pos >= s.pos ? null : new Ns(r.pos, s.pos, this.mark);
  }
  merge(e) {
    return e instanceof Ns && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Ns(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, r) {
    if (typeof r.from != "number" || typeof r.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new Ns(r.from, r.to, e.markFromJSON(r.mark));
  }
}
ja.jsonID("removeMark", Ns);
class Ou extends ja {
  /**
  Create a node mark step.
  */
  constructor(e, r) {
    super(), this.pos = e, this.mark = r;
  }
  apply(e) {
    let r = e.nodeAt(this.pos);
    if (!r)
      return fi.fail("No node at mark step's position");
    let s = r.type.create(r.attrs, null, this.mark.addToSet(r.marks));
    return fi.fromReplace(e, this.pos, this.pos + 1, new ur(qt.from(s), 0, r.isLeaf ? 0 : 1));
  }
  invert(e) {
    let r = e.nodeAt(this.pos);
    if (r) {
      let s = this.mark.addToSet(r.marks);
      if (s.length == r.marks.length) {
        for (let l = 0; l < r.marks.length; l++)
          if (!r.marks[l].isInSet(s))
            return new Ou(this.pos, r.marks[l]);
        return new Ou(this.pos, this.mark);
      }
    }
    return new up(this.pos, this.mark);
  }
  map(e) {
    let r = e.mapResult(this.pos, 1);
    return r.deletedAfter ? null : new Ou(r.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, r) {
    if (typeof r.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new Ou(r.pos, e.markFromJSON(r.mark));
  }
}
ja.jsonID("addNodeMark", Ou);
class up extends ja {
  /**
  Create a mark-removing step.
  */
  constructor(e, r) {
    super(), this.pos = e, this.mark = r;
  }
  apply(e) {
    let r = e.nodeAt(this.pos);
    if (!r)
      return fi.fail("No node at mark step's position");
    let s = r.type.create(r.attrs, null, this.mark.removeFromSet(r.marks));
    return fi.fromReplace(e, this.pos, this.pos + 1, new ur(qt.from(s), 0, r.isLeaf ? 0 : 1));
  }
  invert(e) {
    let r = e.nodeAt(this.pos);
    return !r || !this.mark.isInSet(r.marks) ? this : new Ou(this.pos, this.mark);
  }
  map(e) {
    let r = e.mapResult(this.pos, 1);
    return r.deletedAfter ? null : new up(r.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, r) {
    if (typeof r.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new up(r.pos, e.markFromJSON(r.mark));
  }
}
ja.jsonID("removeNodeMark", up);
class Ji extends ja {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, r, s, l = !1) {
    super(), this.from = e, this.to = r, this.slice = s, this.structure = l;
  }
  apply(e) {
    return this.structure && Uj(e, this.from, this.to) ? fi.fail("Structure replace would overwrite content") : fi.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new fo([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new Ji(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let r = e.mapResult(this.from, 1), s = e.mapResult(this.to, -1);
    return r.deletedAcross && s.deletedAcross ? null : new Ji(r.pos, Math.max(r.pos, s.pos), this.slice);
  }
  merge(e) {
    if (!(e instanceof Ji) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let r = this.slice.size + e.slice.size == 0 ? ur.empty : new ur(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new Ji(this.from, this.to + (e.to - e.from), r, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let r = this.slice.size + e.slice.size == 0 ? ur.empty : new ur(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new Ji(e.from, this.to, r, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, r) {
    if (typeof r.from != "number" || typeof r.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new Ji(r.from, r.to, ur.fromJSON(e, r.slice), !!r.structure);
  }
}
ja.jsonID("replace", Ji);
class mi extends ja {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, r, s, l, c, f, p = !1) {
    super(), this.from = e, this.to = r, this.gapFrom = s, this.gapTo = l, this.slice = c, this.insert = f, this.structure = p;
  }
  apply(e) {
    if (this.structure && (Uj(e, this.from, this.gapFrom) || Uj(e, this.gapTo, this.to)))
      return fi.fail("Structure gap-replace would overwrite content");
    let r = e.slice(this.gapFrom, this.gapTo);
    if (r.openStart || r.openEnd)
      return fi.fail("Gap is not a flat range");
    let s = this.slice.insertAt(this.insert, r.content);
    return s ? fi.fromReplace(e, this.from, this.to, s) : fi.fail("Content does not fit in gap");
  }
  getMap() {
    return new fo([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let r = this.gapTo - this.gapFrom;
    return new mi(this.from, this.from + this.slice.size + r, this.from + this.insert, this.from + this.insert + r, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let r = e.mapResult(this.from, 1), s = e.mapResult(this.to, -1), l = e.map(this.gapFrom, -1), c = e.map(this.gapTo, 1);
    return r.deletedAcross && s.deletedAcross || l < r.pos || c > s.pos ? null : new mi(r.pos, s.pos, l, c, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, r) {
    if (typeof r.from != "number" || typeof r.to != "number" || typeof r.gapFrom != "number" || typeof r.gapTo != "number" || typeof r.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new mi(r.from, r.to, r.gapFrom, r.gapTo, ur.fromJSON(e, r.slice), r.insert, !!r.structure);
  }
}
ja.jsonID("replaceAround", mi);
function Uj(i, e, r) {
  let s = i.resolve(e), l = r - e, c = s.depth;
  for (; l > 0 && c > 0 && s.indexAfter(c) == s.node(c).childCount; )
    c--, l--;
  if (l > 0) {
    let f = s.node(c).maybeChild(s.indexAfter(c));
    for (; l > 0; ) {
      if (!f || f.isLeaf)
        return !0;
      f = f.firstChild, l--;
    }
  }
  return !1;
}
function zQ(i, e, r, s) {
  let l = [], c = [], f, p;
  i.doc.nodesBetween(e, r, (d, m, y) => {
    if (!d.isInline)
      return;
    let S = d.marks;
    if (!s.isInSet(S) && y.type.allowsMarkType(s.type)) {
      let x = Math.max(m, e), w = Math.min(m + d.nodeSize, r), k = s.addToSet(S);
      for (let O = 0; O < S.length; O++)
        S[O].isInSet(k) || (f && f.to == x && f.mark.eq(S[O]) ? f.to = w : l.push(f = new Ns(x, w, S[O])));
      p && p.to == x ? p.to = w : c.push(p = new ku(x, w, s));
    }
  }), l.forEach((d) => i.step(d)), c.forEach((d) => i.step(d));
}
function HQ(i, e, r, s) {
  let l = [], c = 0;
  i.doc.nodesBetween(e, r, (f, p) => {
    if (!f.isInline)
      return;
    c++;
    let d = null;
    if (s instanceof Lx) {
      let m = f.marks, y;
      for (; y = s.isInSet(m); )
        (d || (d = [])).push(y), m = y.removeFromSet(m);
    } else s ? s.isInSet(f.marks) && (d = [s]) : d = f.marks;
    if (d && d.length) {
      let m = Math.min(p + f.nodeSize, r);
      for (let y = 0; y < d.length; y++) {
        let S = d[y], x;
        for (let w = 0; w < l.length; w++) {
          let k = l[w];
          k.step == c - 1 && S.eq(l[w].style) && (x = k);
        }
        x ? (x.to = m, x.step = c) : l.push({ style: S, from: Math.max(p, e), to: m, step: c });
      }
    }
  }), l.forEach((f) => i.step(new Ns(f.from, f.to, f.style)));
}
function jQ(i, e, r, s = r.contentMatch) {
  let l = i.doc.nodeAt(e), c = [], f = e + 1;
  for (let p = 0; p < l.childCount; p++) {
    let d = l.child(p), m = f + d.nodeSize, y = s.matchType(d.type);
    if (!y)
      c.push(new Ji(f, m, ur.empty));
    else {
      s = y;
      for (let S = 0; S < d.marks.length; S++)
        r.allowsMarkType(d.marks[S].type) || i.step(new Ns(f, m, d.marks[S]));
      if (d.isText && !r.spec.code) {
        let S, x = /\r?\n|\r/g, w;
        for (; S = x.exec(d.text); )
          w || (w = new ur(qt.from(r.schema.text(" ", r.allowedMarks(d.marks))), 0, 0)), c.push(new Ji(f + S.index, f + S.index + S[0].length, w));
      }
    }
    f = m;
  }
  if (!s.validEnd) {
    let p = s.fillBefore(qt.empty, !0);
    i.replace(f, f, new ur(p, 0, 0));
  }
  for (let p = c.length - 1; p >= 0; p--)
    i.step(c[p]);
}
function WQ(i, e, r) {
  return (e == 0 || i.canReplace(e, i.childCount)) && (r == i.childCount || i.canReplace(0, r));
}
function Ix(i) {
  let r = i.parent.content.cutByIndex(i.startIndex, i.endIndex);
  for (let s = i.depth; ; --s) {
    let l = i.$from.node(s), c = i.$from.index(s), f = i.$to.indexAfter(s);
    if (s < i.depth && l.canReplace(c, f, r))
      return s;
    if (s == 0 || l.type.spec.isolating || !WQ(l, c, f))
      break;
  }
  return null;
}
function $Q(i, e, r) {
  let { $from: s, $to: l, depth: c } = e, f = s.before(c + 1), p = l.after(c + 1), d = f, m = p, y = qt.empty, S = 0;
  for (let k = c, O = !1; k > r; k--)
    O || s.index(k) > 0 ? (O = !0, y = qt.from(s.node(k).copy(y)), S++) : d--;
  let x = qt.empty, w = 0;
  for (let k = c, O = !1; k > r; k--)
    O || l.after(k + 1) < l.end(k) ? (O = !0, x = qt.from(l.node(k).copy(x)), w++) : m++;
  i.step(new mi(d, m, f, p, new ur(y.append(x), S, w), y.size - S, !0));
}
function UQ(i, e, r = null, s = i) {
  let l = VQ(i, e), c = l && GQ(s, e);
  return c ? l.map(nU).concat({ type: e, attrs: r }).concat(c.map(nU)) : null;
}
function nU(i) {
  return { type: i, attrs: null };
}
function VQ(i, e) {
  let { parent: r, startIndex: s, endIndex: l } = i, c = r.contentMatchAt(s).findWrapping(e);
  if (!c)
    return null;
  let f = c.length ? c[0] : e;
  return r.canReplaceWith(s, l, f) ? c : null;
}
function GQ(i, e) {
  let { parent: r, startIndex: s, endIndex: l } = i, c = r.child(s), f = e.contentMatch.findWrapping(c.type);
  if (!f)
    return null;
  let d = (f.length ? f[f.length - 1] : e).contentMatch;
  for (let m = s; d && m < l; m++)
    d = d.matchType(r.child(m).type);
  return !d || !d.validEnd ? null : f;
}
function YQ(i, e, r) {
  let s = qt.empty;
  for (let f = r.length - 1; f >= 0; f--) {
    if (s.size) {
      let p = r[f].type.contentMatch.matchFragment(s);
      if (!p || !p.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    s = qt.from(r[f].type.create(r[f].attrs, s));
  }
  let l = e.start, c = e.end;
  i.step(new mi(l, c, l, c, new ur(s, 0, 0), r.length, !0));
}
function qQ(i, e, r, s, l) {
  if (!s.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let c = i.steps.length;
  i.doc.nodesBetween(e, r, (f, p) => {
    if (f.isTextblock && !f.hasMarkup(s, l) && KQ(i.doc, i.mapping.slice(c).map(p), s)) {
      i.clearIncompatible(i.mapping.slice(c).map(p, 1), s);
      let d = i.mapping.slice(c), m = d.map(p, 1), y = d.map(p + f.nodeSize, 1);
      return i.step(new mi(m, y, m + 1, y - 1, new ur(qt.from(s.create(l, null, f.marks)), 0, 0), 1, !0)), !1;
    }
  });
}
function KQ(i, e, r) {
  let s = i.resolve(e), l = s.index();
  return s.parent.canReplaceWith(l, l + 1, r);
}
function XQ(i, e, r, s, l) {
  let c = i.doc.nodeAt(e);
  if (!c)
    throw new RangeError("No node at given position");
  r || (r = c.type);
  let f = r.create(s, null, l || c.marks);
  if (c.isLeaf)
    return i.replaceWith(e, e + c.nodeSize, f);
  if (!r.validContent(c.content))
    throw new RangeError("Invalid content for node type " + r.name);
  i.step(new mi(e, e + c.nodeSize, e + 1, e + c.nodeSize - 1, new ur(qt.from(f), 0, 0), 1, !0));
}
function op(i, e, r = 1, s) {
  let l = i.resolve(e), c = l.depth - r, f = s && s[s.length - 1] || l.parent;
  if (c < 0 || l.parent.type.spec.isolating || !l.parent.canReplace(l.index(), l.parent.childCount) || !f.type.validContent(l.parent.content.cutByIndex(l.index(), l.parent.childCount)))
    return !1;
  for (let m = l.depth - 1, y = r - 2; m > c; m--, y--) {
    let S = l.node(m), x = l.index(m);
    if (S.type.spec.isolating)
      return !1;
    let w = S.content.cutByIndex(x, S.childCount), k = s && s[y + 1];
    k && (w = w.replaceChild(0, k.type.create(k.attrs)));
    let O = s && s[y] || S;
    if (!S.canReplace(x + 1, S.childCount) || !O.type.validContent(w))
      return !1;
  }
  let p = l.indexAfter(c), d = s && s[0];
  return l.node(c).canReplaceWith(p, p, d ? d.type : l.node(c + 1).type);
}
function JQ(i, e, r = 1, s) {
  let l = i.doc.resolve(e), c = qt.empty, f = qt.empty;
  for (let p = l.depth, d = l.depth - r, m = r - 1; p > d; p--, m--) {
    c = qt.from(l.node(p).copy(c));
    let y = s && s[m];
    f = qt.from(y ? y.type.create(y.attrs, f) : l.node(p).copy(f));
  }
  i.step(new Ji(e, e, new ur(c.append(f), r, r), !0));
}
function JV(i, e) {
  let r = i.resolve(e), s = r.index();
  return ZQ(r.nodeBefore, r.nodeAfter) && r.parent.canReplace(s, s + 1);
}
function ZQ(i, e) {
  return !!(i && e && !i.isLeaf && i.canAppend(e));
}
function QQ(i, e, r) {
  let s = new Ji(e - r, e + r, ur.empty, !0);
  i.step(s);
}
function eee(i, e, r) {
  let s = i.resolve(e);
  if (s.parent.canReplaceWith(s.index(), s.index(), r))
    return e;
  if (s.parentOffset == 0)
    for (let l = s.depth - 1; l >= 0; l--) {
      let c = s.index(l);
      if (s.node(l).canReplaceWith(c, c, r))
        return s.before(l + 1);
      if (c > 0)
        return null;
    }
  if (s.parentOffset == s.parent.content.size)
    for (let l = s.depth - 1; l >= 0; l--) {
      let c = s.indexAfter(l);
      if (s.node(l).canReplaceWith(c, c, r))
        return s.after(l + 1);
      if (c < s.node(l).childCount)
        return null;
    }
  return null;
}
function tee(i, e, r) {
  let s = i.resolve(e);
  if (!r.content.size)
    return e;
  let l = r.content;
  for (let c = 0; c < r.openStart; c++)
    l = l.firstChild.content;
  for (let c = 1; c <= (r.openStart == 0 && r.size ? 2 : 1); c++)
    for (let f = s.depth; f >= 0; f--) {
      let p = f == s.depth ? 0 : s.pos <= (s.start(f + 1) + s.end(f + 1)) / 2 ? -1 : 1, d = s.index(f) + (p > 0 ? 1 : 0), m = s.node(f), y = !1;
      if (c == 1)
        y = m.canReplace(d, d, l);
      else {
        let S = m.contentMatchAt(d).findWrapping(l.firstChild.type);
        y = S && m.canReplaceWith(d, d, S[0]);
      }
      if (y)
        return p == 0 ? s.pos : p < 0 ? s.before(f + 1) : s.after(f + 1);
    }
  return null;
}
function E3(i, e, r = e, s = ur.empty) {
  if (e == r && !s.size)
    return null;
  let l = i.resolve(e), c = i.resolve(r);
  return ZV(l, c, s) ? new Ji(e, r, s) : new ree(l, c, s).fit();
}
function ZV(i, e, r) {
  return !r.openStart && !r.openEnd && i.start() == e.start() && i.parent.canReplace(i.index(), e.index(), r.content);
}
class ree {
  constructor(e, r, s) {
    this.$from = e, this.$to = r, this.unplaced = s, this.frontier = [], this.placed = qt.empty;
    for (let l = 0; l <= e.depth; l++) {
      let c = e.node(l);
      this.frontier.push({
        type: c.type,
        match: c.contentMatchAt(e.indexAfter(l))
      });
    }
    for (let l = e.depth; l > 0; l--)
      this.placed = qt.from(e.node(l).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let m = this.findFittable();
      m ? this.placeNodes(m) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), r = this.placed.size - this.depth - this.$from.depth, s = this.$from, l = this.close(e < 0 ? this.$to : s.doc.resolve(e));
    if (!l)
      return null;
    let c = this.placed, f = s.depth, p = l.depth;
    for (; f && p && c.childCount == 1; )
      c = c.firstChild.content, f--, p--;
    let d = new ur(c, f, p);
    return e > -1 ? new mi(s.pos, e, this.$to.pos, this.$to.end(), d, r) : d.size || s.pos != this.$to.pos ? new Ji(s.pos, l.pos, d) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let r = this.unplaced.content, s = 0, l = this.unplaced.openEnd; s < e; s++) {
      let c = r.firstChild;
      if (r.childCount > 1 && (l = 0), c.type.spec.isolating && l <= s) {
        e = s;
        break;
      }
      r = c.content;
    }
    for (let r = 1; r <= 2; r++)
      for (let s = r == 1 ? e : this.unplaced.openStart; s >= 0; s--) {
        let l, c = null;
        s ? (c = jH(this.unplaced.content, s - 1).firstChild, l = c.content) : l = this.unplaced.content;
        let f = l.firstChild;
        for (let p = this.depth; p >= 0; p--) {
          let { type: d, match: m } = this.frontier[p], y, S = null;
          if (r == 1 && (f ? m.matchType(f.type) || (S = m.fillBefore(qt.from(f), !1)) : c && d.compatibleContent(c.type)))
            return { sliceDepth: s, frontierDepth: p, parent: c, inject: S };
          if (r == 2 && f && (y = m.findWrapping(f.type)))
            return { sliceDepth: s, frontierDepth: p, parent: c, wrap: y };
          if (c && m.matchType(c.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: r, openEnd: s } = this.unplaced, l = jH(e, r);
    return !l.childCount || l.firstChild.isLeaf ? !1 : (this.unplaced = new ur(e, r + 1, Math.max(s, l.size + r >= e.size - s ? r + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: r, openEnd: s } = this.unplaced, l = jH(e, r);
    if (l.childCount <= 1 && r > 0) {
      let c = e.size - r <= r + l.size;
      this.unplaced = new ur(Fg(e, r - 1, 1), r - 1, c ? r - 1 : s);
    } else
      this.unplaced = new ur(Fg(e, r, 1), r, s);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: r, parent: s, inject: l, wrap: c }) {
    for (; this.depth > r; )
      this.closeFrontierNode();
    if (c)
      for (let O = 0; O < c.length; O++)
        this.openFrontierNode(c[O]);
    let f = this.unplaced, p = s ? s.content : f.content, d = f.openStart - e, m = 0, y = [], { match: S, type: x } = this.frontier[r];
    if (l) {
      for (let O = 0; O < l.childCount; O++)
        y.push(l.child(O));
      S = S.matchFragment(l);
    }
    let w = p.size + e - (f.content.size - f.openEnd);
    for (; m < p.childCount; ) {
      let O = p.child(m), T = S.matchType(O.type);
      if (!T)
        break;
      m++, (m > 1 || d == 0 || O.content.size) && (S = T, y.push(QV(O.mark(x.allowedMarks(O.marks)), m == 1 ? d : 0, m == p.childCount ? w : -1)));
    }
    let k = m == p.childCount;
    k || (w = -1), this.placed = zg(this.placed, r, qt.from(y)), this.frontier[r].match = S, k && w < 0 && s && s.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let O = 0, T = p; O < w; O++) {
      let L = T.lastChild;
      this.frontier.push({ type: L.type, match: L.contentMatchAt(L.childCount) }), T = L.content;
    }
    this.unplaced = k ? e == 0 ? ur.empty : new ur(Fg(f.content, e - 1, 1), e - 1, w < 0 ? f.openEnd : e - 1) : new ur(Fg(f.content, e, m), f.openStart, f.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], r;
    if (!e.type.isTextblock || !WH(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (r = this.findCloseLevel(this.$to)) && r.depth == this.depth)
      return -1;
    let { depth: s } = this.$to, l = this.$to.after(s);
    for (; s > 1 && l == this.$to.end(--s); )
      ++l;
    return l;
  }
  findCloseLevel(e) {
    e: for (let r = Math.min(this.depth, e.depth); r >= 0; r--) {
      let { match: s, type: l } = this.frontier[r], c = r < e.depth && e.end(r + 1) == e.pos + (e.depth - (r + 1)), f = WH(e, r, l, s, c);
      if (f) {
        for (let p = r - 1; p >= 0; p--) {
          let { match: d, type: m } = this.frontier[p], y = WH(e, p, m, d, !0);
          if (!y || y.childCount)
            continue e;
        }
        return { depth: r, fit: f, move: c ? e.doc.resolve(e.after(r + 1)) : e };
      }
    }
  }
  close(e) {
    let r = this.findCloseLevel(e);
    if (!r)
      return null;
    for (; this.depth > r.depth; )
      this.closeFrontierNode();
    r.fit.childCount && (this.placed = zg(this.placed, r.depth, r.fit)), e = r.move;
    for (let s = r.depth + 1; s <= e.depth; s++) {
      let l = e.node(s), c = l.type.contentMatch.fillBefore(l.content, !0, e.index(s));
      this.openFrontierNode(l.type, l.attrs, c);
    }
    return e;
  }
  openFrontierNode(e, r = null, s) {
    let l = this.frontier[this.depth];
    l.match = l.match.matchType(e), this.placed = zg(this.placed, this.depth, qt.from(e.create(r, s))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let r = this.frontier.pop().match.fillBefore(qt.empty, !0);
    r.childCount && (this.placed = zg(this.placed, this.frontier.length, r));
  }
}
function Fg(i, e, r) {
  return e == 0 ? i.cutByIndex(r, i.childCount) : i.replaceChild(0, i.firstChild.copy(Fg(i.firstChild.content, e - 1, r)));
}
function zg(i, e, r) {
  return e == 0 ? i.append(r) : i.replaceChild(i.childCount - 1, i.lastChild.copy(zg(i.lastChild.content, e - 1, r)));
}
function jH(i, e) {
  for (let r = 0; r < e; r++)
    i = i.firstChild.content;
  return i;
}
function QV(i, e, r) {
  if (e <= 0)
    return i;
  let s = i.content;
  return e > 1 && (s = s.replaceChild(0, QV(s.firstChild, e - 1, s.childCount == 1 ? r - 1 : 0))), e > 0 && (s = i.type.contentMatch.fillBefore(s).append(s), r <= 0 && (s = s.append(i.type.contentMatch.matchFragment(s).fillBefore(qt.empty, !0)))), i.copy(s);
}
function WH(i, e, r, s, l) {
  let c = i.node(e), f = l ? i.indexAfter(e) : i.index(e);
  if (f == c.childCount && !r.compatibleContent(c.type))
    return null;
  let p = s.fillBefore(c.content, !0, f);
  return p && !nee(r, c.content, f) ? p : null;
}
function nee(i, e, r) {
  for (let s = r; s < e.childCount; s++)
    if (!i.allowsMarks(e.child(s).marks))
      return !0;
  return !1;
}
function iee(i) {
  return i.spec.defining || i.spec.definingForContent;
}
function aee(i, e, r, s) {
  if (!s.size)
    return i.deleteRange(e, r);
  let l = i.doc.resolve(e), c = i.doc.resolve(r);
  if (ZV(l, c, s))
    return i.step(new Ji(e, r, s));
  let f = t6(l, i.doc.resolve(r));
  f[f.length - 1] == 0 && f.pop();
  let p = -(l.depth + 1);
  f.unshift(p);
  for (let x = l.depth, w = l.pos - 1; x > 0; x--, w--) {
    let k = l.node(x).type.spec;
    if (k.defining || k.definingAsContext || k.isolating)
      break;
    f.indexOf(x) > -1 ? p = x : l.before(x) == w && f.splice(1, 0, -x);
  }
  let d = f.indexOf(p), m = [], y = s.openStart;
  for (let x = s.content, w = 0; ; w++) {
    let k = x.firstChild;
    if (m.push(k), w == s.openStart)
      break;
    x = k.content;
  }
  for (let x = y - 1; x >= 0; x--) {
    let w = m[x], k = iee(w.type);
    if (k && !w.sameMarkup(l.node(Math.abs(p) - 1)))
      y = x;
    else if (k || !w.type.isTextblock)
      break;
  }
  for (let x = s.openStart; x >= 0; x--) {
    let w = (x + y + 1) % (s.openStart + 1), k = m[w];
    if (k)
      for (let O = 0; O < f.length; O++) {
        let T = f[(O + d) % f.length], L = !0;
        T < 0 && (L = !1, T = -T);
        let j = l.node(T - 1), z = l.index(T - 1);
        if (j.canReplaceWith(z, z, k.type, k.marks))
          return i.replace(l.before(T), L ? c.after(T) : r, new ur(e6(s.content, 0, s.openStart, w), w, s.openEnd));
      }
  }
  let S = i.steps.length;
  for (let x = f.length - 1; x >= 0 && (i.replace(e, r, s), !(i.steps.length > S)); x--) {
    let w = f[x];
    w < 0 || (e = l.before(w), r = c.after(w));
  }
}
function e6(i, e, r, s, l) {
  if (e < r) {
    let c = i.firstChild;
    i = i.replaceChild(0, c.copy(e6(c.content, e + 1, r, s, c)));
  }
  if (e > s) {
    let c = l.contentMatchAt(0), f = c.fillBefore(i).append(i);
    i = f.append(c.matchFragment(f).fillBefore(qt.empty, !0));
  }
  return i;
}
function oee(i, e, r, s) {
  if (!s.isInline && e == r && i.doc.resolve(e).parent.content.size) {
    let l = eee(i.doc, e, s.type);
    l != null && (e = r = l);
  }
  i.replaceRange(e, r, new ur(qt.from(s), 0, 0));
}
function see(i, e, r) {
  let s = i.doc.resolve(e), l = i.doc.resolve(r), c = t6(s, l);
  for (let f = 0; f < c.length; f++) {
    let p = c[f], d = f == c.length - 1;
    if (d && p == 0 || s.node(p).type.contentMatch.validEnd)
      return i.delete(s.start(p), l.end(p));
    if (p > 0 && (d || s.node(p - 1).canReplace(s.index(p - 1), l.indexAfter(p - 1))))
      return i.delete(s.before(p), l.after(p));
  }
  for (let f = 1; f <= s.depth && f <= l.depth; f++)
    if (e - s.start(f) == s.depth - f && r > s.end(f) && l.end(f) - r != l.depth - f)
      return i.delete(s.before(f), r);
  i.delete(e, r);
}
function t6(i, e) {
  let r = [], s = Math.min(i.depth, e.depth);
  for (let l = s; l >= 0; l--) {
    let c = i.start(l);
    if (c < i.pos - (i.depth - l) || e.end(l) > e.pos + (e.depth - l) || i.node(l).type.spec.isolating || e.node(l).type.spec.isolating)
      break;
    (c == e.start(l) || l == i.depth && l == e.depth && i.parent.inlineContent && e.parent.inlineContent && l && e.start(l - 1) == c - 1) && r.push(l);
  }
  return r;
}
class sp extends ja {
  /**
  Construct an attribute step.
  */
  constructor(e, r, s) {
    super(), this.pos = e, this.attr = r, this.value = s;
  }
  apply(e) {
    let r = e.nodeAt(this.pos);
    if (!r)
      return fi.fail("No node at attribute step's position");
    let s = /* @__PURE__ */ Object.create(null);
    for (let c in r.attrs)
      s[c] = r.attrs[c];
    s[this.attr] = this.value;
    let l = r.type.create(s, null, r.marks);
    return fi.fromReplace(e, this.pos, this.pos + 1, new ur(qt.from(l), 0, r.isLeaf ? 0 : 1));
  }
  getMap() {
    return fo.empty;
  }
  invert(e) {
    return new sp(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let r = e.mapResult(this.pos, 1);
    return r.deletedAfter ? null : new sp(r.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, r) {
    if (typeof r.pos != "number" || typeof r.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new sp(r.pos, r.attr, r.value);
  }
}
ja.jsonID("attr", sp);
let cp = class extends Error {
};
cp = function i(e) {
  let r = Error.call(this, e);
  return r.__proto__ = i.prototype, r;
};
cp.prototype = Object.create(Error.prototype);
cp.prototype.constructor = cp;
cp.prototype.name = "TransformError";
class lee {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new ap();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let r = this.maybeStep(e);
    if (r.failed)
      throw new cp(r.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let r = e.apply(this.doc);
    return r.failed || this.addStep(e, r.doc), r;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, r) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = r;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, r = e, s = ur.empty) {
    let l = E3(this.doc, e, r, s);
    return l && this.step(l), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, r, s) {
    return this.replace(e, r, new ur(qt.from(s), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, r) {
    return this.replace(e, r, ur.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, r) {
    return this.replaceWith(e, e, r);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, r, s) {
    return aee(this, e, r, s), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, r, s) {
    return oee(this, e, r, s), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, r) {
    return see(this, e, r), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, r) {
    return $Q(this, e, r), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, r = 1) {
    return QQ(this, e, r), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, r) {
    return YQ(this, e, r), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, r = e, s, l = null) {
    return qQ(this, e, r, s, l), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, r, s = null, l) {
    return XQ(this, e, r, s, l), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  */
  setNodeAttribute(e, r, s) {
    return this.step(new sp(e, r, s)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, r) {
    return this.step(new Ou(e, r)), this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, r) {
    if (!(r instanceof Qr)) {
      let s = this.doc.nodeAt(e);
      if (!s)
        throw new RangeError("No node at position " + e);
      if (r = r.isInSet(s.marks), !r)
        return this;
    }
    return this.step(new up(e, r)), this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(e, r = 1, s) {
    return JQ(this, e, r, s), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, r, s) {
    return zQ(this, e, r, s), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, r, s) {
    return HQ(this, e, r, s), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, r, s) {
    return jQ(this, e, r, s), this;
  }
}
const $H = /* @__PURE__ */ Object.create(null);
class jr {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, r, s) {
    this.$anchor = e, this.$head = r, this.ranges = s || [new r6(e.min(r), e.max(r))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let r = 0; r < e.length; r++)
      if (e[r].$from.pos != e[r].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, r = ur.empty) {
    let s = r.content.lastChild, l = null;
    for (let p = 0; p < r.openEnd; p++)
      l = s, s = s.lastChild;
    let c = e.steps.length, f = this.ranges;
    for (let p = 0; p < f.length; p++) {
      let { $from: d, $to: m } = f[p], y = e.mapping.slice(c);
      e.replaceRange(y.map(d.pos), y.map(m.pos), p ? ur.empty : r), p == 0 && oU(e, c, (s ? s.isInline : l && l.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, r) {
    let s = e.steps.length, l = this.ranges;
    for (let c = 0; c < l.length; c++) {
      let { $from: f, $to: p } = l[c], d = e.mapping.slice(s), m = d.map(f.pos), y = d.map(p.pos);
      c ? e.deleteRange(m, y) : (e.replaceRangeWith(m, y, r), oU(e, s, r.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, r, s = !1) {
    let l = e.parent.inlineContent ? new Zr(e) : ep(e.node(0), e.parent, e.pos, e.index(), r, s);
    if (l)
      return l;
    for (let c = e.depth - 1; c >= 0; c--) {
      let f = r < 0 ? ep(e.node(0), e.node(c), e.before(c + 1), e.index(c), r, s) : ep(e.node(0), e.node(c), e.after(c + 1), e.index(c) + 1, r, s);
      if (f)
        return f;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, r = 1) {
    return this.findFrom(e, r) || this.findFrom(e, -r) || new ma(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return ep(e, e, 0, 0, 1) || new ma(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return ep(e, e, e.content.size, e.childCount, -1) || new ma(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, r) {
    if (!r || !r.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let s = $H[r.type];
    if (!s)
      throw new RangeError(`No selection type ${r.type} defined`);
    return s.fromJSON(e, r);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, r) {
    if (e in $H)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return $H[e] = r, r.prototype.jsonID = e, r;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return Zr.between(this.$anchor, this.$head).getBookmark();
  }
}
jr.prototype.visible = !0;
class r6 {
  /**
  Create a range.
  */
  constructor(e, r) {
    this.$from = e, this.$to = r;
  }
}
let iU = !1;
function aU(i) {
  !iU && !i.parent.inlineContent && (iU = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + i.parent.type.name + ")"));
}
class Zr extends jr {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, r = e) {
    aU(e), aU(r), super(e, r);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, r) {
    let s = e.resolve(r.map(this.head));
    if (!s.parent.inlineContent)
      return jr.near(s);
    let l = e.resolve(r.map(this.anchor));
    return new Zr(l.parent.inlineContent ? l : s, s);
  }
  replace(e, r = ur.empty) {
    if (super.replace(e, r), r == ur.empty) {
      let s = this.$from.marksAcross(this.$to);
      s && e.ensureMarks(s);
    }
  }
  eq(e) {
    return e instanceof Zr && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new _x(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, r) {
    if (typeof r.anchor != "number" || typeof r.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new Zr(e.resolve(r.anchor), e.resolve(r.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, r, s = r) {
    let l = e.resolve(r);
    return new this(l, s == r ? l : e.resolve(s));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, r, s) {
    let l = e.pos - r.pos;
    if ((!s || l) && (s = l >= 0 ? 1 : -1), !r.parent.inlineContent) {
      let c = jr.findFrom(r, s, !0) || jr.findFrom(r, -s, !0);
      if (c)
        r = c.$head;
      else
        return jr.near(r, s);
    }
    return e.parent.inlineContent || (l == 0 ? e = r : (e = (jr.findFrom(e, -s, !0) || jr.findFrom(e, s, !0)).$anchor, e.pos < r.pos != l < 0 && (e = r))), new Zr(e, r);
  }
}
jr.jsonID("text", Zr);
class _x {
  constructor(e, r) {
    this.anchor = e, this.head = r;
  }
  map(e) {
    return new _x(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return Zr.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class Er extends jr {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let r = e.nodeAfter, s = e.node(0).resolve(e.pos + r.nodeSize);
    super(e, s), this.node = r;
  }
  map(e, r) {
    let { deleted: s, pos: l } = r.mapResult(this.anchor), c = e.resolve(l);
    return s ? jr.near(c) : new Er(c);
  }
  content() {
    return new ur(qt.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof Er && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new M3(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, r) {
    if (typeof r.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new Er(e.resolve(r.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, r) {
    return new Er(e.resolve(r));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
Er.prototype.visible = !1;
jr.jsonID("node", Er);
class M3 {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: r, pos: s } = e.mapResult(this.anchor);
    return r ? new _x(s, s) : new M3(s);
  }
  resolve(e) {
    let r = e.resolve(this.anchor), s = r.nodeAfter;
    return s && Er.isSelectable(s) ? new Er(r) : jr.near(r);
  }
}
class ma extends jr {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, r = ur.empty) {
    if (r == ur.empty) {
      e.delete(0, e.doc.content.size);
      let s = jr.atStart(e.doc);
      s.eq(e.selection) || e.setSelection(s);
    } else
      super.replace(e, r);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new ma(e);
  }
  map(e) {
    return new ma(e);
  }
  eq(e) {
    return e instanceof ma;
  }
  getBookmark() {
    return uee;
  }
}
jr.jsonID("all", ma);
const uee = {
  map() {
    return this;
  },
  resolve(i) {
    return new ma(i);
  }
};
function ep(i, e, r, s, l, c = !1) {
  if (e.inlineContent)
    return Zr.create(i, r);
  for (let f = s - (l > 0 ? 0 : 1); l > 0 ? f < e.childCount : f >= 0; f += l) {
    let p = e.child(f);
    if (p.isAtom) {
      if (!c && Er.isSelectable(p))
        return Er.create(i, r - (l < 0 ? p.nodeSize : 0));
    } else {
      let d = ep(i, p, r + l, l < 0 ? p.childCount : 0, l, c);
      if (d)
        return d;
    }
    r += p.nodeSize * l;
  }
  return null;
}
function oU(i, e, r) {
  let s = i.steps.length - 1;
  if (s < e)
    return;
  let l = i.steps[s];
  if (!(l instanceof Ji || l instanceof mi))
    return;
  let c = i.mapping.maps[s], f;
  c.forEach((p, d, m, y) => {
    f == null && (f = y);
  }), i.setSelection(jr.near(i.doc.resolve(f), r));
}
const sU = 1, lU = 2, uU = 4;
class cee extends lee {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | sU) & -3, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & sU) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= lU, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return Qr.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & lU) > 0;
  }
  /**
  @internal
  */
  addStep(e, r) {
    super.addStep(e, r), this.updated = this.updated & -3, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, r = !0) {
    let s = this.selection;
    return r && (e = e.mark(this.storedMarks || (s.empty ? s.$from.marks() : s.$from.marksAcross(s.$to) || Qr.none))), s.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, r, s) {
    let l = this.doc.type.schema;
    if (r == null)
      return e ? this.replaceSelectionWith(l.text(e), !0) : this.deleteSelection();
    {
      if (s == null && (s = r), s = s ?? r, !e)
        return this.deleteRange(r, s);
      let c = this.storedMarks;
      if (!c) {
        let f = this.doc.resolve(r);
        c = s == r ? f.marks() : f.marksAcross(this.doc.resolve(s));
      }
      return this.replaceRangeWith(r, s, l.text(e, c)), this.selection.empty || this.setSelection(jr.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, r) {
    return this.meta[typeof e == "string" ? e : e.key] = r, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= uU, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & uU) > 0;
  }
}
function cU(i, e) {
  return !e || !i ? i : i.bind(e);
}
class Hg {
  constructor(e, r, s) {
    this.name = e, this.init = cU(r.init, s), this.apply = cU(r.apply, s);
  }
}
const fee = [
  new Hg("doc", {
    init(i) {
      return i.doc || i.schema.topNodeType.createAndFill();
    },
    apply(i) {
      return i.doc;
    }
  }),
  new Hg("selection", {
    init(i, e) {
      return i.selection || jr.atStart(e.doc);
    },
    apply(i) {
      return i.selection;
    }
  }),
  new Hg("storedMarks", {
    init(i) {
      return i.storedMarks || null;
    },
    apply(i, e, r, s) {
      return s.selection.$cursor ? i.storedMarks : null;
    }
  }),
  new Hg("scrollToSelection", {
    init() {
      return 0;
    },
    apply(i, e) {
      return i.scrolledIntoView ? e + 1 : e;
    }
  })
];
class UH {
  constructor(e, r) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = fee.slice(), r && r.forEach((s) => {
      if (this.pluginsByKey[s.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + s.key + ")");
      this.plugins.push(s), this.pluginsByKey[s.key] = s, s.spec.state && this.fields.push(new Hg(s.key, s.spec.state, s));
    });
  }
}
class Rc {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, r = -1) {
    for (let s = 0; s < this.config.plugins.length; s++)
      if (s != r) {
        let l = this.config.plugins[s];
        if (l.spec.filterTransaction && !l.spec.filterTransaction.call(l, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let r = [e], s = this.applyInner(e), l = null;
    for (; ; ) {
      let c = !1;
      for (let f = 0; f < this.config.plugins.length; f++) {
        let p = this.config.plugins[f];
        if (p.spec.appendTransaction) {
          let d = l ? l[f].n : 0, m = l ? l[f].state : this, y = d < r.length && p.spec.appendTransaction.call(p, d ? r.slice(d) : r, m, s);
          if (y && s.filterTransaction(y, f)) {
            if (y.setMeta("appendedTransaction", e), !l) {
              l = [];
              for (let S = 0; S < this.config.plugins.length; S++)
                l.push(S < f ? { state: s, n: r.length } : { state: this, n: 0 });
            }
            r.push(y), s = s.applyInner(y), c = !0;
          }
          l && (l[f] = { state: s, n: r.length });
        }
      }
      if (!c)
        return { state: s, transactions: r };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let r = new Rc(this.config), s = this.config.fields;
    for (let l = 0; l < s.length; l++) {
      let c = s[l];
      r[c.name] = c.apply(e, this[c.name], this, r);
    }
    return r;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new cee(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let r = new UH(e.doc ? e.doc.type.schema : e.schema, e.plugins), s = new Rc(r);
    for (let l = 0; l < r.fields.length; l++)
      s[r.fields[l].name] = r.fields[l].init(e, s);
    return s;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let r = new UH(this.schema, e.plugins), s = r.fields, l = new Rc(r);
    for (let c = 0; c < s.length; c++) {
      let f = s[c].name;
      l[f] = this.hasOwnProperty(f) ? this[f] : s[c].init(e, l);
    }
    return l;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let r = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (r.storedMarks = this.storedMarks.map((s) => s.toJSON())), e && typeof e == "object")
      for (let s in e) {
        if (s == "doc" || s == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let l = e[s], c = l.spec.state;
        c && c.toJSON && (r[s] = c.toJSON.call(l, this[l.key]));
      }
    return r;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, r, s) {
    if (!r)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let l = new UH(e.schema, e.plugins), c = new Rc(l);
    return l.fields.forEach((f) => {
      if (f.name == "doc")
        c.doc = Au.fromJSON(e.schema, r.doc);
      else if (f.name == "selection")
        c.selection = jr.fromJSON(c.doc, r.selection);
      else if (f.name == "storedMarks")
        r.storedMarks && (c.storedMarks = r.storedMarks.map(e.schema.markFromJSON));
      else {
        if (s)
          for (let p in s) {
            let d = s[p], m = d.spec.state;
            if (d.key == f.name && m && m.fromJSON && Object.prototype.hasOwnProperty.call(r, p)) {
              c[f.name] = m.fromJSON.call(d, e, r[p], c);
              return;
            }
          }
        c[f.name] = f.init(e, c);
      }
    }), c;
  }
}
function n6(i, e, r) {
  for (let s in i) {
    let l = i[s];
    l instanceof Function ? l = l.bind(e) : s == "handleDOMEvents" && (l = n6(l, e, {})), r[s] = l;
  }
  return r;
}
class Wa {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && n6(e.props, this, this.props), this.key = e.key ? e.key.key : i6("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const VH = /* @__PURE__ */ Object.create(null);
function i6(i) {
  return i in VH ? i + "$" + ++VH[i] : (VH[i] = 0, i + "$");
}
class ty {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = i6(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const va = function(i) {
  for (var e = 0; ; e++)
    if (i = i.previousSibling, !i)
      return e;
}, Kg = function(i) {
  let e = i.assignedSlot || i.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let fU = null;
const ml = function(i, e, r) {
  let s = fU || (fU = document.createRange());
  return s.setEnd(i, r ?? i.nodeValue.length), s.setStart(i, e || 0), s;
}, Hc = function(i, e, r, s) {
  return r && (dU(i, e, r, s, -1) || dU(i, e, r, s, 1));
}, dee = /^(img|br|input|textarea|hr)$/i;
function dU(i, e, r, s, l) {
  for (; ; ) {
    if (i == r && e == s)
      return !0;
    if (e == (l < 0 ? 0 : _s(i))) {
      let c = i.parentNode;
      if (!c || c.nodeType != 1 || R3(i) || dee.test(i.nodeName) || i.contentEditable == "false")
        return !1;
      e = va(i) + (l < 0 ? 0 : 1), i = c;
    } else if (i.nodeType == 1) {
      if (i = i.childNodes[e + (l < 0 ? -1 : 0)], i.contentEditable == "false")
        return !1;
      e = l < 0 ? _s(i) : 0;
    } else
      return !1;
  }
}
function _s(i) {
  return i.nodeType == 3 ? i.nodeValue.length : i.childNodes.length;
}
function hee(i, e, r) {
  for (let s = e == 0, l = e == _s(i); s || l; ) {
    if (i == r)
      return !0;
    let c = va(i);
    if (i = i.parentNode, !i)
      return !1;
    s = s && c == 0, l = l && c == _s(i);
  }
}
function R3(i) {
  let e;
  for (let r = i; r && !(e = r.pmViewDesc); r = r.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == i || e.contentDOM == i);
}
const Nx = function(i) {
  return i.focusNode && Hc(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset);
};
function Ec(i, e) {
  let r = document.createEvent("Event");
  return r.initEvent("keydown", !0, !0), r.keyCode = i, r.key = r.code = e, r;
}
function pee(i) {
  let e = i.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function vee(i, e, r) {
  if (i.caretPositionFromPoint)
    try {
      let s = i.caretPositionFromPoint(e, r);
      if (s)
        return { node: s.offsetNode, offset: s.offset };
    } catch {
    }
  if (i.caretRangeFromPoint) {
    let s = i.caretRangeFromPoint(e, r);
    if (s)
      return { node: s.startContainer, offset: s.startOffset };
  }
}
const zs = typeof navigator < "u" ? navigator : null, hU = typeof document < "u" ? document : null, _u = zs && zs.userAgent || "", Vj = /Edge\/(\d+)/.exec(_u), a6 = /MSIE \d/.exec(_u), Gj = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(_u), za = !!(a6 || Gj || Vj), Eu = a6 ? document.documentMode : Gj ? +Gj[1] : Vj ? +Vj[1] : 0, ps = !za && /gecko\/(\d+)/i.test(_u);
ps && +(/Firefox\/(\d+)/.exec(_u) || [0, 0])[1];
const Yj = !za && /Chrome\/(\d+)/.exec(_u), Zi = !!Yj, mee = Yj ? +Yj[1] : 0, ga = !za && !!zs && /Apple Computer/.test(zs.vendor), fp = ga && (/Mobile\/\w+/.test(_u) || !!zs && zs.maxTouchPoints > 2), Lo = fp || (zs ? /Mac/.test(zs.platform) : !1), gee = zs ? /Win/.test(zs.platform) : !1, us = /Android \d/.test(_u), Bx = !!hU && "webkitFontSmoothing" in hU.documentElement.style, yee = Bx ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function bee(i) {
  return {
    left: 0,
    right: i.documentElement.clientWidth,
    top: 0,
    bottom: i.documentElement.clientHeight
  };
}
function hl(i, e) {
  return typeof i == "number" ? i : i[e];
}
function See(i) {
  let e = i.getBoundingClientRect(), r = e.width / i.offsetWidth || 1, s = e.height / i.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + i.clientWidth * r,
    top: e.top,
    bottom: e.top + i.clientHeight * s
  };
}
function pU(i, e, r) {
  let s = i.someProp("scrollThreshold") || 0, l = i.someProp("scrollMargin") || 5, c = i.dom.ownerDocument;
  for (let f = r || i.dom; f; f = Kg(f)) {
    if (f.nodeType != 1)
      continue;
    let p = f, d = p == c.body, m = d ? bee(c) : See(p), y = 0, S = 0;
    if (e.top < m.top + hl(s, "top") ? S = -(m.top - e.top + hl(l, "top")) : e.bottom > m.bottom - hl(s, "bottom") && (S = e.bottom - e.top > m.bottom - m.top ? e.top + hl(l, "top") - m.top : e.bottom - m.bottom + hl(l, "bottom")), e.left < m.left + hl(s, "left") ? y = -(m.left - e.left + hl(l, "left")) : e.right > m.right - hl(s, "right") && (y = e.right - m.right + hl(l, "right")), y || S)
      if (d)
        c.defaultView.scrollBy(y, S);
      else {
        let x = p.scrollLeft, w = p.scrollTop;
        S && (p.scrollTop += S), y && (p.scrollLeft += y);
        let k = p.scrollLeft - x, O = p.scrollTop - w;
        e = { left: e.left - k, top: e.top - O, right: e.right - k, bottom: e.bottom - O };
      }
    if (d || /^(fixed|sticky)$/.test(getComputedStyle(f).position))
      break;
  }
}
function wee(i) {
  let e = i.dom.getBoundingClientRect(), r = Math.max(0, e.top), s, l;
  for (let c = (e.left + e.right) / 2, f = r + 1; f < Math.min(innerHeight, e.bottom); f += 5) {
    let p = i.root.elementFromPoint(c, f);
    if (!p || p == i.dom || !i.dom.contains(p))
      continue;
    let d = p.getBoundingClientRect();
    if (d.top >= r - 20) {
      s = p, l = d.top;
      break;
    }
  }
  return { refDOM: s, refTop: l, stack: o6(i.dom) };
}
function o6(i) {
  let e = [], r = i.ownerDocument;
  for (let s = i; s && (e.push({ dom: s, top: s.scrollTop, left: s.scrollLeft }), i != r); s = Kg(s))
    ;
  return e;
}
function xee({ refDOM: i, refTop: e, stack: r }) {
  let s = i ? i.getBoundingClientRect().top : 0;
  s6(r, s == 0 ? 0 : s - e);
}
function s6(i, e) {
  for (let r = 0; r < i.length; r++) {
    let { dom: s, top: l, left: c } = i[r];
    s.scrollTop != l + e && (s.scrollTop = l + e), s.scrollLeft != c && (s.scrollLeft = c);
  }
}
let Kh = null;
function kee(i) {
  if (i.setActive)
    return i.setActive();
  if (Kh)
    return i.focus(Kh);
  let e = o6(i);
  i.focus(Kh == null ? {
    get preventScroll() {
      return Kh = { preventScroll: !0 }, !0;
    }
  } : void 0), Kh || (Kh = !1, s6(e, 0));
}
function l6(i, e) {
  let r, s = 2e8, l, c = 0, f = e.top, p = e.top, d, m;
  for (let y = i.firstChild, S = 0; y; y = y.nextSibling, S++) {
    let x;
    if (y.nodeType == 1)
      x = y.getClientRects();
    else if (y.nodeType == 3)
      x = ml(y).getClientRects();
    else
      continue;
    for (let w = 0; w < x.length; w++) {
      let k = x[w];
      if (k.top <= f && k.bottom >= p) {
        f = Math.max(k.bottom, f), p = Math.min(k.top, p);
        let O = k.left > e.left ? k.left - e.left : k.right < e.left ? e.left - k.right : 0;
        if (O < s) {
          r = y, s = O, l = O && r.nodeType == 3 ? {
            left: k.right < e.left ? k.right : k.left,
            top: e.top
          } : e, y.nodeType == 1 && O && (c = S + (e.left >= (k.left + k.right) / 2 ? 1 : 0));
          continue;
        }
      } else k.top > e.top && !d && k.left <= e.left && k.right >= e.left && (d = y, m = { left: Math.max(k.left, Math.min(k.right, e.left)), top: k.top });
      !r && (e.left >= k.right && e.top >= k.top || e.left >= k.left && e.top >= k.bottom) && (c = S + 1);
    }
  }
  return !r && d && (r = d, l = m, s = 0), r && r.nodeType == 3 ? Oee(r, l) : !r || s && r.nodeType == 1 ? { node: i, offset: c } : l6(r, l);
}
function Oee(i, e) {
  let r = i.nodeValue.length, s = document.createRange();
  for (let l = 0; l < r; l++) {
    s.setEnd(i, l + 1), s.setStart(i, l);
    let c = bu(s, 1);
    if (c.top != c.bottom && D3(e, c))
      return { node: i, offset: l + (e.left >= (c.left + c.right) / 2 ? 1 : 0) };
  }
  return { node: i, offset: 0 };
}
function D3(i, e) {
  return i.left >= e.left - 1 && i.left <= e.right + 1 && i.top >= e.top - 1 && i.top <= e.bottom + 1;
}
function Cee(i, e) {
  let r = i.parentNode;
  return r && /^li$/i.test(r.nodeName) && e.left < i.getBoundingClientRect().left ? r : i;
}
function Tee(i, e, r) {
  let { node: s, offset: l } = l6(e, r), c = -1;
  if (s.nodeType == 1 && !s.firstChild) {
    let f = s.getBoundingClientRect();
    c = f.left != f.right && r.left > (f.left + f.right) / 2 ? 1 : -1;
  }
  return i.docView.posFromDOM(s, l, c);
}
function Aee(i, e, r, s) {
  let l = -1;
  for (let c = e, f = !1; c != i.dom; ) {
    let p = i.docView.nearestDesc(c, !0);
    if (!p)
      return null;
    if (p.dom.nodeType == 1 && (p.node.isBlock && p.parent && !f || !p.contentDOM)) {
      let d = p.dom.getBoundingClientRect();
      if (p.node.isBlock && p.parent && !f && (f = !0, d.left > s.left || d.top > s.top ? l = p.posBefore : (d.right < s.left || d.bottom < s.top) && (l = p.posAfter)), !p.contentDOM && l < 0 && !p.node.isText)
        return (p.node.isBlock ? s.top < (d.top + d.bottom) / 2 : s.left < (d.left + d.right) / 2) ? p.posBefore : p.posAfter;
    }
    c = p.dom.parentNode;
  }
  return l > -1 ? l : i.docView.posFromDOM(e, r, -1);
}
function u6(i, e, r) {
  let s = i.childNodes.length;
  if (s && r.top < r.bottom)
    for (let l = Math.max(0, Math.min(s - 1, Math.floor(s * (e.top - r.top) / (r.bottom - r.top)) - 2)), c = l; ; ) {
      let f = i.childNodes[c];
      if (f.nodeType == 1) {
        let p = f.getClientRects();
        for (let d = 0; d < p.length; d++) {
          let m = p[d];
          if (D3(e, m))
            return u6(f, e, m);
        }
      }
      if ((c = (c + 1) % s) == l)
        break;
    }
  return i;
}
function Eee(i, e) {
  let r = i.dom.ownerDocument, s, l = 0, c = vee(r, e.left, e.top);
  c && ({ node: s, offset: l } = c);
  let f = (i.root.elementFromPoint ? i.root : r).elementFromPoint(e.left, e.top), p;
  if (!f || !i.dom.contains(f.nodeType != 1 ? f.parentNode : f)) {
    let m = i.dom.getBoundingClientRect();
    if (!D3(e, m) || (f = u6(i.dom, e, m), !f))
      return null;
  }
  if (ga)
    for (let m = f; s && m; m = Kg(m))
      m.draggable && (s = void 0);
  if (f = Cee(f, e), s) {
    if (ps && s.nodeType == 1 && (l = Math.min(l, s.childNodes.length), l < s.childNodes.length)) {
      let m = s.childNodes[l], y;
      m.nodeName == "IMG" && (y = m.getBoundingClientRect()).right <= e.left && y.bottom > e.top && l++;
    }
    s == i.dom && l == s.childNodes.length - 1 && s.lastChild.nodeType == 1 && e.top > s.lastChild.getBoundingClientRect().bottom ? p = i.state.doc.content.size : (l == 0 || s.nodeType != 1 || s.childNodes[l - 1].nodeName != "BR") && (p = Aee(i, s, l, e));
  }
  p == null && (p = Tee(i, f, e));
  let d = i.docView.nearestDesc(f, !0);
  return { pos: p, inside: d ? d.posAtStart - d.border : -1 };
}
function vU(i) {
  return i.top < i.bottom || i.left < i.right;
}
function bu(i, e) {
  let r = i.getClientRects();
  if (r.length) {
    let s = r[e < 0 ? 0 : r.length - 1];
    if (vU(s))
      return s;
  }
  return Array.prototype.find.call(r, vU) || i.getBoundingClientRect();
}
const Mee = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function c6(i, e, r) {
  let { node: s, offset: l, atom: c } = i.docView.domFromPos(e, r < 0 ? -1 : 1), f = Bx || ps;
  if (s.nodeType == 3)
    if (f && (Mee.test(s.nodeValue) || (r < 0 ? !l : l == s.nodeValue.length))) {
      let d = bu(ml(s, l, l), r);
      if (ps && l && /\s/.test(s.nodeValue[l - 1]) && l < s.nodeValue.length) {
        let m = bu(ml(s, l - 1, l - 1), -1);
        if (m.top == d.top) {
          let y = bu(ml(s, l, l + 1), -1);
          if (y.top != d.top)
            return Rg(y, y.left < m.left);
        }
      }
      return d;
    } else {
      let d = l, m = l, y = r < 0 ? 1 : -1;
      return r < 0 && !l ? (m++, y = -1) : r >= 0 && l == s.nodeValue.length ? (d--, y = 1) : r < 0 ? d-- : m++, Rg(bu(ml(s, d, m), y), y < 0);
    }
  if (!i.state.doc.resolve(e - (c || 0)).parent.inlineContent) {
    if (c == null && l && (r < 0 || l == _s(s))) {
      let d = s.childNodes[l - 1];
      if (d.nodeType == 1)
        return GH(d.getBoundingClientRect(), !1);
    }
    if (c == null && l < _s(s)) {
      let d = s.childNodes[l];
      if (d.nodeType == 1)
        return GH(d.getBoundingClientRect(), !0);
    }
    return GH(s.getBoundingClientRect(), r >= 0);
  }
  if (c == null && l && (r < 0 || l == _s(s))) {
    let d = s.childNodes[l - 1], m = d.nodeType == 3 ? ml(d, _s(d) - (f ? 0 : 1)) : d.nodeType == 1 && (d.nodeName != "BR" || !d.nextSibling) ? d : null;
    if (m)
      return Rg(bu(m, 1), !1);
  }
  if (c == null && l < _s(s)) {
    let d = s.childNodes[l];
    for (; d.pmViewDesc && d.pmViewDesc.ignoreForCoords; )
      d = d.nextSibling;
    let m = d ? d.nodeType == 3 ? ml(d, 0, f ? 0 : 1) : d.nodeType == 1 ? d : null : null;
    if (m)
      return Rg(bu(m, -1), !0);
  }
  return Rg(bu(s.nodeType == 3 ? ml(s) : s, -r), r >= 0);
}
function Rg(i, e) {
  if (i.width == 0)
    return i;
  let r = e ? i.left : i.right;
  return { top: i.top, bottom: i.bottom, left: r, right: r };
}
function GH(i, e) {
  if (i.height == 0)
    return i;
  let r = e ? i.top : i.bottom;
  return { top: r, bottom: r, left: i.left, right: i.right };
}
function f6(i, e, r) {
  let s = i.state, l = i.root.activeElement;
  s != e && i.updateState(e), l != i.dom && i.focus();
  try {
    return r();
  } finally {
    s != e && i.updateState(s), l != i.dom && l && l.focus();
  }
}
function Ree(i, e, r) {
  let s = e.selection, l = r == "up" ? s.$from : s.$to;
  return f6(i, e, () => {
    let { node: c } = i.docView.domFromPos(l.pos, r == "up" ? -1 : 1);
    for (; ; ) {
      let p = i.docView.nearestDesc(c, !0);
      if (!p)
        break;
      if (p.node.isBlock) {
        c = p.contentDOM || p.dom;
        break;
      }
      c = p.dom.parentNode;
    }
    let f = c6(i, l.pos, 1);
    for (let p = c.firstChild; p; p = p.nextSibling) {
      let d;
      if (p.nodeType == 1)
        d = p.getClientRects();
      else if (p.nodeType == 3)
        d = ml(p, 0, p.nodeValue.length).getClientRects();
      else
        continue;
      for (let m = 0; m < d.length; m++) {
        let y = d[m];
        if (y.bottom > y.top + 1 && (r == "up" ? f.top - y.top > (y.bottom - f.top) * 2 : y.bottom - f.bottom > (f.bottom - y.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const Dee = /[\u0590-\u08ac]/;
function Pee(i, e, r) {
  let { $head: s } = e.selection;
  if (!s.parent.isTextblock)
    return !1;
  let l = s.parentOffset, c = !l, f = l == s.parent.content.size, p = i.domSelection();
  return !Dee.test(s.parent.textContent) || !p.modify ? r == "left" || r == "backward" ? c : f : f6(i, e, () => {
    let { focusNode: d, focusOffset: m, anchorNode: y, anchorOffset: S } = i.domSelectionRange(), x = p.caretBidiLevel;
    p.modify("move", r, "character");
    let w = s.depth ? i.docView.domAfterPos(s.before()) : i.dom, { focusNode: k, focusOffset: O } = i.domSelectionRange(), T = k && !w.contains(k.nodeType == 1 ? k : k.parentNode) || d == k && m == O;
    try {
      p.collapse(y, S), d && (d != y || m != S) && p.extend && p.extend(d, m);
    } catch {
    }
    return x != null && (p.caretBidiLevel = x), T;
  });
}
let mU = null, gU = null, yU = !1;
function Lee(i, e, r) {
  return mU == e && gU == r ? yU : (mU = e, gU = r, yU = r == "up" || r == "down" ? Ree(i, e, r) : Pee(i, e, r));
}
const Io = 0, bU = 1, Dc = 2, Hs = 3;
class ry {
  constructor(e, r, s, l) {
    this.parent = e, this.children = r, this.dom = s, this.contentDOM = l, this.dirty = Io, s.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, r, s) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let r = 0; r < this.children.length; r++)
      e += this.children[r].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let r = 0, s = this.posAtStart; ; r++) {
      let l = this.children[r];
      if (l == e)
        return s;
      s += l.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, r, s) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (s < 0) {
        let c, f;
        if (e == this.contentDOM)
          c = e.childNodes[r - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          c = e.previousSibling;
        }
        for (; c && !((f = c.pmViewDesc) && f.parent == this); )
          c = c.previousSibling;
        return c ? this.posBeforeChild(f) + f.size : this.posAtStart;
      } else {
        let c, f;
        if (e == this.contentDOM)
          c = e.childNodes[r];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          c = e.nextSibling;
        }
        for (; c && !((f = c.pmViewDesc) && f.parent == this); )
          c = c.nextSibling;
        return c ? this.posBeforeChild(f) : this.posAtEnd;
      }
    let l;
    if (e == this.dom && this.contentDOM)
      l = r > va(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      l = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (r == 0)
        for (let c = e; ; c = c.parentNode) {
          if (c == this.dom) {
            l = !1;
            break;
          }
          if (c.previousSibling)
            break;
        }
      if (l == null && r == e.childNodes.length)
        for (let c = e; ; c = c.parentNode) {
          if (c == this.dom) {
            l = !0;
            break;
          }
          if (c.nextSibling)
            break;
        }
    }
    return l ?? s > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, r = !1) {
    for (let s = !0, l = e; l; l = l.parentNode) {
      let c = this.getDesc(l), f;
      if (c && (!r || c.node))
        if (s && (f = c.nodeDOM) && !(f.nodeType == 1 ? f.contains(e.nodeType == 1 ? e : e.parentNode) : f == e))
          s = !1;
        else
          return c;
    }
  }
  getDesc(e) {
    let r = e.pmViewDesc;
    for (let s = r; s; s = s.parent)
      if (s == this)
        return r;
  }
  posFromDOM(e, r, s) {
    for (let l = e; l; l = l.parentNode) {
      let c = this.getDesc(l);
      if (c)
        return c.localPosFromDOM(e, r, s);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let r = 0, s = 0; r < this.children.length; r++) {
      let l = this.children[r], c = s + l.size;
      if (s == e && c != s) {
        for (; !l.border && l.children.length; )
          l = l.children[0];
        return l;
      }
      if (e < c)
        return l.descAt(e - s - l.border);
      s = c;
    }
  }
  domFromPos(e, r) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let s = 0, l = 0;
    for (let c = 0; s < this.children.length; s++) {
      let f = this.children[s], p = c + f.size;
      if (p > e || f instanceof h6) {
        l = e - c;
        break;
      }
      c = p;
    }
    if (l)
      return this.children[s].domFromPos(l - this.children[s].border, r);
    for (let c; s && !(c = this.children[s - 1]).size && c instanceof d6 && c.side >= 0; s--)
      ;
    if (r <= 0) {
      let c, f = !0;
      for (; c = s ? this.children[s - 1] : null, !(!c || c.dom.parentNode == this.contentDOM); s--, f = !1)
        ;
      return c && r && f && !c.border && !c.domAtom ? c.domFromPos(c.size, r) : { node: this.contentDOM, offset: c ? va(c.dom) + 1 : 0 };
    } else {
      let c, f = !0;
      for (; c = s < this.children.length ? this.children[s] : null, !(!c || c.dom.parentNode == this.contentDOM); s++, f = !1)
        ;
      return c && f && !c.border && !c.domAtom ? c.domFromPos(0, r) : { node: this.contentDOM, offset: c ? va(c.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, r, s = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: r, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let l = -1, c = -1;
    for (let f = s, p = 0; ; p++) {
      let d = this.children[p], m = f + d.size;
      if (l == -1 && e <= m) {
        let y = f + d.border;
        if (e >= y && r <= m - d.border && d.node && d.contentDOM && this.contentDOM.contains(d.contentDOM))
          return d.parseRange(e, r, y);
        e = f;
        for (let S = p; S > 0; S--) {
          let x = this.children[S - 1];
          if (x.size && x.dom.parentNode == this.contentDOM && !x.emptyChildAt(1)) {
            l = va(x.dom) + 1;
            break;
          }
          e -= x.size;
        }
        l == -1 && (l = 0);
      }
      if (l > -1 && (m > r || p == this.children.length - 1)) {
        r = m;
        for (let y = p + 1; y < this.children.length; y++) {
          let S = this.children[y];
          if (S.size && S.dom.parentNode == this.contentDOM && !S.emptyChildAt(-1)) {
            c = va(S.dom);
            break;
          }
          r += S.size;
        }
        c == -1 && (c = this.contentDOM.childNodes.length);
        break;
      }
      f = m;
    }
    return { node: this.contentDOM, from: e, to: r, fromOffset: l, toOffset: c };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let r = this.children[e < 0 ? 0 : this.children.length - 1];
    return r.size == 0 || r.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: r, offset: s } = this.domFromPos(e, 0);
    if (r.nodeType != 1 || s == r.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return r.childNodes[s];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, r, s, l = !1) {
    let c = Math.min(e, r), f = Math.max(e, r);
    for (let x = 0, w = 0; x < this.children.length; x++) {
      let k = this.children[x], O = w + k.size;
      if (c > w && f < O)
        return k.setSelection(e - w - k.border, r - w - k.border, s, l);
      w = O;
    }
    let p = this.domFromPos(e, e ? -1 : 1), d = r == e ? p : this.domFromPos(r, r ? -1 : 1), m = s.getSelection(), y = !1;
    if ((ps || ga) && e == r) {
      let { node: x, offset: w } = p;
      if (x.nodeType == 3) {
        if (y = !!(w && x.nodeValue[w - 1] == `
`), y && w == x.nodeValue.length)
          for (let k = x, O; k; k = k.parentNode) {
            if (O = k.nextSibling) {
              O.nodeName == "BR" && (p = d = { node: O.parentNode, offset: va(O) + 1 });
              break;
            }
            let T = k.pmViewDesc;
            if (T && T.node && T.node.isBlock)
              break;
          }
      } else {
        let k = x.childNodes[w - 1];
        y = k && (k.nodeName == "BR" || k.contentEditable == "false");
      }
    }
    if (ps && m.focusNode && m.focusNode != d.node && m.focusNode.nodeType == 1) {
      let x = m.focusNode.childNodes[m.focusOffset];
      x && x.contentEditable == "false" && (l = !0);
    }
    if (!(l || y && ga) && Hc(p.node, p.offset, m.anchorNode, m.anchorOffset) && Hc(d.node, d.offset, m.focusNode, m.focusOffset))
      return;
    let S = !1;
    if ((m.extend || e == r) && !y) {
      m.collapse(p.node, p.offset);
      try {
        e != r && m.extend(d.node, d.offset), S = !0;
      } catch {
      }
    }
    if (!S) {
      if (e > r) {
        let w = p;
        p = d, d = w;
      }
      let x = document.createRange();
      x.setEnd(d.node, d.offset), x.setStart(p.node, p.offset), m.removeAllRanges(), m.addRange(x);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, r) {
    for (let s = 0, l = 0; l < this.children.length; l++) {
      let c = this.children[l], f = s + c.size;
      if (s == f ? e <= f && r >= s : e < f && r > s) {
        let p = s + c.border, d = f - c.border;
        if (e >= p && r <= d) {
          this.dirty = e == s || r == f ? Dc : bU, e == p && r == d && (c.contentLost || c.dom.parentNode != this.contentDOM) ? c.dirty = Hs : c.markDirty(e - p, r - p);
          return;
        } else
          c.dirty = c.dom == c.contentDOM && c.dom.parentNode == this.contentDOM && !c.children.length ? Dc : Hs;
      }
      s = f;
    }
    this.dirty = Dc;
  }
  markParentsDirty() {
    let e = 1;
    for (let r = this.parent; r; r = r.parent, e++) {
      let s = e == 1 ? Dc : bU;
      r.dirty < s && (r.dirty = s);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
}
class d6 extends ry {
  constructor(e, r, s, l) {
    let c, f = r.type.toDOM;
    if (typeof f == "function" && (f = f(s, () => {
      if (!c)
        return l;
      if (c.parent)
        return c.parent.posBeforeChild(c);
    })), !r.type.spec.raw) {
      if (f.nodeType != 1) {
        let p = document.createElement("span");
        p.appendChild(f), f = p;
      }
      f.contentEditable = "false", f.classList.add("ProseMirror-widget");
    }
    super(e, [], f, null), this.widget = r, this.widget = r, c = this;
  }
  matchesWidget(e) {
    return this.dirty == Io && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let r = this.widget.spec.stopEvent;
    return r ? r(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get side() {
    return this.widget.type.side;
  }
}
class Iee extends ry {
  constructor(e, r, s, l) {
    super(e, [], r, null), this.textDOM = s, this.text = l;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, r) {
    return e != this.textDOM ? this.posAtStart + (r ? this.size : 0) : this.posAtStart + r;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class jc extends ry {
  constructor(e, r, s, l) {
    super(e, [], s, l), this.mark = r;
  }
  static create(e, r, s, l) {
    let c = l.nodeViews[r.type.name], f = c && c(r, l, s);
    return (!f || !f.dom) && (f = bl.renderSpec(document, r.type.spec.toDOM(r, s))), new jc(e, r, f.dom, f.contentDOM || f.dom);
  }
  parseRule() {
    return this.dirty & Hs || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != Hs && this.mark.eq(e);
  }
  markDirty(e, r) {
    if (super.markDirty(e, r), this.dirty != Io) {
      let s = this.parent;
      for (; !s.node; )
        s = s.parent;
      s.dirty < this.dirty && (s.dirty = this.dirty), this.dirty = Io;
    }
  }
  slice(e, r, s) {
    let l = jc.create(this.parent, this.mark, !0, s), c = this.children, f = this.size;
    r < f && (c = Xj(c, r, f, s)), e > 0 && (c = Xj(c, 0, e, s));
    for (let p = 0; p < c.length; p++)
      c[p].parent = l;
    return l.children = c, l;
  }
}
class Mu extends ry {
  constructor(e, r, s, l, c, f, p, d, m) {
    super(e, [], c, f), this.node = r, this.outerDeco = s, this.innerDeco = l, this.nodeDOM = p;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, r, s, l, c, f) {
    let p = c.nodeViews[r.type.name], d, m = p && p(r, c, () => {
      if (!d)
        return f;
      if (d.parent)
        return d.parent.posBeforeChild(d);
    }, s, l), y = m && m.dom, S = m && m.contentDOM;
    if (r.isText) {
      if (!y)
        y = document.createTextNode(r.text);
      else if (y.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else y || ({ dom: y, contentDOM: S } = bl.renderSpec(document, r.type.spec.toDOM(r)));
    !S && !r.isText && y.nodeName != "BR" && (y.hasAttribute("contenteditable") || (y.contentEditable = "false"), r.type.spec.draggable && (y.draggable = !0));
    let x = y;
    return y = m6(y, s, r), m ? d = new _ee(e, r, s, l, y, S || null, x, m, c, f + 1) : r.isText ? new Fx(e, r, s, l, y, x, c) : new Mu(e, r, s, l, y, S || null, x, c, f + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let r = this.children.length - 1; r >= 0; r--) {
        let s = this.children[r];
        if (this.dom.contains(s.dom.parentNode)) {
          e.contentElement = s.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => qt.empty);
    }
    return e;
  }
  matchesNode(e, r, s) {
    return this.dirty == Io && e.eq(this.node) && Kj(r, this.outerDeco) && s.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, r) {
    let s = this.node.inlineContent, l = r, c = e.composing ? this.localCompositionInfo(e, r) : null, f = c && c.pos > -1 ? c : null, p = c && c.pos < 0, d = new Bee(this, f && f.node, e);
    Hee(this.node, this.innerDeco, (m, y, S) => {
      m.spec.marks ? d.syncToMarks(m.spec.marks, s, e) : m.type.side >= 0 && !S && d.syncToMarks(y == this.node.childCount ? Qr.none : this.node.child(y).marks, s, e), d.placeWidget(m, e, l);
    }, (m, y, S, x) => {
      d.syncToMarks(m.marks, s, e);
      let w;
      d.findNodeMatch(m, y, S, x) || p && e.state.selection.from > l && e.state.selection.to < l + m.nodeSize && (w = d.findIndexWithChild(c.node)) > -1 && d.updateNodeAt(m, y, S, w, e) || d.updateNextNode(m, y, S, e, x, l) || d.addNode(m, y, S, e, l), l += m.nodeSize;
    }), d.syncToMarks([], s, e), this.node.isTextblock && d.addTextblockHacks(), d.destroyRest(), (d.changed || this.dirty == Dc) && (f && this.protectLocalComposition(e, f), p6(this.contentDOM, this.children, e), fp && jee(this.dom));
  }
  localCompositionInfo(e, r) {
    let { from: s, to: l } = e.state.selection;
    if (!(e.state.selection instanceof Zr) || s < r || l > r + this.node.content.size)
      return null;
    let c = e.domSelectionRange(), f = Wee(c.focusNode, c.focusOffset);
    if (!f || !this.dom.contains(f.parentNode))
      return null;
    if (this.node.inlineContent) {
      let p = f.nodeValue, d = $ee(this.node.content, p, s - r, l - r);
      return d < 0 ? null : { node: f, pos: d, text: p };
    } else
      return { node: f, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: r, pos: s, text: l }) {
    if (this.getDesc(r))
      return;
    let c = r;
    for (; c.parentNode != this.contentDOM; c = c.parentNode) {
      for (; c.previousSibling; )
        c.parentNode.removeChild(c.previousSibling);
      for (; c.nextSibling; )
        c.parentNode.removeChild(c.nextSibling);
      c.pmViewDesc && (c.pmViewDesc = void 0);
    }
    let f = new Iee(this, c, r, l);
    e.input.compositionNodes.push(f), this.children = Xj(this.children, s, s + l.length, e, f);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, r, s, l) {
    return this.dirty == Hs || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, r, s, l), !0);
  }
  updateInner(e, r, s, l) {
    this.updateOuterDeco(r), this.node = e, this.innerDeco = s, this.contentDOM && this.updateChildren(l, this.posAtStart), this.dirty = Io;
  }
  updateOuterDeco(e) {
    if (Kj(e, this.outerDeco))
      return;
    let r = this.nodeDOM.nodeType != 1, s = this.dom;
    this.dom = v6(this.dom, this.nodeDOM, qj(this.outerDeco, this.node, r), qj(e, this.node, r)), this.dom != s && (s.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable");
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function SU(i, e, r, s, l) {
  m6(s, e, i);
  let c = new Mu(void 0, i, e, r, s, s, s, l, 0);
  return c.contentDOM && c.updateChildren(l, 0), c;
}
class Fx extends Mu {
  constructor(e, r, s, l, c, f, p) {
    super(e, r, s, l, c, null, f, p, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, r, s, l) {
    return this.dirty == Hs || this.dirty != Io && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(r), (this.dirty != Io || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, l.trackWrites == this.nodeDOM && (l.trackWrites = null)), this.node = e, this.dirty = Io, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let r = this.nodeDOM; r; r = r.parentNode)
      if (r == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, r, s) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(r, this.node.text.length) : super.localPosFromDOM(e, r, s);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, r, s) {
    let l = this.node.cut(e, r), c = document.createTextNode(l.text);
    return new Fx(this.parent, l, this.outerDeco, this.innerDeco, c, c, s);
  }
  markDirty(e, r) {
    super.markDirty(e, r), this.dom != this.nodeDOM && (e == 0 || r == this.nodeDOM.nodeValue.length) && (this.dirty = Hs);
  }
  get domAtom() {
    return !1;
  }
}
class h6 extends ry {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == Io && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class _ee extends Mu {
  constructor(e, r, s, l, c, f, p, d, m, y) {
    super(e, r, s, l, c, f, p, m, y), this.spec = d;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, r, s, l) {
    if (this.dirty == Hs)
      return !1;
    if (this.spec.update) {
      let c = this.spec.update(e, r, s);
      return c && this.updateInner(e, r, s, l), c;
    } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, r, s, l);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, r, s, l) {
    this.spec.setSelection ? this.spec.setSelection(e, r, s) : super.setSelection(e, r, s, l);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function p6(i, e, r) {
  let s = i.firstChild, l = !1;
  for (let c = 0; c < e.length; c++) {
    let f = e[c], p = f.dom;
    if (p.parentNode == i) {
      for (; p != s; )
        s = wU(s), l = !0;
      s = s.nextSibling;
    } else
      l = !0, i.insertBefore(p, s);
    if (f instanceof jc) {
      let d = s ? s.previousSibling : i.lastChild;
      p6(f.contentDOM, f.children, r), s = d ? d.nextSibling : i.firstChild;
    }
  }
  for (; s; )
    s = wU(s), l = !0;
  l && r.trackWrites == i && (r.trackWrites = null);
}
const Ug = function(i) {
  i && (this.nodeName = i);
};
Ug.prototype = /* @__PURE__ */ Object.create(null);
const Pc = [new Ug()];
function qj(i, e, r) {
  if (i.length == 0)
    return Pc;
  let s = r ? Pc[0] : new Ug(), l = [s];
  for (let c = 0; c < i.length; c++) {
    let f = i[c].type.attrs;
    if (f) {
      f.nodeName && l.push(s = new Ug(f.nodeName));
      for (let p in f) {
        let d = f[p];
        d != null && (r && l.length == 1 && l.push(s = new Ug(e.isInline ? "span" : "div")), p == "class" ? s.class = (s.class ? s.class + " " : "") + d : p == "style" ? s.style = (s.style ? s.style + ";" : "") + d : p != "nodeName" && (s[p] = d));
      }
    }
  }
  return l;
}
function v6(i, e, r, s) {
  if (r == Pc && s == Pc)
    return e;
  let l = e;
  for (let c = 0; c < s.length; c++) {
    let f = s[c], p = r[c];
    if (c) {
      let d;
      p && p.nodeName == f.nodeName && l != i && (d = l.parentNode) && d.nodeName.toLowerCase() == f.nodeName || (d = document.createElement(f.nodeName), d.pmIsDeco = !0, d.appendChild(l), p = Pc[0]), l = d;
    }
    Nee(l, p || Pc[0], f);
  }
  return l;
}
function Nee(i, e, r) {
  for (let s in e)
    s != "class" && s != "style" && s != "nodeName" && !(s in r) && i.removeAttribute(s);
  for (let s in r)
    s != "class" && s != "style" && s != "nodeName" && r[s] != e[s] && i.setAttribute(s, r[s]);
  if (e.class != r.class) {
    let s = e.class ? e.class.split(" ").filter(Boolean) : [], l = r.class ? r.class.split(" ").filter(Boolean) : [];
    for (let c = 0; c < s.length; c++)
      l.indexOf(s[c]) == -1 && i.classList.remove(s[c]);
    for (let c = 0; c < l.length; c++)
      s.indexOf(l[c]) == -1 && i.classList.add(l[c]);
    i.classList.length == 0 && i.removeAttribute("class");
  }
  if (e.style != r.style) {
    if (e.style) {
      let s = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, l;
      for (; l = s.exec(e.style); )
        i.style.removeProperty(l[1]);
    }
    r.style && (i.style.cssText += r.style);
  }
}
function m6(i, e, r) {
  return v6(i, i, Pc, qj(e, r, i.nodeType != 1));
}
function Kj(i, e) {
  if (i.length != e.length)
    return !1;
  for (let r = 0; r < i.length; r++)
    if (!i[r].type.eq(e[r].type))
      return !1;
  return !0;
}
function wU(i) {
  let e = i.nextSibling;
  return i.parentNode.removeChild(i), e;
}
class Bee {
  constructor(e, r, s) {
    this.lock = r, this.view = s, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = Fee(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, r) {
    if (e != r) {
      for (let s = e; s < r; s++)
        this.top.children[s].destroy();
      this.top.children.splice(e, r - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, r, s) {
    let l = 0, c = this.stack.length >> 1, f = Math.min(c, e.length);
    for (; l < f && (l == c - 1 ? this.top : this.stack[l + 1 << 1]).matchesMark(e[l]) && e[l].type.spec.spanning !== !1; )
      l++;
    for (; l < c; )
      this.destroyRest(), this.top.dirty = Io, this.index = this.stack.pop(), this.top = this.stack.pop(), c--;
    for (; c < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let p = -1;
      for (let d = this.index; d < Math.min(this.index + 3, this.top.children.length); d++) {
        let m = this.top.children[d];
        if (m.matchesMark(e[c]) && !this.isLocked(m.dom)) {
          p = d;
          break;
        }
      }
      if (p > -1)
        p > this.index && (this.changed = !0, this.destroyBetween(this.index, p)), this.top = this.top.children[this.index];
      else {
        let d = jc.create(this.top, e[c], r, s);
        this.top.children.splice(this.index, 0, d), this.top = d, this.changed = !0;
      }
      this.index = 0, c++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, r, s, l) {
    let c = -1, f;
    if (l >= this.preMatch.index && (f = this.preMatch.matches[l - this.preMatch.index]).parent == this.top && f.matchesNode(e, r, s))
      c = this.top.children.indexOf(f, this.index);
    else
      for (let p = this.index, d = Math.min(this.top.children.length, p + 5); p < d; p++) {
        let m = this.top.children[p];
        if (m.matchesNode(e, r, s) && !this.preMatch.matched.has(m)) {
          c = p;
          break;
        }
      }
    return c < 0 ? !1 : (this.destroyBetween(this.index, c), this.index++, !0);
  }
  updateNodeAt(e, r, s, l, c) {
    let f = this.top.children[l];
    return f.dirty == Hs && f.dom == f.contentDOM && (f.dirty = Dc), f.update(e, r, s, c) ? (this.destroyBetween(this.index, l), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let r = e.parentNode;
      if (!r)
        return -1;
      if (r == this.top.contentDOM) {
        let s = e.pmViewDesc;
        if (s) {
          for (let l = this.index; l < this.top.children.length; l++)
            if (this.top.children[l] == s)
              return l;
        }
        return -1;
      }
      e = r;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, r, s, l, c, f) {
    for (let p = this.index; p < this.top.children.length; p++) {
      let d = this.top.children[p];
      if (d instanceof Mu) {
        let m = this.preMatch.matched.get(d);
        if (m != null && m != c)
          return !1;
        let y = d.dom, S, x = this.isLocked(y) && !(e.isText && d.node && d.node.isText && d.nodeDOM.nodeValue == e.text && d.dirty != Hs && Kj(r, d.outerDeco));
        if (!x && d.update(e, r, s, l))
          return this.destroyBetween(this.index, p), d.dom != y && (this.changed = !0), this.index++, !0;
        if (!x && (S = this.recreateWrapper(d, e, r, s, l, f)))
          return this.top.children[this.index] = S, S.dirty = Dc, S.updateChildren(l, f + 1), S.dirty = Io, this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, r, s, l, c, f) {
    if (e.dirty || r.isAtom || !e.children.length || !e.node.content.eq(r.content))
      return null;
    let p = Mu.create(this.top, r, s, l, c, f);
    if (!p.contentDOM)
      return null;
    p.children = e.children, e.children = [], e.destroy();
    for (let d of p.children)
      d.parent = p;
    return p;
  }
  // Insert the node as a newly created node desc.
  addNode(e, r, s, l, c) {
    let f = Mu.create(this.top, e, r, s, l, c);
    f.contentDOM && f.updateChildren(l, c + 1), this.top.children.splice(this.index++, 0, f), this.changed = !0;
  }
  placeWidget(e, r, s) {
    let l = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (l && l.matchesWidget(e) && (e == l.widget || !l.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let c = new d6(this.top, e, r, s);
      this.top.children.splice(this.index++, 0, c), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], r = this.top;
    for (; e instanceof jc; )
      r = e, e = r.children[r.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof Fx) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((ga || Zi) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", r), this.addHackNode("BR", this.top));
  }
  addHackNode(e, r) {
    if (r == this.top && this.index < r.children.length && r.children[this.index].matchesHack(e))
      this.index++;
    else {
      let s = document.createElement(e);
      e == "IMG" && (s.className = "ProseMirror-separator", s.alt = ""), e == "BR" && (s.className = "ProseMirror-trailingBreak");
      let l = new h6(this.top, [], s, null);
      r != this.top ? r.children.push(l) : r.children.splice(this.index++, 0, l), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function Fee(i, e) {
  let r = e, s = r.children.length, l = i.childCount, c = /* @__PURE__ */ new Map(), f = [];
  e: for (; l > 0; ) {
    let p;
    for (; ; )
      if (s) {
        let m = r.children[s - 1];
        if (m instanceof jc)
          r = m, s = m.children.length;
        else {
          p = m, s--;
          break;
        }
      } else {
        if (r == e)
          break e;
        s = r.parent.children.indexOf(r), r = r.parent;
      }
    let d = p.node;
    if (d) {
      if (d != i.child(l - 1))
        break;
      --l, c.set(p, l), f.push(p);
    }
  }
  return { index: l, matched: c, matches: f.reverse() };
}
function zee(i, e) {
  return i.type.side - e.type.side;
}
function Hee(i, e, r, s) {
  let l = e.locals(i), c = 0;
  if (l.length == 0) {
    for (let m = 0; m < i.childCount; m++) {
      let y = i.child(m);
      s(y, l, e.forChild(c, y), m), c += y.nodeSize;
    }
    return;
  }
  let f = 0, p = [], d = null;
  for (let m = 0; ; ) {
    if (f < l.length && l[f].to == c) {
      let k = l[f++], O;
      for (; f < l.length && l[f].to == c; )
        (O || (O = [k])).push(l[f++]);
      if (O) {
        O.sort(zee);
        for (let T = 0; T < O.length; T++)
          r(O[T], m, !!d);
      } else
        r(k, m, !!d);
    }
    let y, S;
    if (d)
      S = -1, y = d, d = null;
    else if (m < i.childCount)
      S = m, y = i.child(m++);
    else
      break;
    for (let k = 0; k < p.length; k++)
      p[k].to <= c && p.splice(k--, 1);
    for (; f < l.length && l[f].from <= c && l[f].to > c; )
      p.push(l[f++]);
    let x = c + y.nodeSize;
    if (y.isText) {
      let k = x;
      f < l.length && l[f].from < k && (k = l[f].from);
      for (let O = 0; O < p.length; O++)
        p[O].to < k && (k = p[O].to);
      k < x && (d = y.cut(k - c), y = y.cut(0, k - c), x = k, S = -1);
    }
    let w = y.isInline && !y.isLeaf ? p.filter((k) => !k.inline) : p.slice();
    s(y, w, e.forChild(c, y), S), c = x;
  }
}
function jee(i) {
  if (i.nodeName == "UL" || i.nodeName == "OL") {
    let e = i.style.cssText;
    i.style.cssText = e + "; list-style: square !important", window.getComputedStyle(i).listStyle, i.style.cssText = e;
  }
}
function Wee(i, e) {
  for (; ; ) {
    if (i.nodeType == 3)
      return i;
    if (i.nodeType == 1 && e > 0) {
      if (i.childNodes.length > e && i.childNodes[e].nodeType == 3)
        return i.childNodes[e];
      i = i.childNodes[e - 1], e = _s(i);
    } else if (i.nodeType == 1 && e < i.childNodes.length)
      i = i.childNodes[e], e = 0;
    else
      return null;
  }
}
function $ee(i, e, r, s) {
  for (let l = 0, c = 0; l < i.childCount && c <= s; ) {
    let f = i.child(l++), p = c;
    if (c += f.nodeSize, !f.isText)
      continue;
    let d = f.text;
    for (; l < i.childCount; ) {
      let m = i.child(l++);
      if (c += m.nodeSize, !m.isText)
        break;
      d += m.text;
    }
    if (c >= r) {
      let m = p < s ? d.lastIndexOf(e, s - p - 1) : -1;
      if (m >= 0 && m + e.length + p >= r)
        return p + m;
      if (r == s && d.length >= s + e.length - p && d.slice(s - p, s - p + e.length) == e)
        return s;
    }
  }
  return -1;
}
function Xj(i, e, r, s, l) {
  let c = [];
  for (let f = 0, p = 0; f < i.length; f++) {
    let d = i[f], m = p, y = p += d.size;
    m >= r || y <= e ? c.push(d) : (m < e && c.push(d.slice(0, e - m, s)), l && (c.push(l), l = void 0), y > r && c.push(d.slice(r - m, d.size, s)));
  }
  return c;
}
function P3(i, e = null) {
  let r = i.domSelectionRange(), s = i.state.doc;
  if (!r.focusNode)
    return null;
  let l = i.docView.nearestDesc(r.focusNode), c = l && l.size == 0, f = i.docView.posFromDOM(r.focusNode, r.focusOffset, 1);
  if (f < 0)
    return null;
  let p = s.resolve(f), d, m;
  if (Nx(r)) {
    for (d = p; l && !l.node; )
      l = l.parent;
    let y = l.node;
    if (l && y.isAtom && Er.isSelectable(y) && l.parent && !(y.isInline && hee(r.focusNode, r.focusOffset, l.dom))) {
      let S = l.posBefore;
      m = new Er(f == S ? p : s.resolve(S));
    }
  } else {
    let y = i.docView.posFromDOM(r.anchorNode, r.anchorOffset, 1);
    if (y < 0)
      return null;
    d = s.resolve(y);
  }
  if (!m) {
    let y = e == "pointer" || i.state.selection.head < p.pos && !c ? 1 : -1;
    m = L3(i, d, p, y);
  }
  return m;
}
function g6(i) {
  return i.editable ? i.hasFocus() : b6(i) && document.activeElement && document.activeElement.contains(i.dom);
}
function wl(i, e = !1) {
  let r = i.state.selection;
  if (y6(i, r), !!g6(i)) {
    if (!e && i.input.mouseDown && i.input.mouseDown.allowDefault && Zi) {
      let s = i.domSelectionRange(), l = i.domObserver.currentSelection;
      if (s.anchorNode && l.anchorNode && Hc(s.anchorNode, s.anchorOffset, l.anchorNode, l.anchorOffset)) {
        i.input.mouseDown.delayedSelectionSync = !0, i.domObserver.setCurSelection();
        return;
      }
    }
    if (i.domObserver.disconnectSelection(), i.cursorWrapper)
      Vee(i);
    else {
      let { anchor: s, head: l } = r, c, f;
      xU && !(r instanceof Zr) && (r.$from.parent.inlineContent || (c = kU(i, r.from)), !r.empty && !r.$from.parent.inlineContent && (f = kU(i, r.to))), i.docView.setSelection(s, l, i.root, e), xU && (c && OU(c), f && OU(f)), r.visible ? i.dom.classList.remove("ProseMirror-hideselection") : (i.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && Uee(i));
    }
    i.domObserver.setCurSelection(), i.domObserver.connectSelection();
  }
}
const xU = ga || Zi && mee < 63;
function kU(i, e) {
  let { node: r, offset: s } = i.docView.domFromPos(e, 0), l = s < r.childNodes.length ? r.childNodes[s] : null, c = s ? r.childNodes[s - 1] : null;
  if (ga && l && l.contentEditable == "false")
    return YH(l);
  if ((!l || l.contentEditable == "false") && (!c || c.contentEditable == "false")) {
    if (l)
      return YH(l);
    if (c)
      return YH(c);
  }
}
function YH(i) {
  return i.contentEditable = "true", ga && i.draggable && (i.draggable = !1, i.wasDraggable = !0), i;
}
function OU(i) {
  i.contentEditable = "false", i.wasDraggable && (i.draggable = !0, i.wasDraggable = null);
}
function Uee(i) {
  let e = i.dom.ownerDocument;
  e.removeEventListener("selectionchange", i.input.hideSelectionGuard);
  let r = i.domSelectionRange(), s = r.anchorNode, l = r.anchorOffset;
  e.addEventListener("selectionchange", i.input.hideSelectionGuard = () => {
    (r.anchorNode != s || r.anchorOffset != l) && (e.removeEventListener("selectionchange", i.input.hideSelectionGuard), setTimeout(() => {
      (!g6(i) || i.state.selection.visible) && i.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function Vee(i) {
  let e = i.domSelection(), r = document.createRange(), s = i.cursorWrapper.dom, l = s.nodeName == "IMG";
  l ? r.setEnd(s.parentNode, va(s) + 1) : r.setEnd(s, 0), r.collapse(!1), e.removeAllRanges(), e.addRange(r), !l && !i.state.selection.visible && za && Eu <= 11 && (s.disabled = !0, s.disabled = !1);
}
function y6(i, e) {
  if (e instanceof Er) {
    let r = i.docView.descAt(e.from);
    r != i.lastSelectedViewDesc && (CU(i), r && r.selectNode(), i.lastSelectedViewDesc = r);
  } else
    CU(i);
}
function CU(i) {
  i.lastSelectedViewDesc && (i.lastSelectedViewDesc.parent && i.lastSelectedViewDesc.deselectNode(), i.lastSelectedViewDesc = void 0);
}
function L3(i, e, r, s) {
  return i.someProp("createSelectionBetween", (l) => l(i, e, r)) || Zr.between(e, r, s);
}
function TU(i) {
  return i.editable && !i.hasFocus() ? !1 : b6(i);
}
function b6(i) {
  let e = i.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return i.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (i.editable || i.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function Gee(i) {
  let e = i.docView.domFromPos(i.state.selection.anchor, 0), r = i.domSelectionRange();
  return Hc(e.node, e.offset, r.anchorNode, r.anchorOffset);
}
function Jj(i, e) {
  let { $anchor: r, $head: s } = i.selection, l = e > 0 ? r.max(s) : r.min(s), c = l.parent.inlineContent ? l.depth ? i.doc.resolve(e > 0 ? l.after() : l.before()) : null : l;
  return c && jr.findFrom(c, e);
}
function Mc(i, e) {
  return i.dispatch(i.state.tr.setSelection(e).scrollIntoView()), !0;
}
function AU(i, e, r) {
  let s = i.state.selection;
  if (s instanceof Zr) {
    if (!s.empty || r.indexOf("s") > -1)
      return !1;
    if (i.endOfTextblock(e > 0 ? "forward" : "backward")) {
      let l = Jj(i.state, e);
      return l && l instanceof Er ? Mc(i, l) : !1;
    } else if (!(Lo && r.indexOf("m") > -1)) {
      let l = s.$head, c = l.textOffset ? null : e < 0 ? l.nodeBefore : l.nodeAfter, f;
      if (!c || c.isText)
        return !1;
      let p = e < 0 ? l.pos - c.nodeSize : l.pos;
      return c.isAtom || (f = i.docView.descAt(p)) && !f.contentDOM ? Er.isSelectable(c) ? Mc(i, new Er(e < 0 ? i.state.doc.resolve(l.pos - c.nodeSize) : l)) : Bx ? Mc(i, new Zr(i.state.doc.resolve(e < 0 ? p : p + c.nodeSize))) : !1 : !1;
    }
  } else {
    if (s instanceof Er && s.node.isInline)
      return Mc(i, new Zr(e > 0 ? s.$to : s.$from));
    {
      let l = Jj(i.state, e);
      return l ? Mc(i, l) : !1;
    }
  }
}
function cx(i) {
  return i.nodeType == 3 ? i.nodeValue.length : i.childNodes.length;
}
function Vg(i) {
  if (i.contentEditable == "false")
    return !0;
  let e = i.pmViewDesc;
  return e && e.size == 0 && (i.nextSibling || i.nodeName != "BR");
}
function Dg(i, e) {
  return e < 0 ? Yee(i) : S6(i);
}
function Yee(i) {
  let e = i.domSelectionRange(), r = e.focusNode, s = e.focusOffset;
  if (!r)
    return;
  let l, c, f = !1;
  for (ps && r.nodeType == 1 && s < cx(r) && Vg(r.childNodes[s]) && (f = !0); ; )
    if (s > 0) {
      if (r.nodeType != 1)
        break;
      {
        let p = r.childNodes[s - 1];
        if (Vg(p))
          l = r, c = --s;
        else if (p.nodeType == 3)
          r = p, s = r.nodeValue.length;
        else
          break;
      }
    } else {
      if (w6(r))
        break;
      {
        let p = r.previousSibling;
        for (; p && Vg(p); )
          l = r.parentNode, c = va(p), p = p.previousSibling;
        if (p)
          r = p, s = cx(r);
        else {
          if (r = r.parentNode, r == i.dom)
            break;
          s = 0;
        }
      }
    }
  f ? Zj(i, r, s) : l && Zj(i, l, c);
}
function S6(i) {
  let e = i.domSelectionRange(), r = e.focusNode, s = e.focusOffset;
  if (!r)
    return;
  let l = cx(r), c, f;
  for (; ; )
    if (s < l) {
      if (r.nodeType != 1)
        break;
      let p = r.childNodes[s];
      if (Vg(p))
        c = r, f = ++s;
      else
        break;
    } else {
      if (w6(r))
        break;
      {
        let p = r.nextSibling;
        for (; p && Vg(p); )
          c = p.parentNode, f = va(p) + 1, p = p.nextSibling;
        if (p)
          r = p, s = 0, l = cx(r);
        else {
          if (r = r.parentNode, r == i.dom)
            break;
          s = l = 0;
        }
      }
    }
  c && Zj(i, c, f);
}
function w6(i) {
  let e = i.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function qee(i, e) {
  for (; i && e == i.childNodes.length && !R3(i); )
    e = va(i) + 1, i = i.parentNode;
  for (; i && e < i.childNodes.length; ) {
    if (i = i.childNodes[e], i.nodeType == 3)
      return i;
    e = 0;
  }
}
function Kee(i, e) {
  for (; i && !e && !R3(i); )
    e = va(i), i = i.parentNode;
  for (; i && e; ) {
    if (i = i.childNodes[e - 1], i.nodeType == 3)
      return i;
    e = i.childNodes.length;
  }
}
function Zj(i, e, r) {
  if (e.nodeType != 3) {
    let c, f;
    (f = qee(e, r)) ? (e = f, r = 0) : (c = Kee(e, r)) && (e = c, r = c.nodeValue.length);
  }
  let s = i.domSelection();
  if (Nx(s)) {
    let c = document.createRange();
    c.setEnd(e, r), c.setStart(e, r), s.removeAllRanges(), s.addRange(c);
  } else s.extend && s.extend(e, r);
  i.domObserver.setCurSelection();
  let { state: l } = i;
  setTimeout(() => {
    i.state == l && wl(i);
  }, 50);
}
function EU(i, e) {
  let r = i.state.doc.resolve(e);
  if (!(Zi || gee) && r.parent.inlineContent) {
    let l = i.coordsAtPos(e);
    if (e > r.start()) {
      let c = i.coordsAtPos(e - 1), f = (c.top + c.bottom) / 2;
      if (f > l.top && f < l.bottom && Math.abs(c.left - l.left) > 1)
        return c.left < l.left ? "ltr" : "rtl";
    }
    if (e < r.end()) {
      let c = i.coordsAtPos(e + 1), f = (c.top + c.bottom) / 2;
      if (f > l.top && f < l.bottom && Math.abs(c.left - l.left) > 1)
        return c.left > l.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(i.dom).direction == "rtl" ? "rtl" : "ltr";
}
function MU(i, e, r) {
  let s = i.state.selection;
  if (s instanceof Zr && !s.empty || r.indexOf("s") > -1 || Lo && r.indexOf("m") > -1)
    return !1;
  let { $from: l, $to: c } = s;
  if (!l.parent.inlineContent || i.endOfTextblock(e < 0 ? "up" : "down")) {
    let f = Jj(i.state, e);
    if (f && f instanceof Er)
      return Mc(i, f);
  }
  if (!l.parent.inlineContent) {
    let f = e < 0 ? l : c, p = s instanceof ma ? jr.near(f, e) : jr.findFrom(f, e);
    return p ? Mc(i, p) : !1;
  }
  return !1;
}
function RU(i, e) {
  if (!(i.state.selection instanceof Zr))
    return !0;
  let { $head: r, $anchor: s, empty: l } = i.state.selection;
  if (!r.sameParent(s))
    return !0;
  if (!l)
    return !1;
  if (i.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let c = !r.textOffset && (e < 0 ? r.nodeBefore : r.nodeAfter);
  if (c && !c.isText) {
    let f = i.state.tr;
    return e < 0 ? f.delete(r.pos - c.nodeSize, r.pos) : f.delete(r.pos, r.pos + c.nodeSize), i.dispatch(f), !0;
  }
  return !1;
}
function DU(i, e, r) {
  i.domObserver.stop(), e.contentEditable = r, i.domObserver.start();
}
function Xee(i) {
  if (!ga || i.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: r } = i.domSelectionRange();
  if (e && e.nodeType == 1 && r == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let s = e.firstChild;
    DU(i, s, "true"), setTimeout(() => DU(i, s, "false"), 20);
  }
  return !1;
}
function Jee(i) {
  let e = "";
  return i.ctrlKey && (e += "c"), i.metaKey && (e += "m"), i.altKey && (e += "a"), i.shiftKey && (e += "s"), e;
}
function Zee(i, e) {
  let r = e.keyCode, s = Jee(e);
  if (r == 8 || Lo && r == 72 && s == "c")
    return RU(i, -1) || Dg(i, -1);
  if (r == 46 && !e.shiftKey || Lo && r == 68 && s == "c")
    return RU(i, 1) || Dg(i, 1);
  if (r == 13 || r == 27)
    return !0;
  if (r == 37 || Lo && r == 66 && s == "c") {
    let l = r == 37 ? EU(i, i.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return AU(i, l, s) || Dg(i, l);
  } else if (r == 39 || Lo && r == 70 && s == "c") {
    let l = r == 39 ? EU(i, i.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return AU(i, l, s) || Dg(i, l);
  } else {
    if (r == 38 || Lo && r == 80 && s == "c")
      return MU(i, -1, s) || Dg(i, -1);
    if (r == 40 || Lo && r == 78 && s == "c")
      return Xee(i) || MU(i, 1, s) || S6(i);
    if (s == (Lo ? "m" : "c") && (r == 66 || r == 73 || r == 89 || r == 90))
      return !0;
  }
  return !1;
}
function x6(i, e) {
  i.someProp("transformCopied", (w) => {
    e = w(e, i);
  });
  let r = [], { content: s, openStart: l, openEnd: c } = e;
  for (; l > 1 && c > 1 && s.childCount == 1 && s.firstChild.childCount == 1; ) {
    l--, c--;
    let w = s.firstChild;
    r.push(w.type.name, w.attrs != w.type.defaultAttrs ? w.attrs : null), s = w.content;
  }
  let f = i.someProp("clipboardSerializer") || bl.fromSchema(i.state.schema), p = E6(), d = p.createElement("div");
  d.appendChild(f.serializeFragment(s, { document: p }));
  let m = d.firstChild, y, S = 0;
  for (; m && m.nodeType == 1 && (y = A6[m.nodeName.toLowerCase()]); ) {
    for (let w = y.length - 1; w >= 0; w--) {
      let k = p.createElement(y[w]);
      for (; d.firstChild; )
        k.appendChild(d.firstChild);
      d.appendChild(k), S++;
    }
    m = d.firstChild;
  }
  m && m.nodeType == 1 && m.setAttribute("data-pm-slice", `${l} ${c}${S ? ` -${S}` : ""} ${JSON.stringify(r)}`);
  let x = i.someProp("clipboardTextSerializer", (w) => w(e, i)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: d, text: x };
}
function k6(i, e, r, s, l) {
  let c = l.parent.type.spec.code, f, p;
  if (!r && !e)
    return null;
  let d = e && (s || c || !r);
  if (d) {
    if (i.someProp("transformPastedText", (x) => {
      e = x(e, c || s, i);
    }), c)
      return e ? new ur(qt.from(i.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : ur.empty;
    let S = i.someProp("clipboardTextParser", (x) => x(e, l, s, i));
    if (S)
      p = S;
    else {
      let x = l.marks(), { schema: w } = i.state, k = bl.fromSchema(w);
      f = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((O) => {
        let T = f.appendChild(document.createElement("p"));
        O && T.appendChild(k.serializeNode(w.text(O, x)));
      });
    }
  } else
    i.someProp("transformPastedHTML", (S) => {
      r = S(r, i);
    }), f = tte(r), Bx && rte(f);
  let m = f && f.querySelector("[data-pm-slice]"), y = m && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(m.getAttribute("data-pm-slice") || "");
  if (y && y[3])
    for (let S = +y[3]; S > 0; S--) {
      let x = f.firstChild;
      for (; x && x.nodeType != 1; )
        x = x.nextSibling;
      if (!x)
        break;
      f = x;
    }
  if (p || (p = (i.someProp("clipboardParser") || i.someProp("domParser") || zc.fromSchema(i.state.schema)).parseSlice(f, {
    preserveWhitespace: !!(d || y),
    context: l,
    ruleFromNode(x) {
      return x.nodeName == "BR" && !x.nextSibling && x.parentNode && !Qee.test(x.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), y)
    p = nte(PU(p, +y[1], +y[2]), y[4]);
  else if (p = ur.maxOpen(ete(p.content, l), !0), p.openStart || p.openEnd) {
    let S = 0, x = 0;
    for (let w = p.content.firstChild; S < p.openStart && !w.type.spec.isolating; S++, w = w.firstChild)
      ;
    for (let w = p.content.lastChild; x < p.openEnd && !w.type.spec.isolating; x++, w = w.lastChild)
      ;
    p = PU(p, S, x);
  }
  return i.someProp("transformPasted", (S) => {
    p = S(p, i);
  }), p;
}
const Qee = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function ete(i, e) {
  if (i.childCount < 2)
    return i;
  for (let r = e.depth; r >= 0; r--) {
    let l = e.node(r).contentMatchAt(e.index(r)), c, f = [];
    if (i.forEach((p) => {
      if (!f)
        return;
      let d = l.findWrapping(p.type), m;
      if (!d)
        return f = null;
      if (m = f.length && c.length && C6(d, c, p, f[f.length - 1], 0))
        f[f.length - 1] = m;
      else {
        f.length && (f[f.length - 1] = T6(f[f.length - 1], c.length));
        let y = O6(p, d);
        f.push(y), l = l.matchType(y.type), c = d;
      }
    }), f)
      return qt.from(f);
  }
  return i;
}
function O6(i, e, r = 0) {
  for (let s = e.length - 1; s >= r; s--)
    i = e[s].create(null, qt.from(i));
  return i;
}
function C6(i, e, r, s, l) {
  if (l < i.length && l < e.length && i[l] == e[l]) {
    let c = C6(i, e, r, s.lastChild, l + 1);
    if (c)
      return s.copy(s.content.replaceChild(s.childCount - 1, c));
    if (s.contentMatchAt(s.childCount).matchType(l == i.length - 1 ? r.type : i[l + 1]))
      return s.copy(s.content.append(qt.from(O6(r, i, l + 1))));
  }
}
function T6(i, e) {
  if (e == 0)
    return i;
  let r = i.content.replaceChild(i.childCount - 1, T6(i.lastChild, e - 1)), s = i.contentMatchAt(i.childCount).fillBefore(qt.empty, !0);
  return i.copy(r.append(s));
}
function Qj(i, e, r, s, l, c) {
  let f = e < 0 ? i.firstChild : i.lastChild, p = f.content;
  return i.childCount > 1 && (c = 0), l < s - 1 && (p = Qj(p, e, r, s, l + 1, c)), l >= r && (p = e < 0 ? f.contentMatchAt(0).fillBefore(p, c <= l).append(p) : p.append(f.contentMatchAt(f.childCount).fillBefore(qt.empty, !0))), i.replaceChild(e < 0 ? 0 : i.childCount - 1, f.copy(p));
}
function PU(i, e, r) {
  return e < i.openStart && (i = new ur(Qj(i.content, -1, e, i.openStart, 0, i.openEnd), e, i.openEnd)), r < i.openEnd && (i = new ur(Qj(i.content, 1, r, i.openEnd, 0, 0), i.openStart, r)), i;
}
const A6 = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let LU = null;
function E6() {
  return LU || (LU = document.implementation.createHTMLDocument("title"));
}
function tte(i) {
  let e = /^(\s*<meta [^>]*>)*/.exec(i);
  e && (i = i.slice(e[0].length));
  let r = E6().createElement("div"), s = /<([a-z][^>\s]+)/i.exec(i), l;
  if ((l = s && A6[s[1].toLowerCase()]) && (i = l.map((c) => "<" + c + ">").join("") + i + l.map((c) => "</" + c + ">").reverse().join("")), r.innerHTML = i, l)
    for (let c = 0; c < l.length; c++)
      r = r.querySelector(l[c]) || r;
  return r;
}
function rte(i) {
  let e = i.querySelectorAll(Zi ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let r = 0; r < e.length; r++) {
    let s = e[r];
    s.childNodes.length == 1 && s.textContent == " " && s.parentNode && s.parentNode.replaceChild(i.ownerDocument.createTextNode(" "), s);
  }
}
function nte(i, e) {
  if (!i.size)
    return i;
  let r = i.content.firstChild.type.schema, s;
  try {
    s = JSON.parse(e);
  } catch {
    return i;
  }
  let { content: l, openStart: c, openEnd: f } = i;
  for (let p = s.length - 2; p >= 0; p -= 2) {
    let d = r.nodes[s[p]];
    if (!d || d.hasRequiredAttrs())
      break;
    l = qt.from(d.create(s[p + 1], l)), c++, f++;
  }
  return new ur(l, c, f);
}
const ya = {}, ba = {}, ite = { touchstart: !0, touchmove: !0 };
class ate {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastAndroidDelete = 0, this.composing = !1, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function ote(i) {
  for (let e in ya) {
    let r = ya[e];
    i.dom.addEventListener(e, i.input.eventHandlers[e] = (s) => {
      lte(i, s) && !I3(i, s) && (i.editable || !(s.type in ba)) && r(i, s);
    }, ite[e] ? { passive: !0 } : void 0);
  }
  ga && i.dom.addEventListener("input", () => null), e3(i);
}
function Cu(i, e) {
  i.input.lastSelectionOrigin = e, i.input.lastSelectionTime = Date.now();
}
function ste(i) {
  i.domObserver.stop();
  for (let e in i.input.eventHandlers)
    i.dom.removeEventListener(e, i.input.eventHandlers[e]);
  clearTimeout(i.input.composingTimeout), clearTimeout(i.input.lastIOSEnterFallbackTimeout);
}
function e3(i) {
  i.someProp("handleDOMEvents", (e) => {
    for (let r in e)
      i.input.eventHandlers[r] || i.dom.addEventListener(r, i.input.eventHandlers[r] = (s) => I3(i, s));
  });
}
function I3(i, e) {
  return i.someProp("handleDOMEvents", (r) => {
    let s = r[e.type];
    return s ? s(i, e) || e.defaultPrevented : !1;
  });
}
function lte(i, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let r = e.target; r != i.dom; r = r.parentNode)
    if (!r || r.nodeType == 11 || r.pmViewDesc && r.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function ute(i, e) {
  !I3(i, e) && ya[e.type] && (i.editable || !(e.type in ba)) && ya[e.type](i, e);
}
ba.keydown = (i, e) => {
  let r = e;
  if (i.input.shiftKey = r.keyCode == 16 || r.shiftKey, !R6(i, r) && (i.input.lastKeyCode = r.keyCode, i.input.lastKeyCodeTime = Date.now(), !(us && Zi && r.keyCode == 13)))
    if (r.keyCode != 229 && i.domObserver.forceFlush(), fp && r.keyCode == 13 && !r.ctrlKey && !r.altKey && !r.metaKey) {
      let s = Date.now();
      i.input.lastIOSEnter = s, i.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        i.input.lastIOSEnter == s && (i.someProp("handleKeyDown", (l) => l(i, Ec(13, "Enter"))), i.input.lastIOSEnter = 0);
      }, 200);
    } else i.someProp("handleKeyDown", (s) => s(i, r)) || Zee(i, r) ? r.preventDefault() : Cu(i, "key");
};
ba.keyup = (i, e) => {
  e.keyCode == 16 && (i.input.shiftKey = !1);
};
ba.keypress = (i, e) => {
  let r = e;
  if (R6(i, r) || !r.charCode || r.ctrlKey && !r.altKey || Lo && r.metaKey)
    return;
  if (i.someProp("handleKeyPress", (l) => l(i, r))) {
    r.preventDefault();
    return;
  }
  let s = i.state.selection;
  if (!(s instanceof Zr) || !s.$from.sameParent(s.$to)) {
    let l = String.fromCharCode(r.charCode);
    !/[\r\n]/.test(l) && !i.someProp("handleTextInput", (c) => c(i, s.$from.pos, s.$to.pos, l)) && i.dispatch(i.state.tr.insertText(l).scrollIntoView()), r.preventDefault();
  }
};
function zx(i) {
  return { left: i.clientX, top: i.clientY };
}
function cte(i, e) {
  let r = e.x - i.clientX, s = e.y - i.clientY;
  return r * r + s * s < 100;
}
function _3(i, e, r, s, l) {
  if (s == -1)
    return !1;
  let c = i.state.doc.resolve(s);
  for (let f = c.depth + 1; f > 0; f--)
    if (i.someProp(e, (p) => f > c.depth ? p(i, r, c.nodeAfter, c.before(f), l, !0) : p(i, r, c.node(f), c.before(f), l, !1)))
      return !0;
  return !1;
}
function lp(i, e, r) {
  i.focused || i.focus();
  let s = i.state.tr.setSelection(e);
  s.setMeta("pointer", !0), i.dispatch(s);
}
function fte(i, e) {
  if (e == -1)
    return !1;
  let r = i.state.doc.resolve(e), s = r.nodeAfter;
  return s && s.isAtom && Er.isSelectable(s) ? (lp(i, new Er(r)), !0) : !1;
}
function dte(i, e) {
  if (e == -1)
    return !1;
  let r = i.state.selection, s, l;
  r instanceof Er && (s = r.node);
  let c = i.state.doc.resolve(e);
  for (let f = c.depth + 1; f > 0; f--) {
    let p = f > c.depth ? c.nodeAfter : c.node(f);
    if (Er.isSelectable(p)) {
      s && r.$from.depth > 0 && f >= r.$from.depth && c.before(r.$from.depth + 1) == r.$from.pos ? l = c.before(r.$from.depth) : l = c.before(f);
      break;
    }
  }
  return l != null ? (lp(i, Er.create(i.state.doc, l)), !0) : !1;
}
function hte(i, e, r, s, l) {
  return _3(i, "handleClickOn", e, r, s) || i.someProp("handleClick", (c) => c(i, e, s)) || (l ? dte(i, r) : fte(i, r));
}
function pte(i, e, r, s) {
  return _3(i, "handleDoubleClickOn", e, r, s) || i.someProp("handleDoubleClick", (l) => l(i, e, s));
}
function vte(i, e, r, s) {
  return _3(i, "handleTripleClickOn", e, r, s) || i.someProp("handleTripleClick", (l) => l(i, e, s)) || mte(i, r, s);
}
function mte(i, e, r) {
  if (r.button != 0)
    return !1;
  let s = i.state.doc;
  if (e == -1)
    return s.inlineContent ? (lp(i, Zr.create(s, 0, s.content.size)), !0) : !1;
  let l = s.resolve(e);
  for (let c = l.depth + 1; c > 0; c--) {
    let f = c > l.depth ? l.nodeAfter : l.node(c), p = l.before(c);
    if (f.inlineContent)
      lp(i, Zr.create(s, p + 1, p + 1 + f.content.size));
    else if (Er.isSelectable(f))
      lp(i, Er.create(s, p));
    else
      continue;
    return !0;
  }
}
function N3(i) {
  return fx(i);
}
const M6 = Lo ? "metaKey" : "ctrlKey";
ya.mousedown = (i, e) => {
  let r = e;
  i.input.shiftKey = r.shiftKey;
  let s = N3(i), l = Date.now(), c = "singleClick";
  l - i.input.lastClick.time < 500 && cte(r, i.input.lastClick) && !r[M6] && (i.input.lastClick.type == "singleClick" ? c = "doubleClick" : i.input.lastClick.type == "doubleClick" && (c = "tripleClick")), i.input.lastClick = { time: l, x: r.clientX, y: r.clientY, type: c };
  let f = i.posAtCoords(zx(r));
  f && (c == "singleClick" ? (i.input.mouseDown && i.input.mouseDown.done(), i.input.mouseDown = new gte(i, f, r, !!s)) : (c == "doubleClick" ? pte : vte)(i, f.pos, f.inside, r) ? r.preventDefault() : Cu(i, "pointer"));
};
class gte {
  constructor(e, r, s, l) {
    this.view = e, this.pos = r, this.event = s, this.flushed = l, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!s[M6], this.allowDefault = s.shiftKey;
    let c, f;
    if (r.inside > -1)
      c = e.state.doc.nodeAt(r.inside), f = r.inside;
    else {
      let y = e.state.doc.resolve(r.pos);
      c = y.parent, f = y.depth ? y.before() : 0;
    }
    const p = l ? null : s.target, d = p ? e.docView.nearestDesc(p, !0) : null;
    this.target = d ? d.dom : null;
    let { selection: m } = e.state;
    (s.button == 0 && c.type.spec.draggable && c.type.spec.selectable !== !1 || m instanceof Er && m.from <= f && m.to > f) && (this.mightDrag = {
      node: c,
      pos: f,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && ps && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), Cu(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => wl(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let r = this.pos;
    this.view.state.doc != this.startDoc && (r = this.view.posAtCoords(zx(e))), this.updateAllowDefault(e), this.allowDefault || !r ? Cu(this.view, "pointer") : hte(this.view, r.pos, r.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    ga && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    Zi && !this.view.state.selection.visible && Math.min(Math.abs(r.pos - this.view.state.selection.from), Math.abs(r.pos - this.view.state.selection.to)) <= 2) ? (lp(this.view, jr.near(this.view.state.doc.resolve(r.pos))), e.preventDefault()) : Cu(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), Cu(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
ya.touchstart = (i) => {
  i.input.lastTouch = Date.now(), N3(i), Cu(i, "pointer");
};
ya.touchmove = (i) => {
  i.input.lastTouch = Date.now(), Cu(i, "pointer");
};
ya.contextmenu = (i) => N3(i);
function R6(i, e) {
  return i.composing ? !0 : ga && Math.abs(e.timeStamp - i.input.compositionEndedAt) < 500 ? (i.input.compositionEndedAt = -2e8, !0) : !1;
}
const yte = us ? 5e3 : -1;
ba.compositionstart = ba.compositionupdate = (i) => {
  if (!i.composing) {
    i.domObserver.flush();
    let { state: e } = i, r = e.selection.$from;
    if (e.selection.empty && (e.storedMarks || !r.textOffset && r.parentOffset && r.nodeBefore.marks.some((s) => s.type.spec.inclusive === !1)))
      i.markCursor = i.state.storedMarks || r.marks(), fx(i, !0), i.markCursor = null;
    else if (fx(i), ps && e.selection.empty && r.parentOffset && !r.textOffset && r.nodeBefore.marks.length) {
      let s = i.domSelectionRange();
      for (let l = s.focusNode, c = s.focusOffset; l && l.nodeType == 1 && c != 0; ) {
        let f = c < 0 ? l.lastChild : l.childNodes[c - 1];
        if (!f)
          break;
        if (f.nodeType == 3) {
          i.domSelection().collapse(f, f.nodeValue.length);
          break;
        } else
          l = f, c = -1;
      }
    }
    i.input.composing = !0;
  }
  D6(i, yte);
};
ba.compositionend = (i, e) => {
  i.composing && (i.input.composing = !1, i.input.compositionEndedAt = e.timeStamp, i.input.compositionPendingChanges = i.domObserver.pendingRecords().length ? i.input.compositionID : 0, i.input.compositionPendingChanges && Promise.resolve().then(() => i.domObserver.flush()), i.input.compositionID++, D6(i, 20));
};
function D6(i, e) {
  clearTimeout(i.input.composingTimeout), e > -1 && (i.input.composingTimeout = setTimeout(() => fx(i), e));
}
function P6(i) {
  for (i.composing && (i.input.composing = !1, i.input.compositionEndedAt = bte()); i.input.compositionNodes.length > 0; )
    i.input.compositionNodes.pop().markParentsDirty();
}
function bte() {
  let i = document.createEvent("Event");
  return i.initEvent("event", !0, !0), i.timeStamp;
}
function fx(i, e = !1) {
  if (!(us && i.domObserver.flushingSoon >= 0)) {
    if (i.domObserver.forceFlush(), P6(i), e || i.docView && i.docView.dirty) {
      let r = P3(i);
      return r && !r.eq(i.state.selection) ? i.dispatch(i.state.tr.setSelection(r)) : i.updateState(i.state), !0;
    }
    return !1;
  }
}
function Ste(i, e) {
  if (!i.dom.parentNode)
    return;
  let r = i.dom.parentNode.appendChild(document.createElement("div"));
  r.appendChild(e), r.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let s = getSelection(), l = document.createRange();
  l.selectNodeContents(e), i.dom.blur(), s.removeAllRanges(), s.addRange(l), setTimeout(() => {
    r.parentNode && r.parentNode.removeChild(r), i.focus();
  }, 50);
}
const dp = za && Eu < 15 || fp && yee < 604;
ya.copy = ba.cut = (i, e) => {
  let r = e, s = i.state.selection, l = r.type == "cut";
  if (s.empty)
    return;
  let c = dp ? null : r.clipboardData, f = s.content(), { dom: p, text: d } = x6(i, f);
  c ? (r.preventDefault(), c.clearData(), c.setData("text/html", p.innerHTML), c.setData("text/plain", d)) : Ste(i, p), l && i.dispatch(i.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function wte(i) {
  return i.openStart == 0 && i.openEnd == 0 && i.content.childCount == 1 ? i.content.firstChild : null;
}
function xte(i, e) {
  if (!i.dom.parentNode)
    return;
  let r = i.input.shiftKey || i.state.selection.$from.parent.type.spec.code, s = i.dom.parentNode.appendChild(document.createElement(r ? "textarea" : "div"));
  r || (s.contentEditable = "true"), s.style.cssText = "position: fixed; left: -10000px; top: 10px", s.focus();
  let l = i.input.shiftKey && i.input.lastKeyCode != 45;
  setTimeout(() => {
    i.focus(), s.parentNode && s.parentNode.removeChild(s), r ? Xg(i, s.value, null, l, e) : Xg(i, s.textContent, s.innerHTML, l, e);
  }, 50);
}
function Xg(i, e, r, s, l) {
  let c = k6(i, e, r, s, i.state.selection.$from);
  if (i.someProp("handlePaste", (d) => d(i, l, c || ur.empty)))
    return !0;
  if (!c)
    return !1;
  let f = wte(c), p = f ? i.state.tr.replaceSelectionWith(f, s) : i.state.tr.replaceSelection(c);
  return i.dispatch(p.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
ba.paste = (i, e) => {
  let r = e;
  if (i.composing && !us)
    return;
  let s = dp ? null : r.clipboardData, l = i.input.shiftKey && i.input.lastKeyCode != 45;
  s && Xg(i, s.getData("text/plain"), s.getData("text/html"), l, r) ? r.preventDefault() : xte(i, r);
};
class kte {
  constructor(e, r) {
    this.slice = e, this.move = r;
  }
}
const L6 = Lo ? "altKey" : "ctrlKey";
ya.dragstart = (i, e) => {
  let r = e, s = i.input.mouseDown;
  if (s && s.done(), !r.dataTransfer)
    return;
  let l = i.state.selection, c = l.empty ? null : i.posAtCoords(zx(r));
  if (!(c && c.pos >= l.from && c.pos <= (l instanceof Er ? l.to - 1 : l.to))) {
    if (s && s.mightDrag)
      i.dispatch(i.state.tr.setSelection(Er.create(i.state.doc, s.mightDrag.pos)));
    else if (r.target && r.target.nodeType == 1) {
      let m = i.docView.nearestDesc(r.target, !0);
      m && m.node.type.spec.draggable && m != i.docView && i.dispatch(i.state.tr.setSelection(Er.create(i.state.doc, m.posBefore)));
    }
  }
  let f = i.state.selection.content(), { dom: p, text: d } = x6(i, f);
  r.dataTransfer.clearData(), r.dataTransfer.setData(dp ? "Text" : "text/html", p.innerHTML), r.dataTransfer.effectAllowed = "copyMove", dp || r.dataTransfer.setData("text/plain", d), i.dragging = new kte(f, !r[L6]);
};
ya.dragend = (i) => {
  let e = i.dragging;
  window.setTimeout(() => {
    i.dragging == e && (i.dragging = null);
  }, 50);
};
ba.dragover = ba.dragenter = (i, e) => e.preventDefault();
ba.drop = (i, e) => {
  let r = e, s = i.dragging;
  if (i.dragging = null, !r.dataTransfer)
    return;
  let l = i.posAtCoords(zx(r));
  if (!l)
    return;
  let c = i.state.doc.resolve(l.pos), f = s && s.slice;
  f ? i.someProp("transformPasted", (k) => {
    f = k(f, i);
  }) : f = k6(i, r.dataTransfer.getData(dp ? "Text" : "text/plain"), dp ? null : r.dataTransfer.getData("text/html"), !1, c);
  let p = !!(s && !r[L6]);
  if (i.someProp("handleDrop", (k) => k(i, r, f || ur.empty, p))) {
    r.preventDefault();
    return;
  }
  if (!f)
    return;
  r.preventDefault();
  let d = f ? tee(i.state.doc, c.pos, f) : c.pos;
  d == null && (d = c.pos);
  let m = i.state.tr;
  p && m.deleteSelection();
  let y = m.mapping.map(d), S = f.openStart == 0 && f.openEnd == 0 && f.content.childCount == 1, x = m.doc;
  if (S ? m.replaceRangeWith(y, y, f.content.firstChild) : m.replaceRange(y, y, f), m.doc.eq(x))
    return;
  let w = m.doc.resolve(y);
  if (S && Er.isSelectable(f.content.firstChild) && w.nodeAfter && w.nodeAfter.sameMarkup(f.content.firstChild))
    m.setSelection(new Er(w));
  else {
    let k = m.mapping.map(d);
    m.mapping.maps[m.mapping.maps.length - 1].forEach((O, T, L, j) => k = j), m.setSelection(L3(i, w, m.doc.resolve(k)));
  }
  i.focus(), i.dispatch(m.setMeta("uiEvent", "drop"));
};
ya.focus = (i) => {
  i.input.lastFocus = Date.now(), i.focused || (i.domObserver.stop(), i.dom.classList.add("ProseMirror-focused"), i.domObserver.start(), i.focused = !0, setTimeout(() => {
    i.docView && i.hasFocus() && !i.domObserver.currentSelection.eq(i.domSelectionRange()) && wl(i);
  }, 20));
};
ya.blur = (i, e) => {
  let r = e;
  i.focused && (i.domObserver.stop(), i.dom.classList.remove("ProseMirror-focused"), i.domObserver.start(), r.relatedTarget && i.dom.contains(r.relatedTarget) && i.domObserver.currentSelection.clear(), i.focused = !1);
};
ya.beforeinput = (i, e) => {
  if (Zi && us && e.inputType == "deleteContentBackward") {
    i.domObserver.flushSoon();
    let { domChangeCount: s } = i.input;
    setTimeout(() => {
      if (i.input.domChangeCount != s || (i.dom.blur(), i.focus(), i.someProp("handleKeyDown", (c) => c(i, Ec(8, "Backspace")))))
        return;
      let { $cursor: l } = i.state.selection;
      l && l.pos > 0 && i.dispatch(i.state.tr.delete(l.pos - 1, l.pos).scrollIntoView());
    }, 50);
  }
};
for (let i in ba)
  ya[i] = ba[i];
function Jg(i, e) {
  if (i == e)
    return !0;
  for (let r in i)
    if (i[r] !== e[r])
      return !1;
  for (let r in e)
    if (!(r in i))
      return !1;
  return !0;
}
class B3 {
  constructor(e, r) {
    this.toDOM = e, this.spec = r || _c, this.side = this.spec.side || 0;
  }
  map(e, r, s, l) {
    let { pos: c, deleted: f } = e.mapResult(r.from + l, this.side < 0 ? -1 : 1);
    return f ? null : new Fa(c - s, c - s, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof B3 && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && Jg(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class Ru {
  constructor(e, r) {
    this.attrs = e, this.spec = r || _c;
  }
  map(e, r, s, l) {
    let c = e.map(r.from + l, this.spec.inclusiveStart ? -1 : 1) - s, f = e.map(r.to + l, this.spec.inclusiveEnd ? 1 : -1) - s;
    return c >= f ? null : new Fa(c, f, this);
  }
  valid(e, r) {
    return r.from < r.to;
  }
  eq(e) {
    return this == e || e instanceof Ru && Jg(this.attrs, e.attrs) && Jg(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof Ru;
  }
  destroy() {
  }
}
class F3 {
  constructor(e, r) {
    this.attrs = e, this.spec = r || _c;
  }
  map(e, r, s, l) {
    let c = e.mapResult(r.from + l, 1);
    if (c.deleted)
      return null;
    let f = e.mapResult(r.to + l, -1);
    return f.deleted || f.pos <= c.pos ? null : new Fa(c.pos - s, f.pos - s, this);
  }
  valid(e, r) {
    let { index: s, offset: l } = e.content.findIndex(r.from), c;
    return l == r.from && !(c = e.child(s)).isText && l + c.nodeSize == r.to;
  }
  eq(e) {
    return this == e || e instanceof F3 && Jg(this.attrs, e.attrs) && Jg(this.spec, e.spec);
  }
  destroy() {
  }
}
class Fa {
  /**
  @internal
  */
  constructor(e, r, s) {
    this.from = e, this.to = r, this.type = s;
  }
  /**
  @internal
  */
  copy(e, r) {
    return new Fa(e, r, this.type);
  }
  /**
  @internal
  */
  eq(e, r = 0) {
    return this.type.eq(e.type) && this.from + r == e.from && this.to + r == e.to;
  }
  /**
  @internal
  */
  map(e, r, s) {
    return this.type.map(e, this, r, s);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, r, s) {
    return new Fa(e, e, new B3(r, s));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, r, s, l) {
    return new Fa(e, r, new Ru(s, l));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, r, s, l) {
    return new Fa(e, r, new F3(s, l));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof Ru;
  }
}
const tp = [], _c = {};
class Bn {
  /**
  @internal
  */
  constructor(e, r) {
    this.local = e.length ? e : tp, this.children = r.length ? r : tp;
  }
  /**
  Create a set of decorations, using the structure of the given
  document.
  */
  static create(e, r) {
    return r.length ? dx(r, e, 0, _c) : Xi;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, r, s) {
    let l = [];
    return this.findInner(e ?? 0, r ?? 1e9, l, 0, s), l;
  }
  findInner(e, r, s, l, c) {
    for (let f = 0; f < this.local.length; f++) {
      let p = this.local[f];
      p.from <= r && p.to >= e && (!c || c(p.spec)) && s.push(p.copy(p.from + l, p.to + l));
    }
    for (let f = 0; f < this.children.length; f += 3)
      if (this.children[f] < r && this.children[f + 1] > e) {
        let p = this.children[f] + 1;
        this.children[f + 2].findInner(e - p, r - p, s, l + p, c);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, r, s) {
    return this == Xi || e.maps.length == 0 ? this : this.mapInner(e, r, 0, 0, s || _c);
  }
  /**
  @internal
  */
  mapInner(e, r, s, l, c) {
    let f;
    for (let p = 0; p < this.local.length; p++) {
      let d = this.local[p].map(e, s, l);
      d && d.type.valid(r, d) ? (f || (f = [])).push(d) : c.onRemove && c.onRemove(this.local[p].spec);
    }
    return this.children.length ? Ote(this.children, f || [], e, r, s, l, c) : f ? new Bn(f.sort(Nc), tp) : Xi;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Needs access to the current document to
  create the appropriate tree structure.
  */
  add(e, r) {
    return r.length ? this == Xi ? Bn.create(e, r) : this.addInner(e, r, 0) : this;
  }
  addInner(e, r, s) {
    let l, c = 0;
    e.forEach((p, d) => {
      let m = d + s, y;
      if (y = _6(r, p, m)) {
        for (l || (l = this.children.slice()); c < l.length && l[c] < d; )
          c += 3;
        l[c] == d ? l[c + 2] = l[c + 2].addInner(p, y, m + 1) : l.splice(c, 0, d, d + p.nodeSize, dx(y, p, m + 1, _c)), c += 3;
      }
    });
    let f = I6(c ? N6(r) : r, -s);
    for (let p = 0; p < f.length; p++)
      f[p].type.valid(e, f[p]) || f.splice(p--, 1);
    return new Bn(f.length ? this.local.concat(f).sort(Nc) : this.local, l || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == Xi ? this : this.removeInner(e, 0);
  }
  removeInner(e, r) {
    let s = this.children, l = this.local;
    for (let c = 0; c < s.length; c += 3) {
      let f, p = s[c] + r, d = s[c + 1] + r;
      for (let y = 0, S; y < e.length; y++)
        (S = e[y]) && S.from > p && S.to < d && (e[y] = null, (f || (f = [])).push(S));
      if (!f)
        continue;
      s == this.children && (s = this.children.slice());
      let m = s[c + 2].removeInner(f, p + 1);
      m != Xi ? s[c + 2] = m : (s.splice(c, 3), c -= 3);
    }
    if (l.length) {
      for (let c = 0, f; c < e.length; c++)
        if (f = e[c])
          for (let p = 0; p < l.length; p++)
            l[p].eq(f, r) && (l == this.local && (l = this.local.slice()), l.splice(p--, 1));
    }
    return s == this.children && l == this.local ? this : l.length || s.length ? new Bn(l, s) : Xi;
  }
  /**
  @internal
  */
  forChild(e, r) {
    if (this == Xi)
      return this;
    if (r.isLeaf)
      return Bn.empty;
    let s, l;
    for (let p = 0; p < this.children.length; p += 3)
      if (this.children[p] >= e) {
        this.children[p] == e && (s = this.children[p + 2]);
        break;
      }
    let c = e + 1, f = c + r.content.size;
    for (let p = 0; p < this.local.length; p++) {
      let d = this.local[p];
      if (d.from < f && d.to > c && d.type instanceof Ru) {
        let m = Math.max(c, d.from) - c, y = Math.min(f, d.to) - c;
        m < y && (l || (l = [])).push(d.copy(m, y));
      }
    }
    if (l) {
      let p = new Bn(l.sort(Nc), tp);
      return s ? new wu([p, s]) : p;
    }
    return s || Xi;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof Bn) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let r = 0; r < this.local.length; r++)
      if (!this.local[r].eq(e.local[r]))
        return !1;
    for (let r = 0; r < this.children.length; r += 3)
      if (this.children[r] != e.children[r] || this.children[r + 1] != e.children[r + 1] || !this.children[r + 2].eq(e.children[r + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return z3(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == Xi)
      return tp;
    if (e.inlineContent || !this.local.some(Ru.is))
      return this.local;
    let r = [];
    for (let s = 0; s < this.local.length; s++)
      this.local[s].type instanceof Ru || r.push(this.local[s]);
    return r;
  }
}
Bn.empty = new Bn([], []);
Bn.removeOverlap = z3;
const Xi = Bn.empty;
class wu {
  constructor(e) {
    this.members = e;
  }
  map(e, r) {
    const s = this.members.map((l) => l.map(e, r, _c));
    return wu.from(s);
  }
  forChild(e, r) {
    if (r.isLeaf)
      return Bn.empty;
    let s = [];
    for (let l = 0; l < this.members.length; l++) {
      let c = this.members[l].forChild(e, r);
      c != Xi && (c instanceof wu ? s = s.concat(c.members) : s.push(c));
    }
    return wu.from(s);
  }
  eq(e) {
    if (!(e instanceof wu) || e.members.length != this.members.length)
      return !1;
    for (let r = 0; r < this.members.length; r++)
      if (!this.members[r].eq(e.members[r]))
        return !1;
    return !0;
  }
  locals(e) {
    let r, s = !0;
    for (let l = 0; l < this.members.length; l++) {
      let c = this.members[l].localsInner(e);
      if (c.length)
        if (!r)
          r = c;
        else {
          s && (r = r.slice(), s = !1);
          for (let f = 0; f < c.length; f++)
            r.push(c[f]);
        }
    }
    return r ? z3(s ? r : r.sort(Nc)) : tp;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return Xi;
      case 1:
        return e[0];
      default:
        return new wu(e.every((r) => r instanceof Bn) ? e : e.reduce((r, s) => r.concat(s instanceof Bn ? s : s.members), []));
    }
  }
}
function Ote(i, e, r, s, l, c, f) {
  let p = i.slice();
  for (let m = 0, y = c; m < r.maps.length; m++) {
    let S = 0;
    r.maps[m].forEach((x, w, k, O) => {
      let T = O - k - (w - x);
      for (let L = 0; L < p.length; L += 3) {
        let j = p[L + 1];
        if (j < 0 || x > j + y - S)
          continue;
        let z = p[L] + y - S;
        w >= z ? p[L + 1] = x <= z ? -2 : -1 : k >= l && T && (p[L] += T, p[L + 1] += T);
      }
      S += T;
    }), y = r.maps[m].map(y, -1);
  }
  let d = !1;
  for (let m = 0; m < p.length; m += 3)
    if (p[m + 1] < 0) {
      if (p[m + 1] == -2) {
        d = !0, p[m + 1] = -1;
        continue;
      }
      let y = r.map(i[m] + c), S = y - l;
      if (S < 0 || S >= s.content.size) {
        d = !0;
        continue;
      }
      let x = r.map(i[m + 1] + c, -1), w = x - l, { index: k, offset: O } = s.content.findIndex(S), T = s.maybeChild(k);
      if (T && O == S && O + T.nodeSize == w) {
        let L = p[m + 2].mapInner(r, T, y + 1, i[m] + c + 1, f);
        L != Xi ? (p[m] = S, p[m + 1] = w, p[m + 2] = L) : (p[m + 1] = -2, d = !0);
      } else
        d = !0;
    }
  if (d) {
    let m = Cte(p, i, e, r, l, c, f), y = dx(m, s, 0, f);
    e = y.local;
    for (let S = 0; S < p.length; S += 3)
      p[S + 1] < 0 && (p.splice(S, 3), S -= 3);
    for (let S = 0, x = 0; S < y.children.length; S += 3) {
      let w = y.children[S];
      for (; x < p.length && p[x] < w; )
        x += 3;
      p.splice(x, 0, y.children[S], y.children[S + 1], y.children[S + 2]);
    }
  }
  return new Bn(e.sort(Nc), p);
}
function I6(i, e) {
  if (!e || !i.length)
    return i;
  let r = [];
  for (let s = 0; s < i.length; s++) {
    let l = i[s];
    r.push(new Fa(l.from + e, l.to + e, l.type));
  }
  return r;
}
function Cte(i, e, r, s, l, c, f) {
  function p(d, m) {
    for (let y = 0; y < d.local.length; y++) {
      let S = d.local[y].map(s, l, m);
      S ? r.push(S) : f.onRemove && f.onRemove(d.local[y].spec);
    }
    for (let y = 0; y < d.children.length; y += 3)
      p(d.children[y + 2], d.children[y] + m + 1);
  }
  for (let d = 0; d < i.length; d += 3)
    i[d + 1] == -1 && p(i[d + 2], e[d] + c + 1);
  return r;
}
function _6(i, e, r) {
  if (e.isLeaf)
    return null;
  let s = r + e.nodeSize, l = null;
  for (let c = 0, f; c < i.length; c++)
    (f = i[c]) && f.from > r && f.to < s && ((l || (l = [])).push(f), i[c] = null);
  return l;
}
function N6(i) {
  let e = [];
  for (let r = 0; r < i.length; r++)
    i[r] != null && e.push(i[r]);
  return e;
}
function dx(i, e, r, s) {
  let l = [], c = !1;
  e.forEach((p, d) => {
    let m = _6(i, p, d + r);
    if (m) {
      c = !0;
      let y = dx(m, p, r + d + 1, s);
      y != Xi && l.push(d, d + p.nodeSize, y);
    }
  });
  let f = I6(c ? N6(i) : i, -r).sort(Nc);
  for (let p = 0; p < f.length; p++)
    f[p].type.valid(e, f[p]) || (s.onRemove && s.onRemove(f[p].spec), f.splice(p--, 1));
  return f.length || l.length ? new Bn(f, l) : Xi;
}
function Nc(i, e) {
  return i.from - e.from || i.to - e.to;
}
function z3(i) {
  let e = i;
  for (let r = 0; r < e.length - 1; r++) {
    let s = e[r];
    if (s.from != s.to)
      for (let l = r + 1; l < e.length; l++) {
        let c = e[l];
        if (c.from == s.from) {
          c.to != s.to && (e == i && (e = i.slice()), e[l] = c.copy(c.from, s.to), IU(e, l + 1, c.copy(s.to, c.to)));
          continue;
        } else {
          c.from < s.to && (e == i && (e = i.slice()), e[r] = s.copy(s.from, c.from), IU(e, l, s.copy(c.from, s.to)));
          break;
        }
      }
  }
  return e;
}
function IU(i, e, r) {
  for (; e < i.length && Nc(r, i[e]) > 0; )
    e++;
  i.splice(e, 0, r);
}
function qH(i) {
  let e = [];
  return i.someProp("decorations", (r) => {
    let s = r(i.state);
    s && s != Xi && e.push(s);
  }), i.cursorWrapper && e.push(Bn.create(i.state.doc, [i.cursorWrapper.deco])), wu.from(e);
}
const Tte = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, Ate = za && Eu <= 11;
class Ete {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
class Mte {
  constructor(e, r) {
    this.view = e, this.handleDOMChange = r, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new Ete(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.observer = window.MutationObserver && new window.MutationObserver((s) => {
      for (let l = 0; l < s.length; l++)
        this.queue.push(s[l]);
      za && Eu <= 11 && s.some((l) => l.type == "childList" && l.removedNodes.length || l.type == "characterData" && l.oldValue.length > l.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), Ate && (this.onCharData = (s) => {
      this.queue.push({ target: s.target, type: "characterData", oldValue: s.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, Tte)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let r = 0; r < e.length; r++)
          this.queue.push(e[r]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (TU(this.view)) {
      if (this.suppressingSelectionUpdates)
        return wl(this.view);
      if (za && Eu <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && Hc(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let r = /* @__PURE__ */ new Set(), s;
    for (let c = e.focusNode; c; c = Kg(c))
      r.add(c);
    for (let c = e.anchorNode; c; c = Kg(c))
      if (r.has(c)) {
        s = c;
        break;
      }
    let l = s && this.view.docView.nearestDesc(s);
    if (l && l.ignoreMutation({
      type: "selection",
      target: s.nodeType == 3 ? s.parentNode : s
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let r = this.pendingRecords();
    r.length && (this.queue = []);
    let s = e.domSelectionRange(), l = !this.suppressingSelectionUpdates && !this.currentSelection.eq(s) && TU(e) && !this.ignoreSelectionChange(s), c = -1, f = -1, p = !1, d = [];
    if (e.editable)
      for (let y = 0; y < r.length; y++) {
        let S = this.registerMutation(r[y], d);
        S && (c = c < 0 ? S.from : Math.min(S.from, c), f = f < 0 ? S.to : Math.max(S.to, f), S.typeOver && (p = !0));
      }
    if (ps && d.length > 1) {
      let y = d.filter((S) => S.nodeName == "BR");
      if (y.length == 2) {
        let S = y[0], x = y[1];
        S.parentNode && S.parentNode.parentNode == x.parentNode ? x.remove() : S.remove();
      }
    }
    let m = null;
    c < 0 && l && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && Nx(s) && (m = P3(e)) && m.eq(jr.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, wl(e), this.currentSelection.set(s), e.scrollToSelection()) : (c > -1 || l) && (c > -1 && (e.docView.markDirty(c, f), Rte(e)), this.handleDOMChange(c, f, p, d), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(s) || wl(e), this.currentSelection.set(s));
  }
  registerMutation(e, r) {
    if (r.indexOf(e.target) > -1)
      return null;
    let s = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (s == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !s || s.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let y = 0; y < e.addedNodes.length; y++)
        r.push(e.addedNodes[y]);
      if (s.contentDOM && s.contentDOM != s.dom && !s.contentDOM.contains(e.target))
        return { from: s.posBefore, to: s.posAfter };
      let l = e.previousSibling, c = e.nextSibling;
      if (za && Eu <= 11 && e.addedNodes.length)
        for (let y = 0; y < e.addedNodes.length; y++) {
          let { previousSibling: S, nextSibling: x } = e.addedNodes[y];
          (!S || Array.prototype.indexOf.call(e.addedNodes, S) < 0) && (l = S), (!x || Array.prototype.indexOf.call(e.addedNodes, x) < 0) && (c = x);
        }
      let f = l && l.parentNode == e.target ? va(l) + 1 : 0, p = s.localPosFromDOM(e.target, f, -1), d = c && c.parentNode == e.target ? va(c) : e.target.childNodes.length, m = s.localPosFromDOM(e.target, d, 1);
      return { from: p, to: m };
    } else return e.type == "attributes" ? { from: s.posAtStart - s.border, to: s.posAtEnd + s.border } : {
      from: s.posAtStart,
      to: s.posAtEnd,
      // An event was generated for a text change that didn't change
      // any text. Mark the dom change to fall back to assuming the
      // selection was typed over with an identical value if it can't
      // find another change.
      typeOver: e.target.nodeValue == e.oldValue
    };
  }
}
let _U = /* @__PURE__ */ new WeakMap(), NU = !1;
function Rte(i) {
  if (!_U.has(i) && (_U.set(i, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(i.dom).whiteSpace) !== -1)) {
    if (i.requiresGeckoHackNode = ps, NU)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), NU = !0;
  }
}
function Dte(i) {
  let e;
  function r(d) {
    d.preventDefault(), d.stopImmediatePropagation(), e = d.getTargetRanges()[0];
  }
  i.dom.addEventListener("beforeinput", r, !0), document.execCommand("indent"), i.dom.removeEventListener("beforeinput", r, !0);
  let s = e.startContainer, l = e.startOffset, c = e.endContainer, f = e.endOffset, p = i.domAtPos(i.state.selection.anchor);
  return Hc(p.node, p.offset, c, f) && ([s, l, c, f] = [c, f, s, l]), { anchorNode: s, anchorOffset: l, focusNode: c, focusOffset: f };
}
function Pte(i, e, r) {
  let { node: s, fromOffset: l, toOffset: c, from: f, to: p } = i.docView.parseRange(e, r), d = i.domSelectionRange(), m, y = d.anchorNode;
  if (y && i.dom.contains(y.nodeType == 1 ? y : y.parentNode) && (m = [{ node: y, offset: d.anchorOffset }], Nx(d) || m.push({ node: d.focusNode, offset: d.focusOffset })), Zi && i.input.lastKeyCode === 8)
    for (let T = c; T > l; T--) {
      let L = s.childNodes[T - 1], j = L.pmViewDesc;
      if (L.nodeName == "BR" && !j) {
        c = T;
        break;
      }
      if (!j || j.size)
        break;
    }
  let S = i.state.doc, x = i.someProp("domParser") || zc.fromSchema(i.state.schema), w = S.resolve(f), k = null, O = x.parse(s, {
    topNode: w.parent,
    topMatch: w.parent.contentMatchAt(w.index()),
    topOpen: !0,
    from: l,
    to: c,
    preserveWhitespace: w.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: m,
    ruleFromNode: Lte,
    context: w
  });
  if (m && m[0].pos != null) {
    let T = m[0].pos, L = m[1] && m[1].pos;
    L == null && (L = T), k = { anchor: T + f, head: L + f };
  }
  return { doc: O, sel: k, from: f, to: p };
}
function Lte(i) {
  let e = i.pmViewDesc;
  if (e)
    return e.parseRule();
  if (i.nodeName == "BR" && i.parentNode) {
    if (ga && /^(ul|ol)$/i.test(i.parentNode.nodeName)) {
      let r = document.createElement("div");
      return r.appendChild(document.createElement("li")), { skip: r };
    } else if (i.parentNode.lastChild == i || ga && /^(tr|table)$/i.test(i.parentNode.nodeName))
      return { ignore: !0 };
  } else if (i.nodeName == "IMG" && i.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const Ite = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function _te(i, e, r, s, l) {
  let c = i.input.compositionPendingChanges || (i.composing ? i.input.compositionID : 0);
  if (i.input.compositionPendingChanges = 0, e < 0) {
    let de = i.input.lastSelectionTime > Date.now() - 50 ? i.input.lastSelectionOrigin : null, Ce = P3(i, de);
    if (Ce && !i.state.selection.eq(Ce)) {
      if (Zi && us && i.input.lastKeyCode === 13 && Date.now() - 100 < i.input.lastKeyCodeTime && i.someProp("handleKeyDown", (oe) => oe(i, Ec(13, "Enter"))))
        return;
      let he = i.state.tr.setSelection(Ce);
      de == "pointer" ? he.setMeta("pointer", !0) : de == "key" && he.scrollIntoView(), c && he.setMeta("composition", c), i.dispatch(he);
    }
    return;
  }
  let f = i.state.doc.resolve(e), p = f.sharedDepth(r);
  e = f.before(p + 1), r = i.state.doc.resolve(r).after(p + 1);
  let d = i.state.selection, m = Pte(i, e, r), y = i.state.doc, S = y.slice(m.from, m.to), x, w;
  i.input.lastKeyCode === 8 && Date.now() - 100 < i.input.lastKeyCodeTime ? (x = i.state.selection.to, w = "end") : (x = i.state.selection.from, w = "start"), i.input.lastKeyCode = null;
  let k = Fte(S.content, m.doc.content, m.from, x, w);
  if ((fp && i.input.lastIOSEnter > Date.now() - 225 || us) && l.some((de) => de.nodeType == 1 && !Ite.test(de.nodeName)) && (!k || k.endA >= k.endB) && i.someProp("handleKeyDown", (de) => de(i, Ec(13, "Enter")))) {
    i.input.lastIOSEnter = 0;
    return;
  }
  if (!k)
    if (s && d instanceof Zr && !d.empty && d.$head.sameParent(d.$anchor) && !i.composing && !(m.sel && m.sel.anchor != m.sel.head))
      k = { start: d.from, endA: d.to, endB: d.to };
    else {
      if (m.sel) {
        let de = BU(i, i.state.doc, m.sel);
        if (de && !de.eq(i.state.selection)) {
          let Ce = i.state.tr.setSelection(de);
          c && Ce.setMeta("composition", c), i.dispatch(Ce);
        }
      }
      return;
    }
  if (Zi && i.cursorWrapper && m.sel && m.sel.anchor == i.cursorWrapper.deco.from && m.sel.head == m.sel.anchor) {
    let de = k.endB - k.start;
    m.sel = { anchor: m.sel.anchor + de, head: m.sel.anchor + de };
  }
  i.input.domChangeCount++, i.state.selection.from < i.state.selection.to && k.start == k.endB && i.state.selection instanceof Zr && (k.start > i.state.selection.from && k.start <= i.state.selection.from + 2 && i.state.selection.from >= m.from ? k.start = i.state.selection.from : k.endA < i.state.selection.to && k.endA >= i.state.selection.to - 2 && i.state.selection.to <= m.to && (k.endB += i.state.selection.to - k.endA, k.endA = i.state.selection.to)), za && Eu <= 11 && k.endB == k.start + 1 && k.endA == k.start && k.start > m.from && m.doc.textBetween(k.start - m.from - 1, k.start - m.from + 1) == "  " && (k.start--, k.endA--, k.endB--);
  let O = m.doc.resolveNoCache(k.start - m.from), T = m.doc.resolveNoCache(k.endB - m.from), L = y.resolve(k.start), j = O.sameParent(T) && O.parent.inlineContent && L.end() >= k.endA, z;
  if ((fp && i.input.lastIOSEnter > Date.now() - 225 && (!j || l.some((de) => de.nodeName == "DIV" || de.nodeName == "P")) || !j && O.pos < m.doc.content.size && !O.sameParent(T) && (z = jr.findFrom(m.doc.resolve(O.pos + 1), 1, !0)) && z.head == T.pos) && i.someProp("handleKeyDown", (de) => de(i, Ec(13, "Enter")))) {
    i.input.lastIOSEnter = 0;
    return;
  }
  if (i.state.selection.anchor > k.start && Bte(y, k.start, k.endA, O, T) && i.someProp("handleKeyDown", (de) => de(i, Ec(8, "Backspace")))) {
    us && Zi && i.domObserver.suppressSelectionUpdates();
    return;
  }
  Zi && us && k.endB == k.start && (i.input.lastAndroidDelete = Date.now()), us && !j && O.start() != T.start() && T.parentOffset == 0 && O.depth == T.depth && m.sel && m.sel.anchor == m.sel.head && m.sel.head == k.endA && (k.endB -= 2, T = m.doc.resolveNoCache(k.endB - m.from), setTimeout(() => {
    i.someProp("handleKeyDown", function(de) {
      return de(i, Ec(13, "Enter"));
    });
  }, 20));
  let J = k.start, ie = k.endA, K, re, ee;
  if (j) {
    if (O.pos == T.pos)
      za && Eu <= 11 && O.parentOffset == 0 && (i.domObserver.suppressSelectionUpdates(), setTimeout(() => wl(i), 20)), K = i.state.tr.delete(J, ie), re = y.resolve(k.start).marksAcross(y.resolve(k.endA));
    else if (
      // Adding or removing a mark
      k.endA == k.endB && (ee = Nte(O.parent.content.cut(O.parentOffset, T.parentOffset), L.parent.content.cut(L.parentOffset, k.endA - L.start())))
    )
      K = i.state.tr, ee.type == "add" ? K.addMark(J, ie, ee.mark) : K.removeMark(J, ie, ee.mark);
    else if (O.parent.child(O.index()).isText && O.index() == T.index() - (T.textOffset ? 0 : 1)) {
      let de = O.parent.textBetween(O.parentOffset, T.parentOffset);
      if (i.someProp("handleTextInput", (Ce) => Ce(i, J, ie, de)))
        return;
      K = i.state.tr.insertText(de, J, ie);
    }
  }
  if (K || (K = i.state.tr.replace(J, ie, m.doc.slice(k.start - m.from, k.endB - m.from))), m.sel) {
    let de = BU(i, K.doc, m.sel);
    de && !(Zi && us && i.composing && de.empty && (k.start != k.endB || i.input.lastAndroidDelete < Date.now() - 100) && (de.head == J || de.head == K.mapping.map(ie) - 1) || za && de.empty && de.head == J) && K.setSelection(de);
  }
  re && K.ensureMarks(re), c && K.setMeta("composition", c), i.dispatch(K.scrollIntoView());
}
function BU(i, e, r) {
  return Math.max(r.anchor, r.head) > e.content.size ? null : L3(i, e.resolve(r.anchor), e.resolve(r.head));
}
function Nte(i, e) {
  let r = i.firstChild.marks, s = e.firstChild.marks, l = r, c = s, f, p, d;
  for (let y = 0; y < s.length; y++)
    l = s[y].removeFromSet(l);
  for (let y = 0; y < r.length; y++)
    c = r[y].removeFromSet(c);
  if (l.length == 1 && c.length == 0)
    p = l[0], f = "add", d = (y) => y.mark(p.addToSet(y.marks));
  else if (l.length == 0 && c.length == 1)
    p = c[0], f = "remove", d = (y) => y.mark(p.removeFromSet(y.marks));
  else
    return null;
  let m = [];
  for (let y = 0; y < e.childCount; y++)
    m.push(d(e.child(y)));
  if (qt.from(m).eq(i))
    return { mark: p, type: f };
}
function Bte(i, e, r, s, l) {
  if (!s.parent.isTextblock || // The content must have shrunk
  r - e <= l.pos - s.pos || // newEnd must point directly at or after the end of the block that newStart points into
  KH(s, !0, !1) < l.pos)
    return !1;
  let c = i.resolve(e);
  if (c.parentOffset < c.parent.content.size || !c.parent.isTextblock)
    return !1;
  let f = i.resolve(KH(c, !0, !0));
  return !f.parent.isTextblock || f.pos > r || KH(f, !0, !1) < r ? !1 : s.parent.content.cut(s.parentOffset).eq(f.parent.content);
}
function KH(i, e, r) {
  let s = i.depth, l = e ? i.end() : i.pos;
  for (; s > 0 && (e || i.indexAfter(s) == i.node(s).childCount); )
    s--, l++, e = !1;
  if (r) {
    let c = i.node(s).maybeChild(i.indexAfter(s));
    for (; c && !c.isLeaf; )
      c = c.firstChild, l++;
  }
  return l;
}
function Fte(i, e, r, s, l) {
  let c = i.findDiffStart(e, r);
  if (c == null)
    return null;
  let { a: f, b: p } = i.findDiffEnd(e, r + i.size, r + e.size);
  if (l == "end") {
    let d = Math.max(0, c - Math.min(f, p));
    s -= f + d - c;
  }
  if (f < c && i.size < e.size) {
    let d = s <= c && s >= f ? c - s : 0;
    c -= d, p = c + (p - f), f = c;
  } else if (p < c) {
    let d = s <= c && s >= p ? c - s : 0;
    c -= d, f = c + (f - p), p = c;
  }
  return { start: c, endA: f, endB: p };
}
class H3 {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, r) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new ate(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = r, this.state = r.state, this.directPlugins = r.plugins || [], this.directPlugins.forEach(WU), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = HU(this), zU(this), this.nodeViews = jU(this), this.docView = SU(this.state.doc, FU(this), qH(this), this.dom, this), this.domObserver = new Mte(this, (s, l, c, f) => _te(this, s, l, c, f)), this.domObserver.start(), ote(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let r in e)
        this._props[r] = e[r];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && e3(this);
    let r = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(WU), this.directPlugins = e.plugins), this.updateStateInner(e.state, r);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let r = {};
    for (let s in this._props)
      r[s] = this._props[s];
    r.state = this.state;
    for (let s in e)
      r[s] = e[s];
    this.update(r);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, r) {
    let s = this.state, l = !1, c = !1;
    e.storedMarks && this.composing && (P6(this), c = !0), this.state = e;
    let f = s.plugins != e.plugins || this._props.plugins != r.plugins;
    if (f || this._props.plugins != r.plugins || this._props.nodeViews != r.nodeViews) {
      let x = jU(this);
      Hte(x, this.nodeViews) && (this.nodeViews = x, l = !0);
    }
    (f || r.handleDOMEvents != this._props.handleDOMEvents) && e3(this), this.editable = HU(this), zU(this);
    let p = qH(this), d = FU(this), m = s.plugins != e.plugins && !s.doc.eq(e.doc) ? "reset" : e.scrollToSelection > s.scrollToSelection ? "to selection" : "preserve", y = l || !this.docView.matchesNode(e.doc, d, p);
    (y || !e.selection.eq(s.selection)) && (c = !0);
    let S = m == "preserve" && c && this.dom.style.overflowAnchor == null && wee(this);
    if (c) {
      this.domObserver.stop();
      let x = y && (za || Zi) && !this.composing && !s.selection.empty && !e.selection.empty && zte(s.selection, e.selection);
      if (y) {
        let w = Zi ? this.trackWrites = this.domSelectionRange().focusNode : null;
        (l || !this.docView.update(e.doc, d, p, this)) && (this.docView.updateOuterDeco([]), this.docView.destroy(), this.docView = SU(e.doc, d, p, this.dom, this)), w && !this.trackWrites && (x = !0);
      }
      x || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && Gee(this)) ? wl(this, x) : (y6(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(s), m == "reset" ? this.dom.scrollTop = 0 : m == "to selection" ? this.scrollToSelection() : S && xee(S);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!this.someProp("handleScrollToSelection", (r) => r(this))) if (this.state.selection instanceof Er) {
      let r = this.docView.domAfterPos(this.state.selection.from);
      r.nodeType == 1 && pU(this, r.getBoundingClientRect(), e);
    } else
      pU(this, this.coordsAtPos(this.state.selection.head, 1), e);
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let r = 0; r < this.directPlugins.length; r++) {
        let s = this.directPlugins[r];
        s.spec.view && this.pluginViews.push(s.spec.view(this));
      }
      for (let r = 0; r < this.state.plugins.length; r++) {
        let s = this.state.plugins[r];
        s.spec.view && this.pluginViews.push(s.spec.view(this));
      }
    } else
      for (let r = 0; r < this.pluginViews.length; r++) {
        let s = this.pluginViews[r];
        s.update && s.update(this, e);
      }
  }
  someProp(e, r) {
    let s = this._props && this._props[e], l;
    if (s != null && (l = r ? r(s) : s))
      return l;
    for (let f = 0; f < this.directPlugins.length; f++) {
      let p = this.directPlugins[f].props[e];
      if (p != null && (l = r ? r(p) : p))
        return l;
    }
    let c = this.state.plugins;
    if (c)
      for (let f = 0; f < c.length; f++) {
        let p = c[f].props[e];
        if (p != null && (l = r ? r(p) : p))
          return l;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (za) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && kee(this.dom), wl(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let r = this.dom.parentNode; r; r = r.parentNode)
        if (r.nodeType == 9 || r.nodeType == 11 && r.host)
          return r.getSelection || (Object.getPrototypeOf(r).getSelection = () => r.ownerDocument.getSelection()), this._root = r;
    }
    return e || document;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return Eee(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, r = 1) {
    return c6(this, e, r);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, r = 0) {
    return this.docView.domFromPos(e, r);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let r = this.docView.descAt(e);
    return r ? r.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, r, s = -1) {
    let l = this.docView.posFromDOM(e, r, s);
    if (l == null)
      throw new RangeError("DOM position not inside the editor");
    return l;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, r) {
    return Lee(this, r || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, r) {
    return Xg(this, "", e, !1, r || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, r) {
    return Xg(this, e, null, !0, r || new ClipboardEvent("paste"));
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (ste(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], qH(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null);
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return ute(this, e);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(e) {
    let r = this._props.dispatchTransaction;
    r ? r.call(this, e) : this.updateState(this.state.apply(e));
  }
  /**
  @internal
  */
  domSelectionRange() {
    return ga && this.root.nodeType === 11 && pee(this.dom.ownerDocument) == this.dom ? Dte(this) : this.domSelection();
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
function FU(i) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(i.editable), i.someProp("attributes", (r) => {
    if (typeof r == "function" && (r = r(i.state)), r)
      for (let s in r)
        s == "class" ? e.class += " " + r[s] : s == "style" ? e.style = (e.style ? e.style + ";" : "") + r[s] : !e[s] && s != "contenteditable" && s != "nodeName" && (e[s] = String(r[s]));
  }), e.translate || (e.translate = "no"), [Fa.node(0, i.state.doc.content.size, e)];
}
function zU(i) {
  if (i.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), i.cursorWrapper = { dom: e, deco: Fa.widget(i.state.selection.head, e, { raw: !0, marks: i.markCursor }) };
  } else
    i.cursorWrapper = null;
}
function HU(i) {
  return !i.someProp("editable", (e) => e(i.state) === !1);
}
function zte(i, e) {
  let r = Math.min(i.$anchor.sharedDepth(i.head), e.$anchor.sharedDepth(e.head));
  return i.$anchor.start(r) != e.$anchor.start(r);
}
function jU(i) {
  let e = /* @__PURE__ */ Object.create(null);
  function r(s) {
    for (let l in s)
      Object.prototype.hasOwnProperty.call(e, l) || (e[l] = s[l]);
  }
  return i.someProp("nodeViews", r), i.someProp("markViews", r), e;
}
function Hte(i, e) {
  let r = 0, s = 0;
  for (let l in i) {
    if (i[l] != e[l])
      return !0;
    r++;
  }
  for (let l in e)
    s++;
  return r != s;
}
function WU(i) {
  if (i.spec.state || i.spec.filterTransaction || i.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
var Lu = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, hx = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, jte = typeof navigator < "u" && /Mac/.test(navigator.platform), Wte = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Ei = 0; Ei < 10; Ei++) Lu[48 + Ei] = Lu[96 + Ei] = String(Ei);
for (var Ei = 1; Ei <= 24; Ei++) Lu[Ei + 111] = "F" + Ei;
for (var Ei = 65; Ei <= 90; Ei++)
  Lu[Ei] = String.fromCharCode(Ei + 32), hx[Ei] = String.fromCharCode(Ei);
for (var XH in Lu) hx.hasOwnProperty(XH) || (hx[XH] = Lu[XH]);
function $te(i) {
  var e = jte && i.metaKey && i.shiftKey && !i.ctrlKey && !i.altKey || Wte && i.shiftKey && i.key && i.key.length == 1 || i.key == "Unidentified", r = !e && i.key || (i.shiftKey ? hx : Lu)[i.keyCode] || i.key || "Unidentified";
  return r == "Esc" && (r = "Escape"), r == "Del" && (r = "Delete"), r == "Left" && (r = "ArrowLeft"), r == "Up" && (r = "ArrowUp"), r == "Right" && (r = "ArrowRight"), r == "Down" && (r = "ArrowDown"), r;
}
const Ute = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function Vte(i) {
  let e = i.split(/-(?!$)/), r = e[e.length - 1];
  r == "Space" && (r = " ");
  let s, l, c, f;
  for (let p = 0; p < e.length - 1; p++) {
    let d = e[p];
    if (/^(cmd|meta|m)$/i.test(d))
      f = !0;
    else if (/^a(lt)?$/i.test(d))
      s = !0;
    else if (/^(c|ctrl|control)$/i.test(d))
      l = !0;
    else if (/^s(hift)?$/i.test(d))
      c = !0;
    else if (/^mod$/i.test(d))
      Ute ? f = !0 : l = !0;
    else
      throw new Error("Unrecognized modifier name: " + d);
  }
  return s && (r = "Alt-" + r), l && (r = "Ctrl-" + r), f && (r = "Meta-" + r), c && (r = "Shift-" + r), r;
}
function Gte(i) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r in i)
    e[Vte(r)] = i[r];
  return e;
}
function JH(i, e, r = !0) {
  return e.altKey && (i = "Alt-" + i), e.ctrlKey && (i = "Ctrl-" + i), e.metaKey && (i = "Meta-" + i), r && e.shiftKey && (i = "Shift-" + i), i;
}
function Zg(i) {
  return new Wa({ props: { handleKeyDown: Yte(i) } });
}
function Yte(i) {
  let e = Gte(i);
  return function(r, s) {
    let l = $te(s), c, f = e[JH(l, s)];
    if (f && f(r.state, r.dispatch, r))
      return !0;
    if (l.length == 1 && l != " ") {
      if (s.shiftKey) {
        let p = e[JH(l, s, !1)];
        if (p && p(r.state, r.dispatch, r))
          return !0;
      }
      if ((s.shiftKey || s.altKey || s.metaKey || l.charCodeAt(0) > 127) && (c = Lu[s.keyCode]) && c != l) {
        let p = e[JH(c, s)];
        if (p && p(r.state, r.dispatch, r))
          return !0;
      }
    }
    return !1;
  };
}
const j3 = (i, e) => i.selection.empty ? !1 : (e && e(i.tr.deleteSelection().scrollIntoView()), !0);
function qte(i, e) {
  let { $cursor: r } = i.selection;
  return !r || (e ? !e.endOfTextblock("backward", i) : r.parentOffset > 0) ? null : r;
}
const Kte = (i, e, r) => {
  let s = qte(i, r);
  if (!s)
    return !1;
  let l = B6(s);
  if (!l) {
    let f = s.blockRange(), p = f && Ix(f);
    return p == null ? !1 : (e && e(i.tr.lift(f, p).scrollIntoView()), !0);
  }
  let c = l.nodeBefore;
  if (!c.type.spec.isolating && W6(i, l, e))
    return !0;
  if (s.parent.content.size == 0 && (hp(c, "end") || Er.isSelectable(c))) {
    let f = E3(i.doc, s.before(), s.after(), ur.empty);
    if (f && f.slice.size < f.to - f.from) {
      if (e) {
        let p = i.tr.step(f);
        p.setSelection(hp(c, "end") ? jr.findFrom(p.doc.resolve(p.mapping.map(l.pos, -1)), -1) : Er.create(p.doc, l.pos - c.nodeSize)), e(p.scrollIntoView());
      }
      return !0;
    }
  }
  return c.isAtom && l.depth == s.depth - 1 ? (e && e(i.tr.delete(l.pos - c.nodeSize, l.pos).scrollIntoView()), !0) : !1;
};
function hp(i, e, r = !1) {
  for (let s = i; s; s = e == "start" ? s.firstChild : s.lastChild) {
    if (s.isTextblock)
      return !0;
    if (r && s.childCount != 1)
      return !1;
  }
  return !1;
}
const Xte = (i, e, r) => {
  let { $head: s, empty: l } = i.selection, c = s;
  if (!l)
    return !1;
  if (s.parent.isTextblock) {
    if (r ? !r.endOfTextblock("backward", i) : s.parentOffset > 0)
      return !1;
    c = B6(s);
  }
  let f = c && c.nodeBefore;
  return !f || !Er.isSelectable(f) ? !1 : (e && e(i.tr.setSelection(Er.create(i.doc, c.pos - f.nodeSize)).scrollIntoView()), !0);
};
function B6(i) {
  if (!i.parent.type.spec.isolating)
    for (let e = i.depth - 1; e >= 0; e--) {
      if (i.index(e) > 0)
        return i.doc.resolve(i.before(e + 1));
      if (i.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function Jte(i, e) {
  let { $cursor: r } = i.selection;
  return !r || (e ? !e.endOfTextblock("forward", i) : r.parentOffset < r.parent.content.size) ? null : r;
}
const F6 = (i, e, r) => {
  let s = Jte(i, r);
  if (!s)
    return !1;
  let l = z6(s);
  if (!l)
    return !1;
  let c = l.nodeAfter;
  if (W6(i, l, e))
    return !0;
  if (s.parent.content.size == 0 && (hp(c, "start") || Er.isSelectable(c))) {
    let f = E3(i.doc, s.before(), s.after(), ur.empty);
    if (f && f.slice.size < f.to - f.from) {
      if (e) {
        let p = i.tr.step(f);
        p.setSelection(hp(c, "start") ? jr.findFrom(p.doc.resolve(p.mapping.map(l.pos)), 1) : Er.create(p.doc, p.mapping.map(l.pos))), e(p.scrollIntoView());
      }
      return !0;
    }
  }
  return c.isAtom && l.depth == s.depth - 1 ? (e && e(i.tr.delete(l.pos, l.pos + c.nodeSize).scrollIntoView()), !0) : !1;
}, Zte = (i, e, r) => {
  let { $head: s, empty: l } = i.selection, c = s;
  if (!l)
    return !1;
  if (s.parent.isTextblock) {
    if (r ? !r.endOfTextblock("forward", i) : s.parentOffset < s.parent.content.size)
      return !1;
    c = z6(s);
  }
  let f = c && c.nodeAfter;
  return !f || !Er.isSelectable(f) ? !1 : (e && e(i.tr.setSelection(Er.create(i.doc, c.pos)).scrollIntoView()), !0);
};
function z6(i) {
  if (!i.parent.type.spec.isolating)
    for (let e = i.depth - 1; e >= 0; e--) {
      let r = i.node(e);
      if (i.index(e) + 1 < r.childCount)
        return i.doc.resolve(i.after(e + 1));
      if (r.type.spec.isolating)
        break;
    }
  return null;
}
const H6 = (i, e) => {
  let { $head: r, $anchor: s } = i.selection;
  return !r.parent.type.spec.code || !r.sameParent(s) ? !1 : (e && e(i.tr.insertText(`
`).scrollIntoView()), !0);
};
function W3(i) {
  for (let e = 0; e < i.edgeCount; e++) {
    let { type: r } = i.edge(e);
    if (r.isTextblock && !r.hasRequiredAttrs())
      return r;
  }
  return null;
}
const $3 = (i, e) => {
  let { $head: r, $anchor: s } = i.selection;
  if (!r.parent.type.spec.code || !r.sameParent(s))
    return !1;
  let l = r.node(-1), c = r.indexAfter(-1), f = W3(l.contentMatchAt(c));
  if (!f || !l.canReplaceWith(c, c, f))
    return !1;
  if (e) {
    let p = r.after(), d = i.tr.replaceWith(p, p, f.createAndFill());
    d.setSelection(jr.near(d.doc.resolve(p), 1)), e(d.scrollIntoView());
  }
  return !0;
}, Qte = (i, e) => {
  let r = i.selection, { $from: s, $to: l } = r;
  if (r instanceof ma || s.parent.inlineContent || l.parent.inlineContent)
    return !1;
  let c = W3(l.parent.contentMatchAt(l.indexAfter()));
  if (!c || !c.isTextblock)
    return !1;
  if (e) {
    let f = (!s.parentOffset && l.index() < l.parent.childCount ? s : l).pos, p = i.tr.insert(f, c.createAndFill());
    p.setSelection(Zr.create(p.doc, f + 1)), e(p.scrollIntoView());
  }
  return !0;
}, ere = (i, e) => {
  let { $cursor: r } = i.selection;
  if (!r || r.parent.content.size)
    return !1;
  if (r.depth > 1 && r.after() != r.end(-1)) {
    let c = r.before();
    if (op(i.doc, c))
      return e && e(i.tr.split(c).scrollIntoView()), !0;
  }
  let s = r.blockRange(), l = s && Ix(s);
  return l == null ? !1 : (e && e(i.tr.lift(s, l).scrollIntoView()), !0);
};
function tre(i) {
  return (e, r) => {
    let { $from: s, $to: l } = e.selection;
    if (e.selection instanceof Er && e.selection.node.isBlock)
      return !s.parentOffset || !op(e.doc, s.pos) ? !1 : (r && r(e.tr.split(s.pos).scrollIntoView()), !0);
    if (!s.parent.isBlock)
      return !1;
    if (r) {
      let c = l.parentOffset == l.parent.content.size, f = e.tr;
      (e.selection instanceof Zr || e.selection instanceof ma) && f.deleteSelection();
      let p = s.depth == 0 ? null : W3(s.node(-1).contentMatchAt(s.indexAfter(-1))), d = c && p ? [{ type: p }] : void 0, m = op(f.doc, f.mapping.map(s.pos), 1, d);
      if (!d && !m && op(f.doc, f.mapping.map(s.pos), 1, p ? [{ type: p }] : void 0) && (p && (d = [{ type: p }]), m = !0), m && (f.split(f.mapping.map(s.pos), 1, d), !c && !s.parentOffset && s.parent.type != p)) {
        let y = f.mapping.map(s.before()), S = f.doc.resolve(y);
        p && s.node(-1).canReplaceWith(S.index(), S.index() + 1, p) && f.setNodeMarkup(f.mapping.map(s.before()), p);
      }
      r(f.scrollIntoView());
    }
    return !0;
  };
}
const rre = tre(), j6 = (i, e) => (e && e(i.tr.setSelection(new ma(i.doc))), !0);
function nre(i, e, r) {
  let s = e.nodeBefore, l = e.nodeAfter, c = e.index();
  return !s || !l || !s.type.compatibleContent(l.type) ? !1 : !s.content.size && e.parent.canReplace(c - 1, c) ? (r && r(i.tr.delete(e.pos - s.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(c, c + 1) || !(l.isTextblock || JV(i.doc, e.pos)) ? !1 : (r && r(i.tr.clearIncompatible(e.pos, s.type, s.contentMatchAt(s.childCount)).join(e.pos).scrollIntoView()), !0);
}
function W6(i, e, r) {
  let s = e.nodeBefore, l = e.nodeAfter, c, f;
  if (s.type.spec.isolating || l.type.spec.isolating)
    return !1;
  if (nre(i, e, r))
    return !0;
  let p = e.parent.canReplace(e.index(), e.index() + 1);
  if (p && (c = (f = s.contentMatchAt(s.childCount)).findWrapping(l.type)) && f.matchType(c[0] || l.type).validEnd) {
    if (r) {
      let S = e.pos + l.nodeSize, x = qt.empty;
      for (let O = c.length - 1; O >= 0; O--)
        x = qt.from(c[O].create(null, x));
      x = qt.from(s.copy(x));
      let w = i.tr.step(new mi(e.pos - 1, S, e.pos, S, new ur(x, 1, 0), c.length, !0)), k = S + 2 * c.length;
      JV(w.doc, k) && w.join(k), r(w.scrollIntoView());
    }
    return !0;
  }
  let d = jr.findFrom(e, 1), m = d && d.$from.blockRange(d.$to), y = m && Ix(m);
  if (y != null && y >= e.depth)
    return r && r(i.tr.lift(m, y).scrollIntoView()), !0;
  if (p && hp(l, "start", !0) && hp(s, "end")) {
    let S = s, x = [];
    for (; x.push(S), !S.isTextblock; )
      S = S.lastChild;
    let w = l, k = 1;
    for (; !w.isTextblock; w = w.firstChild)
      k++;
    if (S.canReplace(S.childCount, S.childCount, w.content)) {
      if (r) {
        let O = qt.empty;
        for (let L = x.length - 1; L >= 0; L--)
          O = qt.from(x[L].copy(O));
        let T = i.tr.step(new mi(e.pos - x.length, e.pos + l.nodeSize, e.pos + k, e.pos + l.nodeSize - k, new ur(O, x.length, 0), 0, !0));
        r(T.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function $6(i) {
  return function(e, r) {
    let s = e.selection, l = i < 0 ? s.$from : s.$to, c = l.depth;
    for (; l.node(c).isInline; ) {
      if (!c)
        return !1;
      c--;
    }
    return l.node(c).isTextblock ? (r && r(e.tr.setSelection(Zr.create(e.doc, i < 0 ? l.start(c) : l.end(c)))), !0) : !1;
  };
}
const ire = $6(-1), are = $6(1);
function ore(i, e = null) {
  return function(r, s) {
    let { $from: l, $to: c } = r.selection, f = l.blockRange(c), p = f && UQ(f, i, e);
    return p ? (s && s(r.tr.wrap(f, p).scrollIntoView()), !0) : !1;
  };
}
function U3(i, e = null) {
  return function(r, s) {
    let l = !1;
    for (let c = 0; c < r.selection.ranges.length && !l; c++) {
      let { $from: { pos: f }, $to: { pos: p } } = r.selection.ranges[c];
      r.doc.nodesBetween(f, p, (d, m) => {
        if (l)
          return !1;
        if (!(!d.isTextblock || d.hasMarkup(i, e)))
          if (d.type == i)
            l = !0;
          else {
            let y = r.doc.resolve(m), S = y.index();
            l = y.parent.canReplaceWith(S, S + 1, i);
          }
      });
    }
    if (!l)
      return !1;
    if (s) {
      let c = r.tr;
      for (let f = 0; f < r.selection.ranges.length; f++) {
        let { $from: { pos: p }, $to: { pos: d } } = r.selection.ranges[f];
        c.setBlockType(p, d, i, e);
      }
      s(c.scrollIntoView());
    }
    return !0;
  };
}
function sre(i, e, r) {
  for (let s = 0; s < e.length; s++) {
    let { $from: l, $to: c } = e[s], f = l.depth == 0 ? i.inlineContent && i.type.allowsMarkType(r) : !1;
    if (i.nodesBetween(l.pos, c.pos, (p) => {
      if (f)
        return !1;
      f = p.inlineContent && p.type.allowsMarkType(r);
    }), f)
      return !0;
  }
  return !1;
}
function ny(i, e = null) {
  return function(r, s) {
    let { empty: l, $cursor: c, ranges: f } = r.selection;
    if (l && !c || !sre(r.doc, f, i))
      return !1;
    if (s)
      if (c)
        i.isInSet(r.storedMarks || c.marks()) ? s(r.tr.removeStoredMark(i)) : s(r.tr.addStoredMark(i.create(e)));
      else {
        let p = !1, d = r.tr;
        for (let m = 0; !p && m < f.length; m++) {
          let { $from: y, $to: S } = f[m];
          p = r.doc.rangeHasMark(y.pos, S.pos, i);
        }
        for (let m = 0; m < f.length; m++) {
          let { $from: y, $to: S } = f[m];
          if (p)
            d.removeMark(y.pos, S.pos, i);
          else {
            let x = y.pos, w = S.pos, k = y.nodeAfter, O = S.nodeBefore, T = k && k.isText ? /^\s*/.exec(k.text)[0].length : 0, L = O && O.isText ? /\s*$/.exec(O.text)[0].length : 0;
            x + T < w && (x += T, w -= L), d.addMark(x, w, i.create(e));
          }
        }
        s(d.scrollIntoView());
      }
    return !0;
  };
}
function Hx(...i) {
  return function(e, r, s) {
    for (let l = 0; l < i.length; l++)
      if (i[l](e, r, s))
        return !0;
    return !1;
  };
}
let ZH = Hx(j3, Kte, Xte), $U = Hx(j3, F6, Zte);
const gl = {
  Enter: Hx(H6, Qte, ere, rre),
  "Mod-Enter": $3,
  Backspace: ZH,
  "Mod-Backspace": ZH,
  "Shift-Backspace": ZH,
  Delete: $U,
  "Mod-Delete": $U,
  "Mod-a": j6
}, U6 = {
  "Ctrl-h": gl.Backspace,
  "Alt-Backspace": gl["Mod-Backspace"],
  "Ctrl-d": gl.Delete,
  "Ctrl-Alt-Backspace": gl["Mod-Delete"],
  "Alt-Delete": gl["Mod-Delete"],
  "Alt-d": gl["Mod-Delete"],
  "Ctrl-a": ire,
  "Ctrl-e": are
};
for (let i in gl)
  U6[i] = gl[i];
const lre = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform ? os.platform() == "darwin" : !1, UU = lre ? U6 : gl;
class V6 {
  // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number) → ?Transaction>)
  /**
  Create an input rule. The rule applies when the user typed
  something and the text directly in front of the cursor matches
  `match`, which should end with `$`.
  
  The `handler` can be a string, in which case the matched text, or
  the first matched group in the regexp, is replaced by that
  string.
  
  Or a it can be a function, which will be called with the match
  array produced by
  [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),
  as well as the start and end of the matched range, and which can
  return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the
  rule's effect, or null to indicate the input was not handled.
  */
  constructor(e, r) {
    this.match = e, this.match = e, this.handler = typeof r == "string" ? ure(r) : r;
  }
}
function ure(i) {
  return function(e, r, s, l) {
    let c = i;
    if (r[1]) {
      let f = r[0].lastIndexOf(r[1]);
      c += r[0].slice(f + r[1].length), s += f;
      let p = s - l;
      p > 0 && (c = r[0].slice(f - p, f) + c, s = l);
    }
    return e.tr.insertText(c, s, l);
  };
}
const cre = 500;
function G6({ rules: i }) {
  let e = new Wa({
    state: {
      init() {
        return null;
      },
      apply(r, s) {
        let l = r.getMeta(this);
        return l || (r.selectionSet || r.docChanged ? null : s);
      }
    },
    props: {
      handleTextInput(r, s, l, c) {
        return VU(r, s, l, c, i, e);
      },
      handleDOMEvents: {
        compositionend: (r) => {
          setTimeout(() => {
            let { $cursor: s } = r.state.selection;
            s && VU(r, s.pos, s.pos, "", i, e);
          });
        }
      }
    },
    isInputRules: !0
  });
  return e;
}
function VU(i, e, r, s, l, c) {
  if (i.composing)
    return !1;
  let f = i.state, p = f.doc.resolve(e);
  if (p.parent.type.spec.code)
    return !1;
  let d = p.parent.textBetween(Math.max(0, p.parentOffset - cre), p.parentOffset, null, "￼") + s;
  for (let m = 0; m < l.length; m++) {
    let y = l[m].match.exec(d), S = y && l[m].handler(f, y, e - (y[0].length - s.length), r);
    if (S)
      return i.dispatch(S.setMeta(c, { transform: S, from: e, to: r, text: s })), !0;
  }
  return !1;
}
const fre = (i, e) => {
  let r = i.plugins;
  for (let s = 0; s < r.length; s++) {
    let l = r[s], c;
    if (l.spec.isInputRules && (c = l.getState(i))) {
      if (e) {
        let f = i.tr, p = c.transform;
        for (let d = p.steps.length - 1; d >= 0; d--)
          f.step(p.steps[d].invert(p.docs[d]));
        if (c.text) {
          let d = f.doc.resolve(c.from).marks();
          f.replaceWith(c.from, c.to, i.schema.text(c.text, d));
        } else
          f.delete(c.from, c.to);
        e(f);
      }
      return !0;
    }
  }
  return !1;
};
var px = 200, gi = function() {
};
gi.prototype.append = function(e) {
  return e.length ? (e = gi.from(e), !this.length && e || e.length < px && this.leafAppend(e) || this.length < px && e.leafPrepend(this) || this.appendInner(e)) : this;
};
gi.prototype.prepend = function(e) {
  return e.length ? gi.from(e).append(this) : this;
};
gi.prototype.appendInner = function(e) {
  return new dre(this, e);
};
gi.prototype.slice = function(e, r) {
  return e === void 0 && (e = 0), r === void 0 && (r = this.length), e >= r ? gi.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, r));
};
gi.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
gi.prototype.forEach = function(e, r, s) {
  r === void 0 && (r = 0), s === void 0 && (s = this.length), r <= s ? this.forEachInner(e, r, s, 0) : this.forEachInvertedInner(e, r, s, 0);
};
gi.prototype.map = function(e, r, s) {
  r === void 0 && (r = 0), s === void 0 && (s = this.length);
  var l = [];
  return this.forEach(function(c, f) {
    return l.push(e(c, f));
  }, r, s), l;
};
gi.from = function(e) {
  return e instanceof gi ? e : e && e.length ? new Y6(e) : gi.empty;
};
var Y6 = /* @__PURE__ */ function(i) {
  function e(s) {
    i.call(this), this.values = s;
  }
  i && (e.__proto__ = i), e.prototype = Object.create(i && i.prototype), e.prototype.constructor = e;
  var r = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(l, c) {
    return l == 0 && c == this.length ? this : new e(this.values.slice(l, c));
  }, e.prototype.getInner = function(l) {
    return this.values[l];
  }, e.prototype.forEachInner = function(l, c, f, p) {
    for (var d = c; d < f; d++)
      if (l(this.values[d], p + d) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(l, c, f, p) {
    for (var d = c - 1; d >= f; d--)
      if (l(this.values[d], p + d) === !1)
        return !1;
  }, e.prototype.leafAppend = function(l) {
    if (this.length + l.length <= px)
      return new e(this.values.concat(l.flatten()));
  }, e.prototype.leafPrepend = function(l) {
    if (this.length + l.length <= px)
      return new e(l.flatten().concat(this.values));
  }, r.length.get = function() {
    return this.values.length;
  }, r.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, r), e;
}(gi);
gi.empty = new Y6([]);
var dre = /* @__PURE__ */ function(i) {
  function e(r, s) {
    i.call(this), this.left = r, this.right = s, this.length = r.length + s.length, this.depth = Math.max(r.depth, s.depth) + 1;
  }
  return i && (e.__proto__ = i), e.prototype = Object.create(i && i.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(s) {
    return s < this.left.length ? this.left.get(s) : this.right.get(s - this.left.length);
  }, e.prototype.forEachInner = function(s, l, c, f) {
    var p = this.left.length;
    if (l < p && this.left.forEachInner(s, l, Math.min(c, p), f) === !1 || c > p && this.right.forEachInner(s, Math.max(l - p, 0), Math.min(this.length, c) - p, f + p) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(s, l, c, f) {
    var p = this.left.length;
    if (l > p && this.right.forEachInvertedInner(s, l - p, Math.max(c, p) - p, f + p) === !1 || c < p && this.left.forEachInvertedInner(s, Math.min(l, p), c, f) === !1)
      return !1;
  }, e.prototype.sliceInner = function(s, l) {
    if (s == 0 && l == this.length)
      return this;
    var c = this.left.length;
    return l <= c ? this.left.slice(s, l) : s >= c ? this.right.slice(s - c, l - c) : this.left.slice(s, c).append(this.right.slice(0, l - c));
  }, e.prototype.leafAppend = function(s) {
    var l = this.right.leafAppend(s);
    if (l)
      return new e(this.left, l);
  }, e.prototype.leafPrepend = function(s) {
    var l = this.left.leafPrepend(s);
    if (l)
      return new e(l, this.right);
  }, e.prototype.appendInner = function(s) {
    return this.left.depth >= Math.max(this.right.depth, s.depth) + 1 ? new e(this.left, new e(this.right, s)) : new e(this, s);
  }, e;
}(gi);
const hre = 500;
class cs {
  constructor(e, r) {
    this.items = e, this.eventCount = r;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, r) {
    if (this.eventCount == 0)
      return null;
    let s = this.items.length;
    for (; ; s--)
      if (this.items.get(s - 1).selection) {
        --s;
        break;
      }
    let l, c;
    r && (l = this.remapping(s, this.items.length), c = l.maps.length);
    let f = e.tr, p, d, m = [], y = [];
    return this.items.forEach((S, x) => {
      if (!S.step) {
        l || (l = this.remapping(s, x + 1), c = l.maps.length), c--, y.push(S);
        return;
      }
      if (l) {
        y.push(new Is(S.map));
        let w = S.step.map(l.slice(c)), k;
        w && f.maybeStep(w).doc && (k = f.mapping.maps[f.mapping.maps.length - 1], m.push(new Is(k, void 0, void 0, m.length + y.length))), c--, k && l.appendMap(k, c);
      } else
        f.maybeStep(S.step);
      if (S.selection)
        return p = l ? S.selection.map(l.slice(c)) : S.selection, d = new cs(this.items.slice(0, s).append(y.reverse().concat(m)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: d, transform: f, selection: p };
  }
  // Create a new branch with the given transform added.
  addTransform(e, r, s, l) {
    let c = [], f = this.eventCount, p = this.items, d = !l && p.length ? p.get(p.length - 1) : null;
    for (let y = 0; y < e.steps.length; y++) {
      let S = e.steps[y].invert(e.docs[y]), x = new Is(e.mapping.maps[y], S, r), w;
      (w = d && d.merge(x)) && (x = w, y ? c.pop() : p = p.slice(0, p.length - 1)), c.push(x), r && (f++, r = void 0), l || (d = x);
    }
    let m = f - s.depth;
    return m > vre && (p = pre(p, m), f -= m), new cs(p.append(c), f);
  }
  remapping(e, r) {
    let s = new ap();
    return this.items.forEach((l, c) => {
      let f = l.mirrorOffset != null && c - l.mirrorOffset >= e ? s.maps.length - l.mirrorOffset : void 0;
      s.appendMap(l.map, f);
    }, e, r), s;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new cs(this.items.append(e.map((r) => new Is(r))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, r) {
    if (!this.eventCount)
      return this;
    let s = [], l = Math.max(0, this.items.length - r), c = e.mapping, f = e.steps.length, p = this.eventCount;
    this.items.forEach((x) => {
      x.selection && p--;
    }, l);
    let d = r;
    this.items.forEach((x) => {
      let w = c.getMirror(--d);
      if (w == null)
        return;
      f = Math.min(f, w);
      let k = c.maps[w];
      if (x.step) {
        let O = e.steps[w].invert(e.docs[w]), T = x.selection && x.selection.map(c.slice(d + 1, w));
        T && p++, s.push(new Is(k, O, T));
      } else
        s.push(new Is(k));
    }, l);
    let m = [];
    for (let x = r; x < f; x++)
      m.push(new Is(c.maps[x]));
    let y = this.items.slice(0, l).append(m).append(s), S = new cs(y, p);
    return S.emptyItemCount() > hre && (S = S.compress(this.items.length - s.length)), S;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((r) => {
      r.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let r = this.remapping(0, e), s = r.maps.length, l = [], c = 0;
    return this.items.forEach((f, p) => {
      if (p >= e)
        l.push(f), f.selection && c++;
      else if (f.step) {
        let d = f.step.map(r.slice(s)), m = d && d.getMap();
        if (s--, m && r.appendMap(m, s), d) {
          let y = f.selection && f.selection.map(r.slice(s));
          y && c++;
          let S = new Is(m.invert(), d, y), x, w = l.length - 1;
          (x = l.length && l[w].merge(S)) ? l[w] = x : l.push(S);
        }
      } else f.map && s--;
    }, this.items.length, 0), new cs(gi.from(l.reverse()), c);
  }
}
cs.empty = new cs(gi.empty, 0);
function pre(i, e) {
  let r;
  return i.forEach((s, l) => {
    if (s.selection && e-- == 0)
      return r = l, !1;
  }), i.slice(r);
}
class Is {
  constructor(e, r, s, l) {
    this.map = e, this.step = r, this.selection = s, this.mirrorOffset = l;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let r = e.step.merge(this.step);
      if (r)
        return new Is(r.getMap().invert(), r, this.selection);
    }
  }
}
class Su {
  constructor(e, r, s, l, c) {
    this.done = e, this.undone = r, this.prevRanges = s, this.prevTime = l, this.prevComposition = c;
  }
}
const vre = 20;
function mre(i, e, r, s) {
  let l = r.getMeta(xl), c;
  if (l)
    return l.historyState;
  r.getMeta(yre) && (i = new Su(i.done, i.undone, null, 0, -1));
  let f = r.getMeta("appendedTransaction");
  if (r.steps.length == 0)
    return i;
  if (f && f.getMeta(xl))
    return f.getMeta(xl).redo ? new Su(i.done.addTransform(r, void 0, s, Kw(e)), i.undone, GU(r.mapping.maps[r.steps.length - 1]), i.prevTime, i.prevComposition) : new Su(i.done, i.undone.addTransform(r, void 0, s, Kw(e)), null, i.prevTime, i.prevComposition);
  if (r.getMeta("addToHistory") !== !1 && !(f && f.getMeta("addToHistory") === !1)) {
    let p = r.getMeta("composition"), d = i.prevTime == 0 || !f && i.prevComposition != p && (i.prevTime < (r.time || 0) - s.newGroupDelay || !gre(r, i.prevRanges)), m = f ? QH(i.prevRanges, r.mapping) : GU(r.mapping.maps[r.steps.length - 1]);
    return new Su(i.done.addTransform(r, d ? e.selection.getBookmark() : void 0, s, Kw(e)), cs.empty, m, r.time, p ?? i.prevComposition);
  } else return (c = r.getMeta("rebased")) ? new Su(i.done.rebased(r, c), i.undone.rebased(r, c), QH(i.prevRanges, r.mapping), i.prevTime, i.prevComposition) : new Su(i.done.addMaps(r.mapping.maps), i.undone.addMaps(r.mapping.maps), QH(i.prevRanges, r.mapping), i.prevTime, i.prevComposition);
}
function gre(i, e) {
  if (!e)
    return !1;
  if (!i.docChanged)
    return !0;
  let r = !1;
  return i.mapping.maps[0].forEach((s, l) => {
    for (let c = 0; c < e.length; c += 2)
      s <= e[c + 1] && l >= e[c] && (r = !0);
  }), r;
}
function GU(i) {
  let e = [];
  return i.forEach((r, s, l, c) => e.push(l, c)), e;
}
function QH(i, e) {
  if (!i)
    return null;
  let r = [];
  for (let s = 0; s < i.length; s += 2) {
    let l = e.map(i[s], 1), c = e.map(i[s + 1], -1);
    l <= c && r.push(l, c);
  }
  return r;
}
function q6(i, e, r, s) {
  let l = Kw(e), c = xl.get(e).spec.config, f = (s ? i.undone : i.done).popEvent(e, l);
  if (!f)
    return;
  let p = f.selection.resolve(f.transform.doc), d = (s ? i.done : i.undone).addTransform(f.transform, e.selection.getBookmark(), c, l), m = new Su(s ? d : f.remaining, s ? f.remaining : d, null, 0, -1);
  r(f.transform.setSelection(p).setMeta(xl, { redo: s, historyState: m }).scrollIntoView());
}
let ej = !1, YU = null;
function Kw(i) {
  let e = i.plugins;
  if (YU != e) {
    ej = !1, YU = e;
    for (let r = 0; r < e.length; r++)
      if (e[r].spec.historyPreserveItems) {
        ej = !0;
        break;
      }
  }
  return ej;
}
const xl = new ty("history"), yre = new ty("closeHistory");
function K6(i = {}) {
  return i = {
    depth: i.depth || 100,
    newGroupDelay: i.newGroupDelay || 500
  }, new Wa({
    key: xl,
    state: {
      init() {
        return new Su(cs.empty, cs.empty, null, 0, -1);
      },
      apply(e, r, s) {
        return mre(r, s, e, i);
      }
    },
    config: i,
    props: {
      handleDOMEvents: {
        beforeinput(e, r) {
          let s = r.inputType, l = s == "historyUndo" ? Gg : s == "historyRedo" ? V3 : null;
          return l ? (r.preventDefault(), l(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
const Gg = (i, e) => {
  let r = xl.getState(i);
  return !r || r.done.eventCount == 0 ? !1 : (e && q6(r, i, e, !1), !0);
}, V3 = (i, e) => {
  let r = xl.getState(i);
  return !r || r.undone.eventCount == 0 ? !1 : (e && q6(r, i, e, !0), !0);
};
function bre(i) {
  let e = xl.getState(i);
  return e ? e.done.eventCount : 0;
}
/**
 * @toast-ui/editor
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var t3 = function(i, e) {
  return t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, s) {
    r.__proto__ = s;
  } || function(r, s) {
    for (var l in s) Object.prototype.hasOwnProperty.call(s, l) && (r[l] = s[l]);
  }, t3(i, e);
};
function pr(i, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  t3(i, e);
  function r() {
    this.constructor = i;
  }
  i.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
}
var Nt = function() {
  return Nt = Object.assign || function(e) {
    for (var r, s = 1, l = arguments.length; s < l; s++) {
      r = arguments[s];
      for (var c in r) Object.prototype.hasOwnProperty.call(r, c) && (e[c] = r[c]);
    }
    return e;
  }, Nt.apply(this, arguments);
};
function Ha(i, e, r) {
  if (arguments.length === 2) for (var s = 0, l = e.length, c; s < l; s++)
    (c || !(s in e)) && (c || (c = Array.prototype.slice.call(e, 0, s)), c[s] = e[s]);
  return i.concat(c || Array.prototype.slice.call(e));
}
function Kr(i, e) {
  return Object.defineProperty ? Object.defineProperty(i, "raw", { value: e }) : i.raw = e, i;
}
function Sre(i, e, r) {
  var s;
  r = r || null;
  for (s in i)
    if (i.hasOwnProperty(s) && e.call(r, i[s], s, i) === !1)
      break;
}
var pp = Sre;
function wre(i, e) {
  var r = Object.prototype.hasOwnProperty, s, l, c, f;
  for (c = 1, f = arguments.length; c < f; c += 1) {
    s = arguments[c];
    for (l in s)
      r.call(s, l) && (i[l] = s[l]);
  }
  return i;
}
var G3 = wre;
function xre(i) {
  return typeof i == "string" || i instanceof String;
}
var Tl = xre;
function kre(i) {
  return i instanceof Array;
}
var Op = kre;
function Ore(i, e, r) {
  var s = 0, l = i.length;
  for (r = r || null; s < l && e.call(r, i[s], s, i) !== !1; s += 1)
    ;
}
var vp = Ore, Cre = Op, Tre = vp, Are = pp;
function Ere(i, e, r) {
  Cre(i) ? Tre(i, e, r) : Are(i, e, r);
}
var jx = Ere, Mre = Tl, Rre = jx;
function Dre(i, e, r) {
  var s = i.style;
  if (Mre(e)) {
    s[e] = r;
    return;
  }
  Rre(e, function(l, c) {
    s[c] = l;
  });
}
var js = Dre, Pre = Op;
function Lre(i, e, r) {
  var s, l;
  if (r = r || 0, !Pre(e))
    return -1;
  if (Array.prototype.indexOf)
    return Array.prototype.indexOf.call(e, i, r);
  for (l = e.length, s = r; r >= 0 && s < l; s += 1)
    if (e[s] === i)
      return s;
  return -1;
}
var Wc = Lre;
function Ire(i) {
  return i === void 0;
}
var vs = Ire, _re = vs;
function Nre(i) {
  return !i || !i.className ? "" : _re(i.className.baseVal) ? i.className : i.className.baseVal;
}
var Y3 = Nre, Bre = Op, Fre = vs;
function zre(i, e) {
  if (e = Bre(e) ? e.join(" ") : e, e = e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), Fre(i.className.baseVal)) {
    i.className = e;
    return;
  }
  i.className.baseVal = e;
}
var X6 = zre, qU = jx, Hre = Wc, jre = Y3, Wre = X6;
function $re(i) {
  var e = Array.prototype.slice.call(arguments, 1), r = i.classList, s = [], l;
  if (r) {
    qU(e, function(c) {
      i.classList.add(c);
    });
    return;
  }
  l = jre(i), l && (e = [].concat(l.split(/\s+/), e)), qU(e, function(c) {
    Hre(c, s) < 0 && s.push(c);
  }), Wre(i, s);
}
var Bs = $re, KU = vp, Ure = Wc, Vre = Y3, Gre = X6;
function Yre(i) {
  var e = Array.prototype.slice.call(arguments, 1), r = i.classList, s, l;
  if (r) {
    KU(e, function(c) {
      r.remove(c);
    });
    return;
  }
  s = Vre(i).split(/\s+/), l = [], KU(s, function(c) {
    Ure(c, e) < 0 && l.push(c);
  }), Gre(i, l);
}
var fs = Yre;
function qre(i) {
  return typeof i == "number" || i instanceof Number;
}
var yl = qre;
function Kre(i) {
  return i === null;
}
var vx = Kre, Xre = pp;
function Jre(i, e) {
  var r = document.createElement("img"), s = "";
  return Xre(e, function(l, c) {
    s += "&" + c + "=" + l;
  }), s = s.substring(1), r.src = i + "?" + s, r.style.display = "none", document.body.appendChild(r), document.body.removeChild(r), r;
}
var Zre = Jre, Qre = vs, ene = Zre, tne = 7 * 24 * 60 * 60 * 1e3;
function rne(i) {
  var e = (/* @__PURE__ */ new Date()).getTime();
  return e - i > tne;
}
function nne(i, e) {
  var r = "https://www.google-analytics.com/collect", s = location.hostname, l = "event", c = "use", f = "TOAST UI " + i + " for " + s + ": Statistics", p = window.localStorage.getItem(f);
  !Qre(window.tui) && window.tui.usageStatistics === !1 || p && !rne(p) || (window.localStorage.setItem(f, (/* @__PURE__ */ new Date()).getTime()), setTimeout(function() {
    (document.readyState === "interactive" || document.readyState === "complete") && ene(r, {
      v: 1,
      t: l,
      tid: e,
      cid: s,
      dp: s,
      dh: i,
      el: i,
      ec: c
    });
  }, 1e3));
}
var ine = nne, ane = /[\u0020]+/g, one = /[>(){}[\]+-.!#|]/g, XU = /<([a-zA-Z_][a-zA-Z0-9\-._]*)(\s|[^\\>])*\/?>|<(\/)([a-zA-Z_][a-zA-Z0-9\-._]*)\s*\/?>|<!--[^-]+-->|<([a-zA-Z_][a-zA-Z0-9\-.:/]*)>/g, JU = /\\[!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~\\]/g, sne = /[*_~`]/g, ZU = /!\[.*\]\(.*\)/g, lne = /[[\]]/g, QU = /(?:^|[^\\])\\(?!\\)/g, une = '[&<>"]', e8 = new RegExp(une, "g");
function cne(i) {
  switch (i) {
    case "&":
      return "&amp;";
    case "<":
      return "&lt;";
    case ">":
      return "&gt;";
    case '"':
      return "&quot;";
    default:
      return i;
  }
}
function np(i) {
  return e8.test(i) ? i.replace(e8, cne) : i;
}
function fne() {
  ine("editor", "UA-129966929-1");
}
function Ri(i, e) {
  return i.indexOf(e) !== -1;
}
var dne = ["rel", "target", "hreflang", "type"], hne = {
  codeblock: /(^ {4}[^\n]+\n*)+/,
  thematicBreak: /^ *((\* *){3,}|(- *){3,} *|(_ *){3,}) */,
  atxHeading: /^(#{1,6}) +[\s\S]+/,
  seTextheading: /^([^\n]+)\n *(=|-){2,} */,
  blockquote: /^( *>[^\n]+.*)+/,
  list: /^ *(\*+|-+|\d+\.) [\s\S]+/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? */,
  link: /!?\[.*\]\(.*\)/,
  reflink: /!?\[.*\]\s*\[([^\]]*)\]/,
  verticalBar: /\u007C/,
  fencedCodeblock: /^((`|~){3,})/
};
function J6(i) {
  if (!i)
    return null;
  var e = {};
  return dne.forEach(function(r) {
    vs(i[r]) || (e[r] = i[r]);
  }), e;
}
function mx(i, e) {
  for (var r = "", s = 0; s < e; s += 1)
    r += i;
  return r;
}
function pne(i) {
  var e = !1;
  return pp(hne, function(r) {
    return r.test(i) && (e = !0), !e;
  }), e;
}
function gx(i) {
  for (var e = [], r = ZU.exec(i); r; )
    e.push([r.index, r.index + r[0].length]), r = ZU.exec(i);
  return i.replace(lne, function(s, l) {
    var c = e.some(function(f) {
      return l > f[0] && l < f[1];
    });
    return c ? s : "\\" + s;
  });
}
function vne(i) {
  var e = function(l) {
    return "\\" + l;
  }, r = function(l) {
    return l + "\\";
  }, s = i.replace(ane, " ");
  return JU.test(s) && (s = s.replace(JU, e)), QU.test(s) && (s = s.replace(QU, r)), s = s.replace(sne, e), XU.test(s) && (s = s.replace(XU, e)), pne(s) && (s = s.replace(one, e)), s;
}
function mne(i) {
  var e;
  return i.indexOf('"') === -1 ? e = '""' : e = i.indexOf("'") === -1 ? "''" : "()", e[0] + i + e[1];
}
function r3(i) {
  return vx(i) || vs(i);
}
function q3(i, e) {
  if (i === null && i === e)
    return !0;
  if (typeof i != "object" || typeof e != "object" || r3(i) || r3(e))
    return i === e;
  for (var r in i)
    if (i[r] !== e[r])
      return !1;
  for (var r in e)
    if (!(r in i))
      return !1;
  return !0;
}
function Qi(i) {
  return i[i.length - 1];
}
function gne(i, e, r) {
  return i >= e && i <= r;
}
function K3(i) {
  return typeof i == "object" && i !== null;
}
function yx(i, e) {
  var r = Nt({}, i);
  return i && e && Object.keys(e).forEach(function(s) {
    K3(r[s]) ? Array.isArray(e[s]) ? r[s] = X3(e[s]) : r.hasOwnProperty(s) ? r[s] = yx(r[s], e[s]) : r[s] = J3(e[s]) : r[s] = e[s];
  }), r;
}
function X3(i) {
  return i.map(function(e) {
    return K3(e) ? Array.isArray(e) ? X3(e) : J3(e) : e;
  });
}
function J3(i) {
  var e = Object.keys(i);
  return e.length ? e.reduce(function(r, s) {
    return K3(i[s]) ? r[s] = Array.isArray(i[s]) ? X3(i[s]) : J3(i[s]) : r[s] = i[s], r;
  }, {}) : i;
}
function Z3(i, e) {
  return e === void 0 && (e = {}), Object.keys(e).forEach(function(r) {
    i.hasOwnProperty(r) && typeof i[r] == "object" ? Array.isArray(e[r]) ? i[r] = e[r] : Z3(i[r], e[r]) : i[r] = e[r];
  }), i;
}
function t8(i, e) {
  return i > e ? [e, i] : [i, e];
}
var yne = vp;
function bne(i) {
  var e;
  try {
    e = Array.prototype.slice.call(i);
  } catch {
    e = [], yne(i, function(s) {
      e.push(s);
    });
  }
  return e;
}
var Ws = bne;
function bx(i, e) {
  var r = i.nodes.paragraph;
  return e ? r.create(null, Tl(e) ? i.text(e) : e) : r.createAndFill();
}
function Mi(i, e, r) {
  return i.text(e, r);
}
function On(i, e, r) {
  r === void 0 && (r = e);
  var s = i.doc.content.size, l = s > 0 ? s - 1 : 1;
  return Zr.create(i.doc, Math.min(e, l), Math.min(r, l));
}
function Q3(i, e, r) {
  var s = e.pos;
  return i.replaceWith(s, s, bx(r)), i.setSelection(On(i, s + 1));
}
function Sx(i) {
  for (var e = i.state, r = i.from, s = i.startIndex, l = i.endIndex, c = i.createText, f = e.tr, p = e.doc, d = e.schema, m = s; m <= l; m += 1) {
    var y = p.child(m), S = y.nodeSize, x = y.textContent, w = y.content, k = c(x), O = k ? Mi(d, k) : qt.empty, T = f.mapping.map(r), L = T + w.size;
    f.replaceWith(T, L, O), r += S;
  }
  return f;
}
function eW(i, e, r, s) {
  var l = r.length;
  i.split(e).delete(e - l, e).insert(i.mapping.map(e), s).setSelection(On(i, i.mapping.map(e) - l));
}
function iy(i) {
  return i.sourcepos[0][0];
}
function Wx(i) {
  return i.sourcepos[1][0];
}
function $x(i) {
  return i.sourcepos[0][1];
}
function Du(i) {
  return i.sourcepos[1][1];
}
function Sne(i) {
  var e = i.type;
  return e === "htmlBlock" || e === "htmlInline";
}
function wne(i) {
  var e = i.type;
  return e === "strike" || e === "strong" || e === "emph" || e === "code" || e === "link" || e === "image";
}
function xne(i) {
  return i && i.type === "codeBlock";
}
function $c(i) {
  return i && (i.type === "item" || i.type === "list");
}
function Z6(i) {
  return $c(i) && i.listData.type === "ordered";
}
function kne(i) {
  return $c(i) && i.listData.type !== "ordered";
}
function r8(i) {
  return i && (i.type === "tableCell" || i.type === "tableDelimCell");
}
function One(i) {
  switch (i.type) {
    case "code":
    case "text":
    case "emph":
    case "strong":
    case "strike":
    case "link":
    case "image":
    case "htmlInline":
    case "linebreak":
    case "softbreak":
    case "customInline":
      return !0;
    default:
      return !1;
  }
}
function mp(i, e, r) {
  for (r === void 0 && (r = !0), i = r ? i : i.parent; i && i.type !== "document"; ) {
    if (e(i))
      return i;
    i = i.parent;
  }
  return null;
}
function Cne(i, e, r) {
  for (r === void 0 && (r = !0), i = r ? i : i.parent; i && i.type !== "document"; )
    e(i), i = i.parent;
}
function vi(i, e) {
  return [i[0], i[1] + e];
}
function Pu(i, e) {
  return [i[0], e];
}
function Tne(i) {
  var e = i.firstChild.literal;
  switch (i.type) {
    case "emph":
      return "*" + e + "*";
    case "strong":
      return "**" + e + "**";
    case "strike":
      return "~~" + e + "~~";
    case "code":
      return "`" + e + "`";
    case "link":
    case "image":
      var r = i, s = r.destination, l = r.title, c = i.type === "link" ? "" : "!";
      return c + "[" + e + "](" + s + (l ? ' "' + l + '"' : "") + ")";
    default:
      return null;
  }
}
function Ane(i) {
  switch (i.type) {
    case "document":
    case "blockQuote":
    case "list":
    case "item":
    case "paragraph":
    case "heading":
    case "emph":
    case "strong":
    case "strike":
    case "link":
    case "image":
    case "table":
    case "tableHead":
    case "tableBody":
    case "tableRow":
    case "tableCell":
    case "tableDelimRow":
    case "customInline":
      return !0;
    default:
      return !1;
  }
}
function Ene(i) {
  for (var e = [], r = i.walker(), s = null; s = r.next(); ) {
    var l = s.node;
    l.type === "text" && e.push(l.literal);
  }
  return e.join("");
}
var Qg = [], Q6 = {}, n8 = /\$\$widget\d+\s/;
function Ux(i) {
  var e = i.search(n8);
  if (e !== -1) {
    var r = i.substring(e), s = r.replace(n8, "").replace("$$", "");
    i = i.substring(0, e), i += Ux(s);
  }
  return i;
}
function e4(i, e) {
  return "$$" + i + " " + e + "$$";
}
function t4(i, e) {
  var r = Q6[i], s = r.rule, l = r.toDOM, c = Ux(e).match(s);
  return c && (e = c[0]), l(e);
}
function Mne() {
  return Qg;
}
function Rne(i) {
  Qg = i, Qg.forEach(function(e, r) {
    Q6["widget" + r] = e;
  });
}
function tj(i, e, r, s) {
  return i.concat(Bc(e, r, s));
}
function Bc(i, e, r) {
  r === void 0 && (r = 0);
  var s = [], l = (Qg[r] || {}).rule, c = r + 1;
  if (i = Ux(i), l && l.test(i)) {
    for (var f = void 0; (f = i.search(l)) !== -1; ) {
      var p = i.substring(0, f);
      p && (s = tj(s, p, e, c)), i = i.substring(f);
      var d = i.match(l)[0], m = "widget" + r;
      s.push(e.nodes.widget.create({ info: m }, e.text(e4(m, d)))), i = i.substring(d.length);
    }
    i && (s = tj(s, i, e, c));
  } else i && (s = r < Qg.length - 1 ? tj(s, i, e, c) : [e.text(i)]);
  return s;
}
function r4(i) {
  for (var e, r = "", s = i.walker(); e = s.next(); ) {
    var l = e.node, c = e.entering;
    c && (l !== i && l.type !== "text" ? (r += Tne(l), s.resumeAt(i, !1), s.next()) : l.type === "text" && (r += l.literal));
  }
  return r;
}
function n4() {
  return {
    deleteSelection: function() {
      return j3;
    },
    selectAll: function() {
      return j6;
    },
    undo: function() {
      return Gg;
    },
    redo: function() {
      return V3;
    }
  };
}
function Dne(i) {
  return new Wa({
    props: {
      decorations: function(e) {
        var r = e.doc;
        if (i.text && r.childCount === 1 && r.firstChild.isTextblock && r.firstChild.content.size === 0) {
          var s = document.createElement("span");
          return Bs(s, "placeholder"), i.className && Bs(s, i.className), s.textContent = i.text, Bn.create(r, [Fa.widget(1, s)]);
        }
        return null;
      }
    }
  });
}
var Pne = Wc, Lne = Y3;
function Ine(i, e) {
  var r;
  return i.classList ? i.classList.contains(e) : (r = Lne(i).split(/\s+/), Pne(e, r) > -1);
}
var i4 = Ine, _ne = Wc, Nne = Ws, Nw = Element.prototype, Bne = Nw.matches || Nw.webkitMatchesSelector || Nw.mozMatchesSelector || Nw.msMatchesSelector || function(i) {
  var e = this.document || this.ownerDocument;
  return _ne(this, Nne(e.querySelectorAll(i))) > -1;
};
function Fne(i, e) {
  return Bne.call(i, e);
}
var zne = Fne, a4 = "[A-Za-z][A-Za-z0-9-]*", Hne = "[a-zA-Z_:][a-zA-Z0-9:._-]*", jne = "[^\"'=<>`\\x00-\\x20]+", Wne = "'[^']*'", $ne = '"[^"]*"', Une = "(?:" + jne + "|" + Wne + "|" + $ne + ")", Vne = "(?:\\s*=\\s*" + Une + ")", o4 = "(?:\\s+" + Hne + Vne + "?)", s4 = "<(" + a4 + ")(" + o4 + ")*\\s*/?>", Gne = "</(" + a4 + ")\\s*[>]", l4 = "(?:" + s4 + "|" + Gne + ")", gp = new RegExp("^" + l4, "i"), n3 = /<br\s*\/*>/i, Yne = /<! ---->|<!--(?:-?[^>-])(?:-?[^-])*-->/, u4 = "</p><p>";
function tW(i, e, r) {
  var s = parseInt(i.left, 10), l = parseInt(i.top, 10), c = parseInt(i.width, 10) + parseInt(i.paddingLeft, 10) + parseInt(i.paddingRight, 10), f = parseInt(i.height, 10) + parseInt(i.paddingTop, 10) + parseInt(i.paddingBottom, 10);
  return e >= s && e <= s + c && r >= l && r <= l + f;
}
var c4 = "toastui-editor-";
function vr() {
  for (var i = [], e = 0; e < arguments.length; e++)
    i[e] = arguments[e];
  for (var r = [], s = 0, l = i; s < l.length; s++) {
    var c = l[s], f = void 0;
    Array.isArray(c) ? f = c[0] ? c[1] : null : f = c, f && r.push("" + c4 + f);
  }
  return r.join(" ");
}
function di() {
  for (var i = [], e = 0; e < arguments.length; e++)
    i[e] = arguments[e];
  return i.map(function(r) {
    return c4 + "md-" + r;
  }).join(" ");
}
function qne(i) {
  return (i == null ? void 0 : i.nodeType) === Node.TEXT_NODE;
}
function Vx(i) {
  return i && i.nodeType === Node.ELEMENT_NODE;
}
function Kne(i, e) {
  var r = Ws(i.querySelectorAll(e));
  return r.length ? r : [];
}
function Xne(i, e) {
  e = Op(e) ? Ws(e) : [e], e.forEach(function(r) {
    i.appendChild(r);
  });
}
function Jne(i, e) {
  e.parentNode && e.parentNode.insertBefore(i, e);
}
function Uc(i) {
  i.parentNode && i.parentNode.removeChild(i);
}
function Zne(i) {
  for (var e = []; i.firstChild; )
    e.push(i.firstChild), i.parentNode && i.parentNode.insertBefore(i.firstChild, i);
  return Uc(i), e;
}
function rW(i, e, r) {
  vs(r) && (r = !i4(i, e));
  var s = r ? Bs : fs;
  s(i, e);
}
function f4(i, e) {
  var r = document.createElement("div");
  Tl(i) ? r.innerHTML = i : r.appendChild(i);
  var s = r.firstChild;
  return e && e.appendChild(s), s;
}
function nW(i) {
  var e = window.getComputedStyle(i);
  return ["margin-left", "margin-right"].reduce(function(r, s) {
    return r + parseInt(e.getPropertyValue(s), 10);
  }, 0) + i.offsetWidth;
}
function Fs(i, e) {
  var r;
  for (Tl(e) ? r = function(s) {
    return zne(s, e);
  } : r = function(s) {
    return s === e;
  }; i && i !== document; ) {
    if (Vx(i) && r(i))
      return i;
    i = i.parentNode;
  }
  return null;
}
function d4(i, e) {
  for (var r = 0, s = 0; i && i !== e; ) {
    var l = i.offsetTop, c = i.offsetLeft, f = i.offsetParent;
    if (r += l, s += c, f === e.offsetParent)
      break;
    i = i.offsetParent;
  }
  return { offsetTop: r, offsetLeft: s };
}
function iW(i, e) {
  Object.keys(i).forEach(function(r) {
    r3(i[r]) ? e.removeAttribute(r) : e.setAttribute(r, i[r]);
  });
}
function Qne(i) {
  var e = i.replace(/<p><br\s*\/*><\/p>/gi, "<p></p>"), r = new RegExp(l4, "ig"), s = e.match(r);
  return s == null || s.forEach(function(l, c) {
    if (n3.test(l)) {
      var f = u4;
      if (c) {
        var p = s[c - 1], d = p.match(s4);
        if (d && !/br/i.test(d[1])) {
          var m = d[1];
          f = "</" + m + "><" + m + ">";
        }
      }
      e = e.replace(n3, f);
    }
  }), e;
}
function aW(i) {
  var e = /<img class="ProseMirror-separator" alt="">/g, r = / class="ProseMirror-trailingBreak"/g, s = i;
  return s = s.replace(e, ""), s = s.replace(r, ""), s;
}
var h4 = new ty("widget"), i8 = 5, eie = (
  /** @class */
  function() {
    function i(e, r) {
      var s = this;
      this.popup = null, this.removeWidget = function() {
        s.popup && (s.rootEl.removeChild(s.popup), s.popup = null);
      }, this.rootEl = e.dom.parentElement, this.eventEmitter = r, this.eventEmitter.listen("blur", this.removeWidget), this.eventEmitter.listen("loadUI", function() {
        s.rootEl = Fs(e.dom.parentElement, "." + vr("defaultUI"));
      }), this.eventEmitter.listen("removePopupWidget", this.removeWidget);
    }
    return i.prototype.update = function(e) {
      var r = h4.getState(e.state);
      if (this.removeWidget(), r) {
        var s = r.node, l = r.style, c = e.coordsAtPos(r.pos), f = c.top, p = c.left, d = c.bottom, m = d - f, y = this.rootEl.getBoundingClientRect(), S = f - y.top;
        js(s, { opacity: "0" }), this.rootEl.appendChild(s), js(s, {
          position: "absolute",
          left: p - y.left + i8 + "px",
          top: (l === "bottom" ? S + m - i8 : S - m) + "px",
          opacity: "1"
        }), this.popup = s, e.focus();
      }
    }, i.prototype.destroy = function() {
      this.eventEmitter.removeEventHandler("blur", this.removeWidget);
    }, i;
  }()
);
function tie(i) {
  return new Wa({
    key: h4,
    state: {
      init: function() {
        return null;
      },
      apply: function(e) {
        return e.getMeta("widget");
      }
    },
    view: function(e) {
      return new eie(e, i);
    }
  });
}
function rie(i) {
  i.listen("addImageBlobHook", function(e, r) {
    var s = new FileReader();
    s.onload = function(l) {
      var c = l.target;
      return r(c.result);
    }, s.readAsDataURL(e);
  });
}
function oW(i, e, r) {
  var s = function(l, c) {
    i.emit("command", "addImage", {
      imageUrl: l,
      altText: c || e.name || "image"
    });
  };
  i.emit("addImageBlobHook", e, s, r);
}
function p4(i) {
  var e = Ws(i).filter(function(s) {
    var l = s.type;
    return l.indexOf("image") !== -1;
  });
  if (e.length === 1) {
    var r = e[0];
    if (r)
      return r.getAsFile();
  }
  return null;
}
function nie(i) {
  var e = i.eventEmitter;
  return new Wa({
    props: {
      handleDOMEvents: {
        drop: function(r, s) {
          var l, c = (l = s.dataTransfer) === null || l === void 0 ? void 0 : l.files;
          return c && vp(c, function(f) {
            return f.type.indexOf("image") !== -1 ? (s.preventDefault(), s.stopPropagation(), oW(e, f, s.type), !1) : !0;
          }), !0;
        }
      }
    }
  });
}
var Sn = (
  /** @class */
  function() {
    function i() {
    }
    return Object.defineProperty(i.prototype, "type", {
      get: function() {
        return "node";
      },
      enumerable: !1,
      configurable: !0
    }), i.prototype.setContext = function(e) {
      this.context = e;
    }, i;
  }()
);
function v4(i) {
  var e = document.createElement("span"), r = t4(i.attrs.info, i.textContent);
  return e.className = "tui-widget", e.appendChild(r), { dom: e };
}
function i3(i) {
  return i.type.name === "widget";
}
var m4 = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "widget";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            info: { default: null }
          },
          group: "inline",
          inline: !0,
          content: "text*",
          selectable: !1,
          atom: !0,
          toDOM: function() {
            return ["span", { class: "tui-widget" }, 0];
          },
          parseDOM: [
            {
              tag: "span.tui-widget",
              getAttrs: function(r) {
                var s = r.textContent, l = s.match(/\$\$(widget\d+)/), c = l[1];
                return { info: c };
              }
            }
          ]
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Sn)
), g4 = (
  /** @class */
  function() {
    function i(e) {
      this.timer = null, this.el = document.createElement("div"), this.el.className = "toastui-editor", this.eventEmitter = e, this.placeholder = { text: "" };
    }
    return i.prototype.createState = function() {
      return Rc.create({
        schema: this.schema,
        plugins: this.createPlugins()
      });
    }, i.prototype.initEvent = function() {
      var e = this, r = e.eventEmitter, s = e.view, l = e.editorType;
      s.dom.addEventListener("focus", function() {
        return r.emit("focus", l);
      }), s.dom.addEventListener("blur", function() {
        return r.emit("blur", l);
      });
    }, i.prototype.emitChangeEvent = function(e) {
      this.eventEmitter.emit("caretChange", this.editorType), e.docChanged && this.eventEmitter.emit("change", this.editorType);
    }, Object.defineProperty(i.prototype, "defaultPlugins", {
      get: function() {
        var e = this.createInputRules(), r = Ha(Ha([], this.keymaps), [
          Zg(Nt({ "Shift-Enter": UU.Enter }, UU)),
          K6(),
          Dne(this.placeholder),
          tie(this.eventEmitter),
          nie(this.context)
        ]);
        return e ? r.concat(e) : r;
      },
      enumerable: !1,
      configurable: !0
    }), i.prototype.createInputRules = function() {
      var e = Mne(), r = e.map(function(s) {
        var l = s.rule;
        return new V6(l, function(c, f, p, d) {
          var m = c.schema, y = c.tr, S = c.doc, x = f.input.match(new RegExp(l, "g")), w = S.resolve(p), k = w.parent, O = 0;
          if (i3(k) && (k = w.node(w.depth - 1)), k.forEach(function(j) {
            return i3(j) && (O += 1);
          }), x.length > O) {
            var T = Qi(x), L = Bc(T, m);
            return y.replaceWith(d - T.length + 1, d, L);
          }
          return null;
        });
      });
      return r.length ? G6({ rules: r }) : null;
    }, i.prototype.clearTimer = function() {
      this.timer && (clearTimeout(this.timer), this.timer = null);
    }, i.prototype.createSchema = function() {
      return new $V({
        nodes: this.specs.nodes,
        marks: this.specs.marks
      });
    }, i.prototype.createKeymaps = function(e) {
      var r = n4(), s = r.undo, l = r.redo, c = this.specs.keymaps(e), f = {
        "Mod-z": s(),
        "Shift-Mod-z": l()
      };
      return e ? c.concat(Zg(f)) : c;
    }, i.prototype.createCommands = function() {
      return this.specs.commands(this.view);
    }, i.prototype.createPluginProps = function() {
      var e = this;
      return this.extraPlugins.map(function(r) {
        return r(e.eventEmitter);
      });
    }, i.prototype.focus = function() {
      var e = this;
      this.clearTimer(), this.timer = setTimeout(function() {
        e.view.focus(), e.view.dispatch(e.view.state.tr.scrollIntoView());
      });
    }, i.prototype.blur = function() {
      this.view.dom.blur();
    }, i.prototype.destroy = function() {
      var e = this;
      this.clearTimer(), this.view.destroy(), Object.keys(this).forEach(function(r) {
        delete e[r];
      });
    }, i.prototype.moveCursorToStart = function(e) {
      var r = this.view.state.tr;
      this.view.dispatch(r.setSelection(On(r, 1)).scrollIntoView()), e && this.focus();
    }, i.prototype.moveCursorToEnd = function(e) {
      var r = this.view.state.tr;
      this.view.dispatch(r.setSelection(On(r, r.doc.content.size - 1)).scrollIntoView()), e && this.focus();
    }, i.prototype.setScrollTop = function(e) {
      this.view.dom.scrollTop = e;
    }, i.prototype.getScrollTop = function() {
      return this.view.dom.scrollTop;
    }, i.prototype.setPlaceholder = function(e) {
      this.placeholder.text = e, this.view.dispatch(this.view.state.tr.scrollIntoView());
    }, i.prototype.setHeight = function(e) {
      js(this.el, { height: e + "px" });
    }, i.prototype.setMinHeight = function(e) {
      js(this.el, { minHeight: e + "px" });
    }, i.prototype.getElement = function() {
      return this.el;
    }, i;
  }()
);
function iie(i) {
  return i instanceof Function;
}
var _o = iie, aie = [
  "Enter",
  "Shift-Enter",
  "Mod-Enter",
  "Tab",
  "Shift-Tab",
  "Delete",
  "Backspace",
  "Mod-Delete",
  "Mod-Backspace",
  "ArrowUp",
  "ArrowDown",
  "ArrowLeft",
  "ArrowRight",
  "Mod-d",
  "Mod-D",
  "Alt-ArrowUp",
  "Alt-ArrowDown"
];
function Bw(i, e, r) {
  return i.focus(), e(r)(i.state, i.dispatch, i);
}
var y4 = (
  /** @class */
  function() {
    function i(e) {
      this.specs = e;
    }
    return Object.defineProperty(i.prototype, "nodes", {
      get: function() {
        return this.specs.filter(function(e) {
          return e.type === "node";
        }).reduce(function(e, r) {
          var s, l = r.name, c = r.schema;
          return Nt(Nt({}, e), (s = {}, s[l] = c, s));
        }, {});
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "marks", {
      get: function() {
        return this.specs.filter(function(e) {
          return e.type === "mark";
        }).reduce(function(e, r) {
          var s, l = r.name, c = r.schema;
          return Nt(Nt({}, e), (s = {}, s[l] = c, s));
        }, {});
      },
      enumerable: !1,
      configurable: !0
    }), i.prototype.commands = function(e, r) {
      var s = this.specs.filter(function(c) {
        var f = c.commands;
        return f;
      }).reduce(function(c, f) {
        var p = {}, d = f.commands();
        return _o(d) ? p[f.name] = function(m) {
          return Bw(e, d, m);
        } : Object.keys(d).forEach(function(m) {
          p[m] = function(y) {
            return Bw(e, d[m], y);
          };
        }), Nt(Nt({}, c), p);
      }, {}), l = n4();
      return Object.keys(l).forEach(function(c) {
        s[c] = function(f) {
          return Bw(e, l[c], f);
        };
      }), r && Object.keys(r).forEach(function(c) {
        s[c] = function(f) {
          return Bw(e, r[c], f);
        };
      }), s;
    }, i.prototype.keymaps = function(e) {
      var r = this.specs.filter(function(s) {
        return s.keymaps;
      }).map(function(s) {
        return s.keymaps();
      });
      return r.map(function(s) {
        return e || Object.keys(s).forEach(function(l) {
          Ri(aie, l) || delete s[l];
        }), Zg(s);
      });
    }, i.prototype.setContext = function(e) {
      this.specs.forEach(function(r) {
        r.setContext(e);
      });
    }, i;
  }()
);
function b4(i) {
  var e = i.from, r = i.to;
  return i instanceof ma ? [e + 1, r - 1] : [e, r];
}
function a8(i) {
  return i.index(0) + 1;
}
function yp(i, e, r) {
  r === void 0 && (r = 1);
  var s = 0;
  return i.forEach(function(l, c) {
    i3(l) && c + 2 < e && (s += 2 * r);
  }), s;
}
function Xw(i, e, r) {
  r === void 0 && (r = e);
  var s = e === r, l = i.resolve(e), c = a8(l), f = c, p = l.start(1), d = p;
  if (!s) {
    var m = i.resolve(r === i.content.size ? r - 1 : r);
    d = m.start(1), f = a8(m), m.pos === i.content.size && (r = i.content.size - 2);
  }
  var y = Math.max(e - p + 1, 1), S = Math.max(r - d + 1, 1);
  return [
    [c, y + yp(i.child(c - 1), y, -1)],
    [f, S + yp(i.child(f - 1), S, -1)]
  ];
}
function S4(i, e) {
  for (var r = [], s = 0, l = 0; s < e; s += 1) {
    var c = i.child(s);
    r[s] = l, l += c.nodeSize;
  }
  return r;
}
function Ac(i, e, r) {
  var s = S4(i, r[0]), l = e[0] - 1, c = r[0] - 1, f = i.child(l), p = i.child(c), d = s[l], m = s[c];
  return d += e[1] + yp(f, e[1] - 1), m += r[1] + yp(p, r[1] - 1), [d, Math.min(m, i.content.size)];
}
function ci(i) {
  var e = i.$from, r = i.$to, s = i.from, l = i.to, c = e.doc;
  return i instanceof ma && (e = c.resolve(s + 1), r = c.resolve(l - 1)), e.depth === 0 && (e = c.resolve(s - 1), r = e), {
    startFromOffset: e.start(1),
    endFromOffset: r.start(1),
    startToOffset: e.end(1),
    endToOffset: r.end(1),
    startIndex: e.index(0),
    endIndex: r.index(0),
    from: e.pos,
    to: r.pos
  };
}
function wx(i, e) {
  for (var r = 1, s = 1, l = 0, c = 0; l < i.childCount; l += 1) {
    var f = i.child(l).nodeSize;
    if (r = c + 1, s = c + f - 1, l === e)
      break;
    c += f;
  }
  return { startOffset: r, endOffset: s };
}
var o8 = "heading", oie = "blockQuote", sie = "listItem", lie = "table", uie = "tableCell", cie = "codeBlock", fie = "thematicBreak", Jw = "link", Fw = "code", Gx = "meta", Vc = "delimiter", die = "taskDelimiter", sW = "markedText", hie = "html", pie = "customBlock", s8 = {
  strong: 2,
  emph: 1,
  strike: 2
};
function rn(i, e, r, s) {
  return { start: i, end: e, spec: { type: r, attrs: s } };
}
function vie(i, e, r) {
  var s = i.level, l = i.headingType, c = [rn(e, r, o8, { level: s })];
  return l === "atx" ? c.push(rn(e, vi(e, s), Vc)) : c.push(rn(Pu(r, 0), r, o8, { seText: !0 })), c;
}
function rj(i, e, r) {
  var s = i.type, l = vi(e, s8[s]), c = vi(r, -s8[s]);
  return [
    rn(l, c, s),
    rn(e, l, Vc),
    rn(c, r, Vc)
  ];
}
function w4(i, e, r, s) {
  return [
    rn(i, e, Jw),
    rn(Pu(i, r[1] + 1), Pu(e, s), Jw, {
      desc: !0
    }),
    rn(Pu(e, s + 2), vi(e, -1), Jw, { url: !0 })
  ];
}
function mie(i, e, r) {
  var s = i.lastChild, l = s ? Du(s) + 1 : 3, c = vi(e, 1);
  return Ha([rn(e, c, Gx)], w4(e, r, c, l));
}
function gie(i, e, r) {
  var s = i.lastChild, l = i.extendedAutolink, c = s ? Du(s) + 1 : 2;
  return l ? [rn(e, r, Jw, { desc: !0 })] : w4(e, r, e, c);
}
function yie(i, e, r) {
  var s = i.tickCount, l = vi(e, s), c = vi(r, -s);
  return [
    rn(e, r, Fw),
    rn(e, l, Fw, { start: !0 }),
    rn(l, c, Fw, { marked: !0 }),
    rn(c, r, Fw, { end: !0 })
  ];
}
function x4(i, e, r, s) {
  var l = {
    start: e,
    end: r,
    spec: {
      attrs: { className: s + "-line-background", codeStart: e[0], codeEnd: r[0] }
    },
    lineBackground: !0
  };
  return i.type !== "item" && i.type !== "blockQuote" ? [
    Nt(Nt({}, l), { end: e, spec: { attrs: { className: s + "-line-background start" } } }),
    Nt(Nt({}, l), { start: [Math.min(e[0] + 1, r[0]), e[1]] })
  ] : null;
}
function bie(i, e, r, s) {
  var l = i.fenceOffset, c = i.fenceLength, f = i.fenceChar, p = i.info, d = i.infoPadding, m = i.parent, y = l + c, S = [rn(Pu(e, 1), r, cie)];
  f && S.push(rn(e, vi(e, y), Vc)), p && S.push(rn(vi(e, c), vi(e, c + d + p.length), Gx));
  var x = "^(\\s{0,4})(" + f + "{" + c + ",})", w = new RegExp(x);
  w.test(s) && S.push(rn(Pu(r, 1), r, Vc));
  var k = x4(m, e, r, "code-block");
  return k ? S.concat(k) : S;
}
function Sie(i, e, r) {
  var s = i, l = s.offset, c = s.syntaxLength, f = s.info, p = s.parent, d = l + c, m = [rn(Pu(e, 1), r, pie)];
  m.push(rn(e, vi(e, d), Vc)), f && m.push(rn(vi(e, d), vi(e, c + f.length), Gx)), m.push(rn(Pu(r, 1), r, Vc));
  var y = x4(p, e, r, "custom-block");
  return y ? m.concat(y) : m;
}
function k4(i, e) {
  for (var r = []; i; ) {
    var s = i.type;
    (s === "paragraph" || s === "codeBlock") && r.push(rn([iy(i), $x(i) - 1], [Wx(i), Du(i) + 1], e)), i = i.next;
  }
  return r;
}
function wie(i) {
  for (var e = []; i; )
    e.push(rn([iy(i), $x(i)], [Wx(i), Du(i) + 1], sW)), i = i.next;
  return e;
}
function xie(i, e, r) {
  var s = i.parent && i.parent.type !== "blockQuote" ? [rn(e, r, oie)] : [];
  if (i.firstChild) {
    var l = [];
    i.firstChild.type === "paragraph" ? l = wie(i.firstChild.firstChild) : i.firstChild.type === "list" && (l = k4(i.firstChild, sW)), s = Ha(Ha([], s), l);
  }
  return s;
}
function kie(i) {
  for (var e = 0; i.parent.parent && i.parent.parent.type === "item"; )
    i = i.parent.parent, e += 1;
  var r = [{ odd: !0 }, { even: !0 }][e % 2];
  return [sie, Nt(Nt({}, r), { listStyle: !0 })];
}
function Oie(i, e) {
  var r = i.listData, s = r.padding, l = r.task, c = kie(i), f = [rn.apply(void 0, Ha([e, vi(e, s)], c))];
  return l && (f.push(rn(vi(e, s), vi(e, s + 3), die)), f.push(rn(vi(e, s + 1), vi(e, s + 2), Gx))), f.concat(k4(i.firstChild, sW));
}
var l8 = {
  heading: vie,
  strong: rj,
  emph: rj,
  strike: rj,
  link: gie,
  image: mie,
  code: yie,
  codeBlock: bie,
  blockQuote: xie,
  item: Oie,
  customBlock: Sie
}, u8 = {
  thematicBreak: fie,
  table: lie,
  tableCell: uie,
  htmlInline: hie
};
function Cie(i, e, r, s) {
  var l = i.type;
  return _o(l8[l]) ? l8[l](i, e, r, s) : u8[l] ? [rn(e, r, u8[l])] : null;
}
var ey = {};
function Tie(i) {
  var e = i.schema, r = i.toastMark;
  return new Wa({
    appendTransaction: function(s, l, c) {
      var f = s[0], p = c.tr;
      if (f.docChanged) {
        var d = [], m = f.getMeta("editResult");
        m.forEach(function(y) {
          var S = y.nodes, x = y.removedNodeRange;
          if (S.length) {
            d = d.concat(Pie(p, S));
            for (var w = 0, k = S; w < k.length; w++)
              for (var O = k[w], T = O.walker(), L = T.next(); L; ) {
                var j = L.node, z = L.entering;
                z && (d = d.concat(Lie(j, r))), L = T.next();
              }
          } else if (x)
            for (var J = p.doc.childCount - 1, ie = x.line, K = ie[0], re = ie[1], ee = Math.min(K, J), de = Math.min(re, J), Ce = ee; Ce <= de; Ce += 1)
              ey[Ce] = !0;
        }), Mie(p, e, d);
      }
      return p.setMeta("widget", f.getMeta("widget"));
    }
  });
}
function Aie(i, e, r) {
  return Object.keys(r).some(function(s) {
    return r[s] !== i.child(e).attrs[s];
  });
}
function Eie(i, e, r, s, l) {
  l === void 0 && (l = {});
  for (var c = s.startIndex, f = s.endIndex, p = s.from, d = s.to, m = !1, y = c; y <= f; y += 1)
    delete ey[y], m = Aie(e, y, l);
  m && i.setBlockType(p, d, r, l);
}
function Mie(i, e, r) {
  var s = i.doc, l = e.nodes.paragraph, c = S4(s, s.childCount);
  r.forEach(function(f) {
    var p = f.start, d = f.end, m = f.spec, y = f.lineBackground, S = Math.min(p[0], s.childCount) - 1, x = Math.min(d[0], s.childCount) - 1, w = s.child(S), k = s.child(x), O = c[S], T = c[x];
    if (O += p[1] + yp(w, p[1] - 1), T += d[1] + yp(k, d[1] - 1), m)
      if (y) {
        var L = { from: O, to: T, startIndex: S, endIndex: x };
        Eie(i, s, l, L, m.attrs);
      } else
        i.addMark(O, T, e.mark(m.type, m.attrs));
    else
      i.removeMark(O, T);
  }), Rie(i, c, l);
}
function Rie(i, e, r) {
  Object.keys(ey).forEach(function(s) {
    var l = Number(s), c = Math.min(Number(s) + 1, i.doc.childCount - 1), f = e[l], p = e[c] - 1;
    l === c && (p += 2), i.setBlockType(f, p, r);
  });
}
function Die(i, e, r) {
  var s = [];
  ey = {};
  for (var l = e[0] - 1; l < r[0]; l += 1) {
    var c = i.child(l), f = c.attrs.codeEnd, p = c.attrs.codeStart;
    if (p && f && !Ri(s, p)) {
      s.push(p), f = Math.min(f, i.childCount);
      for (var d = p - 1, m = r[0], y = d; y < m; y += 1)
        ey[y] = !0;
    }
  }
}
function Pie(i, e) {
  var r = i.doc, s = e[0].sourcepos[0], l = Qi(e).sourcepos, c = l[1], f = [s[0], s[1]], p = [c[0], c[1] + 1], d = [];
  return Die(r, s, c), d.push({ start: f, end: p }), d;
}
function Lie(i, e) {
  var r = e.getLineTexts(), s = [iy(i), $x(i)], l = [Wx(i), Du(i) + 1], c = Cie(i, s, l, r[l[0] - 1]);
  return c ?? [];
}
var Iie = [
  "taskList",
  "orderedList",
  "bulletList",
  "table",
  "strong",
  "emph",
  "strike",
  "heading",
  "thematicBreak",
  "blockQuote",
  "code",
  "codeBlock",
  "indent",
  "outdent"
];
function _ie(i) {
  var e = i.type;
  return $c(i) ? i.listData.task ? "taskList" : i.listData.type === "ordered" ? "orderedList" : "bulletList" : e.indexOf("table") !== -1 ? "table" : Ri(Iie, e) ? e : null;
}
function Nie(i) {
  var e = {
    indent: { active: !1, disabled: !0 },
    outdent: { active: !1, disabled: !0 }
  }, r = !0;
  return Cne(i, function(s) {
    var l = _ie(s);
    l && (l === "bulletList" || l === "orderedList" ? r && (e[l] = { active: !0 }, e.indent.disabled = !1, e.outdent.disabled = !1, r = !1) : e[l] = { active: !0 });
  }), e;
}
function Bie(i) {
  var e = i.toastMark, r = i.eventEmitter;
  return new Wa({
    view: function() {
      return {
        update: function(s, l) {
          var c = s.state, f = c.doc, p = c.selection;
          if (!(l && l.doc.eq(f) && l.selection.eq(p))) {
            var d = p.from, m = c.doc.resolve(d).start(), y = c.doc.content.findIndex(d).index + 1, S = d - m;
            d === m && (S += 1);
            var x = [y, S], w = e.findNodeAtPosition(x), k = Nie(w);
            r.emit("changeToolbarState", {
              cursorPos: x,
              mdNode: w,
              toolbarState: k
            }), r.emit("setFocusedNode", w);
          }
        }
      };
    }
  });
}
var Fie = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "doc";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "block+"
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Sn)
), Cn = (
  /** @class */
  function() {
    function i() {
    }
    return Object.defineProperty(i.prototype, "type", {
      get: function() {
        return "mark";
      },
      enumerable: !1,
      configurable: !0
    }), i.prototype.setContext = function(e) {
      this.context = e;
    }, i;
  }()
);
function ho(i, e) {
  return Iu(i, e - 1);
}
function Iu(i, e) {
  return i.child(e).textContent;
}
var jg = /^\s*> ?/, zie = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "blockQuote";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: di("block-quote") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.createBlockQuoteText = function(r, s) {
      return s ? r.replace(jg, "").trim() : "> " + r.trim();
    }, e.prototype.extendBlockQuote = function() {
      var r = this;
      return function(s, l) {
        var c = s.selection, f = s.doc, p = s.tr, d = s.schema, m = ci(c), y = m.endFromOffset, S = m.endToOffset, x = m.endIndex, w = m.to, k = Iu(f, x), O = jg.test(k);
        if (O && w > y && c.empty) {
          var T = !k.replace(jg, "").trim();
          if (T)
            p.deleteRange(y, S).split(p.mapping.map(S));
          else {
            var L = k.slice(w - y).trim(), j = Mi(d, r.createBlockQuoteText(L));
            eW(p, S, L, j);
          }
          return l(p), !0;
        }
        return !1;
      };
    }, e.prototype.commands = function() {
      var r = this;
      return function() {
        return function(s, l) {
          var c = s.selection, f = s.doc, p = ci(c), d = p.startFromOffset, m = p.endToOffset, y = p.startIndex, S = p.endIndex, x = jg.test(Iu(f, y)), w = Sx({
            state: s,
            startIndex: y,
            endIndex: S,
            from: d,
            createText: function(k) {
              return r.createBlockQuoteText(k, x);
            }
          });
          return l(w.setSelection(On(w, w.mapping.map(m)))), !0;
        };
      };
    }, e.prototype.keymaps = function() {
      var r = this.commands()();
      return {
        "alt-q": r,
        "alt-Q": r,
        Enter: this.extendBlockQuote()
      };
    }, e;
  }(Cn)
), Gc = /(^\s*)([-*+] |[\d]+\. )/, lW = /(^\s*)([\d])+\.( \[[ xX]])? /, kl = /^(\s*)((\d+)([.)]\s(?:\[(?:x|\s)\]\s)?))(.*)/, xx = /(^\s*)([-*+]|[\d]+\.)( \[[ xX]])? /, Hie = /^(\s*)([-*+]+(\s(?:\[(?:x|\s)\]\s)?))(.*)/, jie = /(^\s*)([-*+] |[\d]+\. )(\[[ xX]] )/, Wie = /(^\s*)([-*+])( \[[ xX]]) /;
function uW(i) {
  return lW.test(i) ? "ordered" : "bullet";
}
function cW(i) {
  for (var e = 0; i && i.type !== "document"; )
    i.type === "list" && (e += 1), i = i.parent;
  return e;
}
function a3(i, e, r, s) {
  for (var l = i.getLineTexts(), c = l.length, f = [], p = e; s ? p < c : p > 1; ) {
    p = s ? p + 1 : p - 1;
    var d = i.findFirstNodeAtLine(p), m = cW(d);
    if (m === r)
      f.push({ line: p, depth: r, mdNode: d });
    else if (m < r)
      break;
  }
  return f;
}
function $ie(i) {
  var e = i.toastMark, r = i.mdNode, s = i.line, l = cW(r), c = a3(e, s, l, !1).reverse(), f = a3(e, s, l, !0);
  return c.concat([{ line: s, depth: l, mdNode: r }]).concat(f);
}
function Uie(i) {
  if (!Gc.test(i))
    return "* " + i;
  var e = uW(i);
  return e === "bullet" && xx.test(i) ? i = i.replace(Wie, "$1$2 ") : e === "ordered" && (i = i.replace(lW, "$1* ")), i;
}
function Vie(i, e) {
  if (!Gc.test(i))
    return e + ". " + i;
  var r = uW(i);
  if (r === "bullet" || r === "ordered" && xx.test(i))
    i = i.replace(xx, "$1" + e + ". ");
  else if (r === "ordered") {
    var s = kl.exec(i)[3];
    Number(s) !== e && (i = i.replace(lW, "$1" + e + ". "));
  }
  return i;
}
function O4(i, e, r, s) {
  s === void 0 && (s = 0);
  var l = Number.MAX_VALUE, c = 0, f = e.map(function(p, d) {
    var m = p.line;
    l = Math.min(m - 1, l), c = Math.max(m - 1, c);
    var y = ho(i, m);
    return y = r === "bullet" ? Uie(y) : Vie(y, d + 1 + s), { text: y, line: m };
  });
  return { changedResults: f, firstIndex: l, lastIndex: c };
}
function c8(i, e) {
  var r = $ie(e);
  return O4(e.doc, r, i);
}
var Gie = {
  bullet: function(i) {
    return c8("bullet", i);
  },
  ordered: function(i) {
    return c8("ordered", i);
  },
  task: function(i) {
    var e = i.mdNode, r = i.doc, s = i.line, l = ho(r, s);
    return e.listData.task ? l = l.replace(jie, "$1$2") : $c(e) && (l = l.replace(Gc, "$1$2[ ] ")), { changedResults: [{ text: l, line: s }] };
  }
}, Yie = {
  bullet: function(i) {
    var e = i.doc, r = i.line, s = ho(e, r), l = [{ text: "* " + s, line: r }];
    return { changedResults: l };
  },
  ordered: function(i) {
    for (var e = i.toastMark, r = i.doc, s = i.line, l = i.startLine, c = ho(r, s), f = 1, p = l, d = 0, m = l - 1; m > 0; m -= 1) {
      var y = e.findFirstNodeAtLine(m), S = ho(r, m), x = S && !!mp(y, function(z) {
        return $c(z);
      }), w = kl.exec(ho(r, m));
      if (!w && !x)
        break;
      if (!w && x) {
        d += 1;
        continue;
      }
      var k = w, O = k[1], T = k[3];
      if (!O) {
        f = Number(T), p = m;
        break;
      }
    }
    var L = f + s - p - d, j = [{ text: L + ". " + c, line: s }];
    return { changedResults: j };
  },
  task: function(i) {
    var e = i.doc, r = i.line, s = ho(e, r), l = [{ text: "* [ ] " + s, line: r }];
    return { changedResults: l };
  }
}, qie = {
  bullet: function(i) {
    var e = i.line, r = i.doc, s = ho(r, e), l = Hie.exec(s), c = l[1], f = l[2];
    return { listSyntax: "" + c + f };
  },
  ordered: function(i) {
    var e = i.toastMark, r = i.line, s = i.mdNode, l = i.doc, c = cW(s), f = ho(l, r), p = kl.exec(f), d = p[1], m = p[3], y = p[4], S = Number(m) + 1, x = "" + d + S + y, w = a3(e, r, c, !0), k = w.filter(function(O) {
      var T = kl.exec(ho(l, O.line));
      return T && T[1].length === d.length && !!mp(O.mdNode, function(L) {
        return Z6(L);
      });
    });
    return Nt({ listSyntax: x }, O4(l, k, "ordered", S));
  }
};
function C4(i, e, r, s, l) {
  for (var c = [], f = ho(i, r), p = kl.exec(f); p; ) {
    var d = p[1], m = p[4], y = p[5], S = d.length;
    if (S === l)
      c.push(Mi(e, "" + d + s + m + y)), s += 1, r += 1;
    else if (S > l) {
      var x = C4(i, e, r, 1, S);
      r = x.line, c = c.concat(x.nodes);
    }
    if (S < l || r > i.childCount)
      break;
    f = ho(i, r), p = kl.exec(f);
  }
  return { nodes: c, line: r };
}
var f8 = /(^\s{1,4})(.*)/;
function d8(i, e, r) {
  return i < e || Gc.test(r) || jg.test(r);
}
function h8(i, e, r) {
  var s = r.$from;
  s.depth === 0 && (s = i.resolve(s.pos - 1));
  var l = s.node(1), c = s.start(1), f = l.content.size;
  return l.rangeHasMark(0, f, e.marks.table) && s.pos - c !== f && s.pos !== c;
}
function p8(i, e) {
  var r = e.from, s = e.to;
  if (e.type === "indent") {
    var l = 4;
    r += l, s += (e.lineLen + 1) * l;
  } else {
    var c = e.spaceLenList;
    r -= c[0];
    for (var f = 0; f < c.length; f += 1)
      s -= c[f];
  }
  return On(i, r, s);
}
var Kie = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "paragraph";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "inline*",
          attrs: {
            className: { default: null },
            codeStart: { default: null },
            codeEnd: { default: null }
          },
          selectable: !1,
          group: "block",
          parseDOM: [{ tag: "div" }],
          toDOM: function(r) {
            var s = r.attrs;
            return s.className ? ["div", { class: di(s.className) }, 0] : ["div", 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.reorderList = function(r, s) {
      for (var l = this.context, c = l.view, f = l.toastMark, p = l.schema, d = c.state, m = d.tr, y = d.selection, S = d.doc, x = f.findFirstNodeAtLine(r), w = x; x && !kne(x) && x.parent.type !== "document"; )
        if (x = x.parent, Z6(x)) {
          w = x;
          break;
        }
      w && (r = w.sourcepos[0][0]);
      var k = kl.exec(ho(S, r)), O = k[1], T = k[3], L = O.length, j = C4(S, p, r, Number(T), L), z = j.line, J = j.nodes;
      s = Math.max(s, z - 1);
      for (var ie = wx(S, r - 1).startOffset, K = r - 1; K <= s - 1; K += 1) {
        var re = S.child(K), ee = re.nodeSize, de = re.content, Ce = m.mapping.map(ie), he = Ce + de.size;
        m.replaceWith(Ce, he, J[K - r + 1]), ie += ee;
      }
      var oe = On(m, y.from, y.to);
      c.dispatch(m.setSelection(oe));
    }, e.prototype.indent = function(r) {
      var s = this;
      return r === void 0 && (r = !1), function() {
        return function(l, c) {
          var f = l.schema, p = l.selection, d = l.doc, m = ci(p), y = m.from, S = m.to, x = m.startFromOffset, w = m.startIndex, k = m.endIndex;
          if (r && h8(d, f, p))
            return !1;
          var O = Iu(d, w);
          if (r && d8(y, S, O) || !r && Gc.test(O)) {
            var T = Sx({
              state: l,
              from: x,
              startIndex: w,
              endIndex: k,
              createText: function(j) {
                return "    " + j;
              }
            }), L = {
              type: "indent",
              from: y,
              to: S,
              lineLen: k - w
            };
            c(T.setSelection(p8(T, L))), kl.test(O) && s.reorderList(w + 1, k + 1);
          } else r && c(l.tr.insert(S, Mi(f, "    ")));
          return !0;
        };
      };
    }, e.prototype.outdent = function(r) {
      var s = this;
      return r === void 0 && (r = !1), function() {
        return function(l, c) {
          var f = l.selection, p = l.doc, d = l.schema, m = ci(f), y = m.from, S = m.to, x = m.startFromOffset, w = m.startIndex, k = m.endIndex;
          if (r && h8(p, d, f))
            return !1;
          var O = Iu(p, w);
          if (r && d8(y, S, O) || !r && Gc.test(O)) {
            var T = [], L = Sx({
              state: l,
              from: x,
              startIndex: w,
              endIndex: k,
              createText: function(K) {
                var re = f8.exec(K);
                return T.push(re ? re[1].length : 0), K.replace(f8, "$2");
              }
            }), j = { type: "outdent", from: y, to: S, spaceLenList: T };
            c(L.setSelection(p8(L, j))), kl.test(O) && s.reorderList(w + 1, k + 1);
          } else if (r) {
            var z = O.slice(0, S - x), J = z.replace(/\s{1,4}$/, ""), ie = S - (z.length - J.length);
            c(l.tr.delete(ie, S));
          }
          return !0;
        };
      };
    }, e.prototype.deleteLines = function() {
      var r = this;
      return function(s, l) {
        var c = r.context.view, f = ci(s.selection), p = f.startFromOffset, d = f.endToOffset, m = function() {
          return l(s.tr.deleteRange(p, d)), !0;
        };
        return Hx(m, F6)(s, l, c);
      };
    }, e.prototype.moveDown = function() {
      return function(r, s) {
        var l = r.doc, c = r.tr, f = r.selection, p = r.schema, d = ci(f), m = d.startFromOffset, y = d.endToOffset, S = d.endIndex;
        if (S < l.content.childCount - 1) {
          var x = l.child(S + 1), w = x.nodeSize, k = x.textContent;
          return c.delete(y, y + w).split(m).insert(c.mapping.map(m) - 2, Mi(p, k)), s(c), !0;
        }
        return !1;
      };
    }, e.prototype.moveUp = function() {
      return function(r, s) {
        var l = r.tr, c = r.doc, f = r.selection, p = r.schema, d = ci(f), m = d.startFromOffset, y = d.endToOffset, S = d.startIndex;
        if (S > 0) {
          var x = c.child(S - 1), w = x.nodeSize, k = x.textContent;
          return l.delete(m - w, m).split(l.mapping.map(y)).insert(l.mapping.map(y), Mi(p, k)), s(l), !0;
        }
        return !1;
      };
    }, e.prototype.commands = function() {
      return {
        indent: this.indent(),
        outdent: this.outdent()
      };
    }, e.prototype.keymaps = function() {
      return {
        Tab: this.indent(!0)(),
        "Shift-Tab": this.outdent(!0)(),
        "Mod-d": this.deleteLines(),
        "Mod-D": this.deleteLines(),
        "Alt-ArrowUp": this.moveUp(),
        "Alt-ArrowDown": this.moveDown()
      };
    }, e;
  }(Sn)
), Xie = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "text";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          group: "inline"
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Sn)
), Jie = /^#{1,6}\s/, Zie = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "heading";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            level: { default: 1 },
            seText: { default: !1 }
          },
          toDOM: function(r) {
            var s = r.attrs, l = s.level, c = s.seText, f = "heading|heading" + l;
            return c && (f += "|delimiter|setext"), ["span", { class: di.apply(void 0, f.split("|")) }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.createHeadingText = function(r, s, l) {
      for (var c = s.replace(l, "").trim(), f = ""; r > 0; )
        f += "#", r -= 1;
      return f + " " + c;
    }, e.prototype.commands = function() {
      var r = this;
      return function(s) {
        return function(l, c) {
          var f = s.level, p = ci(l.selection), d = p.startFromOffset, m = p.endToOffset, y = p.startIndex, S = p.endIndex, x = Sx({
            state: l,
            from: d,
            startIndex: y,
            endIndex: S,
            createText: function(w) {
              var k = w.match(Jie), O = k ? k[0] : "";
              return r.createHeadingText(f, w, O);
            }
          });
          return c(x.setSelection(On(x, x.mapping.map(m)))), !0;
        };
      };
    }, e;
  }(Cn)
), nj = "```", Qie = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "codeBlock";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: di("code-block") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return function() {
        return function(r, s) {
          var l = r.selection, c = r.schema, f = r.tr, p = ci(l), d = p.startFromOffset, m = p.endToOffset, y = Mi(c, nj);
          return f.insert(d, y).split(d + nj.length), f.split(f.mapping.map(m)).insert(f.mapping.map(m), y), s(f.setSelection(
            // subtract fenced syntax length and open, close tag(2)
            On(f, f.mapping.map(m) - (nj.length + 2))
          )), !0;
        };
      };
    }, e.prototype.keepIndentation = function() {
      var r = this;
      return function(s, l) {
        var c = s.selection, f = s.tr, p = s.doc, d = s.schema, m = r.context.toastMark, y = ci(c), S = y.startFromOffset, x = y.endToOffset, w = y.endIndex, k = y.from, O = y.to, T = Iu(p, w);
        if (k === O && T.trim()) {
          var L = T.match(/^\s+/), j = m.findFirstNodeAtLine(w + 1);
          if (xne(j) && L) {
            var z = L[0], J = T.slice(O - S), ie = Mi(d, z + J);
            return eW(f, x, J, ie), l(f), !0;
          }
        }
        return !1;
      };
    }, e.prototype.keymaps = function() {
      var r = this.commands()();
      return {
        "Shift-Mod-p": r,
        "Shift-Mod-P": r,
        Enter: this.keepIndentation()
      };
    }, e;
  }(Cn)
), eae = /\||\s/g;
function tae(i) {
  return [kx(i), kx(i, !0)];
}
function rae(i, e) {
  for (var r = [], s = 0; s < e; s += 1)
    r.push(kx(i));
  return r;
}
function kx(i, e) {
  for (var r = "|", s = 0; s < i; s += 1)
    r += e ? " --- |" : "  |";
  return r;
}
function nae(i) {
  return i ? { type: "next", parentType: "tableHead", childType: "firstChild" } : { type: "prev", parentType: "tableBody", childType: "lastChild" };
}
var iae = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "table";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: di("table") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.extendTable = function() {
      var r = this;
      return function(s, l) {
        var c = s.selection, f = s.doc, p = s.tr, d = s.schema;
        if (!c.empty)
          return !1;
        var m = ci(c), y = m.endFromOffset, S = m.endToOffset, x = m.endIndex, w = m.to, k = Iu(f, x), O = [x + 1, w - y + 1], T = r.context.toastMark.findNodeAtPosition(O), L = mp(T, function(K) {
          return r8(K) && (K.parent.type === "tableDelimRow" || K.parent.parent.type === "tableBody");
        });
        if (L) {
          var j = !k.replace(eae, "").trim(), z = L.parent, J = z.parent.parent.columns.length, ie = kx(J);
          return j ? p.deleteRange(y, S).split(p.mapping.map(S)) : p.split(S).insert(p.mapping.map(S), Mi(d, ie)).setSelection(On(p, p.mapping.map(S) - 2)), l(p), !0;
        }
        return !1;
      };
    }, e.prototype.moveTableCell = function(r) {
      var s = this;
      return function(l, c) {
        var f = l.selection, p = l.tr, d = ci(f), m = d.endFromOffset, y = d.endIndex, S = d.to, x = [y + 1, S - m], w = s.context.toastMark.findNodeAtPosition(x), k = mp(w, function(re) {
          return r8(re);
        });
        if (k) {
          var O = k.parent, T = nae(r), L = T.type, j = T.parentType, z = T.childType, J = Du(k);
          if (k[L])
            J = Du(k[L]) - 1;
          else {
            var ie = !O[L] && O.parent.type === j ? O.parent[L][z] : O[L];
            if (L === "next") {
              var K = ie ? Du(ie[z]) : 0;
              J += K + 2;
            } else L === "prev" && (J = ie ? -4 : 0);
          }
          return c(p.setSelection(On(p, m + J))), !0;
        }
        return !1;
      };
    }, e.prototype.addTable = function() {
      return function(r) {
        return function(s, l) {
          var c = s.selection, f = s.tr, p = s.schema, d = r, m = d.columnCount, y = d.rowCount, S = ci(c).endToOffset, x = tae(m), w = rae(m, y - 1), k = Ha(Ha([], x), w);
          return k.forEach(function(O) {
            f.split(f.mapping.map(S)).insert(f.mapping.map(S), Mi(p, O));
          }), l(f.setSelection(On(f, S + 4))), !0;
        };
      };
    }, e.prototype.commands = function() {
      return { addTable: this.addTable() };
    }, e.prototype.keymaps = function() {
      return {
        Enter: this.extendTable(),
        Tab: this.moveTableCell(!0),
        "Shift-Tab": this.moveTableCell(!1)
      };
    }, e;
  }(Cn)
), aae = "***", oae = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "thematicBreak";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: di("thematic-break") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.hr = function() {
      return function() {
        return function(r, s) {
          var l = r.selection, c = r.schema, f = r.tr, p = ci(l), d = p.from, m = p.to, y = p.endToOffset, S = Mi(c, aae);
          return f.split(d).replaceWith(f.mapping.map(d), f.mapping.map(m), S).split(f.mapping.map(m)).setSelection(On(f, f.mapping.map(y))), s(f), !0;
        };
      };
    }, e.prototype.commands = function() {
      return { hr: this.hr() };
    }, e.prototype.keymaps = function() {
      var r = this.hr()();
      return { "Mod-l": r, "Mod-L": r };
    }, e;
  }(Cn)
);
function sae(i, e) {
  var r = i.type, s = i.sourcepos, l = s[0][0];
  return e <= l && (r === "codeBlock" || r === "heading" || r.match("table"));
}
var lae = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "listItem";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            odd: { default: !1 },
            even: { default: !1 },
            listStyle: { default: !1 }
          },
          toDOM: function(r) {
            var s = r.attrs, l = s.odd, c = s.even, f = s.listStyle, p = "list-item";
            return f && (p += "|list-item-style"), l && (p += "|list-item-odd"), c && (p += "|list-item-even"), ["span", { class: di.apply(void 0, p.split("|")) }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.extendList = function() {
      var r = this;
      return function(s, l) {
        var c = s.selection, f = s.doc, p = s.schema, d = s.tr, m = r.context.toastMark, y = ci(c), S = y.to, x = y.startFromOffset, w = y.endFromOffset, k = y.endIndex, O = y.endToOffset, T = Iu(f, k), L = Gc.test(T);
        if (!L || c.from === x || !c.empty)
          return !1;
        var j = !T.replace(xx, "").trim();
        if (j)
          d.deleteRange(w, O).split(d.mapping.map(O));
        else {
          var z = uW(T), J = m.findFirstNodeAtLine(k + 1), ie = T.slice(S - w), K = { toastMark: m, mdNode: J, doc: f, line: k + 1 }, re = qie[z](K), ee = re.listSyntax, de = re.changedResults;
          if (de != null && de.length) {
            d.split(S), de.unshift({ text: ee + ie, line: k + 1 }), r.changeToListPerLine(d, de, {
              from: S,
              // don't subtract 1 because the line has increased through 'split' command.
              startLine: de[0].line,
              endLine: Qi(de).line
            });
            var Ce = d.mapping.map(O) - ie.length;
            d.setSelection(On(d, Ce));
          } else {
            var he = Mi(p, ee + ie);
            eW(d, O, ie, he);
          }
        }
        return l(d), !0;
      };
    }, e.prototype.toList = function(r) {
      var s = this;
      return function() {
        return function(l, c) {
          for (var f = l.doc, p = l.tr, d = l.selection, m = s.context.toastMark, y = ci(d), S = y.startIndex + 1, x = y.endIndex + 1, w = y.endToOffset, k = [], O = S; O <= x; O += 1) {
            var T = m.findFirstNodeAtLine(O);
            if (T && sae(T, O))
              break;
            if (k.indexOf(O) === -1) {
              var L = { toastMark: m, mdNode: T, doc: f, line: O, startLine: S }, j = ($c(T) ? Gie[r](L) : Yie[r](L)).changedResults, z = s.changeToListPerLine(p, j, {
                from: wx(f, j[0].line - 1).startOffset,
                startLine: j[0].line,
                endLine: Qi(j).line,
                indexDiff: 1
              });
              w = Math.max(z, w), j && (k = k.concat(j.map(function(J) {
                return J.line;
              })));
            }
          }
          return c(p.setSelection(On(p, p.mapping.map(w)))), !0;
        };
      };
    }, e.prototype.changeToListPerLine = function(r, s, l) {
      for (var c = l.from, f = l.startLine, p = l.endLine, d = l.indexDiff, m = d === void 0 ? 0 : d, y = 0, S = function(k) {
        var O = r.doc.child(k), T = O.nodeSize, L = O.content, j = r.mapping.map(c), z = j + L.size, J = s.filter(function(ie) {
          return ie.line - m === k;
        })[0];
        J && (r.replaceWith(j, z, Mi(x.context.schema, J.text)), y = Math.max(y, c + L.size)), c += T;
      }, x = this, w = f - m; w <= p - m; w += 1)
        S(w);
      return y;
    }, e.prototype.toggleTask = function() {
      var r = this;
      return function(s, l) {
        for (var c = s.selection, f = s.tr, p = s.doc, d = s.schema, m = r.context.toastMark, y = ci(c), S = y.startIndex, x = y.endIndex, w = null, k = S; k <= x; k += 1) {
          var O = m.findFirstNodeAtLine(k + 1);
          if ($c(O) && O.listData.task) {
            var T = O.listData, L = T.checked, j = T.padding, z = L ? " " : "x", J = O.sourcepos[0], ie = wx(p, J[0] - 1).startOffset;
            ie += J[1] + j, w = f.replaceWith(ie, ie + 1, d.text(z));
          }
        }
        return w ? (l(w), !0) : !1;
      };
    }, e.prototype.commands = function() {
      return {
        bulletList: this.toList("bullet"),
        orderedList: this.toList("ordered"),
        taskList: this.toList("task")
      };
    }, e.prototype.keymaps = function() {
      var r = this.toList("bullet")(), s = this.toList("ordered")(), l = this.toList("task")(), c = this.toggleTask();
      return {
        "Mod-u": r,
        "Mod-U": r,
        "Mod-o": s,
        "Mod-O": s,
        "alt-t": l,
        "alt-T": l,
        "Shift-Ctrl-x": c,
        "Shift-Ctrl-X": c,
        Enter: this.extendList()
      };
    }, e;
  }(Cn)
);
function Yx(i, e) {
  return function() {
    return function(r, s) {
      var l = r.tr, c = r.selection, f = _o(i) ? i : function(z) {
        return i.test(z);
      }, p = e.length, d = l.doc, m = b4(c), y = m[0], S = m[1], x = Math.max(y - p, 1), w = Math.min(S + p, d.content.size - 1), k = c.content(), O = k.content.textBetween(0, k.content.size, `
`), T = d.textBetween(x, y, `
`), L = d.textBetween(S, w, `
`);
      if (O = "" + T + O + L, T && L && f(O))
        l.delete(w - p, w).delete(x, x + p);
      else {
        l.insertText(e, S).insertText(e, y);
        var j = c.empty ? On(l, y + p) : On(l, y + p, S + p);
        l.setSelection(j);
      }
      return s(l), !0;
    };
  };
}
var uae = /^(\*{2}|_{2}).*([\s\S]*)\1$/m, cae = "**", fae = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "strong";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: di("strong") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.bold = function() {
      return Yx(uae, cae);
    }, e.prototype.commands = function() {
      return { bold: this.bold() };
    }, e.prototype.keymaps = function() {
      var r = this.bold()();
      return { "Mod-b": r, "Mod-B": r };
    }, e;
  }(Cn)
), dae = /^(~{2}).*([\s\S]*)\1$/m, hae = "~~", pae = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "strike";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: di("strike") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return Yx(dae, hae);
    }, e.prototype.keymaps = function() {
      var r = this.commands()();
      return { "Mod-s": r, "Mod-S": r };
    }, e;
  }(Cn)
), vae = /^(\*|_).*([\s\S]*)\1$/m, mae = "*", gae = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "emph";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: di("emph") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.italic = function() {
      return Yx(vae, mae);
    }, e.prototype.commands = function() {
      return { italic: this.italic() };
    }, e.prototype.keymaps = function() {
      var r = this.italic()();
      return { "Mod-i": r, "Mod-I": r };
    }, e;
  }(Cn)
), yae = /^(`).*([\s\S]*)\1$/m, bae = "`", Sae = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "code";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            start: { default: !1 },
            end: { default: !1 },
            marked: { default: !1 }
          },
          toDOM: function(r) {
            var s = r.attrs, l = s.start, c = s.end, f = s.marked, p = "code";
            return l && (p += "|delimiter|start"), c && (p += "|delimiter|end"), f && (p += "|marked-text"), ["span", { class: di.apply(void 0, p.split("|")) }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return Yx(yae, bae);
    }, e.prototype.keymaps = function() {
      var r = this.commands()();
      return { "Shift-Mod-c": r, "Shift-Mod-C": r };
    }, e;
  }(Cn)
), wae = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "link";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          attrs: {
            url: { default: !1 },
            desc: { default: !1 }
          },
          toDOM: function(r) {
            var s = r.attrs, l = s.url, c = s.desc, f = "link";
            return l && (f += "|link-url|marked-text"), c && (f += "|link-desc|marked-text"), ["span", { class: di.apply(void 0, f.split("|")) }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.addLinkOrImage = function(r) {
      return function(s) {
        return function(l, c) {
          var f = l.selection, p = l.tr, d = l.schema, m = b4(f), y = m[0], S = m[1], x = s, w = x.linkText, k = x.altText, O = x.linkUrl, T = x.imageUrl, L = w, j = O, z = "";
          return r === "image" && (L = k, j = T, z = "!"), L = gx(L), z += "[" + L + "](" + j + ")", c(p.replaceWith(y, S, Mi(d, z))), !0;
        };
      };
    }, e.prototype.commands = function() {
      return {
        addImage: this.addLinkOrImage("image"),
        addLink: this.addLinkOrImage("link")
      };
    }, e;
  }(Cn)
), xae = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "taskDelimiter";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: di("delimiter", "list-item") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Cn)
), kae = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "delimiter";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: di("delimiter") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Cn)
), Oae = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "meta";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: di("meta") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Cn)
), Cae = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "markedText";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: di("marked-text") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Cn)
), Tae = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "tableCell";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: di("table-cell") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Cn)
), Aae = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "html";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: di("html") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Cn)
), ij = "$$", Eae = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "customBlock";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          toDOM: function() {
            return ["span", { class: di("custom-block") }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return function(r) {
        return function(s, l) {
          var c = s.selection, f = s.schema, p = s.tr, d = ci(c), m = d.startFromOffset, y = d.endToOffset;
          if (!(r != null && r.info))
            return !1;
          var S = "" + ij + r.info, x = Mi(f, S), w = Mi(f, ij);
          return p.insert(m, x).split(m + S.length), p.split(p.mapping.map(y)).insert(p.mapping.map(y), w), l(p.setSelection(On(p, p.mapping.map(y) - (ij.length + 2)))), !0;
        };
      };
    }, e;
  }(Cn)
), Mae = /x|backspace/i, Rae = /^\[(\s*)(x?)(\s*)\](?:\s+)/i;
function Dae(i) {
  var e = i.schema, r = i.toastMark;
  return new Wa({
    props: {
      handleDOMEvents: {
        keyup: function(s, l) {
          var c, f = s.state, p = f.doc, d = f.tr, m = f.selection;
          if (m.empty && Mae.test(l.key)) {
            var y = ci(m), S = y.startIndex, x = y.startFromOffset, w = y.from, k = [S + 1, w - x + 1], O = r.findNodeAtPosition(k), T = mp(O, function(he) {
              var oe;
              return he.type === "paragraph" && ((oe = he.parent) === null || oe === void 0 ? void 0 : oe.type) === "item";
            });
            if (!((c = T == null ? void 0 : T.firstChild) === null || c === void 0) && c.literal) {
              var L = T.firstChild, j = L.literal.match(Rae);
              if (j) {
                var z = L.sourcepos[0], J = j[1], ie = j[2], K = j[3], re = J.length + K.length, ee = wx(p, z[0] - 1).startOffset, de = z[1] + ee;
                if (ie) {
                  var Ce = re ? re + 1 : 0;
                  d.replaceWith(de, Ce + de, e.text(ie)), s.dispatch(d);
                } else re || (d.insertText(" ", de), s.dispatch(d));
              }
            }
          }
          return !1;
        }
      }
    }
  });
}
var aj = "cut", v8 = /\r\n|\n|\r/, Pae = (
  /** @class */
  function(i) {
    pr(e, i);
    function e(r, s) {
      var l = i.call(this, r) || this, c = s.toastMark, f = s.useCommandShortcut, p = f === void 0 ? !0 : f, d = s.mdPlugins, m = d === void 0 ? [] : d;
      return l.editorType = "markdown", l.el.classList.add("md-mode"), l.toastMark = c, l.extraPlugins = m, l.specs = l.createSpecs(), l.schema = l.createSchema(), l.context = l.createContext(), l.keymaps = l.createKeymaps(p), l.view = l.createView(), l.commands = l.createCommands(), l.specs.setContext(Nt(Nt({}, l.context), { view: l.view })), l.createClipboard(), l.eventEmitter.listen("changePreviewTabWrite", function(y) {
        return l.toggleActive(!0, y);
      }), l.eventEmitter.listen("changePreviewTabPreview", function() {
        return l.toggleActive(!1);
      }), l.initEvent(), l;
    }
    return e.prototype.toggleActive = function(r, s) {
      rW(this.el, "active", r), r ? s || this.focus() : this.blur();
    }, e.prototype.createClipboard = function() {
      var r = this;
      this.clipboard = document.createElement("textarea"), this.clipboard.className = vr("pseudo-clipboard"), this.clipboard.addEventListener("paste", function(s) {
        var l = s.clipboardData || window.clipboardData, c = l && l.items;
        if (c) {
          var f = Ws(c).some(function(d) {
            return d.kind === "string" && d.type === "text/rtf";
          });
          if (!f) {
            var p = p4(c);
            p && (s.preventDefault(), oW(r.eventEmitter, p, s.type));
          }
        }
      }), this.clipboard.addEventListener("input", function(s) {
        var l = s.target.value;
        r.replaceSelection(l), s.preventDefault(), s.target.value = "";
      }), this.el.insertBefore(this.clipboard, this.view.dom);
    }, e.prototype.createContext = function() {
      return {
        toastMark: this.toastMark,
        schema: this.schema,
        eventEmitter: this.eventEmitter
      };
    }, e.prototype.createSpecs = function() {
      return new y4([
        new Fie(),
        new Kie(),
        new m4(),
        new Xie(),
        new Zie(),
        new zie(),
        new Qie(),
        new Eae(),
        new iae(),
        new Tae(),
        new oae(),
        new lae(),
        new fae(),
        new pae(),
        new gae(),
        new Sae(),
        new wae(),
        new kae(),
        new xae(),
        new Cae(),
        new Oae(),
        new Aae()
      ]);
    }, e.prototype.createPlugins = function() {
      return Ha([
        Tie(this.context),
        Bie(this.context),
        Dae(this.context)
      ], this.createPluginProps()).concat(this.defaultPlugins);
    }, e.prototype.createView = function() {
      var r = this;
      return new H3(this.el, {
        state: this.createState(),
        dispatchTransaction: function(s) {
          r.updateMarkdown(s);
          var l = r.view.state.applyTransaction(s).state;
          r.view.updateState(l), r.emitChangeEvent(s);
        },
        handleKeyDown: function(s, l) {
          return (l.metaKey || l.ctrlKey) && l.key.toUpperCase() === "V" && r.clipboard.focus(), r.eventEmitter.emit("keydown", r.editorType, l), !1;
        },
        handleDOMEvents: {
          copy: function(s, l) {
            return r.captureCopy(l);
          },
          cut: function(s, l) {
            return r.captureCopy(l, aj);
          },
          scroll: function() {
            return r.eventEmitter.emit("scroll", "editor"), !0;
          },
          keyup: function(s, l) {
            return r.eventEmitter.emit("keyup", r.editorType, l), !1;
          }
        },
        nodeViews: {
          widget: v4
        }
      });
    }, e.prototype.createCommands = function() {
      return this.specs.commands(this.view);
    }, e.prototype.captureCopy = function(r, s) {
      r.preventDefault();
      var l = this.view.state, c = l.selection, f = l.tr;
      if (c.empty)
        return !0;
      var p = this.getChanged(c.content());
      return r.clipboardData ? r.clipboardData.setData("text/plain", p) : window.clipboardData.setData("Text", p), s === aj && this.view.dispatch(f.deleteSelection().scrollIntoView().setMeta("uiEvent", aj)), !0;
    }, e.prototype.updateMarkdown = function(r) {
      var s = this;
      r.docChanged && r.steps.forEach(function(l, c) {
        if (l.slice && !(l instanceof mi)) {
          var f = r.docs[c], p = [l.from, l.to], d = p[0], m = p[1], y = Xw(f, d, m), S = y[0], x = y[1], w = s.getChanged(l.slice);
          S[0] === x[0] && S[1] === x[1] && w === "" && (w = `
`);
          var k = s.toastMark.editMarkdown(S, x, w);
          s.eventEmitter.emit("updatePreview", k), r.setMeta("editResult", k).scrollIntoView();
        }
      });
    }, e.prototype.getChanged = function(r) {
      var s = "", l = 0, c = r.content.size;
      return r.content.nodesBetween(l, c, function(f, p) {
        f.isText ? s += f.text.slice(Math.max(l, p) - p, c - p) : f.isBlock && p > 0 && (s += `
`);
      }), s;
    }, e.prototype.setSelection = function(r, s) {
      s === void 0 && (s = r);
      var l = this.view.state.tr, c = Ac(l.doc, r, s), f = c[0], p = c[1];
      this.view.dispatch(l.setSelection(On(l, f, p)).scrollIntoView());
    }, e.prototype.replaceSelection = function(r, s, l) {
      var c, f = this.view.state, p = f.tr, d = f.schema, m = f.doc, y = r.split(v8), S = y.map(function(T) {
        return bx(d, Bc(T, d));
      }), x = new ur(qt.from(S), 1, 1);
      if (this.focus(), s && l) {
        var w = Ac(m, s, l), k = w[0], O = w[1];
        c = p.replaceRange(k, O, x);
      } else
        c = p.replaceSelection(x);
      this.view.dispatch(c.scrollIntoView());
    }, e.prototype.deleteSelection = function(r, s) {
      var l, c = this.view.state, f = c.tr, p = c.doc;
      if (r && s) {
        var d = Ac(p, r, s), m = d[0], y = d[1];
        l = f.deleteRange(m, y);
      } else
        l = f.deleteSelection();
      this.view.dispatch(l.scrollIntoView());
    }, e.prototype.getSelectedText = function(r, s) {
      var l = this.view.state, c = l.doc, f = l.selection, p = f.from, d = f.to;
      if (r && s) {
        var m = Ac(c, r, s);
        p = m[0], d = m[1];
      }
      return c.textBetween(p, d, `
`);
    }, e.prototype.getSelection = function() {
      var r = this.view.state.selection, s = r.from, l = r.to;
      return Xw(this.view.state.tr.doc, s, l);
    }, e.prototype.setMarkdown = function(r, s) {
      s === void 0 && (s = !0);
      var l = r.split(v8), c = this.view.state, f = c.tr, p = c.doc, d = c.schema, m = l.map(function(y) {
        return bx(d, Bc(y, d));
      });
      this.view.dispatch(f.replaceWith(0, p.content.size, m)), s && this.moveCursorToEnd(!0);
    }, e.prototype.addWidget = function(r, s, l) {
      var c = this.view.state, f = c.tr, p = c.doc, d = c.selection, m = l ? Ac(p, l, l)[0] : d.to;
      this.view.dispatch(f.setMeta("widget", { pos: m, node: r, style: s }));
    }, e.prototype.replaceWithWidget = function(r, s, l) {
      var c = this.view.state, f = c.tr, p = c.schema, d = c.doc, m = Ac(d, r, s), y = Bc(l, p);
      this.view.dispatch(f.replaceWith(m[0], m[1], y));
    }, e.prototype.getRangeInfoOfNode = function(r) {
      var s = this.view.state, l = s.doc, c = s.selection, f = r || Xw(l, c.from)[0], p = this.toastMark.findNodeAtPosition(f);
      return p.type === "text" && p.parent.type !== "paragraph" && (p = p.parent), p.sourcepos[1][1] += 1, { range: p.sourcepos, type: p.type };
    }, e.prototype.getMarkdown = function() {
      return this.toastMark.getLineTexts().map(function(r) {
        return Ux(r);
      }).join(`
`);
    }, e.prototype.getToastMark = function() {
      return this.toastMark;
    }, e;
  }(g4)
), m8 = "_feEventKey";
function Lae(i, e) {
  var r = i[m8], s;
  return r || (r = i[m8] = {}), s = r[e], s || (s = r[e] = []), s;
}
var T4 = Lae, Iae = Tl, Ox = jx, _ae = T4;
function Nae(i, e, r) {
  if (Iae(e)) {
    Ox(e.split(/\s+/g), function(s) {
      g8(i, s, r);
    });
    return;
  }
  Ox(e, function(s, l) {
    g8(i, l, s);
  });
}
function g8(i, e, r) {
  var s = _ae(i, e), l;
  r ? (Ox(s, function(c, f) {
    return r === c.handler ? (y8(i, e, c.wrappedHandler), l = f, !1) : !0;
  }), s.splice(l, 1)) : (Ox(s, function(c) {
    y8(i, e, c.wrappedHandler);
  }), s.splice(0, s.length));
}
function y8(i, e, r) {
  "removeEventListener" in i ? i.removeEventListener(e, r) : "detachEvent" in i && i.detachEvent("on" + e, r);
}
var A4 = Nae, Bae = Tl, o3 = jx, Fae = T4;
function zae(i, e, r, s) {
  if (Bae(e)) {
    o3(e.split(/\s+/g), function(l) {
      b8(i, l, r, s);
    });
    return;
  }
  o3(e, function(l, c) {
    b8(i, c, l, r);
  });
}
function b8(i, e, r, s) {
  function l(c) {
    r.call(s || i, c || window.event);
  }
  "addEventListener" in i ? i.addEventListener(e, l) : "attachEvent" in i && i.attachEvent("on" + e, l), Hae(i, e, r, l);
}
function Hae(i, e, r, s) {
  var l = Fae(i, e), c = !1;
  o3(l, function(f) {
    return f.handler === r ? (c = !0, !1) : !0;
  }), c || l.push({
    handler: r,
    wrappedHandler: s
  });
}
var E4 = zae;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var s3 = function(i, e) {
  return s3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, s) {
    r.__proto__ = s;
  } || function(r, s) {
    for (var l in s) Object.prototype.hasOwnProperty.call(s, l) && (r[l] = s[l]);
  }, s3(i, e);
};
function No(i, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  s3(i, e);
  function r() {
    this.constructor = i;
  }
  i.prototype = e === null ? Object.create(e) : (r.prototype = e.prototype, new r());
}
var Ai = function() {
  return Ai = Object.assign || function(e) {
    for (var r, s = 1, l = arguments.length; s < l; s++) {
      r = arguments[s];
      for (var c in r) Object.prototype.hasOwnProperty.call(r, c) && (e[c] = r[c]);
    }
    return e;
  }, Ai.apply(this, arguments);
};
function l3(i, e, r) {
  if (arguments.length === 2) for (var s = 0, l = e.length, c; s < l; s++)
    (c || !(s in e)) && (c || (c = Array.prototype.slice.call(e, 0, s)), c[s] = e[s]);
  return i.concat(c || Array.prototype.slice.call(e));
}
var bp = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, S8 = {};
function jae(i) {
  var e, r, s = S8[i];
  if (s)
    return s;
  for (s = S8[i] = [], e = 0; e < 128; e++)
    r = String.fromCharCode(e), /^[0-9a-z]$/i.test(r) ? s.push(r) : s.push("%" + ("0" + e.toString(16).toUpperCase()).slice(-2));
  for (e = 0; e < i.length; e++)
    s[i.charCodeAt(e)] = i[e];
  return s;
}
function qx(i, e, r) {
  var s, l, c, f, p, d = "";
  for (typeof e != "string" && (r = e, e = qx.defaultChars), typeof r > "u" && (r = !0), p = jae(e), s = 0, l = i.length; s < l; s++) {
    if (c = i.charCodeAt(s), r && c === 37 && s + 2 < l && /^[0-9a-f]{2}$/i.test(i.slice(s + 1, s + 3))) {
      d += i.slice(s, s + 3), s += 2;
      continue;
    }
    if (c < 128) {
      d += p[c];
      continue;
    }
    if (c >= 55296 && c <= 57343) {
      if (c >= 55296 && c <= 56319 && s + 1 < l && (f = i.charCodeAt(s + 1), f >= 56320 && f <= 57343)) {
        d += encodeURIComponent(i[s] + i[s + 1]), s++;
        continue;
      }
      d += "%EF%BF%BD";
      continue;
    }
    d += encodeURIComponent(i[s]);
  }
  return d;
}
qx.defaultChars = ";/?:@&=+$,-_.!~*'()#";
qx.componentChars = "-_.!~*'()";
var Wae = qx, fW = {}, Ol = {}, $ae = "Á", Uae = "á", Vae = "Ă", Gae = "ă", Yae = "∾", qae = "∿", Kae = "∾̳", Xae = "Â", Jae = "â", Zae = "´", Qae = "А", eoe = "а", toe = "Æ", roe = "æ", noe = "⁡", ioe = "𝔄", aoe = "𝔞", ooe = "À", soe = "à", loe = "ℵ", uoe = "ℵ", coe = "Α", foe = "α", doe = "Ā", hoe = "ā", poe = "⨿", voe = "&", moe = "&", goe = "⩕", yoe = "⩓", boe = "∧", Soe = "⩜", woe = "⩘", xoe = "⩚", koe = "∠", Ooe = "⦤", Coe = "∠", Toe = "⦨", Aoe = "⦩", Eoe = "⦪", Moe = "⦫", Roe = "⦬", Doe = "⦭", Poe = "⦮", Loe = "⦯", Ioe = "∡", _oe = "∟", Noe = "⊾", Boe = "⦝", Foe = "∢", zoe = "Å", Hoe = "⍼", joe = "Ą", Woe = "ą", $oe = "𝔸", Uoe = "𝕒", Voe = "⩯", Goe = "≈", Yoe = "⩰", qoe = "≊", Koe = "≋", Xoe = "'", Joe = "⁡", Zoe = "≈", Qoe = "≊", ese = "Å", tse = "å", rse = "𝒜", nse = "𝒶", ise = "≔", ase = "*", ose = "≈", sse = "≍", lse = "Ã", use = "ã", cse = "Ä", fse = "ä", dse = "∳", hse = "⨑", pse = "≌", vse = "϶", mse = "‵", gse = "∽", yse = "⋍", bse = "∖", Sse = "⫧", wse = "⊽", xse = "⌅", kse = "⌆", Ose = "⌅", Cse = "⎵", Tse = "⎶", Ase = "≌", Ese = "Б", Mse = "б", Rse = "„", Dse = "∵", Pse = "∵", Lse = "∵", Ise = "⦰", _se = "϶", Nse = "ℬ", Bse = "ℬ", Fse = "Β", zse = "β", Hse = "ℶ", jse = "≬", Wse = "𝔅", $se = "𝔟", Use = "⋂", Vse = "◯", Gse = "⋃", Yse = "⨀", qse = "⨁", Kse = "⨂", Xse = "⨆", Jse = "★", Zse = "▽", Qse = "△", ele = "⨄", tle = "⋁", rle = "⋀", nle = "⤍", ile = "⧫", ale = "▪", ole = "▴", sle = "▾", lle = "◂", ule = "▸", cle = "␣", fle = "▒", dle = "░", hle = "▓", ple = "█", vle = "=⃥", mle = "≡⃥", gle = "⫭", yle = "⌐", ble = "𝔹", Sle = "𝕓", wle = "⊥", xle = "⊥", kle = "⋈", Ole = "⧉", Cle = "┐", Tle = "╕", Ale = "╖", Ele = "╗", Mle = "┌", Rle = "╒", Dle = "╓", Ple = "╔", Lle = "─", Ile = "═", _le = "┬", Nle = "╤", Ble = "╥", Fle = "╦", zle = "┴", Hle = "╧", jle = "╨", Wle = "╩", $le = "⊟", Ule = "⊞", Vle = "⊠", Gle = "┘", Yle = "╛", qle = "╜", Kle = "╝", Xle = "└", Jle = "╘", Zle = "╙", Qle = "╚", eue = "│", tue = "║", rue = "┼", nue = "╪", iue = "╫", aue = "╬", oue = "┤", sue = "╡", lue = "╢", uue = "╣", cue = "├", fue = "╞", due = "╟", hue = "╠", pue = "‵", vue = "˘", mue = "˘", gue = "¦", yue = "𝒷", bue = "ℬ", Sue = "⁏", wue = "∽", xue = "⋍", kue = "⧅", Oue = "\\", Cue = "⟈", Tue = "•", Aue = "•", Eue = "≎", Mue = "⪮", Rue = "≏", Due = "≎", Pue = "≏", Lue = "Ć", Iue = "ć", _ue = "⩄", Nue = "⩉", Bue = "⩋", Fue = "∩", zue = "⋒", Hue = "⩇", jue = "⩀", Wue = "ⅅ", $ue = "∩︀", Uue = "⁁", Vue = "ˇ", Gue = "ℭ", Yue = "⩍", que = "Č", Kue = "č", Xue = "Ç", Jue = "ç", Zue = "Ĉ", Que = "ĉ", ece = "∰", tce = "⩌", rce = "⩐", nce = "Ċ", ice = "ċ", ace = "¸", oce = "¸", sce = "⦲", lce = "¢", uce = "·", cce = "·", fce = "𝔠", dce = "ℭ", hce = "Ч", pce = "ч", vce = "✓", mce = "✓", gce = "Χ", yce = "χ", bce = "ˆ", Sce = "≗", wce = "↺", xce = "↻", kce = "⊛", Oce = "⊚", Cce = "⊝", Tce = "⊙", Ace = "®", Ece = "Ⓢ", Mce = "⊖", Rce = "⊕", Dce = "⊗", Pce = "○", Lce = "⧃", Ice = "≗", _ce = "⨐", Nce = "⫯", Bce = "⧂", Fce = "∲", zce = "”", Hce = "’", jce = "♣", Wce = "♣", $ce = ":", Uce = "∷", Vce = "⩴", Gce = "≔", Yce = "≔", qce = ",", Kce = "@", Xce = "∁", Jce = "∘", Zce = "∁", Qce = "ℂ", efe = "≅", tfe = "⩭", rfe = "≡", nfe = "∮", ife = "∯", afe = "∮", ofe = "𝕔", sfe = "ℂ", lfe = "∐", ufe = "∐", cfe = "©", ffe = "©", dfe = "℗", hfe = "∳", pfe = "↵", vfe = "✗", mfe = "⨯", gfe = "𝒞", yfe = "𝒸", bfe = "⫏", Sfe = "⫑", wfe = "⫐", xfe = "⫒", kfe = "⋯", Ofe = "⤸", Cfe = "⤵", Tfe = "⋞", Afe = "⋟", Efe = "↶", Mfe = "⤽", Rfe = "⩈", Dfe = "⩆", Pfe = "≍", Lfe = "∪", Ife = "⋓", _fe = "⩊", Nfe = "⊍", Bfe = "⩅", Ffe = "∪︀", zfe = "↷", Hfe = "⤼", jfe = "⋞", Wfe = "⋟", $fe = "⋎", Ufe = "⋏", Vfe = "¤", Gfe = "↶", Yfe = "↷", qfe = "⋎", Kfe = "⋏", Xfe = "∲", Jfe = "∱", Zfe = "⌭", Qfe = "†", ede = "‡", tde = "ℸ", rde = "↓", nde = "↡", ide = "⇓", ade = "‐", ode = "⫤", sde = "⊣", lde = "⤏", ude = "˝", cde = "Ď", fde = "ď", dde = "Д", hde = "д", pde = "‡", vde = "⇊", mde = "ⅅ", gde = "ⅆ", yde = "⤑", bde = "⩷", Sde = "°", wde = "∇", xde = "Δ", kde = "δ", Ode = "⦱", Cde = "⥿", Tde = "𝔇", Ade = "𝔡", Ede = "⥥", Mde = "⇃", Rde = "⇂", Dde = "´", Pde = "˙", Lde = "˝", Ide = "`", _de = "˜", Nde = "⋄", Bde = "⋄", Fde = "⋄", zde = "♦", Hde = "♦", jde = "¨", Wde = "ⅆ", $de = "ϝ", Ude = "⋲", Vde = "÷", Gde = "÷", Yde = "⋇", qde = "⋇", Kde = "Ђ", Xde = "ђ", Jde = "⌞", Zde = "⌍", Qde = "$", ehe = "𝔻", the = "𝕕", rhe = "¨", nhe = "˙", ihe = "⃜", ahe = "≐", ohe = "≑", she = "≐", lhe = "∸", uhe = "∔", che = "⊡", fhe = "⌆", dhe = "∯", hhe = "¨", phe = "⇓", vhe = "⇐", mhe = "⇔", ghe = "⫤", yhe = "⟸", bhe = "⟺", She = "⟹", whe = "⇒", xhe = "⊨", khe = "⇑", Ohe = "⇕", Che = "∥", The = "⤓", Ahe = "↓", Ehe = "↓", Mhe = "⇓", Rhe = "⇵", Dhe = "̑", Phe = "⇊", Lhe = "⇃", Ihe = "⇂", _he = "⥐", Nhe = "⥞", Bhe = "⥖", Fhe = "↽", zhe = "⥟", Hhe = "⥗", jhe = "⇁", Whe = "↧", $he = "⊤", Uhe = "⤐", Vhe = "⌟", Ghe = "⌌", Yhe = "𝒟", qhe = "𝒹", Khe = "Ѕ", Xhe = "ѕ", Jhe = "⧶", Zhe = "Đ", Qhe = "đ", epe = "⋱", tpe = "▿", rpe = "▾", npe = "⇵", ipe = "⥯", ape = "⦦", ope = "Џ", spe = "џ", lpe = "⟿", upe = "É", cpe = "é", fpe = "⩮", dpe = "Ě", hpe = "ě", ppe = "Ê", vpe = "ê", mpe = "≖", gpe = "≕", ype = "Э", bpe = "э", Spe = "⩷", wpe = "Ė", xpe = "ė", kpe = "≑", Ope = "ⅇ", Cpe = "≒", Tpe = "𝔈", Ape = "𝔢", Epe = "⪚", Mpe = "È", Rpe = "è", Dpe = "⪖", Ppe = "⪘", Lpe = "⪙", Ipe = "∈", _pe = "⏧", Npe = "ℓ", Bpe = "⪕", Fpe = "⪗", zpe = "Ē", Hpe = "ē", jpe = "∅", Wpe = "∅", $pe = "◻", Upe = "∅", Vpe = "▫", Gpe = " ", Ype = " ", qpe = " ", Kpe = "Ŋ", Xpe = "ŋ", Jpe = " ", Zpe = "Ę", Qpe = "ę", eve = "𝔼", tve = "𝕖", rve = "⋕", nve = "⧣", ive = "⩱", ave = "ε", ove = "Ε", sve = "ε", lve = "ϵ", uve = "≖", cve = "≕", fve = "≂", dve = "⪖", hve = "⪕", pve = "⩵", vve = "=", mve = "≂", gve = "≟", yve = "⇌", bve = "≡", Sve = "⩸", wve = "⧥", xve = "⥱", kve = "≓", Ove = "ℯ", Cve = "ℰ", Tve = "≐", Ave = "⩳", Eve = "≂", Mve = "Η", Rve = "η", Dve = "Ð", Pve = "ð", Lve = "Ë", Ive = "ë", _ve = "€", Nve = "!", Bve = "∃", Fve = "∃", zve = "ℰ", Hve = "ⅇ", jve = "ⅇ", Wve = "≒", $ve = "Ф", Uve = "ф", Vve = "♀", Gve = "ﬃ", Yve = "ﬀ", qve = "ﬄ", Kve = "𝔉", Xve = "𝔣", Jve = "ﬁ", Zve = "◼", Qve = "▪", eme = "fj", tme = "♭", rme = "ﬂ", nme = "▱", ime = "ƒ", ame = "𝔽", ome = "𝕗", sme = "∀", lme = "∀", ume = "⋔", cme = "⫙", fme = "ℱ", dme = "⨍", hme = "½", pme = "⅓", vme = "¼", mme = "⅕", gme = "⅙", yme = "⅛", bme = "⅔", Sme = "⅖", wme = "¾", xme = "⅗", kme = "⅜", Ome = "⅘", Cme = "⅚", Tme = "⅝", Ame = "⅞", Eme = "⁄", Mme = "⌢", Rme = "𝒻", Dme = "ℱ", Pme = "ǵ", Lme = "Γ", Ime = "γ", _me = "Ϝ", Nme = "ϝ", Bme = "⪆", Fme = "Ğ", zme = "ğ", Hme = "Ģ", jme = "Ĝ", Wme = "ĝ", $me = "Г", Ume = "г", Vme = "Ġ", Gme = "ġ", Yme = "≥", qme = "≧", Kme = "⪌", Xme = "⋛", Jme = "≥", Zme = "≧", Qme = "⩾", ege = "⪩", tge = "⩾", rge = "⪀", nge = "⪂", ige = "⪄", age = "⋛︀", oge = "⪔", sge = "𝔊", lge = "𝔤", uge = "≫", cge = "⋙", fge = "⋙", dge = "ℷ", hge = "Ѓ", pge = "ѓ", vge = "⪥", mge = "≷", gge = "⪒", yge = "⪤", bge = "⪊", Sge = "⪊", wge = "⪈", xge = "≩", kge = "⪈", Oge = "≩", Cge = "⋧", Tge = "𝔾", Age = "𝕘", Ege = "`", Mge = "≥", Rge = "⋛", Dge = "≧", Pge = "⪢", Lge = "≷", Ige = "⩾", _ge = "≳", Nge = "𝒢", Bge = "ℊ", Fge = "≳", zge = "⪎", Hge = "⪐", jge = "⪧", Wge = "⩺", $ge = ">", Uge = ">", Vge = "≫", Gge = "⋗", Yge = "⦕", qge = "⩼", Kge = "⪆", Xge = "⥸", Jge = "⋗", Zge = "⋛", Qge = "⪌", eye = "≷", tye = "≳", rye = "≩︀", nye = "≩︀", iye = "ˇ", aye = " ", oye = "½", sye = "ℋ", lye = "Ъ", uye = "ъ", cye = "⥈", fye = "↔", dye = "⇔", hye = "↭", pye = "^", vye = "ℏ", mye = "Ĥ", gye = "ĥ", yye = "♥", bye = "♥", Sye = "…", wye = "⊹", xye = "𝔥", kye = "ℌ", Oye = "ℋ", Cye = "⤥", Tye = "⤦", Aye = "⇿", Eye = "∻", Mye = "↩", Rye = "↪", Dye = "𝕙", Pye = "ℍ", Lye = "―", Iye = "─", _ye = "𝒽", Nye = "ℋ", Bye = "ℏ", Fye = "Ħ", zye = "ħ", Hye = "≎", jye = "≏", Wye = "⁃", $ye = "‐", Uye = "Í", Vye = "í", Gye = "⁣", Yye = "Î", qye = "î", Kye = "И", Xye = "и", Jye = "İ", Zye = "Е", Qye = "е", ebe = "¡", tbe = "⇔", rbe = "𝔦", nbe = "ℑ", ibe = "Ì", abe = "ì", obe = "ⅈ", sbe = "⨌", lbe = "∭", ube = "⧜", cbe = "℩", fbe = "Ĳ", dbe = "ĳ", hbe = "Ī", pbe = "ī", vbe = "ℑ", mbe = "ⅈ", gbe = "ℐ", ybe = "ℑ", bbe = "ı", Sbe = "ℑ", wbe = "⊷", xbe = "Ƶ", kbe = "⇒", Obe = "℅", Cbe = "∞", Tbe = "⧝", Abe = "ı", Ebe = "⊺", Mbe = "∫", Rbe = "∬", Dbe = "ℤ", Pbe = "∫", Lbe = "⊺", Ibe = "⋂", _be = "⨗", Nbe = "⨼", Bbe = "⁣", Fbe = "⁢", zbe = "Ё", Hbe = "ё", jbe = "Į", Wbe = "į", $be = "𝕀", Ube = "𝕚", Vbe = "Ι", Gbe = "ι", Ybe = "⨼", qbe = "¿", Kbe = "𝒾", Xbe = "ℐ", Jbe = "∈", Zbe = "⋵", Qbe = "⋹", e0e = "⋴", t0e = "⋳", r0e = "∈", n0e = "⁢", i0e = "Ĩ", a0e = "ĩ", o0e = "І", s0e = "і", l0e = "Ï", u0e = "ï", c0e = "Ĵ", f0e = "ĵ", d0e = "Й", h0e = "й", p0e = "𝔍", v0e = "𝔧", m0e = "ȷ", g0e = "𝕁", y0e = "𝕛", b0e = "𝒥", S0e = "𝒿", w0e = "Ј", x0e = "ј", k0e = "Є", O0e = "є", C0e = "Κ", T0e = "κ", A0e = "ϰ", E0e = "Ķ", M0e = "ķ", R0e = "К", D0e = "к", P0e = "𝔎", L0e = "𝔨", I0e = "ĸ", _0e = "Х", N0e = "х", B0e = "Ќ", F0e = "ќ", z0e = "𝕂", H0e = "𝕜", j0e = "𝒦", W0e = "𝓀", $0e = "⇚", U0e = "Ĺ", V0e = "ĺ", G0e = "⦴", Y0e = "ℒ", q0e = "Λ", K0e = "λ", X0e = "⟨", J0e = "⟪", Z0e = "⦑", Q0e = "⟨", eSe = "⪅", tSe = "ℒ", rSe = "«", nSe = "⇤", iSe = "⤟", aSe = "←", oSe = "↞", sSe = "⇐", lSe = "⤝", uSe = "↩", cSe = "↫", fSe = "⤹", dSe = "⥳", hSe = "↢", pSe = "⤙", vSe = "⤛", mSe = "⪫", gSe = "⪭", ySe = "⪭︀", bSe = "⤌", SSe = "⤎", wSe = "❲", xSe = "{", kSe = "[", OSe = "⦋", CSe = "⦏", TSe = "⦍", ASe = "Ľ", ESe = "ľ", MSe = "Ļ", RSe = "ļ", DSe = "⌈", PSe = "{", LSe = "Л", ISe = "л", _Se = "⤶", NSe = "“", BSe = "„", FSe = "⥧", zSe = "⥋", HSe = "↲", jSe = "≤", WSe = "≦", $Se = "⟨", USe = "⇤", VSe = "←", GSe = "←", YSe = "⇐", qSe = "⇆", KSe = "↢", XSe = "⌈", JSe = "⟦", ZSe = "⥡", QSe = "⥙", ewe = "⇃", twe = "⌊", rwe = "↽", nwe = "↼", iwe = "⇇", awe = "↔", owe = "↔", swe = "⇔", lwe = "⇆", uwe = "⇋", cwe = "↭", fwe = "⥎", dwe = "↤", hwe = "⊣", pwe = "⥚", vwe = "⋋", mwe = "⧏", gwe = "⊲", ywe = "⊴", bwe = "⥑", Swe = "⥠", wwe = "⥘", xwe = "↿", kwe = "⥒", Owe = "↼", Cwe = "⪋", Twe = "⋚", Awe = "≤", Ewe = "≦", Mwe = "⩽", Rwe = "⪨", Dwe = "⩽", Pwe = "⩿", Lwe = "⪁", Iwe = "⪃", _we = "⋚︀", Nwe = "⪓", Bwe = "⪅", Fwe = "⋖", zwe = "⋚", Hwe = "⪋", jwe = "⋚", Wwe = "≦", $we = "≶", Uwe = "≶", Vwe = "⪡", Gwe = "≲", Ywe = "⩽", qwe = "≲", Kwe = "⥼", Xwe = "⌊", Jwe = "𝔏", Zwe = "𝔩", Qwe = "≶", exe = "⪑", txe = "⥢", rxe = "↽", nxe = "↼", ixe = "⥪", axe = "▄", oxe = "Љ", sxe = "љ", lxe = "⇇", uxe = "≪", cxe = "⋘", fxe = "⌞", dxe = "⇚", hxe = "⥫", pxe = "◺", vxe = "Ŀ", mxe = "ŀ", gxe = "⎰", yxe = "⎰", bxe = "⪉", Sxe = "⪉", wxe = "⪇", xxe = "≨", kxe = "⪇", Oxe = "≨", Cxe = "⋦", Txe = "⟬", Axe = "⇽", Exe = "⟦", Mxe = "⟵", Rxe = "⟵", Dxe = "⟸", Pxe = "⟷", Lxe = "⟷", Ixe = "⟺", _xe = "⟼", Nxe = "⟶", Bxe = "⟶", Fxe = "⟹", zxe = "↫", Hxe = "↬", jxe = "⦅", Wxe = "𝕃", $xe = "𝕝", Uxe = "⨭", Vxe = "⨴", Gxe = "∗", Yxe = "_", qxe = "↙", Kxe = "↘", Xxe = "◊", Jxe = "◊", Zxe = "⧫", Qxe = "(", eke = "⦓", tke = "⇆", rke = "⌟", nke = "⇋", ike = "⥭", ake = "‎", oke = "⊿", ske = "‹", lke = "𝓁", uke = "ℒ", cke = "↰", fke = "↰", dke = "≲", hke = "⪍", pke = "⪏", vke = "[", mke = "‘", gke = "‚", yke = "Ł", bke = "ł", Ske = "⪦", wke = "⩹", xke = "<", kke = "<", Oke = "≪", Cke = "⋖", Tke = "⋋", Ake = "⋉", Eke = "⥶", Mke = "⩻", Rke = "◃", Dke = "⊴", Pke = "◂", Lke = "⦖", Ike = "⥊", _ke = "⥦", Nke = "≨︀", Bke = "≨︀", Fke = "¯", zke = "♂", Hke = "✠", jke = "✠", Wke = "↦", $ke = "↦", Uke = "↧", Vke = "↤", Gke = "↥", Yke = "▮", qke = "⨩", Kke = "М", Xke = "м", Jke = "—", Zke = "∺", Qke = "∡", eOe = " ", tOe = "ℳ", rOe = "𝔐", nOe = "𝔪", iOe = "℧", aOe = "µ", oOe = "*", sOe = "⫰", lOe = "∣", uOe = "·", cOe = "⊟", fOe = "−", dOe = "∸", hOe = "⨪", pOe = "∓", vOe = "⫛", mOe = "…", gOe = "∓", yOe = "⊧", bOe = "𝕄", SOe = "𝕞", wOe = "∓", xOe = "𝓂", kOe = "ℳ", OOe = "∾", COe = "Μ", TOe = "μ", AOe = "⊸", EOe = "⊸", MOe = "∇", ROe = "Ń", DOe = "ń", POe = "∠⃒", LOe = "≉", IOe = "⩰̸", _Oe = "≋̸", NOe = "ŉ", BOe = "≉", FOe = "♮", zOe = "ℕ", HOe = "♮", jOe = " ", WOe = "≎̸", $Oe = "≏̸", UOe = "⩃", VOe = "Ň", GOe = "ň", YOe = "Ņ", qOe = "ņ", KOe = "≇", XOe = "⩭̸", JOe = "⩂", ZOe = "Н", QOe = "н", eCe = "–", tCe = "⤤", rCe = "↗", nCe = "⇗", iCe = "↗", aCe = "≠", oCe = "≐̸", sCe = "​", lCe = "​", uCe = "​", cCe = "​", fCe = "≢", dCe = "⤨", hCe = "≂̸", pCe = "≫", vCe = "≪", mCe = `
`, gCe = "∄", yCe = "∄", bCe = "𝔑", SCe = "𝔫", wCe = "≧̸", xCe = "≱", kCe = "≱", OCe = "≧̸", CCe = "⩾̸", TCe = "⩾̸", ACe = "⋙̸", ECe = "≵", MCe = "≫⃒", RCe = "≯", DCe = "≯", PCe = "≫̸", LCe = "↮", ICe = "⇎", _Ce = "⫲", NCe = "∋", BCe = "⋼", FCe = "⋺", zCe = "∋", HCe = "Њ", jCe = "њ", WCe = "↚", $Ce = "⇍", UCe = "‥", VCe = "≦̸", GCe = "≰", YCe = "↚", qCe = "⇍", KCe = "↮", XCe = "⇎", JCe = "≰", ZCe = "≦̸", QCe = "⩽̸", e1e = "⩽̸", t1e = "≮", r1e = "⋘̸", n1e = "≴", i1e = "≪⃒", a1e = "≮", o1e = "⋪", s1e = "⋬", l1e = "≪̸", u1e = "∤", c1e = "⁠", f1e = " ", d1e = "𝕟", h1e = "ℕ", p1e = "⫬", v1e = "¬", m1e = "≢", g1e = "≭", y1e = "∦", b1e = "∉", S1e = "≠", w1e = "≂̸", x1e = "∄", k1e = "≯", O1e = "≱", C1e = "≧̸", T1e = "≫̸", A1e = "≹", E1e = "⩾̸", M1e = "≵", R1e = "≎̸", D1e = "≏̸", P1e = "∉", L1e = "⋵̸", I1e = "⋹̸", _1e = "∉", N1e = "⋷", B1e = "⋶", F1e = "⧏̸", z1e = "⋪", H1e = "⋬", j1e = "≮", W1e = "≰", $1e = "≸", U1e = "≪̸", V1e = "⩽̸", G1e = "≴", Y1e = "⪢̸", q1e = "⪡̸", K1e = "∌", X1e = "∌", J1e = "⋾", Z1e = "⋽", Q1e = "⊀", eTe = "⪯̸", tTe = "⋠", rTe = "∌", nTe = "⧐̸", iTe = "⋫", aTe = "⋭", oTe = "⊏̸", sTe = "⋢", lTe = "⊐̸", uTe = "⋣", cTe = "⊂⃒", fTe = "⊈", dTe = "⊁", hTe = "⪰̸", pTe = "⋡", vTe = "≿̸", mTe = "⊃⃒", gTe = "⊉", yTe = "≁", bTe = "≄", STe = "≇", wTe = "≉", xTe = "∤", kTe = "∦", OTe = "∦", CTe = "⫽⃥", TTe = "∂̸", ATe = "⨔", ETe = "⊀", MTe = "⋠", RTe = "⊀", DTe = "⪯̸", PTe = "⪯̸", LTe = "⤳̸", ITe = "↛", _Te = "⇏", NTe = "↝̸", BTe = "↛", FTe = "⇏", zTe = "⋫", HTe = "⋭", jTe = "⊁", WTe = "⋡", $Te = "⪰̸", UTe = "𝒩", VTe = "𝓃", GTe = "∤", YTe = "∦", qTe = "≁", KTe = "≄", XTe = "≄", JTe = "∤", ZTe = "∦", QTe = "⋢", eAe = "⋣", tAe = "⊄", rAe = "⫅̸", nAe = "⊈", iAe = "⊂⃒", aAe = "⊈", oAe = "⫅̸", sAe = "⊁", lAe = "⪰̸", uAe = "⊅", cAe = "⫆̸", fAe = "⊉", dAe = "⊃⃒", hAe = "⊉", pAe = "⫆̸", vAe = "≹", mAe = "Ñ", gAe = "ñ", yAe = "≸", bAe = "⋪", SAe = "⋬", wAe = "⋫", xAe = "⋭", kAe = "Ν", OAe = "ν", CAe = "#", TAe = "№", AAe = " ", EAe = "≍⃒", MAe = "⊬", RAe = "⊭", DAe = "⊮", PAe = "⊯", LAe = "≥⃒", IAe = ">⃒", _Ae = "⤄", NAe = "⧞", BAe = "⤂", FAe = "≤⃒", zAe = "<⃒", HAe = "⊴⃒", jAe = "⤃", WAe = "⊵⃒", $Ae = "∼⃒", UAe = "⤣", VAe = "↖", GAe = "⇖", YAe = "↖", qAe = "⤧", KAe = "Ó", XAe = "ó", JAe = "⊛", ZAe = "Ô", QAe = "ô", eEe = "⊚", tEe = "О", rEe = "о", nEe = "⊝", iEe = "Ő", aEe = "ő", oEe = "⨸", sEe = "⊙", lEe = "⦼", uEe = "Œ", cEe = "œ", fEe = "⦿", dEe = "𝔒", hEe = "𝔬", pEe = "˛", vEe = "Ò", mEe = "ò", gEe = "⧁", yEe = "⦵", bEe = "Ω", SEe = "∮", wEe = "↺", xEe = "⦾", kEe = "⦻", OEe = "‾", CEe = "⧀", TEe = "Ō", AEe = "ō", EEe = "Ω", MEe = "ω", REe = "Ο", DEe = "ο", PEe = "⦶", LEe = "⊖", IEe = "𝕆", _Ee = "𝕠", NEe = "⦷", BEe = "“", FEe = "‘", zEe = "⦹", HEe = "⊕", jEe = "↻", WEe = "⩔", $Ee = "∨", UEe = "⩝", VEe = "ℴ", GEe = "ℴ", YEe = "ª", qEe = "º", KEe = "⊶", XEe = "⩖", JEe = "⩗", ZEe = "⩛", QEe = "Ⓢ", eMe = "𝒪", tMe = "ℴ", rMe = "Ø", nMe = "ø", iMe = "⊘", aMe = "Õ", oMe = "õ", sMe = "⨶", lMe = "⨷", uMe = "⊗", cMe = "Ö", fMe = "ö", dMe = "⌽", hMe = "‾", pMe = "⏞", vMe = "⎴", mMe = "⏜", gMe = "¶", yMe = "∥", bMe = "∥", SMe = "⫳", wMe = "⫽", xMe = "∂", kMe = "∂", OMe = "П", CMe = "п", TMe = "%", AMe = ".", EMe = "‰", MMe = "⊥", RMe = "‱", DMe = "𝔓", PMe = "𝔭", LMe = "Φ", IMe = "φ", _Me = "ϕ", NMe = "ℳ", BMe = "☎", FMe = "Π", zMe = "π", HMe = "⋔", jMe = "ϖ", WMe = "ℏ", $Me = "ℎ", UMe = "ℏ", VMe = "⨣", GMe = "⊞", YMe = "⨢", qMe = "+", KMe = "∔", XMe = "⨥", JMe = "⩲", ZMe = "±", QMe = "±", eRe = "⨦", tRe = "⨧", rRe = "±", nRe = "ℌ", iRe = "⨕", aRe = "𝕡", oRe = "ℙ", sRe = "£", lRe = "⪷", uRe = "⪻", cRe = "≺", fRe = "≼", dRe = "⪷", hRe = "≺", pRe = "≼", vRe = "≺", mRe = "⪯", gRe = "≼", yRe = "≾", bRe = "⪯", SRe = "⪹", wRe = "⪵", xRe = "⋨", kRe = "⪯", ORe = "⪳", CRe = "≾", TRe = "′", ARe = "″", ERe = "ℙ", MRe = "⪹", RRe = "⪵", DRe = "⋨", PRe = "∏", LRe = "∏", IRe = "⌮", _Re = "⌒", NRe = "⌓", BRe = "∝", FRe = "∝", zRe = "∷", HRe = "∝", jRe = "≾", WRe = "⊰", $Re = "𝒫", URe = "𝓅", VRe = "Ψ", GRe = "ψ", YRe = " ", qRe = "𝔔", KRe = "𝔮", XRe = "⨌", JRe = "𝕢", ZRe = "ℚ", QRe = "⁗", eDe = "𝒬", tDe = "𝓆", rDe = "ℍ", nDe = "⨖", iDe = "?", aDe = "≟", oDe = '"', sDe = '"', lDe = "⇛", uDe = "∽̱", cDe = "Ŕ", fDe = "ŕ", dDe = "√", hDe = "⦳", pDe = "⟩", vDe = "⟫", mDe = "⦒", gDe = "⦥", yDe = "⟩", bDe = "»", SDe = "⥵", wDe = "⇥", xDe = "⤠", kDe = "⤳", ODe = "→", CDe = "↠", TDe = "⇒", ADe = "⤞", EDe = "↪", MDe = "↬", RDe = "⥅", DDe = "⥴", PDe = "⤖", LDe = "↣", IDe = "↝", _De = "⤚", NDe = "⤜", BDe = "∶", FDe = "ℚ", zDe = "⤍", HDe = "⤏", jDe = "⤐", WDe = "❳", $De = "}", UDe = "]", VDe = "⦌", GDe = "⦎", YDe = "⦐", qDe = "Ř", KDe = "ř", XDe = "Ŗ", JDe = "ŗ", ZDe = "⌉", QDe = "}", ePe = "Р", tPe = "р", rPe = "⤷", nPe = "⥩", iPe = "”", aPe = "”", oPe = "↳", sPe = "ℜ", lPe = "ℛ", uPe = "ℜ", cPe = "ℝ", fPe = "ℜ", dPe = "▭", hPe = "®", pPe = "®", vPe = "∋", mPe = "⇋", gPe = "⥯", yPe = "⥽", bPe = "⌋", SPe = "𝔯", wPe = "ℜ", xPe = "⥤", kPe = "⇁", OPe = "⇀", CPe = "⥬", TPe = "Ρ", APe = "ρ", EPe = "ϱ", MPe = "⟩", RPe = "⇥", DPe = "→", PPe = "→", LPe = "⇒", IPe = "⇄", _Pe = "↣", NPe = "⌉", BPe = "⟧", FPe = "⥝", zPe = "⥕", HPe = "⇂", jPe = "⌋", WPe = "⇁", $Pe = "⇀", UPe = "⇄", VPe = "⇌", GPe = "⇉", YPe = "↝", qPe = "↦", KPe = "⊢", XPe = "⥛", JPe = "⋌", ZPe = "⧐", QPe = "⊳", eLe = "⊵", tLe = "⥏", rLe = "⥜", nLe = "⥔", iLe = "↾", aLe = "⥓", oLe = "⇀", sLe = "˚", lLe = "≓", uLe = "⇄", cLe = "⇌", fLe = "‏", dLe = "⎱", hLe = "⎱", pLe = "⫮", vLe = "⟭", mLe = "⇾", gLe = "⟧", yLe = "⦆", bLe = "𝕣", SLe = "ℝ", wLe = "⨮", xLe = "⨵", kLe = "⥰", OLe = ")", CLe = "⦔", TLe = "⨒", ALe = "⇉", ELe = "⇛", MLe = "›", RLe = "𝓇", DLe = "ℛ", PLe = "↱", LLe = "↱", ILe = "]", _Le = "’", NLe = "’", BLe = "⋌", FLe = "⋊", zLe = "▹", HLe = "⊵", jLe = "▸", WLe = "⧎", $Le = "⧴", ULe = "⥨", VLe = "℞", GLe = "Ś", YLe = "ś", qLe = "‚", KLe = "⪸", XLe = "Š", JLe = "š", ZLe = "⪼", QLe = "≻", eIe = "≽", tIe = "⪰", rIe = "⪴", nIe = "Ş", iIe = "ş", aIe = "Ŝ", oIe = "ŝ", sIe = "⪺", lIe = "⪶", uIe = "⋩", cIe = "⨓", fIe = "≿", dIe = "С", hIe = "с", pIe = "⊡", vIe = "⋅", mIe = "⩦", gIe = "⤥", yIe = "↘", bIe = "⇘", SIe = "↘", wIe = "§", xIe = ";", kIe = "⤩", OIe = "∖", CIe = "∖", TIe = "✶", AIe = "𝔖", EIe = "𝔰", MIe = "⌢", RIe = "♯", DIe = "Щ", PIe = "щ", LIe = "Ш", IIe = "ш", _Ie = "↓", NIe = "←", BIe = "∣", FIe = "∥", zIe = "→", HIe = "↑", jIe = "­", WIe = "Σ", $Ie = "σ", UIe = "ς", VIe = "ς", GIe = "∼", YIe = "⩪", qIe = "≃", KIe = "≃", XIe = "⪞", JIe = "⪠", ZIe = "⪝", QIe = "⪟", e_e = "≆", t_e = "⨤", r_e = "⥲", n_e = "←", i_e = "∘", a_e = "∖", o_e = "⨳", s_e = "⧤", l_e = "∣", u_e = "⌣", c_e = "⪪", f_e = "⪬", d_e = "⪬︀", h_e = "Ь", p_e = "ь", v_e = "⌿", m_e = "⧄", g_e = "/", y_e = "𝕊", b_e = "𝕤", S_e = "♠", w_e = "♠", x_e = "∥", k_e = "⊓", O_e = "⊓︀", C_e = "⊔", T_e = "⊔︀", A_e = "√", E_e = "⊏", M_e = "⊑", R_e = "⊏", D_e = "⊑", P_e = "⊐", L_e = "⊒", I_e = "⊐", __e = "⊒", N_e = "□", B_e = "□", F_e = "⊓", z_e = "⊏", H_e = "⊑", j_e = "⊐", W_e = "⊒", $_e = "⊔", U_e = "▪", V_e = "□", G_e = "▪", Y_e = "→", q_e = "𝒮", K_e = "𝓈", X_e = "∖", J_e = "⌣", Z_e = "⋆", Q_e = "⋆", eNe = "☆", tNe = "★", rNe = "ϵ", nNe = "ϕ", iNe = "¯", aNe = "⊂", oNe = "⋐", sNe = "⪽", lNe = "⫅", uNe = "⊆", cNe = "⫃", fNe = "⫁", dNe = "⫋", hNe = "⊊", pNe = "⪿", vNe = "⥹", mNe = "⊂", gNe = "⋐", yNe = "⊆", bNe = "⫅", SNe = "⊆", wNe = "⊊", xNe = "⫋", kNe = "⫇", ONe = "⫕", CNe = "⫓", TNe = "⪸", ANe = "≻", ENe = "≽", MNe = "≻", RNe = "⪰", DNe = "≽", PNe = "≿", LNe = "⪰", INe = "⪺", _Ne = "⪶", NNe = "⋩", BNe = "≿", FNe = "∋", zNe = "∑", HNe = "∑", jNe = "♪", WNe = "¹", $Ne = "²", UNe = "³", VNe = "⊃", GNe = "⋑", YNe = "⪾", qNe = "⫘", KNe = "⫆", XNe = "⊇", JNe = "⫄", ZNe = "⊃", QNe = "⊇", eBe = "⟉", tBe = "⫗", rBe = "⥻", nBe = "⫂", iBe = "⫌", aBe = "⊋", oBe = "⫀", sBe = "⊃", lBe = "⋑", uBe = "⊇", cBe = "⫆", fBe = "⊋", dBe = "⫌", hBe = "⫈", pBe = "⫔", vBe = "⫖", mBe = "⤦", gBe = "↙", yBe = "⇙", bBe = "↙", SBe = "⤪", wBe = "ß", xBe = "	", kBe = "⌖", OBe = "Τ", CBe = "τ", TBe = "⎴", ABe = "Ť", EBe = "ť", MBe = "Ţ", RBe = "ţ", DBe = "Т", PBe = "т", LBe = "⃛", IBe = "⌕", _Be = "𝔗", NBe = "𝔱", BBe = "∴", FBe = "∴", zBe = "∴", HBe = "Θ", jBe = "θ", WBe = "ϑ", $Be = "ϑ", UBe = "≈", VBe = "∼", GBe = "  ", YBe = " ", qBe = " ", KBe = "≈", XBe = "∼", JBe = "Þ", ZBe = "þ", QBe = "˜", e2e = "∼", t2e = "≃", r2e = "≅", n2e = "≈", i2e = "⨱", a2e = "⊠", o2e = "×", s2e = "⨰", l2e = "∭", u2e = "⤨", c2e = "⌶", f2e = "⫱", d2e = "⊤", h2e = "𝕋", p2e = "𝕥", v2e = "⫚", m2e = "⤩", g2e = "‴", y2e = "™", b2e = "™", S2e = "▵", w2e = "▿", x2e = "◃", k2e = "⊴", O2e = "≜", C2e = "▹", T2e = "⊵", A2e = "◬", E2e = "≜", M2e = "⨺", R2e = "⃛", D2e = "⨹", P2e = "⧍", L2e = "⨻", I2e = "⏢", _2e = "𝒯", N2e = "𝓉", B2e = "Ц", F2e = "ц", z2e = "Ћ", H2e = "ћ", j2e = "Ŧ", W2e = "ŧ", $2e = "≬", U2e = "↞", V2e = "↠", G2e = "Ú", Y2e = "ú", q2e = "↑", K2e = "↟", X2e = "⇑", J2e = "⥉", Z2e = "Ў", Q2e = "ў", eFe = "Ŭ", tFe = "ŭ", rFe = "Û", nFe = "û", iFe = "У", aFe = "у", oFe = "⇅", sFe = "Ű", lFe = "ű", uFe = "⥮", cFe = "⥾", fFe = "𝔘", dFe = "𝔲", hFe = "Ù", pFe = "ù", vFe = "⥣", mFe = "↿", gFe = "↾", yFe = "▀", bFe = "⌜", SFe = "⌜", wFe = "⌏", xFe = "◸", kFe = "Ū", OFe = "ū", CFe = "¨", TFe = "_", AFe = "⏟", EFe = "⎵", MFe = "⏝", RFe = "⋃", DFe = "⊎", PFe = "Ų", LFe = "ų", IFe = "𝕌", _Fe = "𝕦", NFe = "⤒", BFe = "↑", FFe = "↑", zFe = "⇑", HFe = "⇅", jFe = "↕", WFe = "↕", $Fe = "⇕", UFe = "⥮", VFe = "↿", GFe = "↾", YFe = "⊎", qFe = "↖", KFe = "↗", XFe = "υ", JFe = "ϒ", ZFe = "ϒ", QFe = "Υ", eze = "υ", tze = "↥", rze = "⊥", nze = "⇈", ize = "⌝", aze = "⌝", oze = "⌎", sze = "Ů", lze = "ů", uze = "◹", cze = "𝒰", fze = "𝓊", dze = "⋰", hze = "Ũ", pze = "ũ", vze = "▵", mze = "▴", gze = "⇈", yze = "Ü", bze = "ü", Sze = "⦧", wze = "⦜", xze = "ϵ", kze = "ϰ", Oze = "∅", Cze = "ϕ", Tze = "ϖ", Aze = "∝", Eze = "↕", Mze = "⇕", Rze = "ϱ", Dze = "ς", Pze = "⊊︀", Lze = "⫋︀", Ize = "⊋︀", _ze = "⫌︀", Nze = "ϑ", Bze = "⊲", Fze = "⊳", zze = "⫨", Hze = "⫫", jze = "⫩", Wze = "В", $ze = "в", Uze = "⊢", Vze = "⊨", Gze = "⊩", Yze = "⊫", qze = "⫦", Kze = "⊻", Xze = "∨", Jze = "⋁", Zze = "≚", Qze = "⋮", eHe = "|", tHe = "‖", rHe = "|", nHe = "‖", iHe = "∣", aHe = "|", oHe = "❘", sHe = "≀", lHe = " ", uHe = "𝔙", cHe = "𝔳", fHe = "⊲", dHe = "⊂⃒", hHe = "⊃⃒", pHe = "𝕍", vHe = "𝕧", mHe = "∝", gHe = "⊳", yHe = "𝒱", bHe = "𝓋", SHe = "⫋︀", wHe = "⊊︀", xHe = "⫌︀", kHe = "⊋︀", OHe = "⊪", CHe = "⦚", THe = "Ŵ", AHe = "ŵ", EHe = "⩟", MHe = "∧", RHe = "⋀", DHe = "≙", PHe = "℘", LHe = "𝔚", IHe = "𝔴", _He = "𝕎", NHe = "𝕨", BHe = "℘", FHe = "≀", zHe = "≀", HHe = "𝒲", jHe = "𝓌", WHe = "⋂", $He = "◯", UHe = "⋃", VHe = "▽", GHe = "𝔛", YHe = "𝔵", qHe = "⟷", KHe = "⟺", XHe = "Ξ", JHe = "ξ", ZHe = "⟵", QHe = "⟸", eje = "⟼", tje = "⋻", rje = "⨀", nje = "𝕏", ije = "𝕩", aje = "⨁", oje = "⨂", sje = "⟶", lje = "⟹", uje = "𝒳", cje = "𝓍", fje = "⨆", dje = "⨄", hje = "△", pje = "⋁", vje = "⋀", mje = "Ý", gje = "ý", yje = "Я", bje = "я", Sje = "Ŷ", wje = "ŷ", xje = "Ы", kje = "ы", Oje = "¥", Cje = "𝔜", Tje = "𝔶", Aje = "Ї", Eje = "ї", Mje = "𝕐", Rje = "𝕪", Dje = "𝒴", Pje = "𝓎", Lje = "Ю", Ije = "ю", _je = "ÿ", Nje = "Ÿ", Bje = "Ź", Fje = "ź", zje = "Ž", Hje = "ž", jje = "З", Wje = "з", $je = "Ż", Uje = "ż", Vje = "ℨ", Gje = "​", Yje = "Ζ", qje = "ζ", Kje = "𝔷", Xje = "ℨ", Jje = "Ж", Zje = "ж", Qje = "⇝", e3e = "𝕫", t3e = "ℤ", r3e = "𝒵", n3e = "𝓏", i3e = "‍", a3e = "‌", M4 = {
  Aacute: $ae,
  aacute: Uae,
  Abreve: Vae,
  abreve: Gae,
  ac: Yae,
  acd: qae,
  acE: Kae,
  Acirc: Xae,
  acirc: Jae,
  acute: Zae,
  Acy: Qae,
  acy: eoe,
  AElig: toe,
  aelig: roe,
  af: noe,
  Afr: ioe,
  afr: aoe,
  Agrave: ooe,
  agrave: soe,
  alefsym: loe,
  aleph: uoe,
  Alpha: coe,
  alpha: foe,
  Amacr: doe,
  amacr: hoe,
  amalg: poe,
  amp: voe,
  AMP: moe,
  andand: goe,
  And: yoe,
  and: boe,
  andd: Soe,
  andslope: woe,
  andv: xoe,
  ang: koe,
  ange: Ooe,
  angle: Coe,
  angmsdaa: Toe,
  angmsdab: Aoe,
  angmsdac: Eoe,
  angmsdad: Moe,
  angmsdae: Roe,
  angmsdaf: Doe,
  angmsdag: Poe,
  angmsdah: Loe,
  angmsd: Ioe,
  angrt: _oe,
  angrtvb: Noe,
  angrtvbd: Boe,
  angsph: Foe,
  angst: zoe,
  angzarr: Hoe,
  Aogon: joe,
  aogon: Woe,
  Aopf: $oe,
  aopf: Uoe,
  apacir: Voe,
  ap: Goe,
  apE: Yoe,
  ape: qoe,
  apid: Koe,
  apos: Xoe,
  ApplyFunction: Joe,
  approx: Zoe,
  approxeq: Qoe,
  Aring: ese,
  aring: tse,
  Ascr: rse,
  ascr: nse,
  Assign: ise,
  ast: ase,
  asymp: ose,
  asympeq: sse,
  Atilde: lse,
  atilde: use,
  Auml: cse,
  auml: fse,
  awconint: dse,
  awint: hse,
  backcong: pse,
  backepsilon: vse,
  backprime: mse,
  backsim: gse,
  backsimeq: yse,
  Backslash: bse,
  Barv: Sse,
  barvee: wse,
  barwed: xse,
  Barwed: kse,
  barwedge: Ose,
  bbrk: Cse,
  bbrktbrk: Tse,
  bcong: Ase,
  Bcy: Ese,
  bcy: Mse,
  bdquo: Rse,
  becaus: Dse,
  because: Pse,
  Because: Lse,
  bemptyv: Ise,
  bepsi: _se,
  bernou: Nse,
  Bernoullis: Bse,
  Beta: Fse,
  beta: zse,
  beth: Hse,
  between: jse,
  Bfr: Wse,
  bfr: $se,
  bigcap: Use,
  bigcirc: Vse,
  bigcup: Gse,
  bigodot: Yse,
  bigoplus: qse,
  bigotimes: Kse,
  bigsqcup: Xse,
  bigstar: Jse,
  bigtriangledown: Zse,
  bigtriangleup: Qse,
  biguplus: ele,
  bigvee: tle,
  bigwedge: rle,
  bkarow: nle,
  blacklozenge: ile,
  blacksquare: ale,
  blacktriangle: ole,
  blacktriangledown: sle,
  blacktriangleleft: lle,
  blacktriangleright: ule,
  blank: cle,
  blk12: fle,
  blk14: dle,
  blk34: hle,
  block: ple,
  bne: vle,
  bnequiv: mle,
  bNot: gle,
  bnot: yle,
  Bopf: ble,
  bopf: Sle,
  bot: wle,
  bottom: xle,
  bowtie: kle,
  boxbox: Ole,
  boxdl: Cle,
  boxdL: Tle,
  boxDl: Ale,
  boxDL: Ele,
  boxdr: Mle,
  boxdR: Rle,
  boxDr: Dle,
  boxDR: Ple,
  boxh: Lle,
  boxH: Ile,
  boxhd: _le,
  boxHd: Nle,
  boxhD: Ble,
  boxHD: Fle,
  boxhu: zle,
  boxHu: Hle,
  boxhU: jle,
  boxHU: Wle,
  boxminus: $le,
  boxplus: Ule,
  boxtimes: Vle,
  boxul: Gle,
  boxuL: Yle,
  boxUl: qle,
  boxUL: Kle,
  boxur: Xle,
  boxuR: Jle,
  boxUr: Zle,
  boxUR: Qle,
  boxv: eue,
  boxV: tue,
  boxvh: rue,
  boxvH: nue,
  boxVh: iue,
  boxVH: aue,
  boxvl: oue,
  boxvL: sue,
  boxVl: lue,
  boxVL: uue,
  boxvr: cue,
  boxvR: fue,
  boxVr: due,
  boxVR: hue,
  bprime: pue,
  breve: vue,
  Breve: mue,
  brvbar: gue,
  bscr: yue,
  Bscr: bue,
  bsemi: Sue,
  bsim: wue,
  bsime: xue,
  bsolb: kue,
  bsol: Oue,
  bsolhsub: Cue,
  bull: Tue,
  bullet: Aue,
  bump: Eue,
  bumpE: Mue,
  bumpe: Rue,
  Bumpeq: Due,
  bumpeq: Pue,
  Cacute: Lue,
  cacute: Iue,
  capand: _ue,
  capbrcup: Nue,
  capcap: Bue,
  cap: Fue,
  Cap: zue,
  capcup: Hue,
  capdot: jue,
  CapitalDifferentialD: Wue,
  caps: $ue,
  caret: Uue,
  caron: Vue,
  Cayleys: Gue,
  ccaps: Yue,
  Ccaron: que,
  ccaron: Kue,
  Ccedil: Xue,
  ccedil: Jue,
  Ccirc: Zue,
  ccirc: Que,
  Cconint: ece,
  ccups: tce,
  ccupssm: rce,
  Cdot: nce,
  cdot: ice,
  cedil: ace,
  Cedilla: oce,
  cemptyv: sce,
  cent: lce,
  centerdot: uce,
  CenterDot: cce,
  cfr: fce,
  Cfr: dce,
  CHcy: hce,
  chcy: pce,
  check: vce,
  checkmark: mce,
  Chi: gce,
  chi: yce,
  circ: bce,
  circeq: Sce,
  circlearrowleft: wce,
  circlearrowright: xce,
  circledast: kce,
  circledcirc: Oce,
  circleddash: Cce,
  CircleDot: Tce,
  circledR: Ace,
  circledS: Ece,
  CircleMinus: Mce,
  CirclePlus: Rce,
  CircleTimes: Dce,
  cir: Pce,
  cirE: Lce,
  cire: Ice,
  cirfnint: _ce,
  cirmid: Nce,
  cirscir: Bce,
  ClockwiseContourIntegral: Fce,
  CloseCurlyDoubleQuote: zce,
  CloseCurlyQuote: Hce,
  clubs: jce,
  clubsuit: Wce,
  colon: $ce,
  Colon: Uce,
  Colone: Vce,
  colone: Gce,
  coloneq: Yce,
  comma: qce,
  commat: Kce,
  comp: Xce,
  compfn: Jce,
  complement: Zce,
  complexes: Qce,
  cong: efe,
  congdot: tfe,
  Congruent: rfe,
  conint: nfe,
  Conint: ife,
  ContourIntegral: afe,
  copf: ofe,
  Copf: sfe,
  coprod: lfe,
  Coproduct: ufe,
  copy: cfe,
  COPY: ffe,
  copysr: dfe,
  CounterClockwiseContourIntegral: hfe,
  crarr: pfe,
  cross: vfe,
  Cross: mfe,
  Cscr: gfe,
  cscr: yfe,
  csub: bfe,
  csube: Sfe,
  csup: wfe,
  csupe: xfe,
  ctdot: kfe,
  cudarrl: Ofe,
  cudarrr: Cfe,
  cuepr: Tfe,
  cuesc: Afe,
  cularr: Efe,
  cularrp: Mfe,
  cupbrcap: Rfe,
  cupcap: Dfe,
  CupCap: Pfe,
  cup: Lfe,
  Cup: Ife,
  cupcup: _fe,
  cupdot: Nfe,
  cupor: Bfe,
  cups: Ffe,
  curarr: zfe,
  curarrm: Hfe,
  curlyeqprec: jfe,
  curlyeqsucc: Wfe,
  curlyvee: $fe,
  curlywedge: Ufe,
  curren: Vfe,
  curvearrowleft: Gfe,
  curvearrowright: Yfe,
  cuvee: qfe,
  cuwed: Kfe,
  cwconint: Xfe,
  cwint: Jfe,
  cylcty: Zfe,
  dagger: Qfe,
  Dagger: ede,
  daleth: tde,
  darr: rde,
  Darr: nde,
  dArr: ide,
  dash: ade,
  Dashv: ode,
  dashv: sde,
  dbkarow: lde,
  dblac: ude,
  Dcaron: cde,
  dcaron: fde,
  Dcy: dde,
  dcy: hde,
  ddagger: pde,
  ddarr: vde,
  DD: mde,
  dd: gde,
  DDotrahd: yde,
  ddotseq: bde,
  deg: Sde,
  Del: wde,
  Delta: xde,
  delta: kde,
  demptyv: Ode,
  dfisht: Cde,
  Dfr: Tde,
  dfr: Ade,
  dHar: Ede,
  dharl: Mde,
  dharr: Rde,
  DiacriticalAcute: Dde,
  DiacriticalDot: Pde,
  DiacriticalDoubleAcute: Lde,
  DiacriticalGrave: Ide,
  DiacriticalTilde: _de,
  diam: Nde,
  diamond: Bde,
  Diamond: Fde,
  diamondsuit: zde,
  diams: Hde,
  die: jde,
  DifferentialD: Wde,
  digamma: $de,
  disin: Ude,
  div: Vde,
  divide: Gde,
  divideontimes: Yde,
  divonx: qde,
  DJcy: Kde,
  djcy: Xde,
  dlcorn: Jde,
  dlcrop: Zde,
  dollar: Qde,
  Dopf: ehe,
  dopf: the,
  Dot: rhe,
  dot: nhe,
  DotDot: ihe,
  doteq: ahe,
  doteqdot: ohe,
  DotEqual: she,
  dotminus: lhe,
  dotplus: uhe,
  dotsquare: che,
  doublebarwedge: fhe,
  DoubleContourIntegral: dhe,
  DoubleDot: hhe,
  DoubleDownArrow: phe,
  DoubleLeftArrow: vhe,
  DoubleLeftRightArrow: mhe,
  DoubleLeftTee: ghe,
  DoubleLongLeftArrow: yhe,
  DoubleLongLeftRightArrow: bhe,
  DoubleLongRightArrow: She,
  DoubleRightArrow: whe,
  DoubleRightTee: xhe,
  DoubleUpArrow: khe,
  DoubleUpDownArrow: Ohe,
  DoubleVerticalBar: Che,
  DownArrowBar: The,
  downarrow: Ahe,
  DownArrow: Ehe,
  Downarrow: Mhe,
  DownArrowUpArrow: Rhe,
  DownBreve: Dhe,
  downdownarrows: Phe,
  downharpoonleft: Lhe,
  downharpoonright: Ihe,
  DownLeftRightVector: _he,
  DownLeftTeeVector: Nhe,
  DownLeftVectorBar: Bhe,
  DownLeftVector: Fhe,
  DownRightTeeVector: zhe,
  DownRightVectorBar: Hhe,
  DownRightVector: jhe,
  DownTeeArrow: Whe,
  DownTee: $he,
  drbkarow: Uhe,
  drcorn: Vhe,
  drcrop: Ghe,
  Dscr: Yhe,
  dscr: qhe,
  DScy: Khe,
  dscy: Xhe,
  dsol: Jhe,
  Dstrok: Zhe,
  dstrok: Qhe,
  dtdot: epe,
  dtri: tpe,
  dtrif: rpe,
  duarr: npe,
  duhar: ipe,
  dwangle: ape,
  DZcy: ope,
  dzcy: spe,
  dzigrarr: lpe,
  Eacute: upe,
  eacute: cpe,
  easter: fpe,
  Ecaron: dpe,
  ecaron: hpe,
  Ecirc: ppe,
  ecirc: vpe,
  ecir: mpe,
  ecolon: gpe,
  Ecy: ype,
  ecy: bpe,
  eDDot: Spe,
  Edot: wpe,
  edot: xpe,
  eDot: kpe,
  ee: Ope,
  efDot: Cpe,
  Efr: Tpe,
  efr: Ape,
  eg: Epe,
  Egrave: Mpe,
  egrave: Rpe,
  egs: Dpe,
  egsdot: Ppe,
  el: Lpe,
  Element: Ipe,
  elinters: _pe,
  ell: Npe,
  els: Bpe,
  elsdot: Fpe,
  Emacr: zpe,
  emacr: Hpe,
  empty: jpe,
  emptyset: Wpe,
  EmptySmallSquare: $pe,
  emptyv: Upe,
  EmptyVerySmallSquare: Vpe,
  emsp13: Gpe,
  emsp14: Ype,
  emsp: qpe,
  ENG: Kpe,
  eng: Xpe,
  ensp: Jpe,
  Eogon: Zpe,
  eogon: Qpe,
  Eopf: eve,
  eopf: tve,
  epar: rve,
  eparsl: nve,
  eplus: ive,
  epsi: ave,
  Epsilon: ove,
  epsilon: sve,
  epsiv: lve,
  eqcirc: uve,
  eqcolon: cve,
  eqsim: fve,
  eqslantgtr: dve,
  eqslantless: hve,
  Equal: pve,
  equals: vve,
  EqualTilde: mve,
  equest: gve,
  Equilibrium: yve,
  equiv: bve,
  equivDD: Sve,
  eqvparsl: wve,
  erarr: xve,
  erDot: kve,
  escr: Ove,
  Escr: Cve,
  esdot: Tve,
  Esim: Ave,
  esim: Eve,
  Eta: Mve,
  eta: Rve,
  ETH: Dve,
  eth: Pve,
  Euml: Lve,
  euml: Ive,
  euro: _ve,
  excl: Nve,
  exist: Bve,
  Exists: Fve,
  expectation: zve,
  exponentiale: Hve,
  ExponentialE: jve,
  fallingdotseq: Wve,
  Fcy: $ve,
  fcy: Uve,
  female: Vve,
  ffilig: Gve,
  fflig: Yve,
  ffllig: qve,
  Ffr: Kve,
  ffr: Xve,
  filig: Jve,
  FilledSmallSquare: Zve,
  FilledVerySmallSquare: Qve,
  fjlig: eme,
  flat: tme,
  fllig: rme,
  fltns: nme,
  fnof: ime,
  Fopf: ame,
  fopf: ome,
  forall: sme,
  ForAll: lme,
  fork: ume,
  forkv: cme,
  Fouriertrf: fme,
  fpartint: dme,
  frac12: hme,
  frac13: pme,
  frac14: vme,
  frac15: mme,
  frac16: gme,
  frac18: yme,
  frac23: bme,
  frac25: Sme,
  frac34: wme,
  frac35: xme,
  frac38: kme,
  frac45: Ome,
  frac56: Cme,
  frac58: Tme,
  frac78: Ame,
  frasl: Eme,
  frown: Mme,
  fscr: Rme,
  Fscr: Dme,
  gacute: Pme,
  Gamma: Lme,
  gamma: Ime,
  Gammad: _me,
  gammad: Nme,
  gap: Bme,
  Gbreve: Fme,
  gbreve: zme,
  Gcedil: Hme,
  Gcirc: jme,
  gcirc: Wme,
  Gcy: $me,
  gcy: Ume,
  Gdot: Vme,
  gdot: Gme,
  ge: Yme,
  gE: qme,
  gEl: Kme,
  gel: Xme,
  geq: Jme,
  geqq: Zme,
  geqslant: Qme,
  gescc: ege,
  ges: tge,
  gesdot: rge,
  gesdoto: nge,
  gesdotol: ige,
  gesl: age,
  gesles: oge,
  Gfr: sge,
  gfr: lge,
  gg: uge,
  Gg: cge,
  ggg: fge,
  gimel: dge,
  GJcy: hge,
  gjcy: pge,
  gla: vge,
  gl: mge,
  glE: gge,
  glj: yge,
  gnap: bge,
  gnapprox: Sge,
  gne: wge,
  gnE: xge,
  gneq: kge,
  gneqq: Oge,
  gnsim: Cge,
  Gopf: Tge,
  gopf: Age,
  grave: Ege,
  GreaterEqual: Mge,
  GreaterEqualLess: Rge,
  GreaterFullEqual: Dge,
  GreaterGreater: Pge,
  GreaterLess: Lge,
  GreaterSlantEqual: Ige,
  GreaterTilde: _ge,
  Gscr: Nge,
  gscr: Bge,
  gsim: Fge,
  gsime: zge,
  gsiml: Hge,
  gtcc: jge,
  gtcir: Wge,
  gt: $ge,
  GT: Uge,
  Gt: Vge,
  gtdot: Gge,
  gtlPar: Yge,
  gtquest: qge,
  gtrapprox: Kge,
  gtrarr: Xge,
  gtrdot: Jge,
  gtreqless: Zge,
  gtreqqless: Qge,
  gtrless: eye,
  gtrsim: tye,
  gvertneqq: rye,
  gvnE: nye,
  Hacek: iye,
  hairsp: aye,
  half: oye,
  hamilt: sye,
  HARDcy: lye,
  hardcy: uye,
  harrcir: cye,
  harr: fye,
  hArr: dye,
  harrw: hye,
  Hat: pye,
  hbar: vye,
  Hcirc: mye,
  hcirc: gye,
  hearts: yye,
  heartsuit: bye,
  hellip: Sye,
  hercon: wye,
  hfr: xye,
  Hfr: kye,
  HilbertSpace: Oye,
  hksearow: Cye,
  hkswarow: Tye,
  hoarr: Aye,
  homtht: Eye,
  hookleftarrow: Mye,
  hookrightarrow: Rye,
  hopf: Dye,
  Hopf: Pye,
  horbar: Lye,
  HorizontalLine: Iye,
  hscr: _ye,
  Hscr: Nye,
  hslash: Bye,
  Hstrok: Fye,
  hstrok: zye,
  HumpDownHump: Hye,
  HumpEqual: jye,
  hybull: Wye,
  hyphen: $ye,
  Iacute: Uye,
  iacute: Vye,
  ic: Gye,
  Icirc: Yye,
  icirc: qye,
  Icy: Kye,
  icy: Xye,
  Idot: Jye,
  IEcy: Zye,
  iecy: Qye,
  iexcl: ebe,
  iff: tbe,
  ifr: rbe,
  Ifr: nbe,
  Igrave: ibe,
  igrave: abe,
  ii: obe,
  iiiint: sbe,
  iiint: lbe,
  iinfin: ube,
  iiota: cbe,
  IJlig: fbe,
  ijlig: dbe,
  Imacr: hbe,
  imacr: pbe,
  image: vbe,
  ImaginaryI: mbe,
  imagline: gbe,
  imagpart: ybe,
  imath: bbe,
  Im: Sbe,
  imof: wbe,
  imped: xbe,
  Implies: kbe,
  incare: Obe,
  in: "∈",
  infin: Cbe,
  infintie: Tbe,
  inodot: Abe,
  intcal: Ebe,
  int: Mbe,
  Int: Rbe,
  integers: Dbe,
  Integral: Pbe,
  intercal: Lbe,
  Intersection: Ibe,
  intlarhk: _be,
  intprod: Nbe,
  InvisibleComma: Bbe,
  InvisibleTimes: Fbe,
  IOcy: zbe,
  iocy: Hbe,
  Iogon: jbe,
  iogon: Wbe,
  Iopf: $be,
  iopf: Ube,
  Iota: Vbe,
  iota: Gbe,
  iprod: Ybe,
  iquest: qbe,
  iscr: Kbe,
  Iscr: Xbe,
  isin: Jbe,
  isindot: Zbe,
  isinE: Qbe,
  isins: e0e,
  isinsv: t0e,
  isinv: r0e,
  it: n0e,
  Itilde: i0e,
  itilde: a0e,
  Iukcy: o0e,
  iukcy: s0e,
  Iuml: l0e,
  iuml: u0e,
  Jcirc: c0e,
  jcirc: f0e,
  Jcy: d0e,
  jcy: h0e,
  Jfr: p0e,
  jfr: v0e,
  jmath: m0e,
  Jopf: g0e,
  jopf: y0e,
  Jscr: b0e,
  jscr: S0e,
  Jsercy: w0e,
  jsercy: x0e,
  Jukcy: k0e,
  jukcy: O0e,
  Kappa: C0e,
  kappa: T0e,
  kappav: A0e,
  Kcedil: E0e,
  kcedil: M0e,
  Kcy: R0e,
  kcy: D0e,
  Kfr: P0e,
  kfr: L0e,
  kgreen: I0e,
  KHcy: _0e,
  khcy: N0e,
  KJcy: B0e,
  kjcy: F0e,
  Kopf: z0e,
  kopf: H0e,
  Kscr: j0e,
  kscr: W0e,
  lAarr: $0e,
  Lacute: U0e,
  lacute: V0e,
  laemptyv: G0e,
  lagran: Y0e,
  Lambda: q0e,
  lambda: K0e,
  lang: X0e,
  Lang: J0e,
  langd: Z0e,
  langle: Q0e,
  lap: eSe,
  Laplacetrf: tSe,
  laquo: rSe,
  larrb: nSe,
  larrbfs: iSe,
  larr: aSe,
  Larr: oSe,
  lArr: sSe,
  larrfs: lSe,
  larrhk: uSe,
  larrlp: cSe,
  larrpl: fSe,
  larrsim: dSe,
  larrtl: hSe,
  latail: pSe,
  lAtail: vSe,
  lat: mSe,
  late: gSe,
  lates: ySe,
  lbarr: bSe,
  lBarr: SSe,
  lbbrk: wSe,
  lbrace: xSe,
  lbrack: kSe,
  lbrke: OSe,
  lbrksld: CSe,
  lbrkslu: TSe,
  Lcaron: ASe,
  lcaron: ESe,
  Lcedil: MSe,
  lcedil: RSe,
  lceil: DSe,
  lcub: PSe,
  Lcy: LSe,
  lcy: ISe,
  ldca: _Se,
  ldquo: NSe,
  ldquor: BSe,
  ldrdhar: FSe,
  ldrushar: zSe,
  ldsh: HSe,
  le: jSe,
  lE: WSe,
  LeftAngleBracket: $Se,
  LeftArrowBar: USe,
  leftarrow: VSe,
  LeftArrow: GSe,
  Leftarrow: YSe,
  LeftArrowRightArrow: qSe,
  leftarrowtail: KSe,
  LeftCeiling: XSe,
  LeftDoubleBracket: JSe,
  LeftDownTeeVector: ZSe,
  LeftDownVectorBar: QSe,
  LeftDownVector: ewe,
  LeftFloor: twe,
  leftharpoondown: rwe,
  leftharpoonup: nwe,
  leftleftarrows: iwe,
  leftrightarrow: awe,
  LeftRightArrow: owe,
  Leftrightarrow: swe,
  leftrightarrows: lwe,
  leftrightharpoons: uwe,
  leftrightsquigarrow: cwe,
  LeftRightVector: fwe,
  LeftTeeArrow: dwe,
  LeftTee: hwe,
  LeftTeeVector: pwe,
  leftthreetimes: vwe,
  LeftTriangleBar: mwe,
  LeftTriangle: gwe,
  LeftTriangleEqual: ywe,
  LeftUpDownVector: bwe,
  LeftUpTeeVector: Swe,
  LeftUpVectorBar: wwe,
  LeftUpVector: xwe,
  LeftVectorBar: kwe,
  LeftVector: Owe,
  lEg: Cwe,
  leg: Twe,
  leq: Awe,
  leqq: Ewe,
  leqslant: Mwe,
  lescc: Rwe,
  les: Dwe,
  lesdot: Pwe,
  lesdoto: Lwe,
  lesdotor: Iwe,
  lesg: _we,
  lesges: Nwe,
  lessapprox: Bwe,
  lessdot: Fwe,
  lesseqgtr: zwe,
  lesseqqgtr: Hwe,
  LessEqualGreater: jwe,
  LessFullEqual: Wwe,
  LessGreater: $we,
  lessgtr: Uwe,
  LessLess: Vwe,
  lesssim: Gwe,
  LessSlantEqual: Ywe,
  LessTilde: qwe,
  lfisht: Kwe,
  lfloor: Xwe,
  Lfr: Jwe,
  lfr: Zwe,
  lg: Qwe,
  lgE: exe,
  lHar: txe,
  lhard: rxe,
  lharu: nxe,
  lharul: ixe,
  lhblk: axe,
  LJcy: oxe,
  ljcy: sxe,
  llarr: lxe,
  ll: uxe,
  Ll: cxe,
  llcorner: fxe,
  Lleftarrow: dxe,
  llhard: hxe,
  lltri: pxe,
  Lmidot: vxe,
  lmidot: mxe,
  lmoustache: gxe,
  lmoust: yxe,
  lnap: bxe,
  lnapprox: Sxe,
  lne: wxe,
  lnE: xxe,
  lneq: kxe,
  lneqq: Oxe,
  lnsim: Cxe,
  loang: Txe,
  loarr: Axe,
  lobrk: Exe,
  longleftarrow: Mxe,
  LongLeftArrow: Rxe,
  Longleftarrow: Dxe,
  longleftrightarrow: Pxe,
  LongLeftRightArrow: Lxe,
  Longleftrightarrow: Ixe,
  longmapsto: _xe,
  longrightarrow: Nxe,
  LongRightArrow: Bxe,
  Longrightarrow: Fxe,
  looparrowleft: zxe,
  looparrowright: Hxe,
  lopar: jxe,
  Lopf: Wxe,
  lopf: $xe,
  loplus: Uxe,
  lotimes: Vxe,
  lowast: Gxe,
  lowbar: Yxe,
  LowerLeftArrow: qxe,
  LowerRightArrow: Kxe,
  loz: Xxe,
  lozenge: Jxe,
  lozf: Zxe,
  lpar: Qxe,
  lparlt: eke,
  lrarr: tke,
  lrcorner: rke,
  lrhar: nke,
  lrhard: ike,
  lrm: ake,
  lrtri: oke,
  lsaquo: ske,
  lscr: lke,
  Lscr: uke,
  lsh: cke,
  Lsh: fke,
  lsim: dke,
  lsime: hke,
  lsimg: pke,
  lsqb: vke,
  lsquo: mke,
  lsquor: gke,
  Lstrok: yke,
  lstrok: bke,
  ltcc: Ske,
  ltcir: wke,
  lt: xke,
  LT: kke,
  Lt: Oke,
  ltdot: Cke,
  lthree: Tke,
  ltimes: Ake,
  ltlarr: Eke,
  ltquest: Mke,
  ltri: Rke,
  ltrie: Dke,
  ltrif: Pke,
  ltrPar: Lke,
  lurdshar: Ike,
  luruhar: _ke,
  lvertneqq: Nke,
  lvnE: Bke,
  macr: Fke,
  male: zke,
  malt: Hke,
  maltese: jke,
  Map: "⤅",
  map: Wke,
  mapsto: $ke,
  mapstodown: Uke,
  mapstoleft: Vke,
  mapstoup: Gke,
  marker: Yke,
  mcomma: qke,
  Mcy: Kke,
  mcy: Xke,
  mdash: Jke,
  mDDot: Zke,
  measuredangle: Qke,
  MediumSpace: eOe,
  Mellintrf: tOe,
  Mfr: rOe,
  mfr: nOe,
  mho: iOe,
  micro: aOe,
  midast: oOe,
  midcir: sOe,
  mid: lOe,
  middot: uOe,
  minusb: cOe,
  minus: fOe,
  minusd: dOe,
  minusdu: hOe,
  MinusPlus: pOe,
  mlcp: vOe,
  mldr: mOe,
  mnplus: gOe,
  models: yOe,
  Mopf: bOe,
  mopf: SOe,
  mp: wOe,
  mscr: xOe,
  Mscr: kOe,
  mstpos: OOe,
  Mu: COe,
  mu: TOe,
  multimap: AOe,
  mumap: EOe,
  nabla: MOe,
  Nacute: ROe,
  nacute: DOe,
  nang: POe,
  nap: LOe,
  napE: IOe,
  napid: _Oe,
  napos: NOe,
  napprox: BOe,
  natural: FOe,
  naturals: zOe,
  natur: HOe,
  nbsp: jOe,
  nbump: WOe,
  nbumpe: $Oe,
  ncap: UOe,
  Ncaron: VOe,
  ncaron: GOe,
  Ncedil: YOe,
  ncedil: qOe,
  ncong: KOe,
  ncongdot: XOe,
  ncup: JOe,
  Ncy: ZOe,
  ncy: QOe,
  ndash: eCe,
  nearhk: tCe,
  nearr: rCe,
  neArr: nCe,
  nearrow: iCe,
  ne: aCe,
  nedot: oCe,
  NegativeMediumSpace: sCe,
  NegativeThickSpace: lCe,
  NegativeThinSpace: uCe,
  NegativeVeryThinSpace: cCe,
  nequiv: fCe,
  nesear: dCe,
  nesim: hCe,
  NestedGreaterGreater: pCe,
  NestedLessLess: vCe,
  NewLine: mCe,
  nexist: gCe,
  nexists: yCe,
  Nfr: bCe,
  nfr: SCe,
  ngE: wCe,
  nge: xCe,
  ngeq: kCe,
  ngeqq: OCe,
  ngeqslant: CCe,
  nges: TCe,
  nGg: ACe,
  ngsim: ECe,
  nGt: MCe,
  ngt: RCe,
  ngtr: DCe,
  nGtv: PCe,
  nharr: LCe,
  nhArr: ICe,
  nhpar: _Ce,
  ni: NCe,
  nis: BCe,
  nisd: FCe,
  niv: zCe,
  NJcy: HCe,
  njcy: jCe,
  nlarr: WCe,
  nlArr: $Ce,
  nldr: UCe,
  nlE: VCe,
  nle: GCe,
  nleftarrow: YCe,
  nLeftarrow: qCe,
  nleftrightarrow: KCe,
  nLeftrightarrow: XCe,
  nleq: JCe,
  nleqq: ZCe,
  nleqslant: QCe,
  nles: e1e,
  nless: t1e,
  nLl: r1e,
  nlsim: n1e,
  nLt: i1e,
  nlt: a1e,
  nltri: o1e,
  nltrie: s1e,
  nLtv: l1e,
  nmid: u1e,
  NoBreak: c1e,
  NonBreakingSpace: f1e,
  nopf: d1e,
  Nopf: h1e,
  Not: p1e,
  not: v1e,
  NotCongruent: m1e,
  NotCupCap: g1e,
  NotDoubleVerticalBar: y1e,
  NotElement: b1e,
  NotEqual: S1e,
  NotEqualTilde: w1e,
  NotExists: x1e,
  NotGreater: k1e,
  NotGreaterEqual: O1e,
  NotGreaterFullEqual: C1e,
  NotGreaterGreater: T1e,
  NotGreaterLess: A1e,
  NotGreaterSlantEqual: E1e,
  NotGreaterTilde: M1e,
  NotHumpDownHump: R1e,
  NotHumpEqual: D1e,
  notin: P1e,
  notindot: L1e,
  notinE: I1e,
  notinva: _1e,
  notinvb: N1e,
  notinvc: B1e,
  NotLeftTriangleBar: F1e,
  NotLeftTriangle: z1e,
  NotLeftTriangleEqual: H1e,
  NotLess: j1e,
  NotLessEqual: W1e,
  NotLessGreater: $1e,
  NotLessLess: U1e,
  NotLessSlantEqual: V1e,
  NotLessTilde: G1e,
  NotNestedGreaterGreater: Y1e,
  NotNestedLessLess: q1e,
  notni: K1e,
  notniva: X1e,
  notnivb: J1e,
  notnivc: Z1e,
  NotPrecedes: Q1e,
  NotPrecedesEqual: eTe,
  NotPrecedesSlantEqual: tTe,
  NotReverseElement: rTe,
  NotRightTriangleBar: nTe,
  NotRightTriangle: iTe,
  NotRightTriangleEqual: aTe,
  NotSquareSubset: oTe,
  NotSquareSubsetEqual: sTe,
  NotSquareSuperset: lTe,
  NotSquareSupersetEqual: uTe,
  NotSubset: cTe,
  NotSubsetEqual: fTe,
  NotSucceeds: dTe,
  NotSucceedsEqual: hTe,
  NotSucceedsSlantEqual: pTe,
  NotSucceedsTilde: vTe,
  NotSuperset: mTe,
  NotSupersetEqual: gTe,
  NotTilde: yTe,
  NotTildeEqual: bTe,
  NotTildeFullEqual: STe,
  NotTildeTilde: wTe,
  NotVerticalBar: xTe,
  nparallel: kTe,
  npar: OTe,
  nparsl: CTe,
  npart: TTe,
  npolint: ATe,
  npr: ETe,
  nprcue: MTe,
  nprec: RTe,
  npreceq: DTe,
  npre: PTe,
  nrarrc: LTe,
  nrarr: ITe,
  nrArr: _Te,
  nrarrw: NTe,
  nrightarrow: BTe,
  nRightarrow: FTe,
  nrtri: zTe,
  nrtrie: HTe,
  nsc: jTe,
  nsccue: WTe,
  nsce: $Te,
  Nscr: UTe,
  nscr: VTe,
  nshortmid: GTe,
  nshortparallel: YTe,
  nsim: qTe,
  nsime: KTe,
  nsimeq: XTe,
  nsmid: JTe,
  nspar: ZTe,
  nsqsube: QTe,
  nsqsupe: eAe,
  nsub: tAe,
  nsubE: rAe,
  nsube: nAe,
  nsubset: iAe,
  nsubseteq: aAe,
  nsubseteqq: oAe,
  nsucc: sAe,
  nsucceq: lAe,
  nsup: uAe,
  nsupE: cAe,
  nsupe: fAe,
  nsupset: dAe,
  nsupseteq: hAe,
  nsupseteqq: pAe,
  ntgl: vAe,
  Ntilde: mAe,
  ntilde: gAe,
  ntlg: yAe,
  ntriangleleft: bAe,
  ntrianglelefteq: SAe,
  ntriangleright: wAe,
  ntrianglerighteq: xAe,
  Nu: kAe,
  nu: OAe,
  num: CAe,
  numero: TAe,
  numsp: AAe,
  nvap: EAe,
  nvdash: MAe,
  nvDash: RAe,
  nVdash: DAe,
  nVDash: PAe,
  nvge: LAe,
  nvgt: IAe,
  nvHarr: _Ae,
  nvinfin: NAe,
  nvlArr: BAe,
  nvle: FAe,
  nvlt: zAe,
  nvltrie: HAe,
  nvrArr: jAe,
  nvrtrie: WAe,
  nvsim: $Ae,
  nwarhk: UAe,
  nwarr: VAe,
  nwArr: GAe,
  nwarrow: YAe,
  nwnear: qAe,
  Oacute: KAe,
  oacute: XAe,
  oast: JAe,
  Ocirc: ZAe,
  ocirc: QAe,
  ocir: eEe,
  Ocy: tEe,
  ocy: rEe,
  odash: nEe,
  Odblac: iEe,
  odblac: aEe,
  odiv: oEe,
  odot: sEe,
  odsold: lEe,
  OElig: uEe,
  oelig: cEe,
  ofcir: fEe,
  Ofr: dEe,
  ofr: hEe,
  ogon: pEe,
  Ograve: vEe,
  ograve: mEe,
  ogt: gEe,
  ohbar: yEe,
  ohm: bEe,
  oint: SEe,
  olarr: wEe,
  olcir: xEe,
  olcross: kEe,
  oline: OEe,
  olt: CEe,
  Omacr: TEe,
  omacr: AEe,
  Omega: EEe,
  omega: MEe,
  Omicron: REe,
  omicron: DEe,
  omid: PEe,
  ominus: LEe,
  Oopf: IEe,
  oopf: _Ee,
  opar: NEe,
  OpenCurlyDoubleQuote: BEe,
  OpenCurlyQuote: FEe,
  operp: zEe,
  oplus: HEe,
  orarr: jEe,
  Or: WEe,
  or: $Ee,
  ord: UEe,
  order: VEe,
  orderof: GEe,
  ordf: YEe,
  ordm: qEe,
  origof: KEe,
  oror: XEe,
  orslope: JEe,
  orv: ZEe,
  oS: QEe,
  Oscr: eMe,
  oscr: tMe,
  Oslash: rMe,
  oslash: nMe,
  osol: iMe,
  Otilde: aMe,
  otilde: oMe,
  otimesas: sMe,
  Otimes: lMe,
  otimes: uMe,
  Ouml: cMe,
  ouml: fMe,
  ovbar: dMe,
  OverBar: hMe,
  OverBrace: pMe,
  OverBracket: vMe,
  OverParenthesis: mMe,
  para: gMe,
  parallel: yMe,
  par: bMe,
  parsim: SMe,
  parsl: wMe,
  part: xMe,
  PartialD: kMe,
  Pcy: OMe,
  pcy: CMe,
  percnt: TMe,
  period: AMe,
  permil: EMe,
  perp: MMe,
  pertenk: RMe,
  Pfr: DMe,
  pfr: PMe,
  Phi: LMe,
  phi: IMe,
  phiv: _Me,
  phmmat: NMe,
  phone: BMe,
  Pi: FMe,
  pi: zMe,
  pitchfork: HMe,
  piv: jMe,
  planck: WMe,
  planckh: $Me,
  plankv: UMe,
  plusacir: VMe,
  plusb: GMe,
  pluscir: YMe,
  plus: qMe,
  plusdo: KMe,
  plusdu: XMe,
  pluse: JMe,
  PlusMinus: ZMe,
  plusmn: QMe,
  plussim: eRe,
  plustwo: tRe,
  pm: rRe,
  Poincareplane: nRe,
  pointint: iRe,
  popf: aRe,
  Popf: oRe,
  pound: sRe,
  prap: lRe,
  Pr: uRe,
  pr: cRe,
  prcue: fRe,
  precapprox: dRe,
  prec: hRe,
  preccurlyeq: pRe,
  Precedes: vRe,
  PrecedesEqual: mRe,
  PrecedesSlantEqual: gRe,
  PrecedesTilde: yRe,
  preceq: bRe,
  precnapprox: SRe,
  precneqq: wRe,
  precnsim: xRe,
  pre: kRe,
  prE: ORe,
  precsim: CRe,
  prime: TRe,
  Prime: ARe,
  primes: ERe,
  prnap: MRe,
  prnE: RRe,
  prnsim: DRe,
  prod: PRe,
  Product: LRe,
  profalar: IRe,
  profline: _Re,
  profsurf: NRe,
  prop: BRe,
  Proportional: FRe,
  Proportion: zRe,
  propto: HRe,
  prsim: jRe,
  prurel: WRe,
  Pscr: $Re,
  pscr: URe,
  Psi: VRe,
  psi: GRe,
  puncsp: YRe,
  Qfr: qRe,
  qfr: KRe,
  qint: XRe,
  qopf: JRe,
  Qopf: ZRe,
  qprime: QRe,
  Qscr: eDe,
  qscr: tDe,
  quaternions: rDe,
  quatint: nDe,
  quest: iDe,
  questeq: aDe,
  quot: oDe,
  QUOT: sDe,
  rAarr: lDe,
  race: uDe,
  Racute: cDe,
  racute: fDe,
  radic: dDe,
  raemptyv: hDe,
  rang: pDe,
  Rang: vDe,
  rangd: mDe,
  range: gDe,
  rangle: yDe,
  raquo: bDe,
  rarrap: SDe,
  rarrb: wDe,
  rarrbfs: xDe,
  rarrc: kDe,
  rarr: ODe,
  Rarr: CDe,
  rArr: TDe,
  rarrfs: ADe,
  rarrhk: EDe,
  rarrlp: MDe,
  rarrpl: RDe,
  rarrsim: DDe,
  Rarrtl: PDe,
  rarrtl: LDe,
  rarrw: IDe,
  ratail: _De,
  rAtail: NDe,
  ratio: BDe,
  rationals: FDe,
  rbarr: zDe,
  rBarr: HDe,
  RBarr: jDe,
  rbbrk: WDe,
  rbrace: $De,
  rbrack: UDe,
  rbrke: VDe,
  rbrksld: GDe,
  rbrkslu: YDe,
  Rcaron: qDe,
  rcaron: KDe,
  Rcedil: XDe,
  rcedil: JDe,
  rceil: ZDe,
  rcub: QDe,
  Rcy: ePe,
  rcy: tPe,
  rdca: rPe,
  rdldhar: nPe,
  rdquo: iPe,
  rdquor: aPe,
  rdsh: oPe,
  real: sPe,
  realine: lPe,
  realpart: uPe,
  reals: cPe,
  Re: fPe,
  rect: dPe,
  reg: hPe,
  REG: pPe,
  ReverseElement: vPe,
  ReverseEquilibrium: mPe,
  ReverseUpEquilibrium: gPe,
  rfisht: yPe,
  rfloor: bPe,
  rfr: SPe,
  Rfr: wPe,
  rHar: xPe,
  rhard: kPe,
  rharu: OPe,
  rharul: CPe,
  Rho: TPe,
  rho: APe,
  rhov: EPe,
  RightAngleBracket: MPe,
  RightArrowBar: RPe,
  rightarrow: DPe,
  RightArrow: PPe,
  Rightarrow: LPe,
  RightArrowLeftArrow: IPe,
  rightarrowtail: _Pe,
  RightCeiling: NPe,
  RightDoubleBracket: BPe,
  RightDownTeeVector: FPe,
  RightDownVectorBar: zPe,
  RightDownVector: HPe,
  RightFloor: jPe,
  rightharpoondown: WPe,
  rightharpoonup: $Pe,
  rightleftarrows: UPe,
  rightleftharpoons: VPe,
  rightrightarrows: GPe,
  rightsquigarrow: YPe,
  RightTeeArrow: qPe,
  RightTee: KPe,
  RightTeeVector: XPe,
  rightthreetimes: JPe,
  RightTriangleBar: ZPe,
  RightTriangle: QPe,
  RightTriangleEqual: eLe,
  RightUpDownVector: tLe,
  RightUpTeeVector: rLe,
  RightUpVectorBar: nLe,
  RightUpVector: iLe,
  RightVectorBar: aLe,
  RightVector: oLe,
  ring: sLe,
  risingdotseq: lLe,
  rlarr: uLe,
  rlhar: cLe,
  rlm: fLe,
  rmoustache: dLe,
  rmoust: hLe,
  rnmid: pLe,
  roang: vLe,
  roarr: mLe,
  robrk: gLe,
  ropar: yLe,
  ropf: bLe,
  Ropf: SLe,
  roplus: wLe,
  rotimes: xLe,
  RoundImplies: kLe,
  rpar: OLe,
  rpargt: CLe,
  rppolint: TLe,
  rrarr: ALe,
  Rrightarrow: ELe,
  rsaquo: MLe,
  rscr: RLe,
  Rscr: DLe,
  rsh: PLe,
  Rsh: LLe,
  rsqb: ILe,
  rsquo: _Le,
  rsquor: NLe,
  rthree: BLe,
  rtimes: FLe,
  rtri: zLe,
  rtrie: HLe,
  rtrif: jLe,
  rtriltri: WLe,
  RuleDelayed: $Le,
  ruluhar: ULe,
  rx: VLe,
  Sacute: GLe,
  sacute: YLe,
  sbquo: qLe,
  scap: KLe,
  Scaron: XLe,
  scaron: JLe,
  Sc: ZLe,
  sc: QLe,
  sccue: eIe,
  sce: tIe,
  scE: rIe,
  Scedil: nIe,
  scedil: iIe,
  Scirc: aIe,
  scirc: oIe,
  scnap: sIe,
  scnE: lIe,
  scnsim: uIe,
  scpolint: cIe,
  scsim: fIe,
  Scy: dIe,
  scy: hIe,
  sdotb: pIe,
  sdot: vIe,
  sdote: mIe,
  searhk: gIe,
  searr: yIe,
  seArr: bIe,
  searrow: SIe,
  sect: wIe,
  semi: xIe,
  seswar: kIe,
  setminus: OIe,
  setmn: CIe,
  sext: TIe,
  Sfr: AIe,
  sfr: EIe,
  sfrown: MIe,
  sharp: RIe,
  SHCHcy: DIe,
  shchcy: PIe,
  SHcy: LIe,
  shcy: IIe,
  ShortDownArrow: _Ie,
  ShortLeftArrow: NIe,
  shortmid: BIe,
  shortparallel: FIe,
  ShortRightArrow: zIe,
  ShortUpArrow: HIe,
  shy: jIe,
  Sigma: WIe,
  sigma: $Ie,
  sigmaf: UIe,
  sigmav: VIe,
  sim: GIe,
  simdot: YIe,
  sime: qIe,
  simeq: KIe,
  simg: XIe,
  simgE: JIe,
  siml: ZIe,
  simlE: QIe,
  simne: e_e,
  simplus: t_e,
  simrarr: r_e,
  slarr: n_e,
  SmallCircle: i_e,
  smallsetminus: a_e,
  smashp: o_e,
  smeparsl: s_e,
  smid: l_e,
  smile: u_e,
  smt: c_e,
  smte: f_e,
  smtes: d_e,
  SOFTcy: h_e,
  softcy: p_e,
  solbar: v_e,
  solb: m_e,
  sol: g_e,
  Sopf: y_e,
  sopf: b_e,
  spades: S_e,
  spadesuit: w_e,
  spar: x_e,
  sqcap: k_e,
  sqcaps: O_e,
  sqcup: C_e,
  sqcups: T_e,
  Sqrt: A_e,
  sqsub: E_e,
  sqsube: M_e,
  sqsubset: R_e,
  sqsubseteq: D_e,
  sqsup: P_e,
  sqsupe: L_e,
  sqsupset: I_e,
  sqsupseteq: __e,
  square: N_e,
  Square: B_e,
  SquareIntersection: F_e,
  SquareSubset: z_e,
  SquareSubsetEqual: H_e,
  SquareSuperset: j_e,
  SquareSupersetEqual: W_e,
  SquareUnion: $_e,
  squarf: U_e,
  squ: V_e,
  squf: G_e,
  srarr: Y_e,
  Sscr: q_e,
  sscr: K_e,
  ssetmn: X_e,
  ssmile: J_e,
  sstarf: Z_e,
  Star: Q_e,
  star: eNe,
  starf: tNe,
  straightepsilon: rNe,
  straightphi: nNe,
  strns: iNe,
  sub: aNe,
  Sub: oNe,
  subdot: sNe,
  subE: lNe,
  sube: uNe,
  subedot: cNe,
  submult: fNe,
  subnE: dNe,
  subne: hNe,
  subplus: pNe,
  subrarr: vNe,
  subset: mNe,
  Subset: gNe,
  subseteq: yNe,
  subseteqq: bNe,
  SubsetEqual: SNe,
  subsetneq: wNe,
  subsetneqq: xNe,
  subsim: kNe,
  subsub: ONe,
  subsup: CNe,
  succapprox: TNe,
  succ: ANe,
  succcurlyeq: ENe,
  Succeeds: MNe,
  SucceedsEqual: RNe,
  SucceedsSlantEqual: DNe,
  SucceedsTilde: PNe,
  succeq: LNe,
  succnapprox: INe,
  succneqq: _Ne,
  succnsim: NNe,
  succsim: BNe,
  SuchThat: FNe,
  sum: zNe,
  Sum: HNe,
  sung: jNe,
  sup1: WNe,
  sup2: $Ne,
  sup3: UNe,
  sup: VNe,
  Sup: GNe,
  supdot: YNe,
  supdsub: qNe,
  supE: KNe,
  supe: XNe,
  supedot: JNe,
  Superset: ZNe,
  SupersetEqual: QNe,
  suphsol: eBe,
  suphsub: tBe,
  suplarr: rBe,
  supmult: nBe,
  supnE: iBe,
  supne: aBe,
  supplus: oBe,
  supset: sBe,
  Supset: lBe,
  supseteq: uBe,
  supseteqq: cBe,
  supsetneq: fBe,
  supsetneqq: dBe,
  supsim: hBe,
  supsub: pBe,
  supsup: vBe,
  swarhk: mBe,
  swarr: gBe,
  swArr: yBe,
  swarrow: bBe,
  swnwar: SBe,
  szlig: wBe,
  Tab: xBe,
  target: kBe,
  Tau: OBe,
  tau: CBe,
  tbrk: TBe,
  Tcaron: ABe,
  tcaron: EBe,
  Tcedil: MBe,
  tcedil: RBe,
  Tcy: DBe,
  tcy: PBe,
  tdot: LBe,
  telrec: IBe,
  Tfr: _Be,
  tfr: NBe,
  there4: BBe,
  therefore: FBe,
  Therefore: zBe,
  Theta: HBe,
  theta: jBe,
  thetasym: WBe,
  thetav: $Be,
  thickapprox: UBe,
  thicksim: VBe,
  ThickSpace: GBe,
  ThinSpace: YBe,
  thinsp: qBe,
  thkap: KBe,
  thksim: XBe,
  THORN: JBe,
  thorn: ZBe,
  tilde: QBe,
  Tilde: e2e,
  TildeEqual: t2e,
  TildeFullEqual: r2e,
  TildeTilde: n2e,
  timesbar: i2e,
  timesb: a2e,
  times: o2e,
  timesd: s2e,
  tint: l2e,
  toea: u2e,
  topbot: c2e,
  topcir: f2e,
  top: d2e,
  Topf: h2e,
  topf: p2e,
  topfork: v2e,
  tosa: m2e,
  tprime: g2e,
  trade: y2e,
  TRADE: b2e,
  triangle: S2e,
  triangledown: w2e,
  triangleleft: x2e,
  trianglelefteq: k2e,
  triangleq: O2e,
  triangleright: C2e,
  trianglerighteq: T2e,
  tridot: A2e,
  trie: E2e,
  triminus: M2e,
  TripleDot: R2e,
  triplus: D2e,
  trisb: P2e,
  tritime: L2e,
  trpezium: I2e,
  Tscr: _2e,
  tscr: N2e,
  TScy: B2e,
  tscy: F2e,
  TSHcy: z2e,
  tshcy: H2e,
  Tstrok: j2e,
  tstrok: W2e,
  twixt: $2e,
  twoheadleftarrow: U2e,
  twoheadrightarrow: V2e,
  Uacute: G2e,
  uacute: Y2e,
  uarr: q2e,
  Uarr: K2e,
  uArr: X2e,
  Uarrocir: J2e,
  Ubrcy: Z2e,
  ubrcy: Q2e,
  Ubreve: eFe,
  ubreve: tFe,
  Ucirc: rFe,
  ucirc: nFe,
  Ucy: iFe,
  ucy: aFe,
  udarr: oFe,
  Udblac: sFe,
  udblac: lFe,
  udhar: uFe,
  ufisht: cFe,
  Ufr: fFe,
  ufr: dFe,
  Ugrave: hFe,
  ugrave: pFe,
  uHar: vFe,
  uharl: mFe,
  uharr: gFe,
  uhblk: yFe,
  ulcorn: bFe,
  ulcorner: SFe,
  ulcrop: wFe,
  ultri: xFe,
  Umacr: kFe,
  umacr: OFe,
  uml: CFe,
  UnderBar: TFe,
  UnderBrace: AFe,
  UnderBracket: EFe,
  UnderParenthesis: MFe,
  Union: RFe,
  UnionPlus: DFe,
  Uogon: PFe,
  uogon: LFe,
  Uopf: IFe,
  uopf: _Fe,
  UpArrowBar: NFe,
  uparrow: BFe,
  UpArrow: FFe,
  Uparrow: zFe,
  UpArrowDownArrow: HFe,
  updownarrow: jFe,
  UpDownArrow: WFe,
  Updownarrow: $Fe,
  UpEquilibrium: UFe,
  upharpoonleft: VFe,
  upharpoonright: GFe,
  uplus: YFe,
  UpperLeftArrow: qFe,
  UpperRightArrow: KFe,
  upsi: XFe,
  Upsi: JFe,
  upsih: ZFe,
  Upsilon: QFe,
  upsilon: eze,
  UpTeeArrow: tze,
  UpTee: rze,
  upuparrows: nze,
  urcorn: ize,
  urcorner: aze,
  urcrop: oze,
  Uring: sze,
  uring: lze,
  urtri: uze,
  Uscr: cze,
  uscr: fze,
  utdot: dze,
  Utilde: hze,
  utilde: pze,
  utri: vze,
  utrif: mze,
  uuarr: gze,
  Uuml: yze,
  uuml: bze,
  uwangle: Sze,
  vangrt: wze,
  varepsilon: xze,
  varkappa: kze,
  varnothing: Oze,
  varphi: Cze,
  varpi: Tze,
  varpropto: Aze,
  varr: Eze,
  vArr: Mze,
  varrho: Rze,
  varsigma: Dze,
  varsubsetneq: Pze,
  varsubsetneqq: Lze,
  varsupsetneq: Ize,
  varsupsetneqq: _ze,
  vartheta: Nze,
  vartriangleleft: Bze,
  vartriangleright: Fze,
  vBar: zze,
  Vbar: Hze,
  vBarv: jze,
  Vcy: Wze,
  vcy: $ze,
  vdash: Uze,
  vDash: Vze,
  Vdash: Gze,
  VDash: Yze,
  Vdashl: qze,
  veebar: Kze,
  vee: Xze,
  Vee: Jze,
  veeeq: Zze,
  vellip: Qze,
  verbar: eHe,
  Verbar: tHe,
  vert: rHe,
  Vert: nHe,
  VerticalBar: iHe,
  VerticalLine: aHe,
  VerticalSeparator: oHe,
  VerticalTilde: sHe,
  VeryThinSpace: lHe,
  Vfr: uHe,
  vfr: cHe,
  vltri: fHe,
  vnsub: dHe,
  vnsup: hHe,
  Vopf: pHe,
  vopf: vHe,
  vprop: mHe,
  vrtri: gHe,
  Vscr: yHe,
  vscr: bHe,
  vsubnE: SHe,
  vsubne: wHe,
  vsupnE: xHe,
  vsupne: kHe,
  Vvdash: OHe,
  vzigzag: CHe,
  Wcirc: THe,
  wcirc: AHe,
  wedbar: EHe,
  wedge: MHe,
  Wedge: RHe,
  wedgeq: DHe,
  weierp: PHe,
  Wfr: LHe,
  wfr: IHe,
  Wopf: _He,
  wopf: NHe,
  wp: BHe,
  wr: FHe,
  wreath: zHe,
  Wscr: HHe,
  wscr: jHe,
  xcap: WHe,
  xcirc: $He,
  xcup: UHe,
  xdtri: VHe,
  Xfr: GHe,
  xfr: YHe,
  xharr: qHe,
  xhArr: KHe,
  Xi: XHe,
  xi: JHe,
  xlarr: ZHe,
  xlArr: QHe,
  xmap: eje,
  xnis: tje,
  xodot: rje,
  Xopf: nje,
  xopf: ije,
  xoplus: aje,
  xotime: oje,
  xrarr: sje,
  xrArr: lje,
  Xscr: uje,
  xscr: cje,
  xsqcup: fje,
  xuplus: dje,
  xutri: hje,
  xvee: pje,
  xwedge: vje,
  Yacute: mje,
  yacute: gje,
  YAcy: yje,
  yacy: bje,
  Ycirc: Sje,
  ycirc: wje,
  Ycy: xje,
  ycy: kje,
  yen: Oje,
  Yfr: Cje,
  yfr: Tje,
  YIcy: Aje,
  yicy: Eje,
  Yopf: Mje,
  yopf: Rje,
  Yscr: Dje,
  yscr: Pje,
  YUcy: Lje,
  yucy: Ije,
  yuml: _je,
  Yuml: Nje,
  Zacute: Bje,
  zacute: Fje,
  Zcaron: zje,
  zcaron: Hje,
  Zcy: jje,
  zcy: Wje,
  Zdot: $je,
  zdot: Uje,
  zeetrf: Vje,
  ZeroWidthSpace: Gje,
  Zeta: Yje,
  zeta: qje,
  zfr: Kje,
  Zfr: Xje,
  ZHcy: Jje,
  zhcy: Zje,
  zigrarr: Qje,
  zopf: e3e,
  Zopf: t3e,
  Zscr: r3e,
  zscr: n3e,
  zwj: i3e,
  zwnj: a3e
}, o3e = "Á", s3e = "á", l3e = "Â", u3e = "â", c3e = "´", f3e = "Æ", d3e = "æ", h3e = "À", p3e = "à", v3e = "&", m3e = "&", g3e = "Å", y3e = "å", b3e = "Ã", S3e = "ã", w3e = "Ä", x3e = "ä", k3e = "¦", O3e = "Ç", C3e = "ç", T3e = "¸", A3e = "¢", E3e = "©", M3e = "©", R3e = "¤", D3e = "°", P3e = "÷", L3e = "É", I3e = "é", _3e = "Ê", N3e = "ê", B3e = "È", F3e = "è", z3e = "Ð", H3e = "ð", j3e = "Ë", W3e = "ë", $3e = "½", U3e = "¼", V3e = "¾", G3e = ">", Y3e = ">", q3e = "Í", K3e = "í", X3e = "Î", J3e = "î", Z3e = "¡", Q3e = "Ì", eWe = "ì", tWe = "¿", rWe = "Ï", nWe = "ï", iWe = "«", aWe = "<", oWe = "<", sWe = "¯", lWe = "µ", uWe = "·", cWe = " ", fWe = "¬", dWe = "Ñ", hWe = "ñ", pWe = "Ó", vWe = "ó", mWe = "Ô", gWe = "ô", yWe = "Ò", bWe = "ò", SWe = "ª", wWe = "º", xWe = "Ø", kWe = "ø", OWe = "Õ", CWe = "õ", TWe = "Ö", AWe = "ö", EWe = "¶", MWe = "±", RWe = "£", DWe = '"', PWe = '"', LWe = "»", IWe = "®", _We = "®", NWe = "§", BWe = "­", FWe = "¹", zWe = "²", HWe = "³", jWe = "ß", WWe = "Þ", $We = "þ", UWe = "×", VWe = "Ú", GWe = "ú", YWe = "Û", qWe = "û", KWe = "Ù", XWe = "ù", JWe = "¨", ZWe = "Ü", QWe = "ü", e$e = "Ý", t$e = "ý", r$e = "¥", n$e = "ÿ", i$e = {
  Aacute: o3e,
  aacute: s3e,
  Acirc: l3e,
  acirc: u3e,
  acute: c3e,
  AElig: f3e,
  aelig: d3e,
  Agrave: h3e,
  agrave: p3e,
  amp: v3e,
  AMP: m3e,
  Aring: g3e,
  aring: y3e,
  Atilde: b3e,
  atilde: S3e,
  Auml: w3e,
  auml: x3e,
  brvbar: k3e,
  Ccedil: O3e,
  ccedil: C3e,
  cedil: T3e,
  cent: A3e,
  copy: E3e,
  COPY: M3e,
  curren: R3e,
  deg: D3e,
  divide: P3e,
  Eacute: L3e,
  eacute: I3e,
  Ecirc: _3e,
  ecirc: N3e,
  Egrave: B3e,
  egrave: F3e,
  ETH: z3e,
  eth: H3e,
  Euml: j3e,
  euml: W3e,
  frac12: $3e,
  frac14: U3e,
  frac34: V3e,
  gt: G3e,
  GT: Y3e,
  Iacute: q3e,
  iacute: K3e,
  Icirc: X3e,
  icirc: J3e,
  iexcl: Z3e,
  Igrave: Q3e,
  igrave: eWe,
  iquest: tWe,
  Iuml: rWe,
  iuml: nWe,
  laquo: iWe,
  lt: aWe,
  LT: oWe,
  macr: sWe,
  micro: lWe,
  middot: uWe,
  nbsp: cWe,
  not: fWe,
  Ntilde: dWe,
  ntilde: hWe,
  Oacute: pWe,
  oacute: vWe,
  Ocirc: mWe,
  ocirc: gWe,
  Ograve: yWe,
  ograve: bWe,
  ordf: SWe,
  ordm: wWe,
  Oslash: xWe,
  oslash: kWe,
  Otilde: OWe,
  otilde: CWe,
  Ouml: TWe,
  ouml: AWe,
  para: EWe,
  plusmn: MWe,
  pound: RWe,
  quot: DWe,
  QUOT: PWe,
  raquo: LWe,
  reg: IWe,
  REG: _We,
  sect: NWe,
  shy: BWe,
  sup1: FWe,
  sup2: zWe,
  sup3: HWe,
  szlig: jWe,
  THORN: WWe,
  thorn: $We,
  times: UWe,
  Uacute: VWe,
  uacute: GWe,
  Ucirc: YWe,
  ucirc: qWe,
  Ugrave: KWe,
  ugrave: XWe,
  uml: JWe,
  Uuml: ZWe,
  uuml: QWe,
  Yacute: e$e,
  yacute: t$e,
  yen: r$e,
  yuml: n$e
}, a$e = "&", o$e = "'", s$e = ">", l$e = "<", u$e = '"', R4 = {
  amp: a$e,
  apos: o$e,
  gt: s$e,
  lt: l$e,
  quot: u$e
}, dW = {}, c$e = {
  0: 65533,
  128: 8364,
  130: 8218,
  131: 402,
  132: 8222,
  133: 8230,
  134: 8224,
  135: 8225,
  136: 710,
  137: 8240,
  138: 352,
  139: 8249,
  140: 338,
  142: 381,
  145: 8216,
  146: 8217,
  147: 8220,
  148: 8221,
  149: 8226,
  150: 8211,
  151: 8212,
  152: 732,
  153: 8482,
  154: 353,
  155: 8250,
  156: 339,
  158: 382,
  159: 376
}, f$e = bp && bp.__importDefault || function(i) {
  return i && i.__esModule ? i : { default: i };
};
Object.defineProperty(dW, "__esModule", { value: !0 });
var w8 = f$e(c$e), d$e = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.fromCodePoint || function(i) {
    var e = "";
    return i > 65535 && (i -= 65536, e += String.fromCharCode(i >>> 10 & 1023 | 55296), i = 56320 | i & 1023), e += String.fromCharCode(i), e;
  }
);
function h$e(i) {
  return i >= 55296 && i <= 57343 || i > 1114111 ? "�" : (i in w8.default && (i = w8.default[i]), d$e(i));
}
dW.default = h$e;
var Kx = bp && bp.__importDefault || function(i) {
  return i && i.__esModule ? i : { default: i };
};
Object.defineProperty(Ol, "__esModule", { value: !0 });
Ol.decodeHTML = Ol.decodeHTMLStrict = Ol.decodeXML = void 0;
var u3 = Kx(M4), p$e = Kx(i$e), v$e = Kx(R4), x8 = Kx(dW), m$e = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
Ol.decodeXML = D4(v$e.default);
Ol.decodeHTMLStrict = D4(u3.default);
function D4(i) {
  var e = P4(i);
  return function(r) {
    return String(r).replace(m$e, e);
  };
}
var k8 = function(i, e) {
  return i < e ? 1 : -1;
};
Ol.decodeHTML = function() {
  for (var i = Object.keys(p$e.default).sort(k8), e = Object.keys(u3.default).sort(k8), r = 0, s = 0; r < e.length; r++)
    i[s] === e[r] ? (e[r] += ";?", s++) : e[r] += ";";
  var l = new RegExp("&(?:" + e.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), c = P4(u3.default);
  function f(p) {
    return p.substr(-1) !== ";" && (p += ";"), c(p);
  }
  return function(p) {
    return String(p).replace(l, f);
  };
}();
function P4(i) {
  return function(r) {
    if (r.charAt(1) === "#") {
      var s = r.charAt(2);
      return s === "X" || s === "x" ? x8.default(parseInt(r.substr(3), 16)) : x8.default(parseInt(r.substr(2), 10));
    }
    return i[r.slice(1, -1)] || r;
  };
}
var po = {}, L4 = bp && bp.__importDefault || function(i) {
  return i && i.__esModule ? i : { default: i };
};
Object.defineProperty(po, "__esModule", { value: !0 });
po.escapeUTF8 = po.escape = po.encodeNonAsciiHTML = po.encodeHTML = po.encodeXML = void 0;
var g$e = L4(R4), I4 = N4(g$e.default), _4 = B4(I4);
po.encodeXML = H4(I4);
var y$e = L4(M4), hW = N4(y$e.default), b$e = B4(hW);
po.encodeHTML = w$e(hW, b$e);
po.encodeNonAsciiHTML = H4(hW);
function N4(i) {
  return Object.keys(i).sort().reduce(function(e, r) {
    return e[i[r]] = "&" + r + ";", e;
  }, {});
}
function B4(i) {
  for (var e = [], r = [], s = 0, l = Object.keys(i); s < l.length; s++) {
    var c = l[s];
    c.length === 1 ? e.push("\\" + c) : r.push(c);
  }
  e.sort();
  for (var f = 0; f < e.length - 1; f++) {
    for (var p = f; p < e.length - 1 && e[p].charCodeAt(1) + 1 === e[p + 1].charCodeAt(1); )
      p += 1;
    var d = 1 + p - f;
    d < 3 || e.splice(f, d, e[f] + "-" + e[p]);
  }
  return r.unshift("[" + e.join("") + "]"), new RegExp(r.join("|"), "g");
}
var F4 = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, S$e = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    function(i) {
      return i.codePointAt(0);
    }
  ) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    function(i) {
      return (i.charCodeAt(0) - 55296) * 1024 + i.charCodeAt(1) - 56320 + 65536;
    }
  )
);
function Xx(i) {
  return "&#x" + (i.length > 1 ? S$e(i) : i.charCodeAt(0)).toString(16).toUpperCase() + ";";
}
function w$e(i, e) {
  return function(r) {
    return r.replace(e, function(s) {
      return i[s];
    }).replace(F4, Xx);
  };
}
var z4 = new RegExp(_4.source + "|" + F4.source, "g");
function x$e(i) {
  return i.replace(z4, Xx);
}
po.escape = x$e;
function k$e(i) {
  return i.replace(_4, Xx);
}
po.escapeUTF8 = k$e;
function H4(i) {
  return function(e) {
    return e.replace(z4, function(r) {
      return i[r] || Xx(r);
    });
  };
}
(function(i) {
  Object.defineProperty(i, "__esModule", { value: !0 }), i.decodeXMLStrict = i.decodeHTML5Strict = i.decodeHTML4Strict = i.decodeHTML5 = i.decodeHTML4 = i.decodeHTMLStrict = i.decodeHTML = i.decodeXML = i.encodeHTML5 = i.encodeHTML4 = i.escapeUTF8 = i.escape = i.encodeNonAsciiHTML = i.encodeHTML = i.encodeXML = i.encode = i.decodeStrict = i.decode = void 0;
  var e = Ol, r = po;
  function s(d, m) {
    return (!m || m <= 0 ? e.decodeXML : e.decodeHTML)(d);
  }
  i.decode = s;
  function l(d, m) {
    return (!m || m <= 0 ? e.decodeXML : e.decodeHTMLStrict)(d);
  }
  i.decodeStrict = l;
  function c(d, m) {
    return (!m || m <= 0 ? r.encodeXML : r.encodeHTML)(d);
  }
  i.encode = c;
  var f = po;
  Object.defineProperty(i, "encodeXML", { enumerable: !0, get: function() {
    return f.encodeXML;
  } }), Object.defineProperty(i, "encodeHTML", { enumerable: !0, get: function() {
    return f.encodeHTML;
  } }), Object.defineProperty(i, "encodeNonAsciiHTML", { enumerable: !0, get: function() {
    return f.encodeNonAsciiHTML;
  } }), Object.defineProperty(i, "escape", { enumerable: !0, get: function() {
    return f.escape;
  } }), Object.defineProperty(i, "escapeUTF8", { enumerable: !0, get: function() {
    return f.escapeUTF8;
  } }), Object.defineProperty(i, "encodeHTML4", { enumerable: !0, get: function() {
    return f.encodeHTML;
  } }), Object.defineProperty(i, "encodeHTML5", { enumerable: !0, get: function() {
    return f.encodeHTML;
  } });
  var p = Ol;
  Object.defineProperty(i, "decodeXML", { enumerable: !0, get: function() {
    return p.decodeXML;
  } }), Object.defineProperty(i, "decodeHTML", { enumerable: !0, get: function() {
    return p.decodeHTML;
  } }), Object.defineProperty(i, "decodeHTMLStrict", { enumerable: !0, get: function() {
    return p.decodeHTMLStrict;
  } }), Object.defineProperty(i, "decodeHTML4", { enumerable: !0, get: function() {
    return p.decodeHTML;
  } }), Object.defineProperty(i, "decodeHTML5", { enumerable: !0, get: function() {
    return p.decodeHTML;
  } }), Object.defineProperty(i, "decodeHTML4Strict", { enumerable: !0, get: function() {
    return p.decodeHTMLStrict;
  } }), Object.defineProperty(i, "decodeHTML5Strict", { enumerable: !0, get: function() {
    return p.decodeHTMLStrict;
  } }), Object.defineProperty(i, "decodeXMLStrict", { enumerable: !0, get: function() {
    return p.decodeXML;
  } });
})(fW);
var j4 = "&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});", O$e = 92, C$e = /[\\&]/, pW = "[!\"#$%&'()*+,./:;<=>?@[\\\\\\]^_`{|}~-]", T$e = new RegExp("\\\\" + pW + "|" + j4, "gi"), A$e = '[&<>"]', O8 = new RegExp(A$e, "g"), E$e = function(i) {
  return i.charCodeAt(0) === O$e ? i.charAt(1) : fW.decodeHTML(i);
};
function Yg(i) {
  return C$e.test(i) ? i.replace(T$e, E$e) : i;
}
function zw(i) {
  try {
    return Wae(i);
  } catch {
    return i;
  }
}
function M$e(i) {
  switch (i) {
    case "&":
      return "&amp;";
    case "<":
      return "&lt;";
    case ">":
      return "&gt;";
    case '"':
      return "&quot;";
    default:
      return i;
  }
}
function rp(i) {
  return O8.test(i) ? i.replace(O8, M$e) : i;
}
function c3(i, e) {
  for (var r = [], s = 0; s < e; s++)
    r.push(i);
  return r.join("");
}
function C8(i) {
  return i ? !/[^ \t]+/.test(i) : !0;
}
var R$e = (
  /** @class */
  function() {
    function i(e) {
      this.current = e, this.root = e, this.entering = !0;
    }
    return i.prototype.next = function() {
      var e = this.current, r = this.entering;
      if (e === null)
        return null;
      var s = vW(e);
      return r && s ? e.firstChild ? (this.current = e.firstChild, this.entering = !0) : this.entering = !1 : e === this.root ? this.current = null : e.next === null ? (this.current = e.parent, this.entering = !1) : (this.current = e.next, this.entering = !0), { entering: r, node: e };
    }, i.prototype.resumeAt = function(e, r) {
      this.current = e, this.entering = r === !0;
    }, i;
  }()
);
function vW(i) {
  switch (i.type) {
    case "document":
    case "blockQuote":
    case "list":
    case "item":
    case "paragraph":
    case "heading":
    case "emph":
    case "strong":
    case "strike":
    case "link":
    case "image":
    case "table":
    case "tableHead":
    case "tableBody":
    case "tableRow":
    case "tableCell":
    case "tableDelimRow":
    case "customInline":
      return !0;
    default:
      return !1;
  }
}
var D$e = 1, Jx = {};
function P$e(i) {
  return Jx[i];
}
function f3(i) {
  delete Jx[i];
}
function L$e() {
  Jx = {};
}
var ay = (
  /** @class */
  function() {
    function i(e, r) {
      this.parent = null, this.prev = null, this.next = null, this.firstChild = null, this.lastChild = null, this.literal = null, e === "document" ? this.id = -1 : this.id = D$e++, this.type = e, this.sourcepos = r, Jx[this.id] = this;
    }
    return i.prototype.isContainer = function() {
      return vW(this);
    }, i.prototype.unlink = function() {
      this.prev ? this.prev.next = this.next : this.parent && (this.parent.firstChild = this.next), this.next ? this.next.prev = this.prev : this.parent && (this.parent.lastChild = this.prev), this.parent = null, this.next = null, this.prev = null;
    }, i.prototype.replaceWith = function(e) {
      this.insertBefore(e), this.unlink();
    }, i.prototype.insertAfter = function(e) {
      e.unlink(), e.next = this.next, e.next && (e.next.prev = e), e.prev = this, this.next = e, this.parent && (e.parent = this.parent, e.next || (e.parent.lastChild = e));
    }, i.prototype.insertBefore = function(e) {
      e.unlink(), e.prev = this.prev, e.prev && (e.prev.next = e), e.next = this, this.prev = e, e.parent = this.parent, e.prev || (e.parent.firstChild = e);
    }, i.prototype.appendChild = function(e) {
      e.unlink(), e.parent = this, this.lastChild ? (this.lastChild.next = e, e.prev = this.lastChild, this.lastChild = e) : (this.firstChild = e, this.lastChild = e);
    }, i.prototype.prependChild = function(e) {
      e.unlink(), e.parent = this, this.firstChild ? (this.firstChild.prev = e, e.next = this.firstChild, this.firstChild = e) : (this.firstChild = e, this.lastChild = e);
    }, i.prototype.walker = function() {
      return new R$e(this);
    }, i;
  }()
), Al = (
  /** @class */
  function(i) {
    No(e, i);
    function e(r, s) {
      var l = i.call(this, r, s) || this;
      return l.open = !0, l.lineOffsets = null, l.stringContent = null, l.lastLineBlank = !1, l.lastLineChecked = !1, l.type = r, l;
    }
    return e;
  }(ay)
), I$e = (
  /** @class */
  function(i) {
    No(e, i);
    function e() {
      var r = i !== null && i.apply(this, arguments) || this;
      return r.listData = null, r;
    }
    return e;
  }(Al)
), _$e = (
  /** @class */
  function(i) {
    No(e, i);
    function e() {
      var r = i !== null && i.apply(this, arguments) || this;
      return r.level = 0, r.headingType = "atx", r;
    }
    return e;
  }(Al)
), N$e = (
  /** @class */
  function(i) {
    No(e, i);
    function e() {
      var r = i !== null && i.apply(this, arguments) || this;
      return r.isFenced = !1, r.fenceChar = null, r.fenceLength = 0, r.fenceOffset = -1, r.info = null, r.infoPadding = 0, r;
    }
    return e;
  }(Al)
), B$e = (
  /** @class */
  function(i) {
    No(e, i);
    function e() {
      var r = i !== null && i.apply(this, arguments) || this;
      return r.columns = [], r;
    }
    return e;
  }(Al)
), F$e = (
  /** @class */
  function(i) {
    No(e, i);
    function e() {
      var r = i !== null && i.apply(this, arguments) || this;
      return r.startIdx = 0, r.endIdx = 0, r.paddingLeft = 0, r.paddingRight = 0, r.ignored = !1, r;
    }
    return e;
  }(Al)
), z$e = (
  /** @class */
  function(i) {
    No(e, i);
    function e() {
      var r = i !== null && i.apply(this, arguments) || this;
      return r.title = "", r.dest = "", r.label = "", r;
    }
    return e;
  }(Al)
), H$e = (
  /** @class */
  function(i) {
    No(e, i);
    function e() {
      var r = i !== null && i.apply(this, arguments) || this;
      return r.syntaxLength = 0, r.offset = -1, r.info = "", r;
    }
    return e;
  }(Al)
), j$e = (
  /** @class */
  function(i) {
    No(e, i);
    function e() {
      var r = i !== null && i.apply(this, arguments) || this;
      return r.htmlBlockType = -1, r;
    }
    return e;
  }(Al)
), W$e = (
  /** @class */
  function(i) {
    No(e, i);
    function e() {
      var r = i !== null && i.apply(this, arguments) || this;
      return r.destination = null, r.title = null, r.extendedAutolink = !1, r;
    }
    return e;
  }(ay)
), $$e = (
  /** @class */
  function(i) {
    No(e, i);
    function e() {
      var r = i !== null && i.apply(this, arguments) || this;
      return r.tickCount = 0, r;
    }
    return e;
  }(ay)
), U$e = (
  /** @class */
  function(i) {
    No(e, i);
    function e() {
      var r = i !== null && i.apply(this, arguments) || this;
      return r.info = "", r;
    }
    return e;
  }(ay)
);
function Nn(i, e) {
  switch (i) {
    case "heading":
      return new _$e(i, e);
    case "list":
    case "item":
      return new I$e(i, e);
    case "link":
    case "image":
      return new W$e(i, e);
    case "codeBlock":
      return new N$e(i, e);
    case "htmlBlock":
      return new j$e(i, e);
    case "table":
      return new B$e(i, e);
    case "tableCell":
      return new F$e(i, e);
    case "document":
    case "paragraph":
    case "blockQuote":
    case "thematicBreak":
    case "tableRow":
    case "tableBody":
    case "tableHead":
    case "frontMatter":
      return new Al(i, e);
    case "code":
      return new $$e(i, e);
    case "refDef":
      return new z$e(i, e);
    case "customBlock":
      return new H$e(i, e);
    case "customInline":
      return new U$e(i, e);
    default:
      return new ay(i, e);
  }
}
function W4(i) {
  return i.type === "codeBlock";
}
function V$e(i) {
  return i.type === "htmlBlock";
}
function G$e(i) {
  return i.type === "heading";
}
function T8(i) {
  return i.type === "list";
}
function Y$e(i) {
  return i.type === "table";
}
function Xh(i) {
  return i.type === "refDef";
}
function $4(i) {
  return i.type === "customBlock";
}
function q$e(i) {
  return i.type === "customInline";
}
function ui(i, e) {
  var r = Nn("text", e);
  return r.literal = i, r;
}
var U4 = "[A-Za-z][A-Za-z0-9-]*", K$e = "[a-zA-Z_:][a-zA-Z0-9:._-]*", X$e = "[^\"'=<>`\\x00-\\x20]+", J$e = "'[^']*'", Z$e = '"[^"]*"', Q$e = "(?:" + X$e + "|" + J$e + "|" + Z$e + ")", eUe = "(?:\\s*=\\s*" + Q$e + ")", tUe = "(?:\\s+" + K$e + eUe + "?)", V4 = "<" + U4 + tUe + "*\\s*/?>", G4 = "</" + U4 + "\\s*[>]", rUe = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->", nUe = "[<][?].*?[?][>]", iUe = "<![A-Z]+\\s+[^>]*>", aUe = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", oUe = "(?:" + V4 + "|" + G4 + "|" + rUe + "|" + nUe + "|" + iUe + "|" + aUe + ")", sUe = new RegExp("^" + oUe, "i");
/*! http://mths.be/fromcodepoint v0.2.1 by @mathias */
var d3;
if (String.fromCodePoint)
  d3 = function(i) {
    try {
      return String.fromCodePoint(i);
    } catch (e) {
      if (e instanceof RangeError)
        return "�";
      throw e;
    }
  };
else {
  var lUe = String.fromCharCode, uUe = Math.floor;
  d3 = function() {
    for (var i = [], e = 0; e < arguments.length; e++)
      i[e] = arguments[e];
    var r = 16384, s = [], l, c, f = -1, p = i.length;
    if (!p)
      return "";
    for (var d = ""; ++f < p; ) {
      var m = Number(i[f]);
      if (!isFinite(m) || // `NaN`, `+Infinity`, or `-Infinity`
      m < 0 || // not a valid Unicode code point
      m > 1114111 || // not a valid Unicode code point
      uUe(m) !== m)
        return "�";
      m <= 65535 ? s.push(m) : (m -= 65536, l = (m >> 10) + 55296, c = m % 1024 + 56320, s.push(l, c)), (f + 1 === p || s.length > r) && (d += lUe.apply(void 0, s), s.length = 0);
    }
    return d;
  };
}
var oj = d3, cUe = "(?:[w-]+.)*[A-Za-z0-9-]+.[A-Za-z0-9-]+", fUe = "[^<\\s]*[^<?!.,:*_?~\\s]", dUe = "[\\w.+-]+@(?:[\\w-]+\\.)+[\\w-]+";
function hUe(i) {
  var e = /\)+$/.exec(i);
  if (e) {
    for (var r = 0, s = 0, l = i; s < l.length; s++) {
      var c = l[s];
      c === "(" ? r < 0 ? r = 1 : r += 1 : c === ")" && (r -= 1);
    }
    if (r < 0) {
      var f = Math.min(-r, e[0].length);
      return i.substring(0, i.length - f);
    }
  }
  return i;
}
function pUe(i) {
  return i.replace(/&[A-Za-z0-9]+;$/, "");
}
function vUe(i) {
  for (var e = new RegExp(dUe, "g"), r = [], s; s = e.exec(i); ) {
    var l = s[0];
    /[_-]+$/.test(l) || r.push({
      text: l,
      range: [s.index, s.index + l.length - 1],
      url: "mailto:" + l
    });
  }
  return r;
}
function mUe(i) {
  for (var e = new RegExp("(www|https?://)." + cUe + fUe, "g"), r = [], s; s = e.exec(i); ) {
    var l = pUe(hUe(s[0])), c = s[1] === "www" ? "http://" : "";
    r.push({
      text: l,
      range: [s.index, s.index + l.length - 1],
      url: "" + c + l
    });
  }
  return r;
}
function gUe(i) {
  return l3(l3([], mUe(i)), vUe(i)).sort(function(e, r) {
    return e.range[0] - r.range[0];
  });
}
function yUe(i, e) {
  typeof e == "boolean" && (e = gUe);
  for (var r, s = function() {
    var l = r.entering, c = r.node;
    if (l && c.type === "text" && c.parent.type !== "link") {
      var f = c.literal, p = e(f);
      if (!p || !p.length)
        return "continue";
      for (var d = 0, m = c.sourcepos[0], y = m[0], S = m[1], x = function(ee, de) {
        return [
          [y, S + ee],
          [y, S + de]
        ];
      }, w = [], k = 0, O = p; k < O.length; k++) {
        var T = O[k], L = T.range, j = T.url, z = T.text;
        L[0] > d && w.push(ui(f.substring(d, L[0]), x(d, L[0] - 1)));
        var J = Nn("link", x.apply(void 0, L));
        J.appendChild(ui(z, x.apply(void 0, L))), J.destination = j, J.extendedAutolink = !0, w.push(J), d = L[1] + 1;
      }
      d < f.length && w.push(ui(f.substring(d), x(d, f.length - 1)));
      for (var ie = 0, K = w; ie < K.length; ie++) {
        var re = K[ie];
        c.insertBefore(re);
      }
      c.unlink();
    }
  }; r = i.next(); )
    s();
}
function Cx(i) {
  return i[i.length - 1];
}
function A8(i) {
  return i.slice(1, i.length - 1).trim().replace(/[ \t\r\n]+/, " ").toLowerCase().toUpperCase();
}
function Hw(i, e) {
  Object.keys(i).forEach(function(r) {
    e(r, i[r]);
  });
}
function bUe(i) {
  for (var e = [], r = 1; r < arguments.length; r++)
    e[r - 1] = arguments[r];
  var s = Ai({}, i);
  return e.forEach(function(l) {
    delete s[l];
  }), s;
}
function Jh(i) {
  return !Object.keys(i).length;
}
function SUe(i) {
  Object.keys(i).forEach(function(e) {
    delete i[e];
  });
}
var h3 = 10, sj = 42, jw = 95, wUe = 96, E8 = 91, xUe = 93, Ww = 126, M8 = 60, kUe = 33, R8 = 92, OUe = 38, D8 = 40, lj = 41, CUe = 58, kc = 39, Oc = 34, Cc = 36, uj = "\\\\" + pW, P8 = new RegExp(/[!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/), TUe = new RegExp('^(?:"(' + uj + '|[^"\\x00])*"|' + ("'(" + uj + "|[^'\\x00])*'") + "|" + ("\\((" + uj + "|[^()\\x00])*\\))")), AUe = /^(?:<(?:[^<>\n\\\x00]|\\.)*>)/, L8 = new RegExp("^" + pW), EUe = new RegExp("^" + j4, "i"), MUe = /`+/, RUe = /^`+/, DUe = /\.\.\./g, PUe = /--+/g, LUe = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/, IUe = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\x00-\x20]*>/i, _Ue = /^ *(?:\n *)?/, cj = /^[ \t\n\x0b\x0c\x0d]/, I8 = /^\s/, NUe = / *$/, BUe = /^ */, _8 = /^ *(?:\n|$)/, FUe = /^\[(?:[^\\\[\]]|\\.){0,1000}\]/, zUe = /^[^\n`\[\]\\!<&*_'"~$]+/m, HUe = (
  /** @class */
  function() {
    function i(e) {
      this.subject = "", this.delimiters = null, this.brackets = null, this.pos = 0, this.lineStartNum = 0, this.lineIdx = 0, this.lineOffsets = [0], this.linePosOffset = 0, this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.options = e;
    }
    return i.prototype.sourcepos = function(e, r) {
      var s = this.linePosOffset + this.lineOffsets[this.lineIdx], l = this.lineStartNum + this.lineIdx, c = [l, e + s];
      return typeof r == "number" ? [c, [l, r + s]] : c;
    }, i.prototype.nextLine = function() {
      this.lineIdx += 1, this.linePosOffset = -this.pos;
    }, i.prototype.match = function(e) {
      var r = e.exec(this.subject.slice(this.pos));
      return r === null ? null : (this.pos += r.index + r[0].length, r[0]);
    }, i.prototype.peek = function() {
      return this.pos < this.subject.length ? this.subject.charCodeAt(this.pos) : -1;
    }, i.prototype.spnl = function() {
      return this.match(_Ue), !0;
    }, i.prototype.parseBackticks = function(e) {
      var r = this.pos + 1, s = this.match(RUe);
      if (s === null)
        return !1;
      for (var l = this.pos, c; (c = this.match(MUe)) !== null; )
        if (c === s) {
          var f = this.subject.slice(l, this.pos - s.length), p = this.sourcepos(r, this.pos), d = f.split(`
`);
          if (d.length > 1) {
            var m = Cx(d);
            this.lineIdx += d.length - 1, this.linePosOffset = -(this.pos - m.length - s.length), p[1] = this.sourcepos(this.pos), f = d.join(" ");
          }
          var y = Nn("code", p);
          return f.length > 0 && f.match(/[^ ]/) !== null && f[0] == " " && f[f.length - 1] == " " ? y.literal = f.slice(1, f.length - 1) : y.literal = f, y.tickCount = s.length, e.appendChild(y), !0;
        }
      return this.pos = l, e.appendChild(ui(s, this.sourcepos(r, this.pos - 1))), !0;
    }, i.prototype.parseBackslash = function(e) {
      var r = this.subject, s;
      this.pos += 1;
      var l = this.pos;
      return this.peek() === h3 ? (this.pos += 1, s = Nn("linebreak", this.sourcepos(this.pos - 1, this.pos)), e.appendChild(s), this.nextLine()) : L8.test(r.charAt(this.pos)) ? (e.appendChild(ui(r.charAt(this.pos), this.sourcepos(l, this.pos))), this.pos += 1) : e.appendChild(ui("\\", this.sourcepos(l, l))), !0;
    }, i.prototype.parseAutolink = function(e) {
      var r, s, l, c = this.pos + 1;
      return (r = this.match(LUe)) ? (s = r.slice(1, r.length - 1), l = Nn("link", this.sourcepos(c, this.pos)), l.destination = zw("mailto:" + s), l.title = "", l.appendChild(ui(s, this.sourcepos(c + 1, this.pos - 1))), e.appendChild(l), !0) : (r = this.match(IUe)) ? (s = r.slice(1, r.length - 1), l = Nn("link", this.sourcepos(c, this.pos)), l.destination = zw(s), l.title = "", l.appendChild(ui(s, this.sourcepos(c + 1, this.pos - 1))), e.appendChild(l), !0) : !1;
    }, i.prototype.parseHtmlTag = function(e) {
      var r = this.pos + 1, s = this.match(sUe);
      if (s === null)
        return !1;
      var l = Nn("htmlInline", this.sourcepos(r, this.pos));
      return l.literal = s, e.appendChild(l), !0;
    }, i.prototype.scanDelims = function(e) {
      var r = 0, s = this.pos;
      if (e === kc || e === Oc)
        r++, this.pos++;
      else
        for (; this.peek() === e; )
          r++, this.pos++;
      if (r === 0 || r < 2 && (e === Ww || e === Cc))
        return this.pos = s, null;
      var l = s === 0 ? `
` : this.subject.charAt(s - 1), c = this.peek(), f;
      c === -1 ? f = `
` : f = oj(c);
      var p = I8.test(f), d = P8.test(f), m = I8.test(l), y = P8.test(l), S = !p && (!d || m || y), x = !m && (!y || p || d), w, k;
      return e === jw ? (w = S && (!x || y), k = x && (!S || d)) : e === kc || e === Oc ? (w = S && !x, k = x) : e === Cc ? (w = !p, k = !m) : (w = S, k = x), this.pos = s, { numdelims: r, canOpen: w, canClose: k };
    }, i.prototype.handleDelim = function(e, r) {
      var s = this.scanDelims(e);
      if (!s)
        return !1;
      var l = s.numdelims, c = this.pos + 1, f;
      this.pos += l, e === kc ? f = "’" : e === Oc ? f = "“" : f = this.subject.slice(c - 1, this.pos);
      var p = ui(f, this.sourcepos(c, this.pos));
      return r.appendChild(p), (s.canOpen || s.canClose) && (this.options.smart || e !== kc && e !== Oc) && (this.delimiters = {
        cc: e,
        numdelims: l,
        origdelims: l,
        node: p,
        previous: this.delimiters,
        next: null,
        canOpen: s.canOpen,
        canClose: s.canClose
      }, this.delimiters.previous && (this.delimiters.previous.next = this.delimiters)), !0;
    }, i.prototype.removeDelimiter = function(e) {
      e.previous !== null && (e.previous.next = e.next), e.next === null ? this.delimiters = e.previous : e.next.previous = e.previous;
    }, i.prototype.removeDelimitersBetween = function(e, r) {
      e.next !== r && (e.next = r, r.previous = e);
    }, i.prototype.processEmphasis = function(e) {
      var r, s, l, c, f, p, d, m = !1, y = (r = {}, r[jw] = [e, e, e], r[sj] = [e, e, e], r[kc] = [e], r[Oc] = [e], r[Ww] = [e], r[Cc] = [e], r);
      for (l = this.delimiters; l !== null && l.previous !== e; )
        l = l.previous;
      for (; l !== null; ) {
        var S = l.cc, x = S === jw || S === sj;
        if (!l.canClose)
          l = l.next;
        else {
          for (s = l.previous, d = !1; s !== null && s !== e && s !== y[S][x ? l.origdelims % 3 : 0]; ) {
            if (m = x && (l.canOpen || s.canClose) && l.origdelims % 3 !== 0 && (s.origdelims + l.origdelims) % 3 === 0, s.cc === l.cc && s.canOpen && !m) {
              d = !0;
              break;
            }
            s = s.previous;
          }
          if (c = l, x || S === Ww || S === Cc) {
            if (!d)
              l = l.next;
            else if (s) {
              var w = l.numdelims >= 2 && s.numdelims >= 2 ? 2 : 1, k = x ? 0 : 1;
              f = s.node, p = l.node;
              var O = x ? w === 1 ? "emph" : "strong" : "strike";
              S === Cc && (O = "customInline");
              var T = Nn(O), L = f.sourcepos[1], j = p.sourcepos[0];
              T.sourcepos = [
                [L[0], L[1] - w + 1],
                [j[0], j[1] + w - 1]
              ], f.sourcepos[1][1] -= w, p.sourcepos[0][1] += w, f.literal = f.literal.slice(w), p.literal = p.literal.slice(w), s.numdelims -= w, l.numdelims -= w;
              for (var z = f.next, J = void 0; z && z !== p; )
                J = z.next, z.unlink(), T.appendChild(z), z = J;
              if (S === Cc) {
                var ie = T.firstChild, K = ie.literal || "", re = K.split(/\s/)[0];
                T.info = re, K.length <= re.length ? ie.unlink() : (ie.sourcepos[0][1] += re.length, ie.literal = K.replace(re + " ", ""));
              }
              if (f.insertAfter(T), this.removeDelimitersBetween(s, l), s.numdelims <= k && (s.numdelims === 0 && f.unlink(), this.removeDelimiter(s)), l.numdelims <= k) {
                l.numdelims === 0 && p.unlink();
                var ee = l.next;
                this.removeDelimiter(l), l = ee;
              }
            }
          } else S === kc ? (l.node.literal = "’", d && (s.node.literal = "‘"), l = l.next) : S === Oc && (l.node.literal = "”", d && (s.node.literal = "“"), l = l.next);
          d || (y[S][x ? c.origdelims % 3 : 0] = c.previous, c.canOpen || this.removeDelimiter(c));
        }
      }
      for (; this.delimiters !== null && this.delimiters !== e; )
        this.removeDelimiter(this.delimiters);
    }, i.prototype.parseLinkTitle = function() {
      var e = this.match(TUe);
      return e === null ? null : Yg(e.substr(1, e.length - 2));
    }, i.prototype.parseLinkDestination = function() {
      var e = this.match(AUe);
      if (e === null) {
        if (this.peek() === M8)
          return null;
        for (var r = this.pos, s = 0, l = void 0; (l = this.peek()) !== -1; )
          if (l === R8 && L8.test(this.subject.charAt(this.pos + 1)))
            this.pos += 1, this.peek() !== -1 && (this.pos += 1);
          else if (l === D8)
            this.pos += 1, s += 1;
          else if (l === lj) {
            if (s < 1)
              break;
            this.pos += 1, s -= 1;
          } else {
            if (cj.exec(oj(l)) !== null)
              break;
            this.pos += 1;
          }
        return this.pos === r && l !== lj || s !== 0 ? null : (e = this.subject.substr(r, this.pos - r), zw(Yg(e)));
      }
      return zw(Yg(e.substr(1, e.length - 2)));
    }, i.prototype.parseLinkLabel = function() {
      var e = this.match(FUe);
      return e === null || e.length > 1001 ? 0 : e.length;
    }, i.prototype.parseOpenBracket = function(e) {
      var r = this.pos;
      this.pos += 1;
      var s = ui("[", this.sourcepos(this.pos, this.pos));
      return e.appendChild(s), this.addBracket(s, r, !1), !0;
    }, i.prototype.parseBang = function(e) {
      var r = this.pos;
      if (this.pos += 1, this.peek() === E8) {
        this.pos += 1;
        var s = ui("![", this.sourcepos(this.pos - 1, this.pos));
        e.appendChild(s), this.addBracket(s, r + 1, !0);
      } else {
        var s = ui("!", this.sourcepos(this.pos, this.pos));
        e.appendChild(s);
      }
      return !0;
    }, i.prototype.parseCloseBracket = function(e) {
      var r = null, s = null, l = !1;
      this.pos += 1;
      var c = this.pos, f = this.brackets;
      if (f === null)
        return e.appendChild(ui("]", this.sourcepos(c, c))), !0;
      if (!f.active)
        return e.appendChild(ui("]", this.sourcepos(c, c))), this.removeBracket(), !0;
      var p = f.image, d = this.pos;
      this.peek() === D8 && (this.pos++, this.spnl() && (r = this.parseLinkDestination()) !== null && this.spnl() && // make sure there's a space before the title:
      (cj.test(this.subject.charAt(this.pos - 1)) && (s = this.parseLinkTitle()) || !0) && this.spnl() && this.peek() === lj ? (this.pos += 1, l = !0) : this.pos = d);
      var m = "";
      if (!l) {
        var y = this.pos, S = this.parseLinkLabel();
        if (S > 2 ? m = this.subject.slice(y, y + S) : f.bracketAfter || (m = this.subject.slice(f.index, c)), S === 0 && (this.pos = d), m) {
          m = A8(m);
          var x = this.refMap[m];
          x && (r = x.destination, s = x.title, l = !0);
        }
      }
      if (l) {
        var w = Nn(p ? "image" : "link");
        w.destination = r, w.title = s || "", w.sourcepos = [f.startpos, this.sourcepos(this.pos)];
        for (var k = f.node.next, O = void 0; k; )
          O = k.next, k.unlink(), w.appendChild(k), k = O;
        if (e.appendChild(w), this.processEmphasis(f.previousDelimiter), this.removeBracket(), f.node.unlink(), !p)
          for (f = this.brackets; f !== null; )
            f.image || (f.active = !1), f = f.previous;
        return this.options.referenceDefinition && (this.refLinkCandidateMap[e.id] = { node: e, refLabel: m }), !0;
      }
      return this.removeBracket(), this.pos = c, e.appendChild(ui("]", this.sourcepos(c, c))), this.options.referenceDefinition && (this.refLinkCandidateMap[e.id] = { node: e, refLabel: m }), !0;
    }, i.prototype.addBracket = function(e, r, s) {
      this.brackets !== null && (this.brackets.bracketAfter = !0), this.brackets = {
        node: e,
        startpos: this.sourcepos(r + (s ? 0 : 1)),
        previous: this.brackets,
        previousDelimiter: this.delimiters,
        index: r,
        image: s,
        active: !0
      };
    }, i.prototype.removeBracket = function() {
      this.brackets && (this.brackets = this.brackets.previous);
    }, i.prototype.parseEntity = function(e) {
      var r, s = this.pos + 1;
      return (r = this.match(EUe)) ? (e.appendChild(ui(fW.decodeHTML(r), this.sourcepos(s, this.pos))), !0) : !1;
    }, i.prototype.parseString = function(e) {
      var r, s = this.pos + 1;
      if (r = this.match(zUe)) {
        if (this.options.smart) {
          var l = r.replace(DUe, "…").replace(PUe, function(f) {
            var p = 0, d = 0;
            return f.length % 3 === 0 ? d = f.length / 3 : f.length % 2 === 0 ? p = f.length / 2 : f.length % 3 === 2 ? (p = 1, d = (f.length - 2) / 3) : (p = 2, d = (f.length - 4) / 3), c3("—", d) + c3("–", p);
          });
          e.appendChild(ui(l, this.sourcepos(s, this.pos)));
        } else {
          var c = ui(r, this.sourcepos(s, this.pos));
          e.appendChild(c);
        }
        return !0;
      }
      return !1;
    }, i.prototype.parseNewline = function(e) {
      this.pos += 1;
      var r = e.lastChild;
      if (r && r.type === "text" && r.literal[r.literal.length - 1] === " ") {
        var s = r.literal[r.literal.length - 2] === " ", l = r.literal.length;
        r.literal = r.literal.replace(NUe, "");
        var c = l - r.literal.length;
        r.sourcepos[1][1] -= c, e.appendChild(Nn(s ? "linebreak" : "softbreak", this.sourcepos(this.pos - c, this.pos)));
      } else
        e.appendChild(Nn("softbreak", this.sourcepos(this.pos, this.pos)));
      return this.nextLine(), this.match(BUe), !0;
    }, i.prototype.parseReference = function(e, r) {
      if (!this.options.referenceDefinition)
        return 0;
      this.subject = e.stringContent, this.pos = 0;
      var s = null, l = this.pos, c = this.parseLinkLabel();
      if (c === 0)
        return 0;
      var f = this.subject.substr(0, c);
      if (this.peek() === CUe)
        this.pos++;
      else
        return this.pos = l, 0;
      this.spnl();
      var p = this.parseLinkDestination();
      if (p === null)
        return this.pos = l, 0;
      var d = this.pos;
      this.spnl(), this.pos !== d && (s = this.parseLinkTitle()), s === null && (s = "", this.pos = d);
      var m = !0;
      if (this.match(_8) === null && (s === "" ? m = !1 : (s = "", this.pos = d, m = this.match(_8) !== null)), !m)
        return this.pos = l, 0;
      var y = A8(f);
      if (y === "")
        return this.pos = l, 0;
      var S = this.getReferenceDefSourcepos(e);
      e.sourcepos[0][0] = S[1][0] + 1;
      var x = Nn("refDef", S);
      return x.title = s, x.dest = p, x.label = y, e.insertBefore(x), r[y] ? this.refDefCandidateMap[x.id] = x : r[y] = m3(x), this.pos - l;
    }, i.prototype.mergeTextNodes = function(e) {
      for (var r, s = []; r = e.next(); ) {
        var l = r.entering, c = r.node;
        if (l && c.type === "text")
          s.push(c);
        else if (s.length === 1)
          s = [];
        else if (s.length > 1) {
          var f = s[0], p = s[s.length - 1];
          f.sourcepos && p.sourcepos && (f.sourcepos[1] = p.sourcepos[1]), f.next = p.next, f.next && (f.next.prev = f);
          for (var d = 1; d < s.length; d += 1)
            f.literal += s[d].literal, s[d].unlink();
          s = [];
        }
      }
    }, i.prototype.getReferenceDefSourcepos = function(e) {
      for (var r = e.stringContent.split(/\n|\r\n/), s = !1, l = 0, c = { line: 0, ch: 0 }, f = 0; f < r.length; f += 1) {
        var p = r[f];
        if (cj.test(p))
          break;
        if (/\:/.test(p) && l === 0) {
          if (s)
            break;
          var d = p.indexOf(":") === p.length - 1 ? f + 1 : f;
          c = { line: d, ch: r[d].length }, s = !0;
        }
        var m = p.match(/'|"/g);
        if (m && (l += m.length), l === 2) {
          c = { line: f, ch: p.length };
          break;
        }
      }
      return [
        [e.sourcepos[0][0], e.sourcepos[0][1]],
        [e.sourcepos[0][0] + c.line, c.ch]
      ];
    }, i.prototype.parseInline = function(e) {
      var r, s = !1, l = this.peek();
      if (l === -1)
        return !1;
      switch (l) {
        case h3:
          s = this.parseNewline(e);
          break;
        case R8:
          s = this.parseBackslash(e);
          break;
        case wUe:
          s = this.parseBackticks(e);
          break;
        case sj:
        case jw:
        case Ww:
        case Cc:
          s = this.handleDelim(l, e);
          break;
        case kc:
        case Oc:
          s = !!(!((r = this.options) === null || r === void 0) && r.smart) && this.handleDelim(l, e);
          break;
        case E8:
          s = this.parseOpenBracket(e);
          break;
        case kUe:
          s = this.parseBang(e);
          break;
        case xUe:
          s = this.parseCloseBracket(e);
          break;
        case M8:
          s = this.parseAutolink(e) || this.parseHtmlTag(e);
          break;
        case OUe:
          e.disabledEntityParse || (s = this.parseEntity(e));
          break;
        default:
          s = this.parseString(e);
          break;
      }
      return s || (this.pos += 1, e.appendChild(ui(oj(l), this.sourcepos(this.pos, this.pos + 1)))), !0;
    }, i.prototype.parse = function(e) {
      for (this.subject = e.stringContent.trim(), this.pos = 0, this.delimiters = null, this.brackets = null, this.lineOffsets = e.lineOffsets || [0], this.lineIdx = 0, this.linePosOffset = 0, this.lineStartNum = e.sourcepos[0][0], G$e(e) && (this.lineOffsets[0] += e.level + 1); this.parseInline(e); )
        ;
      e.stringContent = null, this.processEmphasis(null), this.mergeTextNodes(e.walker());
      var r = this.options, s = r.extendedAutolinks, l = r.customParser;
      if (s && yUe(e.walker(), s), l && e.firstChild)
        for (var c, f = e.firstChild.walker(); c = f.next(); ) {
          var p = c.node, d = c.entering;
          l[p.type] && l[p.type](p, { entering: d, options: this.options });
        }
    }, i;
  }()
), jUe = /^\[([ \txX])\][ \t]+/;
function WUe(i, e) {
  if (e.firstChild && e.firstChild.type === "paragraph") {
    var r = e.firstChild, s = r.stringContent.match(jUe);
    if (s) {
      var l = s[0].length;
      r.stringContent = r.stringContent.substring(l - 1), r.sourcepos[0][1] += l, r.lineOffsets[0] += l, e.listData.task = !0, e.listData.checked = /[xX]/.test(s[1]);
    }
  }
}
var $Ue = {
  continue: function() {
    return 0;
  },
  finalize: function() {
  },
  canContain: function(i) {
    return i === "tableHead" || i === "tableBody";
  },
  acceptsLines: !1
}, UUe = {
  continue: function() {
    return 0;
  },
  finalize: function() {
  },
  canContain: function(i) {
    return i === "tableRow";
  },
  acceptsLines: !1
}, VUe = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function(i) {
    return i === "tableRow" || i === "tableDelimRow";
  },
  acceptsLines: !1
}, GUe = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function(i) {
    return i === "tableDelimCell";
  },
  acceptsLines: !1
}, YUe = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !1
}, qUe = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function(i) {
    return i === "tableCell";
  },
  acceptsLines: !1
}, KUe = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !1
}, Tx = 4, Y4 = 9, q4 = 62, XUe = 60, K4 = 32, X4 = 91, J4 = /[^ \t\f\v\r\n]/, JUe = /^(?:`{3,}|~{3,})(?= *$)/;
function N8(i) {
  for (var e = i; e; ) {
    if (e.lastLineBlank)
      return !0;
    var r = e.type;
    if (!e.lastLineChecked && (r === "list" || r === "item"))
      e.lastLineChecked = !0, e = e.lastChild;
    else {
      e.lastLineChecked = !0;
      break;
    }
  }
  return !1;
}
function vo(i, e) {
  return e < i.length ? i.charCodeAt(e) : -1;
}
function Z4(i) {
  return !J4.test(i);
}
function Sp(i) {
  return i === K4 || i === Y4;
}
var ZUe = /^\$\$$/, QUe = {
  continue: function(i, e) {
    var r = i.currentLine, s = r.match(ZUe);
    if (s)
      return i.lastLineLength = s[0].length, i.finalize(e, i.lineNumber), 2;
    for (var l = e.offset; l > 0 && Sp(vo(r, i.offset)); )
      i.advanceOffset(1, !0), l--;
    return 0;
  },
  finalize: function(i, e) {
    if (e.stringContent !== null) {
      var r = e.stringContent, s = r.indexOf(`
`), l = r.slice(0, s), c = r.slice(s + 1), f = l.match(/^(\s*)(.*)/);
      e.info = Yg(f[2].trim()), e.literal = c, e.stringContent = null;
    }
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, Q4 = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, e8e = {
  continue: function() {
    return 0;
  },
  finalize: function() {
  },
  canContain: function(i) {
    return i !== "item";
  },
  acceptsLines: !1
}, t8e = {
  continue: function() {
    return 0;
  },
  finalize: function(i, e) {
    for (var r = e.firstChild; r; ) {
      if (N8(r) && r.next) {
        e.listData.tight = !1;
        break;
      }
      for (var s = r.firstChild; s; ) {
        if (N8(s) && (r.next || s.next)) {
          e.listData.tight = !1;
          break;
        }
        s = s.next;
      }
      r = r.next;
    }
  },
  canContain: function(i) {
    return i === "item";
  },
  acceptsLines: !1
}, r8e = {
  continue: function(i) {
    var e = i.currentLine;
    if (!i.indented && vo(e, i.nextNonspace) === q4)
      i.advanceNextNonspace(), i.advanceOffset(1, !1), Sp(vo(e, i.offset)) && i.advanceOffset(1, !0);
    else
      return 1;
    return 0;
  },
  finalize: function() {
  },
  canContain: function(i) {
    return i !== "item";
  },
  acceptsLines: !1
}, n8e = {
  continue: function(i, e) {
    if (i.blank) {
      if (e.firstChild === null)
        return 1;
      i.advanceNextNonspace();
    } else if (i.indent >= e.listData.markerOffset + e.listData.padding)
      i.advanceOffset(e.listData.markerOffset + e.listData.padding, !0);
    else
      return 1;
    return 0;
  },
  finalize: WUe,
  canContain: function(i) {
    return i !== "item";
  },
  acceptsLines: !1
}, i8e = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !1
}, a8e = {
  continue: function() {
    return 1;
  },
  finalize: function() {
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !1
}, o8e = {
  continue: function(i, e) {
    var r = i.currentLine, s = i.indent;
    if (e.isFenced) {
      var l = s <= 3 && r.charAt(i.nextNonspace) === e.fenceChar && r.slice(i.nextNonspace).match(JUe);
      if (l && l[0].length >= e.fenceLength)
        return i.lastLineLength = i.offset + s + l[0].length, i.finalize(e, i.lineNumber), 2;
      for (var c = e.fenceOffset; c > 0 && Sp(vo(r, i.offset)); )
        i.advanceOffset(1, !0), c--;
    } else if (s >= Tx)
      i.advanceOffset(Tx, !0);
    else if (i.blank)
      i.advanceNextNonspace();
    else
      return 1;
    return 0;
  },
  finalize: function(i, e) {
    var r;
    if (e.stringContent !== null) {
      if (e.isFenced) {
        var s = e.stringContent, l = s.indexOf(`
`), c = s.slice(0, l), f = s.slice(l + 1), p = c.match(/^(\s*)(.*)/);
        e.infoPadding = p[1].length, e.info = Yg(p[2].trim()), e.literal = f;
      } else
        e.literal = (r = e.stringContent) === null || r === void 0 ? void 0 : r.replace(/(\n *)+$/, `
`);
      e.stringContent = null;
    }
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, s8e = {
  continue: function(i, e) {
    return i.blank && (e.htmlBlockType === 6 || e.htmlBlockType === 7) ? 1 : 0;
  },
  finalize: function(i, e) {
    var r;
    e.literal = ((r = e.stringContent) === null || r === void 0 ? void 0 : r.replace(/(\n *)+$/, "")) || null, e.stringContent = null;
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, l8e = {
  continue: function(i) {
    return i.blank ? 1 : 0;
  },
  finalize: function(i, e) {
    if (e.stringContent !== null) {
      for (var r, s = !1; vo(e.stringContent, 0) === X4 && (r = i.inlineParser.parseReference(e, i.refMap)); )
        e.stringContent = e.stringContent.slice(r), s = !0;
      s && Z4(e.stringContent) && e.unlink();
    }
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, u8e = Q4, c8e = Q4, Zh = {
  document: e8e,
  list: t8e,
  blockQuote: r8e,
  item: n8e,
  heading: i8e,
  thematicBreak: a8e,
  codeBlock: o8e,
  htmlBlock: s8e,
  paragraph: l8e,
  table: $Ue,
  tableBody: UUe,
  tableHead: VUe,
  tableRow: qUe,
  tableCell: KUe,
  tableDelimRow: GUe,
  tableDelimCell: YUe,
  refDef: u8e,
  customBlock: QUe,
  frontMatter: c8e
};
function p3(i) {
  for (var e = 0, r = 0, s = [], l = 0; l < i.length; l += 1)
    if (i[l] === "|" && i[l - 1] !== "\\") {
      var c = i.substring(e, l);
      e === 0 && C8(c) ? r = l + 1 : s.push(c), e = l + 1;
    }
  if (e < i.length) {
    var c = i.substring(e, i.length);
    C8(c) || s.push(c);
  }
  return [r, s];
}
function v3(i, e, r, s) {
  for (var l = [], c = 0, f = e; c < f.length; c++) {
    var p = f[c], d = p.match(/^[ \t]+/), m = d ? d[0].length : 0, y = void 0, S = void 0;
    if (m === p.length)
      m = 0, y = 0, S = "";
    else {
      var x = p.match(/[ \t]+$/);
      y = x ? x[0].length : 0, S = p.slice(m, p.length - y);
    }
    var w = s + m, k = Nn(i, [
      [r, s],
      [r, s + p.length - 1]
    ]);
    k.stringContent = S.replace(/\\\|/g, "|"), k.startIdx = l.length, k.endIdx = l.length, k.lineOffsets = [w - 1], k.paddingLeft = m, k.paddingRight = y, l.push(k), s += p.length + 1;
  }
  return l;
}
function f8e(i) {
  var e = null, r = i.stringContent, s = r[0], l = r[r.length - 1];
  return l === ":" ? e = s === ":" ? "center" : "right" : s === ":" && (e = "left"), { align: e };
}
var d8e = function(i, e) {
  var r = e.stringContent;
  if (e.type === "paragraph" && !i.indented && !i.blank) {
    var s = r.length - 1, l = r.lastIndexOf(`
`, s - 1) + 1, c = r.slice(l, s), f = i.currentLine.slice(i.nextNonspace), p = p3(c), d = p[0], m = p[1], y = p3(f), S = y[0], x = y[1], w = /^[ \t]*:?-+:?[ \t]*$/;
    if (
      // not checking if the number of header cells and delimiter cells are the same
      // to consider the case of merged-column (via plugin)
      !m.length || !x.length || x.some(function(ee) {
        return !w.test(ee);
      }) || // to prevent to regard setTextHeading as tabel delim cell with 'disallowDeepHeading' option
      x.length === 1 && f.indexOf("|") !== 0
    )
      return 0;
    var k = e.lineOffsets, O = i.lineNumber - 1, T = Cx(k) + 1, L = Nn("table", [
      [O, T],
      [i.lineNumber, i.offset]
    ]);
    if (L.columns = x.map(function() {
      return { align: null };
    }), e.insertAfter(L), k.length === 1)
      e.unlink();
    else {
      e.stringContent = r.slice(0, l);
      var j = r.lastIndexOf(`
`, l - 2) + 1, z = l - j - 1;
      i.lastLineLength = k[k.length - 2] + z, i.finalize(e, O - 1);
    }
    i.advanceOffset(i.currentLine.length - i.offset, !1);
    var J = Nn("tableHead", [
      [O, T],
      [i.lineNumber, i.offset]
    ]);
    L.appendChild(J);
    var ie = Nn("tableRow", [
      [O, T],
      [O, T + c.length - 1]
    ]), K = Nn("tableDelimRow", [
      [i.lineNumber, i.nextNonspace + 1],
      [i.lineNumber, i.offset]
    ]);
    J.appendChild(ie), J.appendChild(K), v3("tableCell", m, O, T + d).forEach(function(ee) {
      ie.appendChild(ee);
    });
    var re = v3("tableDelimCell", x, i.lineNumber, i.nextNonspace + 1 + S);
    return re.forEach(function(ee) {
      K.appendChild(ee);
    }), L.columns = re.map(f8e), i.tip = L, 2;
  }
  return 0;
}, h8e = function(i, e) {
  if (e.type !== "table" && e.type !== "tableBody" || !i.blank && i.currentLine.indexOf("|") === -1)
    return 0;
  if (i.advanceOffset(i.currentLine.length - i.offset, !1), i.blank) {
    var r = e;
    return e.type === "tableBody" && (r = e.parent, i.finalize(e, i.lineNumber - 1)), i.finalize(r, i.lineNumber - 1), 0;
  }
  var s = e;
  e.type === "table" && (s = i.addChild("tableBody", i.nextNonspace), s.stringContent = null);
  var l = Nn("tableRow", [
    [i.lineNumber, i.nextNonspace + 1],
    [i.lineNumber, i.currentLine.length]
  ]);
  s.appendChild(l);
  var c = s.parent, f = i.currentLine.slice(i.nextNonspace), p = p3(f), d = p[0], m = p[1];
  return v3("tableCell", m, i.lineNumber, i.nextNonspace + 1 + d).forEach(function(y, S) {
    S >= c.columns.length && (y.ignored = !0), l.appendChild(y);
  }), 2;
}, p8e = /^(\$\$)(\s*[a-zA-Z])+/, v8e = /^(\$\$)(\s*[a-zA-Z])+.*(\$\$)/, m8e = function(i) {
  var e;
  if (!i.indented && !v8e.test(i.currentLine) && (e = i.currentLine.match(p8e))) {
    var r = e[1].length;
    i.closeUnmatchedBlocks();
    var s = i.addChild("customBlock", i.nextNonspace);
    return s.syntaxLength = r, s.offset = i.indent, i.advanceNextNonspace(), i.advanceOffset(r, !1), 2;
  }
  return 0;
}, g8e = /^`{3,}(?!.*`)|^~{3,}/, y8e = [
  /./,
  /^<(?:script|pre|style)(?:\s|>|$)/i,
  /^<!--/,
  /^<[?]/,
  /^<![A-Z]/,
  /^<!\[CDATA\[/,
  /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|[/]?[>]|$)/i,
  new RegExp("^(?:" + V4 + "|" + G4 + ")\\s*$", "i")
], b8e = /^(?:=+|-+)[ \t]*$/, S8e = /^#{1,6}(?:[ \t]+|$)/, w8e = /^(?:(?:\*[ \t]*){3,}|(?:_[ \t]*){3,}|(?:-[ \t]*){3,})[ \t]*$/, e9 = /^[*+-]/, t9 = /^(\d{1,9})([.)])/;
function x8e(i, e) {
  var r = i.currentLine.slice(i.nextNonspace), s, l, c = {
    type: "bullet",
    tight: !0,
    bulletChar: "",
    start: 0,
    delimiter: "",
    padding: 0,
    markerOffset: i.indent,
    // GFM: Task List Item
    task: !1,
    checked: !1
  };
  if (i.indent >= 4)
    return null;
  if (s = r.match(e9))
    c.type = "bullet", c.bulletChar = s[0][0];
  else if ((s = r.match(t9)) && (e.type !== "paragraph" || s[1] === "1"))
    c.type = "ordered", c.start = parseInt(s[1], 10), c.delimiter = s[2];
  else
    return null;
  if (l = vo(i.currentLine, i.nextNonspace + s[0].length), !(l === -1 || l === Y4 || l === K4) || e.type === "paragraph" && !i.currentLine.slice(i.nextNonspace + s[0].length).match(J4))
    return null;
  i.advanceNextNonspace(), i.advanceOffset(s[0].length, !0);
  var f = i.column, p = i.offset;
  do
    i.advanceOffset(1, !0), l = vo(i.currentLine, i.offset);
  while (i.column - f < 5 && Sp(l));
  var d = vo(i.currentLine, i.offset) === -1, m = i.column - f;
  return m >= 5 || m < 1 || d ? (c.padding = s[0].length + 1, i.column = f, i.offset = p, Sp(vo(i.currentLine, i.offset)) && i.advanceOffset(1, !0)) : c.padding = s[0].length + m, c;
}
function k8e(i, e) {
  return i.type === e.type && i.delimiter === e.delimiter && i.bulletChar === e.bulletChar;
}
function r9(i, e) {
  return i.options.disallowDeepHeading && (e.type === "blockQuote" || e.type === "item");
}
var O8e = function(i) {
  return !i.indented && vo(i.currentLine, i.nextNonspace) === q4 ? (i.advanceNextNonspace(), i.advanceOffset(1, !1), Sp(vo(i.currentLine, i.offset)) && i.advanceOffset(1, !0), i.closeUnmatchedBlocks(), i.addChild("blockQuote", i.nextNonspace), 1) : 0;
}, C8e = function(i, e) {
  var r;
  if (!i.indented && // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
  !r9(i, e) && (r = i.currentLine.slice(i.nextNonspace).match(S8e))) {
    i.advanceNextNonspace(), i.advanceOffset(r[0].length, !1), i.closeUnmatchedBlocks();
    var s = i.addChild("heading", i.nextNonspace);
    return s.level = r[0].trim().length, s.headingType = "atx", s.stringContent = i.currentLine.slice(i.offset).replace(/^[ \t]*#+[ \t]*$/, "").replace(/[ \t]+#+[ \t]*$/, ""), i.advanceOffset(i.currentLine.length - i.offset), 2;
  }
  return 0;
}, T8e = function(i) {
  var e;
  if (!i.indented && (e = i.currentLine.slice(i.nextNonspace).match(g8e))) {
    var r = e[0].length;
    i.closeUnmatchedBlocks();
    var s = i.addChild("codeBlock", i.nextNonspace);
    return s.isFenced = !0, s.fenceLength = r, s.fenceChar = e[0][0], s.fenceOffset = i.indent, i.advanceNextNonspace(), i.advanceOffset(r, !1), 2;
  }
  return 0;
}, A8e = function(i, e) {
  if (!i.indented && vo(i.currentLine, i.nextNonspace) === XUe) {
    var r = i.currentLine.slice(i.nextNonspace), s = i.options.disallowedHtmlBlockTags, l = void 0;
    for (l = 1; l <= 7; l++) {
      var c = r.match(y8e[l]);
      if (c) {
        if (l === 7) {
          if (e.type === "paragraph")
            return 0;
          if (s.length > 0) {
            var f = new RegExp("</?(?:" + s.join("|") + ")", "i");
            if (f.test(c[0]))
              return 0;
          }
        }
        i.closeUnmatchedBlocks();
        var p = i.addChild("htmlBlock", i.offset);
        return p.htmlBlockType = l, 2;
      }
    }
  }
  return 0;
}, E8e = function(i, e) {
  var r;
  if (e.stringContent !== null && !i.indented && e.type === "paragraph" && // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
  !r9(i, e.parent) && (r = i.currentLine.slice(i.nextNonspace).match(b8e))) {
    i.closeUnmatchedBlocks();
    for (var s = void 0; vo(e.stringContent, 0) === X4 && (s = i.inlineParser.parseReference(e, i.refMap)); )
      e.stringContent = e.stringContent.slice(s);
    if (e.stringContent.length > 0) {
      var l = Nn("heading", e.sourcepos);
      return l.level = r[0][0] === "=" ? 1 : 2, l.headingType = "setext", l.stringContent = e.stringContent, e.insertAfter(l), e.unlink(), i.tip = l, i.advanceOffset(i.currentLine.length - i.offset, !1), 2;
    }
    return 0;
  }
  return 0;
}, M8e = function(i) {
  return !i.indented && w8e.test(i.currentLine.slice(i.nextNonspace)) ? (i.closeUnmatchedBlocks(), i.addChild("thematicBreak", i.nextNonspace), i.advanceOffset(i.currentLine.length - i.offset, !1), 2) : 0;
}, R8e = function(i, e) {
  var r, s = e;
  return (!i.indented || e.type === "list") && (r = x8e(i, s)) ? (i.closeUnmatchedBlocks(), (i.tip.type !== "list" || !k8e(s.listData, r)) && (s = i.addChild("list", i.nextNonspace), s.listData = r), s = i.addChild("item", i.nextNonspace), s.listData = r, 1) : 0;
}, D8e = function(i) {
  return i.indented && i.tip.type !== "paragraph" && !i.blank ? (i.advanceOffset(Tx, !0), i.closeUnmatchedBlocks(), i.addChild("codeBlock", i.offset), 2) : 0;
}, fj = [
  O8e,
  C8e,
  T8e,
  A8e,
  E8e,
  M8e,
  R8e,
  D8e,
  d8e,
  h8e,
  m8e
], n9 = /^(-{3}|\+{3}|;{3})$/, P8e = function(i, e) {
  var r = i.currentLine, s = i.lineNumber, l = i.indented;
  if (s === 1 && !l && e.type === "document" && n9.test(r)) {
    i.closeUnmatchedBlocks();
    var c = i.addChild("frontMatter", i.nextNonspace);
    return c.stringContent = r, i.advanceNextNonspace(), i.advanceOffset(r.length, !1), 2;
  }
  return 0;
}, L8e = {
  continue: function(i, e) {
    var r = i.currentLine, s = r.match(n9);
    return e.type === "frontMatter" && s ? (e.stringContent += r, i.lastLineLength = s[0].length, i.finalize(e, i.lineNumber), 2) : 0;
  },
  finalize: function(i, e) {
    e.stringContent !== null && (e.literal = e.stringContent, e.stringContent = null);
  },
  canContain: function() {
    return !1;
  },
  acceptsLines: !0
}, I8e = [
  /./,
  /<\/(?:script|pre|style)>/i,
  /-->/,
  /\?>/,
  />/,
  /\]\]>/
], _8e = /^[#`~*+_=<>0-9-;$]/, N8e = /\r\n|\n|\r/;
function dj() {
  return Nn("document", [
    [1, 1],
    [0, 0]
  ]);
}
var B8e = {
  smart: !1,
  tagFilter: !1,
  extendedAutolinks: !1,
  disallowedHtmlBlockTags: [],
  referenceDefinition: !1,
  disallowDeepHeading: !1,
  customParser: null,
  frontMatter: !1
}, F8e = (
  /** @class */
  function() {
    function i(e) {
      this.options = Ai(Ai({}, B8e), e), this.doc = dj(), this.tip = this.doc, this.oldtip = this.doc, this.lineNumber = 0, this.offset = 0, this.column = 0, this.nextNonspace = 0, this.nextNonspaceColumn = 0, this.indent = 0, this.currentLine = "", this.indented = !1, this.blank = !1, this.partiallyConsumedTab = !1, this.allClosed = !0, this.lastMatchedContainer = this.doc, this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.lastLineLength = 0, this.lines = [], this.options.frontMatter && (Zh.frontMatter = L8e, fj.unshift(P8e)), this.inlineParser = new HUe(this.options);
    }
    return i.prototype.advanceOffset = function(e, r) {
      r === void 0 && (r = !1);
      for (var s = this.currentLine, l, c, f; e > 0 && (f = s[this.offset]); )
        f === "	" ? (l = 4 - this.column % 4, r ? (this.partiallyConsumedTab = l > e, c = l > e ? e : l, this.column += c, this.offset += this.partiallyConsumedTab ? 0 : 1, e -= c) : (this.partiallyConsumedTab = !1, this.column += l, this.offset += 1, e -= 1)) : (this.partiallyConsumedTab = !1, this.offset += 1, this.column += 1, e -= 1);
    }, i.prototype.advanceNextNonspace = function() {
      this.offset = this.nextNonspace, this.column = this.nextNonspaceColumn, this.partiallyConsumedTab = !1;
    }, i.prototype.findNextNonspace = function() {
      for (var e = this.currentLine, r = this.offset, s = this.column, l; (l = e.charAt(r)) !== ""; )
        if (l === " ")
          r++, s++;
        else if (l === "	")
          r++, s += 4 - s % 4;
        else
          break;
      this.blank = l === `
` || l === "\r" || l === "", this.nextNonspace = r, this.nextNonspaceColumn = s, this.indent = this.nextNonspaceColumn - this.column, this.indented = this.indent >= Tx;
    }, i.prototype.addLine = function() {
      if (this.partiallyConsumedTab) {
        this.offset += 1;
        var e = 4 - this.column % 4;
        this.tip.stringContent += c3(" ", e);
      }
      this.tip.lineOffsets ? this.tip.lineOffsets.push(this.offset) : this.tip.lineOffsets = [this.offset], this.tip.stringContent += this.currentLine.slice(this.offset) + `
`;
    }, i.prototype.addChild = function(e, r) {
      for (; !Zh[this.tip.type].canContain(e); )
        this.finalize(this.tip, this.lineNumber - 1);
      var s = r + 1, l = Nn(e, [
        [this.lineNumber, s],
        [0, 0]
      ]);
      return l.stringContent = "", this.tip.appendChild(l), this.tip = l, l;
    }, i.prototype.closeUnmatchedBlocks = function() {
      if (!this.allClosed) {
        for (; this.oldtip !== this.lastMatchedContainer; ) {
          var e = this.oldtip.parent;
          this.finalize(this.oldtip, this.lineNumber - 1), this.oldtip = e;
        }
        this.allClosed = !0;
      }
    }, i.prototype.finalize = function(e, r) {
      var s = e.parent;
      e.open = !1, e.sourcepos[1] = [r, this.lastLineLength], Zh[e.type].finalize(this, e), this.tip = s;
    }, i.prototype.processInlines = function(e) {
      var r, s = this.options.customParser, l = e.walker();
      for (this.inlineParser.refMap = this.refMap, this.inlineParser.refLinkCandidateMap = this.refLinkCandidateMap, this.inlineParser.refDefCandidateMap = this.refDefCandidateMap, this.inlineParser.options = this.options; r = l.next(); ) {
        var c = r.node, f = r.entering, p = c.type;
        s && s[p] && s[p](c, { entering: f, options: this.options }), !f && (p === "paragraph" || p === "heading" || p === "tableCell" && !c.ignored) && this.inlineParser.parse(c);
      }
    }, i.prototype.incorporateLine = function(e) {
      var r = this.doc;
      this.oldtip = this.tip, this.offset = 0, this.column = 0, this.blank = !1, this.partiallyConsumedTab = !1, this.lineNumber += 1, e.indexOf("\0") !== -1 && (e = e.replace(/\0/g, "�")), this.currentLine = e;
      for (var s = !0, l; (l = r.lastChild) && l.open; ) {
        switch (r = l, this.findNextNonspace(), Zh[r.type].continue(this, r)) {
          case 0:
            break;
          case 1:
            s = !1;
            break;
          case 2:
            this.lastLineLength = e.length;
            return;
          default:
            throw new Error("continue returned illegal value, must be 0, 1, or 2");
        }
        if (!s) {
          r = r.parent;
          break;
        }
      }
      this.allClosed = r === this.oldtip, this.lastMatchedContainer = r;
      for (var c = r.type !== "paragraph" && Zh[r.type].acceptsLines, f = fj.length; !c; ) {
        if (this.findNextNonspace(), r.type !== "table" && r.type !== "tableBody" && r.type !== "paragraph" && !this.indented && !_8e.test(e.slice(this.nextNonspace))) {
          this.advanceNextNonspace();
          break;
        }
        for (var p = 0; p < f; ) {
          var d = fj[p](this, r);
          if (d === 1) {
            r = this.tip;
            break;
          } else if (d === 2) {
            r = this.tip, c = !0;
            break;
          } else
            p++;
        }
        if (p === f) {
          this.advanceNextNonspace();
          break;
        }
      }
      if (!this.allClosed && !this.blank && this.tip.type === "paragraph")
        this.addLine();
      else {
        this.closeUnmatchedBlocks(), this.blank && r.lastChild && (r.lastChild.lastLineBlank = !0);
        for (var m = r.type, y = this.blank && !(m === "blockQuote" || W4(r) && r.isFenced || m === "item" && !r.firstChild && r.sourcepos[0][0] === this.lineNumber), S = r; S; )
          S.lastLineBlank = y, S = S.parent;
        Zh[m].acceptsLines ? (this.addLine(), V$e(r) && r.htmlBlockType >= 1 && r.htmlBlockType <= 5 && I8e[r.htmlBlockType].test(this.currentLine.slice(this.offset)) && (this.lastLineLength = e.length, this.finalize(r, this.lineNumber))) : this.offset < e.length && !this.blank && (r = this.addChild("paragraph", this.offset), this.advanceNextNonspace(), this.addLine());
      }
      this.lastLineLength = e.length;
    }, i.prototype.parse = function(e, r) {
      this.doc = dj(), this.tip = this.doc, this.lineNumber = 0, this.lastLineLength = 0, this.offset = 0, this.column = 0, this.lastMatchedContainer = this.doc, this.currentLine = "";
      var s = e.split(N8e), l = s.length;
      this.lines = r || s, this.options.referenceDefinition && this.clearRefMaps(), e.charCodeAt(e.length - 1) === h3 && (l -= 1);
      for (var c = 0; c < l; c++)
        this.incorporateLine(s[c]);
      for (; this.tip; )
        this.finalize(this.tip, l);
      return this.processInlines(this.doc), this.doc;
    }, i.prototype.partialParseStart = function(e, r) {
      this.doc = dj(), this.tip = this.doc, this.lineNumber = e - 1, this.lastLineLength = 0, this.offset = 0, this.column = 0, this.lastMatchedContainer = this.doc, this.currentLine = "";
      for (var s = r.length, l = 0; l < s; l++)
        this.incorporateLine(r[l]);
      return this.doc;
    }, i.prototype.partialParseExtends = function(e) {
      for (var r = 0; r < e.length; r++)
        this.incorporateLine(e[r]);
    }, i.prototype.partialParseFinish = function() {
      for (; this.tip; )
        this.finalize(this.tip, this.lineNumber);
      this.processInlines(this.doc);
    }, i.prototype.setRefMaps = function(e, r, s) {
      this.refMap = e, this.refLinkCandidateMap = r, this.refDefCandidateMap = s;
    }, i.prototype.clearRefMaps = function() {
      [this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function(e) {
        SUe(e);
      });
    }, i;
  }()
);
function B8(i, e) {
  return i[0] < e[0] ? 1 : i[0] > e[0] ? -1 : i[1] < e[1] ? 1 : i[1] > e[1] ? -1 : 0;
}
function z8e(i, e) {
  var r = i[0], s = i[1];
  return B8(s, e) === 1 ? 1 : B8(r, e) === -1 ? -1 : 0;
}
function H8e(i, e) {
  if (!(i.parent !== e.parent || i === e)) {
    for (var r = i.next; r && r !== e; ) {
      for (var s = r.next, l = 0, c = ["parent", "prev", "next"]; l < c.length; l++) {
        var f = c[l];
        r[f] && (f3(r[f].id), r[f] = null);
      }
      r = s;
    }
    i.next = e.next, e.next ? e.next.prev = i : i.parent.lastChild = i;
  }
}
function j8e(i) {
  for (var e = [], r = i.firstChild; r; )
    e.push(r), r = r.next;
  return e;
}
function F8(i, e) {
  for (var r = 0, s = e; r < s.length; r++) {
    var l = s[r];
    i.insertBefore(l);
  }
}
function W8e(i, e) {
  for (var r = e.length - 1; r >= 0; r -= 1)
    i.prependChild(e[r]);
}
function $8e(i, e) {
  if (!(!i || !i.parent || e === 0)) {
    var r = i.parent.walker();
    r.resumeAt(i, !0);
    for (var s; s = r.next(); ) {
      var l = s.node, c = s.entering;
      c && (l.sourcepos[0][0] += e, l.sourcepos[1][0] += e);
    }
  }
}
function i9(i, e) {
  var r = i[0], s = i[1];
  return s[0] < e ? 1 : r[0] > e ? -1 : 0;
}
function $w(i, e) {
  for (var r = i.firstChild; r; ) {
    var s = i9(r.sourcepos, e);
    if (s === 0)
      return r;
    if (s === -1)
      return r.prev || r;
    r = r.next;
  }
  return i.lastChild;
}
function U8e(i) {
  for (; i.lastChild; )
    i = i.lastChild;
  return i;
}
function V8e(i) {
  for (; i.parent && i.parent.type !== "document" && i.parent.sourcepos[0][0] === i.sourcepos[0][0]; )
    i = i.parent;
  return i;
}
function G8e(i, e) {
  for (var r = i.firstChild, s = null; r; ) {
    var l = i9(r.sourcepos, e);
    if (l === 0) {
      if (r.sourcepos[0][0] === e || !r.firstChild)
        return r;
      s = r, r = r.firstChild;
    } else {
      if (l === -1)
        break;
      s = r, r = r.next;
    }
  }
  return s ? V8e(U8e(s)) : null;
}
function Y8e(i, e) {
  for (var r = i, s = null; r; ) {
    var l = z8e(r.sourcepos, e);
    if (l === 0)
      if (r.firstChild)
        s = r, r = r.firstChild;
      else
        return r;
    else {
      if (l === -1)
        return s;
      if (r.next)
        r = r.next;
      else
        return s;
    }
  }
  return r;
}
function a9(i) {
  return P$e(i) || null;
}
function hj(i, e, r) {
  if (r === void 0 && (r = null), e)
    for (var s = e.walker(); e && e !== r; ) {
      i(e);
      var l = s.next();
      if (l)
        e = l.node;
      else
        break;
    }
}
function q8e(i) {
  var e = a9(i);
  if (!e)
    return !0;
  for (; e && e.type !== "document"; ) {
    if (!e.parent && !e.prev && !e.next)
      return !0;
    e = e.parent;
  }
  return !1;
}
var z8 = /\r\n|\n|\r/;
function K8e(i) {
  var e = i.match(/^[ \t]+/);
  if (e && (e[0].length >= 2 || /\t/.test(e[0])))
    return !0;
  var r = e ? i.slice(e.length) : i;
  return e9.test(r) || t9.test(r);
}
function X8e(i) {
  return !Z4(i) && i.indexOf("|") !== -1;
}
function m3(i) {
  var e = i.id, r = i.title, s = i.sourcepos, l = i.dest;
  return {
    id: e,
    title: r,
    sourcepos: s,
    unlinked: !1,
    destination: l
  };
}
var o9 = (
  /** @class */
  function() {
    function i(e, r) {
      this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.referenceDefinition = !!(r != null && r.referenceDefinition), this.parser = new F8e(r), this.parser.setRefMaps(this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap), this.eventHandlerMap = { change: [] }, e = e || "", this.lineTexts = e.split(z8), this.root = this.parser.parse(e, this.lineTexts);
    }
    return i.prototype.updateLineTexts = function(e, r, s) {
      var l, c = e[0], f = e[1], p = r[0], d = r[1], m = s.split(z8), y = m.length, S = this.lineTexts[c - 1], x = this.lineTexts[p - 1];
      m[0] = S.slice(0, f - 1) + m[0], m[y - 1] = m[y - 1] + x.slice(d - 1);
      var w = p - c + 1;
      return (l = this.lineTexts).splice.apply(l, l3([c - 1, w], m)), y - w;
    }, i.prototype.updateRootNodeState = function() {
      if (this.lineTexts.length === 1 && this.lineTexts[0] === "") {
        this.root.lastLineBlank = !0, this.root.sourcepos = [
          [1, 1],
          [1, 0]
        ];
        return;
      }
      this.root.lastChild && (this.root.lastLineBlank = this.root.lastChild.lastLineBlank);
      for (var e = this.lineTexts, r = e.length - 1; e[r] === ""; )
        r -= 1;
      e.length - 2 > r && (r += 1), this.root.sourcepos[1] = [r + 1, e[r].length];
    }, i.prototype.replaceRangeNodes = function(e, r, s) {
      e ? (F8(e, s), H8e(e, r), [e.id, r.id].forEach(function(l) {
        return f3(l);
      }), e.unlink()) : r ? (F8(r, s), f3(r.id), r.unlink()) : W8e(this.root, s);
    }, i.prototype.getNodeRange = function(e, r) {
      var s = $w(this.root, e[0]), l = $w(this.root, r[0]);
      return l && l.next && r[0] + 1 === l.next.sourcepos[0][0] && (l = l.next), [s, l];
    }, i.prototype.trigger = function(e, r) {
      this.eventHandlerMap[e].forEach(function(s) {
        s(r);
      });
    }, i.prototype.extendEndLine = function(e) {
      for (; this.lineTexts[e] === ""; )
        e += 1;
      return e;
    }, i.prototype.parseRange = function(e, r, s, l) {
      e && e.prev && (T8(e.prev) && K8e(this.lineTexts[s - 1]) || Y$e(e.prev) && X8e(this.lineTexts[s - 1])) && (e = e.prev, s = e.sourcepos[0][0]);
      for (var c = this.lineTexts.slice(s - 1, l), f = this.parser.partialParseStart(s, c), p = r ? r.next : this.root.firstChild, d = f.lastChild, m = d && W4(d) && d.open, y = d && $4(d) && d.open, S = d && T8(d); (m || y) && p || S && p && (p.type === "list" || p.sourcepos[0][1] >= 2); ) {
        var x = this.extendEndLine(p.sourcepos[1][0]);
        this.parser.partialParseExtends(this.lineTexts.slice(l, x)), e || (e = r), r = p, l = x, p = p.next;
      }
      this.parser.partialParseFinish();
      var w = j8e(f);
      return { newNodes: w, extStartNode: e, extEndNode: r };
    }, i.prototype.getRemovedNodeRange = function(e, r) {
      return !e || e && Xh(e) || r && Xh(r) ? null : {
        id: [e.id, r.id],
        line: [e.sourcepos[0][0] - 1, r.sourcepos[1][0] - 1]
      };
    }, i.prototype.markDeletedRefMap = function(e, r) {
      var s = this;
      if (!Jh(this.refMap)) {
        var l = function(c) {
          if (Xh(c)) {
            var f = s.refMap[c.label];
            f && c.id === f.id && (f.unlinked = !0);
          }
        };
        e && hj(l, e.parent, r), r && hj(l, r);
      }
    }, i.prototype.replaceWithNewRefDefState = function(e) {
      var r = this;
      if (!Jh(this.refMap)) {
        var s = function(l) {
          if (Xh(l)) {
            var c = l.label, f = r.refMap[c];
            (!f || f.unlinked) && (r.refMap[c] = m3(l));
          }
        };
        e.forEach(function(l) {
          hj(s, l);
        });
      }
    }, i.prototype.replaceWithRefDefCandidate = function() {
      var e = this;
      Jh(this.refDefCandidateMap) || Hw(this.refDefCandidateMap, function(r, s) {
        var l = s.label, c = s.sourcepos, f = e.refMap[l];
        (!f || f.unlinked || f.sourcepos[0][0] > c[0][0]) && (e.refMap[l] = m3(s));
      });
    }, i.prototype.getRangeWithRefDef = function(e, r, s, l, c) {
      if (this.referenceDefinition && !Jh(this.refMap)) {
        var f = $w(this.root, e - 1), p = $w(this.root, r + 1);
        f && Xh(f) && f !== s && f !== l && (s = f, e = s.sourcepos[0][0]), p && Xh(p) && p !== s && p !== l && (l = p, r = this.extendEndLine(l.sourcepos[1][0] + c));
      }
      return [s, l, e, r];
    }, i.prototype.parse = function(e, r, s) {
      s === void 0 && (s = 0);
      var l = this.getNodeRange(e, r), c = l[0], f = l[1], p = c ? Math.min(c.sourcepos[0][0], e[0]) : e[0], d = this.extendEndLine((f ? Math.max(f.sourcepos[1][0], r[0]) : r[0]) + s), m = this.parseRange.apply(this, this.getRangeWithRefDef(p, d, c, f, s)), y = m.newNodes, S = m.extStartNode, x = m.extEndNode, w = this.getRemovedNodeRange(S, x), k = x ? x.next : this.root.firstChild;
      return this.referenceDefinition ? (this.markDeletedRefMap(S, x), this.replaceRangeNodes(S, x, y), this.replaceWithNewRefDefState(y)) : this.replaceRangeNodes(S, x, y), { nodes: y, removedNodeRange: w, nextNode: k };
    }, i.prototype.parseRefLink = function() {
      var e = this, r = [];
      return Jh(this.refMap) || Hw(this.refMap, function(s, l) {
        l.unlinked && delete e.refMap[s], Hw(e.refLinkCandidateMap, function(c, f) {
          var p = f.node, d = f.refLabel;
          d === s && r.push(e.parse(p.sourcepos[0], p.sourcepos[1]));
        });
      }), r;
    }, i.prototype.removeUnlinkedCandidate = function() {
      Jh(this.refDefCandidateMap) || [this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function(e) {
        Hw(e, function(r) {
          q8e(r) && delete e[r];
        });
      });
    }, i.prototype.editMarkdown = function(e, r, s) {
      var l = this.updateLineTexts(e, r, s), c = this.parse(e, r, l), f = bUe(c, "nextNode");
      $8e(c.nextNode, l), this.updateRootNodeState();
      var p = [f];
      return this.referenceDefinition && (this.removeUnlinkedCandidate(), this.replaceWithRefDefCandidate(), p = p.concat(this.parseRefLink())), this.trigger("change", p), p;
    }, i.prototype.getLineTexts = function() {
      return this.lineTexts;
    }, i.prototype.getRootNode = function() {
      return this.root;
    }, i.prototype.findNodeAtPosition = function(e) {
      var r = Y8e(this.root, e);
      return !r || r === this.root ? null : r;
    }, i.prototype.findFirstNodeAtLine = function(e) {
      return G8e(this.root, e);
    }, i.prototype.on = function(e, r) {
      this.eventHandlerMap[e].push(r);
    }, i.prototype.off = function(e, r) {
      var s = this.eventHandlerMap[e], l = s.indexOf(r);
      s.splice(l, 1);
    }, i.prototype.findNodeById = function(e) {
      return a9(e);
    }, i.prototype.removeAllNode = function() {
      L$e();
    }, i;
  }()
), J8e = [
  "title",
  "textarea",
  "style",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "script",
  "plaintext"
], H8 = new RegExp("<(/?(?:" + J8e.join("|") + ")[^>]*>)", "ig");
function j8(i) {
  return H8.test(i) ? i.replace(H8, function(e, r) {
    return "&lt;" + r;
  }) : i;
}
var W8 = {
  heading: function(i, e) {
    var r = e.entering;
    return {
      type: r ? "openTag" : "closeTag",
      tagName: "h" + i.level,
      outerNewLine: !0
    };
  },
  text: function(i) {
    return {
      type: "text",
      content: i.literal
    };
  },
  softbreak: function(i, e) {
    var r = e.options;
    return {
      type: "html",
      content: r.softbreak
    };
  },
  linebreak: function() {
    return {
      type: "html",
      content: `<br />
`
    };
  },
  emph: function(i, e) {
    var r = e.entering;
    return {
      type: r ? "openTag" : "closeTag",
      tagName: "em"
    };
  },
  strong: function(i, e) {
    var r = e.entering;
    return {
      type: r ? "openTag" : "closeTag",
      tagName: "strong"
    };
  },
  paragraph: function(i, e) {
    var r, s = e.entering, l = (r = i.parent) === null || r === void 0 ? void 0 : r.parent;
    return l && l.type === "list" && l.listData.tight ? null : {
      type: s ? "openTag" : "closeTag",
      tagName: "p",
      outerNewLine: !0
    };
  },
  thematicBreak: function() {
    return {
      type: "openTag",
      tagName: "hr",
      outerNewLine: !0,
      selfClose: !0
    };
  },
  blockQuote: function(i, e) {
    var r = e.entering;
    return {
      type: r ? "openTag" : "closeTag",
      tagName: "blockquote",
      outerNewLine: !0,
      innerNewLine: !0
    };
  },
  list: function(i, e) {
    var r = e.entering, s = i.listData, l = s.type, c = s.start, f = l === "bullet" ? "ul" : "ol", p = {};
    return f === "ol" && c !== null && c !== 1 && (p.start = c.toString()), {
      type: r ? "openTag" : "closeTag",
      tagName: f,
      attributes: p,
      outerNewLine: !0
    };
  },
  item: function(i, e) {
    var r = e.entering;
    return {
      type: r ? "openTag" : "closeTag",
      tagName: "li",
      outerNewLine: !0
    };
  },
  htmlInline: function(i, e) {
    var r = e.options, s = r.tagFilter ? j8(i.literal) : i.literal;
    return { type: "html", content: s };
  },
  htmlBlock: function(i, e) {
    var r = e.options, s = r.tagFilter ? j8(i.literal) : i.literal;
    return r.nodeId ? [
      { type: "openTag", tagName: "div", outerNewLine: !0 },
      { type: "html", content: s },
      { type: "closeTag", tagName: "div", outerNewLine: !0 }
    ] : { type: "html", content: s, outerNewLine: !0 };
  },
  code: function(i) {
    return [
      { type: "openTag", tagName: "code" },
      { type: "text", content: i.literal },
      { type: "closeTag", tagName: "code" }
    ];
  },
  codeBlock: function(i) {
    var e = i.info, r = e ? e.split(/\s+/) : [], s = [];
    return r.length > 0 && r[0].length > 0 && s.push("language-" + rp(r[0])), [
      { type: "openTag", tagName: "pre", outerNewLine: !0 },
      { type: "openTag", tagName: "code", classNames: s },
      { type: "text", content: i.literal },
      { type: "closeTag", tagName: "code" },
      { type: "closeTag", tagName: "pre", outerNewLine: !0 }
    ];
  },
  link: function(i, e) {
    var r = e.entering;
    if (r) {
      var s = i, l = s.title, c = s.destination;
      return {
        type: "openTag",
        tagName: "a",
        attributes: Ai({ href: rp(c) }, l && { title: rp(l) })
      };
    }
    return { type: "closeTag", tagName: "a" };
  },
  image: function(i, e) {
    var r = e.getChildrenText, s = e.skipChildren, l = i, c = l.title, f = l.destination;
    return s(), {
      type: "openTag",
      tagName: "img",
      selfClose: !0,
      attributes: Ai({ src: rp(f), alt: r(i) }, c && { title: rp(c) })
    };
  },
  customBlock: function(i, e, r) {
    var s = i.info.trim().toLowerCase(), l = r[s];
    if (l)
      try {
        return l(i, e);
      } catch (c) {
        console.warn("[@toast-ui/editor] - The error occurred when " + s + " block node was parsed in markdown renderer: " + c);
      }
    return [
      { type: "openTag", tagName: "div", outerNewLine: !0 },
      { type: "text", content: i.literal },
      { type: "closeTag", tagName: "div", outerNewLine: !0 }
    ];
  },
  frontMatter: function(i) {
    return [
      {
        type: "openTag",
        tagName: "div",
        outerNewLine: !0,
        // Because front matter is metadata, it should not be render.
        attributes: { style: "white-space: pre; display: none;" }
      },
      { type: "text", content: i.literal },
      { type: "closeTag", tagName: "div", outerNewLine: !0 }
    ];
  },
  customInline: function(i, e, r) {
    var s = i, l = s.info, c = s.firstChild, f = l.trim().toLowerCase(), p = r[f], d = e.entering;
    if (p)
      try {
        return p(i, e);
      } catch (m) {
        console.warn("[@toast-ui/editor] - The error occurred when " + f + " inline node was parsed in markdown renderer: " + m);
      }
    return d ? [
      { type: "openTag", tagName: "span" },
      { type: "text", content: "$$" + l + (c ? " " : "") }
    ] : [
      { type: "text", content: "$$" },
      { type: "closeTag", tagName: "span" }
    ];
  }
}, $8 = {
  strike: function(i, e) {
    var r = e.entering;
    return {
      type: r ? "openTag" : "closeTag",
      tagName: "del"
    };
  },
  item: function(i, e) {
    var r = e.entering, s = i.listData, l = s.checked, c = s.task;
    if (r) {
      var f = {
        type: "openTag",
        tagName: "li",
        outerNewLine: !0
      };
      return c ? [
        f,
        {
          type: "openTag",
          tagName: "input",
          selfClose: !0,
          attributes: Ai(Ai({}, l && { checked: "" }), { disabled: "", type: "checkbox" })
        },
        {
          type: "text",
          content: " "
        }
      ] : f;
    }
    return {
      type: "closeTag",
      tagName: "li",
      outerNewLine: !0
    };
  },
  table: function(i, e) {
    var r = e.entering;
    return {
      type: r ? "openTag" : "closeTag",
      tagName: "table",
      outerNewLine: !0
    };
  },
  tableHead: function(i, e) {
    var r = e.entering;
    return {
      type: r ? "openTag" : "closeTag",
      tagName: "thead",
      outerNewLine: !0
    };
  },
  tableBody: function(i, e) {
    var r = e.entering;
    return {
      type: r ? "openTag" : "closeTag",
      tagName: "tbody",
      outerNewLine: !0
    };
  },
  tableRow: function(i, e) {
    var r = e.entering;
    if (r)
      return {
        type: "openTag",
        tagName: "tr",
        outerNewLine: !0
      };
    var s = [];
    if (i.lastChild)
      for (var l = i.parent.parent.columns.length, c = i.lastChild.endIdx, f = c + 1; f < l; f += 1)
        s.push({
          type: "openTag",
          tagName: "td",
          outerNewLine: !0
        }, {
          type: "closeTag",
          tagName: "td",
          outerNewLine: !0
        });
    return s.push({
      type: "closeTag",
      tagName: "tr",
      outerNewLine: !0
    }), s;
  },
  tableCell: function(i, e) {
    var r = e.entering;
    if (i.ignored)
      return {
        type: "text",
        content: ""
      };
    var s = i.parent.parent, l = s.type === "tableHead" ? "th" : "td", c = s.parent, f = c.columns[i.startIdx], p = f != null && f.align ? { align: f.align } : null;
    return r ? Ai({ type: "openTag", tagName: l, outerNewLine: !0 }, p && { attributes: p }) : {
      type: "closeTag",
      tagName: l,
      outerNewLine: !0
    };
  }
}, Z8e = {
  softbreak: `
`,
  gfm: !1,
  tagFilter: !1,
  nodeId: !1
};
function Q8e(i) {
  for (var e = [], r = i.walker(), s = null; s = r.next(); ) {
    var l = s.node;
    l.type === "text" && e.push(l.literal);
  }
  return e.join("");
}
var mW = (
  /** @class */
  function() {
    function i(e) {
      this.buffer = [], this.options = Ai(Ai({}, Z8e), e), this.convertors = this.createConvertors(), delete this.options.convertors;
    }
    return i.prototype.createConvertors = function() {
      var e = Ai({}, W8);
      if (this.options.gfm && (e = Ai(Ai({}, e), $8)), this.options.convertors) {
        var r = this.options.convertors, s = Object.keys(r), l = Ai(Ai({}, W8), $8);
        s.forEach(function(c) {
          var f = e[c], p = r[c], d = Object.keys(l).indexOf(c) === -1 ? c.toLowerCase() : c;
          f ? e[d] = function(m, y, S) {
            return y.origin = function() {
              return f(m, y, S);
            }, p(m, y);
          } : e[d] = p;
        });
      }
      return e;
    }, i.prototype.getConvertors = function() {
      return this.convertors;
    }, i.prototype.getOptions = function() {
      return this.options;
    }, i.prototype.render = function(e) {
      var r = this;
      this.buffer = [];
      for (var s = e.walker(), l = null, c = function() {
        var p = l.node, d = l.entering, m = f.convertors[p.type];
        if (!m)
          return "continue";
        var y = !1, S = {
          entering: d,
          leaf: !vW(p),
          options: f.options,
          getChildrenText: Q8e,
          skipChildren: function() {
            y = !0;
          }
        }, x = $4(p) || q$e(p) ? m(p, S, f.convertors) : m(p, S);
        if (x) {
          var w = Array.isArray(x) ? x : [x];
          w.forEach(function(k, O) {
            k.type === "openTag" && r.options.nodeId && O === 0 && (k.attributes || (k.attributes = {}), k.attributes["data-nodeid"] = String(p.id)), r.renderHTMLNode(k);
          }), y && (s.resumeAt(p, !1), s.next());
        }
      }, f = this; l = s.next(); )
        c();
      return this.addNewLine(), this.buffer.join("");
    }, i.prototype.renderHTMLNode = function(e) {
      switch (e.type) {
        case "openTag":
        case "closeTag":
          this.renderElementNode(e);
          break;
        case "text":
          this.renderTextNode(e);
          break;
        case "html":
          this.renderRawHtmlNode(e);
          break;
      }
    }, i.prototype.generateOpenTagString = function(e) {
      var r = this, s = e.tagName, l = e.classNames, c = e.attributes;
      this.buffer.push("<" + s), l && l.length > 0 && this.buffer.push(' class="' + l.join(" ") + '"'), c && Object.keys(c).forEach(function(f) {
        var p = c[f];
        r.buffer.push(" " + f + '="' + p + '"');
      }), e.selfClose && this.buffer.push(" /"), this.buffer.push(">");
    }, i.prototype.generateCloseTagString = function(e) {
      var r = e.tagName;
      this.buffer.push("</" + r + ">");
    }, i.prototype.addNewLine = function() {
      this.buffer.length && Cx(Cx(this.buffer)) !== `
` && this.buffer.push(`
`);
    }, i.prototype.addOuterNewLine = function(e) {
      e.outerNewLine && this.addNewLine();
    }, i.prototype.addInnerNewLine = function(e) {
      e.innerNewLine && this.addNewLine();
    }, i.prototype.renderTextNode = function(e) {
      this.buffer.push(rp(e.content));
    }, i.prototype.renderRawHtmlNode = function(e) {
      this.addOuterNewLine(e), this.buffer.push(e.content), this.addOuterNewLine(e);
    }, i.prototype.renderElementNode = function(e) {
      e.type === "openTag" ? (this.addOuterNewLine(e), this.generateOpenTagString(e), e.selfClose ? this.addOuterNewLine(e) : this.addInnerNewLine(e)) : (this.addInnerNewLine(e), this.generateCloseTagString(e), this.addOuterNewLine(e));
    }, i;
  }()
);
/*! @license DOMPurify 2.3.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.3/LICENSE */
function e5e(i) {
  if (Array.isArray(i)) {
    for (var e = 0, r = Array(i.length); e < i.length; e++)
      r[e] = i[e];
    return r;
  } else
    return Array.from(i);
}
var t5e = Object.hasOwnProperty, U8 = Object.setPrototypeOf, r5e = Object.isFrozen, n5e = Object.getPrototypeOf, i5e = Object.getOwnPropertyDescriptor, Sa = Object.freeze, Cl = Object.seal, a5e = Object.create, s9 = typeof Reflect < "u" && Reflect, Ax = s9.apply, g3 = s9.construct;
Ax || (Ax = function(e, r, s) {
  return e.apply(r, s);
});
Sa || (Sa = function(e) {
  return e;
});
Cl || (Cl = function(e) {
  return e;
});
g3 || (g3 = function(e, r) {
  return new (Function.prototype.bind.apply(e, [null].concat(e5e(r))))();
});
var o5e = ms(Array.prototype.forEach), V8 = ms(Array.prototype.pop), Pg = ms(Array.prototype.push), Zw = ms(String.prototype.toLowerCase), G8 = ms(String.prototype.match), yu = ms(String.prototype.replace), s5e = ms(String.prototype.indexOf), l5e = ms(String.prototype.trim), pl = ms(RegExp.prototype.test), Y8 = u5e(TypeError);
function ms(i) {
  return function(e) {
    for (var r = arguments.length, s = Array(r > 1 ? r - 1 : 0), l = 1; l < r; l++)
      s[l - 1] = arguments[l];
    return Ax(i, e, s);
  };
}
function u5e(i) {
  return function() {
    for (var e = arguments.length, r = Array(e), s = 0; s < e; s++)
      r[s] = arguments[s];
    return g3(i, r);
  };
}
function Fr(i, e) {
  U8 && U8(i, null);
  for (var r = e.length; r--; ) {
    var s = e[r];
    if (typeof s == "string") {
      var l = Zw(s);
      l !== s && (r5e(e) || (e[r] = l), s = l);
    }
    i[s] = !0;
  }
  return i;
}
function Tc(i) {
  var e = a5e(null), r = void 0;
  for (r in i)
    Ax(t5e, i, [r]) && (e[r] = i[r]);
  return e;
}
function Uw(i, e) {
  for (; i !== null; ) {
    var r = i5e(i, e);
    if (r) {
      if (r.get)
        return ms(r.get);
      if (typeof r.value == "function")
        return ms(r.value);
    }
    i = n5e(i);
  }
  function s(l) {
    return console.warn("fallback value for", l), null;
  }
  return s;
}
var q8 = Sa(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), pj = Sa(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), vj = Sa(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), c5e = Sa(["animate", "color-profile", "cursor", "discard", "fedropshadow", "feimage", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), mj = Sa(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), f5e = Sa(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), K8 = Sa(["#text"]), X8 = Sa(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), gj = Sa(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), J8 = Sa(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Vw = Sa(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), d5e = Cl(/\{\{[\s\S]*|[\s\S]*\}\}/gm), h5e = Cl(/<%[\s\S]*|[\s\S]*%>/gm), p5e = Cl(/^data-[\-\w.\u00B7-\uFFFF]/), v5e = Cl(/^aria-[\-\w]+$/), m5e = Cl(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), g5e = Cl(/^(?:\w+script|data):/i), y5e = Cl(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), Wg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(i) {
  return typeof i;
} : function(i) {
  return i && typeof Symbol == "function" && i.constructor === Symbol && i !== Symbol.prototype ? "symbol" : typeof i;
};
function Ps(i) {
  if (Array.isArray(i)) {
    for (var e = 0, r = Array(i.length); e < i.length; e++)
      r[e] = i[e];
    return r;
  } else
    return Array.from(i);
}
var b5e = function() {
  return typeof window > "u" ? null : window;
}, S5e = function(e, r) {
  if ((typeof e > "u" ? "undefined" : Wg(e)) !== "object" || typeof e.createPolicy != "function")
    return null;
  var s = null, l = "data-tt-policy-suffix";
  r.currentScript && r.currentScript.hasAttribute(l) && (s = r.currentScript.getAttribute(l));
  var c = "dompurify" + (s ? "#" + s : "");
  try {
    return e.createPolicy(c, {
      createHTML: function(p) {
        return p;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + c + " could not be created."), null;
  }
};
function l9() {
  var i = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : b5e(), e = function(ct) {
    return l9(ct);
  };
  if (e.version = "2.3.3", e.removed = [], !i || !i.document || i.document.nodeType !== 9)
    return e.isSupported = !1, e;
  var r = i.document, s = i.document, l = i.DocumentFragment, c = i.HTMLTemplateElement, f = i.Node, p = i.Element, d = i.NodeFilter, m = i.NamedNodeMap, y = m === void 0 ? i.NamedNodeMap || i.MozNamedAttrMap : m, S = i.Text, x = i.Comment, w = i.DOMParser, k = i.trustedTypes, O = p.prototype, T = Uw(O, "cloneNode"), L = Uw(O, "nextSibling"), j = Uw(O, "childNodes"), z = Uw(O, "parentNode");
  if (typeof c == "function") {
    var J = s.createElement("template");
    J.content && J.content.ownerDocument && (s = J.content.ownerDocument);
  }
  var ie = S5e(k, r), K = ie && _e ? ie.createHTML("") : "", re = s, ee = re.implementation, de = re.createNodeIterator, Ce = re.createDocumentFragment, he = re.getElementsByTagName, oe = r.importNode, ge = {};
  try {
    ge = Tc(s).documentMode ? s.documentMode : {};
  } catch {
  }
  var we = {};
  e.isSupported = typeof z == "function" && ee && typeof ee.createHTMLDocument < "u" && ge !== 9;
  var Oe = d5e, Qe = h5e, Me = p5e, Ie = v5e, rt = g5e, ot = y5e, Et = m5e, gt = null, At = Fr({}, [].concat(Ps(q8), Ps(pj), Ps(vj), Ps(mj), Ps(K8))), Mt = null, St = Fr({}, [].concat(Ps(X8), Ps(gj), Ps(J8), Ps(Vw))), Ve = null, Ue = null, He = !0, We = !0, ze = !1, at = !1, Ye = !1, tt = !1, wt = !1, Ft = !1, qe = !1, pe = !0, _e = !1, Xe = !0, lt = !0, Q = !1, te = {}, De = null, nt = Fr({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), be = null, G = Fr({}, ["audio", "video", "img", "source", "image", "track"]), V = null, ve = Fr({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Ne = "http://www.w3.org/1998/Math/MathML", it = "http://www.w3.org/2000/svg", yt = "http://www.w3.org/1999/xhtml", $t = yt, Gt = !1, Jt = void 0, Xt = ["application/xhtml+xml", "text/html"], Ae = "text/html", vt = void 0, Ot = null, Vt = s.createElement("form"), et = function(ct) {
    Ot && Ot === ct || ((!ct || (typeof ct > "u" ? "undefined" : Wg(ct)) !== "object") && (ct = {}), ct = Tc(ct), gt = "ALLOWED_TAGS" in ct ? Fr({}, ct.ALLOWED_TAGS) : At, Mt = "ALLOWED_ATTR" in ct ? Fr({}, ct.ALLOWED_ATTR) : St, V = "ADD_URI_SAFE_ATTR" in ct ? Fr(Tc(ve), ct.ADD_URI_SAFE_ATTR) : ve, be = "ADD_DATA_URI_TAGS" in ct ? Fr(Tc(G), ct.ADD_DATA_URI_TAGS) : G, De = "FORBID_CONTENTS" in ct ? Fr({}, ct.FORBID_CONTENTS) : nt, Ve = "FORBID_TAGS" in ct ? Fr({}, ct.FORBID_TAGS) : {}, Ue = "FORBID_ATTR" in ct ? Fr({}, ct.FORBID_ATTR) : {}, te = "USE_PROFILES" in ct ? ct.USE_PROFILES : !1, He = ct.ALLOW_ARIA_ATTR !== !1, We = ct.ALLOW_DATA_ATTR !== !1, ze = ct.ALLOW_UNKNOWN_PROTOCOLS || !1, at = ct.SAFE_FOR_TEMPLATES || !1, Ye = ct.WHOLE_DOCUMENT || !1, Ft = ct.RETURN_DOM || !1, qe = ct.RETURN_DOM_FRAGMENT || !1, pe = ct.RETURN_DOM_IMPORT !== !1, _e = ct.RETURN_TRUSTED_TYPE || !1, wt = ct.FORCE_BODY || !1, Xe = ct.SANITIZE_DOM !== !1, lt = ct.KEEP_CONTENT !== !1, Q = ct.IN_PLACE || !1, Et = ct.ALLOWED_URI_REGEXP || Et, $t = ct.NAMESPACE || yt, Jt = // eslint-disable-next-line unicorn/prefer-includes
    Xt.indexOf(ct.PARSER_MEDIA_TYPE) === -1 ? Jt = Ae : Jt = ct.PARSER_MEDIA_TYPE, vt = Jt === "application/xhtml+xml" ? function(zt) {
      return zt;
    } : Zw, at && (We = !1), qe && (Ft = !0), te && (gt = Fr({}, [].concat(Ps(K8))), Mt = [], te.html === !0 && (Fr(gt, q8), Fr(Mt, X8)), te.svg === !0 && (Fr(gt, pj), Fr(Mt, gj), Fr(Mt, Vw)), te.svgFilters === !0 && (Fr(gt, vj), Fr(Mt, gj), Fr(Mt, Vw)), te.mathMl === !0 && (Fr(gt, mj), Fr(Mt, J8), Fr(Mt, Vw))), ct.ADD_TAGS && (gt === At && (gt = Tc(gt)), Fr(gt, ct.ADD_TAGS)), ct.ADD_ATTR && (Mt === St && (Mt = Tc(Mt)), Fr(Mt, ct.ADD_ATTR)), ct.ADD_URI_SAFE_ATTR && Fr(V, ct.ADD_URI_SAFE_ATTR), ct.FORBID_CONTENTS && (De === nt && (De = Tc(De)), Fr(De, ct.FORBID_CONTENTS)), lt && (gt["#text"] = !0), Ye && Fr(gt, ["html", "head", "body"]), gt.table && (Fr(gt, ["tbody"]), delete Ve.tbody), Sa && Sa(ct), Ot = ct);
  }, ft = Fr({}, ["mi", "mo", "mn", "ms", "mtext"]), $ = Fr({}, ["foreignobject", "desc", "title", "annotation-xml"]), Se = Fr({}, pj);
  Fr(Se, vj), Fr(Se, c5e);
  var se = Fr({}, mj);
  Fr(se, f5e);
  var M = function(ct) {
    var zt = z(ct);
    (!zt || !zt.tagName) && (zt = {
      namespaceURI: yt,
      tagName: "template"
    });
    var xe = Zw(ct.tagName), ae = Zw(zt.tagName);
    if (ct.namespaceURI === it)
      return zt.namespaceURI === yt ? xe === "svg" : zt.namespaceURI === Ne ? xe === "svg" && (ae === "annotation-xml" || ft[ae]) : !!Se[xe];
    if (ct.namespaceURI === Ne)
      return zt.namespaceURI === yt ? xe === "math" : zt.namespaceURI === it ? xe === "math" && $[ae] : !!se[xe];
    if (ct.namespaceURI === yt) {
      if (zt.namespaceURI === it && !$[ae] || zt.namespaceURI === Ne && !ft[ae])
        return !1;
      var _ = Fr({}, ["title", "style", "font", "a", "script"]);
      return !se[xe] && (_[xe] || !Se[xe]);
    }
    return !1;
  }, ne = function(ct) {
    Pg(e.removed, { element: ct });
    try {
      ct.parentNode.removeChild(ct);
    } catch {
      try {
        ct.outerHTML = K;
      } catch {
        ct.remove();
      }
    }
  }, ce = function(ct, zt) {
    try {
      Pg(e.removed, {
        attribute: zt.getAttributeNode(ct),
        from: zt
      });
    } catch {
      Pg(e.removed, {
        attribute: null,
        from: zt
      });
    }
    if (zt.removeAttribute(ct), ct === "is" && !Mt[ct])
      if (Ft || qe)
        try {
          ne(zt);
        } catch {
        }
      else
        try {
          zt.setAttribute(ct, "");
        } catch {
        }
  }, X = function(ct) {
    var zt = void 0, xe = void 0;
    if (wt)
      ct = "<remove></remove>" + ct;
    else {
      var ae = G8(ct, /^[\r\n\t ]+/);
      xe = ae && ae[0];
    }
    Jt === "application/xhtml+xml" && (ct = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + ct + "</body></html>");
    var _ = ie ? ie.createHTML(ct) : ct;
    if ($t === yt)
      try {
        zt = new w().parseFromString(_, Jt);
      } catch {
      }
    if (!zt || !zt.documentElement) {
      zt = ee.createDocument($t, "template", null);
      try {
        zt.documentElement.innerHTML = Gt ? "" : _;
      } catch {
      }
    }
    var U = zt.body || zt.documentElement;
    return ct && xe && U.insertBefore(s.createTextNode(xe), U.childNodes[0] || null), $t === yt ? he.call(zt, Ye ? "html" : "body")[0] : Ye ? zt.documentElement : U;
  }, Re = function(ct) {
    return de.call(ct.ownerDocument || ct, ct, d.SHOW_ELEMENT | d.SHOW_COMMENT | d.SHOW_TEXT, null, !1);
  }, Ge = function(ct) {
    return ct instanceof S || ct instanceof x ? !1 : typeof ct.nodeName != "string" || typeof ct.textContent != "string" || typeof ct.removeChild != "function" || !(ct.attributes instanceof y) || typeof ct.removeAttribute != "function" || typeof ct.setAttribute != "function" || typeof ct.namespaceURI != "string" || typeof ct.insertBefore != "function";
  }, pt = function(ct) {
    return (typeof f > "u" ? "undefined" : Wg(f)) === "object" ? ct instanceof f : ct && (typeof ct > "u" ? "undefined" : Wg(ct)) === "object" && typeof ct.nodeType == "number" && typeof ct.nodeName == "string";
  }, xt = function(ct, zt, xe) {
    we[ct] && o5e(we[ct], function(ae) {
      ae.call(e, zt, xe, Ot);
    });
  }, Pt = function(ct) {
    var zt = void 0;
    if (xt("beforeSanitizeElements", ct, null), Ge(ct) || G8(ct.nodeName, /[\u0080-\uFFFF]/))
      return ne(ct), !0;
    var xe = vt(ct.nodeName);
    if (xt("uponSanitizeElement", ct, {
      tagName: xe,
      allowedTags: gt
    }), !pt(ct.firstElementChild) && (!pt(ct.content) || !pt(ct.content.firstElementChild)) && pl(/<[/\w]/g, ct.innerHTML) && pl(/<[/\w]/g, ct.textContent) || xe === "select" && pl(/<template/i, ct.innerHTML))
      return ne(ct), !0;
    if (!gt[xe] || Ve[xe]) {
      if (lt && !De[xe]) {
        var ae = z(ct) || ct.parentNode, _ = j(ct) || ct.childNodes;
        if (_ && ae)
          for (var U = _.length, fe = U - 1; fe >= 0; --fe)
            ae.insertBefore(T(_[fe], !0), L(ct));
      }
      return ne(ct), !0;
    }
    return ct instanceof p && !M(ct) || (xe === "noscript" || xe === "noembed") && pl(/<\/no(script|embed)/i, ct.innerHTML) ? (ne(ct), !0) : (at && ct.nodeType === 3 && (zt = ct.textContent, zt = yu(zt, Oe, " "), zt = yu(zt, Qe, " "), ct.textContent !== zt && (Pg(e.removed, { element: ct.cloneNode() }), ct.textContent = zt)), xt("afterSanitizeElements", ct, null), !1);
  }, Yt = function(ct, zt, xe) {
    if (Xe && (zt === "id" || zt === "name") && (xe in s || xe in Vt))
      return !1;
    if (!(We && !Ue[zt] && pl(Me, zt))) {
      if (!(He && pl(Ie, zt))) {
        if (!Mt[zt] || Ue[zt])
          return !1;
        if (!V[zt]) {
          if (!pl(Et, yu(xe, ot, ""))) {
            if (!((zt === "src" || zt === "xlink:href" || zt === "href") && ct !== "script" && s5e(xe, "data:") === 0 && be[ct])) {
              if (!(ze && !pl(rt, yu(xe, ot, "")))) {
                if (xe) return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, gr = function(ct) {
    var zt = void 0, xe = void 0, ae = void 0, _ = void 0;
    xt("beforeSanitizeAttributes", ct, null);
    var U = ct.attributes;
    if (U) {
      var fe = {
        attrName: "",
        attrValue: "",
        keepAttr: !0,
        allowedAttributes: Mt
      };
      for (_ = U.length; _--; ) {
        zt = U[_];
        var Te = zt, Be = Te.name, Je = Te.namespaceURI;
        if (xe = l5e(zt.value), ae = vt(Be), fe.attrName = ae, fe.attrValue = xe, fe.keepAttr = !0, fe.forceKeepAttr = void 0, xt("uponSanitizeAttribute", ct, fe), xe = fe.attrValue, !fe.forceKeepAttr && (ce(Be, ct), !!fe.keepAttr)) {
          if (pl(/\/>/i, xe)) {
            ce(Be, ct);
            continue;
          }
          at && (xe = yu(xe, Oe, " "), xe = yu(xe, Qe, " "));
          var Ct = vt(ct.nodeName);
          if (Yt(Ct, ae, xe))
            try {
              Je ? ct.setAttributeNS(Je, Be, xe) : ct.setAttribute(Be, xe), V8(e.removed);
            } catch {
            }
        }
      }
      xt("afterSanitizeAttributes", ct, null);
    }
  }, dr = function It(ct) {
    var zt = void 0, xe = Re(ct);
    for (xt("beforeSanitizeShadowDOM", ct, null); zt = xe.nextNode(); )
      xt("uponSanitizeShadowNode", zt, null), !Pt(zt) && (zt.content instanceof l && It(zt.content), gr(zt));
    xt("afterSanitizeShadowDOM", ct, null);
  };
  return e.sanitize = function(It, ct) {
    var zt = void 0, xe = void 0, ae = void 0, _ = void 0, U = void 0;
    if (Gt = !It, Gt && (It = "<!-->"), typeof It != "string" && !pt(It)) {
      if (typeof It.toString != "function")
        throw Y8("toString is not a function");
      if (It = It.toString(), typeof It != "string")
        throw Y8("dirty is not a string, aborting");
    }
    if (!e.isSupported) {
      if (Wg(i.toStaticHTML) === "object" || typeof i.toStaticHTML == "function") {
        if (typeof It == "string")
          return i.toStaticHTML(It);
        if (pt(It))
          return i.toStaticHTML(It.outerHTML);
      }
      return It;
    }
    if (tt || et(ct), e.removed = [], typeof It == "string" && (Q = !1), !Q) if (It instanceof f)
      zt = X("<!---->"), xe = zt.ownerDocument.importNode(It, !0), xe.nodeType === 1 && xe.nodeName === "BODY" || xe.nodeName === "HTML" ? zt = xe : zt.appendChild(xe);
    else {
      if (!Ft && !at && !Ye && // eslint-disable-next-line unicorn/prefer-includes
      It.indexOf("<") === -1)
        return ie && _e ? ie.createHTML(It) : It;
      if (zt = X(It), !zt)
        return Ft ? null : K;
    }
    zt && wt && ne(zt.firstChild);
    for (var fe = Re(Q ? It : zt); ae = fe.nextNode(); )
      ae.nodeType === 3 && ae === _ || Pt(ae) || (ae.content instanceof l && dr(ae.content), gr(ae), _ = ae);
    if (_ = null, Q)
      return It;
    if (Ft) {
      if (qe)
        for (U = Ce.call(zt.ownerDocument); zt.firstChild; )
          U.appendChild(zt.firstChild);
      else
        U = zt;
      return pe && (U = oe.call(r, U, !0)), U;
    }
    var Te = Ye ? zt.outerHTML : zt.innerHTML;
    return at && (Te = yu(Te, Oe, " "), Te = yu(Te, Qe, " ")), ie && _e ? ie.createHTML(Te) : Te;
  }, e.setConfig = function(It) {
    et(It), tt = !0;
  }, e.clearConfig = function() {
    Ot = null, tt = !1;
  }, e.isValidAttribute = function(It, ct, zt) {
    Ot || et({});
    var xe = vt(It), ae = vt(ct);
    return Yt(xe, ae, zt);
  }, e.addHook = function(It, ct) {
    typeof ct == "function" && (we[It] = we[It] || [], Pg(we[It], ct));
  }, e.removeHook = function(It) {
    we[It] && V8(we[It]);
  }, e.removeHooks = function(It) {
    we[It] && (we[It] = []);
  }, e.removeAllHooks = function() {
    we = {};
  }, e;
}
var w5e = l9(), x5e = ["iframe", "embed"], u9 = [];
function c9(i) {
  Ri(x5e, i) && u9.push(i.toLowerCase());
}
function Yc(i, e) {
  return w5e.sanitize(i, Nt({ ADD_TAGS: u9, ADD_ATTR: ["rel", "target", "hreflang", "type"], FORBID_TAGS: [
    "input",
    "script",
    "textarea",
    "form",
    "button",
    "select",
    "meta",
    "style",
    "link",
    "title",
    "object",
    "base"
  ] }, e));
}
function f9(i, e) {
  return i.literal.replace(new RegExp("(<\\s*" + e + "[^>]*>)|(</" + e + "\\s*[>])", "ig"), "").trim();
}
function y3(i) {
  i = i.match(gp)[0];
  var e = i.match(new RegExp(o4, "g"));
  return e ? e.reduce(function(r, s) {
    var l = s.trim().split("="), c = l[0], f = l.slice(1);
    return f.length && (r[c] = f.join("=").replace(/'|"/g, "").trim()), r;
  }, {}) : {};
}
function b3(i) {
  return Ws(i.attributes).reduce(function(e, r) {
    return e[r.nodeName] = r.nodeValue, e;
  }, {});
}
function Z8(i, e, r, s) {
  var l = s.getToDOMNode(e)(i), c = r(l.outerHTML), f = document.createElement("div");
  f.innerHTML = c, l = f.firstChild;
  var p = b3(l);
  return { dom: l, htmlAttrs: p };
}
var k5e = {
  htmlBlock: function(i, e, r) {
    return {
      atom: !0,
      content: "block+",
      group: "block",
      attrs: {
        htmlAttrs: { default: {} },
        childrenHTML: { default: "" },
        htmlBlock: { default: !0 }
      },
      parseDOM: [
        {
          tag: i,
          getAttrs: function(s) {
            return {
              htmlAttrs: b3(s),
              childrenHTML: s.innerHTML
            };
          }
        }
      ],
      toDOM: function(s) {
        var l = Z8(s, i, e, r), c = l.dom, f = l.htmlAttrs;
        return f.class = f.class ? f.class + " html-block" : "html-block", Ha([i, f], Ws(c.childNodes));
      }
    };
  },
  htmlInline: function(i, e, r) {
    return {
      attrs: {
        htmlAttrs: { default: {} },
        htmlInline: { default: !0 }
      },
      parseDOM: [
        {
          tag: i,
          getAttrs: function(s) {
            return {
              htmlAttrs: b3(s)
            };
          }
        }
      ],
      toDOM: function(s) {
        var l = Z8(s, i, e, r).htmlAttrs;
        return [i, l, 0];
      }
    };
  }
};
function O5e(i, e, r) {
  var s = { nodes: {}, marks: {} };
  return ["htmlBlock", "htmlInline"].forEach(function(l) {
    i[l] && Object.keys(i[l]).forEach(function(c) {
      var f = l === "htmlBlock" ? "nodes" : "marks";
      c9(c), s[f][c] = k5e[l](c, e, r);
    });
  }), s;
}
var C5e = /^\s*<\s*\//, T5e = {
  paragraph: function(i, e) {
    var r = e.entering, s = e.origin, l = e.options;
    return l.nodeId ? {
      type: r ? "openTag" : "closeTag",
      outerNewLine: !0,
      tagName: "p"
    } : s();
  },
  softbreak: function(i) {
    var e = i.prev && i.prev.type === "htmlInline", r = e && /<br ?\/?>/.test(i.prev.literal), s = r ? `
` : `<br>
`;
    return { type: "html", content: s };
  },
  item: function(i, e) {
    var r = e.entering;
    if (r) {
      var s = {}, l = [];
      return i.listData.task && (s["data-task"] = "", l.push("task-list-item"), i.listData.checked && (l.push("checked"), s["data-task-checked"] = "")), {
        type: "openTag",
        tagName: "li",
        classNames: l,
        attributes: s,
        outerNewLine: !0
      };
    }
    return {
      type: "closeTag",
      tagName: "li",
      outerNewLine: !0
    };
  },
  code: function(i) {
    var e = { "data-backticks": String(i.tickCount) };
    return [
      { type: "openTag", tagName: "code", attributes: e },
      { type: "text", content: i.literal },
      { type: "closeTag", tagName: "code" }
    ];
  },
  codeBlock: function(i) {
    var e = i, r = e.fenceLength, s = e.info, l = s ? s.split(/\s+/) : [], c = [], f = {};
    if (r > 3 && (f["data-backticks"] = r), l.length > 0 && l[0].length > 0) {
      var p = l[0];
      c.push("lang-" + p), f["data-language"] = p;
    }
    return [
      { type: "openTag", tagName: "pre", classNames: c },
      { type: "openTag", tagName: "code", attributes: f },
      { type: "text", content: i.literal },
      { type: "closeTag", tagName: "code" },
      { type: "closeTag", tagName: "pre" }
    ];
  },
  customInline: function(i, e) {
    var r = e.origin, s = e.entering, l = e.skipChildren, c = i.info;
    if (c.indexOf("widget") !== -1 && s) {
      l();
      var f = r4(i), p = t4(c, f).outerHTML;
      return [
        { type: "openTag", tagName: "span", classNames: ["tui-widget"] },
        { type: "html", content: p },
        { type: "closeTag", tagName: "span" }
      ];
    }
    return r();
  }
};
function gW(i, e) {
  var r = Nt({}, T5e);
  return i && (r.link = function(s, l) {
    var c = l.entering, f = l.origin, p = f();
    return c && (p.attributes = Nt(Nt({}, p.attributes), i)), p;
  }), e && Object.keys(e).forEach(function(s) {
    var l = r[s], c = e[s];
    l && _o(c) ? r[s] = function(f, p) {
      var d = Nt({}, p);
      return d.origin = function() {
        return l(f, p);
      }, c(f, d);
    } : Ri(["htmlBlock", "htmlInline"], s) && !_o(c) ? r[s] = function(f, p) {
      var d = f.literal.match(gp);
      if (d) {
        var m = d[0], y = d[1], S = d[3], x = (y || S).toLowerCase(), w = c[x], k = f9(f, x);
        if (w) {
          var O = Nt({}, f);
          return O.attrs = y3(m), O.childrenHTML = k, O.type = x, p.entering = !C5e.test(f.literal), w(O, p);
        }
      }
      return p.origin();
    } : r[s] = c;
  }), r;
}
var A5e = ["list", "item", "blockQuote"], E5e = ["UL", "OL", "BLOCKQUOTE"];
function M5e(i, e) {
  var r, s = i.child(e);
  return !s.childCount || s.childCount === 1 && !(!((r = s.firstChild.text) === null || r === void 0) && r.trim());
}
function Q8(i, e, r) {
  var s = iy(e) - 1, l = Wx(e) - 1, c = r[s].getBoundingClientRect(), f = r[l].offsetTop - r[s].offsetTop + r[l].clientHeight;
  return {
    height: f <= 0 ? r[s].clientHeight : f + R5e(i, r, Math.min(l + 1, i.childCount - 1)),
    rect: c
  };
}
function R5e(i, e, r) {
  for (var s = i.childCount - 1, l = 0; r <= s && M5e(i, r); )
    l += e[r].clientHeight, r += 1;
  return l;
}
function D5e(i, e) {
  for (; !i.getAttribute("data-nodeid") && i.parentElement !== e; )
    i = i.parentElement;
  return i;
}
function Ex(i, e) {
  for (var r = 0; i && i !== e && (Ri(E5e, i.tagName) || (r += i.offsetTop), i.offsetParent !== e.offsetParent); )
    i = i.parentElement;
  return r;
}
function P5e(i, e) {
  for (var r = e, s = null; r; ) {
    var l = r.firstElementChild;
    if (!l)
      break;
    var c = d9(l, i, Ex(r, e));
    s = r, r = c;
  }
  var f = r || s;
  return f === e ? null : f;
}
function d9(i, e, r) {
  return i && e > r + i.offsetTop ? d9(i.nextElementSibling, e, r) || i : null;
}
function L5e(i, e, r, s) {
  var l = Math.min((i - e) / r, 1);
  return l * s;
}
function yj(i, e) {
  for (var r = i.querySelector('[data-nodeid="' + e.id + '"]'); !r || wne(e); )
    e = e.parent, r = i.querySelector('[data-nodeid="' + e.id + '"]');
  return I5e({ mdNode: e, el: r });
}
function I5e(i) {
  for (var e = i.mdNode, r = i.el; (Ri(A5e, e.type) || e.type === "table") && e.firstChild; )
    e = e.firstChild, r = r.firstElementChild;
  return { mdNode: e, el: r };
}
var ds = {};
function _5e(i, e) {
  ds[i] = ds[i] || {}, ds[i].height = e;
}
function N5e(i, e) {
  ds[i] = ds[i] || {}, ds[i].offsetTop = e;
}
function B5e(i) {
  return ds[i] && ds[i].height;
}
function F5e(i) {
  return ds[i] && ds[i].offsetTop;
}
function S3(i) {
  i && (delete ds[Number(i.getAttribute("data-nodeid"))], Ws(i.children).forEach(function(e) {
    S3(e);
  }));
}
function z5e(i, e, r) {
  var s = B5e(r), l = F5e(r), c = s || i.clientHeight, f = l || Ex(i, e) || i.offsetTop;
  return s || _5e(r, c), l || N5e(r, f), { nodeHeight: c, offsetTop: f };
}
var bj = vr("md-preview-highlight");
function H5e(i, e) {
  for (var r = i.firstChild; r && r.next && !($x(r.next) > e + 1); )
    r = r.next;
  return r;
}
var h9 = (
  /** @class */
  function() {
    function i(e, r) {
      var s = document.createElement("div");
      this.el = s, this.eventEmitter = e, this.isViewer = !!r.isViewer, this.el.className = vr("md-preview");
      var l = r.linkAttributes, c = r.customHTMLRenderer, f = r.sanitizer, p = r.highlight, d = p === void 0 ? !1 : p;
      this.renderer = new mW({
        gfm: !0,
        nodeId: !0,
        convertors: gW(l, c)
      }), this.cursorNodeId = null, this.sanitizer = f, this.initEvent(d), this.initContentSection(), this.isViewer && (this.previewContent.style.overflowWrap = "break-word");
    }
    return i.prototype.initContentSection = function() {
      this.previewContent = f4('<div class="' + vr("contents") + '"></div>'), this.isViewer || this.el.appendChild(this.previewContent);
    }, i.prototype.toggleActive = function(e) {
      rW(this.el, "active", e);
    }, i.prototype.initEvent = function(e) {
      var r = this;
      this.eventEmitter.listen("updatePreview", this.update.bind(this)), !this.isViewer && (e && (this.eventEmitter.listen("changeToolbarState", function(s) {
        var l = s.mdNode, c = s.cursorPos;
        r.updateCursorNode(l, c);
      }), this.eventEmitter.listen("blur", function() {
        r.removeHighlight();
      })), E4(this.el, "scroll", function(s) {
        r.eventEmitter.emit("scroll", "preview", P5e(s.target.scrollTop, r.previewContent));
      }), this.eventEmitter.listen("changePreviewTabPreview", function() {
        return r.toggleActive(!0);
      }), this.eventEmitter.listen("changePreviewTabWrite", function() {
        return r.toggleActive(!1);
      }));
    }, i.prototype.removeHighlight = function() {
      if (this.cursorNodeId) {
        var e = this.getElementByNodeId(this.cursorNodeId);
        e && fs(e, bj);
      }
    }, i.prototype.updateCursorNode = function(e, r) {
      e && (e = mp(e, function(f) {
        return !One(f);
      }), e.type === "tableRow" ? e = H5e(e, r[1]) : e.type === "tableBody" && (e = null));
      var s = e ? e.id : null;
      if (this.cursorNodeId !== s) {
        var l = this.getElementByNodeId(this.cursorNodeId), c = this.getElementByNodeId(s);
        l && fs(l, bj), c && Bs(c, bj), this.cursorNodeId = s;
      }
    }, i.prototype.getElementByNodeId = function(e) {
      return e ? this.previewContent.querySelector('[data-nodeid="' + e + '"]') : null;
    }, i.prototype.update = function(e) {
      var r = this;
      e.forEach(function(s) {
        return r.replaceRangeNodes(s);
      }), this.eventEmitter.emit("afterPreviewRender", this);
    }, i.prototype.replaceRangeNodes = function(e) {
      var r = this, s = e.nodes, l = e.removedNodeRange, c = this.previewContent, f = this.eventEmitter.emitReduce("beforePreviewRender", this.sanitizer(s.map(function(k) {
        return r.renderer.render(k);
      }).join("")));
      if (!l)
        c.insertAdjacentHTML("afterbegin", f);
      else {
        var p = l.id, d = p[0], m = p[1], y = this.getElementByNodeId(d), S = this.getElementByNodeId(m);
        if (y) {
          y.insertAdjacentHTML("beforebegin", f);
          for (var x = y; x && x !== S; ) {
            var w = x.nextElementSibling;
            Uc(x), S3(x), x = w;
          }
          x != null && x.parentNode && (Uc(x), S3(x));
        }
      }
    }, i.prototype.getRenderer = function() {
      return this.renderer;
    }, i.prototype.destroy = function() {
      A4(this.el, "scroll"), this.el = null;
    }, i.prototype.getElement = function() {
      return this.el;
    }, i.prototype.getHTML = function() {
      return aW(this.previewContent.innerHTML);
    }, i.prototype.setHTML = function(e) {
      this.previewContent.innerHTML = e;
    }, i.prototype.setHeight = function(e) {
      js(this.el, { height: e + "px" });
    }, i.prototype.setMinHeight = function(e) {
      js(this.el, { minHeight: e + "px" });
    }, i;
  }()
);
function Sl(i, e) {
  for (var r = i.depth; r; ) {
    var s = i.node(r);
    if (e(s, r))
      return {
        node: s,
        depth: r,
        offset: r > 0 ? i.before(r) : 0
      };
    r -= 1;
  }
  return null;
}
function wp(i) {
  return !!Sl(i, function(e) {
    var r = e.type;
    return r.name === "listItem" || r.name === "bulletList" || r.name === "orderedList";
  });
}
function Mx(i) {
  return !!Sl(i, function(e) {
    var r = e.type;
    return r.name === "tableHeadCell" || r.name === "tableBodyCell";
  });
}
function xp(i) {
  return Sl(i, function(e) {
    var r = e.type;
    return r.name === "listItem";
  });
}
function Zx(i) {
  return {
    tag: i,
    getAttrs: function(e) {
      var r = e.getAttribute("data-raw-html");
      return Nt({}, r && { rawHTML: r });
    }
  };
}
function p9(i) {
  return Object.keys(i).reduce(function(e, r) {
    return r !== "rawHTML" && i[r] && (r = r === "className" ? "class" : r, e[r] = i[r]), e;
  }, {});
}
function v9(i) {
  return {
    tag: i,
    getAttrs: function(e) {
      return ["rawHTML", "colspan", "rowspan", "extended"].reduce(function(r, s) {
        var l = s === "rawHTML" ? "data-raw-html" : s, c = e.getAttribute(l);
        return c && (r[s] = Ri(["rawHTML", "extended"], s) ? c : Number(c)), r;
      }, {});
    }
  };
}
function yi() {
  return {
    htmlAttrs: { default: null },
    classNames: { default: null }
  };
}
function Zn(i) {
  var e = i.htmlAttrs, r = i.classNames;
  return Nt(Nt({}, e), { class: r ? r.join(" ") : null });
}
function j5e(i, e) {
  var r = i.parent, s = i.startIndex, l = i.endIndex, c = r.contentMatchAt(s).findWrapping(e);
  if (c) {
    var f = c.length ? c[0] : e;
    return r.canReplaceWith(s, l, f) ? c : null;
  }
  return null;
}
function W5e(i, e) {
  var r = i.parent, s = i.startIndex, l = i.endIndex, c = r.child(s), f = e.contentMatch.findWrapping(c.type);
  if (f) {
    for (var p = f.length ? f[f.length - 1] : e, d = p.contentMatch, m = s; d && m < l; m += 1)
      d = d.matchType(r.child(m).type);
    if (d && d.validEnd)
      return f;
  }
  return null;
}
function $5e(i, e, r, s) {
  var l = j5e(i, r), c = W5e(e, r);
  if (l && c) {
    var f = l.map(function(d) {
      return { type: d };
    }), p = c.map(function(d) {
      return { type: d, attrs: s };
    });
    return f.concat({ type: r }).concat(p);
  }
  return null;
}
function U5e(i, e, r, s, l) {
  for (var c = e.start, f = e.end, p = e.startIndex, d = e.endIndex, m = e.parent, y = qt.empty, S = r.length - 1; S >= 0; S -= 1)
    y = qt.from(r[S].type.create(r[S].attrs, y));
  i.step(new mi(c - (s ? 2 : 0), f, c, f, new ur(y, 0, 0), r.length, !0));
  for (var x = 0, S = 0; S < r.length; S += 1)
    if (r[S].type === l) {
      x = S + 1;
      break;
    }
  for (var w = r.length - x, k = c + r.length - (s ? 2 : 0), S = p, O = d; S < O; S += 1) {
    var T = S === p;
    !T && op(i.doc, k, w) && (i.split(k, w), k += w * 2), k += m.child(S).nodeSize;
  }
  return i;
}
function m9(i, e, r, s) {
  var l = e.$from, c = e.$to, f = e.depth, p = e, d = !1;
  if (f >= 2 && l.node(f - 1).type.compatibleContent(r) && e.startIndex === 0 && l.index(f - 1)) {
    var m = i.doc.resolve(e.start - 2);
    p = new ox(m, m, f), e.endIndex < e.parent.childCount && (e = new ox(l, i.doc.resolve(c.end(f)), f)), d = !0;
  }
  var y = $5e(p, e, r, s);
  return y ? U5e(i, e, y, d, r) : i;
}
function g9(i, e) {
  for (var r = i.resolve(e); r.node().type.name !== "paragraph"; )
    e -= 2, r = i.resolve(e);
  return xp(r);
}
function V5e(i, e) {
  var r = e.$from, s = e.$to, l = xp(r), c = xp(s);
  if (l && c)
    for (; c; ) {
      var f = c.offset, p = c.node, d = { task: !p.attrs.task, checked: !1 };
      if (i.setNodeMarkup(f, null, d), f === l.offset)
        break;
      c = g9(i.doc, f);
    }
  return i;
}
function G5e(i, e, r) {
  var s = e.$from, l = e.$to, c = xp(s), f = xp(l);
  if (c && f)
    for (; f; ) {
      var p = f.offset, d = f.node, m = f.depth;
      d.attrs.task && i.setNodeMarkup(p, null, { task: !1, checked: !1 });
      var y = i.doc.resolve(p);
      if (y.parent.type !== r) {
        var S = y.before(m - 1);
        i.setNodeMarkup(S, r);
      }
      if (p === c.offset)
        break;
      f = g9(i.doc, p);
    }
  return i;
}
function y9(i) {
  return function(e, r) {
    var s = e.selection, l = e.tr, c = s.$from, f = s.$to, p = c.blockRange(f);
    if (p) {
      var d = wp(c) ? G5e(l, p, i) : m9(l, p, i);
      return r(d), !0;
    }
    return !1;
  };
}
function Y5e() {
  return function(i, e) {
    var r = i.selection, s = i.tr, l = i.schema, c = r.$from, f = r.$to, p = c.blockRange(f);
    if (p) {
      var d = wp(c) ? V5e(s, p) : m9(s, p, l.nodes.bulletList, { task: !0 });
      return e(d), !0;
    }
    return !1;
  };
}
function q5e(i) {
  return function(e, r) {
    var s = e.tr, l = e.selection, c = l.$from, f = l.$to, p = c.blockRange(f, function(O) {
      var T = O.childCount, L = O.firstChild;
      return !!T && L.type === i;
    });
    if (p && p.startIndex > 0) {
      var d = p.parent, m = d.child(p.startIndex - 1);
      if (m.type !== i)
        return !1;
      var y = m.lastChild && m.lastChild.type === d.type, S = y ? qt.from(i.create()) : null, x = new ur(qt.from(i.create(null, qt.from(d.type.create(null, S)))), y ? 3 : 1, 0), w = p.start, k = p.end;
      return s.step(new mi(w - (y ? 3 : 1), k, w, k, x, 1, !0)), r(s), !0;
    }
    return !1;
  };
}
function K5e(i, e, r) {
  var s = e.$from, l = e.$to, c = e.end, f = e.depth, p = e.parent, d = l.end(f);
  return c < d && (i.step(new mi(c - 1, d, c, d, new ur(qt.from(r.create(null, p.copy())), 1, 0), 1, !0)), e = new ox(i.doc.resolve(s.pos), i.doc.resolve(d), f)), i.lift(e, Ix(e)), i;
}
function X5e(i, e) {
  for (var r = e.parent, s = e.end, l = e.endIndex - 1, c = e.startIndex; l > c; l -= 1)
    s -= r.child(l).nodeSize, i.delete(s - 1, s + 1);
  var f = i.doc.resolve(e.start), p = f.nodeAfter, d = e.startIndex === 0, m = e.endIndex === r.childCount, y = f.node(-1), S = f.index(-1), x = y.canReplace(S + (d ? 0 : 1), S + 1, p == null ? void 0 : p.content.append(m ? qt.empty : qt.from(r)));
  if (p && x) {
    var w = f.pos, k = w + p.nodeSize;
    i.step(new mi(w - (d ? 1 : 0), k + (m ? 1 : 0), w + 1, k - 1, new ur((d ? qt.empty : qt.from(r.copy(qt.empty))).append(m ? qt.empty : qt.from(r.copy(qt.empty))), d ? 0 : 1, m ? 0 : 1), d ? 0 : 1));
  }
  return i;
}
function J5e(i) {
  return function(e, r) {
    var s = e.tr, l = e.selection, c = l.$from, f = l.$to, p = c.blockRange(f, function(y) {
      var S = y.childCount, x = y.firstChild;
      return !!S && x.type === i;
    });
    if (p) {
      var d = c.node(p.depth - 1).type === i, m = d ? K5e(s, p, i) : X5e(s, p);
      return r(m), !0;
    }
    return !1;
  };
}
function Z5e(i) {
  return function(e, r) {
    var s = e.tr, l = e.selection, c = l.$from, f = l.$to;
    if (c.depth < 2 || !c.sameParent(f))
      return !1;
    var p = c.node(-1);
    if (p.type !== i)
      return !1;
    if (c.parent.content.size === 0 && c.node(-1).childCount === c.indexAfter(-1)) {
      if (c.depth === 2 || c.node(-3).type !== i || c.index(-2) !== c.node(-2).childCount - 1)
        return !1;
      for (var d = c.index(-1) > 0, m = qt.empty, y = c.depth - (d ? 1 : 2); y >= c.depth - 3; y -= 1)
        m = qt.from(c.node(y).copy(m));
      return m = m.append(qt.from(i.createAndFill())), s.replace(d ? c.before() : c.before(-1), c.after(-3), new ur(m, d ? 3 : 2, 2)), s.setSelection(jr.near(s.doc.resolve(c.pos + (d ? 3 : 2)))), r(s), !0;
    }
    var S = f.pos === c.end() ? p.contentMatchAt(0).defaultType : null, x = S && [null, { type: S }];
    return s.delete(c.pos, f.pos), op(s.doc, c.pos, 2, x) ? (s.split(c.pos, 2, x), r(s), !0) : !1;
  };
}
function Q5e() {
  return function() {
    return function(i, e) {
      var r = i.selection, s = i.schema, l = r.$from, c = r.$to, f = l.blockRange(c);
      return f && wp(l) ? q5e(s.nodes.listItem)(i, e) : !1;
    };
  };
}
function eVe() {
  return function() {
    return function(i, e) {
      var r = i.selection, s = i.schema, l = r.$from, c = r.$to, f = l.blockRange(c);
      return f && wp(l) ? J5e(s.nodes.listItem)(i, e) : !1;
    };
  };
}
function yW() {
  return {
    indent: Q5e(),
    outdent: eVe()
  };
}
var e5 = /* @__PURE__ */ new Map(), Ti = (
  /** @class */
  function() {
    function i(e, r, s, l) {
      this.table = e, this.tableRows = r, this.tableStartPos = s, this.rowInfo = l;
    }
    return i.create = function(e) {
      var r = Sl(e, function(k) {
        var O = k.type;
        return O.name === "table";
      });
      if (r) {
        var s = r.node, l = r.depth, c = r.offset, f = e5.get(s);
        if ((f == null ? void 0 : f.tableStartPos) === c + 1)
          return f;
        var p = [], d = e.start(l), m = s.child(0), y = s.child(1), S = w3(m, d), x = w3(y, d + m.nodeSize);
        m.forEach(function(k) {
          return p.push(k);
        }), y.forEach(function(k) {
          return p.push(k);
        });
        var w = new i(s, p, d, S.concat(x));
        return e5.set(s, w), w;
      }
      return null;
    }, Object.defineProperty(i.prototype, "totalRowCount", {
      get: function() {
        return this.rowInfo.length;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "totalColumnCount", {
      get: function() {
        return this.rowInfo[0].length;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "tableStartOffset", {
      get: function() {
        return this.tableStartPos;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(i.prototype, "tableEndOffset", {
      get: function() {
        return this.tableStartPos + this.table.nodeSize - 1;
      },
      enumerable: !1,
      configurable: !0
    }), i.prototype.getCellInfo = function(e, r) {
      return this.rowInfo[e][r];
    }, i.prototype.posAt = function(e, r) {
      for (var s = 0, l = this.tableStartPos; ; s += 1) {
        var c = l + this.tableRows[s].nodeSize;
        if (s === e) {
          for (var f = r; f < this.totalColumnCount && this.rowInfo[s][f].offset < l; )
            f += 1;
          return f === this.totalColumnCount ? c : this.rowInfo[s][f].offset;
        }
        l = c;
      }
    }, i.prototype.getNodeAndPos = function(e, r) {
      var s = this.rowInfo[e][r];
      return {
        node: this.table.nodeAt(s.offset - this.tableStartOffset),
        pos: s.offset
      };
    }, i.prototype.extendedRowspan = function(e, r) {
      return !1;
    }, i.prototype.extendedColspan = function(e, r) {
      return !1;
    }, i.prototype.getRowspanCount = function(e, r) {
      return 0;
    }, i.prototype.getColspanCount = function(e, r) {
      return 0;
    }, i.prototype.decreaseColspanCount = function(e, r) {
      return 0;
    }, i.prototype.decreaseRowspanCount = function(e, r) {
      return 0;
    }, i.prototype.getColspanStartInfo = function(e, r) {
      return null;
    }, i.prototype.getRowspanStartInfo = function(e, r) {
      return null;
    }, i.prototype.getCellStartOffset = function(e, r) {
      var s = this.rowInfo[e][r].offset;
      return this.extendedRowspan(e, r) ? this.posAt(e, r) : s;
    }, i.prototype.getCellEndOffset = function(e, r) {
      var s = this.rowInfo[e][r], l = s.offset, c = s.nodeSize;
      return this.extendedRowspan(e, r) ? this.posAt(e, r) : l + c;
    }, i.prototype.getCellIndex = function(e) {
      for (var r = 0; r < this.totalRowCount; r += 1)
        for (var s = this.rowInfo[r], l = 0; l < this.totalColumnCount; l += 1)
          if (s[l].offset + 1 > e.pos)
            return [r, l];
      return [0, 0];
    }, i.prototype.getRectOffsets = function(e, r) {
      var s, l, c;
      r === void 0 && (r = e), e.pos > r.pos && (s = [r, e], e = s[0], r = s[1]);
      var f = this.getCellIndex(e), p = f[0], d = f[1], m = this.getCellIndex(r), y = m[0], S = m[1];
      return l = t8(p, y), p = l[0], y = l[1], c = t8(d, S), d = c[0], S = c[1], this.getSpannedOffsets({ startRowIdx: p, startColIdx: d, endRowIdx: y, endColIdx: S });
    }, i.prototype.getSpannedOffsets = function(e) {
      return e;
    }, i;
  }()
), w3 = function(i, e) {
  var r = [];
  return i.forEach(function(s, l) {
    var c = { rowspanMap: {}, colspanMap: {}, length: 0 };
    s.forEach(function(f, p) {
      for (var d = f.nodeSize, m = 0; c[m]; )
        m += 1;
      c[m] = {
        // 2 is the sum of the front and back positions of the tag
        offset: e + l + p + 2,
        nodeSize: d
      }, c.length += 1;
    }), r.push(c);
  }), r;
};
function tVe(i, e) {
  return Z3(Ti.prototype, i), w3 = e, Ti;
}
function rVe(i, e, r) {
  for (var s = r.startRowIdx, l = r.startColIdx, c = r.endRowIdx, f = r.endColIdx, p = [], d = s; d <= c; d += 1)
    for (var m = l; m <= f; m += 1) {
      var y = e.getCellInfo(d, m), S = y.offset, x = y.nodeSize;
      p.push(new r6(i.resolve(S + 1), i.resolve(S + x - 1)));
    }
  return p;
}
function nVe(i, e) {
  var r = [];
  return i.childCount && r.push(i), e.childCount && r.push(e), qt.from(r);
}
var bW = (
  /** @class */
  function(i) {
    pr(e, i);
    function e(r, s) {
      s === void 0 && (s = r);
      var l = this, c = r.node(0), f = Ti.create(r), p = f.getRectOffsets(r, s), d = rVe(c, f, p);
      return l = i.call(this, d[0].$from, d[0].$to, d) || this, l.startCell = r, l.endCell = s, l.offsetMap = f, l.isCellSelection = !0, l.visible = !1, l;
    }
    return e.prototype.map = function(r, s) {
      var l = this.startCell.pos, c = this.endCell.pos, f = r.resolve(s.map(l)), p = r.resolve(s.map(c)), d = Ti.create(f);
      if (this.offsetMap.totalColumnCount > d.totalColumnCount || this.offsetMap.totalRowCount > d.totalRowCount) {
        var m = { tableBody: 1, tableRow: 2, tableCell: 3, paragraph: 4 }, y = m[p.parent.type.name], S = p.end(p.depth - y), x = Math.min(S - 4, p.pos);
        return Zr.create(r, x);
      }
      return new e(f, p);
    }, e.prototype.eq = function(r) {
      return r instanceof e && r.startCell.pos === this.startCell.pos && r.endCell.pos === this.endCell.pos;
    }, e.prototype.content = function() {
      for (var r = this.startCell.node(-2), s = this.startCell.start(-2), l = r.child(1).firstChild, c = r.child(0).type.create(), f = r.child(1).type.create(), p = Ti.create(this.startCell), d = p.getRectOffsets(this.startCell, this.endCell), m = d.startRowIdx, y = d.startColIdx, S = d.endRowIdx, x = d.endColIdx, w = !1, k = m; k <= S; k += 1) {
        for (var O = [], T = y; T <= x; T += 1) {
          var L = p.getCellInfo(k, T).offset, j = r.nodeAt(L - s);
          j && (w = j.type.name === "tableHeadCell", p.extendedRowspan(k, T) || p.extendedColspan(k, T) ? O.push(j.type.create({ extended: !0 })) : O.push(j.copy(j.content)));
        }
        var z = l.copy(qt.from(O)), J = w ? c : f;
        J.content = J.content.append(qt.from(z));
      }
      return new ur(nVe(c, f), 1, 1);
    }, e.prototype.toJSON = function() {
      return JSON.stringify(this);
    }, e;
  }(jr)
);
function iVe(i, e, r) {
  for (var s = e.nodes, l = s.tableRow, c = s.tableHeadCell, f = s.paragraph, p = [], d = 0; d < i; d += 1) {
    var m = r && r[d], y = f.create(null, m ? e.text(m) : []);
    p.push(c.create(null, y));
  }
  return [l.create(null, p)];
}
function b9(i, e, r, s) {
  for (var l = r.nodes, c = l.tableRow, f = l.tableBodyCell, p = l.paragraph, d = [], m = 0; m < i; m += 1) {
    for (var y = [], S = 0; S < e; S += 1) {
      var x = s && s[m * e + S], w = p.create(null, x ? r.text(x) : []);
      y.push(f.create(null, w));
    }
    d.push(c.create(null, y));
  }
  return d;
}
function Qw(i, e, r, s) {
  s === void 0 && (s = null);
  for (var l = r.nodes, c = l.tableHeadCell, f = l.tableBodyCell, p = l.paragraph, d = e === 0 ? c : f, m = [], y = 0; y < i; y += 1)
    m.push(d.create(s, p.create()));
  return m;
}
function S9(i, e) {
  for (; i && i !== e; ) {
    if (i.nodeName === "TD" || i.nodeName === "TH")
      return i;
    i = i.parentNode;
  }
  return null;
}
function w9(i) {
  return Sl(i, function(e) {
    var r = e.type;
    return r.name === "tableHeadCell" || r.name === "tableBodyCell";
  });
}
function Ls(i) {
  if (i instanceof Zr) {
    var e = i.$anchor, r = w9(e);
    if (r) {
      var s = e.node(0).resolve(e.before(r.depth));
      return { anchor: s, head: s };
    }
  }
  var l = i, c = l.startCell, f = l.endCell;
  return { anchor: c, head: f };
}
function x9(i) {
  var e;
  if (i.size) {
    var r = i.content, s = i.openStart, l = i.openEnd;
    if (r.childCount !== 1)
      return null;
    for (; r.childCount === 1 && (s > 0 && l > 0 || ((e = r.firstChild) === null || e === void 0 ? void 0 : e.type.name) === "table"); )
      s -= 1, l -= 1, r = r.firstChild.content;
    if (r.firstChild.type.name === "tableHead" || r.firstChild.type.name === "tableBody")
      return r;
  }
  return null;
}
function ip(i) {
  var e = i.startRowIdx, r = i.startColIdx, s = i.endRowIdx, l = i.endColIdx, c = s - e + 1, f = l - r + 1;
  return { rowCount: c, columnCount: f };
}
function aVe(i, e) {
  return Nt(Nt({}, i.attrs), e);
}
var xu = new ty("cellSelection"), oVe = 2, sVe = (
  /** @class */
  function() {
    function i(e) {
      this.view = e, this.handlers = {
        mousedown: this.handleMousedown.bind(this),
        mousemove: this.handleMousemove.bind(this),
        mouseup: this.handleMouseup.bind(this)
      }, this.startCellPos = null, this.init();
    }
    return i.prototype.init = function() {
      this.view.dom.addEventListener("mousedown", this.handlers.mousedown);
    }, i.prototype.handleMousedown = function(e) {
      var r = S9(e.target, this.view.dom);
      if (e.button === oVe) {
        e.preventDefault();
        return;
      }
      if (r) {
        var s = this.getCellPos(e);
        s && (this.startCellPos = s), this.bindEvent();
      }
    }, i.prototype.handleMousemove = function(e) {
      var r = xu.getState(this.view.state), s = this.getCellPos(e), l = this.startCellPos, c;
      r ? c = this.view.state.doc.resolve(r) : l !== s && (c = l), c && l && s && this.setCellSelection(l, s);
    }, i.prototype.handleMouseup = function() {
      this.startCellPos = null, this.unbindEvent(), xu.getState(this.view.state) !== null && this.view.dispatch(this.view.state.tr.setMeta(xu, -1));
    }, i.prototype.bindEvent = function() {
      var e = this.view.dom;
      e.addEventListener("mousemove", this.handlers.mousemove), e.addEventListener("mouseup", this.handlers.mouseup);
    }, i.prototype.unbindEvent = function() {
      var e = this.view.dom;
      e.removeEventListener("mousemove", this.handlers.mousemove), e.removeEventListener("mouseup", this.handlers.mouseup);
    }, i.prototype.getCellPos = function(e) {
      var r = e.clientX, s = e.clientY, l = this.view.posAtCoords({ left: r, top: s });
      if (l) {
        var c = this.view.state.doc, f = c.resolve(l.pos), p = w9(f);
        if (p) {
          var d = f.before(p.depth);
          return c.resolve(d);
        }
      }
      return null;
    }, i.prototype.setCellSelection = function(e, r) {
      var s = this.view.state, l = s.selection, c = s.tr, f = xu.getState(this.view.state) === null, p = new bW(e, r);
      if (f || !l.eq(p)) {
        var d = c.setSelection(p);
        f && d.setMeta(xu, r.pos), this.view.dispatch(d);
      }
    }, i.prototype.destroy = function() {
      this.view.dom.removeEventListener("mousedown", this.handlers.mousedown);
    }, i;
  }()
), lVe = vr("cell-selected");
function uVe(i) {
  var e = i.selection, r = i.doc;
  if (e instanceof bW) {
    var s = [], l = e.ranges;
    return l.forEach(function(c) {
      var f = c.$from, p = c.$to;
      s.push(Fa.node(f.pos - 1, p.pos + 1, { class: lVe }));
    }), Bn.create(r, s);
  }
  return null;
}
function cVe() {
  return new Wa({
    key: xu,
    state: {
      init: function() {
        return null;
      },
      apply: function(i, e) {
        var r = i.getMeta(xu);
        if (r)
          return r === -1 ? null : r;
        if (vx(e) || !i.docChanged)
          return e;
        var s = i.mapping.mapResult(e), l = s.deleted, c = s.pos;
        return l ? null : c;
      }
    },
    props: {
      decorations: uVe,
      createSelectionBetween: function(i) {
        var e = i.state;
        return vx(xu.getState(e)) ? null : e.selection;
      }
    },
    view: function(i) {
      return new sVe(i);
    }
  });
}
var k9 = (
  /** @class */
  function() {
    function i() {
      this.keys = [], this.values = [];
    }
    return i.prototype.getKeyIndex = function(e) {
      return Wc(e, this.keys);
    }, i.prototype.get = function(e) {
      return this.values[this.getKeyIndex(e)];
    }, i.prototype.set = function(e, r) {
      var s = this.getKeyIndex(e);
      return s > -1 ? this.values[s] = r : (this.keys.push(e), this.values.push(r)), this;
    }, i.prototype.has = function(e) {
      return this.getKeyIndex(e) > -1;
    }, i.prototype.delete = function(e) {
      var r = this.getKeyIndex(e);
      return r > -1 ? (this.keys.splice(r, 1), this.values.splice(r, 1), !0) : !1;
    }, i.prototype.forEach = function(e, r) {
      var s = this;
      r === void 0 && (r = this), this.values.forEach(function(l, c) {
        l && s.keys[c] && e.call(r, l, s.keys[c], s);
      });
    }, i.prototype.clear = function() {
      this.keys = [], this.values = [];
    }, i;
  }()
), Sj = "en-US", fVe = (
  /** @class */
  function() {
    function i() {
      this.code = Sj, this.langs = new k9();
    }
    return i.prototype.setCode = function(e) {
      this.code = e || Sj;
    }, i.prototype.setLanguage = function(e, r) {
      var s = this;
      e = [].concat(e), e.forEach(function(l) {
        if (!s.langs.has(l))
          s.langs.set(l, r);
        else {
          var c = s.langs.get(l);
          s.langs.set(l, G3(c, r));
        }
      });
    }, i.prototype.get = function(e, r) {
      r || (r = this.code);
      var s = this.langs.get(r);
      s || (s = this.langs.get(Sj));
      var l = s[e];
      if (!l)
        throw new Error('There is no text key "' + e + '" in ' + r);
      return l;
    }, i;
  }()
), Mr = new fVe(), dVe = [
  [
    {
      action: "Add row to up",
      command: "addRowToUp",
      disableInThead: !0,
      className: "add-row-up"
    },
    {
      action: "Add row to down",
      command: "addRowToDown",
      disableInThead: !0,
      className: "add-row-down"
    },
    { action: "Remove row", command: "removeRow", disableInThead: !0, className: "remove-row" }
  ],
  [
    { action: "Add column to left", command: "addColumnToLeft", className: "add-column-left" },
    { action: "Add column to right", command: "addColumnToRight", className: "add-column-right" },
    { action: "Remove column", command: "removeColumn", className: "remove-column" }
  ],
  [
    {
      action: "Align column to left",
      command: "alignColumn",
      payload: { align: "left" },
      className: "align-column-left"
    },
    {
      action: "Align column to center",
      command: "alignColumn",
      payload: { align: "center" },
      className: "align-column-center"
    },
    {
      action: "Align column to right",
      command: "alignColumn",
      payload: { align: "right" },
      className: "align-column-right"
    }
  ],
  [{ action: "Remove table", command: "removeTable", className: "remove-table" }]
];
function hVe(i, e) {
  return dVe.map(function(r) {
    return r.map(function(s) {
      var l = s.action, c = s.command, f = s.payload, p = s.disableInThead, d = s.className;
      return {
        label: Mr.get(l),
        onClick: function() {
          i.emit("command", c, f);
        },
        disabled: e && !!p,
        className: d
      };
    });
  }).concat();
}
function pVe(i) {
  return new Wa({
    props: {
      handleDOMEvents: {
        contextmenu: function(e, r) {
          var s = S9(r.target, e.dom);
          if (s) {
            r.preventDefault();
            var l = r, c = l.clientX, f = l.clientY, p = e.dom.parentNode.getBoundingClientRect(), d = p.left, m = p.top, y = s.nodeName === "TH";
            return i.emit("contextmenu", {
              pos: { left: c - d + 10 + "px", top: f - m + 30 + "px" },
              menuGroups: hVe(i, y),
              tableCell: s
            }), !0;
          }
          return !1;
        }
      }
    }
  });
}
function vVe() {
  return new Wa({
    props: {
      handleDOMEvents: {
        mousedown: function(i, e) {
          var r = e, s = r.clientX, l = r.clientY, c = i.posAtCoords({ left: s, top: l });
          if (c) {
            var f = i.state, p = f.doc, d = f.tr, m = p.resolve(c.pos), y = xp(m), S = e.target, x = getComputedStyle(S, ":before"), w = e, k = w.offsetX, O = w.offsetY;
            if (!y || !tW(x, k, O))
              return !1;
            e.preventDefault();
            var T = m.before(y.depth), L = y.node.attrs;
            return d.setNodeMarkup(T, null, Nt(Nt({}, L), { checked: !L.checked })), i.dispatch(d), !0;
          }
          return !1;
        }
      }
    }
  });
}
var mVe = ["image", "link", "customBlock", "frontMatter"], gVe = ["strong", "strike", "emph", "code"], O9 = ["bulletList", "orderedList", "taskList"];
function yVe(i, e) {
  var r = i.type.name;
  return r === "listItem" ? i.attrs.task ? "taskList" : e.type.name : r.indexOf("table") !== -1 ? "table" : r;
}
function bVe(i, e) {
  e[i] = { active: !0 }, O9.filter(function(r) {
    return r !== i;
  }).forEach(function(r) {
    e[r] && delete e[r];
  });
}
function SVe(i, e, r, s) {
  gVe.forEach(function(l) {
    var c = r.marks[l], f = i.marksAcross(e) || [], p = !!c.isInSet(f);
    p && (s[l] = { active: !0 });
  });
}
function wVe(i, e, r) {
  var s = i.$from, l = i.$to, c = i.from, f = i.to, p = {
    indent: { active: !1, disabled: !0 },
    outdent: { active: !1, disabled: !0 }
  };
  return e.nodesBetween(c, f, function(d, m, y) {
    var S = yVe(d, y);
    Ri(mVe, S) || (Ri(O9, S) ? (bVe(S, p), p.indent.disabled = !1, p.outdent.disabled = !1) : S === "paragraph" || S === "text" ? SVe(s, l, r, p) : p[S] = { active: !0 });
  }), p;
}
function xVe(i) {
  return new Wa({
    view: function() {
      return {
        update: function(e) {
          var r = e.state, s = r.selection, l = r.doc, c = r.schema;
          i.emit("changeToolbarState", {
            toolbarState: wVe(s, l, c)
          });
        }
      };
    }
  });
}
var kVe = (
  /** @class */
  function() {
    function i(e, r, s, l) {
      var c = this;
      this.openEditor = function() {
        if (c.innerEditorView)
          throw new Error("The editor is already opened.");
        c.dom.draggable = !1, c.wrapper.style.display = "none", c.innerViewContainer.style.display = "block", c.innerEditorView = new H3(c.innerViewContainer, {
          state: Rc.create({
            doc: c.node,
            plugins: [
              Zg({
                "Mod-z": function() {
                  return Gg(c.innerEditorView.state, c.innerEditorView.dispatch);
                },
                "Shift-Mod-z": function() {
                  return V3(c.innerEditorView.state, c.innerEditorView.dispatch);
                },
                Tab: function(f, p) {
                  return p(f.tr.insertText("	")), !0;
                },
                Enter: H6,
                Escape: function() {
                  return c.cancelEditing(), !0;
                },
                "Ctrl-Enter": function() {
                  return c.saveAndFinishEditing(), !0;
                }
              }),
              K6()
            ]
          }),
          dispatchTransaction: function(f) {
            return c.dispatchInner(f);
          },
          handleDOMEvents: {
            mousedown: function() {
              return c.editorView.hasFocus() && c.innerEditorView.focus(), !0;
            },
            blur: function() {
              return c.saveAndFinishEditing(), !0;
            }
          }
        }), c.innerEditorView.focus();
      }, this.node = e, this.editorView = r, this.getPos = s, this.toDOMAdaptor = l, this.innerEditorView = null, this.canceled = !1, this.dom = document.createElement("div"), this.dom.className = vr("custom-block"), this.wrapper = document.createElement("div"), this.wrapper.className = vr("custom-block-view"), this.createInnerViewContainer(), this.renderCustomBlock(), this.dom.appendChild(this.innerViewContainer), this.dom.appendChild(this.wrapper);
    }
    return i.prototype.renderToolArea = function() {
      var e = this, r = document.createElement("div"), s = document.createElement("span"), l = document.createElement("button");
      r.className = "tool", s.textContent = this.node.attrs.info, s.className = "info", l.type = "button", l.addEventListener("click", function() {
        return e.openEditor();
      }), r.appendChild(s), r.appendChild(l), this.wrapper.appendChild(r);
    }, i.prototype.renderCustomBlock = function() {
      var e = this.toDOMAdaptor.getToDOMNode(this.node.attrs.info);
      if (e) {
        for (var r = e(this.node); this.wrapper.hasChildNodes(); )
          this.wrapper.removeChild(this.wrapper.lastChild);
        r && this.wrapper.appendChild(r), this.renderToolArea();
      }
    }, i.prototype.createInnerViewContainer = function() {
      this.innerViewContainer = document.createElement("div"), this.innerViewContainer.className = vr("custom-block-editor"), this.innerViewContainer.style.display = "none";
    }, i.prototype.closeEditor = function() {
      this.innerEditorView && (this.innerEditorView.destroy(), this.innerEditorView = null, this.innerViewContainer.style.display = "none"), this.wrapper.style.display = "block";
    }, i.prototype.saveAndFinishEditing = function() {
      var e = this.editorView.state.selection.to, r = this.editorView.state;
      this.editorView.dispatch(r.tr.setSelection(On(r.tr, e))), this.editorView.focus(), this.renderCustomBlock(), this.closeEditor();
    }, i.prototype.cancelEditing = function() {
      var e = bre(this.innerEditorView.state);
      for (this.canceled = !0; e--; )
        Gg(this.innerEditorView.state, this.innerEditorView.dispatch), Gg(this.editorView.state, this.editorView.dispatch);
      this.canceled = !1;
      var r = this.editorView.state.selection.to, s = this.editorView.state;
      this.editorView.dispatch(s.tr.setSelection(Zr.create(s.doc, r))), this.editorView.focus(), this.closeEditor();
    }, i.prototype.dispatchInner = function(e) {
      var r = this.innerEditorView.state.applyTransaction(e), s = r.state, l = r.transactions;
      if (this.innerEditorView.updateState(s), !this.canceled && _o(this.getPos)) {
        for (var c = this.editorView.state.tr, f = fo.offset(this.getPos() + 1), p = 0; p < l.length; p += 1)
          for (var d = l[p].steps, m = 0; m < d.length; m += 1)
            c.step(d[m].map(f));
        c.docChanged && this.editorView.dispatch(c);
      }
    }, i.prototype.update = function(e) {
      return e.sameMarkup(this.node) ? (this.node = e, this.innerEditorView || this.renderCustomBlock(), !0) : !1;
    }, i.prototype.stopEvent = function(e) {
      return !!this.innerEditorView && !!e.target && this.innerEditorView.dom.contains(e.target);
    }, i.prototype.ignoreMutation = function() {
      return !0;
    }, i.prototype.destroy = function() {
      this.dom.removeEventListener("dblclick", this.openEditor), this.closeEditor();
    }, i;
  }()
), t5 = "image-link", OVe = (
  /** @class */
  function() {
    function i(e, r, s, l) {
      var c = this, f;
      this.handleMousedown = function(p) {
        p.preventDefault();
        var d = p.target, m = p.offsetX, y = p.offsetY;
        if (c.imageLink && _o(c.getPos) && i4(d, t5)) {
          var S = getComputedStyle(d, ":before");
          if (p.stopPropagation(), tW(S, m, y)) {
            var x = c.view.state.tr, w = c.getPos();
            x.setSelection(On(x, w, w + 1)), c.view.dispatch(x), c.eventEmitter.emit("openPopup", "link", c.imageLink.attrs);
          }
        }
      }, this.node = e, this.view = r, this.getPos = s, this.eventEmitter = l, this.imageLink = (f = e.marks.filter(function(p) {
        var d = p.type;
        return d.name === "link";
      })[0]) !== null && f !== void 0 ? f : null, this.dom = this.createElement(), this.bindEvent();
    }
    return i.prototype.createElement = function() {
      var e = this.createImageElement(this.node);
      if (this.imageLink) {
        var r = document.createElement("span");
        return r.className = t5, r.appendChild(e), r;
      }
      return e;
    }, i.prototype.createImageElement = function(e) {
      var r = document.createElement("img"), s = e.attrs, l = s.imageUrl, c = s.altText, f = Zn(e.attrs);
      return r.src = l, c && (r.alt = c), iW(f, r), r;
    }, i.prototype.bindEvent = function() {
      this.imageLink && this.dom.addEventListener("mousedown", this.handleMousedown);
    }, i.prototype.stopEvent = function() {
      return !0;
    }, i.prototype.destroy = function() {
      this.imageLink && this.dom.removeEventListener("mousedown", this.handleMousedown);
    }, i;
  }()
), CVe = "toastui-editor-ww-code-block", TVe = "toastui-editor-ww-code-block-language", AVe = (
  /** @class */
  function() {
    function i(e, r, s, l) {
      var c = this;
      this.contentDOM = null, this.input = null, this.timer = null, this.handleMousedown = function(f) {
        var p = f.target, d = getComputedStyle(p, ":after");
        if (d.backgroundImage !== "none" && _o(c.getPos)) {
          var m = c.view.coordsAtPos(c.getPos()), y = m.top, S = m.right;
          c.createLanguageEditor({ top: y, right: S });
        }
      }, this.handleKeydown = function(f) {
        f.key === "Enter" && c.input && (f.preventDefault(), c.changeLanguage());
      }, this.node = e, this.view = r, this.getPos = s, this.eventEmitter = l, this.createElement(), this.bindDOMEvent(), this.bindEvent();
    }
    return i.prototype.createElement = function() {
      var e = this.node.attrs.language, r = document.createElement("div");
      r.setAttribute("data-language", e || "text"), r.className = CVe;
      var s = this.createCodeBlockElement(), l = s.firstChild;
      r.appendChild(s), this.dom = r, this.contentDOM = l;
    }, i.prototype.createCodeBlockElement = function() {
      var e = document.createElement("pre"), r = document.createElement("code"), s = this.node.attrs.language, l = Zn(this.node.attrs);
      return s && r.setAttribute("data-language", s), iW(l, e), e.appendChild(r), e;
    }, i.prototype.createLanguageEditor = function(e) {
      var r = this, s = e.top, l = e.right, c = document.createElement("span");
      c.className = TVe;
      var f = document.createElement("input");
      f.type = "text", f.value = this.node.attrs.language, c.appendChild(f), this.view.dom.parentElement.appendChild(c);
      var p = c.clientWidth;
      js(c, {
        top: s + 10 + "px",
        left: l - p - 10 + "px",
        width: p + "px"
      }), this.input = f, this.input.addEventListener("blur", function() {
        return r.changeLanguage();
      }), this.input.addEventListener("keydown", this.handleKeydown), this.clearTimer(), this.timer = setTimeout(function() {
        r.input.focus();
      });
    }, i.prototype.bindDOMEvent = function() {
      this.dom && this.dom.addEventListener("click", this.handleMousedown);
    }, i.prototype.bindEvent = function() {
      var e = this;
      this.eventEmitter.listen("scroll", function() {
        e.input && e.reset();
      });
    }, i.prototype.changeLanguage = function() {
      if (this.input && _o(this.getPos)) {
        var e = this.input.value;
        this.reset();
        var r = this.getPos(), s = this.view.state.tr;
        s.setNodeMarkup(r, null, { language: e }), this.view.dispatch(s);
      }
    }, i.prototype.reset = function() {
      var e;
      if (!((e = this.input) === null || e === void 0) && e.parentElement) {
        var r = this.input.parentElement;
        this.input = null, Uc(r);
      }
    }, i.prototype.clearTimer = function() {
      this.timer && (clearTimeout(this.timer), this.timer = null);
    }, i.prototype.stopEvent = function() {
      return !0;
    }, i.prototype.update = function(e) {
      return e.sameMarkup(this.node) ? (this.node = e, !0) : !1;
    }, i.prototype.destroy = function() {
      this.reset(), this.clearTimer(), this.dom && this.dom.removeEventListener("click", this.handleMousedown);
    }, i;
  }()
), EVe = /MsoListParagraph/, C9 = /style=(.|\n)*mso-/, T9 = /mso-list:(.*)/, MVe = /O:P/, RVe = /^(n|u|l)/, DVe = "p.MsoListParagraph";
function PVe(i) {
  return C9.test(i);
}
function LVe(i) {
  for (var e = [], r = document.createTreeWalker(i, 1, null, !1); r.nextNode(); ) {
    var s = r.currentNode;
    if (Vx(s)) {
      var l = s, c = l.outerHTML, f = l.textContent, p = C9.test(c), d = T9.test(c);
      p && !d && f ? e.push([s, !0]) : (MVe.test(s.nodeName) || p && !f || d) && e.push([s, !1]);
    }
  }
  return e.forEach(function(m) {
    var y = m[0], S = m[1];
    S ? Zne(y) : Uc(y);
  }), i.innerHTML.trim();
}
function IVe(i, e) {
  var r = i.getAttribute("style");
  if (r) {
    var s = r.match(T9), l = s[1], c = l.trim().split(" "), f = c[1], p = parseInt(f.replace("level", ""), 10), d = RVe.test(i.textContent || "");
    return {
      id: e,
      level: p,
      prev: null,
      parent: null,
      children: [],
      unordered: d,
      contents: LVe(i)
    };
  }
  return null;
}
function _Ve(i, e) {
  if (e.level < i.level)
    e.children.push(i), i.parent = e;
  else {
    for (; e && e.level !== i.level; )
      e = e.parent;
    e && (i.prev = e, i.parent = e.parent, i.parent && i.parent.children.push(i));
  }
}
function NVe(i) {
  var e = [];
  return i.forEach(function(r, s) {
    var l = e[s - 1], c = IVe(r, s);
    c && (l && _Ve(c, l), e.push(c));
  }), e;
}
function A9(i) {
  var e = i[0].unordered ? "ul" : "ol", r = document.createElement(e);
  return i.forEach(function(s) {
    var l = s.children, c = s.contents, f = document.createElement("li");
    f.innerHTML = c, r.appendChild(f), l.length && r.appendChild(A9(l));
  }), r;
}
function BVe(i) {
  var e = NVe(i), r = e.filter(function(s) {
    var l = s.parent;
    return !l;
  });
  return A9(r);
}
function FVe(i) {
  for (; i && !Vx(i); )
    i = i.nextSibling;
  return i ? !EVe.test(i.className) : !0;
}
function zVe(i) {
  var e = document.createElement("div");
  e.innerHTML = i;
  var r = [], s = Kne(e, DVe);
  s.forEach(function(c) {
    var f = FVe(c.nextSibling);
    if (r.push(c), f) {
      var p = BVe(r), d = c.nextSibling;
      d ? Jne(p, d) : Xne(e, p), r = [];
    }
    Uc(c);
  });
  var l = s.length ? "<p></p>" : "";
  return "" + l + e.innerHTML;
}
var r5 = "<!--StartFragment-->", HVe = "<!--EndFragment-->";
function jVe(i) {
  var e = i.indexOf(r5), r = i.lastIndexOf(HVe);
  return e > -1 && r > -1 && (i = i.slice(e + r5.length, r)), i.replace(/<br[^>]*>/g, u4);
}
function WVe(i) {
  return /<\/td>((?!<\/tr>)[\s\S])*$/i.test(i) && (i = "<tr>" + i + "</tr>"), /<\/tr>((?!<\/table>)[\s\S])*$/i.test(i) && (i = "<table>" + i + "</table>"), i;
}
function $Ve(i) {
  return i = jVe(i), i = WVe(i), PVe(i) && (i = zVe(i)), i;
}
function UVe(i) {
  var e = i.reduce(function(r, s) {
    return r.childCount > s.childCount ? r : s;
  });
  return e.childCount;
}
function E9(i, e, r) {
  for (var s = [], l = i.childCount, c = 0; c < l; c += 1)
    if (!i.child(c).attrs.extended) {
      var f = c < l ? r.create(i.child(c).attrs, i.child(c).content) : r.createAndFill();
      s.push(f);
    }
  return s;
}
function M9(i, e, r) {
  var s = r.nodes, l = s.tableRow, c = s.tableHeadCell, f = E9(i, e, c);
  return l.create(null, f);
}
function R9(i, e, r) {
  var s = r.nodes, l = s.tableRow, c = s.tableBodyCell, f = E9(i, e, c);
  return l.create(null, f);
}
function VVe(i, e) {
  for (var r = e.nodes, s = r.tableRow, l = r.tableBodyCell, c = [], f = 0; f < i; f += 1) {
    var p = l.createAndFill();
    c.push(p);
  }
  return s.create({ dummyRowForPasting: !0 }, c);
}
function D9(i) {
  var e = [], r = [];
  if (i.firstChild.type.name === "tableHead") {
    var s = i.firstChild;
    s.forEach(function(c) {
      return e.push(c);
    });
  }
  if (i.lastChild.type.name === "tableBody") {
    var l = i.lastChild;
    l.forEach(function(c) {
      return r.push(c);
    });
  }
  return Ha(Ha([], e), r);
}
function GVe(i, e, r) {
  var s = M9(i, e, r);
  return r.nodes.tableHead.create(null, s);
}
function n5(i, e, r) {
  var s = i.map(function(c) {
    return R9(c, e, r);
  });
  if (!i.length) {
    var l = VVe(e, r);
    s.push(l);
  }
  return r.nodes.tableBody.create(null, s);
}
function YVe(i, e, r, s) {
  var l = UVe(i);
  if (r && s)
    return e.nodes.table.create(null, [n5(i, l, e)]);
  var c = i[0], f = i.slice(1), p = [GVe(c, l, e)];
  return f.length && p.push(n5(f, l, e)), e.nodes.table.create(null, p);
}
function qVe(i, e, r) {
  var s = [], l = i.content, c = i.openStart, f = i.openEnd;
  return l.forEach(function(p) {
    if (p.type.name === "table") {
      var d = x9(new ur(qt.from(p), 0, 0));
      if (d) {
        var m = D9(d), y = d.firstChild.type.name === "tableBody", S = YVe(m, e, y, r);
        s.push(S);
      }
    } else
      s.push(p);
  }), new ur(qt.from(s), c, f);
}
var KVe = 4, XVe = 2;
function ex(i) {
  return i * KVe;
}
function JVe(i, e, r) {
  var s = [], l = D9(i), c = l[0].childCount, f = l.length, p = e.startRowIdx === 0, d = l.slice(0, f);
  if (p) {
    var m = d.shift();
    if (m) {
      var y = M9(m, c, r).content;
      s.push(y);
    }
  }
  return d.forEach(function(S) {
    if (!S.attrs.dummyRowForPasting) {
      var x = R9(S, c, r).content;
      s.push(x);
    }
  }), s;
}
function ZVe(i, e, r) {
  for (var s = e.startRowIdx, l = e.startColIdx, c = r.length, f = 0, p = function(w) {
    var k = r[w].childCount;
    r[w].forEach(function(O) {
      var T = O.attrs, L = T.colspan;
      L > 1 && (k += L - 1);
    }), f = Math.max(f, k);
  }, d = 0; d < c; d += 1)
    p(d);
  var m = s + c - 1, y = l + f - 1, S = Math.max(m + 1 - i.totalRowCount, 0), x = Math.max(y + 1 - i.totalColumnCount, 0);
  return {
    startRowIdx: s,
    startColIdx: l,
    endRowIdx: m,
    endColIdx: y,
    addedRowCount: S,
    addedColumnCount: x
  };
}
function QVe(i, e) {
  for (var r = i.startRowIdx, s = i.startColIdx, l = i.endRowIdx, c = i.endColIdx, f = i.addedRowCount, p = i.addedColumnCount, d = r; d <= l - f; d += 1)
    e.push({
      rowIdx: d,
      startColIdx: s,
      endColIdx: c - p
    });
}
function e6e(i, e, r, s, l) {
  for (var c = s.startRowIdx, f = s.startColIdx, p = s.endRowIdx, d = s.endColIdx, m = s.addedRowCount, y = s.addedColumnCount, S = r.totalRowCount, x = 0, w = 0; w < S; w += 1) {
    var k = r.getCellInfo(w, d - y), O = k.offset, T = k.nodeSize, L = i.mapping.map(O + T), j = Qw(y, w, e);
    if (i.insert(L, j), w >= c && w <= p - m) {
      var z = r.getCellInfo(w, d - y), J = i.mapping.map(z.offset), ie = L + ex(y);
      l[x] = {
        rowIdx: w,
        startColIdx: f,
        endColIdx: d,
        dummyOffsets: [J, ie]
      }, x += 1;
    }
  }
}
function t6e(i, e, r, s, l) {
  var c = s.addedRowCount, f = s.addedColumnCount, p = s.startColIdx, d = s.endColIdx, m = i.mapping.maps.length, y = r.tableEndOffset - 2, S = b9(c, r.totalColumnCount + f, e), x = y;
  i.insert(i.mapping.slice(m).map(x), S);
  for (var w = 0; w < c; w += 1) {
    var k = x + ex(p) + 1, O = x + ex(d + 1) + 1, T = x + ex(r.totalColumnCount + f) + XVe;
    l.push({
      rowIdx: w + r.totalRowCount,
      startColIdx: p,
      endColIdx: d,
      dummyOffsets: [k, O]
    }), x = T;
  }
}
function r6e(i, e, r, s) {
  var l = i.mapping.maps.length;
  r.forEach(function(c, f) {
    var p = c.rowIdx, d = c.startColIdx, m = c.endColIdx, y = c.dummyOffsets, S = i.mapping.slice(l), x = new ur(e[f], 0, 0), w = y ? y[0] : s.getCellStartOffset(p, d), k = y ? y[1] : s.getCellEndOffset(p, m);
    i.replace(S.map(w), S.map(k), x);
  });
}
function n6e(i, e) {
  var r = i.state, s = r.selection, l = r.schema, c = r.tr, f = Ls(s), p = f.anchor, d = f.head;
  if (p && d) {
    var m = x9(e);
    if (!m)
      return !1;
    var y = Ti.create(p), S = y.getRectOffsets(p, d), x = JVe(m, S, l), w = ZVe(y, S, x), k = [];
    return a6e(y, w) && (QVe(w, k), w.addedColumnCount && e6e(c, l, y, w, k), w.addedRowCount && t6e(c, l, y, w, k), r6e(c, x, k, y), i.dispatch(c), i6e(i, k, y.getCellInfo(0, 0).offset)), !0;
  }
  return !1;
}
function i6e(i, e, r) {
  var s = i.state, l = s.tr, c = s.doc, f = Ti.create(c.resolve(r)), p = e[0], d = p.rowIdx, m = p.startColIdx, y = Qi(e), S = y.rowIdx, x = y.endColIdx, w = f.getCellInfo(d, m).offset, k = f.getCellInfo(S, x).offset;
  i.dispatch(l.setSelection(new bW(c.resolve(w), c.resolve(k))));
}
function a6e(i, e) {
  var r = i.getSpannedOffsets(e), s = ip(r), l = s.rowCount, c = s.columnCount, f = ip(e), p = f.rowCount, d = f.columnCount;
  return l === p && c === d;
}
var o6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "doc";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "block+"
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Sn)
), s6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "paragraph";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "inline*",
          group: "block",
          attrs: Nt({}, yi()),
          parseDOM: [{ tag: "p" }],
          toDOM: function(r) {
            var s = r.attrs;
            return ["p", Zn(s), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Sn)
), l6e = /\s{1,4}$/, u6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "text";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          group: "inline"
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.addSpaces = function() {
      return function(r, s) {
        var l = r.selection, c = r.tr, f = l.$from, p = l.$to, d = f.blockRange(p);
        return d && !wp(f) && !Mx(f) ? (s(c.insertText("    ", f.pos, p.pos)), !0) : !1;
      };
    }, e.prototype.removeSpaces = function() {
      return function(r, s) {
        var l = r.selection, c = r.tr, f = l.$from, p = l.$to, d = l.from, m = f.blockRange(p);
        if (m && !wp(f) && !Mx(f)) {
          var y = f.nodeBefore;
          if (y && y.isText) {
            var S = y.text, x = S.replace(l6e, ""), w = S.length - x.length;
            return s(c.delete(d - w, d)), !0;
          }
        }
        return !1;
      };
    }, e.prototype.keymaps = function() {
      return {
        Tab: this.addSpaces(),
        "Shift-Tab": this.removeSpaces()
      };
    }, e;
  }(Sn)
), c6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "heading";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "levels", {
      get: function() {
        return [1, 2, 3, 4, 5, 6];
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        var r = this.levels.map(function(s) {
          return {
            tag: "h" + s,
            getAttrs: function(l) {
              var c = l.getAttribute("data-raw-html");
              return Nt({ level: s }, c && { rawHTML: c });
            }
          };
        });
        return {
          attrs: Nt({ level: { default: 1 }, headingType: { default: "atx" }, rawHTML: { default: null } }, yi()),
          content: "inline*",
          group: "block",
          defining: !0,
          parseDOM: r,
          toDOM: function(s) {
            var l = s.attrs;
            return ["h" + l.level, Zn(l), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return function(r) {
        return function(s, l) {
          var c = s.schema.nodes[r.level ? "heading" : "paragraph"];
          return U3(c, r)(s, l);
        };
      };
    }, e;
  }(Sn)
), f6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "codeBlock";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          attrs: Nt({ language: { default: null }, rawHTML: { default: null } }, yi()),
          code: !0,
          defining: !0,
          marks: "",
          parseDOM: [
            {
              tag: "pre",
              preserveWhitespace: "full",
              getAttrs: function(r) {
                var s = r.getAttribute("data-raw-html"), l = r.firstElementChild;
                return Nt({ language: (l == null ? void 0 : l.getAttribute("data-language")) || null }, s && { rawHTML: s });
              }
            }
          ],
          toDOM: function(r) {
            var s = r.attrs;
            return [
              s.rawHTML || "pre",
              ["code", Nt({ "data-language": s.language }, Zn(s)), 0]
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return function() {
        return function(r, s) {
          return U3(r.schema.nodes.codeBlock)(r, s);
        };
      };
    }, e.prototype.moveCursor = function(r) {
      var s = this;
      return function(l, c) {
        var f = l.tr, p = l.doc, d = l.schema, m = l.selection.$from, y = s.context.view;
        if (y.endOfTextblock(r) && m.node().type.name === "codeBlock") {
          var S = m.parent.textContent.split(`
`), x = r === "up" ? m.start() : m.end(), w = r === "up" ? [x, S[0].length + x] : [x - Qi(S).length, x], k = p.resolve(r === "up" ? m.before() : m.after()), O = r === "up" ? k.nodeBefore : k.nodeAfter;
          if (gne(m.pos, w[0], w[1]) && !O) {
            var T = Q3(f, k, d);
            if (T)
              return c(T), !0;
          }
        }
        return !1;
      };
    }, e.prototype.keymaps = function() {
      var r = this.commands()();
      return {
        "Shift-Mod-p": r,
        "Shift-Mod-P": r,
        ArrowUp: this.moveCursor("up"),
        ArrowDown: this.moveCursor("down")
      };
    }, e;
  }(Sn)
), d6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "bulletList";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "listItem+",
          group: "block",
          attrs: Nt({ rawHTML: { default: null } }, yi()),
          parseDOM: [Zx("ul")],
          toDOM: function(r) {
            var s = r.attrs;
            return ["ul", Zn(s), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.changeList = function() {
      return function(r, s) {
        return y9(r.schema.nodes.bulletList)(r, s);
      };
    }, e.prototype.commands = function() {
      return {
        bulletList: this.changeList,
        taskList: Y5e
      };
    }, e.prototype.keymaps = function() {
      var r = this.changeList(), s = yW(), l = s.indent, c = s.outdent;
      return {
        "Mod-u": r,
        "Mod-U": r,
        Tab: l(),
        "Shift-Tab": c()
      };
    }, e;
  }(Sn)
), h6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "orderedList";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "listItem+",
          group: "block",
          attrs: Nt({ order: { default: 1 }, rawHTML: { default: null } }, yi()),
          parseDOM: [
            {
              tag: "ol",
              getAttrs: function(r) {
                var s = r.getAttribute("start"), l = r.getAttribute("data-raw-html");
                return Nt({ order: r.hasAttribute("start") ? Number(s) : 1 }, l && { rawHTML: l });
              }
            }
          ],
          toDOM: function(r) {
            var s = r.attrs;
            return [
              s.rawHTML || "ol",
              Nt({ start: s.order === 1 ? null : s.order }, Zn(s)),
              0
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return function() {
        return function(r, s) {
          return y9(r.schema.nodes.orderedList)(r, s);
        };
      };
    }, e.prototype.keymaps = function() {
      var r = this.commands()(), s = yW(), l = s.indent, c = s.outdent;
      return {
        "Mod-o": r,
        "Mod-O": r,
        Tab: l(),
        "Shift-Tab": c()
      };
    }, e;
  }(Sn)
), p6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "listItem";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "paragraph block*",
          selectable: !1,
          attrs: {
            task: { default: !1 },
            checked: { default: !1 },
            rawHTML: { default: null }
          },
          defining: !0,
          parseDOM: [
            {
              tag: "li",
              getAttrs: function(r) {
                var s = r.getAttribute("data-raw-html");
                return Nt({ task: r.hasAttribute("data-task"), checked: r.hasAttribute("data-task-checked") }, s && { rawHTML: s });
              }
            }
          ],
          toDOM: function(r) {
            var s = r.attrs, l = s.task, c = s.checked;
            if (!l)
              return [s.rawHTML || "li", 0];
            var f = ["task-list-item"];
            return c && f.push("checked"), [
              s.rawHTML || "li",
              Nt({ class: f.join(" "), "data-task": l }, c && { "data-task-checked": c }),
              0
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.liftToPrevListItem = function() {
      return function(r, s) {
        var l = r.selection, c = r.tr, f = r.schema, p = l.$from, d = l.empty, m = f.nodes.listItem, y = p.parent, S = p.node(-1);
        if (d && !y.childCount && S.type === m) {
          if (p.index(-2) >= 1)
            return c.delete(p.start(-1) - 1, p.end(-1)), s(c), !0;
          var x = p.node(-3);
          if (x.type === m)
            return c.delete(p.start(-2) - 1, p.end(-1)), s(c), !0;
        }
        return !1;
      };
    }, e.prototype.keymaps = function() {
      var r = function(s, l) {
        return Z5e(s.schema.nodes.listItem)(s, l);
      };
      return {
        Backspace: this.liftToPrevListItem(),
        Enter: r
      };
    }, e;
  }(Sn)
), v6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "blockQuote";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          attrs: Nt({ rawHTML: { default: null } }, yi()),
          content: "block+",
          group: "block",
          parseDOM: [Zx("blockquote")],
          toDOM: function(r) {
            var s = r.attrs;
            return ["blockquote", Zn(s), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return function() {
        return function(r, s) {
          return ore(r.schema.nodes.blockQuote)(r, s);
        };
      };
    }, e.prototype.keymaps = function() {
      var r = this.commands()();
      return {
        "Alt-q": r,
        "Alt-Q": r
      };
    }, e;
  }(Sn)
), m6e = {
  left: O6e,
  right: k6e,
  up: C6e,
  down: T6e
};
function g6e(i, e, r) {
  var s = r[0], l = r[1], c = e.resolve(i.before(s - 1));
  return l === s && !c.nodeBefore;
}
function y6e(i) {
  for (var e, r = i.depth, s; r && (s = i.node(r), s.type.name !== "tableBodyCell"); ) {
    if (s.type.name === "listItem") {
      var l = i.node(r - 1), c = l.lastChild === s, f = ((e = s.lastChild) === null || e === void 0 ? void 0 : e.type.name) !== "paragraph";
      return c ? !f : !1;
    }
    r -= 1;
  }
  return !1;
}
function b6e(i, e, r, s, l) {
  var c = e[0], f = e[1], p = e[2];
  if (i === "left" || i === "up") {
    if (l && !g6e(r, s, [c, f]))
      return !1;
    var d = r.before(p), m = s.resolve(d).nodeBefore;
    if (m)
      return !1;
  }
  return !0;
}
function S6e(i, e, r, s, l) {
  if (i === "right" || i === "down") {
    if (l && !y6e(r))
      return !1;
    var c = r.after(e), f = s.resolve(c).nodeAfter;
    if (f)
      return !1;
  }
  return !0;
}
function w6e(i, e, r, s) {
  var l = e[0], c = e[1], f = l + 3, p = c >= f, d = p ? l + 1 : c, m = b6e(i, [c, f, d], r, s, p), y = S6e(i, d, r, s, p);
  return m && y;
}
function i5(i, e, r) {
  var s = r[0], l = r[1], c = e.getRowspanStartInfo(s, l), f = i === "up" && s === 0, p = i === "down" && ((c == null ? void 0 : c.count) > 1 ? s + c.count - 1 : s) === e.totalRowCount - 1;
  return f || p;
}
function x6e(i, e, r) {
  var s = i.doc.resolve(e.tableStartOffset - 1);
  return s.nodeBefore ? i.setSelection(jr.near(s, -1)) : Q3(i, s, r);
}
function wj(i, e, r, s) {
  s === void 0 && (s = !1);
  var l = i.doc.resolve(e.tableEndOffset);
  return s || !l.nodeAfter ? Q3(i, l, r) : i.setSelection(jr.near(l, 1));
}
function k6e(i, e) {
  var r = i[0], s = i[1], l = e.totalRowCount, c = e.totalColumnCount, f = s === c - 1, p = r === l - 1 && f;
  if (!p) {
    var d = s + 1, m = e.getColspanStartInfo(r, s);
    (m == null ? void 0 : m.count) > 1 && (d += m.count - 1), (f || d === c) && (r += 1, d = 0);
    var y = e.getCellInfo(r, d).offset;
    return y + 2;
  }
  return null;
}
function O6e(i, e) {
  var r = i[0], s = i[1], l = e.totalColumnCount, c = s === 0, f = r === 0 && c;
  if (!f) {
    s -= 1, c && (r -= 1, s = l - 1);
    var p = e.getCellInfo(r, s), d = p.offset, m = p.nodeSize;
    return d + m - 2;
  }
  return null;
}
function C6e(i, e) {
  var r = i[0], s = i[1];
  if (r > 0) {
    var l = e.getCellInfo(r - 1, s), c = l.offset, f = l.nodeSize;
    return c + f - 2;
  }
  return null;
}
function T6e(i, e) {
  var r = i[0], s = i[1], l = e.totalRowCount;
  if (r < l - 1) {
    var c = r + 1, f = e.getRowspanStartInfo(r, s);
    (f == null ? void 0 : f.count) > 1 && (c += f.count - 1);
    var p = e.getCellInfo(c, s).offset;
    return p + 2;
  }
  return null;
}
function a5(i, e, r, s) {
  var l = m6e[i], c = l(r, s);
  if (c) {
    var f = i === "right" || i === "down" ? 1 : -1;
    return e.setSelection(jr.near(e.doc.resolve(c), f));
  }
  return null;
}
function A6e(i, e, r) {
  var s = r[0], l = r[1];
  if (i === "up" || i === "down")
    return !1;
  var c = e.tableStartOffset, f = e.tableEndOffset, p = e.getCellInfo(s, l), d = p.offset, m = p.nodeSize, y = i === "left" ? c : f, S = i === "left" ? d - 2 : d + m + 3;
  return y === S;
}
function E6e(i, e, r) {
  var s = i.doc.resolve(e.before(r - 3));
  return i.setSelection(new Er(s));
}
function M6e(i, e, r) {
  var s, l, c;
  return i === "up" ? (s = r.startRowIdx, l = 0, c = -1) : (s = r.endRowIdx, l = e.totalColumnCount - 1, c = e.getCellInfo(s, l).nodeSize + 1), { targetRowIdx: s, insertColIdx: l, nodeSize: c };
}
function R6e(i, e, r) {
  var s = i.getCellInfo(e, 0).offset, l = i.getCellInfo(e, r - 1), c = l.offset, f = l.nodeSize;
  return { from: s, to: c + f };
}
var D6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "table";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "tableHead{1} tableBody{1}",
          group: "block",
          attrs: Nt({ rawHTML: { default: null } }, yi()),
          parseDOM: [Zx("table")],
          toDOM: function(r) {
            var s = r.attrs;
            return ["table", Zn(s), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.addTable = function() {
      return function(r) {
        return r === void 0 && (r = { rowCount: 2, columnCount: 1, data: [] }), function(s, l) {
          var c = r.rowCount, f = r.columnCount, p = r.data, d = s.schema, m = s.selection, y = s.tr, S = m.from, x = m.to, w = m.$from, k = S === x;
          if (k && !Mx(w)) {
            var O = d.nodes, T = O.tableHead, L = O.tableBody, j = p == null ? void 0 : p.slice(0, f), z = p == null ? void 0 : p.slice(f, p.length), J = iVe(f, d, j), ie = b9(c - 1, f, d, z), K = d.nodes.table.create(null, [
              T.create(null, J),
              L.create(null, ie)
            ]);
            return l(y.replaceSelectionWith(K)), !0;
          }
          return !1;
        };
      };
    }, e.prototype.removeTable = function() {
      return function() {
        return function(r, s) {
          var l = r.selection, c = r.tr, f = Ti.create(l.$anchor);
          if (f) {
            var p = f.tableStartOffset, d = f.tableEndOffset, m = p - 1, y = On(c.delete(m, d), m);
            return s(c.setSelection(y)), !0;
          }
          return !1;
        };
      };
    }, e.prototype.addColumn = function(r) {
      return function() {
        return function(s, l) {
          var c = s.selection, f = s.tr, p = s.schema, d = Ls(c), m = d.anchor, y = d.head;
          if (m && y) {
            for (var S = Ti.create(m), x = S.getRectOffsets(m, y), w = r === "left" ? x.startColIdx : x.endColIdx + 1, k = ip(x).columnCount, O = S.totalRowCount, T = 0; T < O; T += 1) {
              var L = Qw(k, T, p);
              f.insert(f.mapping.map(S.posAt(T, w)), L);
            }
            return l(f), !0;
          }
          return !1;
        };
      };
    }, e.prototype.removeColumn = function() {
      return function() {
        return function(r, s) {
          var l = r.selection, c = r.tr, f = Ls(l), p = f.anchor, d = f.head;
          if (p && d) {
            var m = Ti.create(p), y = m.getRectOffsets(p, d), S = m.totalColumnCount, x = m.totalRowCount, w = ip(y).columnCount, k = w === S;
            if (k)
              return !1;
            for (var O = y.startColIdx, T = y.endColIdx, L = c.mapping.maps.length, j = 0; j < x; j += 1)
              for (var z = T; z >= O; z -= 1) {
                var J = m.getCellInfo(j, z), ie = J.offset, K = J.nodeSize, re = c.mapping.slice(L).map(ie), ee = re + K;
                c.delete(re, ee);
              }
            return s(c), !0;
          }
          return !1;
        };
      };
    }, e.prototype.addRow = function(r) {
      return function() {
        return function(s, l) {
          var c = s.selection, f = s.schema, p = s.tr, d = Ls(c), m = d.anchor, y = d.head;
          if (m && y) {
            var S = Ti.create(m), x = S.totalColumnCount, w = S.getRectOffsets(m, y), k = ip(w).rowCount, O = M6e(r, S, w), T = O.targetRowIdx, L = O.insertColIdx, j = O.nodeSize, z = T === 0;
            if (!z) {
              for (var J = [], ie = p.mapping.map(S.posAt(T, L)) + j, K = [], re = 0; re < x; re += 1)
                K = K.concat(Qw(1, T, f));
              for (var ee = 0; ee < k; ee += 1)
                J.push(f.nodes.tableRow.create(null, K));
              return l(p.insert(ie, J)), !0;
            }
          }
          return !1;
        };
      };
    }, e.prototype.removeRow = function() {
      return function() {
        return function(r, s) {
          var l = r.selection, c = r.tr, f = Ls(l), p = f.anchor, d = f.head;
          if (p && d) {
            var m = Ti.create(p), y = m.totalRowCount, S = m.totalColumnCount, x = m.getRectOffsets(p, d), w = ip(x).rowCount, k = x.startRowIdx, O = x.endRowIdx, T = k === 0, L = w === y - 1;
            if (L || T)
              return !1;
            for (var j = O; j >= k; j -= 1) {
              var z = R6e(m, j, S), J = z.from, ie = z.to;
              c.delete(J - 1, ie + 1);
            }
            return s(c), !0;
          }
          return !1;
        };
      };
    }, e.prototype.alignColumn = function() {
      return function(r) {
        return r === void 0 && (r = { align: "center" }), function(s, l) {
          var c = r.align, f = s.selection, p = s.tr, d = Ls(f), m = d.anchor, y = d.head;
          if (m && y) {
            for (var S = Ti.create(m), x = S.totalRowCount, w = S.getRectOffsets(m, y), k = w.startColIdx, O = w.endColIdx, T = 0; T < x; T += 1)
              for (var L = k; L <= O; L += 1)
                if (!S.extendedRowspan(T, L) && !S.extendedColspan(T, L)) {
                  var j = S.getNodeAndPos(T, L), z = j.node, J = j.pos, ie = aVe(z, { align: c });
                  p.setNodeMarkup(J, null, ie);
                }
            return l(p), !0;
          }
          return !1;
        };
      };
    }, e.prototype.moveToCell = function(r) {
      return function(s, l) {
        var c = s.selection, f = s.tr, p = s.schema, d = Ls(c), m = d.anchor, y = d.head;
        if (m && y) {
          var S = Ti.create(m), x = S.getCellIndex(m), w = void 0;
          if (i5(r, S, x) ? w = wj(f, S, p) : w = a5(r, f, x, S), w)
            return l(w), !0;
        }
        return !1;
      };
    }, e.prototype.moveInCell = function(r) {
      var s = this;
      return function(l, c) {
        var f = l.selection, p = l.tr, d = l.doc, m = l.schema, y = f.$from, S = s.context.view;
        if (!S.endOfTextblock(r))
          return !1;
        var x = Sl(y, function(z) {
          var J = z.type;
          return J.name === "tableHeadCell" || J.name === "tableBodyCell";
        });
        if (x) {
          var w = Sl(y, function(z) {
            var J = z.type;
            return J.name === "paragraph";
          }), k = x.depth;
          if (w && w6e(r, [k, w.depth], y, d)) {
            var O = Ls(f).anchor, T = Ti.create(O), L = T.getCellIndex(O), j = void 0;
            if (A6e(r, T, L) ? j = E6e(p, y, k) : i5(r, T, L) ? r === "up" ? j = x6e(p, T, m) : r === "down" && (j = wj(p, T, m)) : j = a5(r, p, L, T), j)
              return c(j), !0;
          }
        }
        return !1;
      };
    }, e.prototype.deleteCells = function() {
      return function(r, s) {
        var l = r.schema, c = r.selection, f = r.tr, p = Ls(c), d = p.anchor, m = p.head, y = c instanceof Zr;
        if (d && m && !y) {
          for (var S = Ti.create(d), x = S.getRectOffsets(d, m), w = x.startRowIdx, k = x.startColIdx, O = x.endRowIdx, T = x.endColIdx, L = w; L <= O; L += 1)
            for (var j = k; j <= T; j += 1)
              if (!S.extendedRowspan(L, j) && !S.extendedColspan(L, j)) {
                var z = S.getNodeAndPos(L, j), J = z.node, ie = z.pos, K = Qw(1, L, l, J.attrs);
                f.replaceWith(f.mapping.map(ie), f.mapping.map(ie + J.nodeSize), K);
              }
          return s(f), !0;
        }
        return !1;
      };
    }, e.prototype.exitTable = function() {
      return function(r, s) {
        var l = r.selection, c = r.tr, f = r.schema, p = l.$from, d = Sl(p, function(x) {
          var w = x.type;
          return w.name === "tableHeadCell" || w.name === "tableBodyCell";
        });
        if (d) {
          var m = Sl(p, function(x) {
            var w = x.type;
            return w.name === "paragraph";
          });
          if (m) {
            var y = Ls(l).anchor, S = Ti.create(y);
            return s(wj(c, S, f, !0)), !0;
          }
        }
        return !1;
      };
    }, e.prototype.commands = function() {
      return {
        addTable: this.addTable(),
        removeTable: this.removeTable(),
        addColumnToLeft: this.addColumn(
          "left"
          /* LEFT */
        ),
        addColumnToRight: this.addColumn(
          "right"
          /* RIGHT */
        ),
        removeColumn: this.removeColumn(),
        addRowToUp: this.addRow(
          "up"
          /* UP */
        ),
        addRowToDown: this.addRow(
          "down"
          /* DOWN */
        ),
        removeRow: this.removeRow(),
        alignColumn: this.alignColumn()
      };
    }, e.prototype.keymaps = function() {
      var r = this.deleteCells();
      return {
        Tab: this.moveToCell(
          "right"
          /* RIGHT */
        ),
        "Shift-Tab": this.moveToCell(
          "left"
          /* LEFT */
        ),
        ArrowUp: this.moveInCell(
          "up"
          /* UP */
        ),
        ArrowDown: this.moveInCell(
          "down"
          /* DOWN */
        ),
        ArrowLeft: this.moveInCell(
          "left"
          /* LEFT */
        ),
        ArrowRight: this.moveInCell(
          "right"
          /* RIGHT */
        ),
        Backspace: r,
        "Mod-Backspace": r,
        Delete: r,
        "Mod-Delete": r,
        "Mod-Enter": this.exitTable()
      };
    }, e;
  }(Sn)
), P6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "tableHead";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "tableRow{1}",
          attrs: Nt({ rawHTML: { default: null } }, yi()),
          parseDOM: [Zx("thead")],
          toDOM: function(r) {
            var s = r.attrs;
            return ["thead", Zn(s), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Sn)
), L6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "tableBody";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "tableRow+",
          attrs: Nt({ rawHTML: { default: null } }, yi()),
          parseDOM: [
            {
              tag: "tbody",
              getAttrs: function(r) {
                var s = r.querySelectorAll("tr"), l = s[0].children.length, c = r.getAttribute("data-raw-html");
                return l ? Nt({}, c && { rawHTML: c }) : !1;
              }
            }
          ],
          toDOM: function(r) {
            var s = r.attrs;
            return ["tbody", Zn(s), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Sn)
), I6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "tableRow";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "(tableHeadCell | tableBodyCell)*",
          attrs: Nt({ rawHTML: { default: null } }, yi()),
          parseDOM: [
            {
              tag: "tr",
              getAttrs: function(r) {
                var s = r.children.length, l = r.getAttribute("data-raw-html");
                return s ? Nt({}, l && { rawHTML: l }) : !1;
              }
            }
          ],
          toDOM: function(r) {
            var s = r.attrs;
            return ["tr", Zn(s), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Sn)
), _6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "tableHeadCell";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "paragraph+",
          attrs: Nt({ align: { default: null }, className: { default: null }, rawHTML: { default: null }, colspan: { default: null }, extended: { default: null } }, yi()),
          isolating: !0,
          parseDOM: [v9("th")],
          toDOM: function(r) {
            var s = r.attrs, l = p9(s);
            return ["th", Nt(Nt({}, l), Zn(s)), 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Sn)
), N6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "tableBodyCell";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "(paragraph | bulletList | orderedList)+",
          attrs: {
            align: { default: null },
            className: { default: null },
            rawHTML: { default: null },
            colspan: { default: null },
            rowspan: { default: null },
            extended: { default: null }
          },
          isolating: !0,
          parseDOM: [v9("td")],
          toDOM: function(r) {
            var s = r.attrs, l = p9(s);
            return ["td", l, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Sn)
), B6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "image";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          inline: !0,
          attrs: Nt({ imageUrl: { default: "" }, altText: { default: null }, rawHTML: { default: null } }, yi()),
          group: "inline",
          selectable: !1,
          parseDOM: [
            {
              tag: "img[src]",
              getAttrs: function(r) {
                var s = Yc(r, { RETURN_DOM_FRAGMENT: !0 }).firstChild, l = s.getAttribute("src") || "", c = s.getAttribute("data-raw-html"), f = s.getAttribute("alt");
                return Nt({
                  imageUrl: l,
                  altText: f
                }, c && { rawHTML: c });
              }
            }
          ],
          toDOM: function(r) {
            var s = r.attrs;
            return [
              s.rawHTML || "img",
              Nt(Nt({ src: np(s.imageUrl) }, s.altText && { alt: s.altText }), Zn(s))
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.addImage = function() {
      return function(r) {
        return function(s, l) {
          var c = s.schema, f = s.tr, p = r, d = p.imageUrl, m = p.altText;
          if (!d)
            return !1;
          var y = c.nodes.image.createAndFill(Nt({ imageUrl: d }, m && { altText: m }));
          return l(f.replaceSelectionWith(y).scrollIntoView()), !0;
        };
      };
    }, e.prototype.commands = function() {
      return {
        addImage: this.addImage()
      };
    }, e;
  }(Sn)
), o5 = 1, F6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "thematicBreak";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          attrs: Nt({ rawHTML: { default: null } }, yi()),
          group: "block",
          parseDOM: [{ tag: "hr" }],
          selectable: !1,
          toDOM: function(r) {
            var s = r.attrs;
            return ["div", Zn(s), [s.rawHTML || "hr"]];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.hr = function() {
      var r = this;
      return function() {
        return function(s, l) {
          var c, f = s.selection, p = f.$from, d = f.$to;
          if (p === d) {
            var m = s.doc, y = s.schema.nodes, S = y.thematicBreak, x = y.paragraph, w = [S.create()], k = p.node(o5), O = m.child(m.childCount - 1) === k, T = m.resolve(p.after(o5)), L = ((c = p.nodeAfter) === null || c === void 0 ? void 0 : c.type.name) === r.name;
            return (O || L) && w.push(x.create()), l(s.tr.insert(T.pos, w).scrollIntoView()), !0;
          }
          return !1;
        };
      };
    }, e.prototype.commands = function() {
      return { hr: this.hr() };
    }, e.prototype.keymaps = function() {
      var r = this.hr()();
      return {
        "Mod-l": r,
        "Mod-L": r
      };
    }, e;
  }(Sn)
), z6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "strong";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        var r = ["b", "strong"].map(function(s) {
          return {
            tag: s,
            getAttrs: function(l) {
              var c = l.getAttribute("data-raw-html");
              return Nt({}, c && { rawHTML: c });
            }
          };
        });
        return {
          attrs: Nt({ rawHTML: { default: null } }, yi()),
          parseDOM: r,
          toDOM: function(s) {
            var l = s.attrs;
            return [l.rawHTML || "strong", Zn(l)];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.bold = function() {
      return function() {
        return function(r, s) {
          return ny(r.schema.marks.strong)(r, s);
        };
      };
    }, e.prototype.commands = function() {
      return { bold: this.bold() };
    }, e.prototype.keymaps = function() {
      var r = this.bold()();
      return {
        "Mod-b": r,
        "Mod-B": r
      };
    }, e;
  }(Cn)
), H6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "emph";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        var r = ["i", "em"].map(function(s) {
          return {
            tag: s,
            getAttrs: function(l) {
              var c = l.getAttribute("data-raw-html");
              return Nt({}, c && { rawHTML: c });
            }
          };
        });
        return {
          attrs: Nt({ rawHTML: { default: null } }, yi()),
          parseDOM: r,
          toDOM: function(s) {
            var l = s.attrs;
            return [l.rawHTML || "em", Zn(l)];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.italic = function() {
      return function() {
        return function(r, s) {
          return ny(r.schema.marks.emph)(r, s);
        };
      };
    }, e.prototype.commands = function() {
      return { italic: this.italic() };
    }, e.prototype.keymaps = function() {
      var r = this.italic()();
      return {
        "Mod-i": r,
        "Mod-I": r
      };
    }, e;
  }(Cn)
), j6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "strike";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        var r = ["s", "del"].map(function(s) {
          return {
            tag: s,
            getAttrs: function(l) {
              var c = l.getAttribute("data-raw-html");
              return Nt({}, c && { rawHTML: c });
            }
          };
        });
        return {
          attrs: Nt({ rawHTML: { default: null } }, yi()),
          parseDOM: r,
          toDOM: function(s) {
            var l = s.attrs;
            return [l.rawHTML || "del", Zn(l)];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return function() {
        return function(r, s) {
          return ny(r.schema.marks.strike)(r, s);
        };
      };
    }, e.prototype.keymaps = function() {
      var r = this.commands()();
      return {
        "Mod-s": r,
        "Mod-S": r
      };
    }, e;
  }(Cn)
), W6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e(r) {
      var s = i.call(this) || this;
      return s.linkAttributes = r, s;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "link";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        var r = this;
        return {
          attrs: Nt({ linkUrl: { default: "" }, title: { default: null }, rawHTML: { default: null } }, yi()),
          inclusive: !1,
          parseDOM: [
            {
              tag: "a[href]",
              getAttrs: function(s) {
                var l = Yc(s, { RETURN_DOM_FRAGMENT: !0 }).firstChild, c = l.getAttribute("href") || "", f = l.getAttribute("title") || "", p = l.getAttribute("data-raw-html");
                return Nt({ linkUrl: c, title: f }, p && { rawHTML: p });
              }
            }
          ],
          toDOM: function(s) {
            var l = s.attrs;
            return [
              l.rawHTML || "a",
              Nt(Nt({ href: np(l.linkUrl) }, r.linkAttributes), Zn(l))
            ];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.addLink = function() {
      return function(r) {
        return function(s, l) {
          var c = r, f = c.linkUrl, p = c.linkText, d = p === void 0 ? "" : p, m = s.schema, y = s.tr, S = s.selection, x = S.empty, w = S.from, k = S.to;
          if (w && k && f) {
            var O = { linkUrl: f }, T = m.mark("link", O);
            if (x && d) {
              var L = Mi(m, d, T);
              y.replaceRangeWith(w, k, L);
            } else
              y.addMark(w, k, T);
            return l(y.scrollIntoView()), !0;
          }
          return !1;
        };
      };
    }, e.prototype.toggleLink = function() {
      return function(r) {
        return function(s, l) {
          return ny(s.schema.marks.link, r)(s, l);
        };
      };
    }, e.prototype.commands = function() {
      return {
        addLink: this.addLink(),
        toggleLink: this.toggleLink()
      };
    }, e;
  }(Cn)
), $6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "code";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          attrs: Nt({ rawHTML: { default: null } }, yi()),
          parseDOM: [
            {
              tag: "code",
              getAttrs: function(r) {
                var s = r.getAttribute("data-raw-html");
                return Nt({}, s && { rawHTML: s });
              }
            }
          ],
          toDOM: function(r) {
            var s = r.attrs;
            return [s.rawHTML || "code", Zn(s)];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return function() {
        return function(r, s) {
          return ny(r.schema.marks.code)(r, s);
        };
      };
    }, e.prototype.keymaps = function() {
      var r = this.commands()();
      return {
        "Shift-Mod-c": r,
        "Shift-Mod-C": r
      };
    }, e;
  }(Cn)
), U6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "customBlock";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          attrs: {
            info: { default: null }
          },
          atom: !0,
          code: !0,
          defining: !0,
          parseDOM: [
            {
              tag: "div[data-custom-info]",
              getAttrs: function(r) {
                var s = r.getAttribute("data-custom-info");
                return { info: s };
              }
            }
          ],
          toDOM: function(r) {
            var s = r.attrs;
            return ["div", { "data-custom-info": s.info || null }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return function(r) {
        return function(s, l) {
          return r != null && r.info ? U3(s.schema.nodes.customBlock, r)(s, l) : !1;
        };
      };
    }, e;
  }(Sn)
), V6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "frontMatter";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          code: !0,
          defining: !0,
          parseDOM: [
            {
              preserveWhitespace: "full",
              tag: "div[data-front-matter]"
            }
          ],
          toDOM: function() {
            return ["div", { "data-front-matter": "true" }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return function() {
        return function(r, s, l) {
          var c = r.selection.$from;
          return l.endOfTextblock("down") && c.node().type.name === "frontMatter" ? $3(r, s) : !1;
        };
      };
    }, e.prototype.keymaps = function() {
      return {
        Enter: this.commands()()
      };
    }, e;
  }(Sn)
), G6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return Object.defineProperty(e.prototype, "name", {
      get: function() {
        return "htmlComment";
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "schema", {
      get: function() {
        return {
          content: "text*",
          group: "block",
          code: !0,
          defining: !0,
          parseDOM: [{ preserveWhitespace: "full", tag: "div[data-html-comment]" }],
          toDOM: function() {
            return ["div", { "data-html-comment": "true" }, 0];
          }
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.commands = function() {
      return function() {
        return function(r, s, l) {
          var c = r.selection.$from;
          return l.endOfTextblock("down") && c.node().type.name === "htmlComment" ? $3(r, s) : !1;
        };
      };
    }, e.prototype.keymaps = function() {
      return {
        Enter: this.commands()()
      };
    }, e;
  }(Sn)
);
function Y6e(i) {
  return new y4([
    new o6e(),
    new s6e(),
    new u6e(),
    new c6e(),
    new f6e(),
    new d6e(),
    new h6e(),
    new p6e(),
    new v6e(),
    new D6e(),
    new P6e(),
    new L6e(),
    new I6e(),
    new _6e(),
    new N6e(),
    new B6e(),
    new F6e(),
    new z6e(),
    new H6e(),
    new j6e(),
    new W6e(i),
    new $6e(),
    new U6e(),
    new V6e(),
    new m4(),
    new G6e()
  ]);
}
var q6e = vr("contents"), K6e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e(r, s) {
      var l = i.call(this, r) || this, c = s.toDOMAdaptor, f = s.htmlSchemaMap, p = f === void 0 ? {} : f, d = s.linkAttributes, m = d === void 0 ? {} : d, y = s.useCommandShortcut, S = y === void 0 ? !0 : y, x = s.wwPlugins, w = x === void 0 ? [] : x, k = s.wwNodeViews, O = k === void 0 ? {} : k;
      return l.editorType = "wysiwyg", l.el.classList.add("ww-mode"), l.toDOMAdaptor = c, l.linkAttributes = m, l.extraPlugins = w, l.pluginNodeViews = O, l.specs = l.createSpecs(), l.schema = l.createSchema(p), l.context = l.createContext(), l.keymaps = l.createKeymaps(S), l.view = l.createView(), l.commands = l.createCommands(), l.specs.setContext(Nt(Nt({}, l.context), { view: l.view })), l.initEvent(), l;
    }
    return e.prototype.createSpecs = function() {
      return Y6e(this.linkAttributes);
    }, e.prototype.createContext = function() {
      return {
        schema: this.schema,
        eventEmitter: this.eventEmitter
      };
    }, e.prototype.createSchema = function(r) {
      return new $V({
        nodes: Nt(Nt({}, this.specs.nodes), r.nodes),
        marks: Nt(Nt({}, this.specs.marks), r.marks)
      });
    }, e.prototype.createPlugins = function() {
      return Ha([
        cVe(),
        pVe(this.eventEmitter),
        vVe(),
        xVe(this.eventEmitter)
      ], this.createPluginProps()).concat(this.defaultPlugins);
    }, e.prototype.createPluginNodeViews = function() {
      var r = this, s = r.eventEmitter, l = r.pluginNodeViews, c = {};
      return l && Object.keys(l).forEach(function(f) {
        c[f] = function(p, d, m) {
          return l[f](p, d, m, s);
        };
      }), c;
    }, e.prototype.createView = function() {
      var r = this, s = this, l = s.toDOMAdaptor, c = s.eventEmitter;
      return new H3(this.el, {
        state: this.createState(),
        attributes: {
          class: q6e
        },
        nodeViews: Nt({
          customBlock: function(f, p, d) {
            return new kVe(f, p, d, l);
          },
          image: function(f, p, d) {
            return new OVe(f, p, d, c);
          },
          codeBlock: function(f, p, d) {
            return new AVe(f, p, d, c);
          },
          widget: v4
        }, this.createPluginNodeViews()),
        dispatchTransaction: function(f) {
          var p = r.view.state.applyTransaction(f).state;
          r.view.updateState(p), r.emitChangeEvent(f.scrollIntoView()), r.eventEmitter.emit("setFocusedNode", p.selection.$from.node(1));
        },
        transformPastedHTML: $Ve,
        transformPasted: function(f) {
          return qVe(f, r.schema, Mx(r.view.state.selection.$from));
        },
        handlePaste: function(f, p, d) {
          return n6e(f, d);
        },
        handleKeyDown: function(f, p) {
          return r.eventEmitter.emit("keydown", r.editorType, p), !1;
        },
        handleDOMEvents: {
          paste: function(f, p) {
            var d = p.clipboardData || window.clipboardData, m = d == null ? void 0 : d.items;
            if (m) {
              var y = Ws(m).some(function(x) {
                return x.kind === "string" && x.type === "text/rtf";
              });
              if (!y) {
                var S = p4(m);
                S && (p.preventDefault(), oW(r.eventEmitter, S, p.type));
              }
            }
            return !1;
          },
          keyup: function(f, p) {
            return r.eventEmitter.emit("keyup", r.editorType, p), !1;
          },
          scroll: function() {
            return r.eventEmitter.emit("scroll", "editor"), !0;
          }
        }
      });
    }, e.prototype.createCommands = function() {
      return this.specs.commands(this.view, yW());
    }, e.prototype.getHTML = function() {
      return aW(this.view.dom.innerHTML);
    }, e.prototype.getModel = function() {
      return this.view.state.doc;
    }, e.prototype.getSelection = function() {
      var r = this.view.state.selection, s = r.from, l = r.to;
      return [s, l];
    }, e.prototype.getSchema = function() {
      return this.view.state.schema;
    }, e.prototype.replaceSelection = function(r, s, l) {
      var c = this.view.state, f = c.schema, p = c.tr, d = r.split(`
`), m = d.map(function(x) {
        return bx(f, Bc(x, f));
      }), y = new ur(qt.from(m), 1, 1), S = yl(s) && yl(l) ? p.replaceRange(s, l, y) : p.replaceSelection(y);
      this.view.dispatch(S), this.focus();
    }, e.prototype.deleteSelection = function(r, s) {
      var l = this.view.state.tr, c = yl(r) && yl(s) ? l.deleteRange(r, s) : l.deleteSelection();
      this.view.dispatch(c.scrollIntoView());
    }, e.prototype.getSelectedText = function(r, s) {
      var l = this.view.state, c = l.doc, f = l.selection, p = f.from, d = f.to;
      return yl(r) && yl(s) && (p = r, d = s), c.textBetween(p, d, `
`);
    }, e.prototype.setModel = function(r, s) {
      s === void 0 && (s = !1);
      var l = this.view.state, c = l.tr, f = l.doc;
      this.view.dispatch(c.replaceWith(0, f.content.size, r)), s && this.moveCursorToEnd(!0);
    }, e.prototype.setSelection = function(r, s) {
      s === void 0 && (s = r);
      var l = this.view.state.tr, c = On(l, r, s);
      this.view.dispatch(l.setSelection(c).scrollIntoView());
    }, e.prototype.addWidget = function(r, s, l) {
      var c = this.view, f = c.dispatch, p = c.state;
      f(p.tr.setMeta("widget", { pos: l ?? p.selection.to, node: r, style: s }));
    }, e.prototype.replaceWithWidget = function(r, s, l) {
      var c = this.view.state, f = c.tr, p = c.schema, d = Bc(l, p);
      this.view.dispatch(f.replaceWith(r, s, d));
    }, e.prototype.getRangeInfoOfNode = function(r) {
      var s = this.view.state, l = s.doc, c = s.selection, f = r ? l.resolve(r) : c.$from, p = f.marks(), d = f.node(), m = f.start(), y = f.end(), S = d.type.name;
      if (p.length || S === "paragraph") {
        var x = p[p.length - 1], w = function(k) {
          return k.length ? Ri(k, x) : !0;
        };
        S = x ? x.type.name : "text", d.forEach(function(k, O) {
          var T = k.isText, L = k.nodeSize, j = k.marks, z = f.pos - m;
          T && O <= z && O + L >= z && w(j) && (m = m + O, y = m + L);
        });
      }
      return { range: [m, y], type: S };
    }, e;
  }(g4)
), X6e = vs, J6e = vx;
function Z6e(i) {
  return !X6e(i) && !J6e(i);
}
var Q6e = Z6e, e4e = Q6e;
function t4e(i) {
  return e4e(i) && i !== !1;
}
var r4e = t4e, n4e = r4e;
function i4e(i) {
  return !n4e(i);
}
var a4e = i4e, s5 = [
  "afterPreviewRender",
  "updatePreview",
  "changeMode",
  "needChangeMode",
  "command",
  "changePreviewStyle",
  "changePreviewTabPreview",
  "changePreviewTabWrite",
  "scroll",
  "contextmenu",
  "show",
  "hide",
  "changeLanguage",
  "changeToolbarState",
  "toggleScrollSync",
  "mixinTableOffsetMapPrototype",
  "setFocusedNode",
  "removePopupWidget",
  "query",
  // provide event for user
  "openPopup",
  "closePopup",
  "addImageBlobHook",
  "beforePreviewRender",
  "beforeConvertWysiwygToMarkdown",
  "load",
  "loadUI",
  "change",
  "caretChange",
  "destroy",
  "focus",
  "blur",
  "keydown",
  "keyup"
], P9 = (
  /** @class */
  function() {
    function i() {
      var e = this;
      this.events = new k9(), this.eventTypes = s5.reduce(function(r, s) {
        return Nt(Nt({}, r), { type: s });
      }, {}), this.hold = !1, s5.forEach(function(r) {
        e.addEventType(r);
      });
    }
    return i.prototype.listen = function(e, r) {
      var s = this.getTypeInfo(e), l = this.events.get(s.type) || [];
      if (!this.hasEventType(s.type))
        throw new Error("There is no event type " + s.type);
      s.namespace && (r.namespace = s.namespace), l.push(r), this.events.set(s.type, l);
    }, i.prototype.emit = function(e) {
      for (var r = [], s = 1; s < arguments.length; s++)
        r[s - 1] = arguments[s];
      var l = this.getTypeInfo(e), c = this.events.get(l.type), f = [];
      return !this.hold && c && c.forEach(function(p) {
        var d = p.apply(void 0, r);
        vs(d) || f.push(d);
      }), f;
    }, i.prototype.emitReduce = function(e, r) {
      for (var s = [], l = 2; l < arguments.length; l++)
        s[l - 2] = arguments[l];
      var c = this.events.get(e);
      return !this.hold && c && c.forEach(function(f) {
        var p = f.apply(void 0, Ha([r], s));
        a4e(p) || (r = p);
      }), r;
    }, i.prototype.getTypeInfo = function(e) {
      var r = e.split(".");
      return {
        type: r[0],
        namespace: r[1]
      };
    }, i.prototype.hasEventType = function(e) {
      return !vs(this.eventTypes[this.getTypeInfo(e).type]);
    }, i.prototype.addEventType = function(e) {
      if (this.hasEventType(e))
        throw new Error("There is already have event type " + e);
      this.eventTypes[e] = e;
    }, i.prototype.removeEventHandler = function(e, r) {
      var s = this, l = this.getTypeInfo(e), c = l.type, f = l.namespace;
      c && r ? this.removeEventHandlerWithHandler(c, r) : c && !f ? this.events.delete(c) : !c && f ? this.events.forEach(function(p, d) {
        s.removeEventHandlerWithTypeInfo(d, f);
      }) : c && f && this.removeEventHandlerWithTypeInfo(c, f);
    }, i.prototype.removeEventHandlerWithHandler = function(e, r) {
      var s = this.events.get(e);
      if (s) {
        var l = s.indexOf(r);
        s.indexOf(r) >= 0 && s.splice(l, 1);
      }
    }, i.prototype.removeEventHandlerWithTypeInfo = function(e, r) {
      var s = [], l = this.events.get(e);
      l && (l.map(function(c) {
        return c.namespace !== r && s.push(c), null;
      }), this.events.set(e, s));
    }, i.prototype.getEvents = function() {
      return this.events;
    }, i.prototype.holdEventInvoke = function(e) {
      this.hold = !0, e(), this.hold = !1;
    }, i;
  }()
), o4e = (
  /** @class */
  function() {
    function i(e, r, s, l) {
      this.eventEmitter = e, this.mdCommands = r, this.wwCommands = s, this.getEditorType = l, this.initEvent();
    }
    return i.prototype.initEvent = function() {
      var e = this;
      this.eventEmitter.listen("command", function(r, s) {
        e.exec(r, s);
      });
    }, i.prototype.addCommand = function(e, r, s) {
      e === "markdown" ? this.mdCommands[r] = s : this.wwCommands[r] = s;
    }, i.prototype.deleteCommand = function(e, r) {
      e === "markdown" ? delete this.mdCommands[r] : delete this.wwCommands[r];
    }, i.prototype.exec = function(e, r) {
      var s = this.getEditorType();
      s === "markdown" ? this.mdCommands[e](r) : this.wwCommands[e](r);
    }, i;
  }()
);
function tx(i) {
  return i[i.length - 1] === `
` ? i.slice(0, i.length - 1) : i;
}
function x3(i, e) {
  var r = i.schema, s = e.literal, l = s.match(gp);
  if (l) {
    var c = l[1], f = l[3], p = (c || f).toLowerCase();
    return e.type === "htmlInline" && !!(r.marks[p] || r.nodes[p]);
  }
  return !1;
}
function k3(i) {
  var e = i.type;
  return Ri(["text", "strong", "emph", "strike", "image", "link", "code"], e);
}
function l5(i) {
  return (i == null ? void 0 : i.type) === "softbreak";
}
function Lg(i) {
  var e = i.type, r = i.literal, s = e === "htmlInline" && r.match(gp);
  if (s) {
    var l = s[1], c = s[3], f = l || c;
    if (f)
      return Ri(["ul", "ol", "li"], f.toLowerCase());
  }
  return !1;
}
function s4e(i) {
  var e = i.literal, r = /data-task/.test(e), s = /data-task-checked/.test(e);
  return { task: r, checked: s };
}
function u5(i) {
  for (var e = [], r = 1; r < arguments.length; r++)
    e[r - 1] = arguments[r];
  var s = document.createElement("div");
  s.innerHTML = Yc(i);
  var l = s.firstChild;
  return e.map(function(c) {
    return l.getAttribute(c) || "";
  });
}
function l4e(i) {
  var e = {};
  return Object.keys(i).forEach(function(r) {
    var s = r.split(", ");
    s.forEach(function(l) {
      var c = l.toLowerCase();
      e[c] = i[r];
    });
  }), e;
}
var u4e = {
  "b, strong": function(i, e, r) {
    var s = i.schema.marks.strong;
    r ? i.openMark(s.create({ rawHTML: r })) : i.closeMark(s);
  },
  "i, em": function(i, e, r) {
    var s = i.schema.marks.emph;
    r ? i.openMark(s.create({ rawHTML: r })) : i.closeMark(s);
  },
  "s, del": function(i, e, r) {
    var s = i.schema.marks.strike;
    r ? i.openMark(s.create({ rawHTML: r })) : i.closeMark(s);
  },
  code: function(i, e, r) {
    var s = i.schema.marks.code;
    r ? i.openMark(s.create({ rawHTML: r })) : i.closeMark(s);
  },
  a: function(i, e, r) {
    var s = e.literal, l = i.schema.marks.link;
    if (r) {
      var c = u5(s, "href")[0];
      i.openMark(l.create({
        linkUrl: c,
        rawHTML: r
      }));
    } else
      i.closeMark(l);
  },
  img: function(i, e, r) {
    var s = e.literal;
    if (r) {
      var l = u5(s, "src", "alt"), c = l[0], f = l[1], p = i.schema.nodes.image;
      i.addNode(p, Nt({ rawHTML: r, imageUrl: c }, f && { altText: f }));
    }
  },
  hr: function(i, e, r) {
    i.addNode(i.schema.nodes.thematicBreak, { rawHTML: r });
  },
  br: function(i, e) {
    var r = i.schema.nodes.paragraph, s = e.parent, l = e.prev, c = e.next;
    (s == null ? void 0 : s.type) === "paragraph" ? (l5(l) && i.openNode(r), l5(c) ? i.closeNode() : c && (i.closeNode(), i.openNode(r))) : (s == null ? void 0 : s.type) === "tableCell" && (l && (k3(l) || x3(i, l)) && i.closeNode(), c && (k3(c) || x3(i, c)) && i.openNode(r));
  },
  pre: function(i, e, r) {
    var s, l, c = document.createElement("div");
    c.innerHTML = e.literal;
    var f = (l = (s = c.firstChild) === null || s === void 0 ? void 0 : s.firstChild) === null || l === void 0 ? void 0 : l.textContent;
    i.openNode(i.schema.nodes.codeBlock, { rawHTML: r }), i.addText(tx(f)), i.closeNode();
  },
  "ul, ol": function(i, e, r) {
    if (e.parent.type === "tableCell") {
      var s = i.schema.nodes, l = s.bulletList, c = s.orderedList, f = s.paragraph, p = r === "ul" ? l : c;
      r ? (e.prev && !Lg(e.prev) && i.closeNode(), i.openNode(p, { rawHTML: r })) : (i.closeNode(), e.next && !Lg(e.next) && i.openNode(f));
    }
  },
  li: function(i, e, r) {
    var s;
    if (((s = e.parent) === null || s === void 0 ? void 0 : s.type) === "tableCell") {
      var l = i.schema.nodes, c = l.listItem, f = l.paragraph;
      if (r) {
        var p = s4e(e);
        e.prev && !Lg(e.prev) && i.closeNode(), i.openNode(c, Nt({ rawHTML: r }, p)), e.next && !Lg(e.next) && i.openNode(f);
      } else
        e.prev && !Lg(e.prev) && i.closeNode(), i.closeNode();
    }
  }
}, c4e = l4e(u4e);
function c5(i) {
  return i.type === "htmlInline" && n3.test(i.literal);
}
function L9(i) {
  Ws(i.childNodes).forEach(function(e) {
    if (Vx(e)) {
      var r = e.nodeName.toLowerCase();
      e.setAttribute("data-raw-html", r), e.childNodes && L9(e);
    }
  });
}
var f5 = {
  text: function(i, e) {
    i.addText(e.literal || "");
  },
  paragraph: function(i, e, r, s) {
    var l, c = r.entering;
    if (c) {
      var f = i.schema.nodes.paragraph;
      ((l = e.prev) === null || l === void 0 ? void 0 : l.type) === "paragraph" && (i.openNode(f, s), i.closeNode()), i.openNode(f, s);
    } else
      i.closeNode();
  },
  heading: function(i, e, r, s) {
    var l = r.entering;
    if (l) {
      var c = e, f = c.level, p = c.headingType;
      i.openNode(i.schema.nodes.heading, Nt({ level: f, headingType: p }, s));
    } else
      i.closeNode();
  },
  codeBlock: function(i, e, r) {
    var s = i.schema.nodes.codeBlock, l = e, c = l.info, f = l.literal;
    i.openNode(s, Nt({ language: c }, r)), i.addText(tx(f || "")), i.closeNode();
  },
  list: function(i, e, r, s) {
    var l = r.entering;
    if (l) {
      var c = i.schema.nodes, f = c.bulletList, p = c.orderedList, d = e.listData, m = d.type, y = d.start;
      m === "bullet" ? i.openNode(f, s) : i.openNode(p, Nt({ order: y }, s));
    } else
      i.closeNode();
  },
  item: function(i, e, r, s) {
    var l = r.entering, c = i.schema.nodes.listItem, f = e.listData, p = f.task, d = f.checked;
    if (l) {
      var m = Nt(Nt(Nt({}, p && { task: p }), d && { checked: d }), s);
      i.openNode(c, m);
    } else
      i.closeNode();
  },
  blockQuote: function(i, e, r, s) {
    var l = r.entering;
    l ? i.openNode(i.schema.nodes.blockQuote, s) : i.closeNode();
  },
  image: function(i, e, r, s) {
    var l = r.entering, c = r.skipChildren, f = i.schema.nodes.image, p = e, d = p.destination, m = p.firstChild;
    l && c && c(), i.addNode(f, Nt(Nt({ imageUrl: d }, m && { altText: m.literal }), s));
  },
  thematicBreak: function(i, e, r, s) {
    i.addNode(i.schema.nodes.thematicBreak, s);
  },
  strong: function(i, e, r, s) {
    var l = r.entering, c = i.schema.marks.strong;
    l ? i.openMark(c.create(s)) : i.closeMark(c);
  },
  emph: function(i, e, r, s) {
    var l = r.entering, c = i.schema.marks.emph;
    l ? i.openMark(c.create(s)) : i.closeMark(c);
  },
  link: function(i, e, r, s) {
    var l = r.entering, c = i.schema.marks.link, f = e, p = f.destination, d = f.title;
    if (l) {
      var m = Nt({ linkUrl: p, title: d }, s);
      i.openMark(c.create(m));
    } else
      i.closeMark(c);
  },
  softbreak: function(i, e) {
    if (e.parent.type === "paragraph") {
      var r = e.prev, s = e.next;
      r && !c5(r) && i.closeNode(), s && !c5(s) && i.openNode(i.schema.nodes.paragraph);
    }
  },
  // GFM specifications node
  table: function(i, e, r, s) {
    var l = r.entering;
    l ? i.openNode(i.schema.nodes.table, s) : i.closeNode();
  },
  tableHead: function(i, e, r, s) {
    var l = r.entering;
    l ? i.openNode(i.schema.nodes.tableHead, s) : i.closeNode();
  },
  tableBody: function(i, e, r, s) {
    var l = r.entering;
    l ? i.openNode(i.schema.nodes.tableBody, s) : i.closeNode();
  },
  tableRow: function(i, e, r, s) {
    var l = r.entering;
    l ? i.openNode(i.schema.nodes.tableRow, s) : i.closeNode();
  },
  tableCell: function(i, e, r) {
    var s = r.entering;
    if (!e.ignored) {
      var l = function(k) {
        return k && (k3(k) || x3(i, k));
      };
      if (s) {
        var c = i.schema.nodes, f = c.tableHeadCell, p = c.tableBodyCell, d = c.paragraph, m = e.parent.parent, y = m.type === "tableHead" ? f : p, S = m.parent, x = (S.columns[e.startIdx] || {}).align, w = Nt({}, e.attrs);
        x && (w.align = x), i.openNode(y, w), l(e.firstChild) && i.openNode(d);
      } else
        l(e.lastChild) && i.closeNode(), i.closeNode();
    }
  },
  strike: function(i, e, r, s) {
    var l = r.entering, c = i.schema.marks.strike;
    l ? i.openMark(c.create(s)) : i.closeMark(c);
  },
  code: function(i, e, r, s) {
    var l = i.schema.marks.code;
    i.openMark(l.create(s)), i.addText(tx(e.literal || "")), i.closeMark(l);
  },
  customBlock: function(i, e) {
    var r = i.schema.nodes, s = r.customBlock, l = r.paragraph, c = e, f = c.info, p = c.literal;
    i.openNode(s, { info: f }), i.addText(tx(p || "")), i.closeNode(), e.next || (i.openNode(l), i.closeNode());
  },
  frontMatter: function(i, e) {
    i.openNode(i.schema.nodes.frontMatter), i.addText(e.literal), i.closeNode();
  },
  htmlInline: function(i, e) {
    var r = e.literal, s = r.match(gp), l = s[1], c = s[3], f = (l || c).toLowerCase(), p = i.schema.marks[f], d = Yc(r);
    if (p != null && p.spec.attrs.htmlInline)
      if (l) {
        var m = y3(d);
        i.openMark(p.create({ htmlAttrs: m }));
      } else
        i.closeMark(p);
    else {
      var y = c4e[f];
      y && y(i, e, l);
    }
  },
  htmlBlock: function(i, e) {
    var r = e.literal, s = document.createElement("div"), l = Yne.test(r);
    if (l)
      i.openNode(i.schema.nodes.htmlComment), i.addText(e.literal), i.closeNode();
    else {
      var c = r.match(gp), f = c[1], p = c[3], d = (f || p).toLowerCase(), m = i.schema.nodes[d], y = Yc(r);
      if (m != null && m.spec.attrs.htmlBlock) {
        var S = y3(y), x = f9(e, d);
        i.addNode(m, { htmlAttrs: S, childrenHTML: x });
      } else
        s.innerHTML = y, L9(s), i.convertByDOMParser(s);
    }
  },
  customInline: function(i, e, r) {
    var s = r.entering, l = r.skipChildren, c = e, f = c.info, p = c.firstChild, d = i.schema;
    if (f.indexOf("widget") !== -1 && s) {
      var m = r4(e);
      l(), i.addNode(d.nodes.widget, { info: f }, [
        d.text(e4(f, m))
      ]);
    } else {
      var y = "$$";
      s && (y += p ? f + " " : f), i.addText(y);
    }
  }
};
function f4e(i) {
  var e = Object.keys(i), r = Nt({}, f5), s = new mW({
    gfm: !0,
    nodeId: !0,
    convertors: i
  }), l = s.getConvertors();
  return e.forEach(function(c) {
    var f = f5[c];
    f && !Ri(["htmlBlock", "htmlInline"], c) && (r[c] = function(p, d, m) {
      m.origin = function() {
        return l[c](d, m, l);
      };
      var y = i[c](d, m), S;
      if (y) {
        var x = Array.isArray(y) ? y[0] : y, w = x.attributes, k = x.classNames;
        S = { htmlAttrs: w, classNames: k };
      }
      f(p, d, m, S);
    });
  }), r;
}
function d4e(i, e) {
  return i.isText && e.isText && Qr.sameSet(i.marks, e.marks) ? i.withText(i.text + e.text) : !1;
}
var h4e = (
  /** @class */
  function() {
    function i(e, r) {
      this.schema = e, this.convertors = r, this.stack = [{ type: this.schema.topNodeType, attrs: null, content: [] }], this.marks = Qr.none;
    }
    return i.prototype.top = function() {
      return Qi(this.stack);
    }, i.prototype.push = function(e) {
      this.stack.length && this.top().content.push(e);
    }, i.prototype.addText = function(e) {
      if (e) {
        var r = this.top().content, s = Qi(r), l = this.schema.text(e, this.marks), c = s && d4e(s, l);
        c ? r[r.length - 1] = c : r.push(l);
      }
    }, i.prototype.openMark = function(e) {
      this.marks = e.addToSet(this.marks);
    }, i.prototype.closeMark = function(e) {
      this.marks = e.removeFromSet(this.marks);
    }, i.prototype.addNode = function(e, r, s) {
      var l = e.createAndFill(r, s, this.marks);
      return l ? (this.push(l), l) : null;
    }, i.prototype.openNode = function(e, r) {
      this.stack.push({ type: e, attrs: r, content: [] });
    }, i.prototype.closeNode = function() {
      this.marks.length && (this.marks = Qr.none);
      var e = this.stack.pop(), r = e.type, s = e.attrs, l = e.content;
      return this.addNode(r, s, l);
    }, i.prototype.convertByDOMParser = function(e) {
      var r = this, s = zc.fromSchema(this.schema).parse(e);
      s.content.forEach(function(l) {
        return r.push(l);
      });
    }, i.prototype.closeUnmatchedHTMLInline = function(e, r) {
      var s;
      if (!r && e.type !== "htmlInline")
        for (var l = this.stack.length - 1, c = l; c >= 0; c -= 1) {
          var f = this.stack[c];
          if (!((s = f.attrs) === null || s === void 0) && s.rawHTML)
            f.content.length ? this.closeNode() : this.stack.pop();
          else
            break;
        }
    }, i.prototype.convert = function(e, r) {
      for (var s = e.walker(), l = s.next(), c = function() {
        var p = l.node, d = l.entering, m = f.convertors[p.type], y = !1;
        if (m) {
          var S = {
            entering: d,
            leaf: !Ane(p),
            getChildrenText: Ene,
            options: { gfm: !0, nodeId: !1, tagFilter: !1, softbreak: `
` },
            skipChildren: function() {
              y = !0;
            }
          };
          if (f.closeUnmatchedHTMLInline(p, d), m(f, p, S), (r == null ? void 0 : r.node) === p) {
            var x = f.stack.reduce(function(w, k) {
              return w + k.content.reduce(function(O, T) {
                return O + T.nodeSize;
              }, 0);
            }, 0) + 1;
            r.setMappedPos(x);
          }
        }
        y && (s.resumeAt(p, !1), s.next()), l = s.next();
      }, f = this; l; )
        c();
    }, i.prototype.convertNode = function(e, r) {
      return this.convert(e, r), this.stack.length ? this.closeNode() : null;
    }, i;
  }()
);
function p4e(i, e, r) {
  var s = r[0], l = r[1];
  i.write(s), i.convertInline(e), i.write(l);
}
function v4e(i, e, r) {
  var s = e.node, l = e.parent, c = r[0], f = r[1];
  i.stopNewline = !0, i.write(c), i.convertNode(s), i.write(f), (l == null ? void 0 : l.type.name) === "doc" && (i.closeBlock(s), i.stopNewline = !1);
}
function m4e(i, e) {
  var r = i.length, s = "", l = "";
  return e === "left" ? (s = ":", r -= 1) : e === "right" ? (l = ":", r -= 1) : e === "center" && (s = ":", l = ":", r -= 2), "" + s + mx("-", Math.max(r, 3)) + l;
}
var O3 = {
  text: function(i, e) {
    var r, s = e.node, l = (r = s.text) !== null && r !== void 0 ? r : "";
    (s.marks || []).some(function(c) {
      return c.type.name === "link";
    }) ? i.text(gx(l), !1) : i.text(l);
  },
  paragraph: function(i, e) {
    var r = e.node, s = e.parent, l = e.index, c = l === void 0 ? 0 : l;
    if (i.stopNewline)
      i.convertInline(r);
    else {
      var f = c === 0, p = !f && s.child(c - 1), d = p && p.childCount === 0, m = c < s.childCount - 1 && s.child(c + 1), y = m && m.type.name === "paragraph", S = r.childCount === 0;
      if (S && d)
        i.write(`<br>
`);
      else if (S && !d && !f) {
        if ((s == null ? void 0 : s.type.name) === "listItem") {
          var x = i.getDelim();
          i.setDelim(""), i.write("<br>"), i.setDelim(x);
        }
        i.write(`
`);
      } else
        i.convertInline(r), y ? i.write(`
`) : i.closeBlock(r);
    }
  },
  heading: function(i, e, r) {
    var s = e.node, l = r.delim, c = s.attrs.headingType;
    c === "atx" ? (i.write(l + " "), i.convertInline(s), i.closeBlock(s)) : (i.convertInline(s), i.ensureNewLine(), i.write(l), i.closeBlock(s));
  },
  codeBlock: function(i, e, r) {
    var s = e.node, l = r.delim, c = r.text, f = l, p = f[0], d = f[1];
    i.write(p), i.ensureNewLine(), i.text(c, !1), i.ensureNewLine(), i.write(d), i.closeBlock(s);
  },
  blockQuote: function(i, e, r) {
    var s = e.node, l = e.parent, c = r.delim;
    (l == null ? void 0 : l.type.name) === s.type.name && i.flushClose(1), i.wrapBlock(c, null, s, function() {
      return i.convertNode(s);
    });
  },
  bulletList: function(i, e, r) {
    var s = e.node, l = r.delim;
    i.convertList(s, mx(" ", 4), function() {
      return l + " ";
    });
  },
  orderedList: function(i, e) {
    var r = e.node, s = r.attrs.order || 1;
    i.convertList(r, mx(" ", 4), function(l) {
      var c = String(s + l);
      return c + ". ";
    });
  },
  listItem: function(i, e) {
    var r = e.node, s = r.attrs, l = s.task, c = s.checked;
    l && i.write("[" + (c ? "x" : " ") + "] "), i.convertNode(r);
  },
  image: function(i, e, r) {
    var s = r.attrs;
    i.write("![" + (s == null ? void 0 : s.altText) + "](" + (s == null ? void 0 : s.imageUrl) + ")");
  },
  thematicBreak: function(i, e, r) {
    var s = e.node, l = r.delim;
    i.write(l), i.closeBlock(s);
  },
  table: function(i, e) {
    var r = e.node;
    i.convertNode(r), i.closeBlock(r);
  },
  tableHead: function(i, e, r) {
    var s = e.node, l = r.delim, c = s.firstChild;
    i.convertNode(s);
    var f = l ?? "";
    !l && c && c.forEach(function(p) {
      var d = p.textContent, m = p.attrs, y = m4e(d, m.align);
      f += "| " + y + " ";
    }), i.write(f + "|"), i.ensureNewLine();
  },
  tableBody: function(i, e) {
    var r = e.node;
    i.convertNode(r);
  },
  tableRow: function(i, e) {
    var r = e.node;
    i.convertNode(r), i.write("|"), i.ensureNewLine();
  },
  tableHeadCell: function(i, e, r) {
    var s = e.node, l = r.delim, c = l === void 0 ? "| " : l;
    i.write(c), i.convertTableCell(s), i.write(" ");
  },
  tableBodyCell: function(i, e, r) {
    var s = e.node, l = r.delim, c = l === void 0 ? "| " : l;
    i.write(c), i.convertTableCell(s), i.write(" ");
  },
  customBlock: function(i, e, r) {
    var s = e.node, l = r.delim, c = r.text, f = l, p = f[0], d = f[1];
    i.write(p), i.ensureNewLine(), i.text(c, !1), i.ensureNewLine(), i.write(d), i.closeBlock(s);
  },
  frontMatter: function(i, e, r) {
    var s = e.node, l = r.text;
    i.text(l, !1), i.closeBlock(s);
  },
  widget: function(i, e, r) {
    var s = r.text;
    i.write(s);
  },
  html: function(i, e, r) {
    var s = e.node, l = r.text;
    i.write(l), s.attrs.htmlBlock && i.closeBlock(s);
  },
  htmlComment: function(i, e, r) {
    var s = e.node, l = r.text;
    i.write(l), i.closeBlock(s);
  }
};
function g4e(i, e) {
  var r = e.state, s = e.nodeInfo, l = e.params, c = l.rawHTML;
  c ? Wc(i, ["heading", "codeBlock"]) > -1 ? p4e(r, s.node, c) : Wc(i, ["image", "thematicBreak"]) > -1 ? r.write(c) : v4e(r, s, c) : O3[i](r, s, l);
}
function d5(i, e) {
  var r = i.text, s = /`+/g, l = 0;
  if (i.isText && r)
    for (var c = s.exec(r); c; )
      l = Math.max(l, c[0].length), c = s.exec(r);
  for (var f = l > 0 && e > 0 ? " `" : "`", p = 0; p < l; p += 1)
    f += "`";
  return l > 0 && e < 0 && (f += " "), f;
}
function ls(i) {
  return i ? ["<" + i + ">", "</" + i + ">"] : null;
}
function Ig(i) {
  return i ? "<" + i + ">" : null;
}
function _g(i) {
  return i ? "</" + i + ">" : null;
}
var Ng = {
  heading: function(i) {
    var e = i.node, r = e.attrs, s = r.level, l = mx("#", s);
    return r.headingType === "setext" && (l = s === 1 ? "===" : "---"), {
      delim: l,
      rawHTML: ls(r.rawHTML)
    };
  },
  codeBlock: function(i) {
    var e = i.node, r = e, s = r.attrs, l = r.textContent;
    return {
      delim: ["```" + (s.language || ""), "```"],
      rawHTML: ls(s.rawHTML),
      text: l
    };
  },
  blockQuote: function(i) {
    var e = i.node;
    return {
      delim: "> ",
      rawHTML: ls(e.attrs.rawHTML)
    };
  },
  bulletList: function(i, e) {
    var r = i.node, s = e.inTable, l = r.attrs.rawHTML;
    return s && (l = l || "ul"), {
      delim: "*",
      rawHTML: ls(l)
    };
  },
  orderedList: function(i, e) {
    var r = i.node, s = e.inTable, l = r.attrs.rawHTML;
    return s && (l = l || "ol"), {
      rawHTML: ls(l)
    };
  },
  listItem: function(i, e) {
    var r = i.node, s = e.inTable, l = r.attrs, c = l.task, f = l.checked, p = r.attrs.rawHTML;
    s && (p = p || "li");
    var d = c ? ' class="task-list-item' + (f ? " checked" : "") + '"' : "", m = c ? " data-task" + (f ? " data-task-checked" : "") : "";
    return {
      rawHTML: p ? ["<" + p + d + m + ">", "</" + p + ">"] : null
    };
  },
  table: function(i) {
    var e = i.node;
    return {
      rawHTML: ls(e.attrs.rawHTML)
    };
  },
  tableHead: function(i) {
    var e = i.node;
    return {
      rawHTML: ls(e.attrs.rawHTML)
    };
  },
  tableBody: function(i) {
    var e = i.node;
    return {
      rawHTML: ls(e.attrs.rawHTML)
    };
  },
  tableRow: function(i) {
    var e = i.node;
    return {
      rawHTML: ls(e.attrs.rawHTML)
    };
  },
  tableHeadCell: function(i) {
    var e = i.node;
    return {
      rawHTML: ls(e.attrs.rawHTML)
    };
  },
  tableBodyCell: function(i) {
    var e = i.node;
    return {
      rawHTML: ls(e.attrs.rawHTML)
    };
  },
  image: function(i) {
    var e = i.node, r = e.attrs, s = r.rawHTML, l = r.altText, c = r.imageUrl.replace(/&amp;/g, "&"), f = l ? ' alt="' + np(l) + '"' : "";
    return {
      rawHTML: s ? "<" + s + ' src="' + np(c) + '"' + f + ">" : null,
      attrs: {
        altText: gx(l || ""),
        imageUrl: c
      }
    };
  },
  thematicBreak: function(i) {
    var e = i.node;
    return {
      delim: "***",
      rawHTML: Ig(e.attrs.rawHTML)
    };
  },
  customBlock: function(i) {
    var e = i.node, r = e, s = r.attrs, l = r.textContent;
    return {
      delim: ["$$" + s.info, "$$"],
      text: l
    };
  },
  frontMatter: function(i) {
    var e = i.node;
    return {
      text: e.textContent
    };
  },
  widget: function(i) {
    var e = i.node;
    return {
      text: e.textContent
    };
  },
  strong: function(i, e) {
    var r = i.node, s = e.entering, l = r.attrs.rawHTML;
    return {
      delim: "**",
      rawHTML: s ? Ig(l) : _g(l)
    };
  },
  emph: function(i, e) {
    var r = i.node, s = e.entering, l = r.attrs.rawHTML;
    return {
      delim: "*",
      rawHTML: s ? Ig(l) : _g(l)
    };
  },
  strike: function(i, e) {
    var r = i.node, s = e.entering, l = r.attrs.rawHTML;
    return {
      delim: "~~",
      rawHTML: s ? Ig(l) : _g(l)
    };
  },
  link: function(i, e) {
    var r = i.node, s = e.entering, l = r.attrs, c = l.title, f = l.rawHTML, p = l.linkUrl.replace(/&amp;/g, "&"), d = c ? ' title="' + np(c) + '"' : "";
    return s ? {
      delim: "[",
      rawHTML: f ? "<" + f + ' href="' + np(p) + '"' + d + ">" : null
    } : {
      delim: "](" + p + (c ? " " + mne(gx(c)) : "") + ")",
      rawHTML: _g(f)
    };
  },
  code: function(i, e) {
    var r = i.node, s = i.parent, l = i.index, c = l === void 0 ? 0 : l, f = e.entering, p = f ? d5(s.child(c), -1) : d5(s.child(c - 1), 1), d = f ? Ig(r.attrs.rawHTML) : _g(r.attrs.rawHTML);
    return {
      delim: p,
      rawHTML: d
    };
  },
  htmlComment: function(i) {
    var e = i.node;
    return {
      text: e.textContent
    };
  },
  // html inline node, html block node
  html: function(i, e) {
    var r = i.node, s = e.entering, l = r.type.name, c = r.attrs.htmlAttrs, f = "<" + l, p = "</" + l + ">";
    return Object.keys(c).forEach(function(d) {
      f += " " + d + '="' + c[d].replace(/"/g, "'") + '"';
    }), f += ">", r.attrs.htmlInline ? {
      rawHTML: s ? f : p
    } : {
      text: "" + f + r.attrs.childrenHTML + p
    };
  }
}, h5 = {
  strong: {
    mixable: !0,
    removedEnclosingWhitespace: !0
  },
  emph: {
    mixable: !0,
    removedEnclosingWhitespace: !0
  },
  strike: {
    mixable: !0,
    removedEnclosingWhitespace: !0
  },
  code: {
    escape: !1
  },
  link: null,
  html: null
};
function y4e(i) {
  var e = {}, r = Object.keys(O3);
  return r.forEach(function(s) {
    e[s] = function(l, c) {
      var f = O3[s];
      if (f) {
        var p = i[s], d = p ? p(c, {
          inTable: l.inTable
        }) : {};
        g4e(s, { state: l, nodeInfo: c, params: d });
      }
    };
  }), e;
}
function b4e(i) {
  var e = {}, r = Object.keys(h5);
  return r.forEach(function(s) {
    e[s] = function(l, c) {
      var f = h5[s], p = i[s], d = p && l && !vs(c), m = d ? p(l, { entering: c }) : {};
      return Nt(Nt({}, m), f);
    };
  }), e;
}
function S4e(i) {
  var e = Object.keys(i);
  e.forEach(function(l) {
    var c = Ng[l], f = i[l];
    c ? Ng[l] = function(p, d) {
      return d.origin = function() {
        return c(p, d);
      }, f(p, d);
    } : Ng[l] = f, delete i[l];
  });
  var r = y4e(Ng), s = b4e(Ng);
  return {
    nodeTypeConvertors: r,
    markTypeConvertors: s
  };
}
var w4e = (
  /** @class */
  function() {
    function i(e) {
      var r = e.nodeTypeConvertors, s = e.markTypeConvertors;
      this.nodeTypeConvertors = r, this.markTypeConvertors = s, this.delim = "", this.result = "", this.closed = !1, this.tightList = !1, this.stopNewline = !1, this.inTable = !1;
    }
    return i.prototype.getMarkConvertor = function(e) {
      var r = e.attrs.htmlInline ? "html" : e.type.name;
      return this.markTypeConvertors[r];
    }, i.prototype.isInBlank = function() {
      return /(^|\n)$/.test(this.result);
    }, i.prototype.markText = function(e, r, s, l) {
      var c = this.getMarkConvertor(e);
      if (c) {
        var f = c({ node: e, parent: s, index: l }, r), p = f.delim, d = f.rawHTML;
        return d || p;
      }
      return "";
    }, i.prototype.setDelim = function(e) {
      this.delim = e;
    }, i.prototype.getDelim = function() {
      return this.delim;
    }, i.prototype.flushClose = function(e) {
      if (!this.stopNewline && this.closed) {
        if (this.isInBlank() || (this.result += `
`), e || (e = 2), e > 1) {
          var r = this.delim, s = /\s+$/.exec(r);
          s && (r = r.slice(0, r.length - s[0].length));
          for (var l = 1; l < e; l += 1)
            this.result += r + `
`;
        }
        this.closed = !1;
      }
    }, i.prototype.wrapBlock = function(e, r, s, l) {
      var c = this.getDelim();
      this.write(r || e), this.setDelim(this.getDelim() + e), l(), this.setDelim(c), this.closeBlock(s);
    }, i.prototype.ensureNewLine = function() {
      this.isInBlank() || (this.result += `
`);
    }, i.prototype.write = function(e) {
      e === void 0 && (e = ""), this.flushClose(), this.delim && this.isInBlank() && (this.result += this.delim), e && (this.result += e);
    }, i.prototype.closeBlock = function(e) {
      this.closed = e;
    }, i.prototype.text = function(e, r) {
      r === void 0 && (r = !0);
      for (var s = e.split(`
`), l = 0; l < s.length; l += 1)
        this.write(), this.result += r ? vne(s[l]) : s[l], l !== s.length - 1 && (this.result += `
`);
    }, i.prototype.convertBlock = function(e, r, s) {
      var l = e.type.name, c = this.nodeTypeConvertors[l], f = { node: e, parent: r, index: s };
      e.attrs.htmlBlock ? this.nodeTypeConvertors.html(this, f) : c && c(this, f);
    }, i.prototype.convertInline = function(e) {
      var r = this, s = [], l = "", c = function(f, p, d) {
        var m = f ? f.marks : [], y = l;
        l = "";
        var S = f && f.isText && m.some(function(Ce) {
          var he = r.getMarkConvertor(Ce), oe = he && he();
          return oe && oe.removedEnclosingWhitespace;
        });
        if (S && f && f.text) {
          var x = /^(\s*)(.*?)(\s*)$/m.exec(f.text), w = x[1], k = x[2], O = x[3];
          y += w, l = O, (w || O) && (f = k ? f.withText(k) : null, f || (m = s));
        }
        for (var T = m.length && Qi(m), L = T && r.getMarkConvertor(T), j = L && L(), z = j && j.escape === !1, J = m.length - (z ? 1 : 0), ie = 0; ie < J; ie += 1) {
          var k = m[ie];
          if (j && !j.mixable)
            break;
          for (var K = 0; K < s.length; K += 1) {
            var re = s[K];
            if (j && !j.mixable)
              break;
            if (k.eq(re)) {
              ie > K ? m = m.slice(0, K).concat(k).concat(m.slice(K, ie)).concat(m.slice(ie + 1, J)) : K > ie && (m = m.slice(0, ie).concat(m.slice(ie + 1, K)).concat(k).concat(m.slice(K, J)));
              break;
            }
          }
        }
        for (var ee = 0; ee < Math.min(s.length, J) && m[ee].eq(s[ee]); )
          ee += 1;
        for (; ee < s.length; ) {
          var de = s.pop();
          de && r.text(r.markText(de, !1, e, d), !1);
        }
        if (y && r.text(y), f) {
          for (; s.length < J; ) {
            var k = m[s.length];
            s.push(k), r.text(r.markText(k, !0, e, d), !1);
          }
          z && f.isText ? r.text(r.markText(T, !0, e, d) + f.text + r.markText(T, !1, e, d + 1), !1) : r.convertBlock(f, e, d);
        }
      };
      e.forEach(c), c(null, null, e.childCount);
    }, i.prototype.convertList = function(e, r, s) {
      var l = this, c;
      this.closed && this.closed.type === e.type ? this.flushClose(3) : this.tightList && this.flushClose(1);
      var f = (c = e.attrs.tight) !== null && c !== void 0 ? c : !0, p = this.tightList;
      this.tightList = f, e.forEach(function(d, m, y) {
        y && f && l.flushClose(1), l.wrapBlock(r, s(y), e, function() {
          return l.convertBlock(d, e, y);
        });
      }), this.tightList = p;
    }, i.prototype.convertTableCell = function(e) {
      var r = this;
      this.stopNewline = !0, this.inTable = !0, e.forEach(function(s, l, c) {
        if (Ri(["bulletList", "orderedList"], s.type.name))
          r.convertBlock(s, e, c), r.closed = !1;
        else if (r.convertInline(s), c < e.childCount - 1) {
          var f = e.child(c + 1);
          f.type.name === "paragraph" && r.write("<br>");
        }
      }), this.stopNewline = !1, this.inTable = !1;
    }, i.prototype.convertNode = function(e, r) {
      var s = this;
      return e.forEach(function(l, c, f) {
        if (s.convertBlock(l, e, f), (r == null ? void 0 : r.node) === l) {
          var p = s.result.split(`
`);
          r.setMappedPos([p.length, Qi(p).length + 1]);
        }
      }), this.result;
    }, i;
  }()
), x4e = (
  /** @class */
  function() {
    function i(e, r, s, l) {
      var c = this;
      this.setMappedPos = function(f) {
        c.mappedPosWhenConverting = f;
      }, this.schema = e, this.eventEmitter = l, this.focusedNode = null, this.mappedPosWhenConverting = null, this.toWwConvertors = f4e(s), this.toMdConvertors = S4e(r || {}), this.eventEmitter.listen("setFocusedNode", function(f) {
        return c.focusedNode = f;
      });
    }
    return i.prototype.getMappedPos = function() {
      return this.mappedPosWhenConverting;
    }, i.prototype.getInfoForPosSync = function() {
      return { node: this.focusedNode, setMappedPos: this.setMappedPos };
    }, i.prototype.toWysiwygModel = function(e) {
      var r = new h4e(this.schema, this.toWwConvertors);
      return r.convertNode(e, this.getInfoForPosSync());
    }, i.prototype.toMarkdownText = function(e) {
      var r = new w4e(this.toMdConvertors), s = r.convertNode(e, this.getInfoForPosSync());
      return s = this.eventEmitter.emitReduce("beforeConvertWysiwygToMarkdown", s), s;
    }, i;
  }()
);
function k4e(i) {
  var e = i.plugin, r = i.eventEmitter, s = i.usageStatistics, l = i.instance, c = { Plugin: Wa, PluginKey: ty, Selection: jr, TextSelection: Zr }, f = { Decoration: Fa, DecorationSet: Bn }, p = { Fragment: qt }, d = { InputRule: V6, inputRules: G6, undoInputRule: fre }, m = { keymap: Zg }, y = {
    eventEmitter: r,
    usageStatistics: s,
    instance: l,
    pmState: c,
    pmView: f,
    pmModel: p,
    pmRules: d,
    pmKeymap: m,
    i18n: Mr
  };
  if (Op(e)) {
    var S = e[0], x = e[1], w = x === void 0 ? {} : x;
    return S(y, w);
  }
  return e(y);
}
function I9(i) {
  var e = i.plugins, r = i.eventEmitter, s = i.usageStatistics, l = i.instance;
  return r.listen("mixinTableOffsetMapPrototype", tVe), (e ?? []).reduce(function(c, f) {
    var p = k4e({
      plugin: f,
      eventEmitter: r,
      usageStatistics: s,
      instance: l
    });
    if (!p)
      throw new Error("The return value of the executed plugin is empty.");
    var d = p.markdownParsers, m = p.toHTMLRenderers, y = p.toMarkdownRenderers, S = p.markdownPlugins, x = p.wysiwygPlugins, w = p.wysiwygNodeViews, k = p.markdownCommands, O = p.wysiwygCommands, T = p.toolbarItems;
    return m && (c.toHTMLRenderers = yx(c.toHTMLRenderers, m)), y && (c.toMarkdownRenderers = yx(c.toMarkdownRenderers, y)), S && (c.mdPlugins = c.mdPlugins.concat(S)), x && (c.wwPlugins = c.wwPlugins.concat(x)), w && (c.wwNodeViews = Nt(Nt({}, c.wwNodeViews), w)), k && (c.mdCommands = Nt(Nt({}, c.mdCommands), k)), O && (c.wwCommands = Nt(Nt({}, c.wwCommands), O)), T && (c.toolbarItems = c.toolbarItems.concat(T)), d && (c.markdownParsers = Nt(Nt({}, c.markdownParsers), d)), c;
  }, {
    toHTMLRenderers: {},
    toMarkdownRenderers: {},
    mdPlugins: [],
    wwPlugins: [],
    wwNodeViews: {},
    mdCommands: {},
    wwCommands: {},
    toolbarItems: [],
    markdownParsers: {}
  });
}
var O4e = "data-task", C4e = "data-task-disabled", T4e = "checked";
function A4e(i) {
  ["htmlBlock", "htmlInline"].forEach(function(e) {
    i[e] && Object.keys(i[e]).forEach(function(r) {
      return c9(r);
    });
  });
}
var _9 = (
  /** @class */
  function() {
    function i(e) {
      var r = this;
      this.options = G3({
        linkAttributes: null,
        extendedAutolinks: !1,
        customHTMLRenderer: null,
        referenceDefinition: !1,
        customHTMLSanitizer: null,
        frontMatter: !1,
        usageStatistics: !0,
        theme: "light"
      }, e), this.eventEmitter = new P9();
      var s = J6(this.options.linkAttributes), l = I9({
        plugins: this.options.plugins,
        eventEmitter: this.eventEmitter,
        usageStatistics: this.options.usageStatistics,
        instance: this
      }) || {}, c = l.toHTMLRenderers, f = l.markdownParsers, p = this.options, d = p.customHTMLRenderer, m = p.extendedAutolinks, y = p.referenceDefinition, S = p.frontMatter, x = p.customHTMLSanitizer, w = {
        linkAttributes: s,
        customHTMLRenderer: Nt(Nt({}, c), d),
        extendedAutolinks: m,
        referenceDefinition: y,
        frontMatter: S,
        sanitizer: x || Yc
      };
      A4e(w.customHTMLRenderer), this.options.events && pp(this.options.events, function(z, J) {
        r.on(J, z);
      });
      var k = this.options, O = k.el, T = k.initialValue, L = k.theme, j = O.innerHTML;
      L !== "light" && O.classList.add(vr(L)), O.innerHTML = "", this.toastMark = new o9("", {
        disallowedHtmlBlockTags: ["br", "img"],
        extendedAutolinks: m,
        referenceDefinition: y,
        disallowDeepHeading: !0,
        frontMatter: S,
        customParser: f
      }), this.preview = new h9(this.eventEmitter, Nt(Nt({}, w), { isViewer: !0 })), E4(this.preview.previewContent, "mousedown", this.toggleTask.bind(this)), T ? this.setMarkdown(T) : j && this.preview.setHTML(j), O.appendChild(this.preview.previewContent), this.eventEmitter.emit("load", this);
    }
    return i.prototype.toggleTask = function(e) {
      var r = e.target, s = getComputedStyle(r, ":before");
      !r.hasAttribute(C4e) && r.hasAttribute(O4e) && tW(s, e.offsetX, e.offsetY) && (rW(r, T4e), this.eventEmitter.emit("change", {
        source: "viewer",
        date: e
      }));
    }, i.prototype.setMarkdown = function(e) {
      var r = this.toastMark.getLineTexts(), s = r.length, l = Qi(r), c = [s, l.length + 1], f = this.toastMark.editMarkdown([1, 1], c, e || "");
      this.eventEmitter.emit("updatePreview", f);
    }, i.prototype.on = function(e, r) {
      this.eventEmitter.listen(e, r);
    }, i.prototype.off = function(e) {
      this.eventEmitter.removeEventHandler(e);
    }, i.prototype.addHook = function(e, r) {
      this.eventEmitter.removeEventHandler(e), this.eventEmitter.listen(e, r);
    }, i.prototype.destroy = function() {
      A4(this.preview.el, "mousedown", this.toggleTask.bind(this)), this.preview.destroy(), this.eventEmitter.emit("destroy");
    }, i.prototype.isViewer = function() {
      return !0;
    }, i.prototype.isMarkdownMode = function() {
      return !1;
    }, i.prototype.isWysiwygMode = function() {
      return !1;
    }, i;
  }()
);
function rx(i) {
  return i instanceof Au;
}
function N9(i) {
  var e = [
    "document",
    "blockQuote",
    "bulletList",
    "orderedList",
    "listItem",
    "paragraph",
    "heading",
    "emph",
    "strong",
    "strike",
    "link",
    "image",
    "table",
    "tableHead",
    "tableBody",
    "tableRow",
    "tableHeadCell",
    "tableBodyCell"
  ];
  return Ri(e, i);
}
function E4e(i) {
  var e = i.attrs, r = i.type, s = r.name, l = {
    type: s,
    wysiwygNode: !0,
    literal: !N9(s) && rx(i) ? i.textContent : null
  }, c = {
    heading: { level: e.level },
    link: { destination: e.linkUrl, title: e.title },
    image: { destination: e.imageUrl },
    codeBlock: { info: e.language },
    bulletList: { type: "list", listData: { type: "bullet" } },
    orderedList: { type: "list", listData: { type: "ordered", start: e.order } },
    listItem: { type: "item", listData: { task: e.task, checked: e.checked } },
    tableHeadCell: { type: "tableCell", cellType: "head", align: e.align },
    tableBodyCell: { type: "tableCell", cellType: "body", align: e.align },
    customBlock: { info: e.info }
  }, f = c[s], p = Nt(Nt({}, l), f), d = i.attrs, m = d.htmlAttrs, y = d.childrenHTML;
  return m ? Nt(Nt({}, p), { attrs: m, childrenHTML: y }) : p;
}
var M4e = {
  openTag: function(i, e) {
    var r = i, s = r.tagName, l = r.classNames, c = r.attributes, f = document.createElement(s), p = {};
    l && (f.className = l.join(" ")), c && (p = Nt(Nt({}, p), c)), iW(p, f), e.push(f);
  },
  closeTag: function(i, e) {
    if (e.length > 1) {
      var r = e.pop();
      Qi(e).appendChild(r);
    }
  },
  html: function(i, e) {
    Qi(e).insertAdjacentHTML("beforeend", i.content);
  },
  text: function(i, e) {
    var r = document.createTextNode(i.content);
    Qi(e).appendChild(r);
  }
}, R4e = (
  /** @class */
  function() {
    function i(e, r) {
      var s = gW(e, r), l = Nt(Nt({}, r.htmlBlock), r.htmlInline);
      this.customConvertorKeys = Object.keys(r).concat(Object.keys(l)), this.renderer = new mW({
        gfm: !0,
        convertors: Nt(Nt({}, s), l)
      }), this.convertors = this.renderer.getConvertors();
    }
    return i.prototype.generateTokens = function(e) {
      var r = E4e(e), s = {
        entering: !0,
        leaf: rx(e) ? e.isLeaf : !1,
        options: this.renderer.getOptions(),
        getChildrenText: function() {
          return rx(e) ? e.textContent : "";
        },
        skipChildren: function() {
          return !1;
        }
      }, l = this.convertors[e.type.name], c = l(r, s, this.convertors), f = Op(c) ? c : [c];
      return (N9(e.type.name) || e.attrs.htmlInline) && (s.entering = !1, f.push({ type: "text", content: rx(e) ? e.textContent : "" }), f = f.concat(l(r, s, this.convertors))), f;
    }, i.prototype.toDOMNode = function(e) {
      var r = this.generateTokens(e), s = [];
      return r.forEach(function(l) {
        return M4e[l.type](l, s);
      }), s[0];
    }, i.prototype.getToDOMNode = function(e) {
      return Ri(this.customConvertorKeys, e) ? this.toDOMNode.bind(this) : null;
    }, i;
  }()
), D4e = 100, P4e = 15, Gw = null, xj = null;
function p5(i, e) {
  var r = e.syncScrollTop, s = e.releaseEventBlock;
  xj && clearTimeout(xj), r(i), xj = setTimeout(function() {
    s();
  }, P4e);
}
function L4e(i, e, r) {
  var s = e - i, l = Date.now(), c = function() {
    var f = Date.now(), p = (f - l) / D4e, d;
    Gw && clearTimeout(Gw), p < 1 ? (d = i + s * Math.cos((1 - p) * Math.PI / 2), p5(Math.ceil(d), r), Gw = setTimeout(c, 1)) : (p5(e, r), Gw = null);
  };
  c();
}
var I4e = 18, _4e = (
  /** @class */
  function() {
    function i(e, r, s) {
      this.latestEditorScrollTop = null, this.latestPreviewScrollTop = null, this.blockedScroll = null, this.active = !0, this.timer = null;
      var l = r.previewContent, c = r.el;
      this.previewRoot = l, this.previewEl = c, this.mdEditor = e, this.editorView = e.view, this.toastMark = e.getToastMark(), this.eventEmitter = s, this.addScrollSyncEvent();
    }
    return i.prototype.addScrollSyncEvent = function() {
      var e = this;
      this.eventEmitter.listen("afterPreviewRender", function() {
        e.clearTimer(), e.timer = setTimeout(function() {
          e.syncPreviewScrollTop(!0);
        }, 200);
      }), this.eventEmitter.listen("scroll", function(r, s) {
        e.active && (r === "editor" && e.blockedScroll !== "editor" ? e.syncPreviewScrollTop() : r === "preview" && e.blockedScroll !== "preview" && e.syncEditorScrollTop(s));
      }), this.eventEmitter.listen("toggleScrollSync", function(r) {
        e.active = r;
      });
    }, i.prototype.getMdNodeAtPos = function(e, r) {
      var s = e.content.findIndex(r.pos), l = s.index;
      return this.toastMark.findFirstNodeAtLine(l + 1);
    }, i.prototype.getScrollTopByCaretPos = function() {
      var e = this.mdEditor.getSelection(), r = this.toastMark.findFirstNodeAtLine(e[0][0]), s = this.previewEl.clientHeight, l = yj(this.previewRoot, r).el, c = Ex(l, this.previewRoot) || l.offsetTop, f = l.clientHeight, p = c + f - s * 0.5;
      this.latestEditorScrollTop = null;
      var d = l.getBoundingClientRect().top - this.previewEl.getBoundingClientRect().top;
      return d < s ? null : p;
    }, i.prototype.syncPreviewScrollTop = function(e) {
      e === void 0 && (e = !1);
      var r = this, s = r.editorView, l = r.previewEl, c = r.previewRoot, f = s.dom.getBoundingClientRect(), p = f.left, d = f.top, m = s.posAtCoords({ left: p, top: d }), y = s.state.doc, S = this.getMdNodeAtPos(y, m);
      if (!(!S || Sne(S))) {
        var x = l.scrollTop, w = s.dom, k = w.scrollTop, O = w.scrollHeight, T = w.clientHeight, L = w.children, j = O - k <= T + I4e, z = j ? l.scrollHeight : 0;
        if (k && !j) {
          if (e) {
            var J = this.getScrollTopByCaretPos();
            if (!J)
              return;
            z = J;
          } else {
            var ie = yj(this.previewRoot, S), K = ie.el, re = ie.mdNode, ee = Q8(y, re, L), de = ee.height, Ce = ee.rect, he = Ex(K, c) || K.offsetTop, oe = K.clientHeight, ge = d > Ce.top ? Math.min((d - Ce.top) / de, 1) : 0;
            z = he + oe * ge;
          }
          z = this.getResolvedScrollTop("editor", k, z, x), this.latestEditorScrollTop = k;
        }
        z !== x && this.run("editor", z, x);
      }
    }, i.prototype.syncEditorScrollTop = function(e) {
      var r = this, s = r.toastMark, l = r.editorView, c = r.previewRoot, f = r.previewEl, p = l.dom, d = l.state, m = f.scrollTop, y = f.clientHeight, S = f.scrollHeight, x = S - m <= y, w = p.scrollTop, k = x ? p.scrollHeight : 0;
      if (m && e && !x) {
        if (e = D5e(e, c), !e.getAttribute("data-nodeid"))
          return;
        var O = p.children, T = Number(e.getAttribute("data-nodeid")), L = yj(this.previewRoot, s.findNodeById(T)), j = L.mdNode, z = L.el, J = iy(j);
        k = O[J - 1].offsetTop;
        var ie = Q8(d.doc, j, O).height, K = z5e(z, c, T), re = K.nodeHeight, ee = K.offsetTop;
        k += L5e(m, ee, re, ie), k = this.getResolvedScrollTop("preview", m, k, w), this.latestPreviewScrollTop = m;
      }
      k !== w && this.run("preview", k, w);
    }, i.prototype.getResolvedScrollTop = function(e, r, s, l) {
      var c = e === "editor" ? this.latestEditorScrollTop : this.latestPreviewScrollTop;
      return c === null ? s : c < r ? Math.max(s, l) : Math.min(s, l);
    }, i.prototype.run = function(e, r, s) {
      var l = this, c;
      e === "editor" ? (c = this.previewEl, this.blockedScroll = "preview") : (c = this.editorView.dom, this.blockedScroll = "editor");
      var f = {
        syncScrollTop: function(p) {
          return c.scrollTop = p;
        },
        releaseEventBlock: function() {
          return l.blockedScroll = null;
        }
      };
      L4e(s, r, f);
    }, i.prototype.clearTimer = function() {
      this.timer && (clearTimeout(this.timer), this.timer = null);
    }, i.prototype.destroy = function() {
      this.clearTimer(), this.eventEmitter.removeEventHandler("scroll"), this.eventEmitter.removeEventHandler("afterPreviewRender");
    }, i;
  }()
), N4e = {
  getPopupInitialValues: function(i, e) {
    var r = e.popupName;
    return r === "link" ? { linkText: i.getSelectedText() } : {};
  }
};
function B4e(i) {
  i.eventEmitter.listen("query", function(e, r) {
    return N4e[e](i, r);
  });
}
var B9 = (
  /** @class */
  function() {
    function i(e) {
      var r = this;
      this.initialHTML = e.el.innerHTML, e.el.innerHTML = "", this.options = G3({
        previewStyle: "tab",
        previewHighlight: !0,
        initialEditType: "markdown",
        height: "300px",
        minHeight: "200px",
        language: "en-US",
        useCommandShortcut: !0,
        usageStatistics: !0,
        toolbarItems: [
          ["heading", "bold", "italic", "strike"],
          ["hr", "quote"],
          ["ul", "ol", "task", "indent", "outdent"],
          ["table", "image", "link"],
          ["code", "codeblock"],
          ["scrollSync"]
        ],
        hideModeSwitch: !1,
        linkAttributes: null,
        extendedAutolinks: !1,
        customHTMLRenderer: null,
        customMarkdownRenderer: null,
        referenceDefinition: !1,
        customHTMLSanitizer: null,
        frontMatter: !1,
        widgetRules: [],
        theme: "light",
        autofocus: !0
      }, e);
      var s = this.options, l = s.customHTMLRenderer, c = s.extendedAutolinks, f = s.referenceDefinition, p = s.frontMatter, d = s.customMarkdownRenderer, m = s.useCommandShortcut, y = s.initialEditType, S = s.widgetRules, x = s.customHTMLSanitizer;
      this.mode = y || "markdown", this.mdPreviewStyle = this.options.previewStyle, this.i18n = Mr, this.i18n.setCode(this.options.language), this.eventEmitter = new P9(), Rne(S);
      var w = J6(this.options.linkAttributes);
      this.pluginInfo = I9({
        plugins: this.options.plugins,
        eventEmitter: this.eventEmitter,
        usageStatistics: this.options.usageStatistics,
        instance: this
      });
      var k = this.pluginInfo, O = k.toHTMLRenderers, T = k.toMarkdownRenderers, L = k.mdPlugins, j = k.wwPlugins, z = k.wwNodeViews, J = k.mdCommands, ie = k.wwCommands, K = k.markdownParsers, re = {
        linkAttributes: w,
        customHTMLRenderer: yx(O, l),
        extendedAutolinks: c,
        referenceDefinition: f,
        frontMatter: p,
        sanitizer: x || Yc
      }, ee = new R4e(w, re.customHTMLRenderer), de = O5e(re.customHTMLRenderer, re.sanitizer, ee);
      this.toastMark = new o9("", {
        disallowedHtmlBlockTags: ["br", "img"],
        extendedAutolinks: c,
        referenceDefinition: f,
        disallowDeepHeading: !0,
        frontMatter: p,
        customParser: K
      }), this.mdEditor = new Pae(this.eventEmitter, {
        toastMark: this.toastMark,
        useCommandShortcut: m,
        mdPlugins: L
      }), this.preview = new h9(this.eventEmitter, Nt(Nt({}, re), { isViewer: !1, highlight: this.options.previewHighlight })), this.wwEditor = new K6e(this.eventEmitter, {
        toDOMAdaptor: ee,
        useCommandShortcut: m,
        htmlSchemaMap: de,
        linkAttributes: w,
        wwPlugins: j,
        wwNodeViews: z
      }), this.convertor = new x4e(this.wwEditor.getSchema(), Nt(Nt({}, T), d), gW(w, re.customHTMLRenderer), this.eventEmitter), this.setMinHeight(this.options.minHeight), this.setHeight(this.options.height), this.setMarkdown(this.options.initialValue, !1), this.options.placeholder && this.setPlaceholder(this.options.placeholder), this.options.initialValue || this.setHTML(this.initialHTML, !1), this.commandManager = new o4e(this.eventEmitter, this.mdEditor.commands, this.wwEditor.commands, function() {
        return r.mode;
      }), this.options.usageStatistics && fne(), this.scrollSync = new _4e(this.mdEditor, this.preview, this.eventEmitter), this.addInitEvent(), this.addInitCommand(J, ie), B4e(this), this.options.hooks && pp(this.options.hooks, function(Ce, he) {
        return r.addHook(he, Ce);
      }), this.options.events && pp(this.options.events, function(Ce, he) {
        return r.on(he, Ce);
      }), this.eventEmitter.emit("load", this), this.moveCursorToStart(this.options.autofocus);
    }
    return i.prototype.addInitEvent = function() {
      var e = this;
      this.on("needChangeMode", this.changeMode.bind(this)), this.on("loadUI", function() {
        if (e.height !== "auto") {
          var r = Math.min(parseInt(e.minHeight, 10), parseInt(e.height, 10) - 75) + "px";
          e.setMinHeight(r);
        }
      }), rie(this.eventEmitter);
    }, i.prototype.addInitCommand = function(e, r) {
      var s = this, l = function(c, f) {
        Object.keys(f).forEach(function(p) {
          s.addCommand(c, p, f[p]);
        });
      };
      this.addCommand("markdown", "toggleScrollSync", function(c) {
        return s.eventEmitter.emit("toggleScrollSync", c.active), !0;
      }), l("markdown", e), l("wysiwyg", r);
    }, i.prototype.getCurrentModeEditor = function() {
      return this.isMarkdownMode() ? this.mdEditor : this.wwEditor;
    }, i.factory = function(e) {
      return e.viewer ? new _9(e) : new i(e);
    }, i.setLanguage = function(e, r) {
      Mr.setLanguage(e, r);
    }, i.prototype.changePreviewStyle = function(e) {
      this.mdPreviewStyle !== e && (this.mdPreviewStyle = e, this.eventEmitter.emit("changePreviewStyle", e));
    }, i.prototype.exec = function(e, r) {
      this.commandManager.exec(e, r);
    }, i.prototype.addCommand = function(e, r, s) {
      var l = this, c = function(f) {
        f === void 0 && (f = {});
        var p = (e === "markdown" ? l.mdEditor : l.wwEditor).view;
        s(f, p.state, p.dispatch, p);
      };
      this.commandManager.addCommand(e, r, c);
    }, i.prototype.on = function(e, r) {
      this.eventEmitter.listen(e, r);
    }, i.prototype.off = function(e) {
      this.eventEmitter.removeEventHandler(e);
    }, i.prototype.addHook = function(e, r) {
      this.eventEmitter.removeEventHandler(e), this.eventEmitter.listen(e, r);
    }, i.prototype.removeHook = function(e) {
      this.eventEmitter.removeEventHandler(e);
    }, i.prototype.focus = function() {
      this.getCurrentModeEditor().focus();
    }, i.prototype.blur = function() {
      this.getCurrentModeEditor().blur();
    }, i.prototype.moveCursorToEnd = function(e) {
      e === void 0 && (e = !0), this.getCurrentModeEditor().moveCursorToEnd(e);
    }, i.prototype.moveCursorToStart = function(e) {
      e === void 0 && (e = !0), this.getCurrentModeEditor().moveCursorToStart(e);
    }, i.prototype.setMarkdown = function(e, r) {
      if (e === void 0 && (e = ""), r === void 0 && (r = !0), this.mdEditor.setMarkdown(e, r), this.isWysiwygMode()) {
        var s = this.toastMark.getRootNode(), l = this.convertor.toWysiwygModel(s);
        this.wwEditor.setModel(l, r);
      }
    }, i.prototype.setHTML = function(e, r) {
      e === void 0 && (e = ""), r === void 0 && (r = !0);
      var s = document.createElement("div");
      s.innerHTML = Qne(e);
      var l = zc.fromSchema(this.wwEditor.schema).parse(s);
      this.isMarkdownMode() ? this.mdEditor.setMarkdown(this.convertor.toMarkdownText(l), r) : this.wwEditor.setModel(l, r);
    }, i.prototype.getMarkdown = function() {
      return this.isMarkdownMode() ? this.mdEditor.getMarkdown() : this.convertor.toMarkdownText(this.wwEditor.getModel());
    }, i.prototype.getHTML = function() {
      var e = this;
      this.eventEmitter.holdEventInvoke(function() {
        if (e.isMarkdownMode()) {
          var l = e.toastMark.getRootNode(), c = e.convertor.toWysiwygModel(l);
          e.wwEditor.setModel(c);
        }
      });
      var r = aW(this.wwEditor.view.dom.innerHTML);
      if (this.placeholder) {
        var s = new RegExp('<span class="placeholder[^>]+>' + this.placeholder + "</span>", "i");
        return r.replace(s, "");
      }
      return r;
    }, i.prototype.insertText = function(e) {
      this.getCurrentModeEditor().replaceSelection(e);
    }, i.prototype.setSelection = function(e, r) {
      this.getCurrentModeEditor().setSelection(e, r);
    }, i.prototype.replaceSelection = function(e, r, s) {
      this.getCurrentModeEditor().replaceSelection(e, r, s);
    }, i.prototype.deleteSelection = function(e, r) {
      this.getCurrentModeEditor().deleteSelection(e, r);
    }, i.prototype.getSelectedText = function(e, r) {
      return this.getCurrentModeEditor().getSelectedText(e, r);
    }, i.prototype.getRangeInfoOfNode = function(e) {
      return this.getCurrentModeEditor().getRangeInfoOfNode(e);
    }, i.prototype.addWidget = function(e, r, s) {
      this.getCurrentModeEditor().addWidget(e, r, s);
    }, i.prototype.replaceWithWidget = function(e, r, s) {
      this.getCurrentModeEditor().replaceWithWidget(e, r, s);
    }, i.prototype.setHeight = function(e) {
      var r = this.options.el;
      Tl(e) && (e === "auto" ? Bs(r, "auto-height") : fs(r, "auto-height"), this.setMinHeight(this.getMinHeight())), js(r, { height: e }), this.height = e;
    }, i.prototype.getHeight = function() {
      return this.height;
    }, i.prototype.setMinHeight = function(e) {
      if (e !== this.minHeight) {
        var r = this.height || this.options.height;
        r !== "auto" && this.options.el.querySelector("." + vr("main")) && (e = Math.min(parseInt(e, 10), parseInt(r, 10) - 75) + "px");
        var s = parseInt(e, 10);
        this.minHeight = e, this.wwEditor.setMinHeight(s), this.mdEditor.setMinHeight(s), this.preview.setMinHeight(s);
      }
    }, i.prototype.getMinHeight = function() {
      return this.minHeight;
    }, i.prototype.isMarkdownMode = function() {
      return this.mode === "markdown";
    }, i.prototype.isWysiwygMode = function() {
      return this.mode === "wysiwyg";
    }, i.prototype.isViewer = function() {
      return !1;
    }, i.prototype.getCurrentPreviewStyle = function() {
      return this.mdPreviewStyle;
    }, i.prototype.changeMode = function(e, r) {
      if (this.mode !== e) {
        if (this.mode = e, this.isWysiwygMode()) {
          var s = this.toastMark.getRootNode(), l = this.convertor.toWysiwygModel(s);
          this.wwEditor.setModel(l);
        } else {
          var l = this.wwEditor.getModel();
          this.mdEditor.setMarkdown(this.convertor.toMarkdownText(l), !r);
        }
        if (this.eventEmitter.emit("removePopupWidget"), this.eventEmitter.emit("changeMode", e), !r) {
          var c = this.convertor.getMappedPos();
          this.focus(), this.isWysiwygMode() && yl(c) ? this.wwEditor.setSelection(c) : Array.isArray(c) && this.mdEditor.setSelection(c);
        }
      }
    }, i.prototype.destroy = function() {
      var e = this;
      this.wwEditor.destroy(), this.mdEditor.destroy(), this.preview.destroy(), this.scrollSync.destroy(), this.eventEmitter.emit("destroy"), this.eventEmitter.getEvents().forEach(function(r, s) {
        return e.off(s);
      });
    }, i.prototype.hide = function() {
      this.eventEmitter.emit("hide");
    }, i.prototype.show = function() {
      this.eventEmitter.emit("show");
    }, i.prototype.setScrollTop = function(e) {
      this.getCurrentModeEditor().setScrollTop(e);
    }, i.prototype.getScrollTop = function() {
      return this.getCurrentModeEditor().getScrollTop();
    }, i.prototype.reset = function() {
      this.wwEditor.setModel([]), this.mdEditor.setMarkdown("");
    }, i.prototype.getSelection = function() {
      return this.getCurrentModeEditor().getSelection();
    }, i.prototype.setPlaceholder = function(e) {
      this.placeholder = e, this.mdEditor.setPlaceholder(e), this.wwEditor.setPlaceholder(e);
    }, i.prototype.getEditorElements = function() {
      return {
        mdEditor: this.mdEditor.getElement(),
        mdPreview: this.preview.getElement(),
        wwEditor: this.wwEditor.getElement()
      };
    }, i.prototype.convertPosToMatchEditorMode = function(e, r, s) {
      var l, c;
      r === void 0 && (r = e), s === void 0 && (s = this.mode);
      var f = this.mdEditor.view.state.doc, p = Array.isArray(e), d = Array.isArray(r), m = e, y = r;
      if (p !== d)
        throw new Error("Types of arguments must be same");
      return s === "markdown" && !p && !d ? (l = Xw(f, e, r), m = l[0], y = l[1]) : s === "wysiwyg" && p && d && (c = Ac(f, e, r), m = c[0], y = c[1]), [m, y];
    }, i;
  }()
);
function F4e(i) {
  for (var e, r, s = arguments, l = 1, c = "", f = "", p = [0], d = function(y) {
    l === 1 && (y || (c = c.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? p.push(y ? s[y] : c) : l === 3 && (y || c) ? (p[1] = y ? s[y] : c, l = 2) : l === 2 && c === "..." && y ? p[2] = Z3(p[2] || {}, s[y]) : l === 2 && c && !y ? (p[2] = p[2] || {})[c] = !0 : l >= 5 && (l === 5 ? ((p[2] = p[2] || {})[r] = y ? c ? c + s[y] : s[y] : c, l = 6) : (y || c) && (p[2][r] += y ? c + s[y] : c)), c = "";
  }, m = 0; m < i.length; m++) {
    m && (l === 1 && d(), d(m));
    for (let y = 0; y < i[m].length; y++)
      e = i[m][y], l === 1 ? e === "<" ? (d(), p = [p, "", null], l = 3) : c += e : l === 4 ? c === "--" && e === ">" ? (l = 1, c = "") : c = e + c[0] : f ? e === f ? f = "" : c += e : e === '"' || e === "'" ? f = e : e === ">" ? (d(), l = 1) : l && (e === "=" ? (l = 5, r = c, c = "") : e === "/" && (l < 5 || i[m][y + 1] === ">") ? (d(), l === 3 && (p = p[0]), l = p, (p = p[0]).push(this.apply(null, l.slice(1))), l = 0) : e === " " || e === "	" || e === `
` || e === "\r" ? (d(), l = 2) : c += e), l === 3 && c === "!--" && (l = 4, p = p[0]);
  }
  return d(), p.length > 2 ? p.slice(1) : p[1];
}
function z4e(i) {
  return typeof i == "boolean" || i instanceof Boolean;
}
var H4e = z4e, j4e = (
  /** @class */
  function() {
    function i(e) {
      this.current = e, this.root = e, this.entering = !0;
    }
    return i.prototype.walk = function() {
      var e = this, r = e.entering, s = e.current;
      return s ? (r ? s.firstChild ? (this.current = s.firstChild, this.entering = !0) : this.entering = !1 : s === this.root ? this.current = null : s.next ? (this.current = s.next, this.entering = !0) : (this.current = s.parent, this.entering = !1), { vnode: s, entering: r }) : null;
    }, i;
  }()
), hs = (
  /** @class */
  function() {
    function i(e, r, s) {
      this.parent = null, this.old = null, this.firstChild = null, this.next = null, this.skip = !1, this.type = e, this.props = r, this.children = s, this.props.children = s, r.ref && (this.ref = r.ref, delete r.ref), r.key && (this.key = r.key, delete r.key);
    }
    return i.prototype.walker = function() {
      return new j4e(this);
    }, i.removalNodes = [], i;
  }()
);
function W4e(i) {
  return new hs("TEXT_NODE", { nodeValue: i }, []);
}
function v5(i, e) {
  var r = i;
  H4e(i) || i == null ? r = null : (Tl(i) || yl(i)) && (r = W4e(String(i))), r && e.push(r);
}
function $4e(i, e) {
  for (var r = [], s = 2; s < arguments.length; s++)
    r[s - 2] = arguments[s];
  var l = [];
  return r.forEach(function(c) {
    Array.isArray(c) ? c.forEach(function(f) {
      v5(f, l);
    }) : v5(c, l);
  }), new hs(i, e || {}, l);
}
var Xr = F4e.bind($4e);
function U4e(i) {
  return i === Object(i);
}
var V4e = U4e;
function G4e(i) {
  var e;
  return i.type === "TEXT_NODE" ? e = document.createTextNode(i.props.nodeValue) : (e = document.createElement(i.type), z9(e, {}, i.props)), e;
}
function F9(i, e) {
  i.node ? e.removeChild(i.node) : F9(i.firstChild, e);
}
function Y4e(i, e, r) {
  Object.keys(e).forEach(function(s) {
    if (/^on/.test(s)) {
      if (!r[s] || e[s] !== r[s]) {
        var l = s.slice(2).toLowerCase();
        i.removeEventListener(l, e[s]);
      }
    } else s !== "children" && !r[s] && !qne(i) && i.removeAttribute(s);
  }), z9(i, e, r, function(s) {
    return !q3(e[s], r[s]);
  });
}
var q4e = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;
function z9(i, e, r, s) {
  Object.keys(r).forEach(function(l) {
    if (!s || s(l))
      if (/^on/.test(l)) {
        var c = l.slice(2).toLowerCase();
        i.addEventListener(c, r[l]);
      } else l === "nodeValue" ? i[l] = r[l] : l === "style" && V4e(r[l]) ? K4e(i, e[l], r[l]) : l !== "children" && (r[l] === !1 ? i.removeAttribute(l) : i.setAttribute(l, r[l]));
  });
}
function K4e(i, e, r) {
  e && Object.keys(e).forEach(function(s) {
    i.style[s] = "";
  }), Object.keys(r).forEach(function(s) {
    var l = r[s];
    i.style[s] = yl(l) && !q4e.test(s) ? l + "px" : l;
  });
}
function SW(i) {
  if (hs.removalNodes.forEach(function(c) {
    return g5(c);
  }), i) {
    for (var e = void 0, r = i.walker(); e = r.walk(); )
      if (i = e.vnode, e.entering)
        g5(i);
      else if (_o(i.type)) {
        var s = i.component;
        if (!i.old && s.mounted && s.mounted(), i.old && s.updated) {
          var l = s.prevProps || {};
          s.updated(l);
        }
      }
  }
}
function m5(i) {
  for (var e = i.parent; !e.node; )
    e = e.parent;
  return e.node;
}
function g5(i) {
  if (!(!i || !i.parent)) {
    if (i.node) {
      var e = m5(i);
      i.effect === "A" ? e.appendChild(i.node) : i.effect === "U" && Y4e(i.node, i.old.props, i.props);
    }
    if (i.effect === "D") {
      for (var r = void 0, s = i.walker(); r = s.walk(); )
        if (i = r.vnode, !r.entering)
          if (_o(i.type)) {
            var l = i.component;
            l.beforeDestroy && l.beforeDestroy();
          } else {
            var e = m5(i);
            F9(i, e);
          }
    }
    i.ref && (i.component ? i.ref(i.component) : i.node && i.ref(i.node));
  }
}
function X4e(i, e) {
  var r = e.props, s = e.component;
  return s ? (s.prevProps = s.props, s.props = e.props, s) : new i(r);
}
function H9(i) {
  for (var e = i; i && !i.skip; ) {
    if (_o(i.type)) {
      var r = X4e(i.type, i);
      r.vnode = i, i.component = r, i.props.children = i.children = [r.render()], y5(i);
    } else
      i.node || (i.node = G4e(i)), y5(i);
    if (i.firstChild)
      i = i.firstChild;
    else {
      for (; i && i.parent && !i.next && (i = i.parent, i !== e); )
        ;
      i = i.next;
    }
  }
}
function J4e(i, e) {
  return i && e && e.type === i.type && (!e.key || e.key === i.key);
}
function y5(i) {
  var e = i.children, r = i.old ? i.old.firstChild : null, s = null;
  e.forEach(function(c, f) {
    var p = J4e(r, c);
    p && (c.old = r, c.parent = i, c.node = r.node, c.component = r.component, c.effect = "U"), c && !p && (c.old = null, c.parent = i, c.node = null, c.effect = "A"), r && !p && (hs.removalNodes.push(r), r.effect = "D"), r && (r = r.next), f === 0 ? i.firstChild = c : c && (s.next = c), s = c;
  });
  var l = Qi(e);
  if (!e.length)
    for (; r; )
      hs.removalNodes.push(r), r.effect = "D", r = r.next;
  for (; r && l; )
    r && l.old !== r && (hs.removalNodes.push(r), r.effect = "D", r = r.next);
}
function Z4e(i) {
  i.effect = "D", hs.removalNodes = [i], SW(), hs.removalNodes = [];
}
function Q4e(i) {
  var e = i.vnode;
  e.effect = "U", e.old = e, e.next && (e.next.skip = !0), hs.removalNodes = [], H9(e), SW(e), e.next && (e.next.skip = !1);
}
function e9e(i, e) {
  var r = new hs(i.tagName.toLowerCase(), {}, [e]);
  return r.node = i, hs.removalNodes = [], H9(r), SW(r), function() {
    return Z4e(r.firstChild);
  };
}
var ea = (
  /** @class */
  function() {
    function i(e) {
      this.props = e, this.state = {}, this.refs = {};
    }
    return i.prototype.setState = function(e) {
      var r = Nt(Nt({}, this.state), e);
      q3(this.state, r) || (this.state = r, Q4e(this));
    }, i;
  }()
), t9e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e(r) {
      var s = i.call(this, r) || this;
      return s.state = {
        hide: !1
      }, s;
    }
    return e.prototype.show = function() {
      this.setState({ hide: !1 });
    }, e.prototype.hide = function() {
      this.setState({ hide: !0 });
    }, e.prototype.render = function() {
      var r = this.props, s = r.editorType, l = r.eventEmitter;
      return Xr(b5 || (b5 = Kr([`
      <div class="`, '" style="display: ', `">
        <div
          class="tab-item`, `"
          onClick=`, `
        >
          `, `
        </div>
        <div
          class="tab-item`, `"
          onClick=`, `
        >
          `, `
        </div>
      </div>
    `], [
        `
      <div class="`,
        '" style="display: ',
        `">
        <div
          class="tab-item`,
        `"
          onClick=`,
        `
        >
          `,
        `
        </div>
        <div
          class="tab-item`,
        `"
          onClick=`,
        `
        >
          `,
        `
        </div>
      </div>
    `
      ])), vr("mode-switch"), this.state.hide ? "none" : "block", s === "markdown" ? " active" : "", function() {
        l.emit("needChangeMode", "markdown");
      }, Mr.get("Markdown"), s === "wysiwyg" ? " active" : "", function() {
        l.emit("needChangeMode", "wysiwyg");
      }, Mr.get("WYSIWYG"));
    }, e;
  }(ea)
), b5;
function r9e(i, e) {
  var r, s;
  e = e || 0;
  function l() {
    s = Array.prototype.slice.call(arguments), window.clearTimeout(r), r = window.setTimeout(function() {
      i.apply(null, s);
    }, e);
  }
  return l;
}
var n9e = r9e, i9e = n9e;
function a9e(i, e) {
  var r, s = !0, l = function(y) {
    i.apply(null, y), r = null;
  }, c, f, p;
  e = e || 0, c = i9e(l, e);
  function d() {
    if (p = Array.prototype.slice.call(arguments), s) {
      l(p), s = !1;
      return;
    }
    f = Number(/* @__PURE__ */ new Date()), r = r || f, c(p), f - r >= e && l(p);
  }
  function m() {
    s = !0, r = null;
  }
  return d.reset = m, d;
}
var o9e = a9e, j9 = function() {
  if (typeof Map < "u")
    return Map;
  function i(e, r) {
    var s = -1;
    return e.some(function(l, c) {
      return l[0] === r ? (s = c, !0) : !1;
    }), s;
  }
  return (
    /** @class */
    function() {
      function e() {
        this.__entries__ = [];
      }
      return Object.defineProperty(e.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: !0,
        configurable: !0
      }), e.prototype.get = function(r) {
        var s = i(this.__entries__, r), l = this.__entries__[s];
        return l && l[1];
      }, e.prototype.set = function(r, s) {
        var l = i(this.__entries__, r);
        ~l ? this.__entries__[l][1] = s : this.__entries__.push([r, s]);
      }, e.prototype.delete = function(r) {
        var s = this.__entries__, l = i(s, r);
        ~l && s.splice(l, 1);
      }, e.prototype.has = function(r) {
        return !!~i(this.__entries__, r);
      }, e.prototype.clear = function() {
        this.__entries__.splice(0);
      }, e.prototype.forEach = function(r, s) {
        s === void 0 && (s = null);
        for (var l = 0, c = this.__entries__; l < c.length; l++) {
          var f = c[l];
          r.call(s, f[1], f[0]);
        }
      }, e;
    }()
  );
}(), C3 = typeof window < "u" && typeof document < "u" && window.document === document, Rx = function() {
  return typeof global < "u" && global.Math === Math ? global : typeof self < "u" && self.Math === Math ? self : typeof window < "u" && window.Math === Math ? window : Function("return this")();
}(), s9e = function() {
  return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(Rx) : function(i) {
    return setTimeout(function() {
      return i(Date.now());
    }, 1e3 / 60);
  };
}(), l9e = 2;
function u9e(i, e) {
  var r = !1, s = !1, l = 0;
  function c() {
    r && (r = !1, i()), s && p();
  }
  function f() {
    s9e(c);
  }
  function p() {
    var d = Date.now();
    if (r) {
      if (d - l < l9e)
        return;
      s = !0;
    } else
      r = !0, s = !1, setTimeout(f, e);
    l = d;
  }
  return p;
}
var c9e = 20, f9e = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], d9e = typeof MutationObserver < "u", h9e = (
  /** @class */
  function() {
    function i() {
      this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = u9e(this.refresh.bind(this), c9e);
    }
    return i.prototype.addObserver = function(e) {
      ~this.observers_.indexOf(e) || this.observers_.push(e), this.connected_ || this.connect_();
    }, i.prototype.removeObserver = function(e) {
      var r = this.observers_, s = r.indexOf(e);
      ~s && r.splice(s, 1), !r.length && this.connected_ && this.disconnect_();
    }, i.prototype.refresh = function() {
      var e = this.updateObservers_();
      e && this.refresh();
    }, i.prototype.updateObservers_ = function() {
      var e = this.observers_.filter(function(r) {
        return r.gatherActive(), r.hasActive();
      });
      return e.forEach(function(r) {
        return r.broadcastActive();
      }), e.length > 0;
    }, i.prototype.connect_ = function() {
      !C3 || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), d9e ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        subtree: !0
      })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0);
    }, i.prototype.disconnect_ = function() {
      !C3 || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
    }, i.prototype.onTransitionEnd_ = function(e) {
      var r = e.propertyName, s = r === void 0 ? "" : r, l = f9e.some(function(c) {
        return !!~s.indexOf(c);
      });
      l && this.refresh();
    }, i.getInstance = function() {
      return this.instance_ || (this.instance_ = new i()), this.instance_;
    }, i.instance_ = null, i;
  }()
), W9 = function(i, e) {
  for (var r = 0, s = Object.keys(e); r < s.length; r++) {
    var l = s[r];
    Object.defineProperty(i, l, {
      value: e[l],
      enumerable: !1,
      writable: !1,
      configurable: !0
    });
  }
  return i;
}, kp = function(i) {
  var e = i && i.ownerDocument && i.ownerDocument.defaultView;
  return e || Rx;
}, $9 = Qx(0, 0, 0, 0);
function Dx(i) {
  return parseFloat(i) || 0;
}
function S5(i) {
  for (var e = [], r = 1; r < arguments.length; r++)
    e[r - 1] = arguments[r];
  return e.reduce(function(s, l) {
    var c = i["border-" + l + "-width"];
    return s + Dx(c);
  }, 0);
}
function p9e(i) {
  for (var e = ["top", "right", "bottom", "left"], r = {}, s = 0, l = e; s < l.length; s++) {
    var c = l[s], f = i["padding-" + c];
    r[c] = Dx(f);
  }
  return r;
}
function v9e(i) {
  var e = i.getBBox();
  return Qx(0, 0, e.width, e.height);
}
function m9e(i) {
  var e = i.clientWidth, r = i.clientHeight;
  if (!e && !r)
    return $9;
  var s = kp(i).getComputedStyle(i), l = p9e(s), c = l.left + l.right, f = l.top + l.bottom, p = Dx(s.width), d = Dx(s.height);
  if (s.boxSizing === "border-box" && (Math.round(p + c) !== e && (p -= S5(s, "left", "right") + c), Math.round(d + f) !== r && (d -= S5(s, "top", "bottom") + f)), !y9e(i)) {
    var m = Math.round(p + c) - e, y = Math.round(d + f) - r;
    Math.abs(m) !== 1 && (p -= m), Math.abs(y) !== 1 && (d -= y);
  }
  return Qx(l.left, l.top, p, d);
}
var g9e = /* @__PURE__ */ function() {
  return typeof SVGGraphicsElement < "u" ? function(i) {
    return i instanceof kp(i).SVGGraphicsElement;
  } : function(i) {
    return i instanceof kp(i).SVGElement && typeof i.getBBox == "function";
  };
}();
function y9e(i) {
  return i === kp(i).document.documentElement;
}
function b9e(i) {
  return C3 ? g9e(i) ? v9e(i) : m9e(i) : $9;
}
function S9e(i) {
  var e = i.x, r = i.y, s = i.width, l = i.height, c = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object, f = Object.create(c.prototype);
  return W9(f, {
    x: e,
    y: r,
    width: s,
    height: l,
    top: r,
    right: e + s,
    bottom: l + r,
    left: e
  }), f;
}
function Qx(i, e, r, s) {
  return { x: i, y: e, width: r, height: s };
}
var w9e = (
  /** @class */
  function() {
    function i(e) {
      this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = Qx(0, 0, 0, 0), this.target = e;
    }
    return i.prototype.isActive = function() {
      var e = b9e(this.target);
      return this.contentRect_ = e, e.width !== this.broadcastWidth || e.height !== this.broadcastHeight;
    }, i.prototype.broadcastRect = function() {
      var e = this.contentRect_;
      return this.broadcastWidth = e.width, this.broadcastHeight = e.height, e;
    }, i;
  }()
), x9e = (
  /** @class */
  /* @__PURE__ */ function() {
    function i(e, r) {
      var s = S9e(r);
      W9(this, { target: e, contentRect: s });
    }
    return i;
  }()
), k9e = (
  /** @class */
  function() {
    function i(e, r, s) {
      if (this.activeObservations_ = [], this.observations_ = new j9(), typeof e != "function")
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      this.callback_ = e, this.controller_ = r, this.callbackCtx_ = s;
    }
    return i.prototype.observe = function(e) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(e instanceof kp(e).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var r = this.observations_;
        r.has(e) || (r.set(e, new w9e(e)), this.controller_.addObserver(this), this.controller_.refresh());
      }
    }, i.prototype.unobserve = function(e) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(e instanceof kp(e).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var r = this.observations_;
        r.has(e) && (r.delete(e), r.size || this.controller_.removeObserver(this));
      }
    }, i.prototype.disconnect = function() {
      this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
    }, i.prototype.gatherActive = function() {
      var e = this;
      this.clearActive(), this.observations_.forEach(function(r) {
        r.isActive() && e.activeObservations_.push(r);
      });
    }, i.prototype.broadcastActive = function() {
      if (this.hasActive()) {
        var e = this.callbackCtx_, r = this.activeObservations_.map(function(s) {
          return new x9e(s.target, s.broadcastRect());
        });
        this.callback_.call(e, r, e), this.clearActive();
      }
    }, i.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    }, i.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    }, i;
  }()
), U9 = typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : new j9(), V9 = (
  /** @class */
  /* @__PURE__ */ function() {
    function i(e) {
      if (!(this instanceof i))
        throw new TypeError("Cannot call a class as a function.");
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      var r = h9e.getInstance(), s = new k9e(e, r, this);
      U9.set(this, s);
    }
    return i;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(i) {
  V9.prototype[i] = function() {
    var e;
    return (e = U9.get(this))[i].apply(e, arguments);
  };
});
var O9e = function() {
  return typeof Rx.ResizeObserver < "u" ? Rx.ResizeObserver : V9;
}(), C9e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return e.prototype.execCommand = function(r) {
      var s = Fs(r.target, "li");
      this.props.execCommand("heading", {
        level: Number(s.getAttribute("data-level"))
      });
    }, e.prototype.render = function() {
      var r = this;
      return Xr(x5 || (x5 = Kr([`
      <ul
        onClick=`, `
        aria-role="menu"
        aria-label="`, `"
      >
        `, `
        <li data-type="Paragraph" aria-role="menuitem">
          <div>`, `</div>
        </li>
      </ul>
    `], [
        `
      <ul
        onClick=`,
        `
        aria-role="menu"
        aria-label="`,
        `"
      >
        `,
        `
        <li data-type="Paragraph" aria-role="menuitem">
          <div>`,
        `</div>
        </li>
      </ul>
    `
      ])), function(s) {
        return r.execCommand(s);
      }, Mr.get("Headings"), [1, 2, 3, 4, 5, 6].map(function(s) {
        return Xr(w5 || (w5 = Kr([`
              <li data-level="`, `" data-type="Heading" aria-role="menuitem">
                <`, ">", " ", `</$>
              </li>
            `], [`
              <li data-level="`, `" data-type="Heading" aria-role="menuitem">
                <`, ">", " ", `</$>
              </li>
            `])), s, "h" + s, Mr.get("Heading"), s);
      }), Mr.get("Paragraph"));
    }, e;
  }(ea)
), w5, x5, G9 = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return e.prototype.toggleTab = function(r, s) {
      this.props.onClick(r, s);
    }, e.prototype.render = function() {
      var r = this;
      return Xr(O5 || (O5 = Kr([`
      <div class="`, `" aria-role="tabpanel">
        `, `
      </div>
    `], [
        `
      <div class="`,
        `" aria-role="tabpanel">
        `,
        `
      </div>
    `
      ])), vr("tabs"), this.props.tabs.map(function(s) {
        var l = s.name, c = s.text, f = r.props.activeTab === l;
        return Xr(k5 || (k5 = Kr([`
            <div
              class="tab-item`, `"
              onClick=`, `
              aria-role="tab"
              aria-label="`, `"
              aria-selected="`, `"
              tabindex="`, `"
            >
              `, `
            </div>
          `], [`
            <div
              class="tab-item`, `"
              onClick=`, `
              aria-role="tab"
              aria-label="`, `"
              aria-selected="`, `"
              tabindex="`, `"
            >
              `, `
            </div>
          `])), f ? " active" : "", function(p) {
          return r.toggleTab(p, l);
        }, Mr.get(c), f ? "true" : "false", f ? "0" : "-1", Mr.get(c));
      }));
    }, e;
  }(ea)
), k5, O5, T9e = "ui", A9e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e(r) {
      var s = i.call(this, r) || this;
      return s.initialize = function(l) {
        l === void 0 && (l = "file");
        var c = s.refs.url;
        c.value = "", s.refs.altText.value = "", s.refs.file.value = "", fs(c, "wrong"), s.setState({ activeTab: l, file: null, fileNameElClassName: "" });
      }, s.execCommand = function() {
        s.state.activeTab === "file" ? s.emitAddImageBlob() : s.emitAddImage();
      }, s.toggleTab = function(l, c) {
        c !== s.state.activeTab && s.initialize(c);
      }, s.showFileSelectBox = function() {
        s.refs.file.click();
      }, s.changeFile = function(l) {
        var c = l.target.files;
        c != null && c.length && s.setState({ file: c[0] });
      }, s.state = { activeTab: "file", file: null, fileNameElClassName: "" }, s.tabs = [
        { name: "file", text: "File" },
        { name: "url", text: "URL" }
      ], s;
    }
    return e.prototype.emitAddImageBlob = function() {
      var r = this, s = this.refs.file.files, l = this.refs.altText, c = " wrong";
      if (s != null && s.length) {
        c = "";
        var f = s.item(0), p = function(d, m) {
          return r.props.execCommand("addImage", { imageUrl: d, altText: m || l.value });
        };
        this.props.eventEmitter.emit("addImageBlobHook", f, p, T9e);
      }
      this.setState({ fileNameElClassName: c });
    }, e.prototype.emitAddImage = function() {
      var r = this.refs.url, s = this.refs.altText, l = r.value, c = s.value || "image";
      if (fs(r, "wrong"), !l.length) {
        Bs(r, "wrong");
        return;
      }
      l && this.props.execCommand("addImage", { imageUrl: l, altText: c });
    }, e.prototype.preventSelectStart = function(r) {
      r.preventDefault();
    }, e.prototype.updated = function() {
      this.props.show || this.initialize();
    }, e.prototype.render = function() {
      var r = this, s = this.state, l = s.activeTab, c = s.file, f = s.fileNameElClassName;
      return Xr(C5 || (C5 = Kr([`
      <div aria-label="`, `">
        <`, " tabs=", " activeTab=", " onClick=", ` />
        <div style="display:`, `">
          <label for="toastuiImageUrlInput">`, `</label>
          <input
            id="toastuiImageUrlInput"
            type="text"
            ref=`, `
          />
        </div>
        <div style="display:`, `;position: relative;">
          <label for="toastuiImageFileInput">`, `</label>
          <span
            class="`, "", `"
            onClick=`, `
            onSelectstart=`, `
          >
            `, `
          </span>
          <button
            type="button"
            class="`, `"
            onClick=`, `
          >
            `, `
          </button>
          <input
            id="toastuiImageFileInput"
            type="file"
            accept="image/*"
            onChange=`, `
            ref=`, `
          />
        </div>
        <label for="toastuiAltTextInput">`, `</label>
        <input
          id="toastuiAltTextInput"
          type="text"
          ref=`, `
        />
        <div class="`, `">
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
        </div>
      </div>
    `], [`
      <div aria-label="`, `">
        <`, " tabs=", " activeTab=", " onClick=", ` />
        <div style="display:`, `">
          <label for="toastuiImageUrlInput">`, `</label>
          <input
            id="toastuiImageUrlInput"
            type="text"
            ref=`, `
          />
        </div>
        <div style="display:`, `;position: relative;">
          <label for="toastuiImageFileInput">`, `</label>
          <span
            class="`, "", `"
            onClick=`, `
            onSelectstart=`, `
          >
            `, `
          </span>
          <button
            type="button"
            class="`, `"
            onClick=`, `
          >
            `, `
          </button>
          <input
            id="toastuiImageFileInput"
            type="file"
            accept="image/*"
            onChange=`, `
            ref=`, `
          />
        </div>
        <label for="toastuiAltTextInput">`, `</label>
        <input
          id="toastuiAltTextInput"
          type="text"
          ref=`, `
        />
        <div class="`, `">
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
        </div>
      </div>
    `])), Mr.get("Insert image"), G9, this.tabs, l, this.toggleTab, l === "url" ? "block" : "none", Mr.get("Image URL"), function(p) {
        return r.refs.url = p;
      }, l === "file" ? "block" : "none", Mr.get("Select image file"), vr("file-name"), c ? " has-file" : f, this.showFileSelectBox, this.preventSelectStart, c ? c.name : Mr.get("No file"), vr("file-select-button"), this.showFileSelectBox, Mr.get("Choose a file"), this.changeFile, function(p) {
        return r.refs.file = p;
      }, Mr.get("Description"), function(p) {
        return r.refs.altText = p;
      }, vr("button-container"), vr("close-button"), this.props.hidePopup, Mr.get("Cancel"), vr("ok-button"), this.execCommand, Mr.get("OK"));
    }, e;
  }(ea)
), C5, E9e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      var r = i !== null && i.apply(this, arguments) || this;
      return r.execCommand = function() {
        var s = r.refs.url, l = r.refs.text;
        if (fs(s, "wrong"), fs(l, "wrong"), s.value.length < 1) {
          Bs(s, "wrong");
          return;
        }
        var c = vs(r.props.initialValues.linkUrl);
        if (c && l.value.length < 1) {
          Bs(l, "wrong");
          return;
        }
        r.props.execCommand("addLink", {
          linkUrl: s.value,
          linkText: l.value
        });
      }, r;
    }
    return e.prototype.initialize = function() {
      var r = this.props.initialValues, s = r.linkUrl, l = r.linkText, c = this.refs.url, f = this.refs.text;
      fs(c, "wrong"), fs(f, "wrong", "disabled"), f.removeAttribute("disabled"), s && (Bs(f, "disabled"), f.setAttribute("disabled", "disabled")), c.value = s || "", f.value = l || "";
    }, e.prototype.mounted = function() {
      this.initialize();
    }, e.prototype.updated = function(r) {
      !r.show && this.props.show && this.initialize();
    }, e.prototype.render = function() {
      var r = this;
      return Xr(T5 || (T5 = Kr([`
      <div aria-label="`, `">
        <label for="toastuiLinkUrlInput">`, `</label>
        <input
          id="toastuiLinkUrlInput"
          type="text"
          ref=`, `
        />
        <label for="toastuiLinkTextInput">`, `</label>
        <input
          id="toastuiLinkTextInput"
          type="text"
          ref=`, `
        />
        <div class="`, `">
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
        </div>
      </div>
    `], [`
      <div aria-label="`, `">
        <label for="toastuiLinkUrlInput">`, `</label>
        <input
          id="toastuiLinkUrlInput"
          type="text"
          ref=`, `
        />
        <label for="toastuiLinkTextInput">`, `</label>
        <input
          id="toastuiLinkTextInput"
          type="text"
          ref=`, `
        />
        <div class="`, `">
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
          <button type="button" class="`, '" onClick=', `>
            `, `
          </button>
        </div>
      </div>
    `])), Mr.get("Insert link"), Mr.get("URL"), function(s) {
        return r.refs.url = s;
      }, Mr.get("Link text"), function(s) {
        return r.refs.text = s;
      }, vr("button-container"), vr("close-button"), this.props.hidePopup, Mr.get("Cancel"), vr("ok-button"), this.execCommand, Mr.get("OK"));
    }, e;
  }(ea)
), T5, A5 = 20, E5 = 20, M5 = 5, R5 = 14, D5 = 5, P5 = 9, M9e = 1, R9e = 1, L5 = 1, D9e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e(r) {
      var s = i.call(this, r) || this;
      return s.extendSelectionRange = function(l) {
        var c = l.pageX, f = l.pageY, p = c - s.offsetRect.left, d = f - s.offsetRect.top, m = s.getSelectionRangeByOffset(p, d);
        s.setState(Nt({}, m));
      }, s.execCommand = function() {
        s.props.execCommand("addTable", {
          rowCount: s.state.rowIdx + 1,
          columnCount: s.state.colIdx + 1
        });
      }, s.state = {
        rowIdx: -1,
        colIdx: -1
      }, s;
    }
    return e.prototype.getDescription = function() {
      return this.state.colIdx === -1 ? "" : this.state.colIdx + 1 + " x " + (this.state.rowIdx + 1);
    }, e.prototype.getBoundByRange = function(r, s) {
      return {
        width: (r + 1) * A5,
        height: (s + 1) * E5
      };
    }, e.prototype.getRangeByOffset = function(r, s) {
      return {
        colIdx: Math.floor(r / A5),
        rowIdx: Math.floor(s / E5)
      };
    }, e.prototype.getTableRange = function() {
      var r = this.state, s = r.colIdx, l = r.rowIdx, c = Math.max(s, D5), f = Math.max(l, M5);
      return s >= D5 && c < P5 && (c += 1), l >= M5 && f < R5 && (f += 1), { colIdx: c + 1, rowIdx: f + 1 };
    }, e.prototype.getSelectionAreaBound = function() {
      var r = this.getBoundByRange(this.state.colIdx, this.state.rowIdx), s = r.width, l = r.height;
      return !s && !l ? { display: "none" } : { width: s - L5, height: l - L5, display: "block" };
    }, e.prototype.getSelectionRangeByOffset = function(r, s) {
      var l = this.getRangeByOffset(r, s);
      return l.rowIdx = Math.min(Math.max(l.rowIdx, M9e), R5), l.colIdx = Math.min(Math.max(l.colIdx, R9e), P5), l;
    }, e.prototype.updated = function() {
      if (!this.props.show)
        this.setState({ colIdx: -1, rowIdx: -1 });
      else if (this.state.colIdx === -1 && this.state.rowIdx === -1) {
        var r = this.refs.tableEl.getBoundingClientRect(), s = r.left, l = r.top;
        this.offsetRect = {
          left: window.pageXOffset + s,
          top: window.pageYOffset + l
        };
      }
    }, e.prototype.createTableArea = function(r) {
      for (var s = r.colIdx, l = r.rowIdx, c = [], f = 0; f < l; f += 1) {
        for (var p = [], d = 0; d < s; d += 1) {
          var m = "" + vr("table-cell") + (f > 0 ? "" : " header");
          p.push(Xr(I5 || (I5 = Kr(['<div class="', '"></div>'], ['<div class="', '"></div>'])), m));
        }
        c.push(Xr(_5 || (_5 = Kr(['<div class="', '">', "</div>"], ['<div class="', '">', "</div>"])), vr("table-row"), p));
      }
      return Xr(N5 || (N5 = Kr(['<div class="', '">', "</div>"], ['<div class="', '">', "</div>"])), vr("table"), c);
    }, e.prototype.render = function() {
      var r = this, s = this.getTableRange(), l = this.getSelectionAreaBound();
      return Xr(B5 || (B5 = Kr([`
      <div aria-label="`, `">
        <div
          class="`, `"
          ref=`, `
          onMousemove=`, `
          onClick=`, `
        >
          `, `
          <div class="`, '" style=', `></div>
        </div>
        <p class="`, '">', `</p>
      </div>
    `], [`
      <div aria-label="`, `">
        <div
          class="`, `"
          ref=`, `
          onMousemove=`, `
          onClick=`, `
        >
          `, `
          <div class="`, '" style=', `></div>
        </div>
        <p class="`, '">', `</p>
      </div>
    `])), Mr.get("Insert table"), vr("table-selection"), function(c) {
        return r.refs.tableEl = c;
      }, this.extendSelectionRange, this.execCommand, this.createTableArea(s), vr("table-selection-layer"), l, vr("table-description"), this.getDescription());
    }, e;
  }(ea)
), I5, _5, N5, B5, P9e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return e.prototype.mounted = function() {
      this.refs.el.appendChild(this.props.body);
    }, e.prototype.updated = function(r) {
      this.refs.el.replaceChild(this.props.body, r.body);
    }, e.prototype.render = function() {
      var r = this;
      return Xr(F5 || (F5 = Kr(["<div ref=", "></div>"], ["<div ref=", "></div>"])), function(s) {
        return r.refs.el = s;
      });
    }, e;
  }(ea)
), F5;
function T3(i) {
  return Tl(i) ? I9e(i) : i;
}
function L9e() {
  var i = document.createElement("label"), e = document.createElement("input"), r = document.createElement("span");
  i.className = "scroll-sync active", e.type = "checkbox", e.checked = !0, r.className = "switch";
  var s = function(l) {
    return e.addEventListener("change", function(c) {
      var f = c.target.checked;
      f ? Bs(i, "active") : fs(i, "active"), l("toggleScrollSync", { active: f });
    });
  };
  return i.appendChild(e), i.appendChild(r), {
    name: "scrollSync",
    el: i,
    onMounted: s
  };
}
function I9e(i) {
  var e;
  switch (i) {
    case "heading":
      e = {
        name: "heading",
        className: "heading",
        tooltip: Mr.get("Headings"),
        state: "heading"
      };
      break;
    case "bold":
      e = {
        name: "bold",
        className: "bold",
        command: "bold",
        tooltip: Mr.get("Bold"),
        state: "strong"
      };
      break;
    case "italic":
      e = {
        name: "italic",
        className: "italic",
        command: "italic",
        tooltip: Mr.get("Italic"),
        state: "emph"
      };
      break;
    case "strike":
      e = {
        name: "strike",
        className: "strike",
        command: "strike",
        tooltip: Mr.get("Strike"),
        state: "strike"
      };
      break;
    case "hr":
      e = {
        name: "hr",
        className: "hrline",
        command: "hr",
        tooltip: Mr.get("Line"),
        state: "thematicBreak"
      };
      break;
    case "quote":
      e = {
        name: "quote",
        className: "quote",
        command: "blockQuote",
        tooltip: Mr.get("Blockquote"),
        state: "blockQuote"
      };
      break;
    case "ul":
      e = {
        name: "ul",
        className: "bullet-list",
        command: "bulletList",
        tooltip: Mr.get("Unordered list"),
        state: "bulletList"
      };
      break;
    case "ol":
      e = {
        name: "ol",
        className: "ordered-list",
        command: "orderedList",
        tooltip: Mr.get("Ordered list"),
        state: "orderedList"
      };
      break;
    case "task":
      e = {
        name: "task",
        className: "task-list",
        command: "taskList",
        tooltip: Mr.get("Task"),
        state: "taskList"
      };
      break;
    case "table":
      e = {
        name: "table",
        className: "table",
        tooltip: Mr.get("Insert table"),
        state: "table"
      };
      break;
    case "image":
      e = {
        name: "image",
        className: "image",
        tooltip: Mr.get("Insert image")
      };
      break;
    case "link":
      e = {
        name: "link",
        className: "link",
        tooltip: Mr.get("Insert link")
      };
      break;
    case "code":
      e = {
        name: "code",
        className: "code",
        command: "code",
        tooltip: Mr.get("Code"),
        state: "code"
      };
      break;
    case "codeblock":
      e = {
        name: "codeblock",
        className: "codeblock",
        command: "codeBlock",
        tooltip: Mr.get("Insert CodeBlock"),
        state: "codeBlock"
      };
      break;
    case "indent":
      e = {
        name: "indent",
        className: "indent",
        command: "indent",
        tooltip: Mr.get("Indent"),
        state: "indent"
      };
      break;
    case "outdent":
      e = {
        name: "outdent",
        className: "outdent",
        command: "outdent",
        tooltip: Mr.get("Outdent"),
        state: "outdent"
      };
      break;
    case "scrollSync":
      e = L9e();
      break;
    case "more":
      e = {
        name: "more",
        className: "more",
        tooltip: Mr.get("More")
      };
      break;
  }
  return e.name !== "scrollSync" && (e.className += " " + vr("toolbar-icons")), e;
}
function wW(i, e) {
  var r = e.el, s = e.pos, l = e.popup, c = e.initialValues;
  switch (i) {
    case "heading":
      return {
        render: function(f) {
          return Xr(z5 || (z5 = Kr(["<", " ...", " />"], ["<", " ...", " />"])), C9e, f);
        },
        className: vr("popup-add-heading"),
        fromEl: r,
        pos: s
      };
    case "link":
      return {
        render: function(f) {
          return Xr(H5 || (H5 = Kr(["<", " ...", " />"], ["<", " ...", " />"])), E9e, f);
        },
        className: vr("popup-add-link"),
        fromEl: r,
        pos: s,
        initialValues: c
      };
    case "image":
      return {
        render: function(f) {
          return Xr(j5 || (j5 = Kr(["<", " ...", " />"], ["<", " ...", " />"])), A9e, f);
        },
        className: vr("popup-add-image"),
        fromEl: r,
        pos: s
      };
    case "table":
      return {
        render: function(f) {
          return Xr(W5 || (W5 = Kr(["<", " ...", " />"], ["<", " ...", " />"])), D9e, f);
        },
        className: vr("popup-add-table"),
        fromEl: r,
        pos: s
      };
    case "customPopupBody":
      return l ? Nt({ render: function(f) {
        return Xr($5 || ($5 = Kr(["<", " ...", " body=", " />"], ["<", " ...", " body=", " />"])), P9e, f, l.body);
      }, fromEl: r, pos: s }, l) : null;
    default:
      return null;
  }
}
function Px(i) {
  i.hidden = i.length === i.filter(function(e) {
    return e.hidden;
  }).length;
}
function _9e(i, e) {
  var r = function(s) {
    return s.hidden = s.name === "scrollSync" && e, s;
  };
  return i.reduce(function(s, l) {
    s.push(l.map(function(f) {
      return r(T3(f));
    }));
    var c = s[(s.length || 1) - 1];
    return c && Px(c), s;
  }, []);
}
function N9e(i, e) {
  i.forEach(function(r) {
    r.forEach(function(s) {
      return s.hidden = s.name === "scrollSync" && e;
    }), Px(r);
  });
}
var z5, H5, j5, W5, $5, B9e = 20, F9e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      var r = i !== null && i.apply(this, arguments) || this;
      return r.handleMousedown = function(s) {
        !Fs(s.target, "." + vr("popup")) && !Fs(s.target, r.props.info.fromEl) && r.props.hidePopup();
      }, r;
    }
    return e.prototype.mounted = function() {
      document.addEventListener("mousedown", this.handleMousedown), this.props.eventEmitter.listen("closePopup", this.props.hidePopup);
    }, e.prototype.beforeDestroy = function() {
      document.removeEventListener("mousedown", this.handleMousedown);
    }, e.prototype.updated = function(r) {
      var s = this.props, l = s.show, c = s.info;
      if (l && c.pos && r.show !== l) {
        var f = Nt({}, c.pos), p = this.refs.el.offsetWidth, d = Fs(this.refs.el, "." + vr("toolbar")), m = d.offsetWidth;
        f.left + p >= m && (f.left = m - p - B9e), q3(this.state.popupPos, f) || this.setState({ popupPos: f });
      }
    }, e.prototype.render = function() {
      var r = this, s = this.props, l = s.info, c = s.show, f = s.hidePopup, p = s.eventEmitter, d = s.execCommand, m = l || {}, y = m.className, S = y === void 0 ? "" : y, x = m.style, w = m.render, k = m.initialValues, O = k === void 0 ? {} : k, T = Nt(Nt({ display: c ? "block" : "none" }, x), this.state.popupPos);
      return Xr(U5 || (U5 = Kr([`
      <div
        class="`, " ", `"
        style=`, `
        ref=`, `
        aria-role="dialog"
      >
        <div class="`, `">
          `, `
        </div>
      </div>
    `], [`
      <div
        class="`, " ", `"
        style=`, `
        ref=`, `
        aria-role="dialog"
      >
        <div class="`, `">
          `, `
        </div>
      </div>
    `])), vr("popup"), S, T, function(L) {
        return r.refs.el = L;
      }, vr("popup-body"), w && w({ eventEmitter: p, show: c, hidePopup: f, execCommand: d, initialValues: O }));
    }, e;
  }(ea)
), U5, V5 = 6;
function xW(i) {
  return (
    /** @class */
    function(e) {
      pr(r, e);
      function r(s) {
        var l = e.call(this, s) || this;
        return l.showTooltip = function(c) {
          var f = l.props.item.tooltip;
          if (!l.props.disabled && f) {
            var p = l.getBound(c), d = p.left + V5 + "px", m = p.top + V5 + "px";
            js(l.props.tooltipRef.current, { display: "block", left: d, top: m }), l.props.tooltipRef.current.querySelector(".text").textContent = f;
          }
        }, l.hideTooltip = function() {
          js(l.props.tooltipRef.current, "display", "none");
        }, l.state = { active: !1, disabled: s.disabled }, l.addEvent(), l;
      }
      return r.prototype.addEvent = function() {
        var s = this, l = this.props, c = l.item, f = l.eventEmitter;
        c.state && f.listen("changeToolbarState", function(p) {
          var d, m = p.toolbarState, y = (d = m[c.state]) !== null && d !== void 0 ? d : {}, S = y.active, x = y.disabled;
          s.setState({ active: !!S, disabled: x ?? s.props.disabled });
        });
      }, r.prototype.getBound = function(s) {
        var l = d4(s, Fs(s, "." + vr("toolbar"))), c = l.offsetLeft, f = l.offsetTop;
        return { left: c, top: s.offsetHeight + f };
      }, r.prototype.render = function() {
        return Xr(G5 || (G5 = Kr([`
        <`, `
          ...`, `
          active=`, `
          showTooltip=`, `
          hideTooltip=`, `
          getBound=`, `
          disabled=`, `
        />
      `], [`
        <`, `
          ...`, `
          active=`, `
          showTooltip=`, `
          hideTooltip=`, `
          getBound=`, `
          disabled=`, `
        />
      `])), i, this.props, this.state.active, this.showTooltip, this.hideTooltip, this.getBound, this.state.disabled || this.props.disabled);
      }, r;
    }(ea)
  );
}
var G5, z9e = 80, H9e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      var r = i !== null && i.apply(this, arguments) || this;
      return r.showTooltip = function() {
        r.props.showTooltip(r.refs.el);
      }, r.execCommand = function() {
        var s = r.props, l = s.item, c = s.execCommand, f = s.setPopupInfo, p = s.getBound, d = s.eventEmitter, m = l.command, y = l.name, S = l.popup;
        if (m)
          c(m);
        else {
          var x = S ? "customPopupBody" : y, w = d.emit("query", "getPopupInitialValues", { popupName: x })[0], k = wW(x, {
            el: r.refs.el,
            pos: p(r.refs.el),
            popup: S,
            initialValues: w
          });
          k && f(k);
        }
      }, r;
    }
    return e.prototype.mounted = function() {
      this.setItemWidth();
    }, e.prototype.updated = function(r) {
      r.item.name !== this.props.item.name && this.setItemWidth();
    }, e.prototype.setItemWidth = function() {
      var r = this.props, s = r.setItemWidth, l = r.item;
      s && s(l.name, nW(this.refs.el) + (l.hidden ? z9e : 0));
    }, e.prototype.render = function() {
      var r = this, s = this.props, l = s.hideTooltip, c = s.disabled, f = s.item, p = s.active, d = Nt({ display: f.hidden ? "none" : null }, f.style), m = "" + (f.className || "") + (p ? " active" : "");
      return Xr(Y5 || (Y5 = Kr([`
      <button
        ref=`, `
        type="button"
        style=`, `
        class=`, `
        onClick=`, `
        onMouseover=`, `
        onMouseout=`, `
        disabled=`, `
        aria-label=`, `
      >
        `, `
      </button>
    `], [`
      <button
        ref=`, `
        type="button"
        style=`, `
        class=`, `
        onClick=`, `
        onMouseover=`, `
        onMouseout=`, `
        disabled=`, `
        aria-label=`, `
      >
        `, `
      </button>
    `])), function(y) {
        return r.refs.el = y;
      }, d, m, this.execCommand, this.showTooltip, l, !!c, f.text || f.tooltip || "", f.text || "");
    }, e;
  }(ea)
), j9e = xW(H9e), Y5, W9e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      var r = i !== null && i.apply(this, arguments) || this;
      return r.showTooltip = function() {
        r.props.showTooltip(r.refs.el);
      }, r.showPopup = function() {
        var s = wW("customPopupBody", {
          el: r.refs.el,
          pos: r.props.getBound(r.refs.el),
          popup: r.props.item.popup
        });
        s && r.props.setPopupInfo(s);
      }, r;
    }
    return e.prototype.mounted = function() {
      var r = this.props, s = r.setItemWidth, l = r.item;
      this.refs.el.appendChild(l.el), s && s(l.name, nW(this.refs.el)), l.onMounted && l.onMounted(this.props.execCommand);
    }, e.prototype.updated = function(r) {
      var s, l = this.props, c = l.item, f = l.active, p = l.disabled;
      (r.active !== f || r.disabled !== p) && ((s = c.onUpdated) === null || s === void 0 || s.call(c, { active: f, disabled: p }));
    }, e.prototype.render = function() {
      var r = this, s = this.props, l = s.disabled, c = s.item, f = { display: c.hidden ? "none" : "inline-block" }, p = function(d) {
        return l ? null : d;
      };
      return Xr(q5 || (q5 = Kr([`
      <div
        ref=`, `
        style=`, `
        class=`, `
        onClick=`, `
        onMouseover=`, `
        onMouseout=`, `
      ></div>
    `], [`
      <div
        ref=`, `
        style=`, `
        class=`, `
        onClick=`, `
        onMouseover=`, `
        onMouseout=`, `
      ></div>
    `])), function(d) {
        return r.refs.el = d;
      }, f, vr("toolbar-item-wrapper"), p(this.showPopup), p(this.showTooltip), p(this.props.hideTooltip));
    }, e;
  }(ea)
), $9e = xW(W9e), q5, Y9 = (
  /** @class */
  function(i) {
    pr(e, i);
    function e() {
      return i !== null && i.apply(this, arguments) || this;
    }
    return e.prototype.render = function() {
      var r = this, s = this.props, l = s.group, c = s.hiddenDivider, f = l.hidden ? { display: "none" } : null, p = c ? { display: "none" } : null;
      return Xr(X5 || (X5 = Kr([`
      <div class="`, '" style=', `>
        `, `
        <div class="`, '" style=', `></div>
      </div>
    `], [
        `
      <div class="`,
        '" style=',
        `>
        `,
        `
        <div class="`,
        '" style=',
        `></div>
      </div>
    `
      ])), vr("toolbar-group"), f, l.map(function(d) {
        var m = d.el ? $9e : j9e;
        return Xr(K5 || (K5 = Kr(["<", " key=", " ...", " item=", " />"], ["<", " key=", " ...", " item=", " />"])), m, d.name, r.props, d);
      }), vr("toolbar-divider"), p);
    }, e;
  }(ea)
), K5, X5, U9e = 4, V9e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e(r) {
      var s = i.call(this, r) || this;
      return s.handleClickDocument = function(l) {
        var c = l.target;
        !Fs(c, "." + vr("dropdown-toolbar")) && !Fs(c, ".more") && s.setState({ showDropdown: !1, dropdownPos: null });
      }, s.showTooltip = function() {
        s.props.showTooltip(s.refs.el);
      }, s.state = { showDropdown: !1, dropdownPos: null }, s;
    }
    return e.prototype.getBound = function() {
      var r = this.props.getBound(this.refs.el);
      return r.top += U9e, Nt(Nt({}, r), { left: null, right: 10 });
    }, e.prototype.mounted = function() {
      document.addEventListener("click", this.handleClickDocument);
    }, e.prototype.updated = function() {
      this.state.showDropdown && !this.state.dropdownPos && this.setState({ dropdownPos: this.getBound() });
    }, e.prototype.beforeDestroy = function() {
      document.removeEventListener("click", this.handleClickDocument);
    }, e.prototype.render = function() {
      var r = this, s = this.state, l = s.showDropdown, c = s.dropdownPos, f = this.props, p = f.disabled, d = f.item, m = f.items, y = f.hideTooltip, S = m.filter(function(k) {
        return !k.hidden;
      }), x = S.length ? null : { display: "none" }, w = l ? null : { display: "none" };
      return Xr(Z5 || (Z5 = Kr([`
      <div class="`, '" style=', `>
        <button
          ref=`, `
          type="button"
          class=`, `
          onClick=`, `
          onMouseover=`, `
          onMouseout=`, `
          disabled=`, `
        ></button>
        <div
          class="`, `"
          style=`, `
          ref=`, `
        >
          `, `
        </div>
      </div>
    `], [
        `
      <div class="`,
        '" style=',
        `>
        <button
          ref=`,
        `
          type="button"
          class=`,
        `
          onClick=`,
        `
          onMouseover=`,
        `
          onMouseout=`,
        `
          disabled=`,
        `
        ></button>
        <div
          class="`,
        `"
          style=`,
        `
          ref=`,
        `
        >
          `,
        `
        </div>
      </div>
    `
      ])), vr("toolbar-group"), x, function(k) {
        return r.refs.el = k;
      }, d.className, function() {
        return r.setState({ showDropdown: !0 });
      }, this.showTooltip, y, p, vr("dropdown-toolbar"), Nt(Nt({}, w), c), function(k) {
        return r.refs.dropdownEl = k;
      }, S.length ? S.map(function(k, O) {
        var T;
        return Xr(J5 || (J5 = Kr([`
                  <`, `
                    group=`, `
                    hiddenDivider=`, `
                    ...`, `
                  />
                `], [
          `
                  <`,
          `
                    group=`,
          `
                    hiddenDivider=`,
          `
                    ...`,
          `
                  />
                `
        ])), Y9, k, O === S.length - 1 || ((T = S[O + 1]) === null || T === void 0 ? void 0 : T.hidden), r.props);
      }) : null);
    }, e;
  }(ea)
), G9e = xW(V9e), J5, Z5, Y9e = 50, q9e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e(r) {
      var s = i.call(this, r) || this;
      return s.toggleTab = function(l, c) {
        var f = s.props.eventEmitter;
        if (s.state.activeTab !== c) {
          var p = c === "write" ? "changePreviewTabWrite" : "changePreviewTabPreview";
          f.emit(p), s.setState({ activeTab: c });
        }
      }, s.setItemWidth = function(l, c) {
        s.itemWidthMap[l] = c;
      }, s.setPopupInfo = function(l) {
        s.setState({ showPopup: !0, popupInfo: l });
      }, s.openPopup = function(l, c) {
        c === void 0 && (c = {});
        var f = s.refs.el.querySelector("." + vr("toolbar-group") + " ." + l);
        if (f) {
          var p = d4(f, Fs(f, "." + vr("toolbar"))), d = p.offsetLeft, m = p.offsetTop, y = wW(l, {
            el: f,
            pos: { left: d, top: f.offsetHeight + m },
            initialValues: c
          });
          y && s.setPopupInfo(y);
        }
      }, s.hidePopup = function() {
        s.state.showPopup && s.setState({ showPopup: !1 });
      }, s.execCommand = function(l, c) {
        var f = s.props.eventEmitter;
        f.emit("command", l, c), s.hidePopup();
      }, s.tabs = [
        { name: "write", text: "Write" },
        { name: "preview", text: "Preview" }
      ], s.itemWidthMap = {}, s.initialItems = _9e(r.toolbarItems || [], s.hiddenScrollSync()), s.state = {
        items: s.initialItems,
        dropdownItems: [],
        showPopup: !1,
        popupInfo: {},
        activeTab: "write"
      }, s.tooltipRef = { current: null }, s.resizeObserver = new O9e(function() {
        return s.handleResize();
      }), s.addEvent(), s;
    }
    return e.prototype.insertToolbarItem = function(r, s) {
      var l = r.groupIndex, c = r.itemIndex, f = this.initialItems[l];
      s = T3(s), f ? f.splice(c, 0, s) : this.initialItems.push([s]), this.setState(this.classifyToolbarItems());
    }, e.prototype.removeToolbarItem = function(r) {
      var s = this;
      vp(this.initialItems, function(l) {
        var c = !1;
        return vp(l, function(f, p) {
          return f.name === r ? (c = !0, l.splice(p, 1), s.setState(s.classifyToolbarItems()), !1) : !0;
        }), !c;
      });
    }, e.prototype.addEvent = function() {
      var r = this, s = this.props.eventEmitter;
      this.handleResize = o9e(function() {
        r.setState({ items: r.initialItems, dropdownItems: [] }), r.setState(r.classifyToolbarItems());
      }, 200), s.listen("openPopup", this.openPopup);
    }, e.prototype.appendTooltipToRoot = function() {
      var r = '<div class="' + vr("tooltip") + `" style="display:none">
        <div class="arrow"></div>
        <span class="text"></span>
      </div>`;
      this.tooltipRef.current = f4(r, this.refs.el);
    }, e.prototype.hiddenScrollSync = function() {
      return this.props.editorType === "wysiwyg" || this.props.previewStyle === "tab";
    }, e.prototype.movePrevItemToDropdownToolbar = function(r, s, l, c) {
      var f = function(d) {
        var m = d.pop();
        m && c.push(m);
      };
      if (r > 1)
        f(l);
      else {
        var p = Qi(s);
        p && f(p);
      }
    }, e.prototype.classifyToolbarItems = function() {
      var r = this, s = 0, l = this.refs.el.clientWidth, c = this.refs.el.querySelector("." + vr("toolbar-divider")), f = c ? nW(c) : 0, p = [], d = [], m = !1;
      return this.initialItems.forEach(function(y, S) {
        var x = [], w = [];
        y.forEach(function(k, O) {
          k.hidden || (s += r.itemWidthMap[k.name], s > l - Y9e ? (m || (r.movePrevItemToDropdownToolbar(O, p, x, w), m = !0), w.push(k)) : x.push(k));
        }), x.length && (Px(x), p.push(x)), w.length && (Px(w), d.push(w)), S < r.state.items.length - 1 && (s += f);
      }), { items: p, dropdownItems: d };
    }, e.prototype.mounted = function() {
      this.props.previewStyle === "tab" && this.props.eventEmitter.emit("changePreviewTabWrite", !0), this.setState(this.classifyToolbarItems()), this.appendTooltipToRoot(), this.resizeObserver.observe(this.refs.el);
    }, e.prototype.updated = function(r) {
      var s = this.props, l = s.editorType, c = s.previewStyle, f = s.eventEmitter, p = c !== r.previewStyle, d = l !== r.editorType;
      if (p || d) {
        N9e(this.initialItems, this.hiddenScrollSync());
        var m = this.classifyToolbarItems();
        (p || c === "tab" && l === "markdown") && (f.emit("changePreviewTabWrite"), m.activeTab = "write"), this.setState(m);
      }
    }, e.prototype.beforeDestroy = function() {
      window.removeEventListener("resize", this.handleResize), this.resizeObserver.disconnect(), Uc(this.tooltipRef.current);
    }, e.prototype.render = function() {
      var r = this, s = this.props, l = s.previewStyle, c = s.eventEmitter, f = s.editorType, p = this.state, d = p.popupInfo, m = p.showPopup, y = p.activeTab, S = p.items, x = p.dropdownItems, w = {
        eventEmitter: c,
        tooltipRef: this.tooltipRef,
        disabled: f === "markdown" && l === "tab" && y === "preview",
        execCommand: this.execCommand,
        setPopupInfo: this.setPopupInfo
      }, k = l === "tab" ? { borderTopLeftRadius: 0 } : null;
      return Xr(eV || (eV = Kr([`
      <div class="`, `">
        <div
          class="`, `"
          style="display: `, `"
        >
          <`, " tabs=", " activeTab=", " onClick=", ` />
        </div>
        <div
          class="`, `"
          ref=`, `
          style=`, `
        >
          `, `
          <`, `
            item=`, `
            items=`, `
            ...`, `
          />
        </div>
        <`, `
          info=`, `
          show=`, `
          eventEmitter=`, `
          hidePopup=`, `
          execCommand=`, `
        />
      </div>
    `], [
        `
      <div class="`,
        `">
        <div
          class="`,
        `"
          style="display: `,
        `"
        >
          <`,
        " tabs=",
        " activeTab=",
        " onClick=",
        ` />
        </div>
        <div
          class="`,
        `"
          ref=`,
        `
          style=`,
        `
        >
          `,
        `
          <`,
        `
            item=`,
        `
            items=`,
        `
            ...`,
        `
          />
        </div>
        <`,
        `
          info=`,
        `
          show=`,
        `
          eventEmitter=`,
        `
          hidePopup=`,
        `
          execCommand=`,
        `
        />
      </div>
    `
      ])), vr("toolbar"), vr("md-tab-container"), f === "wysiwyg" || l === "vertical" ? "none" : "block", G9, this.tabs, y, this.toggleTab, vr("defaultUI-toolbar"), function(O) {
        return r.refs.el = O;
      }, k, S.map(function(O, T) {
        var L;
        return Xr(Q5 || (Q5 = Kr([`
              <`, `
                group=`, `
                hiddenDivider=`, `
                setItemWidth=`, `
                ...`, `
              />
            `], [`
              <`, `
                group=`, `
                hiddenDivider=`, `
                setItemWidth=`, `
                ...`, `
              />
            `])), Y9, O, T === S.length - 1 || ((L = S[T + 1]) === null || L === void 0 ? void 0 : L.hidden), r.setItemWidth, w);
      }), G9e, T3("more"), x, w, F9e, d, m, c, this.hidePopup, this.execCommand);
    }, e;
  }(ea)
), Q5, eV, K9e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e(r) {
      var s = i.call(this, r) || this;
      return s.handleClickDocument = function(l) {
        Fs(l.target, "." + vr("context-menu")) || s.setState({ pos: null });
      }, s.state = {
        pos: null,
        menuGroups: []
      }, s.addEvent(), s;
    }
    return e.prototype.addEvent = function() {
      var r = this;
      this.props.eventEmitter.listen("contextmenu", function(s) {
        var l = s.pos, c = s.menuGroups;
        r.setState({ pos: l, menuGroups: c });
      });
    }, e.prototype.mounted = function() {
      document.addEventListener("click", this.handleClickDocument);
    }, e.prototype.beforeDestroy = function() {
      document.removeEventListener("click", this.handleClickDocument);
    }, e.prototype.getMenuGroupElements = function() {
      var r = this, s = this.state, l = s.pos, c = s.menuGroups;
      return l ? c.reduce(function(f, p) {
        var d = [];
        return p.forEach(function(m) {
          var y = m.label, S = m.className, x = S === void 0 ? !1 : S, w = m.disabled, k = m.onClick, O = function() {
            w || (k(), r.setState({ pos: null }));
          };
          d.push(Xr(tV || (tV = Kr([`
                <li
                  onClick=`, `
                  class="menu-item`, `"
                  aria-role="menuitem"
                >
                  <span class="`, '">', `</span>
                </li>
              `], [`
                <li
                  onClick=`, `
                  class="menu-item`, `"
                  aria-role="menuitem"
                >
                  <span class="`, '">', `</span>
                </li>
              `])), O, w ? " disabled" : "", x, y));
        }), f.push(Xr(rV || (rV = Kr([`<ul class="menu-group">
              `, `
            </ul>`], [`<ul class="menu-group">
              `, `
            </ul>`])), d)), f;
      }, []) : [];
    }, e.prototype.render = function() {
      var r = Nt({ display: this.state.pos ? "block" : "none" }, this.state.pos);
      return Xr(nV || (nV = Kr(['<div class="', '" style=', ` aria-role="menu">
      `, `
    </div>`], ['<div class="', '" style=', ` aria-role="menu">
      `, `
    </div>`])), vr("context-menu"), r, this.getMenuGroupElements());
    }, e;
  }(ea)
), tV, rV, nV, X9e = (
  /** @class */
  function(i) {
    pr(e, i);
    function e(r) {
      var s = i.call(this, r) || this;
      s.changeMode = function(f) {
        f !== s.state.editorType && s.setState({ editorType: f });
      }, s.changePreviewStyle = function(f) {
        f !== s.state.previewStyle && s.setState({ previewStyle: f });
      }, s.hide = function() {
        s.setState({ hide: !0 });
      }, s.show = function() {
        s.setState({ hide: !1 });
      };
      var l = r.editorType, c = r.previewStyle;
      return s.state = {
        editorType: l,
        previewStyle: c,
        hide: !1
      }, s.addEvent(), s;
    }
    return e.prototype.mounted = function() {
      var r = this.props.slots, s = r.wwEditor, l = r.mdEditor, c = r.mdPreview;
      this.refs.wwContainer.appendChild(s), this.refs.mdContainer.insertAdjacentElement("afterbegin", l), this.refs.mdContainer.appendChild(c);
    }, e.prototype.insertToolbarItem = function(r, s) {
      this.toolbar.insertToolbarItem(r, s);
    }, e.prototype.removeToolbarItem = function(r) {
      this.toolbar.removeToolbarItem(r);
    }, e.prototype.render = function() {
      var r = this, s = this.props, l = s.eventEmitter, c = s.hideModeSwitch, f = s.toolbarItems, p = s.theme, d = this.state, m = d.hide, y = d.previewStyle, S = d.editorType, x = m ? " hidden" : "", w = vr(S === "markdown" ? "md-mode" : "ww-mode"), k = vr("md") + "-" + y + "-style", O = vr([p !== "light", p + " "]);
      return Xr(aV || (aV = Kr([`
      <div
        class="`, "", "", `"
        ref=`, `
      >
        <`, `
          ref=`, `
          eventEmitter=`, `
          previewStyle=`, `
          toolbarItems=`, `
          editorType=`, `
        />
        <div
          class="`, " ", `"
          ref=`, `
        >
          <div class="`, `">
            <div
              class="`, " ", `"
              ref=`, `
            >
              <div class="`, `"></div>
            </div>
            <div
              class="`, `"
              ref=`, `
            />
          </div>
        </div>
        `, `
        <`, " eventEmitter=", ` />
      </div>
    `], [
        `
      <div
        class="`,
        "",
        "",
        `"
        ref=`,
        `
      >
        <`,
        `
          ref=`,
        `
          eventEmitter=`,
        `
          previewStyle=`,
        `
          toolbarItems=`,
        `
          editorType=`,
        `
        />
        <div
          class="`,
        " ",
        `"
          ref=`,
        `
        >
          <div class="`,
        `">
            <div
              class="`,
        " ",
        `"
              ref=`,
        `
            >
              <div class="`,
        `"></div>
            </div>
            <div
              class="`,
        `"
              ref=`,
        `
            />
          </div>
        </div>
        `,
        `
        <`,
        " eventEmitter=",
        ` />
      </div>
    `
      ])), O, vr("defaultUI"), x, function(T) {
        return r.refs.el = T;
      }, q9e, function(T) {
        return r.toolbar = T;
      }, l, y, f, S, vr("main"), w, function(T) {
        return r.refs.editorSection = T;
      }, vr("main-container"), vr("md-container"), k, function(T) {
        return r.refs.mdContainer = T;
      }, vr("md-splitter"), vr("ww-container"), function(T) {
        return r.refs.wwContainer = T;
      }, !c && Xr(iV || (iV = Kr(["<", " eventEmitter=", " editorType=", " />"], ["<", " eventEmitter=", " editorType=", " />"])), t9e, l, S), K9e, l);
    }, e.prototype.addEvent = function() {
      var r = this.props.eventEmitter;
      r.listen("hide", this.hide), r.listen("show", this.show), r.listen("changeMode", this.changeMode), r.listen("changePreviewStyle", this.changePreviewStyle);
    }, e;
  }(ea)
), iV, aV, Qn = (
  /** @class */
  function(i) {
    pr(e, i);
    function e(r) {
      var s, l = i.call(this, r) || this, c, f = e9e(l.options.el, Xr(oV || (oV = Kr([`
        <`, `
          ref=`, `
          eventEmitter=`, `
          slots=`, `
          hideModeSwitch=`, `
          toolbarItems=`, `
          previewStyle=`, `
          editorType=`, `
          theme=`, `
        />
      `], [`
        <`, `
          ref=`, `
          eventEmitter=`, `
          slots=`, `
          hideModeSwitch=`, `
          toolbarItems=`, `
          previewStyle=`, `
          editorType=`, `
          theme=`, `
        />
      `])), X9e, function(p) {
        return c = p;
      }, l.eventEmitter, l.getEditorElements(), l.options.hideModeSwitch, l.options.toolbarItems, l.options.previewStyle, l.options.initialEditType, l.options.theme));
      return l.setMinHeight(l.options.minHeight), l.setHeight(l.options.height), l.defaultUI = {
        insertToolbarItem: c.insertToolbarItem.bind(c),
        removeToolbarItem: c.removeToolbarItem.bind(c),
        destroy: f
      }, (s = l.pluginInfo.toolbarItems) === null || s === void 0 || s.forEach(function(p) {
        var d = p.groupIndex, m = p.itemIndex, y = p.item;
        l.defaultUI.insertToolbarItem({ groupIndex: d, itemIndex: m }, y);
      }), l.eventEmitter.emit("loadUI", l), l;
    }
    return e.factory = function(r) {
      return r.viewer ? new _9(r) : new e(r);
    }, e.prototype.insertToolbarItem = function(r, s) {
      this.defaultUI.insertToolbarItem(r, s);
    }, e.prototype.removeToolbarItem = function(r) {
      this.defaultUI.removeToolbarItem(r);
    }, e.prototype.destroy = function() {
      i.prototype.destroy.call(this), this.defaultUI.destroy();
    }, e;
  }(B9)
), oV;
B9.setLanguage(["en", "en-US"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Write",
  Preview: "Preview",
  Headings: "Headings",
  Paragraph: "Paragraph",
  Bold: "Bold",
  Italic: "Italic",
  Strike: "Strike",
  Code: "Inline code",
  Line: "Line",
  Blockquote: "Blockquote",
  "Unordered list": "Unordered list",
  "Ordered list": "Ordered list",
  Task: "Task",
  Indent: "Indent",
  Outdent: "Outdent",
  "Insert link": "Insert link",
  "Insert CodeBlock": "Insert codeBlock",
  "Insert table": "Insert table",
  "Insert image": "Insert image",
  Heading: "Heading",
  "Image URL": "Image URL",
  "Select image file": "Select image file",
  "Choose a file": "Choose a file",
  "No file": "No file",
  Description: "Description",
  OK: "OK",
  More: "More",
  Cancel: "Cancel",
  File: "File",
  URL: "URL",
  "Link text": "Link text",
  "Add row to up": "Add row to up",
  "Add row to down": "Add row to down",
  "Add column to left": "Add column to left",
  "Add column to right": "Add column to right",
  "Remove row": "Remove row",
  "Remove column": "Remove column",
  "Align column to left": "Align column to left",
  "Align column to center": "Align column to center",
  "Align column to right": "Align column to right",
  "Remove table": "Remove table",
  "Would you like to paste as table?": "Would you like to paste as table?",
  "Text color": "Text color",
  "Auto scroll enabled": "Auto scroll enabled",
  "Auto scroll disabled": "Auto scroll disabled",
  "Choose language": "Choose language"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
Qn.setLanguage("ar", {
  Markdown: "لغة ترميز",
  WYSIWYG: "ما تراه هو ما تحصل عليه",
  Write: "يكتب",
  Preview: "عرض مسبق",
  Headings: "العناوين",
  Paragraph: "فقرة",
  Bold: "خط عريض",
  Italic: "خط مائل",
  Strike: "إضراب",
  Code: "رمز",
  Line: "خط",
  Blockquote: "فقرة مقتبسة",
  "Unordered list": "قائمة غير مرتبة",
  "Ordered list": "قائمة مرتبة",
  Task: "مهمة",
  Indent: "المسافة البادئة",
  Outdent: "المسافة الخارجة",
  "Insert link": "أدخل الرابط",
  "Insert CodeBlock": "أدخل الكود",
  "Insert table": "أدخل جدول",
  "Insert image": "أدخل صورة",
  Heading: "عنوان",
  "Image URL": "رابط الصورة",
  "Select image file": "حدد ملف الصورة",
  "Choose a file": "اختيار الملف",
  "No file": "لا ملف",
  Description: "وصف",
  OK: "موافقة",
  More: "أكثر",
  Cancel: "إلغاء",
  File: "ملف",
  URL: "رابط",
  "Link text": "نص الرابط",
  "Add row to up": "أضف صفًا لأعلى",
  "Add row to down": "أضف صفًا إلى أسفل",
  "Add column to left": "أضف العمود على اليسار",
  "Add column to right": "أضف عمودًا إلى اليمين",
  "Remove row": "حذف سطر",
  "Remove column": "حذف عمود",
  "Align column to left": "محاذاة اليسار",
  "Align column to center": "محاذاة الوسط",
  "Align column to right": "محاذاة اليمين",
  "Remove table": "حذف الجدول",
  "Would you like to paste as table?": "هل تريد اللصق كجدول",
  "Text color": "لون النص",
  "Auto scroll enabled": "التحريك التلقائي ممكّن",
  "Auto scroll disabled": "التحريك التلقائي معطّل",
  "Choose language": "اختر اللغة"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
Qn.setLanguage(["cs", "cs-CZ"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Napsat",
  Preview: "Náhled",
  Headings: "Nadpisy",
  Paragraph: "Odstavec",
  Bold: "Tučné",
  Italic: "Kurzíva",
  Strike: "Přeškrtnuté",
  Code: "Kód",
  Line: "Vodorovná čára",
  Blockquote: "Citace",
  "Unordered list": "Seznam s odrážkami",
  "Ordered list": "Číslovaný seznam",
  Task: "Úkol",
  Indent: "Zvětšit odsazení",
  Outdent: "Zmenšit odsazení",
  "Insert link": "Vložit odkaz",
  "Insert CodeBlock": "Vložit blok kódu",
  "Insert table": "Vložit tabulku",
  "Insert image": "Vložit obrázek",
  Heading: "Nadpis",
  "Image URL": "URL obrázku",
  "Select image file": "Vybrat obrázek",
  "Choose a file": "Vyberte soubor",
  "No file": "Žádný soubor",
  Description: "Popis",
  OK: "OK",
  More: "Více",
  Cancel: "Zrušit",
  File: "Soubor",
  URL: "URL",
  "Link text": "Text odkazu",
  "Add row to up": "Přidejte řádek nahoru",
  "Add row to down": "Přidejte řádek dolů",
  "Add column to left": "Přidat sloupec vlevo",
  "Add column to right": "Přidat sloupec doprava",
  "Remove row": "Odebrat řádek",
  "Remove column": "Odebrat sloupec",
  "Align column to left": "Zarovnat vlevo",
  "Align column to center": "Zarovnat na střed",
  "Align column to right": "Zarovnat vpravo",
  "Remove table": "Odstranit tabulku",
  "Would you like to paste as table?": "Chcete vložit jako tabulku?",
  "Text color": "Barva textu",
  "Auto scroll enabled": "Automatické rolování zapnuto",
  "Auto scroll disabled": "Automatické rolování vypnuto",
  "Choose language": "Vybrat jazyk"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
Qn.setLanguage(["de", "de-DE"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Verfassen",
  Preview: "Vorschau",
  Headings: "Überschriften",
  Paragraph: "Text",
  Bold: "Fett",
  Italic: "Kursiv",
  Strike: "Durchgestrichen",
  Code: "Code",
  Line: "Trennlinie",
  Blockquote: "Blocktext",
  "Unordered list": "Aufzählung",
  "Ordered list": "Nummerierte Aufzählung",
  Task: "Aufgabe",
  Indent: "Einrücken",
  Outdent: "Ausrücken",
  "Insert link": "Link einfügen",
  "Insert CodeBlock": "Codeblock einfügen",
  "Insert table": "Tabelle einfügen",
  "Insert image": "Grafik einfügen",
  Heading: "Titel",
  "Image URL": "Bild URL",
  "Select image file": "Grafik auswählen",
  "Choose a file": "Wähle eine Datei",
  "No file": "Keine Datei",
  Description: "Beschreibung",
  OK: "OK",
  More: "Mehr",
  Cancel: "Abbrechen",
  File: "Datei",
  URL: "URL",
  "Link text": "Anzuzeigender Text",
  "Add row to up": "Zeile nach oben hinzufügen",
  "Add row to down": "Zeile nach unten hinzufügen",
  "Add column to left": "Spalte links hinzufügen",
  "Add column to right": "Spalte rechts hinzufügen",
  "Remove row": "Zeile entfernen",
  "Remove column": "Spalte entfernen",
  "Align column to left": "Links ausrichten",
  "Align column to center": "Zentrieren",
  "Align column to right": "Rechts ausrichten",
  "Remove table": "Tabelle entfernen",
  "Would you like to paste as table?": "Möchten Sie eine Tabelle einfügen?",
  "Text color": "Textfarbe",
  "Auto scroll enabled": "Autoscrollen aktiviert",
  "Auto scroll disabled": "Autoscrollen deaktiviert",
  "Choose language": "Sprache auswählen"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
Qn.setLanguage(["es", "es-ES"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Escribir",
  Preview: "Vista previa",
  Headings: "Encabezados",
  Paragraph: "Párrafo",
  Bold: "Negrita",
  Italic: "Itálica",
  Strike: "Tachado",
  Code: "Código",
  Line: "Línea",
  Blockquote: "Cita",
  "Unordered list": "Lista desordenada",
  "Ordered list": "Lista ordenada",
  Task: "Tarea",
  Indent: "Sangría",
  Outdent: "Saliendo",
  "Insert link": "Insertar enlace",
  "Insert CodeBlock": "Insertar bloque de código",
  "Insert table": "Insertar tabla",
  "Insert image": "Insertar imagen",
  Heading: "Encabezado",
  "Image URL": "URL de la imagen",
  "Select image file": "Seleccionar archivo de imagen",
  "Choose a file": "Escoge un archivo",
  "No file": "Ningún archivo",
  Description: "Descripción",
  OK: "Aceptar",
  More: "Más",
  Cancel: "Cancelar",
  File: "Archivo",
  URL: "URL",
  "Link text": "Texto del enlace",
  "Add row to up": "Agregar fila para subir",
  "Add row to down": "Agregar fila hacia abajo",
  "Add column to left": "Agregar columna a la izquierda",
  "Add column to right": "Agregar columna a la derecha",
  "Remove row": "Eliminar fila",
  "Remove column": "Eliminar columna",
  "Align column to left": "Alinear a la izquierda",
  "Align column to center": "Centrar",
  "Align column to right": "Alinear a la derecha",
  "Remove table": "Eliminar tabla",
  "Would you like to paste as table?": "¿Desea pegar como tabla?",
  "Text color": "Color del texto",
  "Auto scroll enabled": "Desplazamiento automático habilitado",
  "Auto scroll disabled": "Desplazamiento automático deshabilitado",
  "Choose language": "Elegir idioma"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
Qn.setLanguage(["fi", "fi-FI"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Kirjoita",
  Preview: "Esikatselu",
  Headings: "Otsikot",
  Paragraph: "Kappale",
  Bold: "Lihavointi",
  Italic: "Kursivointi",
  Strike: "Yliviivaus",
  Code: "Koodi",
  Line: "Vaakaviiva",
  Blockquote: "Lainaus",
  "Unordered list": "Luettelo",
  "Ordered list": "Numeroitu luettelo",
  Task: "Tehtävä",
  Indent: "Suurenna sisennystä",
  Outdent: "Pienennä sisennystä",
  "Insert link": "Lisää linkki",
  "Insert CodeBlock": "Lisää koodia",
  "Insert table": "Lisää taulukko",
  "Insert image": "Lisää kuva",
  Heading: "Otsikko",
  "Image URL": "Kuvan URL",
  "Select image file": "Valitse kuvatiedosto",
  "Choose a file": "Valitse tiedosto",
  "No file": "Ei tiedosto",
  Description: "Kuvaus",
  OK: "OK",
  More: "Lisää",
  Cancel: "Peruuta",
  File: "Tiedosto",
  URL: "URL",
  "Link text": "Linkkiteksti",
  "Add row to up": "Lisää rivi ylöspäin",
  "Add row to down": "Lisää rivi alaspäin",
  "Add column to left": "Lisää sarake vasemmalla",
  "Add column to right": "Lisää sarake oikealle",
  "Remove row": "Poista rivi",
  "Remove column": "Poista sarake",
  "Align column to left": "Tasaus vasemmalle",
  "Align column to center": "Keskitä",
  "Align column to right": "Tasaus oikealle",
  "Remove table": "Poista taulukko",
  "Would you like to paste as table?": "Haluatko liittää taulukkomuodossa?",
  "Text color": "Tekstin väri",
  "Auto scroll enabled": "Automaattinen skrollaus käytössä",
  "Auto scroll disabled": "Automaattinen skrollaus pois käytöstä",
  "Choose language": "Valitse kieli"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
Qn.setLanguage(["fr", "fr-FR"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Écrire",
  Preview: "Aperçu",
  Headings: "En-têtes",
  Paragraph: "Paragraphe",
  Bold: "Gras",
  Italic: "Italique",
  Strike: "Barré",
  Code: "Code en ligne",
  Line: "Ligne",
  Blockquote: "Citation",
  "Unordered list": "Liste non-ordonnée",
  "Ordered list": "Liste ordonnée",
  Task: "Tâche",
  Indent: "Retrait",
  Outdent: "Sortir",
  "Insert link": "Insérer un lien",
  "Insert CodeBlock": "Insérer un bloc de code",
  "Insert table": "Insérer un tableau",
  "Insert image": "Insérer une image",
  Heading: "En-tête",
  "Image URL": "URL de l'image",
  "Select image file": "Sélectionnez un fichier image",
  "Choose a file": "Choisissez un fichier",
  "No file": "Pas de fichier",
  Description: "Description",
  OK: "OK",
  More: "de plus",
  Cancel: "Annuler",
  File: "Fichier",
  URL: "URL",
  "Link text": "Texte du lien",
  "Add row to up": "Ajouter une ligne vers le haut",
  "Add row to down": "Ajouter une ligne vers le bas",
  "Add column to left": "Ajouter une colonne à gauche",
  "Add column to right": "Ajouter une colonne à droite",
  "Remove row": "Supprimer une ligne",
  "Remove column": "Supprimer une colonne",
  "Align column to left": "Aligner à gauche",
  "Align column to center": "Aligner au centre",
  "Align column to right": "Aligner à droite",
  "Remove table": "Supprimer le tableau",
  "Would you like to paste as table?": "Voulez-vous coller ce contenu en tant que tableau ?",
  "Text color": "Couleur du texte",
  "Auto scroll enabled": "Défilement automatique activé",
  "Auto scroll disabled": "Défilement automatique désactivé",
  "Choose language": "Choix de la langue"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
Qn.setLanguage(["gl", "gl-ES"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Escribir",
  Preview: "Vista previa",
  Headings: "Encabezados",
  Paragraph: "Parágrafo",
  Bold: "Negriña",
  Italic: "Cursiva",
  Strike: "Riscado",
  Code: "Código",
  Line: "Liña",
  Blockquote: "Cita",
  "Unordered list": "Lista desordenada",
  "Ordered list": "Lista ordenada",
  Task: "Tarefa",
  Indent: "Sangría",
  Outdent: "Anular sangría",
  "Insert link": "Inserir enlace",
  "Insert CodeBlock": "Inserir bloque de código",
  "Insert table": "Inserir táboa",
  "Insert image": "Inserir imaxe",
  Heading: "Encabezado",
  "Image URL": "URL da imaxe",
  "Select image file": "Seleccionar arquivo da imaxe",
  "Choose a file": "Escoge un archivo",
  "No file": "Ningún archivo",
  Description: "Descrición",
  OK: "Aceptar",
  More: "Máis",
  Cancel: "Cancelar",
  File: "Arquivo",
  URL: "URL",
  "Link text": "Texto do enlace",
  "Add row to up": "Engade fila para arriba",
  "Add row to down": "Engade fila para abaixo",
  "Add column to left": "Engade columna á esquerda",
  "Add column to right": "Engade columna á dereita",
  "Remove row": "Eliminar fila",
  "Remove column": "Eliminar columna",
  "Align column to left": "Aliñar á esquerda",
  "Align column to center": "Centrar",
  "Align column to right": "Aliñar á dereita",
  "Remove table": "Eliminar táboa",
  "Would you like to paste as table?": "Desexa pegar como táboa?",
  "Text color": "Cor do texto",
  "Auto scroll enabled": "Desprazamento automático habilitado",
  "Auto scroll disabled": "Desprazamento automático deshabilitado",
  "Choose language": "Elixir idioma"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
Qn.setLanguage(["it", "it-IT"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Scrivere",
  Preview: "Anteprima",
  Headings: "Intestazioni",
  Paragraph: "Paragrafo",
  Bold: "Grassetto",
  Italic: "Corsivo",
  Strike: "Barrato",
  Code: "Codice",
  Line: "Linea",
  Blockquote: "Blocco citazione",
  "Unordered list": "Lista puntata",
  "Ordered list": "Lista numerata",
  Task: "Attività",
  Indent: "Aggiungi indentazione",
  Outdent: "Rimuovi indentazione",
  "Insert link": "Inserisci link",
  "Insert CodeBlock": "Inserisci blocco di codice",
  "Insert table": "Inserisci tabella",
  "Insert image": "Inserisci immagine",
  Heading: "Intestazione",
  "Image URL": "URL immagine",
  "Select image file": "Seleziona file immagine",
  "Choose a file": "Scegli un file",
  "No file": "Nessun file",
  Description: "Descrizione",
  OK: "OK",
  More: "Più",
  Cancel: "Cancella",
  File: "File",
  URL: "URL",
  "Link text": "Testo del collegamento",
  "Add row to up": "Aggiungi riga in alto",
  "Add row to down": "Aggiungi riga in basso",
  "Add column to left": "Aggiungi colonna a sinistra",
  "Add column to right": "Aggiungi colonna a destra",
  "Remove row": "Rimuovi riga",
  "Remove column": "Rimuovi colonna",
  "Align column to left": "Allinea a sinistra",
  "Align column to center": "Allinea al centro",
  "Align column to right": "Allinea a destra",
  "Remove table": "Rimuovi tabella",
  "Would you like to paste as table?": "Desideri incollare sotto forma di tabella?",
  "Text color": "Colore del testo",
  "Auto scroll enabled": "Scrolling automatico abilitato",
  "Auto scroll disabled": "Scrolling automatico disabilitato",
  "Choose language": "Scegli la lingua"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
Qn.setLanguage(["ja", "ja-JP"], {
  Markdown: "マークダウン",
  WYSIWYG: "WYSIWYG",
  Write: "編集する",
  Preview: "プレビュー",
  Headings: "見出し",
  Paragraph: "本文",
  Bold: "太字",
  Italic: "イタリック",
  Strike: "ストライク",
  Code: "インラインコード",
  Line: "ライン",
  Blockquote: "引用",
  "Unordered list": "番号なしリスト",
  "Ordered list": "順序付きリスト",
  Task: "タスク",
  Indent: "インデント",
  Outdent: "アウトデント",
  "Insert link": "リンク挿入",
  "Insert CodeBlock": "コードブロック挿入",
  "Insert table": "テーブル挿入",
  "Insert image": "画像挿入",
  Heading: "見出し",
  "Image URL": "イメージURL",
  "Select image file": "画像ファイル選択",
  "Choose a file": "ファイルの選択",
  "No file": "ファイルがない",
  Description: "ディスクリプション ",
  OK: "はい",
  More: "もっと",
  Cancel: "キャンセル",
  File: "ファイル",
  URL: "URL",
  "Link text": "リンクテキスト",
  "Add row to up": "行を上に追加",
  "Add row to down": "下に行を追加",
  "Add column to left": "左側に列を追加",
  "Add column to right": "右側に列を追加",
  "Remove row": "行削除",
  "Remove column": "列削除",
  "Align column to left": "左揃え",
  "Align column to center": "中央揃え",
  "Align column to right": "右揃え",
  "Remove table": "テーブル削除",
  "Would you like to paste as table?": "テーブルを貼り付けますか?",
  "Text color": "文字色相",
  "Auto scroll enabled": "自動スクロールが有効",
  "Auto scroll disabled": "自動スクロールを無効に",
  "Choose language": "言語選択"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
Qn.setLanguage(["ko", "ko-KR"], {
  Markdown: "마크다운",
  WYSIWYG: "위지윅",
  Write: "편집하기",
  Preview: "미리보기",
  Headings: "제목크기",
  Paragraph: "본문",
  Bold: "굵게",
  Italic: "기울임꼴",
  Strike: "취소선",
  Code: "인라인 코드",
  Line: "문단나눔",
  Blockquote: "인용구",
  "Unordered list": "글머리 기호",
  "Ordered list": "번호 매기기",
  Task: "체크박스",
  Indent: "들여쓰기",
  Outdent: "내어쓰기",
  "Insert link": "링크 삽입",
  "Insert CodeBlock": "코드블럭 삽입",
  "Insert table": "표 삽입",
  "Insert image": "이미지 삽입",
  Heading: "제목",
  "Image URL": "이미지 주소",
  "Select image file": "이미지 파일을 선택하세요.",
  "Choose a file": "파일 선택",
  "No file": "선택된 파일 없음",
  Description: "설명",
  OK: "확인",
  More: "더 보기",
  Cancel: "취소",
  File: "파일",
  URL: "주소",
  "Link text": "링크 텍스트",
  "Add row to up": "위에 행 추가",
  "Add row to down": "아래에 행 추가",
  "Add column to left": "왼쪽에 열 추가",
  "Add column to right": "오른쪽에 열 추가",
  "Remove row": "행 삭제",
  "Remove column": "열 삭제",
  "Align column to left": "열 왼쪽 정렬",
  "Align column to center": "열 가운데 정렬",
  "Align column to right": "열 오른쪽 정렬",
  "Remove table": "표 삭제",
  "Would you like to paste as table?": "표형태로 붙여 넣겠습니까?",
  "Text color": "글자 색상",
  "Auto scroll enabled": "자동 스크롤 켜짐",
  "Auto scroll disabled": "자동 스크롤 꺼짐",
  "Choose language": "언어 선택"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
Qn.setLanguage(["nb", "nb-NO"], {
  Markdown: "Funksjonaliteter",
  WYSIWYG: "WYSIWYG",
  Write: "Skriv",
  Preview: "Forhåndsvisning",
  Headings: "Overskrift",
  Paragraph: "Paragraf",
  Bold: "Fet skrift",
  Italic: "Italic",
  Strike: "Strike",
  Code: "Kode",
  Line: "Linje",
  Blockquote: "Blokksitat",
  "Unordered list": "Usortert liste",
  "Ordered list": "Sortert liste",
  Task: "Task",
  Indent: "Indent",
  Outdent: "Outdent",
  "Insert link": "Sett inn lenke",
  "Insert CodeBlock": "Sett inn CodeStreng",
  "Insert table": "Sett inn diagram",
  "Insert image": "Sett inn bilde",
  Heading: "Overskrift",
  "Image URL": "BildeURL",
  "Select image file": "Velg bildefil",
  "Choose a file": "Velg en fil",
  "No file": "Ingen fil",
  Description: "Beskrivelse",
  OK: "OK",
  More: "Mer",
  Cancel: "Angre",
  File: "Fil",
  URL: "URL",
  "Link text": "Lenketekst",
  "Add row to up": "Legg rad til opp",
  "Add row to down": "Legg rad til ned",
  "Add column to left": "Legg til kolonne til venstre",
  "Add column to right": "Legg til kolonne til høyre",
  "Remove row": "Fjern rad",
  "Remove column": "Fjern kolonne",
  "Align column to left": "Venstreorienter",
  "Align column to center": "Senterorienter",
  "Align column to right": "Høyreorienter",
  "Remove table": "Fjern diagram",
  "Would you like to paste as table?": "Ønsker du å lime inn som et diagram?",
  "Text color": "Tekstfarge",
  "Auto scroll enabled": "Auto-scroll aktivert",
  "Auto scroll disabled": "Auto-scroll deaktivert",
  "Choose language": "Velg språl"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
Qn.setLanguage(["nl", "nl-NL"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Opslaan",
  Preview: "Voorbeeld",
  Headings: "Koppen",
  Paragraph: "Alinea",
  Bold: "Vet",
  Italic: "Cursief",
  Strike: "Doorhalen",
  Code: "Inline code",
  Line: "Regel",
  Blockquote: "Citaatblok",
  "Unordered list": "Opsomming",
  "Ordered list": "Genummerde opsomming",
  Task: "Taak",
  Indent: "Niveau verhogen",
  Outdent: "Niveau verlagen",
  "Insert link": "Link invoegen",
  "Insert CodeBlock": "Codeblok toevoegen",
  "Insert table": "Tabel invoegen",
  "Insert image": "Afbeelding invoegen",
  Heading: "Kop",
  "Image URL": "Afbeelding URL",
  "Select image file": "Selecteer een afbeelding",
  "Choose a file": "Kies een bestand",
  "No file": "Geen bestand",
  Description: "Omschrijving",
  OK: "OK",
  More: "Meer",
  Cancel: "Annuleren",
  File: "Bestand",
  URL: "URL",
  "Link text": "Link tekst",
  "Add row to up": "Voeg rij toe aan omhoog",
  "Add row to down": "Rij naar beneden toevoegen",
  "Add column to left": "Voeg kolom aan de linkerkant toe",
  "Add column to right": "Voeg een kolom aan de rechterkant toe",
  "Remove row": "Rij verwijderen",
  "Remove column": "Kolom verwijderen",
  "Align column to left": "Links uitlijnen",
  "Align column to center": "Centreren",
  "Align column to right": "Rechts uitlijnen",
  "Remove table": "Verwijder tabel",
  "Would you like to paste as table?": "Wil je dit als tabel plakken?",
  "Text color": "Tekstkleur",
  "Auto scroll enabled": "Autoscroll ingeschakeld",
  "Auto scroll disabled": "Autoscroll uitgeschakeld",
  "Choose language": "Kies een taal"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
Qn.setLanguage(["pl", "pl-PL"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Napisz",
  Preview: "Podgląd",
  Headings: "Nagłówki",
  Paragraph: "Akapit",
  Bold: "Pogrubienie",
  Italic: "Kursywa",
  Strike: "Przekreślenie",
  Code: "Fragment kodu",
  Line: "Linia",
  Blockquote: "Cytat",
  "Unordered list": "Lista nieuporządkowana",
  "Ordered list": "Lista uporządkowana",
  Task: "Zadanie",
  Indent: "Utwórz wcięcie",
  Outdent: "Usuń wcięcie",
  "Insert link": "Umieść odnośnik",
  "Insert CodeBlock": "Umieść blok kodu",
  "Insert table": "Umieść tabelę",
  "Insert image": "Umieść obraz",
  Heading: "Nagłówek",
  "Image URL": "Adres URL obrazu",
  "Select image file": "Wybierz plik obrazu",
  "Choose a file": "Wybierz plik",
  "No file": "Brak plik",
  Description: "Opis",
  OK: "OK",
  More: "Więcej",
  Cancel: "Anuluj",
  File: "Plik",
  URL: "URL",
  "Link text": "Tekst odnośnika",
  "Add row to up": "Dodaj wiersz do góry",
  "Add row to down": "Dodaj wiersz w dół",
  "Add column to left": "Dodaj kolumnę po lewej stronie",
  "Add column to right": "Dodaj kolumnę po prawej stronie",
  "Remove row": "Usuń rząd",
  "Remove column": "Usuń kolumnę",
  "Align column to left": "Wyrównaj do lewej",
  "Align column to center": "Wyśrodkuj",
  "Align column to right": "Wyrównaj do prawej",
  "Remove table": "Usuń tabelę",
  "Would you like to paste as table?": "Czy chcesz wkleić tekst jako tabelę?",
  "Text color": "Kolor tekstu",
  "Auto scroll enabled": "Włączono automatyczne przewijanie",
  "Auto scroll disabled": "Wyłączono automatyczne przewijanie",
  "Choose language": "Wybierz język"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
Qn.setLanguage(["ru", "ru-RU"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Редактор",
  Preview: "Просмотр",
  Headings: "Заголовки",
  Paragraph: "Абзац",
  Bold: "Жирный",
  Italic: "Курсив",
  Strike: "Зачеркнутый",
  Code: "Код",
  Line: "Линия",
  Blockquote: "Цитата",
  "Unordered list": "Неупорядоченный список",
  "Ordered list": "Упорядоченный список",
  Task: "Галочка",
  Indent: "Увеличить отступ",
  Outdent: "Уменьшить отступ",
  "Insert link": "Вставить ссылку",
  "Insert CodeBlock": "Вставить блок кода",
  "Insert table": "Вставить таблицу",
  "Insert image": "Вставить изображение",
  Heading: "Заголовок",
  "Image URL": "URL изображения",
  "Select image file": "Выбрать файл изображения",
  "Choose a file": "Выбрать",
  "No file": "Нет файла",
  Description: "Описание",
  OK: "Хорошо",
  More: "Еще",
  Cancel: "Отмена",
  File: "Файл",
  URL: "URL",
  "Link text": "Текст ссылки",
  "Add row to up": "Добавить строку вверх",
  "Add row to down": "Добавить строку вниз",
  "Add column to left": "Добавить столбец слева",
  "Add column to right": "Добавить столбец справа",
  "Remove row": "Удалить ряд",
  "Remove column": "Удалить столбец",
  "Align column to left": "Выровнять по левому краю",
  "Align column to center": "Выровнять по центру",
  "Align column to right": "Выровнять по правому краю",
  "Remove table": "Удалить таблицу",
  "Would you like to paste as table?": "Вы хотите вставить в виде таблицы?",
  "Text color": "Цвет текста",
  "Auto scroll enabled": "Автопрокрутка включена",
  "Auto scroll disabled": "Автопрокрутка отключена",
  "Choose language": "Выбрать язык"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
Qn.setLanguage(["sv", "sv-SE"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Skriv",
  Preview: "Förhandsgranska",
  Headings: "Överskrifter",
  Paragraph: "Paragraf",
  Bold: "Fet",
  Italic: "Kursiv",
  Strike: "Genomstruken",
  Code: "Kodrad",
  Line: "Linje",
  Blockquote: "Citatblock",
  "Unordered list": "Punktlista",
  "Ordered list": "Numrerad lista",
  Task: "Att göra",
  Indent: "Öka indrag",
  Outdent: "Minska indrag",
  "Insert link": "Infoga länk",
  "Insert CodeBlock": "Infoga kodblock",
  "Insert table": "Infoga tabell",
  "Insert image": "Infoga bild",
  Heading: "Överskrift",
  "Image URL": "Bildadress",
  "Select image file": "Välj en bildfil",
  "Choose a file": "Välj en fil",
  "No file": "Ingen fil",
  Description: "Beskrivning",
  OK: "OK",
  More: "Mer",
  Cancel: "Avbryt",
  File: "Fil",
  URL: "Adress",
  "Link text": "Länktext",
  "Add row to up": "Lägg till rad till upp",
  "Add row to down": "Lägg till rad till ner",
  "Add column to left": "Lägg till kolumn till vänster",
  "Add column to right": "Lägg till kolumn till höger",
  "Remove row": "Radera rad",
  "Remove column": "Radera kolumn",
  "Align column to left": "Vänsterjustera",
  "Align column to center": "Centrera",
  "Align column to right": "Högerjustera",
  "Remove table": "Radera tabell",
  "Would you like to paste as table?": "Vill du klistra in som en tabell?",
  "Text color": "Textfärg",
  "Auto scroll enabled": "Automatisk scroll aktiverad",
  "Auto scroll disabled": "Automatisk scroll inaktiverad",
  "Choose language": "Välj språk"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
Qn.setLanguage(["tr", "tr-TR"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Düzenle",
  Preview: "Ön izleme",
  Headings: "Başlıklar",
  Paragraph: "Paragraf",
  Bold: "Kalın",
  Italic: "İtalik",
  Strike: "Altı çizgili",
  Code: "Satır içi kod",
  Line: "Çizgi",
  Blockquote: "Alıntı",
  "Unordered list": "Sıralanmamış liste",
  "Ordered list": "Sıralı liste",
  Task: "Görev kutusu",
  Indent: "Girintiyi arttır",
  Outdent: "Girintiyi azalt",
  "Insert link": "Bağlantı ekle",
  "Insert CodeBlock": "Kod bloku ekle",
  "Insert table": "Tablo ekle",
  "Insert image": "İmaj ekle",
  Heading: "Başlık",
  "Image URL": "İmaj URL",
  "Select image file": "İmaj dosyası seç",
  "Choose a file": "Bir dosya seçin",
  "No file": "Dosya yok",
  Description: "Açıklama",
  OK: "Onay",
  More: "Daha Fazla",
  Cancel: "İptal",
  File: "Dosya",
  URL: "URL",
  "Link text": "Bağlantı yazısı",
  "Add row to up": "Yukarı satır ekle",
  "Add row to down": "Aşağı satır ekle",
  "Add column to left": "Sola sütun ekleyin",
  "Add column to right": "Sağa sütun ekle",
  "Remove row": "Satır sil",
  "Remove column": "Sütun sil",
  "Align column to left": "Sola hizala",
  "Align column to center": "Merkeze hizala",
  "Align column to right": "Sağa hizala",
  "Remove table": "Tabloyu kaldır",
  "Would you like to paste as table?": "Tablo olarak yapıştırmak ister misiniz?",
  "Text color": "Metin rengi",
  "Auto scroll enabled": "Otomatik kaydırma açık",
  "Auto scroll disabled": "Otomatik kaydırma kapalı",
  "Choose language": "Dil seçiniz"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
Qn.setLanguage(["uk", "uk-UA"], {
  Markdown: "Markdown",
  WYSIWYG: "WYSIWYG",
  Write: "Написати",
  Preview: "Попередній перегляд",
  Headings: "Заголовки",
  Paragraph: "Абзац",
  Bold: "Жирний",
  Italic: "Курсив",
  Strike: "Закреслений",
  Code: "Вбудований код",
  Line: "Лінія",
  Blockquote: "Блок цитування",
  "Unordered list": "Невпорядкований список",
  "Ordered list": "Упорядкований список",
  Task: "Завдання",
  Indent: "відступ",
  Outdent: "застарілий",
  "Insert link": "Вставити посилання",
  "Insert CodeBlock": "Вставити код",
  "Insert table": "Вставити таблицю",
  "Insert image": "Вставити зображення",
  Heading: "Заголовок",
  "Image URL": "URL зображення",
  "Select image file": "Вибрати файл зображення",
  "Choose a file": "Виберіть файл",
  "No file": "Немає файлу",
  Description: "Опис",
  OK: "OK",
  More: "ще",
  Cancel: "Скасувати",
  File: "Файл",
  URL: "URL",
  "Link text": "Текст посилання",
  "Add row to up": "Додати рядок вгору",
  "Add row to down": "Додати рядок вниз",
  "Add column to left": "Додайте стовпець зліва",
  "Add column to right": "Додайте стовпець праворуч",
  "Remove row": "Видалити ряд",
  "Remove column": "Видалити стовпчик",
  "Align column to left": "Вирівняти по лівому краю",
  "Align column to center": "Вирівняти по центру",
  "Align column to right": "Вирівняти по правому краю",
  "Remove table": "Видалити таблицю",
  "Would you like to paste as table?": "Ви хочете вставити у вигляді таблиці?",
  "Text color": "Колір тексту",
  "Auto scroll enabled": "Автоматична прокрутка включена",
  "Auto scroll disabled": "Автоматична прокрутка відключена",
  "Choose language": "Вибрати мову"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
Qn.setLanguage("zh-CN", {
  Markdown: "Markdown",
  WYSIWYG: "所见即所得",
  Write: "编辑",
  Preview: "预览",
  Headings: "标题",
  Paragraph: "文本",
  Bold: "加粗",
  Italic: "斜体字",
  Strike: "删除线",
  Code: "内嵌代码",
  Line: "水平线",
  Blockquote: "引用块",
  "Unordered list": "无序列表",
  "Ordered list": "有序列表",
  Task: "任务",
  Indent: "缩进",
  Outdent: "减少缩进",
  "Insert link": "插入链接",
  "Insert CodeBlock": "插入代码块",
  "Insert table": "插入表格",
  "Insert image": "插入图片",
  Heading: "标题",
  "Image URL": "图片网址",
  "Select image file": "选择图片文件",
  "Choose a file": "选择一个文件",
  "No file": "没有文件",
  Description: "说明",
  OK: "确认",
  More: "更多",
  Cancel: "取消",
  File: "文件",
  URL: "URL",
  "Link text": "链接文本",
  "Add row to up": "向上添加行",
  "Add row to down": "在下方添加行",
  "Add column to left": "在左侧添加列",
  "Add column to right": "在右侧添加列",
  "Remove row": "删除行",
  "Remove column": "删除列",
  "Align column to left": "左对齐",
  "Align column to center": "居中对齐",
  "Align column to right": "右对齐",
  "Remove table": "删除表格",
  "Would you like to paste as table?": "需要粘贴为表格吗?",
  "Text color": "文字颜色",
  "Auto scroll enabled": "自动滚动已启用",
  "Auto scroll disabled": "自动滚动已禁用",
  "Choose language": "选择语言"
});
/**
 * @toast-ui/editor : i18n
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
Qn.setLanguage("zh-TW", {
  Markdown: "Markdown",
  WYSIWYG: "所見即所得",
  Write: "編輯",
  Preview: "預覽",
  Headings: "標題",
  Paragraph: "內文",
  Bold: "粗體",
  Italic: "斜體",
  Strike: "刪除線",
  Code: "內嵌程式碼",
  Line: "分隔線",
  Blockquote: "引言",
  "Unordered list": "項目符號清單",
  "Ordered list": "編號清單",
  Task: "核取方塊清單",
  Indent: "增加縮排",
  Outdent: "減少縮排",
  "Insert link": "插入超連結",
  "Insert CodeBlock": "插入程式碼區塊",
  "Insert table": "插入表格",
  "Insert image": "插入圖片",
  Heading: "標題",
  "Image URL": "圖片網址",
  "Select image file": "選擇圖片檔案",
  "Choose a file": "選擇一個文件",
  "No file": "沒有文件",
  Description: "描述",
  OK: "確認",
  More: "更多",
  Cancel: "取消",
  File: "檔案",
  URL: "URL",
  "Link text": "超連結文字",
  "Add row to up": "向上添加行",
  "Add row to down": "在下方添加行",
  "Add column to left": "在左側添加列",
  "Add column to right": "在右側添加列",
  "Remove row": "刪除行",
  "Remove column": "刪除列",
  "Align column to left": "靠左對齊",
  "Align column to center": "置中",
  "Align column to right": "靠右對齊",
  "Remove table": "刪除表格",
  "Would you like to paste as table?": "您要以表格貼上嗎？",
  "Text color": "文字顏色",
  "Auto scroll enabled": "已啟用自動滾動",
  "Auto scroll disabled": "已停用自動滾動",
  "Choose language": "選擇語言"
});
function Cp(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
var kj = { exports: {} }, Oj = { exports: {} };
/*!
 * TOAST UI Chart 4th Edition
 * @version 4.6.1 | Wed Dec 21 2022
 * @author NHN Cloud. FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
var sV;
function J9e() {
  return sV || (sV = 1, function(i, e) {
    (function(s, l) {
      i.exports = l();
    })(self, function() {
      return (
        /******/
        function() {
          var r = {
            /***/
            3819: (
              /***/
              function(f) {
                f.exports = function(p) {
                  if (typeof p != "function")
                    throw TypeError(String(p) + " is not a function");
                  return p;
                };
              }
            ),
            /***/
            8505: (
              /***/
              function(f, p, d) {
                var m = d(5052);
                f.exports = function(y) {
                  if (!m(y) && y !== null)
                    throw TypeError("Can't set " + String(y) + " as a prototype");
                  return y;
                };
              }
            ),
            /***/
            9736: (
              /***/
              function(f, p, d) {
                var m = d(95), y = d(2391), S = d(1787), x = m("unscopables"), w = Array.prototype;
                w[x] == null && S.f(w, x, {
                  configurable: !0,
                  value: y(null)
                }), f.exports = function(k) {
                  w[x][k] = !0;
                };
              }
            ),
            /***/
            6637: (
              /***/
              function(f, p, d) {
                var m = d(966).charAt;
                f.exports = function(y, S, x) {
                  return S + (x ? m(y, S).length : 1);
                };
              }
            ),
            /***/
            7728: (
              /***/
              function(f) {
                f.exports = function(p, d, m) {
                  if (!(p instanceof d))
                    throw TypeError("Incorrect " + (m ? m + " " : "") + "invocation");
                  return p;
                };
              }
            ),
            /***/
            1176: (
              /***/
              function(f, p, d) {
                var m = d(5052);
                f.exports = function(y) {
                  if (!m(y))
                    throw TypeError(String(y) + " is not an object");
                  return y;
                };
              }
            ),
            /***/
            3339: (
              /***/
              function(f) {
                f.exports = typeof ArrayBuffer < "u" && typeof DataView < "u";
              }
            ),
            /***/
            9918: (
              /***/
              function(f, p, d) {
                var m = d(3339), y = d(7400), S = d(9859), x = d(5052), w = d(816), k = d(1589), O = d(5762), T = d(7487), L = d(1787).f, j = d(7567), z = d(6540), J = d(95), ie = d(1441), K = S.Int8Array, re = K && K.prototype, ee = S.Uint8ClampedArray, de = ee && ee.prototype, Ce = K && j(K), he = re && j(re), oe = Object.prototype, ge = oe.isPrototypeOf, we = J("toStringTag"), Oe = ie("TYPED_ARRAY_TAG"), Qe = m && !!z && k(S.opera) !== "Opera", Me = !1, Ie, rt = {
                  Int8Array: 1,
                  Uint8Array: 1,
                  Uint8ClampedArray: 1,
                  Int16Array: 2,
                  Uint16Array: 2,
                  Int32Array: 4,
                  Uint32Array: 4,
                  Float32Array: 4,
                  Float64Array: 8
                }, ot = {
                  BigInt64Array: 8,
                  BigUint64Array: 8
                }, Et = function(He) {
                  if (!x(He)) return !1;
                  var We = k(He);
                  return We === "DataView" || w(rt, We) || w(ot, We);
                }, gt = function(Ue) {
                  if (!x(Ue)) return !1;
                  var He = k(Ue);
                  return w(rt, He) || w(ot, He);
                }, At = function(Ue) {
                  if (gt(Ue)) return Ue;
                  throw TypeError("Target is not a typed array");
                }, Mt = function(Ue) {
                  if (z) {
                    if (ge.call(Ce, Ue)) return Ue;
                  } else for (var He in rt) if (w(rt, Ie)) {
                    var We = S[He];
                    if (We && (Ue === We || ge.call(We, Ue)))
                      return Ue;
                  }
                  throw TypeError("Target is not a typed array constructor");
                }, St = function(Ue, He, We) {
                  if (y) {
                    if (We) for (var ze in rt) {
                      var at = S[ze];
                      if (at && w(at.prototype, Ue)) try {
                        delete at.prototype[Ue];
                      } catch {
                      }
                    }
                    (!he[Ue] || We) && T(he, Ue, We ? He : Qe && re[Ue] || He);
                  }
                }, Ve = function(Ue, He, We) {
                  var ze, at;
                  if (y) {
                    if (z) {
                      if (We) {
                        for (ze in rt)
                          if (at = S[ze], at && w(at, Ue)) try {
                            delete at[Ue];
                          } catch {
                          }
                      }
                      if (!Ce[Ue] || We)
                        try {
                          return T(Ce, Ue, We ? He : Qe && Ce[Ue] || He);
                        } catch {
                        }
                      else return;
                    }
                    for (ze in rt)
                      at = S[ze], at && (!at[Ue] || We) && T(at, Ue, He);
                  }
                };
                for (Ie in rt)
                  S[Ie] || (Qe = !1);
                if ((!Qe || typeof Ce != "function" || Ce === Function.prototype) && (Ce = function() {
                  throw TypeError("Incorrect invocation");
                }, Qe))
                  for (Ie in rt)
                    S[Ie] && z(S[Ie], Ce);
                if ((!Qe || !he || he === oe) && (he = Ce.prototype, Qe))
                  for (Ie in rt)
                    S[Ie] && z(S[Ie].prototype, he);
                if (Qe && j(de) !== he && z(de, he), y && !w(he, we)) {
                  Me = !0, L(he, we, { get: function() {
                    return x(this) ? this[Oe] : void 0;
                  } });
                  for (Ie in rt) S[Ie] && O(S[Ie], Oe, Ie);
                }
                f.exports = {
                  NATIVE_ARRAY_BUFFER_VIEWS: Qe,
                  TYPED_ARRAY_TAG: Me && Oe,
                  aTypedArray: At,
                  aTypedArrayConstructor: Mt,
                  exportTypedArrayMethod: St,
                  exportTypedArrayStaticMethod: Ve,
                  isView: Et,
                  isTypedArray: gt,
                  TypedArray: Ce,
                  TypedArrayPrototype: he
                };
              }
            ),
            /***/
            3816: (
              /***/
              function(f, p, d) {
                var m = d(9859), y = d(7400), S = d(3339), x = d(5762), w = d(8787), k = d(4229), O = d(7728), T = d(6051), L = d(4237), j = d(7331), z = d(6201), J = d(7567), ie = d(6540), K = d(8151).f, re = d(1787).f, ee = d(7065), de = d(4555), Ce = d(6407), he = Ce.get, oe = Ce.set, ge = "ArrayBuffer", we = "DataView", Oe = "prototype", Qe = "Wrong length", Me = "Wrong index", Ie = m[ge], rt = Ie, ot = m[we], Et = ot && ot[Oe], gt = Object.prototype, At = m.RangeError, Mt = z.pack, St = z.unpack, Ve = function(Q) {
                  return [Q & 255];
                }, Ue = function(Q) {
                  return [Q & 255, Q >> 8 & 255];
                }, He = function(Q) {
                  return [Q & 255, Q >> 8 & 255, Q >> 16 & 255, Q >> 24 & 255];
                }, We = function(Q) {
                  return Q[3] << 24 | Q[2] << 16 | Q[1] << 8 | Q[0];
                }, ze = function(Q) {
                  return Mt(Q, 23, 4);
                }, at = function(Q) {
                  return Mt(Q, 52, 8);
                }, Ye = function(Q, te) {
                  re(Q[Oe], te, { get: function() {
                    return he(this)[te];
                  } });
                }, tt = function(Q, te, De, nt) {
                  var be = j(De), G = he(Q);
                  if (be + te > G.byteLength) throw At(Me);
                  var V = he(G.buffer).bytes, ve = be + G.byteOffset, Ne = V.slice(ve, ve + te);
                  return nt ? Ne : Ne.reverse();
                }, wt = function(Q, te, De, nt, be, G) {
                  var V = j(De), ve = he(Q);
                  if (V + te > ve.byteLength) throw At(Me);
                  for (var Ne = he(ve.buffer).bytes, it = V + ve.byteOffset, yt = nt(+be), $t = 0; $t < te; $t++) Ne[it + $t] = yt[G ? $t : te - $t - 1];
                };
                if (!S)
                  rt = function(te) {
                    O(this, rt, ge);
                    var De = j(te);
                    oe(this, {
                      bytes: ee.call(new Array(De), 0),
                      byteLength: De
                    }), y || (this.byteLength = De);
                  }, ot = function(te, De, nt) {
                    O(this, ot, we), O(te, rt, we);
                    var be = he(te).byteLength, G = T(De);
                    if (G < 0 || G > be) throw At("Wrong offset");
                    if (nt = nt === void 0 ? be - G : L(nt), G + nt > be) throw At(Qe);
                    oe(this, {
                      buffer: te,
                      byteLength: nt,
                      byteOffset: G
                    }), y || (this.buffer = te, this.byteLength = nt, this.byteOffset = G);
                  }, y && (Ye(rt, "byteLength"), Ye(ot, "buffer"), Ye(ot, "byteLength"), Ye(ot, "byteOffset")), w(ot[Oe], {
                    getInt8: function(te) {
                      return tt(this, 1, te)[0] << 24 >> 24;
                    },
                    getUint8: function(te) {
                      return tt(this, 1, te)[0];
                    },
                    getInt16: function(te) {
                      var De = tt(this, 2, te, arguments.length > 1 ? arguments[1] : void 0);
                      return (De[1] << 8 | De[0]) << 16 >> 16;
                    },
                    getUint16: function(te) {
                      var De = tt(this, 2, te, arguments.length > 1 ? arguments[1] : void 0);
                      return De[1] << 8 | De[0];
                    },
                    getInt32: function(te) {
                      return We(tt(this, 4, te, arguments.length > 1 ? arguments[1] : void 0));
                    },
                    getUint32: function(te) {
                      return We(tt(this, 4, te, arguments.length > 1 ? arguments[1] : void 0)) >>> 0;
                    },
                    getFloat32: function(te) {
                      return St(tt(this, 4, te, arguments.length > 1 ? arguments[1] : void 0), 23);
                    },
                    getFloat64: function(te) {
                      return St(tt(this, 8, te, arguments.length > 1 ? arguments[1] : void 0), 52);
                    },
                    setInt8: function(te, De) {
                      wt(this, 1, te, Ve, De);
                    },
                    setUint8: function(te, De) {
                      wt(this, 1, te, Ve, De);
                    },
                    setInt16: function(te, De) {
                      wt(this, 2, te, Ue, De, arguments.length > 2 ? arguments[2] : void 0);
                    },
                    setUint16: function(te, De) {
                      wt(this, 2, te, Ue, De, arguments.length > 2 ? arguments[2] : void 0);
                    },
                    setInt32: function(te, De) {
                      wt(this, 4, te, He, De, arguments.length > 2 ? arguments[2] : void 0);
                    },
                    setUint32: function(te, De) {
                      wt(this, 4, te, He, De, arguments.length > 2 ? arguments[2] : void 0);
                    },
                    setFloat32: function(te, De) {
                      wt(this, 4, te, ze, De, arguments.length > 2 ? arguments[2] : void 0);
                    },
                    setFloat64: function(te, De) {
                      wt(this, 8, te, at, De, arguments.length > 2 ? arguments[2] : void 0);
                    }
                  });
                else {
                  if (!k(function() {
                    Ie(1);
                  }) || !k(function() {
                    new Ie(-1);
                  }) || k(function() {
                    return new Ie(), new Ie(1.5), new Ie(NaN), Ie.name != ge;
                  })) {
                    rt = function(te) {
                      return O(this, rt), new Ie(j(te));
                    };
                    for (var Ft = rt[Oe] = Ie[Oe], qe = K(Ie), pe = 0, _e; qe.length > pe; )
                      (_e = qe[pe++]) in rt || x(rt, _e, Ie[_e]);
                    Ft.constructor = rt;
                  }
                  ie && J(Et) !== gt && ie(Et, gt);
                  var Xe = new ot(new rt(2)), lt = Et.setInt8;
                  Xe.setInt8(0, 2147483648), Xe.setInt8(1, 2147483649), (Xe.getInt8(0) || !Xe.getInt8(1)) && w(Et, {
                    setInt8: function(te, De) {
                      lt.call(this, te, De << 24 >> 24);
                    },
                    setUint8: function(te, De) {
                      lt.call(this, te, De << 24 >> 24);
                    }
                  }, { unsafe: !0 });
                }
                de(rt, ge), de(ot, we), f.exports = {
                  ArrayBuffer: rt,
                  DataView: ot
                };
              }
            ),
            /***/
            7154: (
              /***/
              function(f, p, d) {
                var m = d(2991), y = d(3231), S = d(4237), x = Math.min;
                f.exports = [].copyWithin || function(k, O) {
                  var T = m(this), L = S(T.length), j = y(k, L), z = y(O, L), J = arguments.length > 2 ? arguments[2] : void 0, ie = x((J === void 0 ? L : y(J, L)) - z, L - j), K = 1;
                  for (z < j && j < z + ie && (K = -1, z += ie - 1, j += ie - 1); ie-- > 0; )
                    z in T ? T[j] = T[z] : delete T[j], j += K, z += K;
                  return T;
                };
              }
            ),
            /***/
            7065: (
              /***/
              function(f, p, d) {
                var m = d(2991), y = d(3231), S = d(4237);
                f.exports = function(w) {
                  for (var k = m(this), O = S(k.length), T = arguments.length, L = y(T > 1 ? arguments[1] : void 0, O), j = T > 2 ? arguments[2] : void 0, z = j === void 0 ? O : y(j, O); z > L; ) k[L++] = w;
                  return k;
                };
              }
            ),
            /***/
            6570: (
              /***/
              function(f, p, d) {
                var m = d(9996).forEach, y = d(6038), S = y("forEach");
                f.exports = S ? [].forEach : function(w) {
                  return m(this, w, arguments.length > 1 ? arguments[1] : void 0);
                };
              }
            ),
            /***/
            507: (
              /***/
              function(f, p, d) {
                var m = d(7636), y = d(2991), S = d(4960), x = d(1943), w = d(4237), k = d(2324), O = d(8830);
                f.exports = function(L) {
                  var j = y(L), z = typeof this == "function" ? this : Array, J = arguments.length, ie = J > 1 ? arguments[1] : void 0, K = ie !== void 0, re = O(j), ee = 0, de, Ce, he, oe, ge, we;
                  if (K && (ie = m(ie, J > 2 ? arguments[2] : void 0, 2)), re != null && !(z == Array && x(re)))
                    for (oe = re.call(j), ge = oe.next, Ce = new z(); !(he = ge.call(oe)).done; ee++)
                      we = K ? S(oe, ie, [he.value, ee], !0) : he.value, k(Ce, ee, we);
                  else
                    for (de = w(j.length), Ce = new z(de); de > ee; ee++)
                      we = K ? ie(j[ee], ee) : j[ee], k(Ce, ee, we);
                  return Ce.length = ee, Ce;
                };
              }
            ),
            /***/
            9540: (
              /***/
              function(f, p, d) {
                var m = d(905), y = d(4237), S = d(3231), x = function(w) {
                  return function(k, O, T) {
                    var L = m(k), j = y(L.length), z = S(T, j), J;
                    if (w && O != O) {
                      for (; j > z; )
                        if (J = L[z++], J != J) return !0;
                    } else for (; j > z; z++)
                      if ((w || z in L) && L[z] === O) return w || z || 0;
                    return !w && -1;
                  };
                };
                f.exports = {
                  // `Array.prototype.includes` method
                  // https://tc39.es/ecma262/#sec-array.prototype.includes
                  includes: x(!0),
                  // `Array.prototype.indexOf` method
                  // https://tc39.es/ecma262/#sec-array.prototype.indexof
                  indexOf: x(!1)
                };
              }
            ),
            /***/
            9996: (
              /***/
              function(f, p, d) {
                var m = d(7636), y = d(9337), S = d(2991), x = d(4237), w = d(7501), k = [].push, O = function(T) {
                  var L = T == 1, j = T == 2, z = T == 3, J = T == 4, ie = T == 6, K = T == 7, re = T == 5 || ie;
                  return function(ee, de, Ce, he) {
                    for (var oe = S(ee), ge = y(oe), we = m(de, Ce, 3), Oe = x(ge.length), Qe = 0, Me = he || w, Ie = L ? Me(ee, Oe) : j || K ? Me(ee, 0) : void 0, rt, ot; Oe > Qe; Qe++) if ((re || Qe in ge) && (rt = ge[Qe], ot = we(rt, Qe, oe), T))
                      if (L) Ie[Qe] = ot;
                      else if (ot) switch (T) {
                        case 3:
                          return !0;
                        // some
                        case 5:
                          return rt;
                        // find
                        case 6:
                          return Qe;
                        // findIndex
                        case 2:
                          k.call(Ie, rt);
                      }
                      else switch (T) {
                        case 4:
                          return !1;
                        // every
                        case 7:
                          k.call(Ie, rt);
                      }
                    return ie ? -1 : z || J ? J : Ie;
                  };
                };
                f.exports = {
                  // `Array.prototype.forEach` method
                  // https://tc39.es/ecma262/#sec-array.prototype.foreach
                  forEach: O(0),
                  // `Array.prototype.map` method
                  // https://tc39.es/ecma262/#sec-array.prototype.map
                  map: O(1),
                  // `Array.prototype.filter` method
                  // https://tc39.es/ecma262/#sec-array.prototype.filter
                  filter: O(2),
                  // `Array.prototype.some` method
                  // https://tc39.es/ecma262/#sec-array.prototype.some
                  some: O(3),
                  // `Array.prototype.every` method
                  // https://tc39.es/ecma262/#sec-array.prototype.every
                  every: O(4),
                  // `Array.prototype.find` method
                  // https://tc39.es/ecma262/#sec-array.prototype.find
                  find: O(5),
                  // `Array.prototype.findIndex` method
                  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
                  findIndex: O(6),
                  // `Array.prototype.filterOut` method
                  // https://github.com/tc39/proposal-array-filtering
                  filterOut: O(7)
                };
              }
            ),
            /***/
            6462: (
              /***/
              function(f, p, d) {
                var m = d(905), y = d(6051), S = d(4237), x = d(6038), w = Math.min, k = [].lastIndexOf, O = !!k && 1 / [1].lastIndexOf(1, -0) < 0, T = x("lastIndexOf"), L = O || !T;
                f.exports = L ? function(z) {
                  if (O) return k.apply(this, arguments) || 0;
                  var J = m(this), ie = S(J.length), K = ie - 1;
                  for (arguments.length > 1 && (K = w(K, y(arguments[1]))), K < 0 && (K = ie + K); K >= 0; K--) if (K in J && J[K] === z) return K || 0;
                  return -1;
                } : k;
              }
            ),
            /***/
            1460: (
              /***/
              function(f, p, d) {
                var m = d(4229), y = d(95), S = d(6358), x = y("species");
                f.exports = function(w) {
                  return S >= 51 || !m(function() {
                    var k = [], O = k.constructor = {};
                    return O[x] = function() {
                      return { foo: 1 };
                    }, k[w](Boolean).foo !== 1;
                  });
                };
              }
            ),
            /***/
            6038: (
              /***/
              function(f, p, d) {
                var m = d(4229);
                f.exports = function(y, S) {
                  var x = [][y];
                  return !!x && m(function() {
                    x.call(null, S || function() {
                      throw 1;
                    }, 1);
                  });
                };
              }
            ),
            /***/
            3143: (
              /***/
              function(f, p, d) {
                var m = d(3819), y = d(2991), S = d(9337), x = d(4237), w = function(k) {
                  return function(O, T, L, j) {
                    m(T);
                    var z = y(O), J = S(z), ie = x(z.length), K = k ? ie - 1 : 0, re = k ? -1 : 1;
                    if (L < 2) for (; ; ) {
                      if (K in J) {
                        j = J[K], K += re;
                        break;
                      }
                      if (K += re, k ? K < 0 : ie <= K)
                        throw TypeError("Reduce of empty array with no initial value");
                    }
                    for (; k ? K >= 0 : ie > K; K += re) K in J && (j = T(j, J[K], K, z));
                    return j;
                  };
                };
                f.exports = {
                  // `Array.prototype.reduce` method
                  // https://tc39.es/ecma262/#sec-array.prototype.reduce
                  left: w(!1),
                  // `Array.prototype.reduceRight` method
                  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
                  right: w(!0)
                };
              }
            ),
            /***/
            7501: (
              /***/
              function(f, p, d) {
                var m = d(5052), y = d(3718), S = d(95), x = S("species");
                f.exports = function(w, k) {
                  var O;
                  return y(w) && (O = w.constructor, typeof O == "function" && (O === Array || y(O.prototype)) ? O = void 0 : m(O) && (O = O[x], O === null && (O = void 0))), new (O === void 0 ? Array : O)(k === 0 ? 0 : k);
                };
              }
            ),
            /***/
            4960: (
              /***/
              function(f, p, d) {
                var m = d(1176), y = d(7281);
                f.exports = function(S, x, w, k) {
                  try {
                    return k ? x(m(w)[0], w[1]) : x(w);
                  } catch (O) {
                    throw y(S), O;
                  }
                };
              }
            ),
            /***/
            4575: (
              /***/
              function(f, p, d) {
                var m = d(95), y = m("iterator"), S = !1;
                try {
                  var x = 0, w = {
                    next: function() {
                      return { done: !!x++ };
                    },
                    return: function() {
                      S = !0;
                    }
                  };
                  w[y] = function() {
                    return this;
                  }, Array.from(w, function() {
                    throw 2;
                  });
                } catch {
                }
                f.exports = function(k, O) {
                  if (!O && !S) return !1;
                  var T = !1;
                  try {
                    var L = {};
                    L[y] = function() {
                      return {
                        next: function() {
                          return { done: T = !0 };
                        }
                      };
                    }, k(L);
                  } catch {
                  }
                  return T;
                };
              }
            ),
            /***/
            7079: (
              /***/
              function(f) {
                var p = {}.toString;
                f.exports = function(d) {
                  return p.call(d).slice(8, -1);
                };
              }
            ),
            /***/
            1589: (
              /***/
              function(f, p, d) {
                var m = d(1601), y = d(7079), S = d(95), x = S("toStringTag"), w = y(/* @__PURE__ */ function() {
                  return arguments;
                }()) == "Arguments", k = function(O, T) {
                  try {
                    return O[T];
                  } catch {
                  }
                };
                f.exports = m ? y : function(O) {
                  var T, L, j;
                  return O === void 0 ? "Undefined" : O === null ? "Null" : typeof (L = k(T = Object(O), x)) == "string" ? L : w ? y(T) : (j = y(T)) == "Object" && typeof T.callee == "function" ? "Arguments" : j;
                };
              }
            ),
            /***/
            8081: (
              /***/
              function(f, p, d) {
                var m = d(1787).f, y = d(2391), S = d(8787), x = d(7636), w = d(7728), k = d(9003), O = d(7675), T = d(1832), L = d(7400), j = d(5926).fastKey, z = d(6407), J = z.set, ie = z.getterFor;
                f.exports = {
                  getConstructor: function(K, re, ee, de) {
                    var Ce = K(function(we, Oe) {
                      w(we, Ce, re), J(we, {
                        type: re,
                        index: y(null),
                        first: void 0,
                        last: void 0,
                        size: 0
                      }), L || (we.size = 0), Oe != null && k(Oe, we[de], { that: we, AS_ENTRIES: ee });
                    }), he = ie(re), oe = function(we, Oe, Qe) {
                      var Me = he(we), Ie = ge(we, Oe), rt, ot;
                      return Ie ? Ie.value = Qe : (Me.last = Ie = {
                        index: ot = j(Oe, !0),
                        key: Oe,
                        value: Qe,
                        previous: rt = Me.last,
                        next: void 0,
                        removed: !1
                      }, Me.first || (Me.first = Ie), rt && (rt.next = Ie), L ? Me.size++ : we.size++, ot !== "F" && (Me.index[ot] = Ie)), we;
                    }, ge = function(we, Oe) {
                      var Qe = he(we), Me = j(Oe), Ie;
                      if (Me !== "F") return Qe.index[Me];
                      for (Ie = Qe.first; Ie; Ie = Ie.next)
                        if (Ie.key == Oe) return Ie;
                    };
                    return S(Ce.prototype, {
                      // 23.1.3.1 Map.prototype.clear()
                      // 23.2.3.2 Set.prototype.clear()
                      clear: function() {
                        for (var Oe = this, Qe = he(Oe), Me = Qe.index, Ie = Qe.first; Ie; )
                          Ie.removed = !0, Ie.previous && (Ie.previous = Ie.previous.next = void 0), delete Me[Ie.index], Ie = Ie.next;
                        Qe.first = Qe.last = void 0, L ? Qe.size = 0 : Oe.size = 0;
                      },
                      // 23.1.3.3 Map.prototype.delete(key)
                      // 23.2.3.4 Set.prototype.delete(value)
                      delete: function(we) {
                        var Oe = this, Qe = he(Oe), Me = ge(Oe, we);
                        if (Me) {
                          var Ie = Me.next, rt = Me.previous;
                          delete Qe.index[Me.index], Me.removed = !0, rt && (rt.next = Ie), Ie && (Ie.previous = rt), Qe.first == Me && (Qe.first = Ie), Qe.last == Me && (Qe.last = rt), L ? Qe.size-- : Oe.size--;
                        }
                        return !!Me;
                      },
                      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
                      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
                      forEach: function(Oe) {
                        for (var Qe = he(this), Me = x(Oe, arguments.length > 1 ? arguments[1] : void 0, 3), Ie; Ie = Ie ? Ie.next : Qe.first; )
                          for (Me(Ie.value, Ie.key, this); Ie && Ie.removed; ) Ie = Ie.previous;
                      },
                      // 23.1.3.7 Map.prototype.has(key)
                      // 23.2.3.7 Set.prototype.has(value)
                      has: function(Oe) {
                        return !!ge(this, Oe);
                      }
                    }), S(Ce.prototype, ee ? {
                      // 23.1.3.6 Map.prototype.get(key)
                      get: function(Oe) {
                        var Qe = ge(this, Oe);
                        return Qe && Qe.value;
                      },
                      // 23.1.3.9 Map.prototype.set(key, value)
                      set: function(Oe, Qe) {
                        return oe(this, Oe === 0 ? 0 : Oe, Qe);
                      }
                    } : {
                      // 23.2.3.1 Set.prototype.add(value)
                      add: function(Oe) {
                        return oe(this, Oe = Oe === 0 ? 0 : Oe, Oe);
                      }
                    }), L && m(Ce.prototype, "size", {
                      get: function() {
                        return he(this).size;
                      }
                    }), Ce;
                  },
                  setStrong: function(K, re, ee) {
                    var de = re + " Iterator", Ce = ie(re), he = ie(de);
                    O(K, re, function(oe, ge) {
                      J(this, {
                        type: de,
                        target: oe,
                        state: Ce(oe),
                        kind: ge,
                        last: void 0
                      });
                    }, function() {
                      for (var oe = he(this), ge = oe.kind, we = oe.last; we && we.removed; ) we = we.previous;
                      return !oe.target || !(oe.last = we = we ? we.next : oe.state.first) ? (oe.target = void 0, { value: void 0, done: !0 }) : ge == "keys" ? { value: we.key, done: !1 } : ge == "values" ? { value: we.value, done: !1 } : { value: [we.key, we.value], done: !1 };
                    }, ee ? "entries" : "values", !ee, !0), T(re);
                  }
                };
              }
            ),
            /***/
            9789: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(9859), S = d(6541), x = d(7487), w = d(5926), k = d(9003), O = d(7728), T = d(5052), L = d(4229), j = d(4575), z = d(4555), J = d(835);
                f.exports = function(ie, K, re) {
                  var ee = ie.indexOf("Map") !== -1, de = ie.indexOf("Weak") !== -1, Ce = ee ? "set" : "add", he = y[ie], oe = he && he.prototype, ge = he, we = {}, Oe = function(gt) {
                    var At = oe[gt];
                    x(
                      oe,
                      gt,
                      gt == "add" ? function(St) {
                        return At.call(this, St === 0 ? 0 : St), this;
                      } : gt == "delete" ? function(Mt) {
                        return de && !T(Mt) ? !1 : At.call(this, Mt === 0 ? 0 : Mt);
                      } : gt == "get" ? function(St) {
                        return de && !T(St) ? void 0 : At.call(this, St === 0 ? 0 : St);
                      } : gt == "has" ? function(St) {
                        return de && !T(St) ? !1 : At.call(this, St === 0 ? 0 : St);
                      } : function(St, Ve) {
                        return At.call(this, St === 0 ? 0 : St, Ve), this;
                      }
                    );
                  }, Qe = S(
                    ie,
                    typeof he != "function" || !(de || oe.forEach && !L(function() {
                      new he().entries().next();
                    }))
                  );
                  if (Qe)
                    ge = re.getConstructor(K, ie, ee, Ce), w.REQUIRED = !0;
                  else if (S(ie, !0)) {
                    var Me = new ge(), Ie = Me[Ce](de ? {} : -0, 1) != Me, rt = L(function() {
                      Me.has(1);
                    }), ot = j(function(gt) {
                      new he(gt);
                    }), Et = !de && L(function() {
                      for (var gt = new he(), At = 5; At--; ) gt[Ce](At, At);
                      return !gt.has(-0);
                    });
                    ot || (ge = K(function(gt, At) {
                      O(gt, ge, ie);
                      var Mt = J(new he(), gt, ge);
                      return At != null && k(At, Mt[Ce], { that: Mt, AS_ENTRIES: ee }), Mt;
                    }), ge.prototype = oe, oe.constructor = ge), (rt || Et) && (Oe("delete"), Oe("has"), ee && Oe("get")), (Et || Ie) && Oe(Ce), de && oe.clear && delete oe.clear;
                  }
                  return we[ie] = ge, m({ global: !0, forced: ge != he }, we), z(ge, ie), de || re.setStrong(ge, ie, ee), ge;
                };
              }
            ),
            /***/
            7081: (
              /***/
              function(f, p, d) {
                var m = d(816), y = d(4826), S = d(7933), x = d(1787);
                f.exports = function(w, k) {
                  for (var O = y(k), T = x.f, L = S.f, j = 0; j < O.length; j++) {
                    var z = O[j];
                    m(w, z) || T(w, z, L(k, z));
                  }
                };
              }
            ),
            /***/
            8127: (
              /***/
              function(f, p, d) {
                var m = d(95), y = m("match");
                f.exports = function(S) {
                  var x = /./;
                  try {
                    "/./"[S](x);
                  } catch {
                    try {
                      return x[y] = !1, "/./"[S](x);
                    } catch {
                    }
                  }
                  return !1;
                };
              }
            ),
            /***/
            7528: (
              /***/
              function(f, p, d) {
                var m = d(4229);
                f.exports = !m(function() {
                  function y() {
                  }
                  return y.prototype.constructor = null, Object.getPrototypeOf(new y()) !== y.prototype;
                });
              }
            ),
            /***/
            1720: (
              /***/
              function(f, p, d) {
                var m = d(8885), y = /"/g;
                f.exports = function(S, x, w, k) {
                  var O = String(m(S)), T = "<" + x;
                  return w !== "" && (T += " " + w + '="' + String(k).replace(y, "&quot;") + '"'), T + ">" + O + "</" + x + ">";
                };
              }
            ),
            /***/
            3723: (
              /***/
              function(f, p, d) {
                var m = d(693).IteratorPrototype, y = d(2391), S = d(5358), x = d(4555), w = d(5495), k = function() {
                  return this;
                };
                f.exports = function(O, T, L) {
                  var j = T + " Iterator";
                  return O.prototype = y(m, { next: S(1, L) }), x(O, j, !1, !0), w[j] = k, O;
                };
              }
            ),
            /***/
            5762: (
              /***/
              function(f, p, d) {
                var m = d(7400), y = d(1787), S = d(5358);
                f.exports = m ? function(x, w, k) {
                  return y.f(x, w, S(1, k));
                } : function(x, w, k) {
                  return x[w] = k, x;
                };
              }
            ),
            /***/
            5358: (
              /***/
              function(f) {
                f.exports = function(p, d) {
                  return {
                    enumerable: !(p & 1),
                    configurable: !(p & 2),
                    writable: !(p & 4),
                    value: d
                  };
                };
              }
            ),
            /***/
            2324: (
              /***/
              function(f, p, d) {
                var m = d(2066), y = d(1787), S = d(5358);
                f.exports = function(x, w, k) {
                  var O = m(w);
                  O in x ? y.f(x, O, S(0, k)) : x[O] = k;
                };
              }
            ),
            /***/
            7675: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(3723), S = d(7567), x = d(6540), w = d(4555), k = d(5762), O = d(7487), T = d(95), L = d(4231), j = d(5495), z = d(693), J = z.IteratorPrototype, ie = z.BUGGY_SAFARI_ITERATORS, K = T("iterator"), re = "keys", ee = "values", de = "entries", Ce = function() {
                  return this;
                };
                f.exports = function(he, oe, ge, we, Oe, Qe, Me) {
                  y(ge, oe, we);
                  var Ie = function(He) {
                    if (He === Oe && At) return At;
                    if (!ie && He in Et) return Et[He];
                    switch (He) {
                      case re:
                        return function() {
                          return new ge(this, He);
                        };
                      case ee:
                        return function() {
                          return new ge(this, He);
                        };
                      case de:
                        return function() {
                          return new ge(this, He);
                        };
                    }
                    return function() {
                      return new ge(this);
                    };
                  }, rt = oe + " Iterator", ot = !1, Et = he.prototype, gt = Et[K] || Et["@@iterator"] || Oe && Et[Oe], At = !ie && gt || Ie(Oe), Mt = oe == "Array" && Et.entries || gt, St, Ve, Ue;
                  if (Mt && (St = S(Mt.call(new he())), J !== Object.prototype && St.next && (!L && S(St) !== J && (x ? x(St, J) : typeof St[K] != "function" && k(St, K, Ce)), w(St, rt, !0, !0), L && (j[rt] = Ce))), Oe == ee && gt && gt.name !== ee && (ot = !0, At = function() {
                    return gt.call(this);
                  }), (!L || Me) && Et[K] !== At && k(Et, K, At), j[oe] = At, Oe)
                    if (Ve = {
                      values: Ie(ee),
                      keys: Qe ? At : Ie(re),
                      entries: Ie(de)
                    }, Me) for (Ue in Ve)
                      (ie || ot || !(Ue in Et)) && O(Et, Ue, Ve[Ue]);
                    else m({ target: oe, proto: !0, forced: ie || ot }, Ve);
                  return Ve;
                };
              }
            ),
            /***/
            8423: (
              /***/
              function(f, p, d) {
                var m = d(9276), y = d(816), S = d(5391), x = d(1787).f;
                f.exports = function(w) {
                  var k = m.Symbol || (m.Symbol = {});
                  y(k, w) || x(k, w, {
                    value: S.f(w)
                  });
                };
              }
            ),
            /***/
            7400: (
              /***/
              function(f, p, d) {
                var m = d(4229);
                f.exports = !m(function() {
                  return Object.defineProperty({}, 1, { get: function() {
                    return 7;
                  } })[1] != 7;
                });
              }
            ),
            /***/
            2635: (
              /***/
              function(f, p, d) {
                var m = d(9859), y = d(5052), S = m.document, x = y(S) && y(S.createElement);
                f.exports = function(w) {
                  return x ? S.createElement(w) : {};
                };
              }
            ),
            /***/
            5694: (
              /***/
              function(f) {
                f.exports = {
                  CSSRuleList: 0,
                  CSSStyleDeclaration: 0,
                  CSSValueList: 0,
                  ClientRectList: 0,
                  DOMRectList: 0,
                  DOMStringList: 0,
                  DOMTokenList: 1,
                  DataTransferItemList: 0,
                  FileList: 0,
                  HTMLAllCollection: 0,
                  HTMLCollection: 0,
                  HTMLFormElement: 0,
                  HTMLSelectElement: 0,
                  MediaList: 0,
                  MimeTypeArray: 0,
                  NamedNodeMap: 0,
                  NodeList: 1,
                  PaintRequestList: 0,
                  Plugin: 0,
                  PluginArray: 0,
                  SVGLengthList: 0,
                  SVGNumberList: 0,
                  SVGPathSegList: 0,
                  SVGPointList: 0,
                  SVGStringList: 0,
                  SVGTransformList: 0,
                  SourceBufferList: 0,
                  StyleSheetList: 0,
                  TextTrackCueList: 0,
                  TextTrackList: 0,
                  TouchList: 0
                };
              }
            ),
            /***/
            8801: (
              /***/
              function(f, p, d) {
                var m = d(7079), y = d(9859);
                f.exports = m(y.process) == "process";
              }
            ),
            /***/
            598: (
              /***/
              function(f, p, d) {
                var m = d(1333);
                f.exports = m("navigator", "userAgent") || "";
              }
            ),
            /***/
            6358: (
              /***/
              function(f, p, d) {
                var m = d(9859), y = d(598), S = m.process, x = S && S.versions, w = x && x.v8, k, O;
                w ? (k = w.split("."), O = k[0] + k[1]) : y && (k = y.match(/Edge\/(\d+)/), (!k || k[1] >= 74) && (k = y.match(/Chrome\/(\d+)/), k && (O = k[1]))), f.exports = O && +O;
              }
            ),
            /***/
            3837: (
              /***/
              function(f) {
                f.exports = [
                  "constructor",
                  "hasOwnProperty",
                  "isPrototypeOf",
                  "propertyIsEnumerable",
                  "toLocaleString",
                  "toString",
                  "valueOf"
                ];
              }
            ),
            /***/
            3103: (
              /***/
              function(f, p, d) {
                var m = d(9859), y = d(7933).f, S = d(5762), x = d(7487), w = d(2079), k = d(7081), O = d(6541);
                f.exports = function(T, L) {
                  var j = T.target, z = T.global, J = T.stat, ie, K, re, ee, de, Ce;
                  if (z ? K = m : J ? K = m[j] || w(j, {}) : K = (m[j] || {}).prototype, K) for (re in L) {
                    if (de = L[re], T.noTargetGet ? (Ce = y(K, re), ee = Ce && Ce.value) : ee = K[re], ie = O(z ? re : j + (J ? "." : "#") + re, T.forced), !ie && ee !== void 0) {
                      if (typeof de == typeof ee) continue;
                      k(de, ee);
                    }
                    (T.sham || ee && ee.sham) && S(de, "sham", !0), x(K, re, de, T);
                  }
                };
              }
            ),
            /***/
            4229: (
              /***/
              function(f) {
                f.exports = function(p) {
                  try {
                    return !!p();
                  } catch {
                    return !0;
                  }
                };
              }
            ),
            /***/
            4954: (
              /***/
              function(f, p, d) {
                d(7950);
                var m = d(7487), y = d(4229), S = d(95), x = d(5762), w = S("species"), k = !y(function() {
                  var z = /./;
                  return z.exec = function() {
                    var J = [];
                    return J.groups = { a: "7" }, J;
                  }, "".replace(z, "$<a>") !== "7";
                }), O = function() {
                  return "a".replace(/./, "$0") === "$0";
                }(), T = S("replace"), L = function() {
                  return /./[T] ? /./[T]("a", "$0") === "" : !1;
                }(), j = !y(function() {
                  var z = /(?:)/, J = z.exec;
                  z.exec = function() {
                    return J.apply(this, arguments);
                  };
                  var ie = "ab".split(z);
                  return ie.length !== 2 || ie[0] !== "a" || ie[1] !== "b";
                });
                f.exports = function(z, J, ie, K) {
                  var re = S(z), ee = !y(function() {
                    var we = {};
                    return we[re] = function() {
                      return 7;
                    }, ""[z](we) != 7;
                  }), de = ee && !y(function() {
                    var we = !1, Oe = /a/;
                    return z === "split" && (Oe = {}, Oe.constructor = {}, Oe.constructor[w] = function() {
                      return Oe;
                    }, Oe.flags = "", Oe[re] = /./[re]), Oe.exec = function() {
                      return we = !0, null;
                    }, Oe[re](""), !we;
                  });
                  if (!ee || !de || z === "replace" && !(k && O && !L) || z === "split" && !j) {
                    var Ce = /./[re], he = ie(re, ""[z], function(we, Oe, Qe, Me, Ie) {
                      return Oe.exec === RegExp.prototype.exec ? ee && !Ie ? { done: !0, value: Ce.call(Oe, Qe, Me) } : { done: !0, value: we.call(Qe, Oe, Me) } : { done: !1 };
                    }, {
                      REPLACE_KEEPS_$0: O,
                      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: L
                    }), oe = he[0], ge = he[1];
                    m(String.prototype, z, oe), m(
                      RegExp.prototype,
                      re,
                      J == 2 ? function(we, Oe) {
                        return ge.call(we, this, Oe);
                      } : function(we) {
                        return ge.call(we, this);
                      }
                    );
                  }
                  K && x(RegExp.prototype[re], "sham", !0);
                };
              }
            ),
            /***/
            4990: (
              /***/
              function(f, p, d) {
                var m = d(3718), y = d(4237), S = d(7636), x = function(w, k, O, T, L, j, z, J) {
                  for (var ie = L, K = 0, re = z ? S(z, J, 3) : !1, ee; K < T; ) {
                    if (K in O) {
                      if (ee = re ? re(O[K], K, k) : O[K], j > 0 && m(ee))
                        ie = x(w, k, ee, y(ee.length), ie, j - 1) - 1;
                      else {
                        if (ie >= 9007199254740991) throw TypeError("Exceed the acceptable array length");
                        w[ie] = ee;
                      }
                      ie++;
                    }
                    K++;
                  }
                  return ie;
                };
                f.exports = x;
              }
            ),
            /***/
            8476: (
              /***/
              function(f, p, d) {
                var m = d(4229);
                f.exports = !m(function() {
                  return Object.isExtensible(Object.preventExtensions({}));
                });
              }
            ),
            /***/
            7636: (
              /***/
              function(f, p, d) {
                var m = d(3819);
                f.exports = function(y, S, x) {
                  if (m(y), S === void 0) return y;
                  switch (x) {
                    case 0:
                      return function() {
                        return y.call(S);
                      };
                    case 1:
                      return function(w) {
                        return y.call(S, w);
                      };
                    case 2:
                      return function(w, k) {
                        return y.call(S, w, k);
                      };
                    case 3:
                      return function(w, k, O) {
                        return y.call(S, w, k, O);
                      };
                  }
                  return function() {
                    return y.apply(S, arguments);
                  };
                };
              }
            ),
            /***/
            4128: (
              /***/
              function(f, p, d) {
                var m = d(3819), y = d(5052), S = [].slice, x = {}, w = function(k, O, T) {
                  if (!(O in x)) {
                    for (var L = [], j = 0; j < O; j++) L[j] = "a[" + j + "]";
                    x[O] = Function("C,a", "return new C(" + L.join(",") + ")");
                  }
                  return x[O](k, T);
                };
                f.exports = Function.bind || function(O) {
                  var T = m(this), L = S.call(arguments, 1), j = function() {
                    var J = L.concat(S.call(arguments));
                    return this instanceof j ? w(T, J.length, J) : T.apply(O, J);
                  };
                  return y(T.prototype) && (j.prototype = T.prototype), j;
                };
              }
            ),
            /***/
            1333: (
              /***/
              function(f, p, d) {
                var m = d(9276), y = d(9859), S = function(x) {
                  return typeof x == "function" ? x : void 0;
                };
                f.exports = function(x, w) {
                  return arguments.length < 2 ? S(m[x]) || S(y[x]) : m[x] && m[x][w] || y[x] && y[x][w];
                };
              }
            ),
            /***/
            8830: (
              /***/
              function(f, p, d) {
                var m = d(1589), y = d(5495), S = d(95), x = S("iterator");
                f.exports = function(w) {
                  if (w != null) return w[x] || w["@@iterator"] || y[m(w)];
                };
              }
            ),
            /***/
            17: (
              /***/
              function(f, p, d) {
                var m = d(2991), y = Math.floor, S = "".replace, x = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, w = /\$([$&'`]|\d{1,2})/g;
                f.exports = function(k, O, T, L, j, z) {
                  var J = T + k.length, ie = L.length, K = w;
                  return j !== void 0 && (j = m(j), K = x), S.call(z, K, function(re, ee) {
                    var de;
                    switch (ee.charAt(0)) {
                      case "$":
                        return "$";
                      case "&":
                        return k;
                      case "`":
                        return O.slice(0, T);
                      case "'":
                        return O.slice(J);
                      case "<":
                        de = j[ee.slice(1, -1)];
                        break;
                      default:
                        var Ce = +ee;
                        if (Ce === 0) return re;
                        if (Ce > ie) {
                          var he = y(Ce / 10);
                          return he === 0 ? re : he <= ie ? L[he - 1] === void 0 ? ee.charAt(1) : L[he - 1] + ee.charAt(1) : re;
                        }
                        de = L[Ce - 1];
                    }
                    return de === void 0 ? "" : de;
                  });
                };
              }
            ),
            /***/
            9859: (
              /***/
              function(f, p, d) {
                var m = function(y) {
                  return y && y.Math == Math && y;
                };
                f.exports = // eslint-disable-next-line es/no-global-this -- safe
                m(typeof globalThis == "object" && globalThis) || m(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
                m(typeof self == "object" && self) || m(typeof d.g == "object" && d.g) || // eslint-disable-next-line no-new-func -- fallback
                /* @__PURE__ */ function() {
                  return this;
                }() || Function("return this")();
              }
            ),
            /***/
            816: (
              /***/
              function(f, p, d) {
                var m = d(2991), y = {}.hasOwnProperty;
                f.exports = function(x, w) {
                  return y.call(m(x), w);
                };
              }
            ),
            /***/
            5977: (
              /***/
              function(f) {
                f.exports = {};
              }
            ),
            /***/
            3777: (
              /***/
              function(f, p, d) {
                var m = d(1333);
                f.exports = m("document", "documentElement");
              }
            ),
            /***/
            4394: (
              /***/
              function(f, p, d) {
                var m = d(7400), y = d(4229), S = d(2635);
                f.exports = !m && !y(function() {
                  return Object.defineProperty(S("div"), "a", {
                    get: function() {
                      return 7;
                    }
                  }).a != 7;
                });
              }
            ),
            /***/
            6201: (
              /***/
              function(f) {
                var p = Math.abs, d = Math.pow, m = Math.floor, y = Math.log, S = Math.LN2, x = function(k, O, T) {
                  var L = new Array(T), j = T * 8 - O - 1, z = (1 << j) - 1, J = z >> 1, ie = O === 23 ? d(2, -24) - d(2, -77) : 0, K = k < 0 || k === 0 && 1 / k < 0 ? 1 : 0, re = 0, ee, de, Ce;
                  for (k = p(k), k != k || k === 1 / 0 ? (de = k != k ? 1 : 0, ee = z) : (ee = m(y(k) / S), k * (Ce = d(2, -ee)) < 1 && (ee--, Ce *= 2), ee + J >= 1 ? k += ie / Ce : k += ie * d(2, 1 - J), k * Ce >= 2 && (ee++, Ce /= 2), ee + J >= z ? (de = 0, ee = z) : ee + J >= 1 ? (de = (k * Ce - 1) * d(2, O), ee = ee + J) : (de = k * d(2, J - 1) * d(2, O), ee = 0)); O >= 8; L[re++] = de & 255, de /= 256, O -= 8) ;
                  for (ee = ee << O | de, j += O; j > 0; L[re++] = ee & 255, ee /= 256, j -= 8) ;
                  return L[--re] |= K * 128, L;
                }, w = function(k, O) {
                  var T = k.length, L = T * 8 - O - 1, j = (1 << L) - 1, z = j >> 1, J = L - 7, ie = T - 1, K = k[ie--], re = K & 127, ee;
                  for (K >>= 7; J > 0; re = re * 256 + k[ie], ie--, J -= 8) ;
                  for (ee = re & (1 << -J) - 1, re >>= -J, J += O; J > 0; ee = ee * 256 + k[ie], ie--, J -= 8) ;
                  if (re === 0)
                    re = 1 - z;
                  else {
                    if (re === j)
                      return ee ? NaN : K ? -1 / 0 : 1 / 0;
                    ee = ee + d(2, O), re = re - z;
                  }
                  return (K ? -1 : 1) * ee * d(2, re - O);
                };
                f.exports = {
                  pack: x,
                  unpack: w
                };
              }
            ),
            /***/
            9337: (
              /***/
              function(f, p, d) {
                var m = d(4229), y = d(7079), S = "".split;
                f.exports = m(function() {
                  return !Object("z").propertyIsEnumerable(0);
                }) ? function(x) {
                  return y(x) == "String" ? S.call(x, "") : Object(x);
                } : Object;
              }
            ),
            /***/
            835: (
              /***/
              function(f, p, d) {
                var m = d(5052), y = d(6540);
                f.exports = function(S, x, w) {
                  var k, O;
                  return (
                    // it can work only with native `setPrototypeOf`
                    y && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
                    typeof (k = x.constructor) == "function" && k !== w && m(O = k.prototype) && O !== w.prototype && y(S, O), S
                  );
                };
              }
            ),
            /***/
            8511: (
              /***/
              function(f, p, d) {
                var m = d(5353), y = Function.toString;
                typeof m.inspectSource != "function" && (m.inspectSource = function(S) {
                  return y.call(S);
                }), f.exports = m.inspectSource;
              }
            ),
            /***/
            5926: (
              /***/
              function(f, p, d) {
                var m = d(5977), y = d(5052), S = d(816), x = d(1787).f, w = d(1441), k = d(8476), O = w("meta"), T = 0, L = Object.isExtensible || function() {
                  return !0;
                }, j = function(re) {
                  x(re, O, { value: {
                    objectID: "O" + ++T,
                    // object ID
                    weakData: {}
                    // weak collections IDs
                  } });
                }, z = function(re, ee) {
                  if (!y(re)) return typeof re == "symbol" ? re : (typeof re == "string" ? "S" : "P") + re;
                  if (!S(re, O)) {
                    if (!L(re)) return "F";
                    if (!ee) return "E";
                    j(re);
                  }
                  return re[O].objectID;
                }, J = function(re, ee) {
                  if (!S(re, O)) {
                    if (!L(re)) return !0;
                    if (!ee) return !1;
                    j(re);
                  }
                  return re[O].weakData;
                }, ie = function(re) {
                  return k && K.REQUIRED && L(re) && !S(re, O) && j(re), re;
                }, K = f.exports = {
                  REQUIRED: !1,
                  fastKey: z,
                  getWeakData: J,
                  onFreeze: ie
                };
                m[O] = !0;
              }
            ),
            /***/
            6407: (
              /***/
              function(f, p, d) {
                var m = d(8694), y = d(9859), S = d(5052), x = d(5762), w = d(816), k = d(5353), O = d(4399), T = d(5977), L = "Object already initialized", j = y.WeakMap, z, J, ie, K = function(ge) {
                  return ie(ge) ? J(ge) : z(ge, {});
                }, re = function(ge) {
                  return function(we) {
                    var Oe;
                    if (!S(we) || (Oe = J(we)).type !== ge)
                      throw TypeError("Incompatible receiver, " + ge + " required");
                    return Oe;
                  };
                };
                if (m) {
                  var ee = k.state || (k.state = new j()), de = ee.get, Ce = ee.has, he = ee.set;
                  z = function(ge, we) {
                    if (Ce.call(ee, ge)) throw new TypeError(L);
                    return we.facade = ge, he.call(ee, ge, we), we;
                  }, J = function(ge) {
                    return de.call(ee, ge) || {};
                  }, ie = function(ge) {
                    return Ce.call(ee, ge);
                  };
                } else {
                  var oe = O("state");
                  T[oe] = !0, z = function(ge, we) {
                    if (w(ge, oe)) throw new TypeError(L);
                    return we.facade = ge, x(ge, oe, we), we;
                  }, J = function(ge) {
                    return w(ge, oe) ? ge[oe] : {};
                  }, ie = function(ge) {
                    return w(ge, oe);
                  };
                }
                f.exports = {
                  set: z,
                  get: J,
                  has: ie,
                  enforce: K,
                  getterFor: re
                };
              }
            ),
            /***/
            1943: (
              /***/
              function(f, p, d) {
                var m = d(95), y = d(5495), S = m("iterator"), x = Array.prototype;
                f.exports = function(w) {
                  return w !== void 0 && (y.Array === w || x[S] === w);
                };
              }
            ),
            /***/
            3718: (
              /***/
              function(f, p, d) {
                var m = d(7079);
                f.exports = Array.isArray || function(S) {
                  return m(S) == "Array";
                };
              }
            ),
            /***/
            6541: (
              /***/
              function(f, p, d) {
                var m = d(4229), y = /#|\.prototype\./, S = function(T, L) {
                  var j = w[x(T)];
                  return j == O ? !0 : j == k ? !1 : typeof L == "function" ? m(L) : !!L;
                }, x = S.normalize = function(T) {
                  return String(T).replace(y, ".").toLowerCase();
                }, w = S.data = {}, k = S.NATIVE = "N", O = S.POLYFILL = "P";
                f.exports = S;
              }
            ),
            /***/
            5052: (
              /***/
              function(f) {
                f.exports = function(p) {
                  return typeof p == "object" ? p !== null : typeof p == "function";
                };
              }
            ),
            /***/
            4231: (
              /***/
              function(f) {
                f.exports = !1;
              }
            ),
            /***/
            8311: (
              /***/
              function(f, p, d) {
                var m = d(5052), y = d(7079), S = d(95), x = S("match");
                f.exports = function(w) {
                  var k;
                  return m(w) && ((k = w[x]) !== void 0 ? !!k : y(w) == "RegExp");
                };
              }
            ),
            /***/
            9003: (
              /***/
              function(f, p, d) {
                var m = d(1176), y = d(1943), S = d(4237), x = d(7636), w = d(8830), k = d(7281), O = function(T, L) {
                  this.stopped = T, this.result = L;
                };
                f.exports = function(T, L, j) {
                  var z = j && j.that, J = !!(j && j.AS_ENTRIES), ie = !!(j && j.IS_ITERATOR), K = !!(j && j.INTERRUPTED), re = x(L, z, 1 + J + K), ee, de, Ce, he, oe, ge, we, Oe = function(Me) {
                    return ee && k(ee), new O(!0, Me);
                  }, Qe = function(Me) {
                    return J ? (m(Me), K ? re(Me[0], Me[1], Oe) : re(Me[0], Me[1])) : K ? re(Me, Oe) : re(Me);
                  };
                  if (ie)
                    ee = T;
                  else {
                    if (de = w(T), typeof de != "function") throw TypeError("Target is not iterable");
                    if (y(de)) {
                      for (Ce = 0, he = S(T.length); he > Ce; Ce++)
                        if (oe = Qe(T[Ce]), oe && oe instanceof O) return oe;
                      return new O(!1);
                    }
                    ee = de.call(T);
                  }
                  for (ge = ee.next; !(we = ge.call(ee)).done; ) {
                    try {
                      oe = Qe(we.value);
                    } catch (Me) {
                      throw k(ee), Me;
                    }
                    if (typeof oe == "object" && oe && oe instanceof O) return oe;
                  }
                  return new O(!1);
                };
              }
            ),
            /***/
            7281: (
              /***/
              function(f, p, d) {
                var m = d(1176);
                f.exports = function(y) {
                  var S = y.return;
                  if (S !== void 0)
                    return m(S.call(y)).value;
                };
              }
            ),
            /***/
            693: (
              /***/
              function(f, p, d) {
                var m = d(4229), y = d(7567), S = d(5762), x = d(816), w = d(95), k = d(4231), O = w("iterator"), T = !1, L = function() {
                  return this;
                }, j, z, J;
                [].keys && (J = [].keys(), "next" in J ? (z = y(y(J)), z !== Object.prototype && (j = z)) : T = !0);
                var ie = j == null || m(function() {
                  var K = {};
                  return j[O].call(K) !== K;
                });
                ie && (j = {}), (!k || ie) && !x(j, O) && S(j, O, L), f.exports = {
                  IteratorPrototype: j,
                  BUGGY_SAFARI_ITERATORS: T
                };
              }
            ),
            /***/
            5495: (
              /***/
              function(f) {
                f.exports = {};
              }
            ),
            /***/
            3839: (
              /***/
              function(f, p, d) {
                var m = d(8801), y = d(6358), S = d(4229);
                f.exports = !!Object.getOwnPropertySymbols && !S(function() {
                  return !Symbol.sham && // Chrome 38 Symbol has incorrect toString conversion
                  // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
                  (m ? y === 38 : y > 37 && y < 41);
                });
              }
            ),
            /***/
            8694: (
              /***/
              function(f, p, d) {
                var m = d(9859), y = d(8511), S = m.WeakMap;
                f.exports = typeof S == "function" && /native code/.test(y(S));
              }
            ),
            /***/
            7272: (
              /***/
              function(f, p, d) {
                var m = d(8311);
                f.exports = function(y) {
                  if (m(y))
                    throw TypeError("The method doesn't accept regular expressions");
                  return y;
                };
              }
            ),
            /***/
            2391: (
              /***/
              function(f, p, d) {
                var m = d(1176), y = d(219), S = d(3837), x = d(5977), w = d(3777), k = d(2635), O = d(4399), T = ">", L = "<", j = "prototype", z = "script", J = O("IE_PROTO"), ie = function() {
                }, K = function(he) {
                  return L + z + T + he + L + "/" + z + T;
                }, re = function(he) {
                  he.write(K("")), he.close();
                  var oe = he.parentWindow.Object;
                  return he = null, oe;
                }, ee = function() {
                  var he = k("iframe"), oe = "java" + z + ":", ge;
                  return he.style.display = "none", w.appendChild(he), he.src = String(oe), ge = he.contentWindow.document, ge.open(), ge.write(K("document.F=Object")), ge.close(), ge.F;
                }, de, Ce = function() {
                  try {
                    de = document.domain && new ActiveXObject("htmlfile");
                  } catch {
                  }
                  Ce = de ? re(de) : ee();
                  for (var he = S.length; he--; ) delete Ce[j][S[he]];
                  return Ce();
                };
                x[J] = !0, f.exports = Object.create || function(oe, ge) {
                  var we;
                  return oe !== null ? (ie[j] = m(oe), we = new ie(), ie[j] = null, we[J] = oe) : we = Ce(), ge === void 0 ? we : y(we, ge);
                };
              }
            ),
            /***/
            219: (
              /***/
              function(f, p, d) {
                var m = d(7400), y = d(1787), S = d(1176), x = d(5632);
                f.exports = m ? Object.defineProperties : function(k, O) {
                  S(k);
                  for (var T = x(O), L = T.length, j = 0, z; L > j; ) y.f(k, z = T[j++], O[z]);
                  return k;
                };
              }
            ),
            /***/
            1787: (
              /***/
              function(f, p, d) {
                var m = d(7400), y = d(4394), S = d(1176), x = d(2066), w = Object.defineProperty;
                p.f = m ? w : function(O, T, L) {
                  if (S(O), T = x(T, !0), S(L), y) try {
                    return w(O, T, L);
                  } catch {
                  }
                  if ("get" in L || "set" in L) throw TypeError("Accessors not supported");
                  return "value" in L && (O[T] = L.value), O;
                };
              }
            ),
            /***/
            7933: (
              /***/
              function(f, p, d) {
                var m = d(7400), y = d(9195), S = d(5358), x = d(905), w = d(2066), k = d(816), O = d(4394), T = Object.getOwnPropertyDescriptor;
                p.f = m ? T : function(j, z) {
                  if (j = x(j), z = w(z, !0), O) try {
                    return T(j, z);
                  } catch {
                  }
                  if (k(j, z)) return S(!y.f.call(j, z), j[z]);
                };
              }
            ),
            /***/
            166: (
              /***/
              function(f, p, d) {
                var m = d(905), y = d(8151).f, S = {}.toString, x = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [], w = function(k) {
                  try {
                    return y(k);
                  } catch {
                    return x.slice();
                  }
                };
                f.exports.f = function(O) {
                  return x && S.call(O) == "[object Window]" ? w(O) : y(m(O));
                };
              }
            ),
            /***/
            8151: (
              /***/
              function(f, p, d) {
                var m = d(140), y = d(3837), S = y.concat("length", "prototype");
                p.f = Object.getOwnPropertyNames || function(w) {
                  return m(w, S);
                };
              }
            ),
            /***/
            894: (
              /***/
              function(f, p) {
                p.f = Object.getOwnPropertySymbols;
              }
            ),
            /***/
            7567: (
              /***/
              function(f, p, d) {
                var m = d(816), y = d(2991), S = d(4399), x = d(7528), w = S("IE_PROTO"), k = Object.prototype;
                f.exports = x ? Object.getPrototypeOf : function(O) {
                  return O = y(O), m(O, w) ? O[w] : typeof O.constructor == "function" && O instanceof O.constructor ? O.constructor.prototype : O instanceof Object ? k : null;
                };
              }
            ),
            /***/
            140: (
              /***/
              function(f, p, d) {
                var m = d(816), y = d(905), S = d(9540).indexOf, x = d(5977);
                f.exports = function(w, k) {
                  var O = y(w), T = 0, L = [], j;
                  for (j in O) !m(x, j) && m(O, j) && L.push(j);
                  for (; k.length > T; ) m(O, j = k[T++]) && (~S(L, j) || L.push(j));
                  return L;
                };
              }
            ),
            /***/
            5632: (
              /***/
              function(f, p, d) {
                var m = d(140), y = d(3837);
                f.exports = Object.keys || function(x) {
                  return m(x, y);
                };
              }
            ),
            /***/
            9195: (
              /***/
              function(f, p) {
                var d = {}.propertyIsEnumerable, m = Object.getOwnPropertyDescriptor, y = m && !d.call({ 1: 2 }, 1);
                p.f = y ? function(x) {
                  var w = m(this, x);
                  return !!w && w.enumerable;
                } : d;
              }
            ),
            /***/
            6540: (
              /***/
              function(f, p, d) {
                var m = d(1176), y = d(8505);
                f.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
                  var S = !1, x = {}, w;
                  try {
                    w = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set, w.call(x, []), S = x instanceof Array;
                  } catch {
                  }
                  return function(O, T) {
                    return m(O), y(T), S ? w.call(O, T) : O.__proto__ = T, O;
                  };
                }() : void 0);
              }
            ),
            /***/
            7664: (
              /***/
              function(f, p, d) {
                var m = d(7400), y = d(5632), S = d(905), x = d(9195).f, w = function(k) {
                  return function(O) {
                    for (var T = S(O), L = y(T), j = L.length, z = 0, J = [], ie; j > z; )
                      ie = L[z++], (!m || x.call(T, ie)) && J.push(k ? [ie, T[ie]] : T[ie]);
                    return J;
                  };
                };
                f.exports = {
                  // `Object.entries` method
                  // https://tc39.es/ecma262/#sec-object.entries
                  entries: w(!0),
                  // `Object.values` method
                  // https://tc39.es/ecma262/#sec-object.values
                  values: w(!1)
                };
              }
            ),
            /***/
            4059: (
              /***/
              function(f, p, d) {
                var m = d(1601), y = d(1589);
                f.exports = m ? {}.toString : function() {
                  return "[object " + y(this) + "]";
                };
              }
            ),
            /***/
            4826: (
              /***/
              function(f, p, d) {
                var m = d(1333), y = d(8151), S = d(894), x = d(1176);
                f.exports = m("Reflect", "ownKeys") || function(k) {
                  var O = y.f(x(k)), T = S.f;
                  return T ? O.concat(T(k)) : O;
                };
              }
            ),
            /***/
            9276: (
              /***/
              function(f, p, d) {
                var m = d(9859);
                f.exports = m;
              }
            ),
            /***/
            8787: (
              /***/
              function(f, p, d) {
                var m = d(7487);
                f.exports = function(y, S, x) {
                  for (var w in S) m(y, w, S[w], x);
                  return y;
                };
              }
            ),
            /***/
            7487: (
              /***/
              function(f, p, d) {
                var m = d(9859), y = d(5762), S = d(816), x = d(2079), w = d(8511), k = d(6407), O = k.get, T = k.enforce, L = String(String).split("String");
                (f.exports = function(j, z, J, ie) {
                  var K = ie ? !!ie.unsafe : !1, re = ie ? !!ie.enumerable : !1, ee = ie ? !!ie.noTargetGet : !1, de;
                  if (typeof J == "function" && (typeof z == "string" && !S(J, "name") && y(J, "name", z), de = T(J), de.source || (de.source = L.join(typeof z == "string" ? z : ""))), j === m) {
                    re ? j[z] = J : x(z, J);
                    return;
                  } else K ? !ee && j[z] && (re = !0) : delete j[z];
                  re ? j[z] = J : y(j, z, J);
                })(Function.prototype, "toString", function() {
                  return typeof this == "function" && O(this).source || w(this);
                });
              }
            ),
            /***/
            8115: (
              /***/
              function(f, p, d) {
                var m = d(7079), y = d(3466);
                f.exports = function(S, x) {
                  var w = S.exec;
                  if (typeof w == "function") {
                    var k = w.call(S, x);
                    if (typeof k != "object")
                      throw TypeError("RegExp exec method returned something other than an Object or null");
                    return k;
                  }
                  if (m(S) !== "RegExp")
                    throw TypeError("RegExp#exec called on incompatible receiver");
                  return y.call(S, x);
                };
              }
            ),
            /***/
            3466: (
              /***/
              function(f, p, d) {
                var m = d(895), y = d(5650), S = d(3036), x = RegExp.prototype.exec, w = S("native-string-replace", String.prototype.replace), k = x, O = function() {
                  var z = /a/, J = /b*/g;
                  return x.call(z, "a"), x.call(J, "a"), z.lastIndex !== 0 || J.lastIndex !== 0;
                }(), T = y.UNSUPPORTED_Y || y.BROKEN_CARET, L = /()??/.exec("")[1] !== void 0, j = O || L || T;
                j && (k = function(J) {
                  var ie = this, K, re, ee, de, Ce = T && ie.sticky, he = m.call(ie), oe = ie.source, ge = 0, we = J;
                  return Ce && (he = he.replace("y", ""), he.indexOf("g") === -1 && (he += "g"), we = String(J).slice(ie.lastIndex), ie.lastIndex > 0 && (!ie.multiline || ie.multiline && J[ie.lastIndex - 1] !== `
`) && (oe = "(?: " + oe + ")", we = " " + we, ge++), re = new RegExp("^(?:" + oe + ")", he)), L && (re = new RegExp("^" + oe + "$(?!\\s)", he)), O && (K = ie.lastIndex), ee = x.call(Ce ? re : ie, we), Ce ? ee ? (ee.input = ee.input.slice(ge), ee[0] = ee[0].slice(ge), ee.index = ie.lastIndex, ie.lastIndex += ee[0].length) : ie.lastIndex = 0 : O && ee && (ie.lastIndex = ie.global ? ee.index + ee[0].length : K), L && ee && ee.length > 1 && w.call(ee[0], re, function() {
                    for (de = 1; de < arguments.length - 2; de++)
                      arguments[de] === void 0 && (ee[de] = void 0);
                  }), ee;
                }), f.exports = k;
              }
            ),
            /***/
            895: (
              /***/
              function(f, p, d) {
                var m = d(1176);
                f.exports = function() {
                  var y = m(this), S = "";
                  return y.global && (S += "g"), y.ignoreCase && (S += "i"), y.multiline && (S += "m"), y.dotAll && (S += "s"), y.unicode && (S += "u"), y.sticky && (S += "y"), S;
                };
              }
            ),
            /***/
            5650: (
              /***/
              function(f, p, d) {
                var m = d(4229);
                function y(S, x) {
                  return RegExp(S, x);
                }
                p.UNSUPPORTED_Y = m(function() {
                  var S = y("a", "y");
                  return S.lastIndex = 2, S.exec("abcd") != null;
                }), p.BROKEN_CARET = m(function() {
                  var S = y("^r", "gy");
                  return S.lastIndex = 2, S.exec("str") != null;
                });
              }
            ),
            /***/
            8885: (
              /***/
              function(f) {
                f.exports = function(p) {
                  if (p == null) throw TypeError("Can't call method on " + p);
                  return p;
                };
              }
            ),
            /***/
            2079: (
              /***/
              function(f, p, d) {
                var m = d(9859), y = d(5762);
                f.exports = function(S, x) {
                  try {
                    y(m, S, x);
                  } catch {
                    m[S] = x;
                  }
                  return x;
                };
              }
            ),
            /***/
            1832: (
              /***/
              function(f, p, d) {
                var m = d(1333), y = d(1787), S = d(95), x = d(7400), w = S("species");
                f.exports = function(k) {
                  var O = m(k), T = y.f;
                  x && O && !O[w] && T(O, w, {
                    configurable: !0,
                    get: function() {
                      return this;
                    }
                  });
                };
              }
            ),
            /***/
            4555: (
              /***/
              function(f, p, d) {
                var m = d(1787).f, y = d(816), S = d(95), x = S("toStringTag");
                f.exports = function(w, k, O) {
                  w && !y(w = O ? w : w.prototype, x) && m(w, x, { configurable: !0, value: k });
                };
              }
            ),
            /***/
            4399: (
              /***/
              function(f, p, d) {
                var m = d(3036), y = d(1441), S = m("keys");
                f.exports = function(x) {
                  return S[x] || (S[x] = y(x));
                };
              }
            ),
            /***/
            5353: (
              /***/
              function(f, p, d) {
                var m = d(9859), y = d(2079), S = "__core-js_shared__", x = m[S] || y(S, {});
                f.exports = x;
              }
            ),
            /***/
            3036: (
              /***/
              function(f, p, d) {
                var m = d(4231), y = d(5353);
                (f.exports = function(S, x) {
                  return y[S] || (y[S] = x !== void 0 ? x : {});
                })("versions", []).push({
                  version: "3.11.3",
                  mode: m ? "pure" : "global",
                  copyright: "© 2021 Denis Pushkarev (zloirock.ru)"
                });
              }
            ),
            /***/
            7942: (
              /***/
              function(f, p, d) {
                var m = d(1176), y = d(3819), S = d(95), x = S("species");
                f.exports = function(w, k) {
                  var O = m(w).constructor, T;
                  return O === void 0 || (T = m(O)[x]) == null ? k : y(T);
                };
              }
            ),
            /***/
            3689: (
              /***/
              function(f, p, d) {
                var m = d(4229);
                f.exports = function(y) {
                  return m(function() {
                    var S = ""[y]('"');
                    return S !== S.toLowerCase() || S.split('"').length > 3;
                  });
                };
              }
            ),
            /***/
            966: (
              /***/
              function(f, p, d) {
                var m = d(6051), y = d(8885), S = function(x) {
                  return function(w, k) {
                    var O = String(y(w)), T = m(k), L = O.length, j, z;
                    return T < 0 || T >= L ? x ? "" : void 0 : (j = O.charCodeAt(T), j < 55296 || j > 56319 || T + 1 === L || (z = O.charCodeAt(T + 1)) < 56320 || z > 57343 ? x ? O.charAt(T) : j : x ? O.slice(T, T + 2) : (j - 55296 << 10) + (z - 56320) + 65536);
                  };
                };
                f.exports = {
                  // `String.prototype.codePointAt` method
                  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
                  codeAt: S(!1),
                  // `String.prototype.at` method
                  // https://github.com/mathiasbynens/String.prototype.at
                  charAt: S(!0)
                };
              }
            ),
            /***/
            3124: (
              /***/
              function(f, p, d) {
                var m = d(6051), y = d(8885);
                f.exports = function(x) {
                  var w = String(y(this)), k = "", O = m(x);
                  if (O < 0 || O == 1 / 0) throw RangeError("Wrong number of repetitions");
                  for (; O > 0; (O >>>= 1) && (w += w)) O & 1 && (k += w);
                  return k;
                };
              }
            ),
            /***/
            1017: (
              /***/
              function(f, p, d) {
                var m = d(8885), y = d(1647), S = "[" + y + "]", x = RegExp("^" + S + S + "*"), w = RegExp(S + S + "*$"), k = function(O) {
                  return function(T) {
                    var L = String(m(T));
                    return O & 1 && (L = L.replace(x, "")), O & 2 && (L = L.replace(w, "")), L;
                  };
                };
                f.exports = {
                  // `String.prototype.{ trimLeft, trimStart }` methods
                  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
                  start: k(1),
                  // `String.prototype.{ trimRight, trimEnd }` methods
                  // https://tc39.es/ecma262/#sec-string.prototype.trimend
                  end: k(2),
                  // `String.prototype.trim` method
                  // https://tc39.es/ecma262/#sec-string.prototype.trim
                  trim: k(3)
                };
              }
            ),
            /***/
            143: (
              /***/
              function(f, p, d) {
                var m = d(7079);
                f.exports = function(y) {
                  if (typeof y != "number" && m(y) != "Number")
                    throw TypeError("Incorrect invocation");
                  return +y;
                };
              }
            ),
            /***/
            3231: (
              /***/
              function(f, p, d) {
                var m = d(6051), y = Math.max, S = Math.min;
                f.exports = function(x, w) {
                  var k = m(x);
                  return k < 0 ? y(k + w, 0) : S(k, w);
                };
              }
            ),
            /***/
            7331: (
              /***/
              function(f, p, d) {
                var m = d(6051), y = d(4237);
                f.exports = function(S) {
                  if (S === void 0) return 0;
                  var x = m(S), w = y(x);
                  if (x !== w) throw RangeError("Wrong length or index");
                  return w;
                };
              }
            ),
            /***/
            905: (
              /***/
              function(f, p, d) {
                var m = d(9337), y = d(8885);
                f.exports = function(S) {
                  return m(y(S));
                };
              }
            ),
            /***/
            6051: (
              /***/
              function(f) {
                var p = Math.ceil, d = Math.floor;
                f.exports = function(m) {
                  return isNaN(m = +m) ? 0 : (m > 0 ? d : p)(m);
                };
              }
            ),
            /***/
            4237: (
              /***/
              function(f, p, d) {
                var m = d(6051), y = Math.min;
                f.exports = function(S) {
                  return S > 0 ? y(m(S), 9007199254740991) : 0;
                };
              }
            ),
            /***/
            2991: (
              /***/
              function(f, p, d) {
                var m = d(8885);
                f.exports = function(y) {
                  return Object(m(y));
                };
              }
            ),
            /***/
            4262: (
              /***/
              function(f, p, d) {
                var m = d(2002);
                f.exports = function(y, S) {
                  var x = m(y);
                  if (x % S) throw RangeError("Wrong offset");
                  return x;
                };
              }
            ),
            /***/
            2002: (
              /***/
              function(f, p, d) {
                var m = d(6051);
                f.exports = function(y) {
                  var S = m(y);
                  if (S < 0) throw RangeError("The argument can't be less than 0");
                  return S;
                };
              }
            ),
            /***/
            2066: (
              /***/
              function(f, p, d) {
                var m = d(5052);
                f.exports = function(y, S) {
                  if (!m(y)) return y;
                  var x, w;
                  if (S && typeof (x = y.toString) == "function" && !m(w = x.call(y)) || typeof (x = y.valueOf) == "function" && !m(w = x.call(y)) || !S && typeof (x = y.toString) == "function" && !m(w = x.call(y))) return w;
                  throw TypeError("Can't convert object to primitive value");
                };
              }
            ),
            /***/
            1601: (
              /***/
              function(f, p, d) {
                var m = d(95), y = m("toStringTag"), S = {};
                S[y] = "z", f.exports = String(S) === "[object z]";
              }
            ),
            /***/
            2574: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(9859), S = d(7400), x = d(8200), w = d(9918), k = d(3816), O = d(7728), T = d(5358), L = d(5762), j = d(4237), z = d(7331), J = d(4262), ie = d(2066), K = d(816), re = d(1589), ee = d(5052), de = d(2391), Ce = d(6540), he = d(8151).f, oe = d(5215), ge = d(9996).forEach, we = d(1832), Oe = d(1787), Qe = d(7933), Me = d(6407), Ie = d(835), rt = Me.get, ot = Me.set, Et = Oe.f, gt = Qe.f, At = Math.round, Mt = y.RangeError, St = k.ArrayBuffer, Ve = k.DataView, Ue = w.NATIVE_ARRAY_BUFFER_VIEWS, He = w.TYPED_ARRAY_TAG, We = w.TypedArray, ze = w.TypedArrayPrototype, at = w.aTypedArrayConstructor, Ye = w.isTypedArray, tt = "BYTES_PER_ELEMENT", wt = "Wrong length", Ft = function(Q, te) {
                  for (var De = 0, nt = te.length, be = new (at(Q))(nt); nt > De; ) be[De] = te[De++];
                  return be;
                }, qe = function(Q, te) {
                  Et(Q, te, { get: function() {
                    return rt(this)[te];
                  } });
                }, pe = function(Q) {
                  var te;
                  return Q instanceof St || (te = re(Q)) == "ArrayBuffer" || te == "SharedArrayBuffer";
                }, _e = function(Q, te) {
                  return Ye(Q) && typeof te != "symbol" && te in Q && String(+te) == String(te);
                }, Xe = function(te, De) {
                  return _e(te, De = ie(De, !0)) ? T(2, te[De]) : gt(te, De);
                }, lt = function(te, De, nt) {
                  return _e(te, De = ie(De, !0)) && ee(nt) && K(nt, "value") && !K(nt, "get") && !K(nt, "set") && !nt.configurable && (!K(nt, "writable") || nt.writable) && (!K(nt, "enumerable") || nt.enumerable) ? (te[De] = nt.value, te) : Et(te, De, nt);
                };
                S ? (Ue || (Qe.f = Xe, Oe.f = lt, qe(ze, "buffer"), qe(ze, "byteOffset"), qe(ze, "byteLength"), qe(ze, "length")), m({ target: "Object", stat: !0, forced: !Ue }, {
                  getOwnPropertyDescriptor: Xe,
                  defineProperty: lt
                }), f.exports = function(Q, te, De) {
                  var nt = Q.match(/\d+$/)[0] / 8, be = Q + (De ? "Clamped" : "") + "Array", G = "get" + Q, V = "set" + Q, ve = y[be], Ne = ve, it = Ne && Ne.prototype, yt = {}, $t = function(Xt, Ae) {
                    var vt = rt(Xt);
                    return vt.view[G](Ae * nt + vt.byteOffset, !0);
                  }, Gt = function(Xt, Ae, vt) {
                    var Ot = rt(Xt);
                    De && (vt = (vt = At(vt)) < 0 ? 0 : vt > 255 ? 255 : vt & 255), Ot.view[V](Ae * nt + Ot.byteOffset, vt, !0);
                  }, Jt = function(Xt, Ae) {
                    Et(Xt, Ae, {
                      get: function() {
                        return $t(this, Ae);
                      },
                      set: function(vt) {
                        return Gt(this, Ae, vt);
                      },
                      enumerable: !0
                    });
                  };
                  Ue ? x && (Ne = te(function(Xt, Ae, vt, Ot) {
                    return O(Xt, Ne, be), Ie(function() {
                      return ee(Ae) ? pe(Ae) ? Ot !== void 0 ? new ve(Ae, J(vt, nt), Ot) : vt !== void 0 ? new ve(Ae, J(vt, nt)) : new ve(Ae) : Ye(Ae) ? Ft(Ne, Ae) : oe.call(Ne, Ae) : new ve(z(Ae));
                    }(), Xt, Ne);
                  }), Ce && Ce(Ne, We), ge(he(ve), function(Xt) {
                    Xt in Ne || L(Ne, Xt, ve[Xt]);
                  }), Ne.prototype = it) : (Ne = te(function(Xt, Ae, vt, Ot) {
                    O(Xt, Ne, be);
                    var Vt = 0, et = 0, ft, $, Se;
                    if (!ee(Ae))
                      Se = z(Ae), $ = Se * nt, ft = new St($);
                    else if (pe(Ae)) {
                      ft = Ae, et = J(vt, nt);
                      var se = Ae.byteLength;
                      if (Ot === void 0) {
                        if (se % nt || ($ = se - et, $ < 0)) throw Mt(wt);
                      } else if ($ = j(Ot) * nt, $ + et > se) throw Mt(wt);
                      Se = $ / nt;
                    } else return Ye(Ae) ? Ft(Ne, Ae) : oe.call(Ne, Ae);
                    for (ot(Xt, {
                      buffer: ft,
                      byteOffset: et,
                      byteLength: $,
                      length: Se,
                      view: new Ve(ft)
                    }); Vt < Se; ) Jt(Xt, Vt++);
                  }), Ce && Ce(Ne, We), it = Ne.prototype = de(ze)), it.constructor !== Ne && L(it, "constructor", Ne), He && L(it, He, be), yt[be] = Ne, m({
                    global: !0,
                    forced: Ne != ve,
                    sham: !Ue
                  }, yt), tt in Ne || L(Ne, tt, nt), tt in it || L(it, tt, nt), we(be);
                }) : f.exports = function() {
                };
              }
            ),
            /***/
            8200: (
              /***/
              function(f, p, d) {
                var m = d(9859), y = d(4229), S = d(4575), x = d(9918).NATIVE_ARRAY_BUFFER_VIEWS, w = m.ArrayBuffer, k = m.Int8Array;
                f.exports = !x || !y(function() {
                  k(1);
                }) || !y(function() {
                  new k(-1);
                }) || !S(function(O) {
                  new k(), new k(null), new k(1.5), new k(O);
                }, !0) || y(function() {
                  return new k(new w(2), 1, void 0).length !== 1;
                });
              }
            ),
            /***/
            8874: (
              /***/
              function(f, p, d) {
                var m = d(9918).aTypedArrayConstructor, y = d(7942);
                f.exports = function(S, x) {
                  for (var w = y(S, S.constructor), k = 0, O = x.length, T = new (m(w))(O); O > k; ) T[k] = x[k++];
                  return T;
                };
              }
            ),
            /***/
            5215: (
              /***/
              function(f, p, d) {
                var m = d(2991), y = d(4237), S = d(8830), x = d(1943), w = d(7636), k = d(9918).aTypedArrayConstructor;
                f.exports = function(T) {
                  var L = m(T), j = arguments.length, z = j > 1 ? arguments[1] : void 0, J = z !== void 0, ie = S(L), K, re, ee, de, Ce, he;
                  if (ie != null && !x(ie))
                    for (Ce = ie.call(L), he = Ce.next, L = []; !(de = he.call(Ce)).done; )
                      L.push(de.value);
                  for (J && j > 2 && (z = w(z, arguments[2], 2)), re = y(L.length), ee = new (k(this))(re), K = 0; re > K; K++)
                    ee[K] = J ? z(L[K], K) : L[K];
                  return ee;
                };
              }
            ),
            /***/
            1441: (
              /***/
              function(f) {
                var p = 0, d = Math.random();
                f.exports = function(m) {
                  return "Symbol(" + String(m === void 0 ? "" : m) + ")_" + (++p + d).toString(36);
                };
              }
            ),
            /***/
            6969: (
              /***/
              function(f, p, d) {
                var m = d(3839);
                f.exports = m && !Symbol.sham && typeof Symbol.iterator == "symbol";
              }
            ),
            /***/
            5391: (
              /***/
              function(f, p, d) {
                var m = d(95);
                p.f = m;
              }
            ),
            /***/
            95: (
              /***/
              function(f, p, d) {
                var m = d(9859), y = d(3036), S = d(816), x = d(1441), w = d(3839), k = d(6969), O = y("wks"), T = m.Symbol, L = k ? T : T && T.withoutSetter || x;
                f.exports = function(j) {
                  return (!S(O, j) || !(w || typeof O[j] == "string")) && (w && S(T, j) ? O[j] = T[j] : O[j] = L("Symbol." + j)), O[j];
                };
              }
            ),
            /***/
            1647: (
              /***/
              function(f) {
                f.exports = `	
\v\f\r                　\u2028\u2029\uFEFF`;
              }
            ),
            /***/
            2994: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(4229), S = d(3816), x = d(1176), w = d(3231), k = d(4237), O = d(7942), T = S.ArrayBuffer, L = S.DataView, j = T.prototype.slice, z = y(function() {
                  return !new T(2).slice(1, void 0).byteLength;
                });
                m({ target: "ArrayBuffer", proto: !0, unsafe: !0, forced: z }, {
                  slice: function(ie, K) {
                    if (j !== void 0 && K === void 0)
                      return j.call(x(this), ie);
                    for (var re = x(this).byteLength, ee = w(ie, re), de = w(K === void 0 ? re : K, re), Ce = new (O(this, T))(k(de - ee)), he = new L(this), oe = new L(Ce), ge = 0; ee < de; )
                      oe.setUint8(ge++, he.getUint8(ee++));
                    return Ce;
                  }
                });
              }
            ),
            /***/
            8178: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(4229), S = d(3718), x = d(5052), w = d(2991), k = d(4237), O = d(2324), T = d(7501), L = d(1460), j = d(95), z = d(6358), J = j("isConcatSpreadable"), ie = 9007199254740991, K = "Maximum allowed index exceeded", re = z >= 51 || !y(function() {
                  var he = [];
                  return he[J] = !1, he.concat()[0] !== he;
                }), ee = L("concat"), de = function(he) {
                  if (!x(he)) return !1;
                  var oe = he[J];
                  return oe !== void 0 ? !!oe : S(he);
                }, Ce = !re || !ee;
                m({ target: "Array", proto: !0, forced: Ce }, {
                  // eslint-disable-next-line no-unused-vars -- required for `.length`
                  concat: function(oe) {
                    var ge = w(this), we = T(ge, 0), Oe = 0, Qe, Me, Ie, rt, ot;
                    for (Qe = -1, Ie = arguments.length; Qe < Ie; Qe++)
                      if (ot = Qe === -1 ? ge : arguments[Qe], de(ot)) {
                        if (rt = k(ot.length), Oe + rt > ie) throw TypeError(K);
                        for (Me = 0; Me < rt; Me++, Oe++) Me in ot && O(we, Oe, ot[Me]);
                      } else {
                        if (Oe >= ie) throw TypeError(K);
                        O(we, Oe++, ot);
                      }
                    return we.length = Oe, we;
                  }
                });
              }
            ),
            /***/
            2656: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(7065), S = d(9736);
                m({ target: "Array", proto: !0 }, {
                  fill: y
                }), S("fill");
              }
            ),
            /***/
            5342: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(9996).filter, S = d(1460), x = S("filter");
                m({ target: "Array", proto: !0, forced: !x }, {
                  filter: function(k) {
                    return y(this, k, arguments.length > 1 ? arguments[1] : void 0);
                  }
                });
              }
            ),
            /***/
            9949: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(9996).findIndex, S = d(9736), x = "findIndex", w = !0;
                x in [] && Array(1)[x](function() {
                  w = !1;
                }), m({ target: "Array", proto: !0, forced: w }, {
                  findIndex: function(O) {
                    return y(this, O, arguments.length > 1 ? arguments[1] : void 0);
                  }
                }), S(x);
              }
            ),
            /***/
            9228: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(9996).find, S = d(9736), x = "find", w = !0;
                x in [] && Array(1)[x](function() {
                  w = !1;
                }), m({ target: "Array", proto: !0, forced: w }, {
                  find: function(O) {
                    return y(this, O, arguments.length > 1 ? arguments[1] : void 0);
                  }
                }), S(x);
              }
            ),
            /***/
            4870: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(4990), S = d(2991), x = d(4237), w = d(3819), k = d(7501);
                m({ target: "Array", proto: !0 }, {
                  flatMap: function(T) {
                    var L = S(this), j = x(L.length), z;
                    return w(T), z = k(L, 0), z.length = y(z, L, L, j, 0, 1, T, arguments.length > 1 ? arguments[1] : void 0), z;
                  }
                });
              }
            ),
            /***/
            7233: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(507), S = d(4575), x = !S(function(w) {
                  Array.from(w);
                });
                m({ target: "Array", stat: !0, forced: x }, {
                  from: y
                });
              }
            ),
            /***/
            9529: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(9540).includes, S = d(9736);
                m({ target: "Array", proto: !0 }, {
                  includes: function(w) {
                    return y(this, w, arguments.length > 1 ? arguments[1] : void 0);
                  }
                }), S("includes");
              }
            ),
            /***/
            5735: (
              /***/
              function(f, p, d) {
                var m = d(905), y = d(9736), S = d(5495), x = d(6407), w = d(7675), k = "Array Iterator", O = x.set, T = x.getterFor(k);
                f.exports = w(Array, "Array", function(L, j) {
                  O(this, {
                    type: k,
                    target: m(L),
                    // target
                    index: 0,
                    // next index
                    kind: j
                    // kind
                  });
                }, function() {
                  var L = T(this), j = L.target, z = L.kind, J = L.index++;
                  return !j || J >= j.length ? (L.target = void 0, { value: void 0, done: !0 }) : z == "keys" ? { value: J, done: !1 } : z == "values" ? { value: j[J], done: !1 } : { value: [J, j[J]], done: !1 };
                }, "values"), S.Arguments = S.Array, y("keys"), y("values"), y("entries");
              }
            ),
            /***/
            6781: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(9337), S = d(905), x = d(6038), w = [].join, k = y != Object, O = x("join", ",");
                m({ target: "Array", proto: !0, forced: k || !O }, {
                  join: function(L) {
                    return w.call(S(this), L === void 0 ? "," : L);
                  }
                });
              }
            ),
            /***/
            3450: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(9996).map, S = d(1460), x = S("map");
                m({ target: "Array", proto: !0, forced: !x }, {
                  map: function(k) {
                    return y(this, k, arguments.length > 1 ? arguments[1] : void 0);
                  }
                });
              }
            ),
            /***/
            2501: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(5052), S = d(3718), x = d(3231), w = d(4237), k = d(905), O = d(2324), T = d(95), L = d(1460), j = L("slice"), z = T("species"), J = [].slice, ie = Math.max;
                m({ target: "Array", proto: !0, forced: !j }, {
                  slice: function(re, ee) {
                    var de = k(this), Ce = w(de.length), he = x(re, Ce), oe = x(ee === void 0 ? Ce : ee, Ce), ge, we, Oe;
                    if (S(de) && (ge = de.constructor, typeof ge == "function" && (ge === Array || S(ge.prototype)) ? ge = void 0 : y(ge) && (ge = ge[z], ge === null && (ge = void 0)), ge === Array || ge === void 0))
                      return J.call(de, he, oe);
                    for (we = new (ge === void 0 ? Array : ge)(ie(oe - he, 0)), Oe = 0; he < oe; he++, Oe++) he in de && O(we, Oe, de[he]);
                    return we.length = Oe, we;
                  }
                });
              }
            ),
            /***/
            9805: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(3231), S = d(6051), x = d(4237), w = d(2991), k = d(7501), O = d(2324), T = d(1460), L = T("splice"), j = Math.max, z = Math.min, J = 9007199254740991, ie = "Maximum allowed length exceeded";
                m({ target: "Array", proto: !0, forced: !L }, {
                  splice: function(re, ee) {
                    var de = w(this), Ce = x(de.length), he = y(re, Ce), oe = arguments.length, ge, we, Oe, Qe, Me, Ie;
                    if (oe === 0 ? ge = we = 0 : oe === 1 ? (ge = 0, we = Ce - he) : (ge = oe - 2, we = z(j(S(ee), 0), Ce - he)), Ce + ge - we > J)
                      throw TypeError(ie);
                    for (Oe = k(de, we), Qe = 0; Qe < we; Qe++)
                      Me = he + Qe, Me in de && O(Oe, Qe, de[Me]);
                    if (Oe.length = we, ge < we) {
                      for (Qe = he; Qe < Ce - we; Qe++)
                        Me = Qe + we, Ie = Qe + ge, Me in de ? de[Ie] = de[Me] : delete de[Ie];
                      for (Qe = Ce; Qe > Ce - we + ge; Qe--) delete de[Qe - 1];
                    } else if (ge > we)
                      for (Qe = Ce - we; Qe > he; Qe--)
                        Me = Qe + we - 1, Ie = Qe + ge - 1, Me in de ? de[Ie] = de[Me] : delete de[Ie];
                    for (Qe = 0; Qe < ge; Qe++)
                      de[Qe + he] = arguments[Qe + 2];
                    return de.length = Ce - we + ge, Oe;
                  }
                });
              }
            ),
            /***/
            3985: (
              /***/
              function(f, p, d) {
                var m = d(9736);
                m("flatMap");
              }
            ),
            /***/
            6936: (
              /***/
              function(f, p, d) {
                var m = d(7400), y = d(1787).f, S = Function.prototype, x = S.toString, w = /^\s*function ([^ (]*)/, k = "name";
                m && !(k in S) && y(S, k, {
                  configurable: !0,
                  get: function() {
                    try {
                      return x.call(this).match(w)[1];
                    } catch {
                      return "";
                    }
                  }
                });
              }
            ),
            /***/
            1245: (
              /***/
              function(f, p, d) {
                var m = d(7400), y = d(9859), S = d(6541), x = d(7487), w = d(816), k = d(7079), O = d(835), T = d(2066), L = d(4229), j = d(2391), z = d(8151).f, J = d(7933).f, ie = d(1787).f, K = d(1017).trim, re = "Number", ee = y[re], de = ee.prototype, Ce = k(j(de)) == re, he = function(Qe) {
                  var Me = T(Qe, !1), Ie, rt, ot, Et, gt, At, Mt, St;
                  if (typeof Me == "string" && Me.length > 2) {
                    if (Me = K(Me), Ie = Me.charCodeAt(0), Ie === 43 || Ie === 45) {
                      if (rt = Me.charCodeAt(2), rt === 88 || rt === 120) return NaN;
                    } else if (Ie === 48) {
                      switch (Me.charCodeAt(1)) {
                        case 66:
                        case 98:
                          ot = 2, Et = 49;
                          break;
                        // fast equal of /^0b[01]+$/i
                        case 79:
                        case 111:
                          ot = 8, Et = 55;
                          break;
                        // fast equal of /^0o[0-7]+$/i
                        default:
                          return +Me;
                      }
                      for (gt = Me.slice(2), At = gt.length, Mt = 0; Mt < At; Mt++)
                        if (St = gt.charCodeAt(Mt), St < 48 || St > Et) return NaN;
                      return parseInt(gt, ot);
                    }
                  }
                  return +Me;
                };
                if (S(re, !ee(" 0o1") || !ee("0b1") || ee("+0x1"))) {
                  for (var oe = function(Me) {
                    var Ie = arguments.length < 1 ? 0 : Me, rt = this;
                    return rt instanceof oe && (Ce ? L(function() {
                      de.valueOf.call(rt);
                    }) : k(rt) != re) ? O(new ee(he(Ie)), rt, oe) : he(Ie);
                  }, ge = m ? z(ee) : (
                    // ES3:
                    "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,fromString,range".split(",")
                  ), we = 0, Oe; ge.length > we; we++)
                    w(ee, Oe = ge[we]) && !w(oe, Oe) && ie(oe, Oe, J(ee, Oe));
                  oe.prototype = de, de.constructor = oe, x(y, re, oe);
                }
              }
            ),
            /***/
            8143: (
              /***/
              function(f, p, d) {
                var m = d(3103);
                m({ target: "Number", stat: !0 }, {
                  MAX_SAFE_INTEGER: 9007199254740991
                });
              }
            ),
            /***/
            2023: (
              /***/
              function(f, p, d) {
                var m = d(3103);
                m({ target: "Number", stat: !0 }, {
                  MIN_SAFE_INTEGER: -9007199254740991
                });
              }
            ),
            /***/
            1321: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(6051), S = d(143), x = d(3124), w = d(4229), k = 1 .toFixed, O = Math.floor, T = function(K, re, ee) {
                  return re === 0 ? ee : re % 2 === 1 ? T(K, re - 1, ee * K) : T(K * K, re / 2, ee);
                }, L = function(K) {
                  for (var re = 0, ee = K; ee >= 4096; )
                    re += 12, ee /= 4096;
                  for (; ee >= 2; )
                    re += 1, ee /= 2;
                  return re;
                }, j = function(K, re, ee) {
                  for (var de = -1, Ce = ee; ++de < 6; )
                    Ce += re * K[de], K[de] = Ce % 1e7, Ce = O(Ce / 1e7);
                }, z = function(K, re) {
                  for (var ee = 6, de = 0; --ee >= 0; )
                    de += K[ee], K[ee] = O(de / re), de = de % re * 1e7;
                }, J = function(K) {
                  for (var re = 6, ee = ""; --re >= 0; )
                    if (ee !== "" || re === 0 || K[re] !== 0) {
                      var de = String(K[re]);
                      ee = ee === "" ? de : ee + x.call("0", 7 - de.length) + de;
                    }
                  return ee;
                }, ie = k && (8e-5.toFixed(3) !== "0.000" || 0.9.toFixed(0) !== "1" || 1.255.toFixed(2) !== "1.25" || 1000000000000000100 .toFixed(0) !== "1000000000000000128") || !w(function() {
                  k.call({});
                });
                m({ target: "Number", proto: !0, forced: ie }, {
                  toFixed: function(re) {
                    var ee = S(this), de = y(re), Ce = [0, 0, 0, 0, 0, 0], he = "", oe = "0", ge, we, Oe, Qe;
                    if (de < 0 || de > 20) throw RangeError("Incorrect fraction digits");
                    if (ee != ee) return "NaN";
                    if (ee <= -1e21 || ee >= 1e21) return String(ee);
                    if (ee < 0 && (he = "-", ee = -ee), ee > 1e-21)
                      if (ge = L(ee * T(2, 69, 1)) - 69, we = ge < 0 ? ee * T(2, -ge, 1) : ee / T(2, ge, 1), we *= 4503599627370496, ge = 52 - ge, ge > 0) {
                        for (j(Ce, 0, we), Oe = de; Oe >= 7; )
                          j(Ce, 1e7, 0), Oe -= 7;
                        for (j(Ce, T(10, Oe, 1), 0), Oe = ge - 1; Oe >= 23; )
                          z(Ce, 8388608), Oe -= 23;
                        z(Ce, 1 << Oe), j(Ce, 1, 1), z(Ce, 2), oe = J(Ce);
                      } else
                        j(Ce, 0, we), j(Ce, 1 << -ge, 0), oe = J(Ce) + x.call("0", de);
                    return de > 0 ? (Qe = oe.length, oe = he + (Qe <= de ? "0." + x.call("0", de - Qe) + oe : oe.slice(0, Qe - de) + "." + oe.slice(Qe - de))) : oe = he + oe, oe;
                  }
                });
              }
            ),
            /***/
            2144: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(8476), S = d(4229), x = d(5052), w = d(5926).onFreeze, k = Object.freeze, O = S(function() {
                  k(1);
                });
                m({ target: "Object", stat: !0, forced: O, sham: !y }, {
                  freeze: function(L) {
                    return k && x(L) ? k(w(L)) : L;
                  }
                });
              }
            ),
            /***/
            8625: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(4229), S = d(905), x = d(7933).f, w = d(7400), k = y(function() {
                  x(1);
                }), O = !w || k;
                m({ target: "Object", stat: !0, forced: O, sham: !w }, {
                  getOwnPropertyDescriptor: function(L, j) {
                    return x(S(L), j);
                  }
                });
              }
            ),
            /***/
            2775: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(7400), S = d(4826), x = d(905), w = d(7933), k = d(2324);
                m({ target: "Object", stat: !0, sham: !y }, {
                  getOwnPropertyDescriptors: function(T) {
                    for (var L = x(T), j = w.f, z = S(L), J = {}, ie = 0, K, re; z.length > ie; )
                      re = j(L, K = z[ie++]), re !== void 0 && k(J, K, re);
                    return J;
                  }
                });
              }
            ),
            /***/
            6928: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(4229), S = d(2991), x = d(7567), w = d(7528), k = y(function() {
                  x(1);
                });
                m({ target: "Object", stat: !0, forced: k, sham: !w }, {
                  getPrototypeOf: function(T) {
                    return x(S(T));
                  }
                });
              }
            ),
            /***/
            4769: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(2991), S = d(5632), x = d(4229), w = x(function() {
                  S(1);
                });
                m({ target: "Object", stat: !0, forced: w }, {
                  keys: function(O) {
                    return S(y(O));
                  }
                });
              }
            ),
            /***/
            2506: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(6540);
                m({ target: "Object", stat: !0 }, {
                  setPrototypeOf: y
                });
              }
            ),
            /***/
            8188: (
              /***/
              function(f, p, d) {
                var m = d(1601), y = d(7487), S = d(4059);
                m || y(Object.prototype, "toString", S, { unsafe: !0 });
              }
            ),
            /***/
            7890: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(7664).values;
                m({ target: "Object", stat: !0 }, {
                  values: function(x) {
                    return y(x);
                  }
                });
              }
            ),
            /***/
            1229: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(1333), S = d(3819), x = d(1176), w = d(5052), k = d(2391), O = d(4128), T = d(4229), L = y("Reflect", "construct"), j = T(function() {
                  function ie() {
                  }
                  return !(L(function() {
                  }, [], ie) instanceof ie);
                }), z = !T(function() {
                  L(function() {
                  });
                }), J = j || z;
                m({ target: "Reflect", stat: !0, forced: J, sham: J }, {
                  construct: function(K, re) {
                    S(K), x(re);
                    var ee = arguments.length < 3 ? K : S(arguments[2]);
                    if (z && !j) return L(K, re, ee);
                    if (K == ee) {
                      switch (re.length) {
                        case 0:
                          return new K();
                        case 1:
                          return new K(re[0]);
                        case 2:
                          return new K(re[0], re[1]);
                        case 3:
                          return new K(re[0], re[1], re[2]);
                        case 4:
                          return new K(re[0], re[1], re[2], re[3]);
                      }
                      var de = [null];
                      return de.push.apply(de, re), new (O.apply(K, de))();
                    }
                    var Ce = ee.prototype, he = k(w(Ce) ? Ce : Object.prototype), oe = Function.apply.call(K, he, re);
                    return w(oe) ? oe : he;
                  }
                });
              }
            ),
            /***/
            4565: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(5052), S = d(1176), x = d(816), w = d(7933), k = d(7567);
                function O(T, L) {
                  var j = arguments.length < 3 ? T : arguments[2], z, J;
                  if (S(T) === j) return T[L];
                  if (z = w.f(T, L)) return x(z, "value") ? z.value : z.get === void 0 ? void 0 : z.get.call(j);
                  if (y(J = k(T))) return O(J, L, j);
                }
                m({ target: "Reflect", stat: !0 }, {
                  get: O
                });
              }
            ),
            /***/
            7368: (
              /***/
              function(f, p, d) {
                var m = d(7400), y = d(9859), S = d(6541), x = d(835), w = d(1787).f, k = d(8151).f, O = d(8311), T = d(895), L = d(5650), j = d(7487), z = d(4229), J = d(6407).enforce, ie = d(1832), K = d(95), re = K("match"), ee = y.RegExp, de = ee.prototype, Ce = /a/g, he = /a/g, oe = new ee(Ce) !== Ce, ge = L.UNSUPPORTED_Y, we = m && S("RegExp", !oe || ge || z(function() {
                  return he[re] = !1, ee(Ce) != Ce || ee(he) == he || ee(Ce, "i") != "/a/i";
                }));
                if (we) {
                  for (var Oe = function(ot, Et) {
                    var gt = this instanceof Oe, At = O(ot), Mt = Et === void 0, St;
                    if (!gt && At && ot.constructor === Oe && Mt)
                      return ot;
                    oe ? At && !Mt && (ot = ot.source) : ot instanceof Oe && (Mt && (Et = T.call(ot)), ot = ot.source), ge && (St = !!Et && Et.indexOf("y") > -1, St && (Et = Et.replace(/y/g, "")));
                    var Ve = x(
                      oe ? new ee(ot, Et) : ee(ot, Et),
                      gt ? this : de,
                      Oe
                    );
                    if (ge && St) {
                      var Ue = J(Ve);
                      Ue.sticky = !0;
                    }
                    return Ve;
                  }, Qe = function(rt) {
                    rt in Oe || w(Oe, rt, {
                      configurable: !0,
                      get: function() {
                        return ee[rt];
                      },
                      set: function(ot) {
                        ee[rt] = ot;
                      }
                    });
                  }, Me = k(ee), Ie = 0; Me.length > Ie; ) Qe(Me[Ie++]);
                  de.constructor = Oe, Oe.prototype = de, j(y, "RegExp", Oe);
                }
                ie("RegExp");
              }
            ),
            /***/
            7950: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(3466);
                m({ target: "RegExp", proto: !0, forced: /./.exec !== y }, {
                  exec: y
                });
              }
            ),
            /***/
            8233: (
              /***/
              function(f, p, d) {
                var m = d(7487), y = d(1176), S = d(4229), x = d(895), w = "toString", k = RegExp.prototype, O = k[w], T = S(function() {
                  return O.call({ source: "a", flags: "b" }) != "/a/b";
                }), L = O.name != w;
                (T || L) && m(RegExp.prototype, w, function() {
                  var z = y(this), J = String(z.source), ie = z.flags, K = String(ie === void 0 && z instanceof RegExp && !("flags" in k) ? x.call(z) : ie);
                  return "/" + J + "/" + K;
                }, { unsafe: !0 });
              }
            ),
            /***/
            3244: (
              /***/
              function(f, p, d) {
                var m = d(9789), y = d(8081);
                f.exports = m("Set", function(S) {
                  return function() {
                    return S(this, arguments.length ? arguments[0] : void 0);
                  };
                }, y);
              }
            ),
            /***/
            1549: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(1720), S = d(3689);
                m({ target: "String", proto: !0, forced: S("anchor") }, {
                  anchor: function(w) {
                    return y(this, "a", "name", w);
                  }
                });
              }
            ),
            /***/
            1235: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(7272), S = d(8885), x = d(8127);
                m({ target: "String", proto: !0, forced: !x("includes") }, {
                  includes: function(k) {
                    return !!~String(S(this)).indexOf(y(k), arguments.length > 1 ? arguments[1] : void 0);
                  }
                });
              }
            ),
            /***/
            8673: (
              /***/
              function(f, p, d) {
                var m = d(966).charAt, y = d(6407), S = d(7675), x = "String Iterator", w = y.set, k = y.getterFor(x);
                S(String, "String", function(O) {
                  w(this, {
                    type: x,
                    string: String(O),
                    index: 0
                  });
                }, function() {
                  var T = k(this), L = T.string, j = T.index, z;
                  return j >= L.length ? { value: void 0, done: !0 } : (z = m(L, j), T.index += z.length, { value: z, done: !1 });
                });
              }
            ),
            /***/
            4069: (
              /***/
              function(f, p, d) {
                var m = d(4954), y = d(1176), S = d(4237), x = d(8885), w = d(6637), k = d(8115);
                m("match", 1, function(O, T, L) {
                  return [
                    // `String.prototype.match` method
                    // https://tc39.es/ecma262/#sec-string.prototype.match
                    function(z) {
                      var J = x(this), ie = z == null ? void 0 : z[O];
                      return ie !== void 0 ? ie.call(z, J) : new RegExp(z)[O](String(J));
                    },
                    // `RegExp.prototype[@@match]` method
                    // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
                    function(j) {
                      var z = L(T, j, this);
                      if (z.done) return z.value;
                      var J = y(j), ie = String(this);
                      if (!J.global) return k(J, ie);
                      var K = J.unicode;
                      J.lastIndex = 0;
                      for (var re = [], ee = 0, de; (de = k(J, ie)) !== null; ) {
                        var Ce = String(de[0]);
                        re[ee] = Ce, Ce === "" && (J.lastIndex = w(ie, S(J.lastIndex), K)), ee++;
                      }
                      return ee === 0 ? null : re;
                    }
                  ];
                });
              }
            ),
            /***/
            5940: (
              /***/
              function(f, p, d) {
                var m = d(4954), y = d(1176), S = d(4237), x = d(6051), w = d(8885), k = d(6637), O = d(17), T = d(8115), L = Math.max, j = Math.min, z = function(J) {
                  return J === void 0 ? J : String(J);
                };
                m("replace", 2, function(J, ie, K, re) {
                  var ee = re.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE, de = re.REPLACE_KEEPS_$0, Ce = ee ? "$" : "$0";
                  return [
                    // `String.prototype.replace` method
                    // https://tc39.es/ecma262/#sec-string.prototype.replace
                    function(oe, ge) {
                      var we = w(this), Oe = oe == null ? void 0 : oe[J];
                      return Oe !== void 0 ? Oe.call(oe, we, ge) : ie.call(String(we), oe, ge);
                    },
                    // `RegExp.prototype[@@replace]` method
                    // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
                    function(he, oe) {
                      if (!ee && de || typeof oe == "string" && oe.indexOf(Ce) === -1) {
                        var ge = K(ie, he, this, oe);
                        if (ge.done) return ge.value;
                      }
                      var we = y(he), Oe = String(this), Qe = typeof oe == "function";
                      Qe || (oe = String(oe));
                      var Me = we.global;
                      if (Me) {
                        var Ie = we.unicode;
                        we.lastIndex = 0;
                      }
                      for (var rt = []; ; ) {
                        var ot = T(we, Oe);
                        if (ot === null || (rt.push(ot), !Me)) break;
                        var Et = String(ot[0]);
                        Et === "" && (we.lastIndex = k(Oe, S(we.lastIndex), Ie));
                      }
                      for (var gt = "", At = 0, Mt = 0; Mt < rt.length; Mt++) {
                        ot = rt[Mt];
                        for (var St = String(ot[0]), Ve = L(j(x(ot.index), Oe.length), 0), Ue = [], He = 1; He < ot.length; He++) Ue.push(z(ot[He]));
                        var We = ot.groups;
                        if (Qe) {
                          var ze = [St].concat(Ue, Ve, Oe);
                          We !== void 0 && ze.push(We);
                          var at = String(oe.apply(void 0, ze));
                        } else
                          at = O(St, Oe, Ve, Ue, We, oe);
                        Ve >= At && (gt += Oe.slice(At, Ve) + at, At = Ve + St.length);
                      }
                      return gt + Oe.slice(At);
                    }
                  ];
                });
              }
            ),
            /***/
            8319: (
              /***/
              function(f, p, d) {
                var m = d(4954), y = d(8311), S = d(1176), x = d(8885), w = d(7942), k = d(6637), O = d(4237), T = d(8115), L = d(3466), j = d(5650), z = j.UNSUPPORTED_Y, J = [].push, ie = Math.min, K = 4294967295;
                m("split", 2, function(re, ee, de) {
                  var Ce;
                  return "abbc".split(/(b)*/)[1] == "c" || // eslint-disable-next-line regexp/no-empty-group -- required for testing
                  "test".split(/(?:)/, -1).length != 4 || "ab".split(/(?:ab)*/).length != 2 || ".".split(/(.?)(.?)/).length != 4 || // eslint-disable-next-line regexp/no-assertion-capturing-group, regexp/no-empty-group -- required for testing
                  ".".split(/()()/).length > 1 || "".split(/.?/).length ? Ce = function(he, oe) {
                    var ge = String(x(this)), we = oe === void 0 ? K : oe >>> 0;
                    if (we === 0) return [];
                    if (he === void 0) return [ge];
                    if (!y(he))
                      return ee.call(ge, he, we);
                    for (var Oe = [], Qe = (he.ignoreCase ? "i" : "") + (he.multiline ? "m" : "") + (he.unicode ? "u" : "") + (he.sticky ? "y" : ""), Me = 0, Ie = new RegExp(he.source, Qe + "g"), rt, ot, Et; (rt = L.call(Ie, ge)) && (ot = Ie.lastIndex, !(ot > Me && (Oe.push(ge.slice(Me, rt.index)), rt.length > 1 && rt.index < ge.length && J.apply(Oe, rt.slice(1)), Et = rt[0].length, Me = ot, Oe.length >= we))); )
                      Ie.lastIndex === rt.index && Ie.lastIndex++;
                    return Me === ge.length ? (Et || !Ie.test("")) && Oe.push("") : Oe.push(ge.slice(Me)), Oe.length > we ? Oe.slice(0, we) : Oe;
                  } : "0".split(void 0, 0).length ? Ce = function(he, oe) {
                    return he === void 0 && oe === 0 ? [] : ee.call(this, he, oe);
                  } : Ce = ee, [
                    // `String.prototype.split` method
                    // https://tc39.es/ecma262/#sec-string.prototype.split
                    function(oe, ge) {
                      var we = x(this), Oe = oe == null ? void 0 : oe[re];
                      return Oe !== void 0 ? Oe.call(oe, we, ge) : Ce.call(String(we), oe, ge);
                    },
                    // `RegExp.prototype[@@split]` method
                    // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
                    //
                    // NOTE: This cannot be properly polyfilled in engines that don't support
                    // the 'y' flag.
                    function(he, oe) {
                      var ge = de(Ce, he, this, oe, Ce !== ee);
                      if (ge.done) return ge.value;
                      var we = S(he), Oe = String(this), Qe = w(we, RegExp), Me = we.unicode, Ie = (we.ignoreCase ? "i" : "") + (we.multiline ? "m" : "") + (we.unicode ? "u" : "") + (z ? "g" : "y"), rt = new Qe(z ? "^(?:" + we.source + ")" : we, Ie), ot = oe === void 0 ? K : oe >>> 0;
                      if (ot === 0) return [];
                      if (Oe.length === 0) return T(rt, Oe) === null ? [Oe] : [];
                      for (var Et = 0, gt = 0, At = []; gt < Oe.length; ) {
                        rt.lastIndex = z ? 0 : gt;
                        var Mt = T(rt, z ? Oe.slice(gt) : Oe), St;
                        if (Mt === null || (St = ie(O(rt.lastIndex + (z ? gt : 0)), Oe.length)) === Et)
                          gt = k(Oe, gt, Me);
                        else {
                          if (At.push(Oe.slice(Et, gt)), At.length === ot) return At;
                          for (var Ve = 1; Ve <= Mt.length - 1; Ve++)
                            if (At.push(Mt[Ve]), At.length === ot) return At;
                          gt = Et = St;
                        }
                      }
                      return At.push(Oe.slice(Et)), At;
                    }
                  ];
                }, z);
              }
            ),
            /***/
            634: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(7400), S = d(9859), x = d(816), w = d(5052), k = d(1787).f, O = d(7081), T = S.Symbol;
                if (y && typeof T == "function" && (!("description" in T.prototype) || // Safari 12 bug
                T().description !== void 0)) {
                  var L = {}, j = function() {
                    var ee = arguments.length < 1 || arguments[0] === void 0 ? void 0 : String(arguments[0]), de = this instanceof j ? new T(ee) : ee === void 0 ? T() : T(ee);
                    return ee === "" && (L[de] = !0), de;
                  };
                  O(j, T);
                  var z = j.prototype = T.prototype;
                  z.constructor = j;
                  var J = z.toString, ie = String(T("test")) == "Symbol(test)", K = /^Symbol\((.*)\)[^)]+$/;
                  k(z, "description", {
                    configurable: !0,
                    get: function() {
                      var ee = w(this) ? this.valueOf() : this, de = J.call(ee);
                      if (x(L, ee)) return "";
                      var Ce = ie ? de.slice(7, -1) : de.replace(K, "$1");
                      return Ce === "" ? void 0 : Ce;
                    }
                  }), m({ global: !0, forced: !0 }, {
                    Symbol: j
                  });
                }
              }
            ),
            /***/
            796: (
              /***/
              function(f, p, d) {
                var m = d(8423);
                m("iterator");
              }
            ),
            /***/
            4115: (
              /***/
              function(f, p, d) {
                var m = d(3103), y = d(9859), S = d(1333), x = d(4231), w = d(7400), k = d(3839), O = d(6969), T = d(4229), L = d(816), j = d(3718), z = d(5052), J = d(1176), ie = d(2991), K = d(905), re = d(2066), ee = d(5358), de = d(2391), Ce = d(5632), he = d(8151), oe = d(166), ge = d(894), we = d(7933), Oe = d(1787), Qe = d(9195), Me = d(5762), Ie = d(7487), rt = d(3036), ot = d(4399), Et = d(5977), gt = d(1441), At = d(95), Mt = d(5391), St = d(8423), Ve = d(4555), Ue = d(6407), He = d(9996).forEach, We = ot("hidden"), ze = "Symbol", at = "prototype", Ye = At("toPrimitive"), tt = Ue.set, wt = Ue.getterFor(ze), Ft = Object[at], qe = y.Symbol, pe = S("JSON", "stringify"), _e = we.f, Xe = Oe.f, lt = oe.f, Q = Qe.f, te = rt("symbols"), De = rt("op-symbols"), nt = rt("string-to-symbol-registry"), be = rt("symbol-to-string-registry"), G = rt("wks"), V = y.QObject, ve = !V || !V[at] || !V[at].findChild, Ne = w && T(function() {
                  return de(Xe({}, "a", {
                    get: function() {
                      return Xe(this, "a", { value: 7 }).a;
                    }
                  })).a != 7;
                }) ? function(et, ft, $) {
                  var Se = _e(Ft, ft);
                  Se && delete Ft[ft], Xe(et, ft, $), Se && et !== Ft && Xe(Ft, ft, Se);
                } : Xe, it = function(et, ft) {
                  var $ = te[et] = de(qe[at]);
                  return tt($, {
                    type: ze,
                    tag: et,
                    description: ft
                  }), w || ($.description = ft), $;
                }, yt = O ? function(et) {
                  return typeof et == "symbol";
                } : function(et) {
                  return Object(et) instanceof qe;
                }, $t = function(ft, $, Se) {
                  ft === Ft && $t(De, $, Se), J(ft);
                  var se = re($, !0);
                  return J(Se), L(te, se) ? (Se.enumerable ? (L(ft, We) && ft[We][se] && (ft[We][se] = !1), Se = de(Se, { enumerable: ee(0, !1) })) : (L(ft, We) || Xe(ft, We, ee(1, {})), ft[We][se] = !0), Ne(ft, se, Se)) : Xe(ft, se, Se);
                }, Gt = function(ft, $) {
                  J(ft);
                  var Se = K($), se = Ce(Se).concat(Ot(Se));
                  return He(se, function(M) {
                    (!w || Xt.call(Se, M)) && $t(ft, M, Se[M]);
                  }), ft;
                }, Jt = function(ft, $) {
                  return $ === void 0 ? de(ft) : Gt(de(ft), $);
                }, Xt = function(ft) {
                  var $ = re(ft, !0), Se = Q.call(this, $);
                  return this === Ft && L(te, $) && !L(De, $) ? !1 : Se || !L(this, $) || !L(te, $) || L(this, We) && this[We][$] ? Se : !0;
                }, Ae = function(ft, $) {
                  var Se = K(ft), se = re($, !0);
                  if (!(Se === Ft && L(te, se) && !L(De, se))) {
                    var M = _e(Se, se);
                    return M && L(te, se) && !(L(Se, We) && Se[We][se]) && (M.enumerable = !0), M;
                  }
                }, vt = function(ft) {
                  var $ = lt(K(ft)), Se = [];
                  return He($, function(se) {
                    !L(te, se) && !L(Et, se) && Se.push(se);
                  }), Se;
                }, Ot = function(ft) {
                  var $ = ft === Ft, Se = lt($ ? De : K(ft)), se = [];
                  return He(Se, function(M) {
                    L(te, M) && (!$ || L(Ft, M)) && se.push(te[M]);
                  }), se;
                };
                if (k || (qe = function() {
                  if (this instanceof qe) throw TypeError("Symbol is not a constructor");
                  var ft = !arguments.length || arguments[0] === void 0 ? void 0 : String(arguments[0]), $ = gt(ft), Se = function(se) {
                    this === Ft && Se.call(De, se), L(this, We) && L(this[We], $) && (this[We][$] = !1), Ne(this, $, ee(1, se));
                  };
                  return w && ve && Ne(Ft, $, { configurable: !0, set: Se }), it($, ft);
                }, Ie(qe[at], "toString", function() {
                  return wt(this).tag;
                }), Ie(qe, "withoutSetter", function(et) {
                  return it(gt(et), et);
                }), Qe.f = Xt, Oe.f = $t, we.f = Ae, he.f = oe.f = vt, ge.f = Ot, Mt.f = function(et) {
                  return it(At(et), et);
                }, w && (Xe(qe[at], "description", {
                  configurable: !0,
                  get: function() {
                    return wt(this).description;
                  }
                }), x || Ie(Ft, "propertyIsEnumerable", Xt, { unsafe: !0 }))), m({ global: !0, wrap: !0, forced: !k, sham: !k }, {
                  Symbol: qe
                }), He(Ce(G), function(et) {
                  St(et);
                }), m({ target: ze, stat: !0, forced: !k }, {
                  // `Symbol.for` method
                  // https://tc39.es/ecma262/#sec-symbol.for
                  for: function(et) {
                    var ft = String(et);
                    if (L(nt, ft)) return nt[ft];
                    var $ = qe(ft);
                    return nt[ft] = $, be[$] = ft, $;
                  },
                  // `Symbol.keyFor` method
                  // https://tc39.es/ecma262/#sec-symbol.keyfor
                  keyFor: function(ft) {
                    if (!yt(ft)) throw TypeError(ft + " is not a symbol");
                    if (L(be, ft)) return be[ft];
                  },
                  useSetter: function() {
                    ve = !0;
                  },
                  useSimple: function() {
                    ve = !1;
                  }
                }), m({ target: "Object", stat: !0, forced: !k, sham: !w }, {
                  // `Object.create` method
                  // https://tc39.es/ecma262/#sec-object.create
                  create: Jt,
                  // `Object.defineProperty` method
                  // https://tc39.es/ecma262/#sec-object.defineproperty
                  defineProperty: $t,
                  // `Object.defineProperties` method
                  // https://tc39.es/ecma262/#sec-object.defineproperties
                  defineProperties: Gt,
                  // `Object.getOwnPropertyDescriptor` method
                  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
                  getOwnPropertyDescriptor: Ae
                }), m({ target: "Object", stat: !0, forced: !k }, {
                  // `Object.getOwnPropertyNames` method
                  // https://tc39.es/ecma262/#sec-object.getownpropertynames
                  getOwnPropertyNames: vt,
                  // `Object.getOwnPropertySymbols` method
                  // https://tc39.es/ecma262/#sec-object.getownpropertysymbols
                  getOwnPropertySymbols: Ot
                }), m({ target: "Object", stat: !0, forced: T(function() {
                  ge.f(1);
                }) }, {
                  getOwnPropertySymbols: function(ft) {
                    return ge.f(ie(ft));
                  }
                }), pe) {
                  var Vt = !k || T(function() {
                    var et = qe();
                    return pe([et]) != "[null]" || pe({ a: et }) != "{}" || pe(Object(et)) != "{}";
                  });
                  m({ target: "JSON", stat: !0, forced: Vt }, {
                    // eslint-disable-next-line no-unused-vars -- required for `.length`
                    stringify: function(ft, $, Se) {
                      for (var se = [ft], M = 1, ne; arguments.length > M; ) se.push(arguments[M++]);
                      if (ne = $, !(!z($) && ft === void 0 || yt(ft)))
                        return j($) || ($ = function(ce, X) {
                          if (typeof ne == "function" && (X = ne.call(this, ce, X)), !yt(X)) return X;
                        }), se[1] = $, pe.apply(null, se);
                    }
                  });
                }
                qe[at][Ye] || Me(qe[at], Ye, qe[at].valueOf), Ve(qe, ze), Et[We] = !0;
              }
            ),
            /***/
            5825: (
              /***/
              function(f, p, d) {
                var m = d(9918), y = d(7154), S = m.aTypedArray, x = m.exportTypedArrayMethod;
                x("copyWithin", function(k, O) {
                  return y.call(S(this), k, O, arguments.length > 2 ? arguments[2] : void 0);
                });
              }
            ),
            /***/
            7170: (
              /***/
              function(f, p, d) {
                var m = d(9918), y = d(9996).every, S = m.aTypedArray, x = m.exportTypedArrayMethod;
                x("every", function(k) {
                  return y(S(this), k, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            8857: (
              /***/
              function(f, p, d) {
                var m = d(9918), y = d(7065), S = m.aTypedArray, x = m.exportTypedArrayMethod;
                x("fill", function(k) {
                  return y.apply(S(this), arguments);
                });
              }
            ),
            /***/
            8329: (
              /***/
              function(f, p, d) {
                var m = d(9918), y = d(9996).filter, S = d(8874), x = m.aTypedArray, w = m.exportTypedArrayMethod;
                w("filter", function(O) {
                  var T = y(x(this), O, arguments.length > 1 ? arguments[1] : void 0);
                  return S(this, T);
                });
              }
            ),
            /***/
            427: (
              /***/
              function(f, p, d) {
                var m = d(9918), y = d(9996).findIndex, S = m.aTypedArray, x = m.exportTypedArrayMethod;
                x("findIndex", function(k) {
                  return y(S(this), k, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            6279: (
              /***/
              function(f, p, d) {
                var m = d(9918), y = d(9996).find, S = m.aTypedArray, x = m.exportTypedArrayMethod;
                x("find", function(k) {
                  return y(S(this), k, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            1159: (
              /***/
              function(f, p, d) {
                var m = d(9918), y = d(9996).forEach, S = m.aTypedArray, x = m.exportTypedArrayMethod;
                x("forEach", function(k) {
                  y(S(this), k, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            2516: (
              /***/
              function(f, p, d) {
                var m = d(9918), y = d(9540).includes, S = m.aTypedArray, x = m.exportTypedArrayMethod;
                x("includes", function(k) {
                  return y(S(this), k, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            4349: (
              /***/
              function(f, p, d) {
                var m = d(9918), y = d(9540).indexOf, S = m.aTypedArray, x = m.exportTypedArrayMethod;
                x("indexOf", function(k) {
                  return y(S(this), k, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            5273: (
              /***/
              function(f, p, d) {
                var m = d(9859), y = d(9918), S = d(5735), x = d(95), w = x("iterator"), k = m.Uint8Array, O = S.values, T = S.keys, L = S.entries, j = y.aTypedArray, z = y.exportTypedArrayMethod, J = k && k.prototype[w], ie = !!J && (J.name == "values" || J.name == null), K = function() {
                  return O.call(j(this));
                };
                z("entries", function() {
                  return L.call(j(this));
                }), z("keys", function() {
                  return T.call(j(this));
                }), z("values", K, !ie), z(w, K, !ie);
              }
            ),
            /***/
            6729: (
              /***/
              function(f, p, d) {
                var m = d(9918), y = m.aTypedArray, S = m.exportTypedArrayMethod, x = [].join;
                S("join", function(k) {
                  return x.apply(y(this), arguments);
                });
              }
            ),
            /***/
            1801: (
              /***/
              function(f, p, d) {
                var m = d(9918), y = d(6462), S = m.aTypedArray, x = m.exportTypedArrayMethod;
                x("lastIndexOf", function(k) {
                  return y.apply(S(this), arguments);
                });
              }
            ),
            /***/
            574: (
              /***/
              function(f, p, d) {
                var m = d(9918), y = d(9996).map, S = d(7942), x = m.aTypedArray, w = m.aTypedArrayConstructor, k = m.exportTypedArrayMethod;
                k("map", function(T) {
                  return y(x(this), T, arguments.length > 1 ? arguments[1] : void 0, function(L, j) {
                    return new (w(S(L, L.constructor)))(j);
                  });
                });
              }
            ),
            /***/
            9271: (
              /***/
              function(f, p, d) {
                var m = d(9918), y = d(3143).right, S = m.aTypedArray, x = m.exportTypedArrayMethod;
                x("reduceRight", function(k) {
                  return y(S(this), k, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            5787: (
              /***/
              function(f, p, d) {
                var m = d(9918), y = d(3143).left, S = m.aTypedArray, x = m.exportTypedArrayMethod;
                x("reduce", function(k) {
                  return y(S(this), k, arguments.length, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            3160: (
              /***/
              function(f, p, d) {
                var m = d(9918), y = m.aTypedArray, S = m.exportTypedArrayMethod, x = Math.floor;
                S("reverse", function() {
                  for (var k = this, O = y(k).length, T = x(O / 2), L = 0, j; L < T; )
                    j = k[L], k[L++] = k[--O], k[O] = j;
                  return k;
                });
              }
            ),
            /***/
            5688: (
              /***/
              function(f, p, d) {
                var m = d(9918), y = d(4237), S = d(4262), x = d(2991), w = d(4229), k = m.aTypedArray, O = m.exportTypedArrayMethod, T = w(function() {
                  new Int8Array(1).set({});
                });
                O("set", function(j) {
                  k(this);
                  var z = S(arguments.length > 1 ? arguments[1] : void 0, 1), J = this.length, ie = x(j), K = y(ie.length), re = 0;
                  if (K + z > J) throw RangeError("Wrong length");
                  for (; re < K; ) this[z + re] = ie[re++];
                }, T);
              }
            ),
            /***/
            3157: (
              /***/
              function(f, p, d) {
                var m = d(9918), y = d(7942), S = d(4229), x = m.aTypedArray, w = m.aTypedArrayConstructor, k = m.exportTypedArrayMethod, O = [].slice, T = S(function() {
                  new Int8Array(1).slice();
                });
                k("slice", function(j, z) {
                  for (var J = O.call(x(this), j, z), ie = y(this, this.constructor), K = 0, re = J.length, ee = new (w(ie))(re); re > K; ) ee[K] = J[K++];
                  return ee;
                }, T);
              }
            ),
            /***/
            3333: (
              /***/
              function(f, p, d) {
                var m = d(9918), y = d(9996).some, S = m.aTypedArray, x = m.exportTypedArrayMethod;
                x("some", function(k) {
                  return y(S(this), k, arguments.length > 1 ? arguments[1] : void 0);
                });
              }
            ),
            /***/
            315: (
              /***/
              function(f, p, d) {
                var m = d(9918), y = m.aTypedArray, S = m.exportTypedArrayMethod, x = [].sort;
                S("sort", function(k) {
                  return x.call(y(this), k);
                });
              }
            ),
            /***/
            8314: (
              /***/
              function(f, p, d) {
                var m = d(9918), y = d(4237), S = d(3231), x = d(7942), w = m.aTypedArray, k = m.exportTypedArrayMethod;
                k("subarray", function(T, L) {
                  var j = w(this), z = j.length, J = S(T, z);
                  return new (x(j, j.constructor))(
                    j.buffer,
                    j.byteOffset + J * j.BYTES_PER_ELEMENT,
                    y((L === void 0 ? z : S(L, z)) - J)
                  );
                });
              }
            ),
            /***/
            556: (
              /***/
              function(f, p, d) {
                var m = d(9859), y = d(9918), S = d(4229), x = m.Int8Array, w = y.aTypedArray, k = y.exportTypedArrayMethod, O = [].toLocaleString, T = [].slice, L = !!x && S(function() {
                  O.call(new x(1));
                }), j = S(function() {
                  return [1, 2].toLocaleString() != new x([1, 2]).toLocaleString();
                }) || !S(function() {
                  x.prototype.toLocaleString.call([1, 2]);
                });
                k("toLocaleString", function() {
                  return O.apply(L ? T.call(w(this)) : w(this), arguments);
                }, j);
              }
            ),
            /***/
            9224: (
              /***/
              function(f, p, d) {
                var m = d(9918).exportTypedArrayMethod, y = d(4229), S = d(9859), x = S.Uint8Array, w = x && x.prototype || {}, k = [].toString, O = [].join;
                y(function() {
                  k.call({});
                }) && (k = function() {
                  return O.call(this);
                });
                var T = w.toString != k;
                m("toString", k, T);
              }
            ),
            /***/
            3675: (
              /***/
              function(f, p, d) {
                var m = d(2574);
                m("Uint8", function(y) {
                  return function(x, w, k) {
                    return y(this, x, w, k);
                  };
                });
              }
            ),
            /***/
            1939: (
              /***/
              function(f, p, d) {
                var m = d(9859), y = d(5694), S = d(6570), x = d(5762);
                for (var w in y) {
                  var k = m[w], O = k && k.prototype;
                  if (O && O.forEach !== S) try {
                    x(O, "forEach", S);
                  } catch {
                    O.forEach = S;
                  }
                }
              }
            ),
            /***/
            6886: (
              /***/
              function(f, p, d) {
                var m = d(9859), y = d(5694), S = d(5735), x = d(5762), w = d(95), k = w("iterator"), O = w("toStringTag"), T = S.values;
                for (var L in y) {
                  var j = m[L], z = j && j.prototype;
                  if (z) {
                    if (z[k] !== T) try {
                      x(z, k, T);
                    } catch {
                      z[k] = T;
                    }
                    if (z[O] || x(z, O, L), y[L]) {
                      for (var J in S)
                        if (z[J] !== S[J]) try {
                          x(z, J, S[J]);
                        } catch {
                          z[J] = S[J];
                        }
                    }
                  }
                }
              }
            )
            /******/
          }, s = {};
          function l(f) {
            var p = s[f];
            if (p !== void 0)
              return p.exports;
            var d = s[f] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            return r[f](d, d.exports, l), d.exports;
          }
          (function() {
            l.d = function(f, p) {
              for (var d in p)
                l.o(p, d) && !l.o(f, d) && Object.defineProperty(f, d, { enumerable: !0, get: p[d] });
            };
          })(), function() {
            l.g = function() {
              if (typeof globalThis == "object") return globalThis;
              try {
                return this || new Function("return this")();
              } catch {
                if (typeof window == "object") return window;
              }
            }();
          }(), function() {
            l.o = function(f, p) {
              return Object.prototype.hasOwnProperty.call(f, p);
            };
          }(), function() {
            l.r = function(f) {
              typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(f, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(f, "__esModule", { value: !0 });
            };
          }();
          var c = {};
          return function() {
            l.d(c, {
              default: function() {
                return (
                  /* binding */
                  Pn
                );
              }
            });
            var f = {};
            l.r(f), l.d(f, {
              DEFAULT_LABEL_TEXT: function() {
                return _i;
              },
              bubbleLabel: function() {
                return $a;
              },
              label: function() {
                return Ni;
              },
              labelStyle: function() {
                return gs;
              },
              strokeLabelStyle: function() {
                return ys;
              }
            });
            var p = {};
            l.r(p), l.d(p, {
              arc: function() {
                return Hr;
              },
              circle: function() {
                return Rr;
              },
              clipRectArea: function() {
                return er;
              },
              line: function() {
                return Wr;
              },
              pathRect: function() {
                return hr;
              },
              rect: function() {
                return cn;
              }
            });
            var d = {};
            l.r(d), l.d(d, {
              TICK_SIZE: function() {
                return Ur;
              },
              tick: function() {
                return Ho;
              }
            });
            var m = {};
            l.r(m), l.d(m, {
              dataLabel: function() {
                return sO;
              },
              drawBubbleLabel: function() {
                return Ey;
              },
              getBubbleArrowPoints: function() {
                return rv;
              }
            });
            var y = {};
            l.r(y), l.d(y, {
              SPECTRUM_LEGEND_LABEL_HEIGHT: function() {
                return wo;
              },
              spectrumLegend: function() {
                return yO;
              },
              spectrumLegendBar: function() {
                return Ta;
              },
              spectrumLegendTooltip: function() {
                return Aa;
              },
              spectrumTooltip: function() {
                return bO;
              }
            });
            var S = {};
            l.r(S), l.d(S, {
              polygon: function() {
                return cv;
              }
            });
            var x = {};
            l.r(x), l.d(x, {
              scatterSeries: function() {
                return Gy;
              }
            });
            var w = {};
            l.r(w), l.d(w, {
              LEGEND_CHECKBOX_SIZE: function() {
                return Ui;
              },
              LEGEND_ICON_SIZE: function() {
                return Nl;
              },
              LEGEND_ITEM_MARGIN_X: function() {
                return Zs;
              },
              LEGEND_MARGIN_X: function() {
                return $i;
              },
              getLegendItemHeight: function() {
                return wf;
              },
              legend: function() {
                return TC;
              }
            });
            var k = {};
            l.r(k), l.d(k, {
              areaPoints: function() {
                return om;
              },
              linePoints: function() {
                return C0;
              }
            });
            var O = {};
            l.r(O), l.d(O, {
              exportMenuButton: function() {
                return lD;
              }
            });
            var T = {};
            l.r(T), l.d(T, {
              backButton: function() {
                return fD;
              },
              resetButton: function() {
                return dD;
              }
            });
            var L = {};
            l.r(L), l.d(L, {
              sector: function() {
                return ID;
              }
            });
            var j = {};
            l.r(j), l.d(j, {
              circleLegend: function() {
                return gN;
              }
            });
            var z = {};
            l.r(z), l.d(z, {
              boxPlot: function() {
                return _F;
              }
            });
            var J = {};
            l.r(J), l.d(J, {
              clockHand: function() {
                return Uz;
              }
            }), l(2506), l(6928), l(1229), l(4565), l(8625), l(4769), l(4115), l(5342), l(1939), l(2775), l(634), l(8188), l(796), l(5735), l(8673), l(6886), l(3450), l(8178), l(7233), l(2501), l(6936), l(7950), l(8319), l(9805), l(9529), l(9949), l(1245), l(9228), l(1321);
            function ie(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function K(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? ie(Object(a), !0).forEach(function(o) {
                  re(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : ie(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function re(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function ee(t, n) {
              var a = typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"];
              if (!a) {
                if (Array.isArray(t) || (a = de(t)) || n) {
                  a && (t = a);
                  var o = 0, u = function() {
                  };
                  return { s: u, n: function() {
                    return o >= t.length ? { done: !0 } : { done: !1, value: t[o++] };
                  }, e: function(C) {
                    throw C;
                  }, f: u };
                }
                throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
              }
              var h = !0, v = !1, g;
              return { s: function() {
                a = a.call(t);
              }, n: function() {
                var C = a.next();
                return h = C.done, C;
              }, e: function(C) {
                v = !0, g = C;
              }, f: function() {
                try {
                  !h && a.return != null && a.return();
                } finally {
                  if (v) throw g;
                }
              } };
            }
            function de(t, n) {
              if (t) {
                if (typeof t == "string") return Ce(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return Ce(t, n);
              }
            }
            function Ce(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function he(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? he = function(a) {
                return typeof a;
              } : he = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, he(t);
            }
            function oe(t) {
              return !we(t) && !Oe(t);
            }
            function ge(t) {
              return t instanceof Date;
            }
            function we(t) {
              return typeof t > "u";
            }
            function Oe(t) {
              return t === null;
            }
            function Qe(t) {
              return typeof t == "boolean";
            }
            function Me(t) {
              return typeof t == "number";
            }
            function Ie(t) {
              return typeof t == "string";
            }
            function rt(t) {
              return Me(t) && isFinite(t) && Math.floor(t) === t;
            }
            function ot(t) {
              return he(t) === "object" && t !== null;
            }
            function Et(t) {
              return typeof t == "function";
            }
            function gt(t, n) {
              for (var a in t)
                t.hasOwnProperty(a) && n(t[a], a);
            }
            function At(t, n) {
              for (var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, o = 0, u = t.length; o < u && n.call(a, t[o], o, t) !== !1; o += 1)
                ;
            }
            function Mt(t, n, a) {
              we(n) && (n = t || 0, t = 0), a = a || 1;
              var o = [];
              if (n) {
                var u = a < 0 ? -1 : 1;
                for (n *= u; t * u < n; t += a)
                  o.push(t);
              }
              return o;
            }
            function St(t) {
              var n = [];
              try {
                n = Array.prototype.slice.call(t);
              } catch {
                At(t, function(o) {
                  n.push(o);
                });
              }
              return n;
            }
            function Ve(t, n, a) {
              var o = ee(t), u;
              try {
                for (o.s(); !(u = o.n()).done; ) {
                  var h = u.value;
                  if (h === n)
                    return !0;
                }
              } catch (v) {
                o.e(v);
              } finally {
                o.f();
              }
              return !1;
            }
            function Ue(t) {
              for (var n = arguments.length, a = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)
                a[o - 1] = arguments[o];
              var u = {};
              return Object.keys(t).forEach(function(h) {
                Ve(a, h) && (u[h] = t[h]);
              }), u;
            }
            function He(t) {
              for (var n = arguments.length, a = new Array(n > 1 ? n - 1 : 0), o = 1; o < n; o++)
                a[o - 1] = arguments[o];
              var u = {};
              return Object.keys(t).forEach(function(h) {
                Ve(a, h) || (u[h] = t[h]);
              }), u;
            }
            function We(t, n) {
              var a = n.length;
              if (a)
                for (var o = 0; o < a; o += 1) {
                  if (we(t) || Oe(t))
                    return null;
                  t = t[n[o]];
                }
              return t;
            }
            function ze(t, n) {
              var a = n.length;
              if (a)
                for (var o = 0; o < a; o += 1)
                  we(t[n[o]]) && (t[n[o]] = {}), t = t[n[o]];
              return t;
            }
            function at(t) {
              var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, a;
              function o() {
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                window.clearTimeout(a), a = window.setTimeout(function() {
                  t.apply(void 0, h);
                }, n);
              }
              return o;
            }
            function Ye(t, n) {
              var a = K({}, t);
              return Object.keys(n).forEach(function(o) {
                ot(a[o]) ? Array.isArray(n[o]) ? a[o] = tt(n[o]) : a.hasOwnProperty(o) ? a[o] = Ye(a[o], n[o]) : a[o] = wt(n[o]) : a[o] = n[o];
              }), a;
            }
            function tt(t) {
              return t.map(function(n) {
                return ot(n) ? Array.isArray(n) ? tt(n) : wt(n) : n;
              });
            }
            function wt(t) {
              var n = {}, a = Object.keys(t);
              return a.length ? (a.forEach(function(o) {
                ot(t[o]) ? n[o] = Array.isArray(t[o]) ? tt(t[o]) : wt(t[o]) : n[o] = t[o];
              }), n) : t;
            }
            function Ft(t, n) {
              return rt(t) ? Number(t) - Number(n) : new Date(t).getTime() - new Date(n).getTime();
            }
            function qe(t, n) {
              return t - n;
            }
            function pe(t) {
              return t.length ? t[0] : void 0;
            }
            function _e(t) {
              return t.length ? t[t.length - 1] : void 0;
            }
            function Xe() {
              var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
              return t.some(function(n) {
                return Number(n) < 0;
              });
            }
            function lt(t) {
              return t.reduce(function(n, a) {
                return n + a;
              }, 0);
            }
            function Q(t) {
              return t.every(function(n) {
                return Number(n) >= 0;
              });
            }
            function te(t) {
              return t.every(function(n) {
                return Number(n) <= 0;
              });
            }
            function De(t) {
              return t == null ? void 0 : t.find(function(n) {
                return n !== null;
              });
            }
            function nt(t) {
              return Number(t.substr(0, t.length - 1));
            }
            function be(t, n) {
              return Me(n) ? n : Number((t * nt(n) / 100).toFixed(2));
            }
            function G(t) {
              return Me(t) ? t : 0;
            }
            function V(t) {
              return t === "auto";
            }
            var ve = {
              SELECT_SERIES_API_SELECTABLE_ERROR: "It works only when the selectable option is true.",
              SELECT_SERIES_API_INDEX_ERROR: "The index value is invalid.",
              ALREADY_OBSERVABLE_ERROR: "Source object is observable already",
              CIRCLE_LEGEND_RENDER_ERROR: "circleLegend is only possible when bubble series is present",
              noDataError: function(n) {
                return "There's no ".concat(n, " data!");
              },
              noBrushError: function(n) {
                return "Brush don't exist in painter: ".concat(n);
              },
              DASH_SEGMENTS_UNAVAILABLE_ERROR: "DashSegments option is available from IE11 and above.",
              SERIES_INDEX_ERROR: "The seriesIndex value is invalid",
              AUTO_LAYOUT_CONTAINER_SIZE_ERROR: 'To use auto layout, the width or height of the container must be specified as a value such as "%" or "vh", "vw".'
            };
            function Ne(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Ne = function(a) {
                return typeof a;
              } : Ne = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Ne(t);
            }
            var it = null, yt = null, $t = [], Gt = !1;
            function Jt(t) {
              var n = function a() {
                yt !== a && (Gt || !Oe(yt) ? ($t.includes(a) && $t.splice($t.indexOf(a), 1), $t.push(a)) : Oe(yt) && (yt = a, t(), yt = null, Xt()));
              };
              return n.deps = [], it = n, it(), it = null, function() {
                n.deps.forEach(function(a) {
                  var o = a.findIndex(function(u) {
                    return u === n;
                  });
                  a.splice(o, 1);
                }), n.deps = [];
              };
            }
            function Xt() {
              if ($t.length) {
                var t = $t.shift();
                t && t();
              }
            }
            function Ae(t) {
              return Ne(t) === "object" && t.__toastUIChartOb__;
            }
            function vt(t) {
              var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t;
              if (Ae(n))
                throw new Error(ve.ALREADY_OBSERVABLE_ERROR);
              Ae(t) || Object.defineProperty(t, "__toastUIChartOb__", {
                enumerable: !1
              });
              var a = function(v) {
                if (!n.hasOwnProperty(v))
                  return "continue";
                var g = [], b = n[v], C = Object.getOwnPropertyDescriptor(n, v), R = C && C.get, I = C && C.set;
                Object.defineProperty(t, v, {
                  configurable: !0,
                  enumerable: !0,
                  get: function() {
                    return it === Se ? {
                      target: t,
                      key: v,
                      value: b,
                      obs: g
                    } : (!Gt && it && !g.includes(it) && (g.push(it), it.deps.push(g)), b);
                  },
                  set: function(Z) {
                    var ue = b;
                    I ? (I.call(t, Z), b = R ? R.call(t) : t[v]) : b = Z, ue !== b && $(g);
                  }
                }), Ne(t[v]) === "object" && !Array.isArray(t[v]) && vt(t[v]);
              };
              for (var o in n)
                var u = a(o);
              return t;
            }
            function Ot(t, n) {
              if (Ae(n))
                throw new Error(ve.ALREADY_OBSERVABLE_ERROR);
              return vt(t, n);
            }
            function Vt(t, n) {
              var a = Se(t, n);
              a && $(a.obs);
            }
            function et(t) {
              Gt = !0, t(), Gt = !1, Xt();
            }
            function ft(t, n) {
              var a = n.split("."), o = a.splice(a.length - 1, 1)[0], u = We(t, a);
              u && Vt(u, o);
            }
            function $(t) {
              t.forEach(function(n) {
                return n();
              });
            }
            function Se(t, n) {
              it = Se;
              var a = t[n];
              return it = null, Ne(a) === "object" && a.hasOwnProperty("target") && a.hasOwnProperty("obs") ? a : null;
            }
            function se(t, n, a) {
              var o, u = {};
              Object.defineProperty(u, n, {
                configurable: !0,
                enumerable: !0,
                get: function() {
                  return o;
                }
              }), Ot(t, u), Jt(function() {
                var h = o;
                o = a(), h !== o && (t[n] = o);
              });
            }
            function M(t, n, a) {
              var o = n.split("."), u = o.splice(o.length - 1, 1)[0], h = We(t, o);
              if (!h)
                return null;
              var v = Se(h, u);
              if (!v)
                return null;
              var g = function() {
                a(h[u]);
              };
              return v.obs.push(g), function() {
                var b = v.obs.findIndex(function(C) {
                  return C === g;
                });
                b > -1 && v.obs.splice(b, 1);
              };
            }
            function ne(t) {
              return JSON.parse(JSON.stringify(t));
            }
            function ce(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? ce = function(a) {
                return typeof a;
              } : ce = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, ce(t);
            }
            function X(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function Re(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function Ge(t, n, a) {
              return n && Re(t.prototype, n), t;
            }
            function pt(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var xt = /* @__PURE__ */ function() {
              function t(n) {
                X(this, t), pt(this, "state", void 0), pt(this, "initStoreState", void 0), pt(this, "computed", {}), pt(this, "actions", {}), this.initStoreState = wt(n), this.setRootState({});
              }
              return Ge(t, [{
                key: "setRootState",
                value: function(a) {
                  vt(a), this.state = a;
                }
              }, {
                key: "setComputed",
                value: function(a, o) {
                  var u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.computed, h = a.split("."), v = h.splice(h.length - 1, 1)[0], g = ze(u, h);
                  se(g, v, o.bind(null, this.state, this.computed));
                }
              }, {
                key: "setWatch",
                value: function(a, o) {
                  return M(this, a, o);
                }
              }, {
                key: "setAction",
                value: function(a, o) {
                  this.actions[a] = o;
                }
              }, {
                key: "dispatch",
                value: function(a, o, u) {
                  var h = this;
                  u ? et(function() {
                    h.actions[a].call(h, h, o);
                  }) : this.actions[a].call(this, this, o);
                }
              }, {
                key: "observe",
                value: function(a) {
                  return Jt(a.bind(this, this.state, this.computed));
                }
              }, {
                key: "observable",
                value: function(a) {
                  return vt(a);
                }
              }, {
                key: "notifyByPath",
                value: function(a) {
                  ft(this, a);
                }
              }, {
                key: "notify",
                value: function(a, o) {
                  Vt(a, o);
                }
              }, {
                key: "setModule",
                value: function(a, o) {
                  var u = this;
                  if (o || (o = a, a = o.name), o.state) {
                    var h = typeof o.state == "function" ? o.state(this.initStoreState) : o.state;
                    Pt(this.state, h);
                  }
                  o.computed && gt(o.computed, function(v, g) {
                    u.setComputed(g, v);
                  }), o.watch && gt(o.watch, function(v, g) {
                    u.setWatch(g, v);
                  }), o.action && gt(o.action, function(v, g) {
                    u.setAction(g, v);
                  }), o.observe && gt(o.observe, function(v) {
                    u.observe(v);
                  });
                }
              }, {
                key: "setValue",
                value: function(a, o, u) {
                  Pt(a, pt({}, o, u));
                }
              }]), t;
            }();
            function Pt(t, n) {
              var a = {};
              for (var o in n)
                n.hasOwnProperty(o) && (we(t[o]) ? a[o] = n[o] : ce(n[o]) === "object" && !Array.isArray(n[o]) ? Pt(t[o], n[o]) : t[o] = n[o]);
              Object.keys(a).length && Ot(t, a);
            }
            function Yt(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function gr(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? Yt(Object(a), !0).forEach(function(o) {
                  dr(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : Yt(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function dr(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function It(t, n) {
              var a = n.width, o = n.height;
              return {
                width: a === 0 ? t.offsetWidth : a,
                height: o === 0 ? t.offsetHeight : o
              };
            }
            var ct = {
              name: "root",
              state: function(n) {
                var a, o, u, h, v = n.options;
                return {
                  chart: gr(gr({}, v.chart), {}, {
                    width: G(v == null || (a = v.chart) === null || a === void 0 ? void 0 : a.width),
                    height: G(v == null || (o = v.chart) === null || o === void 0 ? void 0 : o.height)
                  }),
                  usingContainerSize: {
                    width: V(v == null || (u = v.chart) === null || u === void 0 ? void 0 : u.width),
                    height: V(v == null || (h = v.chart) === null || h === void 0 ? void 0 : h.height)
                  },
                  container: {}
                };
              },
              action: {
                setChartSize: function(n, a) {
                  var o = n.state;
                  o.chart.width = a.width, o.chart.height = a.height, this.notify(o, "chart");
                },
                initChartSize: function(n, a) {
                  var o = this, u = n.state, h = u.chart, v = h.width, g = h.height;
                  (v === 0 || g === 0) && (a.parentNode ? this.dispatch("setChartSize", It(a, {
                    width: v,
                    height: g
                  })) : setTimeout(function() {
                    o.dispatch("setChartSize", It(a, {
                      width: v,
                      height: g
                    }));
                  }, 0));
                },
                setUsingContainerSize: function(n, a) {
                  var o = n.state, u = a.width, h = a.height;
                  o.usingContainerSize.width = u, o.usingContainerSize.height = h;
                }
              }
            }, zt = ct;
            l(3244), l(4069), l(2656), l(5940), l(8233);
            function xe(t, n) {
              return Te(t) || fe(t, n) || _(t, n) || ae();
            }
            function ae() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function _(t, n) {
              if (t) {
                if (typeof t == "string") return U(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return U(t, n);
              }
            }
            function U(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function fe(t, n) {
              var a = t && (typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]);
              if (a != null) {
                var o = [], u = !0, h = !1, v, g;
                try {
                  for (a = a.call(t); !(u = (v = a.next()).done) && (o.push(v.value), !(n && o.length === n)); u = !0)
                    ;
                } catch (b) {
                  h = !0, g = b;
                } finally {
                  try {
                    !u && a.return != null && a.return();
                  } finally {
                    if (h) throw g;
                  }
                }
                return o;
              }
            }
            function Te(t) {
              if (Array.isArray(t)) return t;
            }
            var Be = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i, Je = /rgb\((\d{1,3}), ?(\d{1,3}), ?(\d{1,3})\)/, Ct = /rgba\((\d{1,3}), ?(\d{1,3}), ?(\d{1,3}), ?(1|0?\.?\d+)\)/, jt = {
              aliceblue: "#f0f8ff",
              antiquewhite: "#faebd7",
              aqua: "#00ffff",
              aquamarine: "#7fffd4",
              azure: "#f0ffff",
              beige: "#f5f5dc",
              bisque: "#ffe4c4",
              black: "#000000",
              blanchedalmond: "#ffebcd",
              blue: "#0000ff",
              blueviolet: "#8a2be2",
              brown: "#a52a2a",
              burlywood: "#deb887",
              cadetblue: "#5f9ea0",
              chartreuse: "#7fff00",
              chocolate: "#d2691e",
              coral: "#ff7f50",
              cornflowerblue: "#6495ed",
              cornsilk: "#fff8dc",
              crimson: "#dc143c",
              cyan: "#00ffff",
              darkblue: "#00008b",
              darkcyan: "#008b8b",
              darkgoldenrod: "#b8860b",
              darkgray: "#a9a9a9",
              darkgreen: "#006400",
              darkkhaki: "#bdb76b",
              darkmagenta: "#8b008b",
              darkolivegreen: "#556b2f",
              darkorange: "#ff8c00",
              darkorchid: "#9932cc",
              darkred: "#8b0000",
              darksalmon: "#e9967a",
              darkseagreen: "#8fbc8f",
              darkslateblue: "#483d8b",
              darkslategray: "#2f4f4f",
              darkturquoise: "#00ced1",
              darkviolet: "#9400d3",
              deeppink: "#ff1493",
              deepskyblue: "#00bfff",
              dimgray: "#696969",
              dodgerblue: "#1e90ff",
              firebrick: "#b22222",
              floralwhite: "#fffaf0",
              forestgreen: "#228b22",
              fuchsia: "#ff00ff",
              gainsboro: "#dcdcdc",
              ghostwhite: "#f8f8ff",
              gold: "#ffd700",
              goldenrod: "#daa520",
              gray: "#808080",
              green: "#008000",
              greenyellow: "#adff2f",
              honeydew: "#f0fff0",
              hotpink: "#ff69b4",
              indianred: "#cd5c5c",
              indigo: "#4b0082",
              ivory: "#fffff0",
              khaki: "#f0e68c",
              lavender: "#e6e6fa",
              lavenderblush: "#fff0f5",
              lawngreen: "#7cfc00",
              lemonchiffon: "#fffacd",
              lightblue: "#add8e6",
              lightcoral: "#f08080",
              lightcyan: "#e0ffff",
              lightgoldenrodyellow: "#fafad2",
              lightgrey: "#d3d3d3",
              lightgreen: "#90ee90",
              lightpink: "#ffb6c1",
              lightsalmon: "#ffa07a",
              lightseagreen: "#20b2aa",
              lightskyblue: "#87cefa",
              lightslategray: "#778899",
              lightsteelblue: "#b0c4de",
              lightyellow: "#ffffe0",
              lime: "#00ff00",
              limegreen: "#32cd32",
              linen: "#faf0e6",
              magenta: "#ff00ff",
              maroon: "#800000",
              mediumaquamarine: "#66cdaa",
              mediumblue: "#0000cd",
              mediumorchid: "#ba55d3",
              mediumpurple: "#9370d8",
              mediumseagreen: "#3cb371",
              mediumslateblue: "#7b68ee",
              mediumspringgreen: "#00fa9a",
              mediumturquoise: "#48d1cc",
              mediumvioletred: "#c71585",
              midnightblue: "#191970",
              mintcream: "#f5fffa",
              mistyrose: "#ffe4e1",
              moccasin: "#ffe4b5",
              navajowhite: "#ffdead",
              navy: "#000080",
              oldlace: "#fdf5e6",
              olive: "#808000",
              olivedrab: "#6b8e23",
              orange: "#ffa500",
              orangered: "#ff4500",
              orchid: "#da70d6",
              palegoldenrod: "#eee8aa",
              palegreen: "#98fb98",
              paleturquoise: "#afeeee",
              palevioletred: "#d87093",
              papayawhip: "#ffefd5",
              peachpuff: "#ffdab9",
              peru: "#cd853f",
              pink: "#ffc0cb",
              plum: "#dda0dd",
              powderblue: "#b0e0e6",
              purple: "#800080",
              red: "#ff0000",
              rosybrown: "#bc8f8f",
              royalblue: "#4169e1",
              saddlebrown: "#8b4513",
              salmon: "#fa8072",
              sandybrown: "#f4a460",
              seagreen: "#2e8b57",
              seashell: "#fff5ee",
              sienna: "#a0522d",
              silver: "#c0c0c0",
              skyblue: "#87ceeb",
              slateblue: "#6a5acd",
              slategray: "#708090",
              snow: "#fffafa",
              springgreen: "#00ff7f",
              steelblue: "#4682b4",
              tan: "#d2b48c",
              teal: "#008080",
              thistle: "#d8bfd8",
              tomato: "#ff6347",
              turquoise: "#40e0d0",
              violet: "#ee82ee",
              wheat: "#f5deb3",
              white: "#ffffff",
              whitesmoke: "#f5f5f5",
              yellow: "#ffff00",
              yellowgreen: "#9acd32"
            };
            function tr(t, n) {
              if (t.length > n)
                return t;
              var a = t;
              return Mt(0, n - 1).forEach(function(o) {
                a = "0" + a;
              }), a.slice(n * -1);
            }
            function Kt(t) {
              return Be.test(t);
            }
            function rr(t) {
              return jt[t.toLowerCase()] || t;
            }
            // @license RGB <-> HSV conversion utilities based off of http://www.cs.rit.edu/~ncs/color/t_convert.html
            function kr(t) {
              var n = rr(t);
              return Kt(n) ? n.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, function(a, o, u, h) {
                return "#" + o + o + u + u + h + h;
              }).substring(1).match(/.{2}/g).map(function(a) {
                return parseInt(a, 16);
              }) : !1;
            }
            function on(t, n, a) {
              var o = "#", u = o + tr(t.toString(16), 2) + tr(n.toString(16), 2) + tr(a.toString(16), 2);
              return Kt(u) ? u : !1;
            }
            function cr(t, n) {
              var a = rr(t);
              if (Kt(a)) {
                var o = kr(a), u = xe(o, 3), h = u[0], v = u[1], g = u[2];
                return "rgba(".concat(h, ", ").concat(v, ", ").concat(g, ", ").concat(n, ")");
              }
              if (Je.test(t)) {
                var b = Je.exec(t);
                return "rgba(".concat(b[1], ", ").concat(b[2], ", ").concat(b[3], ", ").concat(n, ")");
              }
              if (Ct.test(t)) {
                var C = Ct.exec(t);
                return "rgba(".concat(C[1], ", ").concat(C[2], ", ").concat(C[3], ", ").concat(n, ")");
              }
              return t;
            }
            function An(t) {
              if (Ct.test(t)) {
                var n = Ct.exec(t);
                return Number(n[4]);
              }
              return 1;
            }
            function ei(t) {
              var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, a = An(t) * n;
              return cr(t, a);
            }
            function bi(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function wa(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? bi(Object(a), !0).forEach(function(o) {
                  Di(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : bi(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function Di(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function Pi(t, n) {
              return t.reduce(function(a, o) {
                return Ie(o) ? wa(wa({}, a), n[o]) : wa(wa({}, a), o);
              }, {});
            }
            function Bo(t, n) {
              return "translate(".concat(t, "px,").concat(n, "px)");
            }
            function an(t) {
              var n = t.fontFamily, a = t.fontSize, o = t.fontWeight;
              return "".concat(o, " ").concat(a, "px ").concat(n);
            }
            function En(t) {
              var n = t.color, a = t.fontSize, o = t.fontFamily, u = t.fontWeight;
              return "font-weight: ".concat(u, "; font-family: ").concat(o, "; font-size: ").concat(a, "px; color: ").concat(n, ";");
            }
            function Si(t) {
              return an(Ue(t, "fontFamily", "fontWeight", "fontSize"));
            }
            function ta(t, n) {
              t.setLineDash && t.setLineDash(n);
            }
            function Fo(t) {
              return Math.floor(t * 0.15);
            }
            function Li(t, n) {
              t.fillStyle = n, t.fill();
            }
            function Ii(t, n) {
              var a = n.lineWidth, o = n.strokeStyle;
              o && (t.strokeStyle = o), a && (t.lineWidth = a), t.lineWidth && An(String(t.strokeStyle)) && t.stroke();
            }
            var _i = "normal 11px Arial", gs = {
              default: {
                font: _i,
                fillStyle: "#333333",
                textAlign: "left",
                textBaseline: "middle"
              },
              title: {
                textBaseline: "top"
              },
              axisTitle: {
                textBaseline: "top"
              },
              rectLabel: {
                font: _i,
                fillStyle: "rgba(0, 0, 0, 0.3)",
                textAlign: "center",
                textBaseline: "middle"
              }
            }, ys = {
              none: {
                lineWidth: 1,
                strokeStyle: "rgba(255, 255, 255, 0)"
              },
              stroke: {
                lineWidth: 4,
                strokeStyle: "rgba(255, 255, 255, 0.5)"
              }
            };
            function Ni(t, n) {
              var a = n.x, o = n.y, u = n.text, h = n.style, v = n.stroke, g = n.opacity, b = n.radian, C = n.rotationPosition;
              if (h) {
                var R = Pi(h, gs);
                Object.keys(R).forEach(function(Le) {
                  t[Le] = Le === "fillStyle" && Me(g) ? ei(R[Le], g) : R[Le];
                });
              }
              if (t.save(), b) {
                var I, W, Z, ue;
                t.translate((I = C == null ? void 0 : C.x) !== null && I !== void 0 ? I : a, (W = C == null ? void 0 : C.y) !== null && W !== void 0 ? W : o), t.rotate(b), t.translate(-((Z = C == null ? void 0 : C.x) !== null && Z !== void 0 ? Z : a), -((ue = C == null ? void 0 : C.y) !== null && ue !== void 0 ? ue : o));
              }
              if (v) {
                var ke = Pi(v, ys), Ee = Object.keys(ke);
                Ee.forEach(function(Le) {
                  t[Le] = Le === "strokeStyle" && Me(g) ? ei(ke[Le], g) : ke[Le];
                }), Ee.length && t.strokeText(u, a, o);
              }
              t.fillText(u, a, o), t.restore();
            }
            var Fn = {
              shadow: {
                shadowColor: "rgba(0, 0, 0, 0.3)",
                shadowOffsetY: 2,
                shadowBlur: 4
              }
            };
            function $a(t, n) {
              var a = n.radian, o = a === void 0 ? 0 : a, u = n.rotationPosition, h = n.bubble, v = h.x, g = h.y, b = h.width, C = h.height, R = h.radius, I = R === void 0 ? 0 : R, W = h.lineWidth, Z = W === void 0 ? 1 : W, ue = h.direction, ke = h.points, Ee = ke === void 0 ? [] : ke, Le = h.fill, je = Le === void 0 ? "#fff" : Le, Ke = h.strokeStyle, ut = Ke === void 0 ? "rgba(0, 0, 0, 0)" : Ke, bt = h.style, mt = bt === void 0 ? null : bt;
              if (b > 0 && C > 0) {
                var Rt, Dt;
                Bi(t, {
                  x: v,
                  y: g,
                  radius: I,
                  width: b,
                  height: C,
                  style: mt,
                  fill: je,
                  strokeStyle: ut,
                  lineWidth: Z,
                  direction: ue,
                  points: Ee,
                  radian: o,
                  rotationPosition: {
                    x: (Rt = u == null ? void 0 : u.x) !== null && Rt !== void 0 ? Rt : v,
                    y: (Dt = u == null ? void 0 : u.y) !== null && Dt !== void 0 ? Dt : g
                  }
                });
              }
              if (n.label.text) {
                var Lt = n.label, Wt = Lt.x, Qt = Lt.y, or = Lt.text, lr = Lt.strokeStyle, xr = lr === void 0 ? "rgba(0, 0, 0, 0)" : lr, br = Lt.style;
                t.shadowColor = "rgba(0, 0, 0, 0)", Ni(t, {
                  x: Wt,
                  y: Qt,
                  text: or,
                  style: br,
                  stroke: [{
                    strokeStyle: xr
                  }],
                  radian: o,
                  rotationPosition: u
                });
              }
            }
            function ra(t, n) {
              n.length && (t.lineTo(n[0].x, n[0].y), t.lineTo(n[1].x, n[1].y), t.lineTo(n[2].x, n[2].y));
            }
            function Bi(t, n) {
              var a = n.x, o = n.y, u = n.width, h = n.height, v = n.style, g = n.radius, b = g === void 0 ? 0 : g, C = n.strokeStyle, R = n.fill, I = n.lineWidth, W = I === void 0 ? 1 : I, Z = n.points, ue = Z === void 0 ? [] : Z, ke = n.direction, Ee = ke === void 0 ? "" : ke, Le = n.radian, je = n.rotationPosition, Ke = a + u, ut = o + h;
              if (t.beginPath(), t.save(), Le && je && (t.translate(je.x, je.y), t.rotate(Le), t.translate(-je.x, -je.y)), t.moveTo(a + b, o), Ee === "top" && ra(t, ue), t.lineTo(Ke - b, o), t.quadraticCurveTo(Ke, o, Ke, o + b), Ee === "right" && ra(t, ue), t.lineTo(Ke, o + h - b), t.quadraticCurveTo(Ke, ut, Ke - b, ut), Ee === "bottom" && ra(t, ue), t.lineTo(a + b, ut), t.quadraticCurveTo(a, ut, a, ut - b), Ee === "left" && ra(t, ue), t.lineTo(a, o + b), t.quadraticCurveTo(a, o, a + b, o), v) {
                var bt = Pi(v, Fn);
                Object.keys(bt).forEach(function(mt) {
                  t[mt] = bt[mt];
                });
              }
              R && Li(t, R), C && Ii(t, {
                strokeStyle: C,
                lineWidth: W
              }), t.restore();
            }
            l(1549);
            function mo(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function Nu(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? mo(Object(a), !0).forEach(function(o) {
                  Ua(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : mo(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function Ua(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var wi = 180, Bu = -180, Dr = 360, gn = 0, ti = -90, ri = 90, bs = 10;
            function xa(t, n) {
              return Nu({
                anchor: t
              }, Ue(n, "x", "y", "radius", "degree", "drawingStartAngle"));
            }
            function Pr(t) {
              var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ti, a = 0;
              return t % Dr === 0 ? a = Math.PI / wi * n : t >= 0 && (a = Math.PI / wi * (t + n)), a;
            }
            function El(t) {
              var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ti;
              return (t * wi / Math.PI - n + Dr) % Dr;
            }
            function ka(t) {
              var n = t.anchor, a = t.x, o = t.y, u = t.radius, h = u.inner, v = u.outer, g = t.degree, b = g.start, C = g.end, R = t.drawingStartAngle, I = R === void 0 ? ti : R, W = b + (C - b) / 2, Z = Pr(W, I), ue = n === "outer" ? v : (v + h) / 2;
              return hn(a, o, ue, Z);
            }
            function hn(t, n, a, o) {
              return {
                x: Math.round(t + a * Math.cos(o)),
                y: Math.round(n + a * Math.sin(o))
              };
            }
            function go(t, n, a, o) {
              return t ? n <= o && a >= o : n >= o && a <= o;
            }
            function zo(t) {
              var n, a, o, u, h, v = (n = t == null ? void 0 : t.clockwise) !== null && n !== void 0 ? n : !0;
              return {
                clockwise: v,
                startAngle: (a = t == null || (o = t.angleRange) === null || o === void 0 ? void 0 : o.start) !== null && a !== void 0 ? a : v ? gn : Dr,
                endAngle: (u = t == null || (h = t.angleRange) === null || h === void 0 ? void 0 : h.end) !== null && u !== void 0 ? u : v ? Dr : gn
              };
            }
            function xi(t) {
              var n = t.width, a = t.height, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, h = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, v;
              return o ? v = Math.min(n / 2, a) - h : n > a ? v = a / 2 - h : v = n / 2 - u, Math.max(v, bs);
            }
            function $s(t, n, a, o) {
              var u = o ? (n + t) / 2 : t;
              return Pr(u, a);
            }
            function Ss(t, n) {
              var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, o = t.totalAngle, u = o === void 0 ? Dr : o, h = t.degree, v = h.start, g = h.end, b = t.drawingStartAngle, C = b === void 0 ? ti : b, R = "center";
              if (n !== "outer")
                return R;
              var I = Pr(0, C), W = Pr(u / 2, C), Z = $s(v, g, C, a);
              return C >= ti && C < ri ? I < Z && W > Z ? R = "left" : W < Z && (R = "right") : I < Z && W > Z ? R = "right" : W < Z && (R = "left"), R;
            }
            function ws(t, n) {
              return t.reduce(function(a, o, u) {
                return u && a.push({
                  inner: o + n,
                  outer: t[u - 1] - n
                }), u === t.length - 1 && a.push({
                  inner: n,
                  outer: o - n
                }), a;
              }, []);
            }
            function zn(t) {
              return t < gn ? Dr + t % Dr : t > Dr ? t % Dr : t;
            }
            var mr = {
              default: {
                strokeStyle: "#ffffff",
                lineWidth: 2
              },
              plot: {
                lineWidth: 1,
                strokeStyle: "rgba(0, 0, 0, 0.05)"
              }
            }, kt = {
              shadow: {
                shadowColor: "rgba(0, 0, 0, 0.3)",
                shadowOffsetX: 2,
                shadowOffsetY: 2,
                shadowBlur: 6
              }
            };
            function er(t, n) {
              var a = n.x, o = n.y, u = n.width, h = n.height;
              t.beginPath(), t.rect(a, o, u, h), t.clip();
            }
            function hr(t, n) {
              var a = n.x, o = n.y, u = n.width, h = n.height, v = n.radius, g = v === void 0 ? 0 : v, b = n.stroke, C = b === void 0 ? "black" : b, R = n.fill, I = R === void 0 ? "" : R, W = n.lineWidth, Z = W === void 0 ? 1 : W;
              t.beginPath(), t.moveTo(a + g, o), t.lineTo(a + u - g, o), t.quadraticCurveTo(a + u, o, a + u, o + g), t.lineTo(a + u, o + h - g), t.quadraticCurveTo(a + u, o + h, a + u - g, o + h), t.lineTo(a + g, o + h), t.quadraticCurveTo(a, o + h, a, o + h - g), t.lineTo(a, o + g), t.quadraticCurveTo(a, o, a + g, o), t.closePath(), I && Li(t, I), Ii(t, {
                lineWidth: Z,
                strokeStyle: C
              });
            }
            function Rr(t, n) {
              var a = n.x, o = n.y, u = n.style, h = n.radius, v = n.color, g = n.angle, b = g === void 0 ? {
                start: 0,
                end: Math.PI * 2
              } : g, C = n.borderWidth, R = n.borderColor;
              if (t.beginPath(), u) {
                var I = Pi(u, mr);
                Object.keys(I).forEach(function(W) {
                  t[W] = I[W];
                });
              }
              t.arc(a, o, h, b.start, b.end, !0), Ii(t, {
                lineWidth: C,
                strokeStyle: R
              }), Li(t, v), t.closePath();
            }
            function Wr(t, n) {
              var a = n.x, o = n.y, u = n.x2, h = n.y2, v = n.strokeStyle, g = n.lineWidth, b = n.dashSegments;
              t.beginPath(), b && ta(t, b), t.moveTo(a, o), t.lineTo(u, h), Ii(t, {
                strokeStyle: v,
                lineWidth: g
              }), t.closePath();
            }
            function cn(t, n) {
              var a = n.x, o = n.y, u = n.width, h = n.height, v = n.style, g = n.thickness, b = g === void 0 ? 0 : g, C = n.color, R = n.borderColor, I = R === void 0 ? "#ffffff" : R;
              if (t.beginPath(), v) {
                var W = Pi(v, kt);
                Object.keys(W).forEach(function(Z) {
                  t[Z] = W[Z];
                });
              }
              b && (t.fillStyle = I, t.fillRect(a - b, o - b, u + b * 2, h + b * 2), t.shadowColor = "rgba(0, 0, 0, 0)"), t.rect(a, o, u, h), Li(t, C);
            }
            function Hr(t, n) {
              var a = n.x, o = n.y, u = n.angle, h = u.start, v = u.end, g = n.borderWidth, b = n.borderColor, C = n.drawingStartAngle, R = n.radius, I = n.clockwise, W = I === void 0 ? !0 : I;
              t.beginPath();
              var Z = Pr(h, C), ue = Pr(v, C);
              t.arc(a, o, R, Z, ue, !W), Ii(t, {
                lineWidth: g,
                strokeStyle: b
              }), t.closePath();
            }
            var Ur = 5;
            function Ho(t, n) {
              var a = n.x, o = n.y, u = n.isYAxis, h = n.tickSize, v = h === void 0 ? Ur : h, g = n.strokeStyle, b = n.lineWidth, C = {
                x: a,
                y: o,
                x2: a,
                y2: o,
                strokeStyle: g,
                lineWidth: b
              };
              u ? C.x2 += v : C.y2 += v, Wr(t, C);
            }
            function Ml(t) {
              return zu(t) || Tp(t) || Va(t) || Fu();
            }
            function Fu() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function Va(t, n) {
              if (t) {
                if (typeof t == "string") return Us(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return Us(t, n);
              }
            }
            function Tp(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function zu(t) {
              if (Array.isArray(t)) return Us(t);
            }
            function Us(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            var Ap = 1.2, Rl = document.createElement("canvas").getContext("2d");
            function ni(t) {
              var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _i;
              return Rl.font = n, Math.ceil(Rl.measureText(t).width);
            }
            function Vs(t) {
              var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _i;
              Rl.font = n;
              var a = Rl.measureText(t), o = a.actualBoundingBoxAscent, u = a.actualBoundingBoxDescent, h = Me(o) && Me(u);
              return h ? Math.ceil(Math.abs(o) + Math.abs(u)) + 1 : Dl(n);
            }
            function Dl() {
              var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _i, n = t.match(/\d+(?=px)/);
              return parseInt(String(Number(n) * Ap), 10);
            }
            function jo(t) {
              return Cr(Ur * 2 + t / 2);
            }
            function Ep(t) {
              var n, a;
              return (n = (a = String(t).split(".")[1]) === null || a === void 0 ? void 0 : a.length) !== null && n !== void 0 ? n : 0;
            }
            function Pl() {
              for (var t = arguments.length, n = new Array(t), a = 0; a < t; a++)
                n[a] = arguments[a];
              var o = n.map(function(h) {
                return Ep(h);
              }), u = Math.max.apply(Math, Ml(o));
              return Math.pow(10, u);
            }
            function Hu(t, n) {
              var a = Pl(t, n);
              return (t * a + n * a) / a;
            }
            function ju(t, n) {
              var a = Pl(t, n);
              return t * a * (n * a) / (a * a);
            }
            function qc(t, n) {
              var a = Pl(t, n);
              return t * a / (n * a);
            }
            function Wu(t) {
              var n = t.slice();
              return n.unshift(0), n.reduce(function(a, o) {
                return Hu(parseFloat(String(a)), parseFloat(String(o)));
              });
            }
            function $u(t) {
              for (var n = [], a = 2, o; a * a <= t; a += 1)
                t % a === 0 && (o = t / a, n.push(a), o !== a && n.push(o));
              return n.sort(function(u, h) {
                return u - h;
              });
            }
            function yo(t, n, a) {
              var o = Pl(n), u = Math.round(t.min * o), h = Math.round(t.max * o), v = Mt(u, h + 1, n * o);
              return v.map(function(g) {
                return String(a ? new Date(g) : g / o);
              });
            }
            function Fi(t, n) {
              var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, u = [];
              return n > 0 && (u = Mt(0, n).map(function(h) {
                var v = h === 0 ? 0 : h / (n - 1);
                return v * t + a;
              })), o && u.push(o), u;
            }
            function Cr(t) {
              var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, a = n / 2;
              return n % 2 ? (rt(t) ? t : Math.round(t - a)) + a : Math.round(t);
            }
            function Mp(t, n, a) {
              var o = 0.333, u = t.x, h = t.y, v = n.x, g = n.y, b = a.x, C = a.y, R = Uu(a, n), I = Uu(n, t), W = o * I / (I + R) || 0, Z = o * R / (I + R) || 0;
              return {
                prev: {
                  x: v - W * (b - u),
                  // x2-x0 is the width of triangle T
                  y: g - W * (C - h)
                  // y2-y0 is the height of T
                },
                next: {
                  x: v + Z * (b - u),
                  y: g + Z * (C - h)
                }
              };
            }
            function Gs(t) {
              for (var n = 0, a = t.length, o = t[0]; n < a; n += 1) {
                var u = t[n];
                if (Oe(u)) {
                  o = t[n + 1];
                  continue;
                }
                var h = t[Math.min(n + 1, a - 1) % a];
                o && h && (u.controlPoint = Mp(o, u, h)), o = u;
              }
            }
            function bo(t, n) {
              var a = n.min, o = n.max;
              return o === a ? 0 : (t - a) / (o - a);
            }
            function Uu(t, n) {
              return Math.sqrt(Math.pow(n.x - t.x, 2) + Math.pow(n.y - t.y, 2));
            }
            function Oa(t) {
              var n = t.reduce(function(a, o) {
                return a.length > o.length ? a : o;
              }, "");
              return ni(n);
            }
            function Vu(t, n, a, o) {
              var u = t.pointOnColumn, h = t.tickDistance, v = t.labelRange, g;
              if (v) {
                var b = Ie(a) ? Number(new Date(a)) : Number(a), C = bo(b, v);
                g = C * n;
              } else
                g = h * o + (u ? h / 2 : 0);
              return g;
            }
            function xs(t) {
              return Pp(t) || Ys(t) || Dp(t) || Rp();
            }
            function Rp() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function Dp(t, n) {
              if (t) {
                if (typeof t == "string") return Ll(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return Ll(t, n);
              }
            }
            function Ys(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function Pp(t) {
              if (Array.isArray(t)) return Ll(t);
            }
            function Ll(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function Kc(t, n) {
              if (t.length !== n.length)
                return !1;
              for (var a = 0; a < t.length; a += 1)
                if (t[a] !== n[a])
                  return !1;
              return !0;
            }
            function Wo(t, n) {
              return t.reduce(function(a, o) {
                return [].concat(xs(a), [o[n]]);
              }, []);
            }
            function So(t) {
              return ks(t) || $o(t) || Lp(t) || qs();
            }
            function qs() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function Lp(t, n) {
              if (t) {
                if (typeof t == "string") return Ga(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return Ga(t, n);
              }
            }
            function $o(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function ks(t) {
              if (Array.isArray(t)) return Ga(t);
            }
            function Ga(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function zi(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function Mn(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? zi(Object(a), !0).forEach(function(o) {
                  Hi(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : zi(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function Xc(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function Ip(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function Jc(t, n, a) {
              return n && Ip(t.prototype, n), t;
            }
            function Hi(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var Lr = /* @__PURE__ */ function() {
              function t(n) {
                var a = n.store, o = n.eventBus;
                Xc(this, t), Hi(this, "name", "Component"), Hi(this, "type", "component"), Hi(this, "rect", {
                  x: 0,
                  y: 0,
                  height: 0,
                  width: 0
                }), Hi(this, "isShow", !0), Hi(this, "selectable", void 0), Hi(this, "store", void 0), Hi(this, "eventBus", void 0), Hi(this, "models", void 0), Hi(this, "drawModels", void 0), Hi(this, "responders", void 0), Hi(this, "activeSeriesMap", void 0), this.store = a, this.eventBus = o;
              }
              return Jc(t, [{
                key: "update",
                value: function(a) {
                  var o = this;
                  this.drawModels && (Array.isArray(this.models) ? this.updateModels(this.drawModels, this.models, a) : Object.keys(this.models).forEach(function(u) {
                    var h = o.drawModels[u], v = o.models[u];
                    o.updateModels(h, v, a);
                  }));
                }
              }, {
                key: "initUpdate",
                value: function(a) {
                  this.update(a);
                }
              }, {
                key: "updateModels",
                value: function(a, o, u) {
                  var h = this;
                  a.forEach(function(v, g) {
                    var b = o[g];
                    Object.keys(v).forEach(function(C) {
                      if (!(!v || !b) && C[0] !== "_")
                        if (Me(v[C]))
                          v[C] = v[C] + (b[C] - v[C]) * u;
                        else if (C === "points") {
                          var R, I = h.getCurrentModelToMatchTargetModel(v[C], v[C], b[C]), W = I.map(function(Z, ue) {
                            var ke = b[C][ue];
                            if (Z && ke) {
                              var Ee = Z.x, Le = Z.y, je = ke.x, Ke = ke.y;
                              return Mn(Mn({}, ke), {}, {
                                x: Ee + (je - Ee) * u,
                                y: Le + (Ke - Le) * u
                              });
                            }
                            return ke;
                          });
                          (R = h.store.state.options.series) !== null && R !== void 0 && R.spline && Gs(W), v[C] = W;
                        } else
                          v[C] = b[C];
                    });
                  });
                }
              }, {
                key: "sync",
                value: function() {
                  var a = this;
                  this.drawModels && (Array.isArray(this.models) ? this.syncModels(this.drawModels, this.models) : Object.keys(this.models).length ? Object.keys(this.models).forEach(function(o) {
                    var u = a.drawModels[o], h = a.models[o];
                    a.syncModels(u, h, o);
                  }) : this.drawModels = this.models);
                }
              }, {
                key: "getCurrentModelToMatchTargetModel",
                value: function(a, o, u) {
                  var h;
                  if (!a || !o)
                    return So(u);
                  if ((h = De(u)) !== null && h !== void 0 && h.name) {
                    var v = So(new Set(a.map(function(I) {
                      var W = I.name;
                      return W;
                    }))), g = So(new Set(u.map(function(I) {
                      var W = I.name;
                      return W;
                    }))), b = Kc(v, g);
                    if (!b)
                      return this.getCurrentModelWithDifferentModel(a, o, u, v, g);
                  }
                  var C = o.length, R = u.length;
                  return C < R ? [].concat(So(o), So(u.slice(C, R))) : C > R ? o.slice(0, R) : a;
                }
              }, {
                key: "getCurrentModelWithDifferentModel",
                value: function(a, o, u, h, v) {
                  var g = o.length, b = u.length;
                  if (g > b) {
                    var C = a.filter(function(W) {
                      var Z = W.name;
                      return Ve(v, Z);
                    });
                    return C.length !== u.length ? u : C;
                  }
                  if (g < b) {
                    var R = u.reduce(function(W, Z, ue) {
                      var ke = !Ve(h, Z.name);
                      return ke ? {
                        models: [].concat(So(W.models), [Z]),
                        modelIdx: [].concat(So(W.modelIdx), [ue])
                      } : W;
                    }, {
                      models: [],
                      modelIdx: []
                    });
                    if (a.length + R.models.length === b) {
                      var I = So(a);
                      return R.models.forEach(function(W, Z) {
                        I.splice(R.modelIdx[Z], 0, W);
                      }), I;
                    }
                    return u;
                  }
                  return a;
                }
              }, {
                key: "syncModels",
                value: function(a, o, u) {
                  var h = u ? this.drawModels[u] : this.drawModels, v = this.getCurrentModelToMatchTargetModel(h, a, o);
                  u ? this.drawModels[u] = v : this.drawModels = v;
                }
              }, {
                key: "getSelectableOption",
                value: function(a) {
                  var o, u;
                  return (o = a == null || (u = a.series) === null || u === void 0 ? void 0 : u.selectable) !== null && o !== void 0 ? o : !1;
                }
              }, {
                key: "renderDataLabels",
                value: function(a, o) {
                  var u = this;
                  setTimeout(function() {
                    u.eventBus.emit("renderDataLabels", {
                      data: a,
                      name: o ?? u.name
                    });
                  }, 0);
                }
              }, {
                key: "draw",
                value: function(a) {
                  var o = this.drawModels ? this.drawModels : this.models;
                  Array.isArray(o) ? a.paintForEach(o) : o && Object.keys(o).forEach(function(u) {
                    a.paintForEach(o[u]);
                  });
                }
              }]), t;
            }();
            function Ks(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Ks = function(a) {
                return typeof a;
              } : Ks = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Ks(t);
            }
            function Il(t) {
              return Yu(t) || Zc(t) || Gu(t) || Uo();
            }
            function Uo() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function Gu(t, n) {
              if (t) {
                if (typeof t == "string") return qu(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return qu(t, n);
              }
            }
            function Zc(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function Yu(t) {
              if (Array.isArray(t)) return qu(t);
            }
            function qu(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function Qc(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function _p(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? Qc(Object(a), !0).forEach(function(o) {
                  ji(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : Qc(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function Np(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function ef(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function tf(t, n, a) {
              return n && ef(t.prototype, n), t;
            }
            function Bp(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Ku(t, n);
            }
            function Ku(t, n) {
              return Ku = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Ku(t, n);
            }
            function Fp(t) {
              var n = Hp();
              return function() {
                var o = Xs(t), u;
                if (n) {
                  var h = Xs(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return zp(this, u);
              };
            }
            function zp(t, n) {
              return n && (Ks(n) === "object" || typeof n == "function") ? n : Os(t);
            }
            function Os(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function Hp() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function Xs(t) {
              return Xs = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, Xs(t);
            }
            function ji(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var _r;
            (function(t) {
              t.X = "xAxis", t.Y = "yAxis", t.SECONDARY_Y = "secondaryYAxis", t.CIRCULAR = "circularAxis", t.VERTICAL = "verticalAxis";
            })(_r || (_r = {}));
            function Xu(t) {
              return {
                offsetKey: t ? "y" : "x",
                anchorKey: t ? "x" : "y"
              };
            }
            var Vr = /* @__PURE__ */ function(t) {
              Bp(a, t);
              var n = Fp(a);
              function a() {
                var o;
                Np(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), ji(Os(o), "models", {
                  label: [],
                  tick: [],
                  axisLine: []
                }), ji(Os(o), "drawModels", void 0), ji(Os(o), "yAxisComponent", void 0), ji(Os(o), "theme", void 0), ji(Os(o), "axisSize", 0), o;
              }
              return tf(a, [{
                key: "initialize",
                value: function(u) {
                  var h = u.name;
                  this.type = "axis", this.name = h, this.yAxisComponent = Ve([_r.Y, _r.SECONDARY_Y], h);
                }
              }, {
                key: "render",
                value: function(u) {
                  var h = this, v = u.layout, g = u.axes, b = u.theme, C = u.scale;
                  if (!(g.centerYAxis || !g[this.name])) {
                    this.theme = Go(b, this.name), this.rect = v[this.name], this.axisSize = this.yAxisComponent ? this.rect.height : this.rect.width;
                    var R = g[this.name].viewLabels, I = Xu(this.yAxisComponent), W = I.offsetKey, Z = I.anchorKey, ue = this.makeRenderOptions(g[this.name], C == null ? void 0 : C[this.name]), ke = this.hasOnlyAxisLine();
                    ke || (this.models.label = this.renderLabelModels(R, W, Z, ue), this.models.tick = this.renderTickModels(W, Z, ue)), this.models.axisLine = [this.renderAxisLineModel()], this.drawModels || (this.drawModels = {
                      tick: [],
                      label: [],
                      axisLine: this.models.axisLine
                    }, ["tick", "label"].forEach(function(Ee) {
                      h.drawModels[Ee] = h.models[Ee].map(function(Le) {
                        var je = _p({}, Le);
                        return h.yAxisComponent ? je.y = 0 : je.x = 0, je;
                      });
                    }));
                  }
                }
              }, {
                key: "renderAxisLineModel",
                value: function() {
                  var u = Cr(0), h, v = this.theme, g = v.color, b = v.width;
                  if (this.yAxisComponent) {
                    var C = this.getYAxisXPoint();
                    h = {
                      type: "line",
                      x: C,
                      y: u,
                      x2: C,
                      y2: Cr(this.axisSize),
                      strokeStyle: g,
                      lineWidth: b
                    };
                  } else
                    h = {
                      type: "line",
                      x: u,
                      y: u,
                      x2: Cr(this.axisSize),
                      y2: u,
                      strokeStyle: g,
                      lineWidth: b
                    };
                  return h;
                }
              }, {
                key: "renderTickModels",
                value: function(u, h, v) {
                  var g = this, b = this.yAxisComponent ? this.getYAxisXPoint() : Cr(0), C = v.tickInterval, R = v.relativePositions, I = Ve([_r.SECONDARY_Y, _r.X], this.name) ? Ur : -5;
                  return R.reduce(function(W, Z, ue) {
                    var ke;
                    return ue % C ? W : [].concat(Il(W), [(ke = {
                      type: "tick",
                      isYAxis: g.yAxisComponent,
                      tickSize: I
                    }, ji(ke, u, Cr(Z)), ji(ke, h, b), ji(ke, "strokeStyle", g.theme.color), ji(ke, "lineWidth", g.theme.width), ke)]);
                  }, []);
                }
              }, {
                key: "renderLabelModels",
                value: function(u, h, v, g) {
                  var b = g.needRotateLabel, C = g.radian, R = g.offsetY, I = this.theme.label, W = an(I), Z = this.getLabelTextAlign(b), ue = ["default", {
                    textAlign: Z,
                    font: W,
                    fillStyle: I.color
                  }], ke = this.yAxisComponent ? this.getYAxisAnchorPoint() : R;
                  return u.map(function(Ee) {
                    var Le, je = Ee.text, Ke = Ee.offsetPos;
                    return Le = {
                      type: "label",
                      text: je,
                      style: ue,
                      radian: C
                    }, ji(Le, h, Cr(Ke)), ji(Le, v, ke), Le;
                  });
                }
              }, {
                key: "makeRenderOptions",
                value: function(u, h) {
                  var v, g, b = u.tickCount, C = u.tickInterval, R = (v = h == null ? void 0 : h.sizeRatio) !== null && v !== void 0 ? v : 1, I = (g = h == null ? void 0 : h.positionRatio) !== null && g !== void 0 ? g : 0, W = Fi(this.axisSize * R, b, this.axisSize * I);
                  if (this.yAxisComponent)
                    return {
                      relativePositions: W,
                      tickInterval: C
                    };
                  var Z = u.needRotateLabel, ue = u.radian, ke = u.offsetY;
                  return {
                    relativePositions: W,
                    tickInterval: C,
                    needRotateLabel: Z,
                    radian: ue,
                    offsetY: ke
                  };
                }
              }, {
                key: "getYAxisAnchorPoint",
                value: function() {
                  return this.isRightSide() ? Cr(this.rect.width) : Cr(0);
                }
              }, {
                key: "getLabelTextAlign",
                value: function(u) {
                  var h = this.isRightSide() ? "right" : "left", v = u ? "left" : "center";
                  return this.yAxisComponent ? h : v;
                }
              }, {
                key: "isRightSide",
                value: function() {
                  return this.name === _r.SECONDARY_Y;
                }
              }, {
                key: "getYAxisXPoint",
                value: function() {
                  return this.isRightSide() ? Cr(0) : Cr(this.rect.width);
                }
              }, {
                key: "hasOnlyAxisLine",
                value: function() {
                  return this.yAxisComponent && !this.rect.width || this.name === _r.X && !this.rect.height;
                }
              }]), a;
            }(Lr), rf = Math.PI / 180, nf = 90, jp = [0, 25, 45, 65, 85, 90];
            function af(t, n) {
              return Math.cos(t * rf) * n;
            }
            function Ju(t, n) {
              return Math.sin(t * rf) * n;
            }
            function of(t, n, a) {
              var o = af(t, n / 2), u = af(nf - t, a / 2);
              return (o + u) * 2;
            }
            function sf(t, n, a) {
              var o = Ju(t, n / 2), u = Ju(nf - t, a / 2);
              return (o + u) * 2;
            }
            var Wp = "YY-MM-DD hh:mm:ss";
            function lf(t) {
              if (t)
                return ot(t) ? t.format : Wp;
            }
            var $p = /[\\]*YYYY|[\\]*YY|[\\]*MMMM|[\\]*MMM|[\\]*MM|[\\]*M|[\\]*DD|[\\]*D|[\\]*HH|[\\]*H|[\\]*mm|[\\]*m|[\\]*ss|[\\]*s|[\\]*A/gi, Zu = ["Invalid month", "January", "February", "March", "April", "May", "Jun", "Jul", "August", "September", "October", "November", "December"], A = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], B = {
              M: function(n) {
                return Number(n.month);
              },
              MM: function(n) {
                var a = n.month;
                return Number(a) < 10 ? "0".concat(a) : a;
              },
              MMM: function(n) {
                return Zu[Number(n.month)].substr(0, 3);
              },
              MMMM: function(n) {
                return Zu[Number(n.month)];
              },
              D: function(n) {
                return Number(n.date);
              },
              d: function(n) {
                return B.D(n);
              },
              // eslint-disable-line new-cap
              DD: function(n) {
                var a = n.date;
                return Number(a) < 10 ? "0".concat(a) : a;
              },
              dd: function(n) {
                return B.DD(n);
              },
              // eslint-disable-line new-cap
              YY: function(n) {
                return Number(n.year) % 100;
              },
              yy: function(n) {
                return B.YY(n);
              },
              // eslint-disable-line new-cap
              YYYY: function(n) {
                var a = "20", o = n.year;
                return o > 69 && o < 100 && (a = "19"), Number(o) < 100 ? a + String(o) : o;
              },
              yyyy: function(n) {
                return B.YYYY(n);
              },
              // eslint-disable-line new-cap
              A: function(n) {
                return n.meridiem;
              },
              a: function(n) {
                return n.meridiem;
              },
              hh: function(n) {
                var a = n.hour;
                return Number(a) < 10 ? "0" + a : a;
              },
              HH: function(n) {
                return B.hh(n);
              },
              h: function(n) {
                return String(Number(n.hour));
              },
              H: function(n) {
                return B.h(n);
              },
              m: function(n) {
                return String(Number(n.minute));
              },
              mm: function(n) {
                var a = n.minute;
                return Number(a) < 10 ? "0".concat(a) : a;
              },
              s: function(n) {
                return String(Number(n.second));
              },
              ss: function(n) {
                var a = n.second;
                return Number(a) < 10 ? "0".concat(a) : a;
              }
            };
            function E(t, n) {
              return t === 2 && n % 4 === 0 && (n % 100 !== 0 || n % 400 === 0);
            }
            function N(t, n, a) {
              var o = Number(t), u = Number(n), h = Number(a), v = o > -1 && o < 100 || o > 1969 && o < 2070, g = u > 0 && u < 13;
              if (!v || !g)
                return !1;
              var b = E(u, o) ? 29 : A[u];
              return h > 0 && h <= b;
            }
            function H(t, n, a) {
              var o, u = (o = void 0) !== null && o !== void 0 ? o : "AM", h = "PM", v;
              if (ge(n))
                v = {
                  year: n.getFullYear(),
                  month: n.getMonth() + 1,
                  date: n.getDate(),
                  hour: n.getHours(),
                  minute: n.getMinutes(),
                  second: n.getSeconds()
                };
              else {
                var g = n.year, b = n.month, C = n.hour, R = n.minute, I = n.second;
                v = {
                  year: g,
                  month: b,
                  date: n.date,
                  hour: C,
                  minute: R,
                  second: I
                };
              }
              return N(v.year, v.month, v.date) ? (v.meridiem = "", /([^\\]|^)[aA]\b/.test(t) && (v.hour > 12 && (v.hour %= 12), v.hour === 0 && (v.hour = 12), v.meridiem = v.hour > 11 ? h : u), t.replace($p, function(W) {
                return W.indexOf("\\") > -1 ? W.replace(/\\/, "") : B[W](v) || "";
              })) : "";
            }
            var Y = {
              COUNTER_CLOCKWISE: 0.1,
              CLOCKWISE: 1
            };
            function le(t, n, a) {
              return t && (n >= ti && a <= ri || n >= ri && a <= wi);
            }
            function me(t, n, a) {
              return !t && (n >= Bu && a <= ri || n <= ri && a >= ti);
            }
            function Pe(t, n, a) {
              var o = a - n, u = Math.abs(o), h = o > gn && u !== Dr && !t || o < gn && u !== Dr && t;
              return h ? Dr - u : u;
            }
            function $e(t, n, a) {
              return Pe(t, n, a) <= wi && (le(t, n, a) || me(t, n, a));
            }
            function st(t, n) {
              return n ? t * Y.CLOCKWISE : t * Y.COUNTER_CLOCKWISE;
            }
            function Tt(t) {
              var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
              return t.filter(function(a) {
                var o = a.data;
                return !Oe(o);
              }).map(function(a) {
                var o = a.data, u = a.name, h = a.color, v = a.rootParentName;
                return {
                  label: u,
                  color: h,
                  value: o,
                  category: n,
                  rootParentName: v,
                  templateType: "pie"
                };
              });
            }
            function ht(t) {
              var n;
              return !!(t.pie && Array.isArray((n = t.pie[0]) === null || n === void 0 ? void 0 : n.data));
            }
            function _t(t) {
              return t.pie.map(function(n) {
                var a = n.name;
                return a;
              });
            }
            function Ht(t) {
              var n = t.toFixed(2), a = parseFloat(n), o = n.length > 5;
              return "".concat(o ? parseFloat(n.substr(0, 4)) : String(a), "%");
            }
            function nr(t, n) {
              var a, o;
              return !!n.pie && (t == null || (a = t.series) === null || a === void 0 || (o = a.dataLabels) === null || o === void 0 ? void 0 : o.anchor) === "outer";
            }
            function Tr(t, n) {
              var a, o, u;
              return !!n.pie && (t == null || (a = t.series) === null || a === void 0 || (o = a.dataLabels) === null || o === void 0 || (u = o.pieSeriesName) === null || u === void 0 ? void 0 : u.anchor) === "outer";
            }
            var Zt = 5, Gr = 25, Or;
            (function(t) {
              t.CIRCULAR = "circularAxis", t.VERTICAL = "verticalAxis";
            })(Or || (Or = {}));
            function en() {
              var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, a = "center";
              return n && (a = t ? "right" : "left"), a;
            }
            function Nr(t) {
              var n = t.labels, a = t.pointOnColumn, o = t.intervalData, u = t.isLabelOnVerticalAxis, h = t.verticalAxisLabelMargin, v = t.verticalAxisLabelFont, g = t.defaultAxisData, b = t.radiusData, C = g.clockwise, R = g.axisSize, I = g.centerX, W = g.centerY, Z = g.startAngle, ue = g.endAngle, ke = b.radiusRanges, Ee = b.innerRadius, Le = b.outerRadius, je = o.labelInterval, Ke = Yo(n, h, v), ut = Ke.maxLabelWidth, bt = Ke.maxLabelHeight;
              return {
                axisSize: R,
                centerX: I,
                centerY: W,
                label: {
                  labels: n,
                  interval: je,
                  margin: h,
                  maxWidth: ut,
                  maxHeight: bt,
                  align: en(C, u)
                },
                radius: {
                  inner: Ee,
                  outer: Le,
                  ranges: ke
                },
                angle: {
                  start: Z,
                  end: ue
                },
                tickDistance: (Le - Ee) / n.length,
                pointOnColumn: a
              };
            }
            function zr(t) {
              var n = t.labels, a = t.intervalData, o = t.circularAxisLabelMargin, u = t.circularAxisLabelFont, h = t.defaultAxisData, v = t.radiusData, g = Yo(n, o, u), b = g.maxLabelWidth, C = g.maxLabelHeight, R = h.totalAngle, I = h.clockwise, W = h.axisSize, Z = h.centerX, ue = h.centerY, ke = h.startAngle, Ee = h.endAngle, Le = h.drawingStartAngle, je = a.tickInterval, Ke = a.labelInterval, ut = v.innerRadius, bt = v.outerRadius, mt = R / (n.length + (R < Dr ? -1 : gn));
              return {
                axisSize: W,
                centerX: Z,
                centerY: ue,
                label: {
                  labels: n,
                  interval: Ke,
                  margin: o,
                  maxWidth: b,
                  maxHeight: C
                },
                radius: {
                  inner: ut,
                  outer: bt
                },
                angle: {
                  start: ke,
                  end: Ee,
                  total: R,
                  central: mt,
                  drawingStart: Le
                },
                tickInterval: je,
                clockwise: I
              };
            }
            function fn(t, n, a) {
              var o, u, h, v = (o = (u = t[a]) === null || u === void 0 || (h = u.label) === null || h === void 0 ? void 0 : h.formatter) !== null && o !== void 0 ? o : function(g) {
                return g;
              };
              return n.map(function(g, b) {
                return v(g, {
                  index: b,
                  labels: n,
                  axisName: a
                });
              });
            }
            function ki(t, n, a, o) {
              var u = t ? Or.CIRCULAR : Or.VERTICAL, h = o[u], v = h.limit, g = h.stepSize, b = fn(n, yo(v, g), u), C = fn(n, a, t ? Or.VERTICAL : Or.CIRCULAR);
              return {
                radialAxisLabels: t ? b : C,
                yAxisLabels: t ? C : b
              };
            }
            function na(t, n) {
              var a, o, u, h, v, g;
              return {
                verticalAxisLabelMargin: (a = n == null || (o = n.verticalAxis) === null || o === void 0 || (u = o.label) === null || u === void 0 ? void 0 : u.margin) !== null && a !== void 0 ? a : t ? Zt : 0,
                circularAxisLabelMargin: (h = n == null || (v = n.circularAxis) === null || v === void 0 || (g = v.label) === null || g === void 0 ? void 0 : g.margin) !== null && h !== void 0 ? h : Gr
              };
            }
            var Rn = {
              name: "radialAxes",
              state: function() {
                return {
                  radialAxes: {}
                };
              },
              action: {
                setRadialAxesData: function(n) {
                  var a, o = n.state, u = o.series, h = o.layout, v = o.scale, g = o.categories, b = h.plot, C = sa({
                    series: u,
                    categories: g
                  }), R = o.options, I = o.theme, W = an(I.circularAxis.label), Z = an(I.verticalAxis.label), ue = na(C, R), ke = ue.verticalAxisLabelMargin, Ee = ue.circularAxisLabelMargin, Le = ki(C, R, g, v), je = Le.radialAxisLabels, Ke = Le.yAxisLabels, ut = Yo(je, Ee, W), bt = ut.maxLabelWidth, mt = ut.maxLabelHeight, Rt = my(R, b, bt, mt + Ee, C), Dt = Rt.axisSize, Lt = C ? lk(Dt, R == null || (a = R.series) === null || a === void 0 ? void 0 : a.radiusRange, Ke.length + 1) : {
                    radiusRanges: Fi(Dt, Ke.length),
                    innerRadius: 0,
                    outerRadius: Dt
                  }, Wt = Nr({
                    labels: Ke,
                    pointOnColumn: C,
                    isLabelOnVerticalAxis: C,
                    intervalData: hf(C, {
                      axis: R.verticalAxis,
                      categories: g,
                      layout: h
                    }),
                    verticalAxisLabelMargin: ke,
                    verticalAxisLabelFont: Z,
                    defaultAxisData: Rt,
                    radiusData: Lt
                  });
                  o.radialAxes = {
                    circularAxis: zr({
                      labels: je,
                      intervalData: hf(!0, {
                        axis: R.circularAxis,
                        categories: g,
                        layout: h
                      }),
                      defaultAxisData: Rt,
                      circularAxisLabelMargin: Ee,
                      circularAxisLabelFont: W,
                      radiusData: Lt
                    }),
                    verticalAxis: Wt
                  };
                }
              },
              observe: {
                updateRadialAxes: function() {
                  this.dispatch("setRadialAxesData");
                }
              }
            }, ia = Rn;
            function ii(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function aa(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? ii(Object(a), !0).forEach(function(o) {
                  Ca(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : ii(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function Ca(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function Ya(t) {
              return Up(t) || uf(t) || yn(t) || oa();
            }
            function oa() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function yn(t, n) {
              if (t) {
                if (typeof t == "string") return Cs(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return Cs(t, n);
              }
            }
            function uf(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function Up(t) {
              if (Array.isArray(t)) return Cs(t);
            }
            function Cs(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function Vo(t, n, a) {
              var o, u = Math.floor(n / a), h = null, v = u ? Math.floor(t / u) : t;
              return v > 1 && (o = t - v * u, o >= v && (u += Math.floor(o / v), o = o % v), h = {
                blockCount: u,
                remainBlockCount: o,
                interval: v
              }), h;
            }
            function cf(t, n, a) {
              var o = {
                MIN_WIDTH: 90,
                MAX_WIDTH: 121,
                STEP_SIZE: 5
              }, u = 5;
              if (a != null && a[0]) {
                var h = ni(a[0]);
                if (h < n / t - u)
                  return 1;
              }
              var v = [];
              if ($u(t).forEach(function(R) {
                var I = R / t * n;
                I >= o.MIN_WIDTH && I <= o.MAX_WIDTH && v.push({
                  interval: R,
                  blockCount: Math.floor(t / R),
                  remainBlockCount: 0
                });
              }), !v.length) {
                var g = Mt(o.MIN_WIDTH, o.MAX_WIDTH, o.STEP_SIZE);
                v = g.reduce(function(R, I) {
                  var W = Vo(t, n, I);
                  return W ? [].concat(Ya(R), [W]) : R;
                }, []);
              }
              var b = 1;
              if (v.length) {
                var C = v.reduce(function(R, I) {
                  return I.blockCount > R.blockCount ? I : R;
                }, {
                  blockCount: 0,
                  interval: 1
                });
                b = C.interval;
              }
              return b;
            }
            function sa(t) {
              var n, a = t.series, o = t.options, u = t.categories;
              return !!a.bar || !!a.radialBar || !!a.gauge && Array.isArray(u) && !u.length || !!a.bullet && !(o != null && (n = o.series) !== null && n !== void 0 && n.vertical);
            }
            function oy(t) {
              return !!t.column || !!t.bar || !!t.boxPlot || !!t.bullet;
            }
            function rk(t, n) {
              if (oy(t))
                return !0;
              if (t.line || t.area) {
                var a;
                return !!(!((a = n.xAxis) === null || a === void 0) && a.pointOnColumn);
              }
              return !1;
            }
            function sy(t) {
              return !!t.radar || !!t.radialBar || !!t.gauge;
            }
            function nk(t) {
              return {
                valueAxisName: t ? "circularAxis" : "verticalAxis",
                labelAxisName: t ? "verticalAxis" : "circularAxis"
              };
            }
            function ff(t, n) {
              return sy(n) ? nk(t) : {
                valueAxisName: t ? "xAxis" : "yAxis",
                labelAxisName: t ? "yAxis" : "xAxis"
              };
            }
            function df(t) {
              return {
                valueSizeKey: t ? "width" : "height",
                labelSizeKey: t ? "height" : "width"
              };
            }
            function Vp(t) {
              var n = t.map(function(a) {
                return Number(a);
              });
              return {
                min: Math.min.apply(Math, Ya(n)),
                max: Math.max.apply(Math, Ya(n))
              };
            }
            function ly(t) {
              return Array.isArray(t == null ? void 0 : t.yAxis) && t.yAxis.length === 2;
            }
            function qa(t) {
              var n = ly(t);
              return {
                yAxis: n ? t.yAxis[0] : t == null ? void 0 : t.yAxis,
                secondaryYAxis: n ? t.yAxis[1] : null
              };
            }
            function Qu(t, n, a) {
              var o = qa(t), u = o.secondaryYAxis;
              return (u == null ? void 0 : u.chartType) === n ? "secondaryYAxis" : a;
            }
            function uy(t, n) {
              if (Ve([_r.X, _r.CIRCULAR, _r.VERTICAL], n))
                return [n];
              var a = t, o = qa(a), u = o.yAxis, h = o.secondaryYAxis;
              return h ? [u.chartType, h.chartType].map(function(v, g) {
                return v ? Qu(a, v, n) : ["yAxis", "secondaryYAxis"][g];
              }) : [n];
            }
            function Go(t, n) {
              var a = t.xAxis, o = t.yAxis, u = t.circularAxis, h;
              return n === _r.X ? h = a : Array.isArray(o) ? h = n === _r.Y ? o[0] : o[1] : n === Or.CIRCULAR ? h = u : h = o, h;
            }
            function ik(t, n, a, o) {
              var u = 0;
              return jp.every(function(h) {
                var v = of(h, n, a);
                return u = h, v > t || v / 2 > o.x;
              }), t < n || n / 2 > o.x ? u : 0;
            }
            function cy(t, n, a) {
              var o = t[a], u = n[a];
              return !o && !u ? !1 : (o == null ? void 0 : o.maxLabelWidth) !== (u == null ? void 0 : u.maxLabelWidth);
            }
            function ak(t, n) {
              return cy(t, n, "yAxis") || cy(t, n, "secondaryYAxis");
            }
            function ok(t, n) {
              var a = t.xAxis.maxHeight, o = n.xAxis.maxHeight;
              return a !== o;
            }
            function fy(t, n) {
              return ak(t, n) || ok(t, n);
            }
            function dy(t) {
              var n, a, o;
              return (n = t == null || (a = t.xAxis) === null || a === void 0 || (o = a.label) === null || o === void 0 ? void 0 : o.rotatable) !== null && n !== void 0 ? n : !0;
            }
            function Gp(t, n) {
              var a = t.labels, o = t.pointOnColumn, u = t.labelDistance, h = t.tickDistance, v = t.labelInterval, g = t.tickInterval, b = t.tickCount, C = t.scale, R = n, I = 0, W = 0;
              if (C) {
                var Z, ue, ke = (Z = C == null ? void 0 : C.sizeRatio) !== null && Z !== void 0 ? Z : 1, Ee = (ue = C == null ? void 0 : C.positionRatio) !== null && ue !== void 0 ? ue : 0;
                R = n * ke, I = n * Ee;
              } else {
                var Le = v === g ? v : 1;
                W = o ? (u ?? h * Le) / 2 : 0;
              }
              var je = Fi(R, b, I);
              return a.reduce(function(Ke, ut, bt) {
                var mt = je[bt] + W, Rt = !(bt % v) && mt <= n;
                return Rt ? [].concat(Ya(Ke), [{
                  offsetPos: mt,
                  text: ut
                }]) : Ke;
              }, []);
            }
            function Yp(t) {
              if (we(t))
                return t;
              var n = {
                text: "",
                offsetX: 0,
                offsetY: 0
              };
              return Ie(t) ? aa(aa({}, n), {}, {
                text: t
              }) : aa(aa({}, n), t);
            }
            function hy(t, n) {
              var a, o, u, h = aa(aa({}, qa(t)), {}, {
                xAxis: t.xAxis
              });
              return (a = (o = h[n]) === null || o === void 0 || (u = o.label) === null || u === void 0 ? void 0 : u.formatter) !== null && a !== void 0 ? a : function(v) {
                return v;
              };
            }
            function py(t, n, a, o) {
              var u, h = lf(n == null || (u = n[o]) === null || u === void 0 ? void 0 : u.date), v = a && h ? t.map(function(b) {
                return H(h, new Date(b));
              }) : t, g = hy(n, o);
              return v.map(function(b, C) {
                return g(b, {
                  index: C,
                  labels: t,
                  axisName: o
                });
              });
            }
            function vy(t, n, a, o, u) {
              var h = ik(a, t, n, u);
              return !o || h === 0 ? {
                needRotateLabel: !1,
                radian: 0,
                rotationHeight: n
              } : {
                needRotateLabel: h > 0,
                radian: Pr(h, 0),
                rotationHeight: sf(h, t, n)
              };
            }
            function Yo(t, n) {
              var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _i, o = t.reduce(function(u, h) {
                return u.length > h.length ? u : h;
              }, "");
              return {
                maxLabelWidth: ni(o, a) + n,
                maxLabelHeight: Vs(o, a)
              };
            }
            function qp(t, n) {
              var a, o, u;
              if (t === "xAxis")
                return 0;
              var h = qa(n);
              return Math.abs((a = h == null || (o = h[t]) === null || o === void 0 || (u = o.label) === null || u === void 0 ? void 0 : u.margin) !== null && a !== void 0 ? a : 0);
            }
            function hf(t, n) {
              var a, o, u, h = n.axis, v = n.categories, g = n.layout, b = n.isCoordinateTypeChart, C = h == null || (a = h.tick) === null || a === void 0 ? void 0 : a.interval, R = h == null || (o = h.label) === null || o === void 0 ? void 0 : o.interval, I = Me(C) || Me(R), W = t && !Me(h == null || (u = h.scale) === null || u === void 0 ? void 0 : u.stepSize) && !n.shift && !I && !b, Z = W ? sk(v, g) : 1, ue = W ? Z : 1, ke = {
                tickInterval: C ?? Z,
                labelInterval: R ?? ue
              };
              return ke;
            }
            function sk(t, n) {
              if (!t || !n)
                return 1;
              var a = n.xAxis.width, o = t.length;
              return cf(o, a, t);
            }
            function my(t, n) {
              var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, u = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, h = n.width / 2;
              if (u) {
                var v = zo(t == null ? void 0 : t.series), g = v.startAngle, b = v.endAngle, C = v.clockwise, R = $e(C, g, b);
                return {
                  isSemiCircular: R,
                  axisSize: xi(n, R, a, o),
                  centerX: h,
                  centerY: R ? st(n.height, C) : n.height / 2,
                  totalAngle: Pe(C, g, b),
                  drawingStartAngle: g,
                  clockwise: C,
                  startAngle: g,
                  endAngle: b
                };
              }
              return {
                isSemiCircular: !1,
                axisSize: xi(n, !1, a, o),
                centerX: h,
                centerY: n.height / 2,
                totalAngle: Dr,
                drawingStartAngle: gn,
                clockwise: !0,
                startAngle: gn,
                endAngle: Dr
              };
            }
            function lk(t, n) {
              var a, o, u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, h = be(t, (a = n == null ? void 0 : n.inner) !== null && a !== void 0 ? a : 0), v = be(t, (o = n == null ? void 0 : n.outer) !== null && o !== void 0 ? o : t);
              return {
                radiusRanges: Fi(v - h, u, h).splice(h === 0 ? 1 : 0, u).reverse(),
                innerRadius: h,
                outerRadius: v
              };
            }
            function Kp(t, n) {
              var a;
              return !!((a = t[n]) !== null && a !== void 0 && a.date);
            }
            function qo(t) {
              return Me(t) ? t : Array.isArray(t) ? t[1] : t.y;
            }
            function Ka(t) {
              return Array.isArray(t) ? t[0] : t.x;
            }
            function uk(t, n) {
              var a = _e(n);
              return a ? Me(t) ? t >= Number(a) : new Date(t) >= new Date(a) : !1;
            }
            function Xp(t, n, a, o) {
              if (Me(t))
                return a - o;
              var u = Ka(t), h = n.findIndex(function(v) {
                return v === String(u);
              });
              return h === -1 && uk(u, n) && (h = n.length), h;
            }
            function ck(t) {
              var n;
              if (!t.line)
                return !1;
              var a = De((n = t.line[0]) === null || n === void 0 ? void 0 : n.data);
              return a && (Array.isArray(a) || ot(a));
            }
            function _l(t) {
              return ck(t) || !!t.scatter || !!t.bubble;
            }
            function fk(t, n) {
              var a = t.height, o = t.width, u = n.x, h = n.y;
              return u >= 0 && u <= o && h >= 0 && h <= a;
            }
            function dk(t, n) {
              var a = t.x, o = t.y, u = t.width, h = t.height;
              return n.x >= a && n.x <= a + u && n.y >= o && n.y <= o + h;
            }
            function gy(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function Ko(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? gy(Object(a), !0).forEach(function(o) {
                  hk(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : gy(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function hk(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function Jp(t) {
              return gk(t) || mk(t) || vk(t) || pk();
            }
            function pk() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function vk(t, n) {
              if (t) {
                if (typeof t == "string") return Zp(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return Zp(t, n);
              }
            }
            function mk(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function gk(t) {
              if (Array.isArray(t)) return Zp(t);
            }
            function Zp(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function yy(t) {
              var n, a = !!We(t, ["series", "diverging"]), o = (t == null || (n = t.yAxis) === null || n === void 0 ? void 0 : n.align) === "center";
              return a && o;
            }
            function yk(t, n) {
              var a;
              return oy(t) && !!((a = n.series) !== null && a !== void 0 && a.diverging);
            }
            function bk(t, n, a, o) {
              var u = t.min, h = t.max, v = u <= 0 && h >= 0;
              if (!v || o)
                return null;
              var g = (0 - u) / (h - u) * n;
              return a ? g : n - g;
            }
            function by(t) {
              var n = t.axisSize, a = t.categories, o = t.series, u = t.options, h = t.theme, v = t.scale, g = t.initialAxisData, b = t.isCoordinateTypeChart, C = t.axisName, R = !!o.line, I = rk(o, u), W = Kp(u, C), Z = b ? yo(v.limit, v.stepSize, W) : a, ue = py(Z, u, W, C), ke;
              if (v && R) {
                var Ee = I ? Z : a, Le = Ee.map(function(Lt) {
                  return Number(W ? new Date(Lt) : Lt);
                });
                ke = {
                  min: Math.min.apply(Math, Jp(Le)),
                  max: Math.max.apply(Math, Jp(Le))
                };
              }
              var je = a.length, Ke = je - (I ? 0 : 1), ut = Ke ? n / Ke : n, bt = n / (ue.length - (I ? 0 : 1)), mt = ue.length;
              I && !b && (mt += 1);
              var Rt = Gp(Ko({
                labels: ue,
                pointOnColumn: I,
                tickDistance: ut,
                tickCount: mt,
                scale: v
              }, g), n), Dt = qp(C, u);
              return Ko(Ko({
                labels: ue,
                viewLabels: Rt,
                pointOnColumn: I,
                labelDistance: bt,
                tickDistance: ut,
                tickCount: mt,
                labelRange: ke,
                rectResponderCount: je,
                isLabelAxis: !0
              }, g), Yo(ue, Dt, an(h.label)));
            }
            function Sy(t) {
              var n = t.scale, a = t.axisSize, o = t.series, u = t.options, h = t.centerYAxis, v = t.initialAxisData, g = t.theme, b = t.labelOnYAxis, C = t.axisName, R = n.limit, I = n.stepSize, W = h ? h == null ? void 0 : h.xAxisHalfSize : a, Z = yk(o, u), ue = hy(u, C), ke = bk(R, a, sa({
                series: o,
                options: u
              }), Z), Ee = yo(R, I);
              !h && Z && (Ee = Sk(Ee));
              var Le = Ee.map(function(Dt, Lt) {
                return ue(Dt, {
                  index: Lt,
                  labels: Ee,
                  axisName: C
                });
              }), je = W / Math.max(Ee.length, 1), Ke = Ee.length, ut = !1, bt = Gp(Ko({
                labels: b ? Le : Jp(Le).reverse(),
                pointOnColumn: ut,
                tickDistance: je,
                tickCount: Ke
              }, v), W), mt = qp(C, u), Rt = Ko(Ko({
                labels: Le,
                viewLabels: bt,
                pointOnColumn: ut,
                isLabelAxis: !1,
                tickCount: Ke,
                tickDistance: je
              }, v), Yo(Le, mt, an(g.label)));
              return Me(ke) && (Rt.zeroPosition = ke), Rt;
            }
            function Sk(t) {
              return te(t) ? t.reverse().slice(1).concat(t) : t.slice(1).reverse().concat(t);
            }
            function Qp(t, n) {
              var a, o = hf(t, n), u = Yp(n == null || (a = n.axis) === null || a === void 0 ? void 0 : a.title);
              return u && (o.title = u), o;
            }
            function wk(t, n, a, o, u) {
              var h, v = qa(t), g = v.yAxis, b = v.secondaryYAxis, C = t == null || (h = t.series) === null || h === void 0 ? void 0 : h.shift;
              return {
                xAxis: Qp(!n, {
                  categories: a,
                  axis: t == null ? void 0 : t.xAxis,
                  layout: o,
                  shift: C,
                  isCoordinateTypeChart: u
                }),
                yAxis: Qp(n, {
                  axis: g
                }),
                secondaryYAxis: b ? Qp(n, {
                  axis: b
                }) : null
              };
            }
            function xk(t) {
              var n, a, o = t.state, u = t.labelOnYAxis, h = t.valueAxisSize, v = t.labelAxisSize, g = t.initialAxisData, b = t.isCoordinateTypeChart, C = o.scale, R = o.options, I = o.series, W = o.theme, Z = o.categories;
              return u ? by({
                scale: C.secondaryYAxis,
                axisSize: v,
                categories: (n = (a = qa(R).secondaryYAxis) === null || a === void 0 ? void 0 : a.categories) !== null && n !== void 0 ? n : Z,
                options: R,
                series: I,
                theme: Go(W, _r.SECONDARY_Y),
                initialAxisData: g,
                isCoordinateTypeChart: b,
                axisName: _r.SECONDARY_Y
              }) : Sy({
                scale: C.secondaryYAxis,
                axisSize: h,
                options: R,
                series: I,
                theme: Go(W, _r.SECONDARY_Y),
                centerYAxis: null,
                initialAxisData: g,
                axisName: _r.SECONDARY_Y
              });
            }
            function kk(t) {
              var n = t.axisData, a = t.axisSize, o = t.axisLayout, u = t.centerYAxis, h = t.rotatable, v = t.labelMargin, g = v === void 0 ? 0 : v, b = n.viewLabels, C = n.pointOnColumn, R = n.maxLabelWidth, I = n.maxLabelHeight, W = jo(I) + g, Z = u ? u.xAxisHalfSize : a, ue = Z / (b.length - (C ? 0 : 1)), ke = vy(R, I, ue, h, o), Ee = ke.needRotateLabel, Le = ke.rotationHeight, je = (Ee ? Le : I) + W;
              return Ko(Ko(Ko({}, n), ke), {}, {
                maxHeight: je,
                offsetY: W
              });
            }
            function Ok(t, n, a) {
              var o = ff(t, a), u = o.valueAxisName, h = o.labelAxisName, v = df(t), g = v.valueSizeKey, b = v.labelSizeKey, C = n[g], R = n[b];
              return {
                valueAxisName: u,
                valueAxisSize: C,
                labelAxisName: h,
                labelAxisSize: R
              };
            }
            function Ck(t, n) {
              var a, o;
              return {
                categories: (a = t) !== null && a !== void 0 ? a : [],
                rawCategories: (o = n) !== null && o !== void 0 ? o : []
              };
            }
            var Tk = {
              name: "axes",
              state: function(n) {
                var a = n.series, o = n.options, u = qa(o), h = u.secondaryYAxis, v = {
                  xAxis: {},
                  yAxis: {}
                };
                return a.bar && yy(o) && (v.centerYAxis = {}), h && (v.secondaryYAxis = {}), {
                  axes: v
                };
              },
              action: {
                setAxesData: function(n) {
                  var a, o, u = n.state, h = n.initStoreState, v = u.scale, g = u.options, b = u.series, C = u.layout, R = u.theme, I = C.xAxis, W = C.yAxis, Z = C.plot, ue = _l(h.series), ke = sa({
                    series: b,
                    options: g
                  }), Ee = Ck(u.categories, u.rawCategories), Le = Ee.categories, je = Ok(ke, Z, b), Ke = je.valueAxisName, ut = je.valueAxisSize, bt = je.labelAxisName, mt = je.labelAxisSize, Rt = u.axes.centerYAxis, Dt = wk(g, ke, Le, C, ue), Lt = Sy({
                    scale: v[Ke],
                    axisSize: ut,
                    options: g,
                    series: b,
                    theme: Go(R, Ke),
                    centerYAxis: Rt ? {
                      xAxisHalfSize: (I.width - W.width) / 2
                    } : null,
                    initialAxisData: Dt[Ke],
                    labelOnYAxis: ke,
                    axisName: Ke
                  }), Wt = by({
                    scale: v[bt],
                    axisSize: mt,
                    categories: Le,
                    options: g,
                    series: b,
                    theme: Go(R, bt),
                    initialAxisData: Dt[bt],
                    isCoordinateTypeChart: ue,
                    axisName: bt
                  }), Qt, or;
                  if (u.axes.secondaryYAxis && (Qt = xk({
                    state: u,
                    labelOnYAxis: ke,
                    valueAxisSize: ut,
                    labelAxisSize: mt,
                    initialAxisData: Dt.secondaryYAxis,
                    isCoordinateTypeChart: ue
                  })), Rt) {
                    var lr = (I.width - W.width) / 2;
                    or = Ye(Lt, {
                      x: I.x + lr,
                      xAxisHalfSize: lr,
                      secondStartX: (I.width + W.width) / 2,
                      yAxisLabelAnchorPoint: W.width / 2,
                      yAxisHeight: W.height
                    });
                  }
                  var xr = {
                    xAxis: kk({
                      axisData: ke ? Lt : Wt,
                      axisSize: ke ? ut : mt,
                      axisLayout: C.xAxis,
                      centerYAxis: or,
                      rotatable: dy(g),
                      labelMargin: (a = g.xAxis) === null || a === void 0 || (o = a.label) === null || o === void 0 ? void 0 : o.margin
                    }),
                    yAxis: ke ? Wt : Lt,
                    secondaryYAxis: Qt,
                    centerYAxis: or
                  };
                  fy(u.axes, xr) && this.notify(u, "layout"), u.axes = xr;
                }
              },
              computed: {},
              observe: {
                updateAxes: function() {
                  this.dispatch("setAxesData");
                }
              }
            }, Xa = Tk;
            l(1235), l(6781), l(2144), l(2994), l(3675), l(5825), l(7170), l(8857), l(8329), l(6279), l(427), l(1159), l(2516), l(4349), l(5273), l(6729), l(1801), l(574), l(5787), l(9271), l(3160), l(5688), l(3157), l(3333), l(315), l(8314), l(556), l(9224);
            var wy;
            function Ak(t, n) {
              return n || (n = t.slice(0)), Object.freeze(Object.defineProperties(t, { raw: { value: Object.freeze(n) } }));
            }
            function pn(t) {
              return Dk(t) || Rk(t) || Mk(t) || Ek();
            }
            function Ek() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function Mk(t, n) {
              if (t) {
                if (typeof t == "string") return ev(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return ev(t, n);
              }
            }
            function Rk(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function Dk(t) {
              if (Array.isArray(t)) return ev(t);
            }
            function ev(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            var xy = {
              xls: "data:application/vnd.ms-excel;base64,",
              csv: "data:text/csv;charset=utf-8,%EF%BB%BF"
              /* BOM for utf-8 */
            };
            function Pk() {
              var t, n = !we(document.createElement("a").download), a = !we(window.Blob && window.navigator.msSaveOrOpenBlob);
              return a ? t = _k : n && (t = Nk), t;
            }
            function Lk(t) {
              for (var n = t.substr(0, t.indexOf(";base64,")).substr(t.indexOf(":") + 1), a = 1024, o = atob(t.substr(t.indexOf(",") + 1)), u = [], h = 0; h < o.length; h += a) {
                for (var v = o.slice(h, h + a), g = new Array(v.length), b = 0; b < v.length; b += 1)
                  g[b] = v.charCodeAt(b);
                u.push(new window.Uint8Array(g));
              }
              try {
                return new Blob(u, {
                  type: n
                });
              } catch {
                return new Blob(u.map(function(R) {
                  return R.buffer;
                }), {
                  type: n
                });
              }
            }
            function Ik(t) {
              return t === "jpeg" || t === "png";
            }
            function _k(t, n, a, o) {
              var u = Ik(n) ? Lk(a) : new Blob([a], {
                type: o
              });
              window.navigator.msSaveOrOpenBlob(u, "".concat(t, ".").concat(n));
            }
            function Nk(t, n, a) {
              if (a) {
                var o = document.createElement("a");
                o.href = a, o.target = "_blank", o.download = "".concat(t, ".").concat(n), document.body.appendChild(o), o.click(), o.remove();
              }
            }
            function Bk() {
              var t = function(a) {
                for (var o = arguments.length, u = new Array(o > 1 ? o - 1 : 0), h = 1; h < o; h++)
                  u[h - 1] = arguments[h];
                return a.reduce(function(v, g, b) {
                  return v + u[b - 1] + g;
                });
              };
              return t.apply(void 0, arguments).replace(/\n\s*/g, "");
            }
            function Fk() {
              var t = !we(document.createElement("a").download), n = !we(window.Blob && window.navigator.msSaveOrOpenBlob);
              return !n && t;
            }
            function ky(t, n) {
              return t.reduce(function(a, o, u) {
                var h;
                return !u || a < (o == null || (h = o[n]) === null || h === void 0 ? void 0 : h.length) ? o[n].length : a;
              }, 0);
            }
            function zk(t) {
              var n = t.series, a = n.bullet.data, o = ky(a, "markers"), u = ky(a, "ranges"), h = Mt(0, u).map(function(g) {
                return "Range ".concat(g + 1);
              }), v = Mt(0, o).map(function(g) {
                return "Marker ".concat(g + 1);
              });
              return a.reduce(function(g, b) {
                var C = b.data, R = b.markers, I = b.name, W = b.ranges, Z = h.map(function(ke, Ee) {
                  var Le = W == null ? void 0 : W[Ee];
                  return Le ? "".concat(Le[0], " ~ ").concat(Le[1]) : "";
                }), ue = v.map(function(ke, Ee) {
                  var Le;
                  return (Le = R == null ? void 0 : R[Ee]) !== null && Le !== void 0 ? Le : "";
                });
                return [].concat(pn(g), [[I, C ?? ""].concat(pn(Z), pn(ue))]);
              }, [["", "Actual"].concat(pn(h), pn(v))]);
            }
            function Hk(t) {
              var n = t.categories, a = t.series, o = n.x;
              return a.heatmap.data.reduce(function(u, h) {
                var v = h.data, g = h.yCategory;
                return [].concat(pn(u), [[g].concat(pn(v.map(function(b) {
                  return Oe(b) ? "" : b;
                })))]);
              }, [[""].concat(pn(o))]);
            }
            function Oy(t, n) {
              var a = t.label, o = t.data, u = t.children, h = u === void 0 ? [] : u;
              return o && n.push([a, o]), h.forEach(function(v) {
                return Oy(v, n);
              }), n;
            }
            function jk(t) {
              var n = t.series, a = [["Label", "Data"]];
              return n.treemap.data.forEach(function(o) {
                Oy(o, a);
              }), a;
            }
            function Wk(t) {
              var n = t.series;
              return n.bubble.data.reduce(function(a, o) {
                var u = o.name, h = o.data;
                return [].concat(pn(a), pn(h.map(function(v) {
                  return Oe(v) ? [] : [u, v.label, String(v.x), v.y, v.r];
                })));
              }, [["Name", "Label", "X", "Y", "Radius"]]);
            }
            function $k(t) {
              var n, a = t.series, o = (n = t.categories) !== null && n !== void 0 ? n : [];
              return a.boxPlot.data.reduce(function(u, h) {
                var v = h.name, g = h.data, b = h.outliers, C = (g ?? []).map(function(R, I) {
                  var W, Z = (W = (b ?? []).find(function(ke) {
                    return ke[0] === I;
                  })) === null || W === void 0 ? void 0 : W[1], ue = Z ? [].concat(pn(R), [Z]) : pn(R);
                  return ue.join();
                });
                return [].concat(pn(u), [[v].concat(pn(C))]);
              }, [[""].concat(pn(o))]);
            }
            function Uk(t) {
              var n, a = t.series, o = (n = t.categories) !== null && n !== void 0 ? n : [];
              return a.pie.data.reduce(function(u, h) {
                var v = h.name, g = h.data, b = Array.isArray(g) ? (g ?? []).reduce(function(C, R) {
                  var I;
                  return [].concat(pn(C), [[R.name, (I = R.data) !== null && I !== void 0 ? I : ""]]);
                }, []) : [[v, g ?? ""]];
                return [].concat(pn(u), pn(b));
              }, o.length ? [[""].concat(pn(o))] : []);
            }
            function Vk(t, n, a) {
              return n.map(function(o, u) {
                if (t === "area" && Array.isArray(a[u]))
                  return a[u].join();
                var h = a.find(function(v) {
                  return o === String(Ka(v));
                });
                return h ? qo(h) : "";
              });
            }
            function Gk(t) {
              var n = t.series, a = t.categories;
              return Object.keys(n).reduce(function(o, u) {
                var h = n[u].data.map(function(v) {
                  var g = v.name, b = v.data, C = !Me(De(b)) && Ve(["line", "area", "scatter"], u) ? Vk(u, a, b) : b.map(function(R) {
                    return Array.isArray(R) ? R.join() : R;
                  });
                  return [g].concat(pn(C));
                });
                return [].concat(pn(o), pn(h));
              }, n.gauge ? [] : [[""].concat(pn(a))]);
            }
            function Yk(t) {
              var n, a = t.series;
              return a.bullet ? n = zk(t) : a.heatmap ? n = Hk(t) : a.bubble ? n = Wk(t) : a.boxPlot ? n = $k(t) : a.pie ? n = Uk(t) : a.treemap ? n = jk(t) : n = Gk(t), n;
            }
            function qk(t) {
              var n = "<table>";
              return t.forEach(function(a, o) {
                var u = o === 0 ? "th" : "td";
                n += "<tr>", a.forEach(function(h, v) {
                  var g = o !== 0 || v === 0 ? ' class="number"' : "", b = "<".concat(u).concat(g, ">").concat(h, "</").concat(u, ">");
                  n += b;
                }), n += "</tr>";
              }), n += "</table>", n;
            }
            function Kk(t) {
              return Bk(wy || (wy = Ak([`<html xmlns:o="urn:schemas-microsoft-com:office:office"
        xmlns:x="urn:schemas-microsoft-com:office:excel"
        xmlns="http://www.w3.org/TR/REC-html40">
        <head>
            <!--[if gte mso 9]>
                <xml>
                    <x:ExcelWorkbook>
                        <x:ExcelWorksheets>
                            <x:ExcelWorksheet>
                                <x:Name>Ark1</x:Name>
                                <x:WorksheetOptions>
                                    <x:DisplayGridlines/>
                                </x:WorksheetOptions>
                            </x:ExcelWorksheet>
                        </x:ExcelWorksheets>
                        </x:ExcelWorkbook>
                </xml>
            <![endif]-->
            <meta name=ProgId content=Excel.Sheet>
            <meta charset=UTF-8>
        </head>
        <body>
            `, `
        </body>
        </html>`])), qk(t));
            }
            function Xk(t) {
              var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, a = n.lineDelimiter, o = a === void 0 ? `
` : a, u = n.itemDelimiter, h = u === void 0 ? "," : u, v = t.length - 1, g = "";
              return t.forEach(function(b, C) {
                var R = b.length - 1;
                b.forEach(function(I, W) {
                  var Z = Me(I) ? I : '"'.concat(I, '"');
                  g += Z, W < R && (g += h);
                }), C < v && (g += o);
              }), g;
            }
            function Cy(t, n, a, o) {
              var u = Pk();
              !Ie(a) || !u || u(t, n, a, o);
            }
            function Jk(t, n, a) {
              var o = Yk(a), u = xy[n].replace(/(data:|;base64,|,%EF%BB%BF)/g, ""), h = "";
              n === "csv" ? h = encodeURIComponent(Xk(o)) : h = Kk(o), Fk() && (n !== "csv" && (h = window.btoa(unescape(encodeURIComponent(h)))), h = xy[n] + h), Cy(t, n, h, u);
            }
            function pf(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? pf = function(a) {
                return typeof a;
              } : pf = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, pf(t);
            }
            function Zk(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function Qk(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function eO(t, n, a) {
              return n && Qk(t.prototype, n), t;
            }
            function tO(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && tv(t, n);
            }
            function tv(t, n) {
              return tv = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, tv(t, n);
            }
            function rO(t) {
              var n = iO();
              return function() {
                var o = vf(t), u;
                if (n) {
                  var h = vf(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return nO(this, u);
              };
            }
            function nO(t, n) {
              return n && (pf(n) === "object" || typeof n == "function") ? n : Wi(t);
            }
            function Wi(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function iO() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function vf(t) {
              return vf = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, vf(t);
            }
            function la(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var aO = 140, Ty = {
              IMAGES: ["png", "jpeg"],
              SPREAD_SHEETS: ["xls", "csv"]
            }, sn = 24, Hn = /* @__PURE__ */ function(t) {
              tO(a, t);
              var n = rO(a);
              function a() {
                var o;
                Zk(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), la(Wi(o), "responders", void 0), la(Wi(o), "models", {
                  exportMenuButton: []
                }), la(Wi(o), "opened", !1), la(Wi(o), "fileName", void 0), la(Wi(o), "data", void 0), la(Wi(o), "chartEl", void 0), la(Wi(o), "exportMenuEl", void 0), la(Wi(o), "theme", void 0), la(Wi(o), "chartBackgroundColor", void 0), la(Wi(o), "chartWidth", 0), la(Wi(o), "toggleExportMenu", function() {
                  o.opened = !o.opened, o.models.exportMenuButton[0].opened = o.opened, o.eventBus.emit("needDraw"), o.opened ? (o.applyPanelWrapperStyle(), o.chartEl.appendChild(o.exportMenuEl)) : o.chartEl.removeChild(o.exportMenuEl);
                }), la(Wi(o), "getCanvasExportBtnRemoved", function() {
                  var g = o.chartEl.getElementsByTagName("canvas")[0], b = g.getContext("2d"), C = o.rect, R = C.x, I = C.y, W = C.height, Z = C.width;
                  return b.clearRect(R, I, Z, W), b.fillStyle = o.chartBackgroundColor, b.fillRect(R, I, Z, W), g;
                }), la(Wi(o), "onClickExportButton", function(g) {
                  var b = g.target.id, C = Ty.IMAGES.includes(b), R = Ty.SPREAD_SHEETS.includes(b);
                  if (C) {
                    var I = o.getCanvasExportBtnRemoved();
                    Cy(o.fileName, b, I.toDataURL("image/".concat(b), 1));
                  } else R && Jk(o.fileName, b, o.data);
                  (C || R) && o.toggleExportMenu();
                }), o;
              }
              return eO(a, [{
                key: "applyExportButtonPanelStyle",
                value: function() {
                  var u = this.exportMenuEl.querySelector(".toastui-chart-export-menu-title"), h = this.exportMenuEl.querySelector(".toastui-chart-export-menu-btn-wrapper");
                  u.setAttribute("style", this.makePanelStyle("header")), h.setAttribute("style", this.makePanelStyle("body"));
                }
              }, {
                key: "makeExportMenuButton",
                value: function() {
                  var u = document.createElement("div");
                  return u.onclick = this.onClickExportButton, u.innerHTML = `
        <div class="toastui-chart-export-menu">
          <p class="toastui-chart-export-menu-title">Export to</p>
          <div class="toastui-chart-export-menu-btn-wrapper">
            <button class="toastui-chart-export-menu-btn" id="xls">xls</button>
            <button class="toastui-chart-export-menu-btn" id="csv">csv</button>
            <button class="toastui-chart-export-menu-btn" id="png">png</button>
            <button class="toastui-chart-export-menu-btn" id="jpeg">jpeg</button>
          </div>
        </div>
      `, u;
                }
              }, {
                key: "initialize",
                value: function(u) {
                  var h = u.chartEl;
                  this.chartEl = h, this.type = "exportMenu", this.name = "exportMenu", this.exportMenuEl = this.makeExportMenuButton();
                }
              }, {
                key: "onClick",
                value: function(u) {
                  var h = u.responders;
                  h.length && this.toggleExportMenu();
                }
              }, {
                key: "getFileName",
                value: function(u) {
                  var h;
                  return Ie(u) ? u : (h = u == null ? void 0 : u.text) !== null && h !== void 0 ? h : "toast-ui-chart";
                }
              }, {
                key: "render",
                value: function(u) {
                  var h, v = u.options, g = u.layout, b = u.chart, C = u.series, R = u.rawCategories, I = u.theme;
                  this.isShow = Iy(v), this.chartWidth = b.width, this.isShow && (this.chartBackgroundColor = I.chart.backgroundColor, this.theme = I.exportMenu, this.data = {
                    series: C,
                    categories: R
                  }, this.fileName = this.getFileName((v == null || (h = v.exportMenu) === null || h === void 0 ? void 0 : h.filename) || b.title), this.applyExportButtonPanelStyle(), this.rect = g.exportMenu, this.models.exportMenuButton = [{
                    type: "exportMenuButton",
                    x: 0,
                    y: 0,
                    opened: this.opened,
                    theme: this.theme.button
                  }], this.responders = [{
                    type: "rect",
                    width: sn,
                    height: sn,
                    x: 0,
                    y: 0
                  }]);
                }
              }, {
                key: "applyPanelWrapperStyle",
                value: function() {
                  var u = this.exportMenuEl.querySelector(".toastui-chart-export-menu"), h = this.chartWidth - aO - Br.X, v = Br.Y + sn + 5, g = this.theme.panel, b = g.borderRadius, C = g.borderWidth, R = g.borderColor, I = `
      transform: `.concat(Bo(h, v), `;
      border: `).concat(C, "px solid ").concat(R, `;
      border-radius: `).concat(b, "px;");
                  u.setAttribute("style", I);
                }
              }, {
                key: "makePanelStyle",
                value: function(u) {
                  var h = this.theme.panel[u], v = u === "header" ? "top" : "bottom", g = this.theme.panel, b = g.borderRadius, C = g.borderWidth, R = "".concat(b - C, "px");
                  return ["".concat(En(h)), "border-".concat(v, "-left-radius: ").concat(R, ";"), "border-".concat(v, "-right-radius: ").concat(R, ";"), "background-color: ".concat(h.backgroundColor, ";")].join("");
                }
              }]), a;
            }(Lr);
            function Ay(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function mf(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? Ay(Object(a), !0).forEach(function(o) {
                  oO(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : Ay(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function oO(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function sO(t, n) {
              var a = n.x, o = n.y, u = n.text, h = n.textAlign, v = n.textBaseline, g = n.opacity, b = n.callout, C = n.theme, R = n.radian, I = C.color, W = C.textBubble, Z = Si(C), ue = {
                textAlign: h,
                textBaseline: v,
                font: Z,
                fillStyle: I
              }, ke = fO(C);
              if (b) {
                var Ee = b.theme, Le = Ee.lineWidth, je = Ee.lineColor;
                Wr(t, mf(mf({
                  type: "line"
                }, Ue(b, "x", "y", "x2", "y2")), {}, {
                  strokeStyle: je,
                  lineWidth: Le
                }));
              }
              if (W != null && W.visible) {
                Ey(t, n);
                return;
              }
              Ni(t, {
                x: a,
                y: o,
                text: u,
                style: [ue],
                stroke: [ke],
                opacity: g,
                radian: R
              });
            }
            function Ey(t, n) {
              var a = n.text, o = n.theme, u = n.radian, h = u === void 0 ? 0 : u, v = o, g = v.color, b = v.textStrokeColor, C = Si(o), R = lO(n), I = R.x, W = R.y, Z = R.width, ue = R.height;
              $a(t, {
                radian: h,
                rotationPosition: {
                  x: n.x,
                  y: n.y
                },
                bubble: R,
                label: {
                  x: I + Z / 2,
                  y: W + ue / 2,
                  text: a,
                  style: [{
                    font: C,
                    fillStyle: g,
                    textAlign: "center",
                    textBaseline: "middle"
                  }],
                  strokeStyle: b
                }
              });
            }
            function rv(t, n, a) {
              var o = n.x, u = n.y, h = a.width, v = a.height, g = [];
              return t === "top" ? g = [{
                x: o - h / 2,
                y: u + v
              }, {
                x: o,
                y: u
              }, {
                x: o + h / 2,
                y: u + v
              }] : t === "bottom" ? g = [{
                x: o + h / 2,
                y: u - v
              }, {
                x: o,
                y: u
              }, {
                x: o - h / 2,
                y: u - v
              }] : t === "right" ? g = [{
                x: o - v,
                y: u - h / 2
              }, {
                x: o,
                y: u
              }, {
                x: o - v,
                y: u + h / 2
              }] : t === "left" && (g = [{
                x: o + v,
                y: u + h / 2
              }, {
                x: o,
                y: u
              }, {
                x: o + v,
                y: u - h / 2
              }]), g;
            }
            function lO(t) {
              var n = t.text, a = t.theme, o = t.textAlign, u = t.textBaseline, h = Si(a), v = a.textBubble, g = v.arrow, b = v.paddingX, C = v.paddingY, R = v.borderRadius, I = v.borderColor, W = v.borderWidth, Z = v.backgroundColor, ue = v.shadowBlur, ke = v.shadowOffsetX, Ee = v.shadowOffsetY, Le = v.shadowColor, je = ni(n, h), Ke = je + b * 2, ut = Vs(n, h) + C * 2, bt = t.x, mt = t.y;
              o === "center" ? bt -= Ke / 2 : Ve(["right", "end"], o) && (bt -= Ke), u === "middle" ? mt -= ut / 2 : u === "bottom" && (mt -= ut);
              var Rt = {
                x: bt,
                y: mt,
                width: Ke,
                height: ut
              };
              return mf(mf({}, Rt), {}, {
                radius: R,
                lineWidth: W,
                fill: Z,
                strokeStyle: I,
                style: [{
                  shadowBlur: ue,
                  shadowOffsetX: ke,
                  shadowOffsetY: Ee,
                  shadowColor: Le
                }]
              }, uO(Rt, o, u, g));
            }
            function uO(t, n, a, o) {
              var u;
              if (!(o != null && o.visible))
                return null;
              var h = o.height, v = t.width, g = t.height, b = (u = o.direction) !== null && u !== void 0 ? u : cO(n, a), C = t.x, R = t.y, I = t.x, W = t.y;
              return b === "top" ? R += h : b === "bottom" ? (R -= h, W += g) : b === "right" ? (C -= h, I += v) : b === "left" && (C += h), n === "center" ? I = t.x + v / 2 : a === "middle" && (W = t.y + g / 2), {
                direction: b,
                points: rv(b, {
                  x: I,
                  y: W
                }, o),
                x: C,
                y: R
              };
            }
            function cO(t, n) {
              var a = "top";
              return t === "center" && n === "top" ? a = "top" : t === "center" && n === "bottom" ? a = "bottom" : n === "middle" && t === "right" ? a = "right" : n === "middle" && t === "left" && (a = "left"), a;
            }
            function fO(t) {
              var n = t.textStrokeColor, a = Ue(t, "lineWidth", "shadowColor", "shadowBlur");
              return n && (a.strokeStyle = n), a;
            }
            function My(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function gf(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? My(Object(a), !0).forEach(function(o) {
                  dO(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : My(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function dO(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var wo = 12, Ta = {
              HEIGHT: 6,
              PADDING: 5
            }, Aa = {
              HEIGHT: 28,
              POINT_WIDTH: 8,
              POINT_HEIGHT: 6,
              PADDING: 6
            };
            function hO(t) {
              var n = t.align, a = t.x, o = t.y, u = t.labels, h = t.width, v = Ta.PADDING, g, b;
              return n === "top" ? (g = a, b = o + wo + v) : n === "bottom" ? (g = a, b = o + Aa.HEIGHT) : n === "left" ? (g = a + Oa(u) + v, b = o + wo / 2) : (g = a + h - (Oa(u) + Br.X + v * 2 + Ta.HEIGHT), b = o + wo / 2), {
                x: g,
                y: b
              };
            }
            function pO(t) {
              var n = t.align, a = t.x, o = t.y, u = t.labels, h = t.width, v, g;
              return n === "top" ? (v = a, g = o) : n === "bottom" ? (v = a, g = o + Aa.HEIGHT + Ta.HEIGHT + Ta.PADDING) : n === "left" ? (v = a + Oa(u), g = o) : (v = a + h - Oa(u) - Br.X, g = o), {
                x: v,
                y: g
              };
            }
            function nv(t, n, a) {
              var o = Ta.HEIGHT, u = a ? t : o, h = a ? o : n - wo;
              return {
                barWidth: u,
                barHeight: h
              };
            }
            function vO(t, n) {
              var a = n.labels, o = n.align, u = n.x, h = n.y, v = n.width, g = n.height, b = n.verticalAlign, C = nv(v, g, b), R = C.barWidth, I = C.barHeight, W = a.length - 1, Z = {
                left: {
                  textAlign: "right",
                  textBaseline: "top"
                },
                right: {
                  textAlign: "left",
                  textBaseline: "top"
                },
                top: {
                  textAlign: "center",
                  textBaseline: "top"
                },
                bottom: {
                  textAlign: "center",
                  textBaseline: "top"
                }
              };
              a.forEach(function(ue, ke) {
                var Ee = b ? u + R / W * ke : u, Le = b ? h : h + I / W * ke;
                Ni(t, {
                  x: Ee,
                  y: Le,
                  text: ue,
                  style: ["default", Z[o]]
                });
              });
            }
            function mO(t, n) {
              var a = n.width, o = n.height, u = n.startColor, h = n.endColor, v = n.x, g = n.y, b = n.verticalAlign, C = nv(a, o, b), R = C.barWidth, I = C.barHeight, W = b ? t.createLinearGradient(v, g, v + R, g) : t.createLinearGradient(v, g, v, g + I);
              W.addColorStop(0, u), W.addColorStop(1, h), t.fillStyle = W, t.fillRect(v, g, R, I);
            }
            function gO(t) {
              var n = t.align, a = t.colorRatio, o = t.width, u = t.height, h = t.x, v = t.y, g = t.labels, b = t.verticalAlign, C = nv(o, u, b), R = C.barWidth, I = C.barHeight, W = Ta.PADDING, Z = Ta.HEIGHT;
              if (n === "top")
                return {
                  x: h + R * a,
                  y: v + wo + Z + W * 2
                };
              if (n === "bottom")
                return {
                  x: h + R * a,
                  y: v + wo + W * 2
                };
              if (n === "left")
                return {
                  x: h + Oa(g) + Z + W * 2,
                  y: v + I * a + W
                };
              if (n === "right")
                return {
                  x: h + o - (Oa(g) + Br.X + W * 3 + Z),
                  y: v + I * a + W
                };
            }
            function yO(t, n) {
              var a = pO(n), o = hO(n);
              vO(t, gf(gf({}, n), a)), mO(t, gf(gf({}, n), o));
            }
            function bO(t, n) {
              var a = gO(n), o = a.x, u = a.y, h = Aa.PADDING, v = Aa.POINT_HEIGHT, g = Aa.POINT_WIDTH, b = n.align, C = n.text, R = n.color, I = ni(C), W = I + h * 2, Z = wo + h * 2, ue = b, ke = o, Ee = u;
              b === "top" ? Ee += v : b === "right" ? (ke -= W / 2 + v, Ee -= Z / 2) : b === "left" ? (ke += W / 2 + v, Ee -= Z / 2) : b === "bottom" && (Ee -= Z + v);
              var Le = rv(b, {
                x: o,
                y: u
              }, {
                width: g,
                height: v
              });
              $a(t, {
                bubble: {
                  x: ke - W / 2,
                  y: Ee,
                  width: W,
                  height: Z,
                  points: Le,
                  direction: ue,
                  fill: R
                },
                label: {
                  text: C,
                  x: ke,
                  y: Ee + Z / 2,
                  style: [{
                    font: "normal 11px Arial",
                    fillStyle: "#333333",
                    textAlign: "center",
                    textBaseline: "middle"
                  }]
                }
              });
            }
            function Ry(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function Js(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? Ry(Object(a), !0).forEach(function(o) {
                  SO(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : Ry(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function SO(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var Br = {
              X: 10,
              Y: 15
            }, yf = 20, wO = 40;
            function xo(t) {
              return t === "top" || t === "bottom";
            }
            function iv(t, n, a) {
              var o, u;
              return {
                height: (o = t == null ? void 0 : t.height) !== null && o !== void 0 ? o : a,
                width: (u = t == null ? void 0 : t.width) !== null && u !== void 0 ? u : n
              };
            }
            function xO(t) {
              var n;
              return (n = t.xAxis) !== null && n !== void 0 && n.height && !t.yAxis ? t.xAxis.height : yf;
            }
            function Dy(t) {
              var n = t.yAxisTitle, a = t.isRightSide, o = t.visibleSecondaryYAxis, u = av(t);
              return a && o ? Math.max(n.x + n.width - u, 0) : n.x;
            }
            function kO(t) {
              var n = t.chartSize, a = t.legend, o = t.circleLegend, u = t.hasCenterYAxis, h = t.maxLabelWidth, v = n.width, g = a.align, b = av(t), C = Dy(t);
              return u && (b = h + (Ur + Br.X) * 2, C = (v - a.width - b + Br.X * 2) / 2), a.visible && g === "left" && (C = Dy(t)), o.visible && g === "left" && (C = Math.max(o.width + Br.X, C)), C;
            }
            function OO(t) {
              var n = t.yAxisTitle;
              return n.y + n.height;
            }
            function av(t) {
              var n, a, o = t.maxLabelWidth, u = t.size, h = t.isRightSide;
              return (n = u == null || (a = u[h ? "secondaryYAxis" : "yAxis"]) === null || a === void 0 ? void 0 : a.width) !== null && n !== void 0 ? n : o;
            }
            function CO(t) {
              var n = t.hasCenterYAxis, a = t.hasXYAxis, o = t.maxLabelWidth, u = t.visibleSecondaryYAxis, h = u === void 0 ? !1 : u, v = t.isRightSide, g = v === void 0 ? !1 : v, b = av(t);
              return n && !g ? b = o + (Ur + Br.X) * 2 : (!a || g && !h) && (b = 0), b;
            }
            function TO(t) {
              var n, a, o = t.chartSize, u = t.legend, h = t.yAxisTitle, v = t.hasXYAxis, g = t.size, b = t.xAxisTitleHeight, C = o.height, R = u.align, I = u.height, W = xO(g), Z = h.y + h.height, ue = C - Z - W - b;
              if (v || (ue = C - Z), u.visible) {
                var ke = Math.max(Z, I);
                R === "top" ? ue = C - ke - (v ? yf + b : 0) : R === "bottom" && (ue = C - Z - yf - b - I);
              }
              return !(g != null && (n = g.yAxis) !== null && n !== void 0 && n.height) && g !== null && g !== void 0 && (a = g.plot) !== null && a !== void 0 && a.height && (ue = g.plot.height), ue;
            }
            function Py(t) {
              var n = t.size, a = t.isRightSide, o = a === void 0 ? !1 : a, u = kO(t), h = OO(t), v = CO(t), g = TO(t);
              return Js({
                x: u,
                y: h
              }, iv(o ? n == null ? void 0 : n.secondaryYAxis : n == null ? void 0 : n.yAxis, v, g));
            }
            function AO(t) {
              var n = t.chartSize, a = t.yAxis, o = t.hasCenterYAxis, u = t.legend, h = t.circleLegend, v = t.secondaryYAxis, g = t.xAxisData, b = n.width, C = u.align, R = u.width, I = xo(C), W;
              return I ? (W = b - (a.x + a.width + Br.X), h.visible && (W -= h.width)) : W = b - (a.width + Math.max(R, h.visible ? h.width : 0)), o && (W = b - (I ? 0 : R) - Br.X * 2), v.width && (W -= v.width), g != null && g.maxLabelWidth && (W -= g.maxLabelWidth * 0.5), W;
            }
            function EO(t) {
              var n, a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
              return a ? (n = t == null ? void 0 : t.maxHeight) !== null && n !== void 0 ? n : yf : 0;
            }
            function MO(t) {
              var n = t.hasXYAxis, a = t.hasCenterYAxis, o = t.yAxis, u = t.size, h = t.xAxisData, v = a ? Br.X * 2 : o.x + o.width, g = o.y + o.height, b = AO(t), C = EO(h, n);
              return Js({
                x: v,
                y: g
              }, iv(u == null ? void 0 : u.xAxis, b, C));
            }
            function RO(t) {
              var n = t.legend, a = t.xAxis, o = t.yAxis, u = t.chartSize, h = t.title, v = t.hasXYAxis, g = t.secondaryYAxis, b = t.xAxisTitleHeight;
              if (!n.visible)
                return {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
                };
              var C = n.align, R = n.width, I = n.height, W = u.width, Z = xo(C), ue = a.x + a.width + g.width + Br.X, ke = Math.max(o.y, sn);
              return Z ? (ue = (W - R) / 2, C === "top" ? ke = h.y + h.height : ke = o.y + o.height + (v ? a.height + b : Br.Y)) : C === "left" && (ue = Br.X), {
                width: R,
                height: I,
                x: ue,
                y: ke
              };
            }
            function DO(t, n, a, o) {
              return {
                width: o,
                height: n.height,
                x: a === "left" ? Br.X : t.x + t.width + Br.X,
                y: n.y
              };
            }
            function PO(t, n, a) {
              return Js({
                x: t.x,
                y: n.y
              }, iv(a, t.width, n.height));
            }
            function LO(t, n, a, o) {
              var u = {
                x: Br.X,
                y: Br.Y
              }, h = 5, v = a ? t.width - n.width : 0, g = a ? Math.max(o + h, n.height) : n.height;
              return Js({
                width: v,
                height: g
              }, u);
            }
            function IO(t, n) {
              return t ? wo + Ta.PADDING * 2 + Aa.POINT_HEIGHT + Aa.HEIGHT + Br.Y : n + Br.Y;
            }
            function Ly(t) {
              var n = t.chartSize, a = t.visible, o = t.title, u = t.legend, h = u.align, v = u.width, g = u.height, b = u.visible, C = u.useSpectrumLegend, R = t.hasCenterYAxis, I = t.visibleSecondaryYAxis, W = t.isRightSide, Z = W === void 0 ? !1 : W, ue = t.yAxisTitleHeight, ke = 5, Ee = a ? ue + ke : 0, Le = xo(h), je = (n.width - (Le ? Br.X * 2 : v)) / (I ? 2 : 1), Ke = {
                x: Z ? o.x + je : o.x,
                y: o.y + o.height
              };
              return b && (h === "left" ? Ke.x += v : h === "top" && (Ke.y += IO(C, g))), R && (Ke.x = (je + Br.X * 2) / 2), Js({
                height: Ee,
                width: je
              }, Ke);
            }
            function _O(t, n, a) {
              var o = {
                x: n.x,
                y: n.y + n.height
              }, u = t ? a : 0, h = t ? n.width : 0;
              return Js({
                height: u,
                width: h
              }, o);
            }
            function NO(t, n) {
              var a = 5, o = n ? Br.X + t.width - sn : Br.X + t.width, u = Br.Y, h = n ? sn + a : 0, v = n ? sn : 0;
              return {
                x: o,
                y: u,
                height: h,
                width: v
              };
            }
            function BO(t, n) {
              var a = 5, o = n ? t.x - sn - Br.X : 0, u = n ? t.y : 0, h = n ? sn + a : 0, v = n ? sn : 0;
              return {
                x: o,
                y: u,
                height: h,
                width: v
              };
            }
            function ov(t) {
              var n;
              return !!((n = t.series) !== null && n !== void 0 && n.zoomable);
            }
            function Iy(t) {
              var n, a = (n = t.exportMenu) === null || n === void 0 ? void 0 : n.visible;
              return we(a) ? !0 : a;
            }
            function _y(t) {
              return t ? t + Br.X : wO;
            }
            function bf(t) {
              return !t || we(t.width) && we(t.height) ? null : Ue(t, "width", "height");
            }
            function sv(t, n, a) {
              var o = t[a], u = n[a];
              if (Me(o) && Me(u))
                return Math.max(o, u);
            }
            function FO(t) {
              var n = bf(t.xAxis), a = qa(t), o = bf(a.yAxis), u = bf(a.secondaryYAxis), h = bf(t.plot);
              return h && (n && (n.width = h.width = sv(n, h, "width")), o && (o.height = h.height = sv(o, h, "height")), u && (u.height = h.height = sv(u, h, "height"))), {
                xAxis: n,
                yAxis: o,
                plot: h,
                secondaryYAxis: u
              };
            }
            function Ny(t) {
              var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, a = Array.isArray(t) ? Math.max(t[0].title.fontSize, t[1].title.fontSize) : t.title.fontSize;
              return a + n;
            }
            function zO(t, n, a) {
              var o = t.width, u = t.height;
              if (!(o < 0 || u < 0)) {
                var h = n.title, v = n.yAxisTitle, g = n.yAxis, b = n.xAxis, C = n.xAxisTitle, R = n.legend, I = n.secondaryYAxis, W = a.align, Z = xo(W), ue = Z ? R.height : 0, ke = b.height + C.height + g.height + v.height + h.height + ue - u;
                ke > 0 && (g.height -= ke, b.y -= ke, C.y -= ke, Z && (R.y -= ke)), I.x = b.x + b.width, I.height = g.height;
              }
            }
            function HO(t, n, a) {
              var o;
              if (!a)
                return Js({}, t);
              var u = t.x, h = t.y, v = a.centerX, g = a.centerY, b = a.axisSize, C = a.title, R = a.radius.outer, I = (o = C == null ? void 0 : C.offsetY) !== null && o !== void 0 ? o : 0;
              return {
                x: v + u - b / 2,
                y: g + h - R / 2,
                width: b,
                height: n.title.fontSize + I
              };
            }
            function jO(t) {
              return !(t.pie || t.radar || t.treemap || t.radialBar || t.gauge);
            }
            function WO(t, n) {
              return n ? qa(t) : {
                yAxis: null,
                secondaryYAxis: null
              };
            }
            var $O = {
              name: "layout",
              state: function() {
                return {
                  layout: {}
                };
              },
              action: {
                setLayout: function(n) {
                  var a, o, u, h, v, g, b, C, R, I = n.state, W = I.legend, Z = I.theme, ue = I.circleLegend, ke = I.series, Ee = I.options, Le = I.chart, je = I.axes, Ke = I.radialAxes, ut = Le.width, bt = Le.height, mt = {
                    height: bt - Br.Y * 2,
                    width: ut - Br.X * 2
                  }, Rt = ke.bar ? yy(Ee) : !1, Dt = jO(ke), Lt = FO(Ee), Wt = WO(Ee, Dt), Qt = Wt.yAxis, or = Wt.secondaryYAxis, lr = !!or, xr = Z.title.fontSize, br = (a = Ny(Z.yAxis, je == null || (o = je.yAxis) === null || o === void 0 || (u = o.title) === null || u === void 0 ? void 0 : u.offsetY)) !== null && a !== void 0 ? a : 0, yr = (h = Ny(Z.xAxis, je == null || (v = je.xAxis) === null || v === void 0 || (g = v.title) === null || g === void 0 ? void 0 : g.offsetY)) !== null && h !== void 0 ? h : 0, Ar = NO(mt, Iy(Ee)), qr = BO(Ar, ov(Ee)), nn = Ar.height ? Ar : qr, tn = LO(mt, nn, !!((b = Ee.chart) !== null && b !== void 0 && b.title), xr), bn = !!(Qt != null && Qt.title) || !!(or != null && or.title), Tn = Ly({
                    chartSize: mt,
                    visible: bn,
                    title: tn,
                    legend: W,
                    hasCenterYAxis: Rt,
                    visibleSecondaryYAxis: lr,
                    yAxisTitleHeight: br
                  }), un = Py({
                    chartSize: mt,
                    legend: W,
                    circleLegend: ue,
                    yAxisTitle: Tn,
                    hasCenterYAxis: Rt,
                    hasXYAxis: Dt,
                    maxLabelWidth: _y(je == null ? void 0 : je.yAxis.maxLabelWidth),
                    size: Lt,
                    xAxisTitleHeight: yr
                  }), Ln = Ly({
                    chartSize: mt,
                    visible: bn,
                    title: tn,
                    legend: W,
                    hasCenterYAxis: Rt,
                    isRightSide: !0,
                    visibleSecondaryYAxis: lr,
                    yAxisTitleHeight: br
                  }), so = Py({
                    chartSize: mt,
                    legend: W,
                    circleLegend: ue,
                    yAxisTitle: Ln,
                    hasCenterYAxis: Rt,
                    hasXYAxis: Dt,
                    maxLabelWidth: _y(je == null || (C = je.secondaryYAxis) === null || C === void 0 ? void 0 : C.maxLabelWidth),
                    size: Lt,
                    isRightSide: !0,
                    visibleSecondaryYAxis: lr,
                    xAxisTitleHeight: yr
                  }), Ro = MO({
                    chartSize: mt,
                    yAxis: un,
                    secondaryYAxis: so,
                    legend: W,
                    circleLegend: ue,
                    hasCenterYAxis: Rt,
                    hasXYAxis: Dt,
                    size: Lt,
                    xAxisData: je == null ? void 0 : je.xAxis
                  }), Ds = _O(!!((R = Ee.xAxis) !== null && R !== void 0 && R.title), Ro, yr), gu = RO({
                    chartSize: mt,
                    xAxis: Ro,
                    yAxis: un,
                    secondaryYAxis: so,
                    title: tn,
                    legend: W,
                    hasXYAxis: Dt,
                    xAxisTitleHeight: yr
                  });
                  zO(mt, {
                    title: tn,
                    yAxisTitle: Tn,
                    yAxis: un,
                    xAxis: Ro,
                    xAxisTitle: Ds,
                    legend: gu,
                    secondaryYAxis: so
                  }, W);
                  var nH = DO(Ro, un, W.align, ue.width), bw = PO(Ro, un, Lt.plot), iH = HO(bw, Z.circularAxis, Ke == null ? void 0 : Ke.circularAxis);
                  Pt(I.layout, {
                    chart: {
                      x: 0,
                      y: 0,
                      width: ut,
                      height: bt
                    },
                    title: tn,
                    plot: bw,
                    legend: gu,
                    circleLegend: nH,
                    xAxis: Ro,
                    xAxisTitle: Ds,
                    yAxis: un,
                    yAxisTitle: Tn,
                    exportMenu: Ar,
                    resetButton: qr,
                    secondaryYAxisTitle: Ln,
                    secondaryYAxis: so,
                    circularAxisTitle: iH
                  });
                }
              },
              observe: {
                updateLayoutObserve: function() {
                  this.dispatch("setLayout");
                }
              }
            }, UO = $O;
            function ko(t) {
              return Array.isArray(t) && t.length === 2;
            }
            function By(t) {
              return Array.isArray(t) && ko(De(t));
            }
            function VO(t, n) {
              return !!(n && (n[0] !== 0 || n[1] !== t.length - 1));
            }
            function Ts(t, n) {
              return n ? t.slice(n[0], n[1] + 1) : t;
            }
            function Fy(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function zy(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? Fy(Object(a), !0).forEach(function(o) {
                  GO(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : Fy(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function GO(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function ec(t, n) {
              if (n)
                return n;
              var a = /* @__PURE__ */ new Set();
              return Object.keys(t).forEach(function(o) {
                var u;
                o === "pie" || o === "gauge" || ((u = t[o].data) !== null && u !== void 0 ? u : t[o]).forEach(function(h) {
                  var v = h.data, g = h.name, b = h.visible;
                  Array.isArray(v) ? v.forEach(function(C) {
                    if (!Oe(C)) {
                      var R = Ka(C);
                      a.add(Me(R) ? R : R.toString());
                    }
                  }) : (o === "bullet" && we(b) || b) && a.add(g);
                });
              }), Array.from(a).sort(Ft).map(function(o) {
                return String(o);
              });
            }
            var YO = {
              name: "category",
              state: function(n) {
                var a = n.categories, o = n.series;
                return {
                  categories: ec(o, a)
                };
              },
              action: {
                setCategory: function(n) {
                  var a = n.state, o = n.computed, u = o.viewRange, h = a.rawCategories;
                  u && (Array.isArray(h) ? h = Ts(h, u) : h = zy(zy({}, h), {}, {
                    x: Ts(h.x, u)
                  })), a.categories = h, this.notify(a, "categories");
                },
                initCategory: function(n) {
                  var a = n.initStoreState, o = n.state, u = o.zoomRange, h = ec(a.series);
                  u && Array.isArray(h) && (h = Ts(h, u)), o.categories = h, this.notify(o, "categories");
                },
                removeCategoryByName: function(n, a) {
                  var o = n.state, u = o.categories.findIndex(function(h) {
                    return h === a;
                  });
                  o.categories.splice(u, 1), this.notify(o, "axes");
                }
              },
              observe: {
                updateCategory: function() {
                  this.dispatch("setCategory");
                }
              }
            }, qO = YO;
            function Hy(t) {
              return JO(t) || XO(t) || Wy(t) || KO();
            }
            function KO() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function XO(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function JO(t) {
              if (Array.isArray(t)) return lv(t);
            }
            function jy(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function tc(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? jy(Object(a), !0).forEach(function(o) {
                  ZO(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : jy(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function ZO(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function rc(t, n) {
              return tC(t) || eC(t, n) || Wy(t, n) || QO();
            }
            function QO() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function Wy(t, n) {
              if (t) {
                if (typeof t == "string") return lv(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return lv(t, n);
              }
            }
            function lv(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function eC(t, n) {
              var a = t && (typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]);
              if (a != null) {
                var o = [], u = !0, h = !1, v, g;
                try {
                  for (a = a.call(t); !(u = (v = a.next()).done) && (o.push(v.value), !(n && o.length === n)); u = !0)
                    ;
                } catch (b) {
                  h = !0, g = b;
                } finally {
                  try {
                    !u && a.return != null && a.return();
                  } finally {
                    if (h) throw g;
                  }
                }
                return o;
              }
            }
            function tC(t) {
              if (Array.isArray(t)) return t;
            }
            function uv(t, n) {
              var a;
              return n ? a = Array.isArray(n) ? n.length : n.x.length : a = Object.keys(ec(t, n)).length, [0, a - 1];
            }
            function rC(t, n, a) {
              var o;
              if (!(!(t.line || t.area || t.column) || !((o = n.series) !== null && o !== void 0 && o.rangeSelectable)))
                return uv(t, a);
            }
            function $y(t, n, a) {
              var o;
              if (!(!(t.line || t.area) || !((o = n.series) !== null && o !== void 0 && o.zoomable)))
                return uv(t, a);
            }
            function nC(t, n, a) {
              var o;
              if (!(!(t.line || t.area || t.column || t.heatmap) || !((o = n.series) !== null && o !== void 0 && o.shift)))
                return uv(t, a);
            }
            function iC(t, n, a) {
              var o = rc(a, 2), u = o[0], h = o[1], v, g;
              return Mt(u, h + 1).forEach(function(b) {
                var C = t.findIndex(function(I) {
                  return Ka(I).toString() === n[b];
                });
                if (C !== -1 && (we(v) && (v = C), !we(v))) {
                  var R;
                  g = Math.max(C, (R = g) !== null && R !== void 0 ? R : 0);
                }
              }), [v, g];
            }
            function aC(t, n, a, o) {
              return o ? t.slice(0, a + 1) : t[n % t.length];
            }
            function oC(t, n, a, o) {
              if (!o)
                return t;
              var u = rc(o, 2), h = u[0], v = u[1], g = De(t), b = a !== "area" && !we(g) && !Me(g);
              if (b) {
                var C = iC(t, n, o), R = rc(C, 2);
                h = R[0], v = R[1];
              } else
                h = h > 1 ? h - 1 : h, v = v < n.length - 1 ? v + 1 : v;
              return t.slice(h, v + 1);
            }
            function Uy(t, n) {
              return _l(t) && (we(n) || n === "line" || n === "scatter");
            }
            function sC(t, n, a) {
              return t[n].some(function(o) {
                var u = o.label;
                return u === a.name;
              });
            }
            function lC(t, n) {
              return t.treemap.some(function(a) {
                var o = a.label;
                return o === n.label;
              });
            }
            function uC(t, n) {
              return Ve(t.y, n);
            }
            function cC(t) {
              var n = ht(t), a = [];
              return n ? t.pie.forEach(function(o) {
                var u = o.data;
                u.forEach(function(h) {
                  Qe(h.visible) && !h.visible && a.push(h.name);
                });
              }) : Object.keys(t).forEach(function(o) {
                t[o].forEach(function(u) {
                  var h = u.name, v = u.visible;
                  Qe(v) && !v && a.push(h);
                });
              }), a;
            }
            var fC = {
              name: "seriesData",
              state: function(n) {
                var a = n.series, o = n.categories, u = n.options;
                return {
                  rawCategories: ec(a, o),
                  series: tc({}, a),
                  selectionRange: rC(a, u, o),
                  zoomRange: $y(a, u, o),
                  shiftRange: nC(a, u, o),
                  disabledSeries: cC(a)
                };
              },
              action: {
                setSeriesData: function(n) {
                  var a = n.state, o = n.initStoreState, u = wt(o.series), h = a.disabledSeries, v = a.theme, g = a.zoomRange, b = a.rawCategories, C = {}, R = 0;
                  Object.keys(u).forEach(function(I) {
                    var W, Z, ue, ke = v.series[I], Ee = ke.colors, Le = ke.iconTypes, je = u[I].map(function(mt) {
                      var Rt = !!mt.colorByCategories, Dt = Rt ? b.length : 1, Lt = Ee ? aC(Ee, R, Dt, Rt) : "";
                      return R += Dt, tc(tc({}, mt), {}, {
                        rawData: mt.data,
                        data: oC(mt.data, b, I, g),
                        color: Lt
                      });
                    });
                    I === "scatter" && (je = je.map(function(mt, Rt) {
                      return tc(tc({}, mt), {}, {
                        iconType: Le ? Le[Rt] : "circle"
                      });
                    }));
                    var Ke = je.length, ut = (W = (Z = je[0]) === null || Z === void 0 || (ue = Z.data) === null || ue === void 0 ? void 0 : ue.length) !== null && W !== void 0 ? W : 0, bt = je.filter(function(mt) {
                      var Rt = mt.name;
                      return !h.includes(Rt);
                    });
                    C[I] = {
                      seriesCount: Ke,
                      seriesGroupCount: ut,
                      data: bt,
                      colors: Ee
                    };
                  }), Pt(a.series, C);
                },
                disableSeries: function(n, a) {
                  var o = n.state;
                  o.disabledSeries.push(a), this.notify(o, "disabledSeries"), o.series.bullet && this.dispatch("removeCategoryByName", a);
                },
                enableSeries: function(n, a) {
                  var o = n.state, u = o.disabledSeries.findIndex(function(h) {
                    return h === a;
                  });
                  o.disabledSeries.splice(u, 1), this.notify(o, "disabledSeries"), o.series.bullet && (o.categories = o.series.bullet.data.map(function(h) {
                    var v = h.name;
                    return v;
                  }), this.notify(o, "axes"));
                },
                selection: function(n, a) {
                  var o = n.state, u = o.rawCategories;
                  o.selectionRange = a.map(function(h) {
                    return u.findIndex(function(v) {
                      return v === h;
                    });
                  }), this.notify(o, "selectionRange");
                },
                zoom: function(n, a) {
                  var o = n.state, u = o.rawCategories;
                  o.zoomRange = a.map(function(h) {
                    return u.findIndex(function(v) {
                      return v === h;
                    });
                  }), this.notify(o, "zoomRange");
                },
                resetZoom: function(n) {
                  var a = n.state, o = n.initStoreState, u = o.series, h = o.options, v = a.rawCategories;
                  a.zoomRange = $y(u, h, v), this.notify(a, "zoomRange");
                },
                addData: function(n, a) {
                  var o = n.state, u = n.initStoreState, h = a.data, v = a.category, g = a.chartType, b = u.series, C = Uy(o.series, g), R = u.categories;
                  if (R = b.heatmap ? R.x : R, v && Array.isArray(R)) {
                    var I = R.some(function(je) {
                      return je === v;
                    });
                    if (!I && (R.push(v), Array.isArray(o.shiftRange))) {
                      var W = rc(o.shiftRange, 2), Z = W[0], ue = W[1];
                      o.shiftRange = [Z + 1, ue + 1];
                    }
                  }
                  if (g)
                    b[g].forEach(function(je, Ke) {
                      je.data.push(h[Ke]);
                    });
                  else {
                    var ke = Object.keys(u.series), Ee = rc(ke, 1), Le = Ee[0];
                    b[Le].forEach(function(je, Ke) {
                      je.data.push(h[Ke]);
                    });
                  }
                  this.notify(o, "series"), this.notify(o, "rawCategories"), Array.isArray(o.zoomRange) && this.dispatch("resetZoom"), C && this.dispatch("initCategory");
                },
                addSeries: function(n, a) {
                  var o = n.state, u = n.initStoreState, h = a.data, v = a.chartType, g = a.category, b = u.series, C = u.categories, R = Uy(o.series, v), I = v || Object.keys(b)[0], W = sC(b, I, h);
                  W || (b[I].push(h), Array.isArray(C) && g && C.push(g)), this.dispatch("initThemeState"), this.dispatch("initLegendState"), this.notify(o, "series"), (R || I === "bullet") && this.dispatch("initCategory");
                },
                addHeatmapSeries: function(n, a) {
                  var o = n.state, u = n.initStoreState, h = a.data, v = a.category, g = u.series, b = u.categories, C = uC(b, v);
                  C || g.heatmap.push({
                    data: h,
                    yCategory: v
                  }), !C && v && (b.y.push(v), this.notify(o, "rawCategories")), this.notify(o, "series"), this.dispatch("initThemeState"), this.dispatch("initLegendState");
                },
                addTreemapSeries: function(n, a) {
                  var o = n.state, u = n.initStoreState, h = a.data, v = u.series, g = lC(v, h);
                  g || v.treemap.push(h), this.notify(o, "series"), this.notify(o, "treemapSeries"), this.dispatch("initThemeState"), this.dispatch("initLegendState");
                },
                setData: function(n, a) {
                  var o = n.state, u = n.initStoreState, h = a.series, v = a.categories;
                  u.series = h;
                  var g = ht(h);
                  g || (o.rawCategories = ec(h, v)), this.dispatch("initThemeState"), this.dispatch("initLegendState");
                },
                addOutlier: function(n, a) {
                  var o, u = n.state, h = n.initStoreState, v = a.seriesIndex, g = a.outliers, b = h.series, C = b.boxPlot[v];
                  if (!C)
                    throw new Error(ve.SERIES_INDEX_ERROR);
                  C.outliers = [].concat(Hy((o = C.outliers) !== null && o !== void 0 ? o : []), Hy(g)), this.notify(u, "series");
                }
              },
              observe: {
                updateSeriesData: function() {
                  this.dispatch("setSeriesData");
                }
              },
              computed: {
                isLineTypeSeriesZooming: function(n) {
                  var a = n.zoomRange, o = n.rawCategories;
                  return VO(o, a);
                },
                viewRange: function(n) {
                  var a = n.zoomRange, o = n.shiftRange;
                  return a || o;
                }
              }
            }, dC = fC;
            l(4870), l(3985), l(7890);
            function cv(t, n) {
              var a = n.color, o = n.points, u = n.lineWidth, h = n.fillColor, v = n.dashSegments, g = v === void 0 ? [] : v;
              o.length && (t.beginPath(), g && ta(t, g), o.forEach(function(b, C) {
                var R = b.x, I = b.y;
                if (C === 0) {
                  t.moveTo(R, I);
                  return;
                }
                t.lineTo(R, I);
              }), t.lineTo(o[0].x, o[0].y), h && Li(t, h), Ii(t, {
                lineWidth: u,
                strokeStyle: a
              }), t.closePath());
            }
            function Vy(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function Sf(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? Vy(Object(a), !0).forEach(function(o) {
                  hC(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : Vy(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function hC(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function pC(t, n) {
              var a = n.numberOfSides, o = n.size, u = n.x, h = n.y, v = n.borderColor, g = n.borderWidth, b = n.fillColor, C = o / 2, R = a % 2 ? Math.PI / 180 * (10 + (a - 3) / 2) * a : 0, I = 2 * Math.PI / a;
              t.beginPath();
              for (var W = 0; W <= a; W += 1) {
                var Z = W * I + R;
                t.lineTo(u + C * Math.cos(Z), h + C * Math.sin(Z));
              }
              t.strokeStyle = v, t.lineWidth = g, Li(t, b), t.stroke(), t.closePath();
            }
            function vC(t, n) {
              var a = n.x, o = n.y, u = n.borderColor, h = n.borderWidth, v = n.size, g = n.fillColor;
              t.lineWidth = h, t.strokeStyle = u, t.fillStyle = g, t.save(), t.beginPath(), t.translate(a, o), t.moveTo(0, -v);
              for (var b = 0; b < 5; b += 1)
                t.rotate(Math.PI / 5), t.lineTo(0, -v / 2), t.rotate(Math.PI / 5), t.lineTo(0, -v);
              t.fill(), t.stroke(), t.restore(), t.closePath();
            }
            function mC(t, n) {
              for (var a = n.x, o = n.y, u = n.borderColor, h = n.borderWidth, v = n.size, g = n.fillColor, b = v / 4, C = v / 2, R = [-C, -C, -b, -b, b, b, C, C, b, b, -b, -b], I = [], W = 0, Z = R.length; W < Z; W += 1) {
                var ue = 9;
                I.push(R[(ue + W) % Z]);
              }
              cv(t, {
                lineWidth: h,
                color: u,
                points: R.map(function(ke, Ee) {
                  return {
                    x: a + ke,
                    y: o + I[Ee]
                  };
                }),
                fillColor: g
              });
            }
            function gC(t) {
              switch (t) {
                case "triangle":
                  return 3;
                case "diamond":
                  return 4;
                case "pentagon":
                  return 5;
                case "hexagon":
                  return 6;
              }
            }
            function Gy(t, n) {
              var a = n.x, o = n.y, u = n.borderColor, h = n.borderWidth, v = n.fillColor, g = n.iconType, b = n.size, C = {
                x: a,
                y: o,
                fillColor: v,
                borderColor: u,
                borderWidth: h,
                size: b
              };
              switch (t.beginPath(), g) {
                case "rect":
                  hr(t, {
                    x: a - b / 2,
                    y: o - b / 2,
                    width: b,
                    height: b,
                    stroke: u,
                    lineWidth: h,
                    fill: v
                  });
                  break;
                case "triangle":
                case "pentagon":
                case "diamond":
                case "hexagon":
                  pC(t, Sf({
                    type: "regularPolygon",
                    numberOfSides: gC(g)
                  }, C));
                  break;
                case "star":
                  vC(t, Sf(Sf({
                    type: "star"
                  }, C), {}, {
                    size: b / 2
                  }));
                  break;
                case "cross":
                  mC(t, Sf({
                    type: "cross"
                  }, C));
                  break;
                default:
                  Rr(t, {
                    x: a,
                    y: o,
                    radius: b / 2,
                    style: [{
                      strokeStyle: u,
                      lineWidth: h
                    }],
                    color: v
                  });
              }
              t.stroke(), t.closePath();
            }
            var Zs = 40, $i = 5, Ui = 12, Nl = 12, yC = 1.5, nc = 0.3, fv = 10, bC = 2, Bl = 6;
            function wf(t) {
              return t + Br.Y;
            }
            function SC(t, n, a, o) {
              var u = [2, 2, 6, 6, 10, 10], h = [8, 0, 0, 8, 8, 0];
              u.forEach(function(v, g) {
                g !== 5 && Wr(t, {
                  x: n + v,
                  y: a + h[g],
                  x2: n + u[g + 1],
                  y2: a + h[g + 1],
                  lineWidth: 2,
                  strokeStyle: o
                });
              });
            }
            function wC(t, n, a, o) {
              var u = "#555555", h = o ? u : cr(u, nc);
              Wr(t, {
                x: n + 2,
                y: a + 5,
                x2: n + 5,
                y2: a + 8,
                strokeStyle: h,
                lineWidth: 2
              }), Wr(t, {
                x: n + 5,
                y: a + 9,
                x2: n + 10,
                y2: a + 3,
                strokeStyle: h,
                lineWidth: 2
              });
            }
            function xC(t, n, a, o) {
              var u = o.active, h = o.checked, v = u ? "#bbb" : cr("#bbbbbb", nc);
              cn(t, {
                x: n,
                y: a,
                width: Ui,
                height: Ui,
                color: "#fff",
                borderColor: v,
                thickness: 1
              }), h && wC(t, n, a, u);
            }
            function kC(t, n, a, o) {
              var u = o.iconType, h = o.active, v = o.color, g = o.showCheckbox, b = n + (g ? Ui + $i : 0), C = h ? v : cr(v, nc);
              u === "rect" ? cn(t, {
                x: b,
                y: a + (Ui - fv) / 2,
                width: fv,
                height: fv,
                color: C
              }) : u === "line" ? SC(t, b, a + bC, C) : u === "circle" && Rr(t, {
                x: b + Bl,
                y: a + Bl,
                radius: Bl,
                color: C,
                style: ["default"]
              });
            }
            function OC(t, n, a, o) {
              var u = o.iconType, h = o.active, v = o.color, g = o.showCheckbox, b = n + (g ? Ui + $i : 0), C = h ? v : cr(v, nc);
              Gy(t, {
                iconType: u,
                x: b + Bl,
                y: a + Bl,
                borderColor: C,
                size: Bl * 2,
                fillColor: "rgba(255, 255, 255, 0)",
                borderWidth: yC
              });
            }
            function CC(t, n, a, o, u) {
              var h = u.active, v = u.showCheckbox, g = u.font, b = u.fontColor, C = h ? b : cr(b, nc);
              Ni(t, {
                x: n + Nl + $i + (v ? Ui + $i : 0),
                y: a,
                text: o,
                style: ["default", {
                  font: g,
                  textBaseline: "top",
                  fillStyle: C
                }]
              });
            }
            function TC(t, n) {
              var a = n.data, o = n.showCheckbox;
              n.align;
              var u = n.fontSize, h = n.fontFamily, v = n.fontWeight, g = an({
                fontSize: u,
                fontFamily: h,
                fontWeight: v
              }), b = n.color;
              a.forEach(function(C) {
                var R = C.x, I = C.y, W = C.checked, Z = C.active, ue = C.color, ke = C.iconType, Ee = C.useScatterChartIcon, Le = C.viewLabel, je = I - 1 + (Vs(Le, g) - 11) / 4, Ke = {
                  iconType: ke,
                  checked: W,
                  active: Z,
                  color: ue,
                  showCheckbox: o,
                  font: g,
                  fontColor: b
                };
                o && xC(t, R, je, Ke), Ee && ke !== "line" ? OC(t, R, je, Ke) : kC(t, R, je, Ke), CC(t, R, I, Le, Ke);
              });
            }
            function Yy(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function ir(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? Yy(Object(a), !0).forEach(function(o) {
                  dv(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : Yy(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function dv(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var AC = 2, ic = 3, qy = 0.3, EC = qy, MC = 0.06, Xo = {
              LINE_WIDTH: 2,
              DOT_RADIUS: 3,
              HOVER_DOT_RADIUS: 4,
              SELECTED_SERIES_OPACITY: 0.3,
              UNSELECTED_SERIES_OPACITY: 0.05
            }, hi = {
              HOVER_THICKNESS: 4,
              BOX_HOVER: {
                shadowColor: "rgba(0, 0, 0, 0.3)",
                shadowOffsetX: 2,
                shadowOffsetY: 2,
                shadowBlur: 6
              }
            }, Qs = {
              OUTLIER_RADIUS: 4,
              OUTLIER_BORDER_WIDTH: 2,
              LINE_TYPE: {
                whisker: {
                  lineWidth: 1
                },
                maximum: {
                  lineWidth: 1
                },
                minimum: {
                  lineWidth: 1
                },
                median: {
                  lineWidth: 1,
                  color: "#ffffff"
                }
              }
            }, RC = [0.5, 0.3, 0.1], Fl = 3;
            function ac() {
              var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "Arial";
              return {
                fontFamily: t,
                fontSize: 11,
                fontWeight: 400,
                color: "#333333",
                useSeriesColor: !1
              };
            }
            var oc = {
              width: 8,
              height: 6
            }, Jo = {
              colors: ["#00a9ff", "#ffb840", "#ff5a46", "#00bd9f", "#785fff", "#f28b8c", "#989486", "#516f7d", "#28e6eb", "#28695f", "#96c85a", "#45ba3f", "#295ba0", "#2a4175", "#289399", "#66c8d3", "#617178", "#8a9a9a", "#bebebe", "#374b5a", "#64eba0", "#ffe155", "#ff9141", "#af4beb", "#ff73fa", "#ff55b2", "#2869f5", "#3296ff", "#8cc3ff", "#2828b9", "#fa8787", "#e13782", "#7d5aaa", "#643c91", "#d25f5f", "#fabe6e", "#c3a9eb", "#b9c8f5", "#73a0cd", "#0f5a8c"],
              startColor: "#ffe98a",
              endColor: "#d74177",
              lineWidth: AC,
              dashSegments: [],
              select: {
                dot: {
                  radius: ic,
                  borderWidth: ic + 2
                },
                restSeries: {
                  areaOpacity: MC
                }
              },
              hover: {
                dot: {
                  radius: ic,
                  borderWidth: ic + 2
                }
              },
              dot: {
                radius: ic
              }
            };
            function Ky() {
              var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "Arial";
              return {
                fontSize: 11,
                fontFamily: t,
                fontWeight: 700,
                color: "#bbbbbb"
              };
            }
            function DC() {
              var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "Arial";
              return {
                fontSize: 11,
                fontFamily: t,
                fontWeight: "normal",
                color: "#333333"
              };
            }
            function Xy(t) {
              var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "Arial", a = Ky(n), o = DC(n), u = !!(t != null && t.radar), h = !!(t != null && t.gauge);
              return {
                chart: {
                  fontFamily: n,
                  backgroundColor: "#ffffff"
                },
                noData: {
                  fontSize: 18,
                  fontFamily: n,
                  fontWeight: "normal",
                  color: "#333333"
                },
                title: {
                  fontSize: 18,
                  fontFamily: n,
                  fontWeight: 100,
                  color: "#333333"
                },
                yAxis: {
                  title: ir({}, a),
                  label: ir({}, o),
                  width: 1,
                  color: "#333333"
                },
                xAxis: {
                  title: ir({}, a),
                  label: ir({}, o),
                  width: 1,
                  color: "#333333"
                },
                verticalAxis: {
                  label: ir(ir({}, o), {}, {
                    textBubble: {
                      visible: u,
                      backgroundColor: u ? "#f3f3f3" : "rgba(0, 0, 0, 0)",
                      borderRadius: 7,
                      paddingX: 7,
                      paddingY: 2,
                      borderColor: "rgba(0, 0, 0, 0)",
                      borderWidth: 1
                    }
                  })
                },
                circularAxis: {
                  title: ir({}, a),
                  label: ir({}, o),
                  lineWidth: 1,
                  strokeStyle: h ? "rgba(0, 0, 0, 0.5)" : "rgba(0, 0, 0, 0.05)",
                  dotColor: "rgba(0, 0, 0, 0.5)",
                  tick: {
                    lineWidth: 1,
                    strokeStyle: "rgba(0, 0, 0, 0.5)"
                  }
                },
                legend: {
                  label: {
                    color: "#333333",
                    fontSize: 11,
                    fontWeight: "normal",
                    fontFamily: n
                  }
                },
                tooltip: {
                  background: "rgba(85, 85, 85, 0.95)",
                  borderColor: "rgba(255, 255, 255, 0)",
                  borderWidth: 0,
                  borderRadius: 3,
                  borderStyle: "solid",
                  body: {
                    fontSize: 12,
                    fontFamily: "".concat(n, ", sans-serif"),
                    fontWeight: "normal",
                    color: "#ffffff"
                  },
                  header: {
                    fontSize: 13,
                    fontFamily: "".concat(n, ", sans-serif"),
                    fontWeight: "bold",
                    color: "#ffffff"
                  }
                },
                plot: {
                  lineColor: "rgba(0, 0, 0, 0.05)",
                  backgroundColor: "rgba(255, 255, 255, 0)"
                },
                exportMenu: {
                  button: ir(ir({}, Jy(5, "#f4f4f4")), {}, {
                    backgroundColor: "#f4f4f4",
                    xIcon: {
                      color: "#555555",
                      lineWidth: 2
                    },
                    dotIcon: {
                      color: "#555555",
                      width: 2,
                      height: 2,
                      gap: 2
                    }
                  }),
                  panel: ir(ir({}, Jy(0, "#bab9ba")), {}, {
                    header: ir(ir({}, o), {}, {
                      backgroundColor: "#f4f4f4"
                    }),
                    body: ir(ir({}, o), {}, {
                      backgroundColor: "#ffffff"
                    })
                  })
                }
              };
            }
            function Jy(t, n) {
              var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
              return {
                borderWidth: a,
                borderRadius: t,
                borderColor: n
              };
            }
            function Oo() {
              var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 7, a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 5, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1, u = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "#ffffff";
              return {
                visible: t,
                paddingX: a,
                paddingY: o,
                borderRadius: n,
                backgroundColor: u,
                shadowColor: "rgba(0, 0, 0, 0.3)",
                shadowOffsetY: 2,
                shadowBlur: 4
              };
            }
            function Zy(t) {
              var n = ac(t);
              return {
                lineWidth: Jo.lineWidth,
                dashSegments: Jo.dashSegments,
                select: {
                  dot: Jo.select.dot
                },
                hover: {
                  dot: Jo.hover.dot
                },
                dot: Jo.dot,
                dataLabels: ir(ir({}, n), {}, {
                  textBubble: ir(ir({}, Oo()), {}, {
                    arrow: ir({
                      visible: !1,
                      direction: "bottom"
                    }, oc)
                  })
                })
              };
            }
            function Qy(t) {
              var n = ac(t);
              return {
                startColor: Jo.startColor,
                endColor: Jo.endColor,
                borderWidth: 0,
                borderColor: "#ffffff",
                hover: {
                  borderWidth: hi.HOVER_THICKNESS,
                  borderColor: "#ffffff"
                },
                select: {
                  borderWidth: hi.HOVER_THICKNESS,
                  borderColor: "#ffffff"
                },
                dataLabels: ir(ir({}, n), {}, {
                  color: "#ffffff",
                  textBubble: ir({}, Oo(!1, 1, 5, 1, "rgba(255, 255, 255, 0.5)"))
                })
              };
            }
            function eb(t) {
              var n = ac(t);
              return {
                areaOpacity: 1,
                hover: ir(ir({}, hi.BOX_HOVER), {}, {
                  borderWidth: hi.HOVER_THICKNESS,
                  borderColor: "#ffffff",
                  groupedRect: {
                    color: "#000000",
                    opacity: 0.05
                  }
                }),
                select: ir(ir({}, hi.BOX_HOVER), {}, {
                  borderWidth: hi.HOVER_THICKNESS,
                  borderColor: "#ffffff",
                  groupedRect: {
                    color: "#000000",
                    opacity: 0.2
                  },
                  restSeries: {
                    areaOpacity: 0.2
                  },
                  areaOpacity: 1
                }),
                connector: {
                  color: "rgba(51, 85, 139, 0.3)",
                  lineWidth: 1,
                  dashSegments: []
                },
                dataLabels: ir(ir({}, n), {}, {
                  textBubble: ir(ir({}, Oo(!1, 1, 4, 3)), {}, {
                    arrow: ir({
                      visible: !1
                    }, oc)
                  }),
                  stackTotal: ir(ir({}, n), {}, {
                    textBubble: ir(ir({}, Oo(!0, 1, 4, 3)), {}, {
                      arrow: ir({
                        visible: !0
                      }, oc)
                    })
                  })
                })
              };
            }
            var tb = "rgba(255, 255, 255, 0)", hv = {
              line: function(n) {
                return ir({}, Zy(n));
              },
              area: function(n) {
                var a = Zy(n);
                return ir(ir({}, a), {}, {
                  select: ir(ir({}, a.select), {}, {
                    areaOpacity: EC,
                    restSeries: Jo.select.restSeries
                  }),
                  areaOpacity: qy
                });
              },
              treemap: function(n) {
                return Qy(n);
              },
              heatmap: function(n) {
                return Qy(n);
              },
              scatter: function() {
                return {
                  size: 12,
                  borderWidth: 1.5,
                  fillColor: tb,
                  select: {
                    fillColor: "rgba(255, 255, 255, 1)",
                    borderWidth: 2.5,
                    size: 12
                  },
                  hover: {
                    fillColor: "rgba(255, 255, 255, 1)",
                    borderWidth: 2.5,
                    size: 12
                  }
                };
              },
              bubble: function() {
                return {
                  borderWidth: 0,
                  borderColor: tb,
                  select: {},
                  hover: {
                    shadowColor: "rgba(0, 0, 0, 0.3)",
                    shadowBlur: 2,
                    shadowOffsetY: 2,
                    lineWidth: 2
                  }
                };
              },
              radar: function() {
                return {
                  areaOpacity: Xo.SELECTED_SERIES_OPACITY,
                  hover: {
                    dot: {
                      radius: Xo.HOVER_DOT_RADIUS,
                      borderWidth: Xo.HOVER_DOT_RADIUS + 1
                    }
                  },
                  select: {
                    dot: {
                      radius: Xo.HOVER_DOT_RADIUS,
                      borderWidth: Xo.HOVER_DOT_RADIUS + 1
                    },
                    restSeries: {
                      areaOpacity: Xo.UNSELECTED_SERIES_OPACITY
                    },
                    areaOpacity: Xo.SELECTED_SERIES_OPACITY
                  },
                  dot: {
                    radius: Xo.DOT_RADIUS
                  }
                };
              },
              bar: function(n) {
                return ir({}, eb(n));
              },
              column: function(n) {
                return ir({}, eb(n));
              },
              bullet: function(n) {
                var a = ac(n);
                return {
                  areaOpacity: 1,
                  barWidthRatios: {
                    rangeRatio: 1,
                    bulletRatio: 0.5,
                    markerRatio: 0.8
                  },
                  markerLineWidth: 1,
                  borderWidth: 0,
                  borderColor: "rgba(255, 255, 255, 0)",
                  hover: ir(ir({}, hi.BOX_HOVER), {}, {
                    borderWidth: hi.HOVER_THICKNESS,
                    borderColor: "#ffffff",
                    groupedRect: {
                      color: "#000000",
                      opacity: 0.05
                    }
                  }),
                  select: ir(ir({}, hi.BOX_HOVER), {}, {
                    borderWidth: hi.HOVER_THICKNESS,
                    borderColor: "#ffffff",
                    groupedRect: {
                      color: "#000000",
                      opacity: 0.2
                    },
                    restSeries: {
                      areaOpacity: 0.2
                    },
                    areaOpacity: 1
                  }),
                  dataLabels: ir(ir({}, a), {}, {
                    textBubble: ir(ir({}, Oo()), {}, {
                      arrow: ir({
                        visible: !1
                      }, oc)
                    }),
                    marker: ir(ir({}, a), {}, {
                      fontSize: 9,
                      useSeriesColor: !0,
                      textBubble: ir(ir({}, Oo(!0)), {}, {
                        backgroundColor: "rgba(255, 255, 255, 0.8)",
                        shadowColor: "rgba(0, 0, 0, 0.0)",
                        shadowOffsetX: 0,
                        shadowOffsetY: 0,
                        shadowBlur: 0,
                        arrow: ir({
                          visible: !1
                        }, oc)
                      })
                    })
                  })
                };
              },
              boxPlot: function() {
                return {
                  areaOpacity: 1,
                  barWidthRatios: {
                    barRatio: 1,
                    minMaxBarRatio: 0.5
                  },
                  markerLineWidth: 1,
                  dot: {
                    color: "#ffffff",
                    radius: Qs.OUTLIER_RADIUS,
                    borderWidth: Qs.OUTLIER_BORDER_WIDTH,
                    useSeriesColor: !1
                  },
                  rect: {
                    borderWidth: 0
                  },
                  line: ir({}, Qs.LINE_TYPE),
                  hover: ir(ir({}, hi.BOX_HOVER), {}, {
                    rect: {
                      borderWidth: hi.HOVER_THICKNESS,
                      borderColor: "#ffffff"
                    },
                    dot: {
                      radius: Qs.OUTLIER_RADIUS,
                      borderWidth: 0,
                      useSeriesColor: !0
                    },
                    line: ir({}, Qs.LINE_TYPE)
                  }),
                  select: ir(ir({}, hi.BOX_HOVER), {}, {
                    rect: {
                      borderWidth: hi.HOVER_THICKNESS,
                      borderColor: "#ffffff"
                    },
                    dot: {
                      radius: Qs.OUTLIER_RADIUS,
                      borderWidth: 0,
                      useSeriesColor: !0
                    },
                    line: ir({}, Qs.LINE_TYPE),
                    restSeries: {
                      areaOpacity: 0.2
                    },
                    areaOpacity: 1
                  })
                };
              },
              pie: function(n, a) {
                var o = a.hasOuterAnchor, u = o === void 0 ? !1 : o, h = a.hasOuterAnchorPieSeriesName, v = h === void 0 ? !1 : h, g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, b = ac(n);
                return {
                  areaOpacity: 1,
                  strokeStyle: g ? "#ffffff" : "rgba(255, 255, 255, 0)",
                  lineWidth: g ? 1 : 0,
                  hover: {
                    lineWidth: Fl,
                    strokeStyle: "#ffffff",
                    shadowColor: "#cccccc",
                    shadowBlur: 5,
                    shadowOffsetX: 0,
                    shadowOffsetY: 0
                  },
                  select: {
                    lineWidth: Fl,
                    strokeStyle: "#ffffff",
                    shadowColor: "#cccccc",
                    shadowBlur: 5,
                    shadowOffsetX: 0,
                    shadowOffsetY: 0,
                    restSeries: {
                      areaOpacity: 0.3
                    },
                    areaOpacity: 1
                  },
                  dataLabels: {
                    fontFamily: n,
                    fontSize: 16,
                    fontWeight: 600,
                    color: u ? "#333333" : "#ffffff",
                    useSeriesColor: u,
                    textBubble: ir({}, Oo(!1, 0)),
                    callout: {
                      lineWidth: 1,
                      useSeriesColor: !0,
                      lineColor: "#e9e9e9"
                    },
                    pieSeriesName: ir(ir({}, b), {}, {
                      useSeriesColor: v,
                      color: v ? "#333333" : "#ffffff",
                      textBubble: ir({}, Oo(!1, 0))
                    })
                  }
                };
              },
              radialBar: function(n) {
                return {
                  areaOpacity: 1,
                  strokeStyle: "rgba(255, 255, 255, 0)",
                  lineWidth: 0,
                  hover: {
                    lineWidth: Fl,
                    strokeStyle: "#fff",
                    shadowColor: "#cccccc",
                    shadowBlur: 5,
                    shadowOffsetX: 0,
                    shadowOffsetY: 0,
                    groupedSector: {
                      color: "#000000",
                      opacity: 0.05
                    }
                  },
                  select: {
                    lineWidth: Fl,
                    strokeStyle: "#fff",
                    shadowColor: "#cccccc",
                    shadowBlur: 5,
                    shadowOffsetX: 0,
                    shadowOffsetY: 0,
                    restSeries: {
                      areaOpacity: 0.3
                    },
                    areaOpacity: 1,
                    groupedSector: {
                      color: "#000000",
                      opacity: 0.2
                    }
                  },
                  dataLabels: {
                    fontFamily: n,
                    fontSize: 11,
                    fontWeight: 400,
                    color: "#333333",
                    useSeriesColor: !1,
                    textBubble: ir({}, Oo(!1, 0))
                  }
                };
              },
              gauge: function(n) {
                return {
                  areaOpacity: 1,
                  hover: {
                    clockHand: {
                      baseLine: 5
                    },
                    pin: {
                      radius: 5,
                      borderWidth: 5
                    },
                    solid: {
                      lineWidth: Fl,
                      strokeStyle: "#ffffff",
                      shadowColor: "#cccccc",
                      shadowBlur: 5,
                      shadowOffsetX: 0,
                      shadowOffsetY: 0
                    }
                  },
                  select: {
                    clockHand: {
                      baseLine: 5
                    },
                    pin: {
                      radius: 6,
                      borderWidth: 4
                    },
                    solid: {
                      lineWidth: Fl,
                      strokeStyle: "#ffffff",
                      shadowColor: "#cccccc",
                      shadowBlur: 5,
                      shadowOffsetX: 0,
                      shadowOffsetY: 0,
                      restSeries: {
                        areaOpacity: 0.3
                      },
                      areaOpacity: 1
                    },
                    areaOpacity: 1,
                    restSeries: {
                      areaOpacity: 0.3
                    }
                  },
                  clockHand: {
                    baseLine: 4
                  },
                  pin: {
                    radius: 5,
                    borderWidth: 5
                  },
                  solid: {
                    lineWidth: 0,
                    backgroundSolid: {
                      color: "rgba(0, 0, 0, 0.1)"
                    }
                  },
                  dataLabels: {
                    fontFamily: n,
                    fontSize: 11,
                    fontWeight: 400,
                    color: "#333333",
                    useSeriesColor: !1,
                    textBubble: ir(ir({}, Oo(!0, 4, 4, 3)), {}, {
                      shadowColor: "rgba(0, 0, 0, 0)",
                      shadowOffsetY: 0,
                      shadowBlur: 0,
                      borderColor: "#ccc",
                      borderWidth: 1
                    })
                  }
                };
              }
            };
            function rb(t, n, a) {
              var o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
              return n === "pie" ? hv[n](t, a, o) : Ve(["bubble", "radar", "boxPlot"], n) ? hv[n]() : hv[n](t);
            }
            function PC(t, n) {
              var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "Arial", o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, u = Object.keys(t).reduce(function(v, g) {
                return ir(ir({}, v), {}, {
                  series: ir(ir({}, v.series), {}, dv({}, g, rb(a, g, n)))
                });
              }, Xy(t, a));
              if (o) {
                var h = _t(t);
                u.series.pie = h.reduce(function(v, g) {
                  return ir(ir({}, v), {}, dv({}, g, rb(a, "pie", n[g], o)));
                }, {});
              }
              return u;
            }
            function xf(t, n, a) {
              var o = t.index, u = t.seriesIndex, h = t.chartType;
              return Me(o) && (n === "grouped" || Me(u)) && (we(h) || h === a);
            }
            function kf(t, n) {
              var a = t.index, o = t.seriesIndex, u = t.chartType;
              return Me(a) && Me(o) && (we(u) || u === n);
            }
            function pv(t) {
              return Object.keys(t).reduce(function(n, a) {
                return !t[a].data.length && n;
              }, !0);
            }
            function nb(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function ib(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? nb(Object(a), !0).forEach(function(o) {
                  ab(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : nb(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function ab(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function Ea(t) {
              return t.data.reduce(function(n, a) {
                var o = a.active, u = a.label;
                return ib(ib({}, n), {}, ab({}, u, o));
              }, {});
            }
            function LC(t) {
              var n, a;
              return (n = t == null || (a = t.circleLegend) === null || a === void 0 ? void 0 : a.visible) !== null && n !== void 0 ? n : !0;
            }
            function ob(t, n) {
              var a, o, u;
              return n.gauge || n.treemap && !((a = t.series) !== null && a !== void 0 && a.useColorValue) ? !1 : we((o = t.legend) === null || o === void 0 ? void 0 : o.visible) ? !0 : !!((u = t.legend) !== null && u !== void 0 && u.visible);
            }
            function sb(t) {
              var n, a;
              return we((n = t.legend) === null || n === void 0 ? void 0 : n.showCheckbox) ? !0 : !!((a = t.legend) !== null && a !== void 0 && a.showCheckbox);
            }
            function IC(t) {
              return Ve(["bar", "column", "area", "pie", "boxPlot", "bullet", "radialBar"], t);
            }
            function _C(t) {
              return Ve(["bubble", "scatter"], t);
            }
            function NC(t) {
              return Ve(["line", "radar"], t);
            }
            function BC(t) {
              var n = "spectrum";
              return _C(t) ? n = "circle" : IC(t) ? n = "rect" : NC(t) && (n = "line"), n;
            }
            function lb(t) {
              var n, a;
              return (n = (a = t.legend) === null || a === void 0 ? void 0 : a.align) !== null && n !== void 0 ? n : "right";
            }
            function FC(t, n) {
              return jC(t) || HC(t, n) || cb(t, n) || zC();
            }
            function zC() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function HC(t, n) {
              var a = t && (typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]);
              if (a != null) {
                var o = [], u = !0, h = !1, v, g;
                try {
                  for (a = a.call(t); !(u = (v = a.next()).done) && (o.push(v.value), !(n && o.length === n)); u = !0)
                    ;
                } catch (b) {
                  h = !0, g = b;
                } finally {
                  try {
                    !u && a.return != null && a.return();
                  } finally {
                    if (h) throw g;
                  }
                }
                return o;
              }
            }
            function jC(t) {
              if (Array.isArray(t)) return t;
            }
            function ub(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function sc(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? ub(Object(a), !0).forEach(function(o) {
                  WC(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : ub(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function WC(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function el(t) {
              return VC(t) || UC(t) || cb(t) || $C();
            }
            function $C() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function cb(t, n) {
              if (t) {
                if (typeof t == "string") return vv(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return vv(t, n);
              }
            }
            function UC(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function VC(t) {
              if (Array.isArray(t)) return vv(t);
            }
            function vv(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            var GC = 100, mv = 150, YC = 100, fb = "...", qC = "W", gv = 2;
            function KC(t, n) {
              var a = t.legendWidths, o = t.itemHeight, u = a.length * o, h = Math.ceil(u / n), v = a.length / h, g = 0;
              return Mt(0, h).forEach(function(b) {
                g += Math.max.apply(Math, el(a.slice(b * v, (b + 1) * v)));
              }), g += Zs * (h - 1), {
                legendWidth: g,
                legendHeight: v * o + Br.Y,
                columnCount: h,
                rowCount: v
              };
            }
            function XC(t, n) {
              var a = t.legendWidths, o = t.itemHeight, u = 0, h = 0, v = a.reduce(function(b, C) {
                var R = Zs + C;
                return b.totalWidth + C > n ? (b.totalWidth = R, b.rowCount += 1, b.columnCount = 1, u = Math.max(u, b.columnCount)) : (b.totalWidth += R, b.columnCount += 1), h = Math.max(h, b.totalWidth), b;
              }, {
                totalWidth: 0,
                rowCount: 1,
                columnCount: 0
              }), g = v.rowCount;
              return {
                legendHeight: o * g,
                rowCount: g,
                columnCount: u,
                legendWidth: h
              };
            }
            function JC(t) {
              if (!t.visible)
                return {
                  legendWidth: 0,
                  legendHeight: 0,
                  rowCount: 0,
                  columnCount: 0
                };
              var n = t.chart, a = t.verticalAlign, o = t.legendWidths, u = r1(t), h = u.legendWidth, v = u.isOverflow, g = ZC(t), b = g.legendHeight, C = g.isOverflow, R = a ? o.length : 1, I = a ? Math.ceil(h / n.width) : o.length;
              return v ? XC(t, h / I) : C ? KC(t, b) : {
                legendWidth: h,
                legendHeight: b,
                columnCount: R,
                rowCount: I
              };
            }
            function ZC(t) {
              var n = t.verticalAlign, a = t.itemHeight, o = t.legendWidths, u = db(t), h = u.height, v, g = !1;
              if (n)
                v = h;
              else {
                var b = o.length * a;
                g = h < b, v = g ? h : b;
              }
              return {
                legendHeight: v,
                isOverflow: g
              };
            }
            function QC(t, n, a) {
              if (a) {
                var o = lt(t);
                return Math.max(n / 4, o);
              }
              var u = (Aa.PADDING + Ta.PADDING + Br.X) * gv + Aa.POINT_HEIGHT + Ta.HEIGHT;
              return Math.max.apply(Math, el(t)) + u;
            }
            function e1(t, n, a) {
              return a ? wo + Ta.PADDING * gv + Aa.POINT_HEIGHT + Aa.HEIGHT + Br.Y : n * 3 / 4;
            }
            function t1(t) {
              var n = t.initialWidth, a = t.legendWidths, o = t.checkbox, u = t.verticalAlign, h = !1, v;
              if (u) {
                var g = db(t), b = g.width, C = lt(a) + Zs * (a.length - 1);
                h = C > b, v = C;
              } else {
                var R = Math.max.apply(Math, el(a));
                v = (o ? Ui + $i : 0) + Nl + $i + Math.max(R, n);
              }
              return {
                legendWidth: v,
                isOverflow: h
              };
            }
            function r1(t) {
              var n = t.options, a = t.visible, o = n == null ? void 0 : n.legend;
              return a ? o != null && o.width ? {
                legendWidth: o.width,
                isOverflow: !1
              } : t1(t) : {
                legendWidth: 0,
                isOverflow: !1
              };
            }
            function db(t) {
              var n = t.verticalAlign, a = t.chart, o = t.itemHeight, u = t.initialWidth, h = t.circleLegendVisible, v = YC + (h ? mv : 0);
              return n ? {
                width: a.width - Br.X * gv,
                height: o
              } : {
                width: u,
                height: a.height - v
              };
            }
            function n1(t, n) {
              var a = [], o = hb(n);
              return t.pie.forEach(function(u) {
                var h = u.data;
                h.forEach(function(v) {
                  var g = v.name, b = v.parentName, C = v.visible;
                  if (!b) {
                    var R = pb(n, g, o), I = R.width, W = R.viewLabel;
                    a.push({
                      label: g,
                      type: "pie",
                      checked: C ?? !0,
                      viewLabel: W,
                      width: I
                    });
                  }
                });
              }), a;
            }
            function hb(t) {
              var n, a = t.legendOptions, o = t.font, u = t.checkboxVisible, h = a == null || (n = a.item) === null || n === void 0 ? void 0 : n.width;
              if (!we(h)) {
                var v = u ? Ui + $i : 0, g = Nl + $i, b = ni(fb, o), C = ni(qC, o), R = Math.floor((h - b - v - g) / C);
                return R > 0 ? R : 0;
              }
            }
            function pb(t, n, a) {
              var o, u = t.checkboxVisible, h = t.useSpectrumLegend, v = t.font, g = t.legendOptions, b = n, C = g == null || (o = g.item) === null || o === void 0 ? void 0 : o.width, R = a1(b, u, h, v);
              return Me(C) && Me(a) && C < R && (b = "".concat(n.slice(0, a)).concat(fb)), {
                viewLabel: b,
                width: C ?? R
              };
            }
            function i1(t, n, a) {
              var o = hb(n), u = 0;
              return Object.keys(t).flatMap(function(h) {
                var v = t[h].map(function(g) {
                  var b = g.name, C = g.colorValue, R = g.visible, I = g.colorByCategories, W = C || b, Z = u, ue = pb(n, W, o), ke = ue.width, Ee = ue.viewLabel;
                  return u += I ? a.length : 1, {
                    label: W,
                    type: h,
                    colorByCategories: !!I,
                    colorIndex: Z,
                    checked: R ?? !0,
                    viewLabel: Ee,
                    width: ke
                  };
                });
                return u += t[h].length - 1, v;
              });
            }
            function a1(t, n, a, o) {
              return (a ? 0 : (n ? Ui + $i : 0) + Nl + $i) + ni(t, o);
            }
            function vb(t, n) {
              var a = Object.values(n).reduce(function(u, h) {
                return h && h.colors ? [].concat(el(u), el(h.colors)) : u;
              }, []), o = t.some(function(u) {
                return u.colorByCategories;
              });
              return t.map(function(u, h) {
                var v = u.colorByCategories, g = u.colorIndex, b = o && g || h;
                return sc(sc({}, u), {}, {
                  color: v ? "#aaa" : a[b % a.length]
                });
              });
            }
            function mb(t, n, a) {
              var o, u, h, v, g, b, C = (o = t == null || (u = t.series) === null || u === void 0 ? void 0 : u.useColorValue) !== null && o !== void 0 ? o : !!n.heatmap, R = !!(n != null && n.scatter), I = C ? !1 : sb(t), W = Xy(n, t == null || (h = t.theme) === null || h === void 0 || (v = h.chart) === null || v === void 0 ? void 0 : v.fontFamily), Z = an(Ye(W.legend.label, sc({}, (g = t.theme) === null || g === void 0 || (b = g.legend) === null || b === void 0 ? void 0 : b.label))), ue = {
                checkboxVisible: I,
                font: Z,
                useSpectrumLegend: C,
                legendOptions: t.legend
              }, ke = ht(n) ? n1(n, ue) : i1(n, ue, a), Ee = ke.map(function(Le) {
                var je = Le.label, Ke = Le.type, ut = Le.checked, bt = Le.width, mt = Le.viewLabel, Rt = Le.colorByCategories, Dt = Le.colorIndex;
                return {
                  label: je,
                  active: !0,
                  checked: ut,
                  width: bt,
                  iconType: BC(Ke),
                  chartType: Ke,
                  rowIndex: 0,
                  columnIndex: 0,
                  viewLabel: mt,
                  colorByCategories: Rt,
                  colorIndex: Dt
                };
              });
              return {
                useSpectrumLegend: C,
                useScatterChartIcon: R,
                data: Ee
              };
            }
            function o1(t) {
              var n = t.verticalAlign, a = t.columnCount, o = t.rowCount, u = t.legendCount, h = t.rowIndex, v = t.columnIndex;
              if (n) {
                var g = u / o;
                g - 1 > v ? v += 1 : (h += 1, v = 0);
              } else {
                var b = u / a;
                b - 1 > h ? h += 1 : (v += 1, h = 0);
              }
              return [h, v];
            }
            function s1(t, n, a, o, u) {
              var h = 0, v = 0;
              t.forEach(function(g) {
                g.rowIndex = v, g.columnIndex = h;
                var b = o1({
                  rowCount: n,
                  columnCount: a,
                  verticalAlign: u,
                  legendCount: o,
                  rowIndex: v,
                  columnIndex: h
                }), C = FC(b, 2);
                v = C[0], h = C[1];
              });
            }
            var l1 = {
              name: "legend",
              state: function(n) {
                var a = n.options, o = n.series, u = n.categories;
                return {
                  legend: mb(a, o, u),
                  circleLegend: {}
                };
              },
              action: {
                initLegendState: function(n) {
                  var a = n.state, o = n.initStoreState;
                  Pt(a.legend, mb(o.options, o.series, o.categories));
                },
                setLegendLayout: function(n) {
                  var a = n.state;
                  a.legend.useSpectrumLegend ? this.dispatch("setSpectrumLegendLayout") : this.dispatch("setNormalLegendLayout");
                },
                setSpectrumLegendLayout: function(n) {
                  var a = n.state, o = a.legend.data, u = a.series, h = a.options, v = a.chart, g = a.theme, b = lb(h), C = ob(h, u), R = xo(b), I = o.map(function(ke) {
                    var Ee = ke.width;
                    return Ee;
                  }), W = wf(g.legend.label.fontSize), Z = QC(I, v.width, R), ue = e1(W, v.height, R);
                  Pt(a.legend, {
                    visible: C,
                    align: b,
                    width: Z,
                    height: ue
                  });
                },
                setNormalLegendLayout: function(n) {
                  var a = n.state, o = n.initStoreState, u = a.legend.data, h = a.series, v = a.options, g = a.chart, b = a.theme, C = lb(v), R = ob(v, h), I = sb(v), W = Math.min(g.width / 5, GC), Z = xo(C), ue = ht(o.series), ke = !!h.scatter, Ee = !!h.bubble, Le = Ee ? LC(v) : !1, je = u.map(function(Lt) {
                    var Wt = Lt.width;
                    return Wt;
                  }), Ke = wf(b.legend.label.fontSize), ut = JC({
                    initialWidth: W,
                    legendWidths: je,
                    options: v,
                    verticalAlign: Z,
                    visible: R,
                    checkbox: I,
                    chart: g,
                    itemHeight: Ke,
                    circleLegendVisible: Le
                  }), bt = ut.legendWidth, mt = ut.legendHeight, Rt = ut.rowCount, Dt = ut.columnCount;
                  s1(u, Rt, Dt, je.length, Z), Pt(a.legend, {
                    visible: R,
                    align: C,
                    showCheckbox: I,
                    width: bt,
                    height: mt
                  }), Ee && Le && this.dispatch("updateCircleLegendLayout", {
                    legendWidth: bt
                  }), !ue && !pv(h) && this.dispatch("updateLegendColor"), ke && this.dispatch("updateLegendIcon");
                },
                updateCircleLegendLayout: function(n, a) {
                  var o = n.state, u = a.legendWidth, h = u === 0 ? mv : Math.min(u, mv), v = Math.max((h - $i) / 2, 0);
                  Pt(o.circleLegend, {
                    visible: !0,
                    width: h,
                    radius: v
                  });
                },
                setLegendActiveState: function(n, a) {
                  var o = n.state, u = a.name, h = a.active, v = o.legend.data, g = v.find(function(b) {
                    var C = b.label;
                    return C === u;
                  });
                  g.active = h, this.notify(o, "legend");
                },
                setAllLegendActiveState: function(n, a) {
                  var o = n.state;
                  o.legend.data.forEach(function(u) {
                    u.active = a;
                  }), this.notify(o, "legend");
                },
                setLegendCheckedState: function(n, a) {
                  var o = n.state, u = a.name, h = a.checked, v = o.legend.data.find(function(g) {
                    var b = g.label;
                    return b === u;
                  });
                  v.checked = h, this.notify(o, "legend");
                },
                updateLegendColor: function(n) {
                  var a = n.state, o = a.legend, u = a.series, h = vb(o.data, u);
                  Pt(a.legend, {
                    data: h
                  });
                },
                updateLegendIcon: function(n) {
                  var a = n.state, o = a.legend, u = a.series, h = o.data.reduce(function(v, g) {
                    var b;
                    if (g.chartType === "scatter" && (b = u.scatter) !== null && b !== void 0 && b.data) {
                      var C = u.scatter.data.find(function(I) {
                        var W = I.name;
                        return W === g.label;
                      }), R = C ? C.iconType : g.iconType;
                      return [].concat(el(v), [sc(sc({}, g), {}, {
                        iconType: R
                      })]);
                    }
                    return [].concat(el(v), [g]);
                  }, []);
                  Pt(a.legend, {
                    data: h
                  });
                },
                updateNestedPieChartLegend: function(n) {
                  var a = n.state, o = a.legend, u = a.nestedPieSeries;
                  Pt(a.legend, {
                    data: vb(o.data, u)
                  });
                }
              },
              observe: {
                updateLegendLayout: function() {
                  this.dispatch("setLegendLayout");
                }
              }
            }, u1 = l1;
            function c1(t, n) {
              var a, o = (a = n.responsive) === null || a === void 0 ? void 0 : a.rules;
              return Array.isArray(o) ? o.reduce(function(u, h) {
                return h.condition(t) ? Ye(u, h.options) : u;
              }, n) : n;
            }
            function gb(t, n, a) {
              var o = t.width, u = t.height;
              return {
                width: o ? n.width : a == null ? void 0 : a.width,
                height: u ? n.height : a == null ? void 0 : a.height
              };
            }
            var f1 = {
              name: "options",
              state: function(n) {
                var a = n.options;
                return {
                  originalOptions: wt(a),
                  options: a
                };
              },
              action: {
                setOptions: function(n) {
                  var a = n.state, o = a.chart, u = o.width, h = o.height;
                  u < 0 || h < 0 || (a.options = c1({
                    width: u,
                    height: h
                  }, a.originalOptions));
                },
                initOptions: function(n, a) {
                  var o = n.initStoreState, u = n.state, h = a.options, v = a.containerSize;
                  o.options = h, u.originalOptions = wt(h);
                  var g = u.usingContainerSize, b = u.originalOptions, C = gb(g, v, {
                    width: b.chart.width,
                    height: b.chart.height
                  });
                  this.dispatch("setChartSize", C);
                },
                updateOptions: function(n, a) {
                  var o, u, h = n.state, v = n.initStoreState, g = a.options, b = a.containerSize;
                  v.options = Ye(v.options, g), h.originalOptions = Ye(h.originalOptions, g);
                  var C = h.usingContainerSize, R = h.originalOptions, I = gb(C, b, {
                    width: (o = R.chart) === null || o === void 0 ? void 0 : o.width,
                    height: (u = R.chart) === null || u === void 0 ? void 0 : u.height
                  });
                  this.dispatch("setChartSize", I), this.dispatch("initThemeState");
                }
              },
              observe: {
                updateOptions: function() {
                  this.dispatch("setOptions");
                }
              }
            }, d1 = f1;
            function yb(t) {
              return m1(t) || v1(t) || p1(t) || h1();
            }
            function h1() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function p1(t, n) {
              if (t) {
                if (typeof t == "string") return yv(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return yv(t, n);
              }
            }
            function v1(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function m1(t) {
              if (Array.isArray(t)) return yv(t);
            }
            function yv(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function bb(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function jn(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? bb(Object(a), !0).forEach(function(o) {
                  lc(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : bb(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function lc(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function g1(t, n, a) {
              var o = t == null ? void 0 : t.theme;
              if (!(o != null && o.series))
                return {};
              var u = a ? _t(n) : Object.keys(n);
              return u.reduce(function(h, v) {
                return delete h[v], h;
              }, jn({}, o.series));
            }
            function y1(t) {
              var n, a, o = jn({}, t.theme);
              if (!Array.isArray(o.yAxis))
                return o;
              var u = Ky(t == null || (n = t.theme) === null || n === void 0 || (a = n.chart) === null || a === void 0 ? void 0 : a.fontFamily), h = o.yAxis.map(function(v) {
                return Ye({
                  title: jn({}, u)
                }, jn({}, v));
              });
              return jn(jn({}, o), {}, {
                yAxis: h
              });
            }
            function b1(t, n, a, o) {
              var u = y1(t);
              if (!(u != null && u.series))
                return jn({}, u);
              var h = jn(jn({}, u), {}, {
                series: {}
              }), v = Object.keys(n), g = v.length > 1;
              if (o) {
                var b = _t(n);
                h.series = {
                  pie: b.reduce(function(C, R) {
                    var I;
                    return jn(jn({}, C), {}, lc({}, R, Ye((I = u.series) === null || I === void 0 ? void 0 : I[R], He(a, "colors"))));
                  }, {})
                };
              } else g ? h.series = jn({}, v.reduce(function(C, R) {
                var I;
                return jn(jn({}, C), {}, lc({}, R, Ye((I = u.series) === null || I === void 0 ? void 0 : I[R], He(a, "colors"))));
              }, {})) : h.series = lc({}, v[0], u.series);
              return h;
            }
            function S1(t, n, a, o, u) {
              var h, v = 0, g = [].concat(yb((h = a == null ? void 0 : a.colors) !== null && h !== void 0 ? h : []), yb(Jo.colors)), b = o ? _t(n) : Object.keys(n);
              b.forEach(function(C, R) {
                var I, W = n[C] || [], Z = W.filter(function(je) {
                  return je.colorByCategories;
                }), ue = Z.length > 0, ke;
                if (o)
                  ke = n.pie[R].data.length;
                else if (ue) {
                  var Ee = W.filter(function(je) {
                    return !je.colorByCategories;
                  });
                  ke = Ee.length + u.length;
                } else
                  ke = n[C].length;
                var Le = o ? t.series.pie : t.series;
                (I = Le[C]) !== null && I !== void 0 && I.colors || (Le[C] = jn(jn({}, Le[C]), {}, {
                  colors: g.slice(v, v + ke)
                }), v += ke);
              });
            }
            function w1(t) {
              ["vertical", "horizontal"].reduce(function(n, a) {
                return n[a] || (n[a] = {
                  lineColor: n.lineColor
                }), n;
              }, t.plot);
            }
            function x1(t, n, a) {
              var o, u, h, v, g, b, C;
              return {
                hasOuterAnchor: !!n.pie && (t == null || (o = t.series) === null || o === void 0 || (u = o[a]) === null || u === void 0 || (h = u.dataLabels) === null || h === void 0 ? void 0 : h.anchor) === "outer",
                hasOuterAnchorPieSeriesName: !!n.pie && (t == null || (v = t.series) === null || v === void 0 || (g = v[a]) === null || g === void 0 || (b = g.dataLabels) === null || b === void 0 || (C = b.pieSeriesName) === null || C === void 0 ? void 0 : C.anchor) === "outer"
              };
            }
            function Sb(t, n, a) {
              var o, u, h = ht(n), v = g1(t, n, h), g = {
                hasOuterAnchor: nr(t, n),
                hasOuterAnchorPieSeriesName: Tr(t, n)
              };
              if (h) {
                var b = _t(n);
                g = b.reduce(function(I, W) {
                  return jn(jn({}, I), {}, lc({}, W, x1(t, n, W)));
                }, {});
              }
              var C = t == null || (o = t.theme) === null || o === void 0 || (u = o.chart) === null || u === void 0 ? void 0 : u.fontFamily, R = Ye(PC(n, g, C, h), b1(t, n, v, h));
              return n.heatmap || S1(R, n, v, h, a), w1(R), R;
            }
            var k1 = {
              name: "theme",
              state: function(n) {
                var a = n.options, o = n.series, u = n.categories;
                return {
                  theme: Sb(a, o, u)
                };
              },
              action: {
                initThemeState: function(n) {
                  var a = n.state, o = n.initStoreState;
                  a.theme = Sb(a.options, o.series, o.categories);
                }
              },
              observe: {
                updateTheme: function() {
                  this.dispatch("initThemeState");
                }
              }
            }, O1 = k1;
            function C1(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function T1(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function A1(t, n, a) {
              return n && T1(t.prototype, n), t;
            }
            function E1(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var M1 = /* @__PURE__ */ function() {
              function t() {
                C1(this, t), E1(this, "handlers", []);
              }
              return A1(t, [{
                key: "on",
                value: function(a, o) {
                  this.handlers[a] || (this.handlers[a] = []), this.handlers[a].push(o);
                }
              }, {
                key: "emit",
                value: function(a) {
                  for (var o, u = arguments.length, h = new Array(u > 1 ? u - 1 : 0), v = 1; v < u; v++)
                    h[v - 1] = arguments[v];
                  (o = this.handlers[a]) === null || o === void 0 || o.forEach(function(g) {
                    return g.apply(void 0, h);
                  });
                }
              }]), t;
            }();
            function R1(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function D1(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function P1(t, n, a) {
              return n && D1(t.prototype, n), t;
            }
            function bv(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var L1 = /* @__PURE__ */ function() {
              function t(n) {
                var a = n.store, o = n.eventBus;
                R1(this, t), bv(this, "components", []), bv(this, "store", void 0), bv(this, "eventBus", void 0), this.store = a, this.eventBus = o;
              }
              return P1(t, [{
                key: "add",
                value: function(a, o) {
                  var u = this, h = new a({
                    store: this.store,
                    eventBus: this.eventBus
                  });
                  h.initialize && h.initialize(o);
                  var v = function() {
                    h.render(arguments.length <= 0 ? void 0 : arguments[0], arguments.length <= 1 ? void 0 : arguments[1]), h.sync(), u.eventBus.emit("needLoop");
                  };
                  this.store.observe(function() {
                    v.apply(void 0, arguments);
                  }), v = at(v), this.components.push(h);
                }
              }, {
                key: "remove",
                value: function(a) {
                  this.components = this.components.filter(function(o) {
                    return !(o instanceof a);
                  });
                }
              }, {
                key: "clear",
                value: function() {
                  this.components = [], this.eventBus.emit("needDraw");
                }
              }, {
                key: "invoke",
                value: function(a, o) {
                  this.components.forEach(function(u) {
                    var h = u[a];
                    h && h.call(u, o);
                  });
                }
              }, {
                key: "forEach",
                value: function(a) {
                  this.components.forEach(a);
                }
              }]), t;
            }();
            function I1(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function _1(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function N1(t, n, a) {
              return n && _1(t.prototype, n), t;
            }
            function zl(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var B1 = /* @__PURE__ */ function() {
              function t(n) {
                I1(this, t), zl(this, "width", 0), zl(this, "height", 0), zl(this, "brushes", {}), zl(this, "chart", void 0), zl(this, "canvas", void 0), zl(this, "ctx", void 0), this.chart = n;
              }
              return N1(t, [{
                key: "showUnsupportedCanvasFeatureError",
                value: function() {
                  this.ctx.setLineDash || console.warn(ve.DASH_SEGMENTS_UNAVAILABLE_ERROR);
                }
              }, {
                key: "setup",
                value: function() {
                  var a = this.chart.store.state.chart, o = a.height, u = a.width;
                  if (!this.canvas) {
                    var h = document.createElement("canvas");
                    this.canvas = h, this.chart.el.appendChild(h), h.addEventListener("click", this.chart), h.addEventListener("mousemove", this.chart), h.addEventListener("mousedown", this.chart), h.addEventListener("mouseup", this.chart), h.addEventListener("mouseout", this.chart);
                    var v = h.getContext("2d");
                    v && (this.ctx = v);
                  }
                  this.setSize(u, o), this.showUnsupportedCanvasFeatureError();
                }
              }, {
                key: "setSize",
                value: function(a, o) {
                  this.canvas.style.width = "".concat(a, "px"), this.canvas.style.height = "".concat(o, "px");
                  var u = 1;
                  "deviceXDPI" in window.screen ? u = window.screen.deviceXDPI / window.screen.logicalXDPI : window.hasOwnProperty("devicePixelRatio") && (u = window.devicePixelRatio), this.width = a * u || 0, this.height = o * u || 0, this.scaleCanvasRatio(u);
                }
              }, {
                key: "scaleCanvasRatio",
                value: function(a) {
                  this.canvas.width = this.width, this.canvas.height = this.height, this.ctx.scale(a, a);
                }
              }, {
                key: "add",
                value: function(a, o) {
                  this.brushes[a] = o;
                }
              }, {
                key: "addGroups",
                value: function(a) {
                  var o = this;
                  a.forEach(function(u) {
                    Object.keys(u).forEach(function(h) {
                      o.add(h, u[h]);
                    });
                  });
                }
              }, {
                key: "paint",
                value: function(a, o) {
                  if (this.brushes[a])
                    this.brushes[a](this.ctx, o);
                  else
                    throw new Error(ve.noBrushError(a));
                }
              }, {
                key: "paintForEach",
                value: function(a) {
                  var o = this;
                  a.forEach(function(u) {
                    return o.paint(u.type, u);
                  });
                }
              }, {
                key: "beforeFrame",
                value: function() {
                  this.ctx.clearRect(0, 0, this.width, this.height), this.ctx.fillStyle = "transparent", this.ctx.fillRect(0, 0, this.width, this.height);
                }
              }, {
                key: "beforeDraw",
                value: function(a, o) {
                  this.ctx.save(), this.ctx.translate(a, o);
                }
              }, {
                key: "afterDraw",
                value: function() {
                  this.ctx.restore();
                }
              }]), t;
            }();
            function F1(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function z1(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function H1(t, n, a) {
              return n && z1(t.prototype, n), t;
            }
            function Of(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var j1 = /* @__PURE__ */ function() {
              function t() {
                F1(this, t), Of(this, "anims", []), Of(this, "state", "IDLE"), Of(this, "requestId", null), Of(this, "firstRendering", !0);
              }
              return H1(t, [{
                key: "add",
                value: function(a) {
                  var o = this, u = a.chart, h = a.duration, v = a.requester, g = a.onCompleted, b = g === void 0 ? function() {
                  } : g, C = a.onFrame, R = C === void 0 ? function(I) {
                    o.firstRendering || u.update(I), o.firstRendering && (u.initUpdate(I), I === 1 && (o.firstRendering = !1));
                  } : C;
                  this.anims.length && this.reset(), this.state === "IDLE" && (this.anims.push({
                    chart: u,
                    requester: v,
                    duration: h,
                    onFrame: R,
                    onCompleted: b,
                    start: null,
                    current: null,
                    completed: !1
                  }), this.start());
                }
              }, {
                key: "reset",
                value: function() {
                  this.anims.forEach(function(a) {
                    a.current = 1, a.onFrame(a.current), a.completed = !0;
                  }), this.anims = [], this.cancelAnimFrame(), this.state = "IDLE", this.requestId = null;
                }
              }, {
                key: "start",
                value: function() {
                  this.anims.length && (this.state = "RUNNING", this.runFrame());
                }
              }, {
                key: "runFrame",
                value: function() {
                  var a = this;
                  this.requestId = window.requestAnimationFrame(function(o) {
                    a.runAnims(o);
                  });
                }
              }, {
                key: "runAnims",
                value: function(a) {
                  this.next(a), this.anims.length ? this.runFrame() : (this.state = "IDLE", this.requestId = null);
                }
              }, {
                key: "next",
                value: function(a) {
                  var o = this;
                  this.anims.forEach(function(u) {
                    Oe(u.start) && (u.start = a), Object.defineProperty(u.chart, "___animId___", {
                      value: a,
                      enumerable: !1,
                      writable: !1,
                      configurable: !0
                    }), u.current = u.duration ? Math.min((a - u.start) / u.duration, 1) : 1, u.onFrame(u.current), u.completed = u.current === 1;
                  }), this.anims.forEach(function(u) {
                    u.chart.___animId___ === a && (u.chart.draw(), delete u.chart.___animId___), u.completed && (o.cancelAnimFrame(), u.onCompleted(), u.chart.eventBus.emit("animationCompleted", u.requester));
                  }), this.anims = this.anims.filter(function(u) {
                    return !u.completed;
                  });
                }
              }, {
                key: "cancelAnimFrame",
                value: function() {
                  this.requestId && window.cancelAnimationFrame(this.requestId);
                }
              }]), t;
            }();
            function W1(t, n) {
              return G1(t) || V1(t, n) || U1(t, n) || $1();
            }
            function $1() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function U1(t, n) {
              if (t) {
                if (typeof t == "string") return wb(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return wb(t, n);
              }
            }
            function wb(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function V1(t, n) {
              var a = t && (typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]);
              if (a != null) {
                var o = [], u = !0, h = !1, v, g;
                try {
                  for (a = a.call(t); !(u = (v = a.next()).done) && (o.push(v.value), !(n && o.length === n)); u = !0)
                    ;
                } catch (b) {
                  h = !0, g = b;
                } finally {
                  try {
                    !u && a.return != null && a.return();
                  } finally {
                    if (h) throw g;
                  }
                }
                return o;
              }
            }
            function G1(t) {
              if (Array.isArray(t)) return t;
            }
            function Y1(t) {
              var n = t.slope, a = t.yIntercept, o = t.mouseX, u = t.mouseY, h = t.modelXPositions, v = t.compX, g = t.compY, b = t.detectionSize, C = b === void 0 ? 0 : b, R = W1(h, 2), I = R[0], W = R[1], Z = n * (o - v) + a, ue = I > W && o >= v + W && o <= v + I || I < W && o <= v + W && o >= v + I, ke = Z - C + g <= u && u <= Z + C + g;
              return ue && ke;
            }
            var Cf = {
              circle: function(n, a, o) {
                var u = n.x, h = n.y, v = a.x, g = a.y, b = a.radius, C = a.detectionSize, R = o.x, I = o.y, W = we(C) ? 10 : C;
                return Math.pow(u - (v + R), 2) + Math.pow(h - (g + I), 2) < Math.pow(b + W, 2);
              },
              rect: function(n, a) {
                var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
                  x: 0,
                  y: 0
                }, u = n.x, h = n.y, v = a.x, g = a.y, b = a.width, C = a.height, R = o.x, I = o.y;
                return u >= v + R && u <= v + R + b && h >= g + I && h <= g + I + C;
              },
              sector: function(n, a) {
                var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
                  x: 0,
                  y: 0
                }, u = n.x, h = n.y, v = a.x, g = a.y, b = a.radius, C = b.outer, R = b.inner, I = a.degree, W = I.start, Z = I.end, ue = a.drawingStartAngle, ke = a.clockwise, Ee = o.x, Le = o.y, je = u - (v + Ee), Ke = h - (g + Le), ut = Math.pow(je, 2) + Math.pow(Ke, 2) < Math.pow(C, 2), bt = Math.pow(je, 2) + Math.pow(Ke, 2) > Math.pow(R, 2), mt = ut && bt, Rt = El(Math.atan2(Ke, je), ue);
                return mt && go(ke, W, Z, Rt);
              },
              line: function(n, a) {
                var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
                  x: 0,
                  y: 0
                }, u = n.x, h = n.y, v = o.x, g = o.y, b = a.x, C = a.y, R = a.x2, I = a.y2, W = a.detectionSize, Z = W === void 0 ? 3 : W, ue = I - C, ke = R - b, Ee = !1;
                if (ue === 0) {
                  var Le = Math.min(b, R), je = Math.max(b, R);
                  Ee = u - v >= Le && u - v <= je && h >= C + g - Z && h <= C + g + Z;
                } else if (ke === 0) {
                  var Ke = Math.min(C, I), ut = Math.max(C, I);
                  Ee = h - g >= Ke && h - g <= ut && u >= b + v - Z && u <= b + v + Z;
                } else {
                  var bt = ue / ke, mt = u - (b + v), Rt = h - (C + g);
                  Ee = bt * mt === Rt;
                }
                return Ee;
              },
              boxPlot: function(n, a) {
                var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
                };
                return ["rect", "median", "minimum", "maximum", "upperWhisker", "lowerWhisker"].some(function(u) {
                  return a[u] ? u === "rect" ? Cf.rect(n, a[u], o) : Cf.line(n, a[u], o) : !1;
                });
              },
              clockHand: function(n, a) {
                var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
                  x: 0,
                  y: 0
                }, u = n.x, h = n.y, v = o.x, g = o.y, b = a.x, C = a.y, R = a.x2, I = a.y2, W = a.detectionSize, Z = W === void 0 ? 5 : W, ue = I - C, ke = R - b, Ee = !1;
                if (ue === 0) {
                  var Le = Math.min(b, R), je = Math.max(b, R);
                  Ee = u - v >= Le && u - v <= je && h >= C + g - Z && h <= C + g + Z;
                } else if (ke === 0) {
                  var Ke = Math.min(C, I), ut = Math.max(C, I);
                  Ee = h - g >= Ke && h - g <= ut && u >= b + v - Z && u <= b + v + Z;
                } else {
                  var bt = ue / ke, mt = C - bt * b;
                  Ee = Y1({
                    slope: bt,
                    yIntercept: mt,
                    mouseX: u,
                    mouseY: h,
                    modelXPositions: [b, R],
                    compX: v,
                    compY: g,
                    detectionSize: Z
                  });
                }
                return Ee;
              }
            }, q1 = 7 * 24 * 60 * 60 * 1e3;
            function K1(t) {
              var n = (/* @__PURE__ */ new Date()).getTime();
              return n - t > q1;
            }
            function X1(t, n) {
              var a = Object.keys(n).map(function(u, h) {
                return "".concat(h ? "&" : "").concat(u, "=").concat(n[u]);
              }).join(""), o = document.createElement("img");
              return o.src = "".concat(t, "?").concat(a), o.style.display = "none", document.body.appendChild(o), document.body.removeChild(o), o;
            }
            function J1() {
              var t = location.hostname, n = "TOAST UI chart for ".concat(t, ": Statistics"), a = window.localStorage.getItem(n);
              a && !K1(Number(a)) || (window.localStorage.setItem(n, String((/* @__PURE__ */ new Date()).getTime())), setTimeout(function() {
                (document.readyState === "interactive" || document.readyState === "complete") && X1("https://www.google-analytics.com/collect", {
                  v: 1,
                  t: "event",
                  tid: "UA-129983528-2",
                  cid: t,
                  dp: t,
                  dh: "chart",
                  el: "chart",
                  ec: "use"
                });
              }, 1e3));
            }
            function Z1(t) {
              return rT(t) || tT(t) || eT(t) || Q1();
            }
            function Q1() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function eT(t, n) {
              if (t) {
                if (typeof t == "string") return Sv(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return Sv(t, n);
              }
            }
            function tT(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function rT(t) {
              if (Array.isArray(t)) return Sv(t);
            }
            function Sv(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function xb(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function uc(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? xb(Object(a), !0).forEach(function(o) {
                  dn(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : xb(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function nT(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function iT(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function aT(t, n, a) {
              return n && iT(t.prototype, n), t;
            }
            function dn(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var kb = 500;
            function oT(t, n, a, o) {
              var u = n.width, h = n.height, v = V(a), g = V(o);
              return t === "updateOptions" ? {
                width: !we(a) && u !== v ? v : u,
                height: !we(o) && h !== g ? g : h
              } : {
                width: v,
                height: g
              };
            }
            var Wn = /* @__PURE__ */ function() {
              function t(n) {
                var a = this, o, u;
                nT(this, t), dn(this, "store", void 0), dn(this, "___animId___", null), dn(this, "animator", void 0), dn(this, "containerEl", void 0), dn(this, "el", void 0), dn(this, "ctx", void 0), dn(this, "painter", new B1(this)), dn(this, "eventBus", new M1()), dn(this, "componentManager", void 0), dn(this, "modules", void 0), dn(this, "enteredComponents", []), dn(this, "animationControlFlag", {
                  resizing: !1,
                  updating: !1
                }), dn(this, "resizeObserver", null), dn(this, "debounceResizeEvent", at(function() {
                  var R = a.containerEl, I = R.offsetWidth, W = R.offsetHeight;
                  a.resizeChartSize(I, W);
                }, 100)), dn(this, "getCheckedLegend", function() {
                  var R = a.store.state.legend.data;
                  return R.filter(function(I) {
                    return I.checked;
                  }).map(function(I) {
                    return Ue(I, "chartType", "label", "checked");
                  });
                }), dn(this, "getOptions", function() {
                  return ne(a.store.initStoreState.options);
                }), dn(this, "on", function(R, I) {
                  a.eventBus.on(R, I);
                }), dn(this, "destroy", function() {
                  a.componentManager.clear(), a.clearResizeEvent(), a.containerEl.innerHTML = "";
                }), dn(this, "selectSeries", function(R) {
                  if (!a.isSelectableSeries())
                    throw new Error(ve.SELECT_SERIES_API_SELECTABLE_ERROR);
                  a.eventBus.emit("selectSeries", uc(uc({}, R), {}, {
                    state: a.store.state
                  }));
                }), dn(this, "unselectSeries", function() {
                  if (!a.isSelectableSeries())
                    throw new Error(ve.SELECT_SERIES_API_SELECTABLE_ERROR);
                  a.store.dispatch("setAllLegendActiveState", !0), a.eventBus.emit("resetSelectedSeries");
                }), dn(this, "resize", function(R) {
                  a.resetSeries(), a.dispatchOptionsEvent("updateOptions", {
                    chart: uc({}, R)
                  });
                }), dn(this, "resetSeries", function() {
                  a.eventBus.emit("resetHoveredSeries"), a.eventBus.emit("resetSelectedSeries");
                }), dn(this, "setResizeEventListeners", function(R, I) {
                  var W, Z, ue = a.store.state.usingContainerSize, ke = ue.width, Ee = ue.height, Le = I == null || (W = I.chart) === null || W === void 0 ? void 0 : W.width, je = I == null || (Z = I.chart) === null || Z === void 0 ? void 0 : Z.height, Ke = V(Le), ut = V(je);
                  a.store.dispatch("setUsingContainerSize", oT(R, ue, Le, je)), (ke || Ee) && Me(Le) && Me(je) ? a.clearResizeEvent() : !(ke || Ee) && (Ke || ut) && a.setResizeEvent();
                });
                var h = n.el, v = n.options, g = n.series, b = n.categories, C = n.modules;
                this.modules = C ?? [], (we(v.usageStatistics) || v.usageStatistics) && J1(), this.containerEl = h, this.el = this.createChartWrapper(), this.containerEl.appendChild(this.el), this.animator = new j1(), this.store = new xt({
                  series: g,
                  categories: b,
                  options: v
                }), this.componentManager = new L1({
                  store: this.store,
                  eventBus: this.eventBus
                }), this.eventBus.on("needLoop", at(function() {
                  var R, I = a.getAnimationDuration((R = v.chart) === null || R === void 0 ? void 0 : R.animation);
                  if (a.animationControlFlag.resizing) {
                    var W;
                    I = we(v.responsive) ? a.getAnimationDuration() : a.getAnimationDuration((W = v.responsive) === null || W === void 0 ? void 0 : W.animation), a.animationControlFlag.resizing = !1;
                  }
                  a.eventBus.emit("loopStart"), a.animator.add({
                    onCompleted: function() {
                      a.eventBus.emit("loopComplete");
                    },
                    chart: a,
                    duration: I,
                    requester: a
                  });
                }, 10)), this.eventBus.on("needSubLoop", function(R) {
                  a.animator.add(uc(uc({}, R), {}, {
                    chart: a
                  }));
                }), this.eventBus.on("needDraw", at(function() {
                  a.draw();
                }, 10)), this.initialize(), this.store.observe(function() {
                  a.painter.setup();
                }), (V(v == null || (o = v.chart) === null || o === void 0 ? void 0 : o.width) || V(v == null || (u = v.chart) === null || u === void 0 ? void 0 : u.height)) && this.setResizeEvent();
              }
              return aT(t, [{
                key: "getAnimationDuration",
                value: function(a) {
                  var o = this.animator.firstRendering, u = this.animationControlFlag, h = u.resizing, v = u.updating, g;
                  return !o && !h || we(a) ? g = kb : Qe(a) ? g = a ? kb : 0 : Me(a.duration) && (g = a.duration), v && (g = 0), this.animationControlFlag.updating = !1, g;
                }
              }, {
                key: "createChartWrapper",
                value: function() {
                  var a = document.createElement("div");
                  return a.classList.add("toastui-chart-wrapper"), a;
                }
              }, {
                key: "resizeChartSize",
                value: function(a, o) {
                  this.animationControlFlag.resizing = !0;
                  var u = this.store.state, h = u.usingContainerSize, v = h.width, g = h.height, b = u.chart, C = b.width, R = b.height;
                  if (!(v || g) || !(a || o) || a === C && o === R) {
                    this.animationControlFlag.resizing = !1;
                    return;
                  }
                  this.resetSeries(), this.store.dispatch("setChartSize", {
                    width: v ? a : C,
                    height: g ? o : R
                  }), this.draw();
                }
              }, {
                key: "setResizeEvent",
                value: function() {
                  var a = this, o = this.store.state.usingContainerSize;
                  if (o.height && !this.containerEl.style.height.length || o.width && !this.containerEl.style.width.length)
                    throw new Error(ve.AUTO_LAYOUT_CONTAINER_SIZE_ERROR);
                  var u = typeof ResizeObserver > "u";
                  u ? window.addEventListener("resize", this.debounceResizeEvent) : (this.resizeObserver = new ResizeObserver(function(h) {
                    h.forEach(function() {
                      a.debounceResizeEvent();
                    });
                  }), this.resizeObserver.observe(this.containerEl));
                }
              }, {
                key: "clearResizeEvent",
                value: function() {
                  this.resizeObserver ? (this.resizeObserver.unobserve(this.containerEl), this.resizeObserver.disconnect(), this.resizeObserver = null) : window.removeEventListener("resize", this.debounceResizeEvent);
                }
              }, {
                key: "handleCanvasMouseEvent",
                value: function(a, o) {
                  var u = this, h = [];
                  this.componentManager.forEach(function(v) {
                    if (a === "mousemove") {
                      var g = u.enteredComponents.some(function(b) {
                        return b === v;
                      });
                      dk(v.rect, o) ? (h.push(v), !g && v.onMouseenterComponent && v.onMouseenterComponent()) : g && v.onMouseoutComponent && v.onMouseoutComponent();
                    } else a === "mouseout" && v.onMouseoutComponent && v.onMouseoutComponent();
                  }), this.enteredComponents = h;
                }
              }, {
                key: "handleResponderEvent",
                value: function(a, o) {
                  var u = a.type, h = "on".concat(u[0].toUpperCase() + u.substring(1)), v = [];
                  this.componentManager.forEach(function(g) {
                    if (g[h] && Cf.rect(o, g.rect)) {
                      var b = (g.responders || []).filter(function(C) {
                        return Cf[C.type](o, C, g.rect);
                      });
                      b.length && v.push({
                        component: g,
                        detected: b
                      }), g[h]({
                        mousePosition: o,
                        responders: b
                      }, a);
                    }
                  }), this.handleEventForAllResponders && this.handleEventForAllResponders(a, v, h, o);
                }
              }, {
                key: "handleEvent",
                value: function(a) {
                  var o = a.clientX, u = a.clientY, h = a.type, v = this.painter.ctx.canvas, g = v.getBoundingClientRect(), b = g.width, C = g.height, R = g.left, I = g.top, W = b / v.offsetWidth, Z = C / v.offsetHeight, ue = {
                    x: (o - R) / W,
                    y: (u - I) / Z
                  };
                  (h === "mousemove" || h === "mouseout") && this.handleCanvasMouseEvent(h, ue), this.handleResponderEvent(a, ue);
                }
              }, {
                key: "initStore",
                value: function() {
                  var a = this;
                  [zt, d1, O1, dC, u1, UO, qO].concat(Z1(this.modules)).forEach(function(o) {
                    return a.store.setModule(o);
                  });
                }
              }, {
                key: "initialize",
                value: function() {
                  this.initStore(), this.store.dispatch("initChartSize", this.containerEl);
                }
              }, {
                key: "draw",
                value: function() {
                  var a = this;
                  this.painter.beforeFrame(), this.componentManager.forEach(function(o) {
                    o.isShow && (a.painter.beforeDraw(o.rect.x, o.rect.y), o.beforeDraw && o.beforeDraw(a.painter), o.draw(a.painter), a.painter.afterDraw());
                  });
                }
              }, {
                key: "update",
                value: function(a) {
                  this.componentManager.invoke("update", a);
                }
              }, {
                key: "initUpdate",
                value: function(a) {
                  this.componentManager.invoke("initUpdate", a);
                }
              }, {
                key: "isSelectableSeries",
                value: function() {
                  var a;
                  return (a = this.store.initStoreState.options.series) === null || a === void 0 ? void 0 : a.selectable;
                }
                /**
                 * Select series. It works only when the selectable option is true.
                 * @param {Object} seriesInfo - Information of the series to be selected
                 *      @param {number} [seriesInfo.seriesIndex] - Index of series
                 *      @param {number} [seriesInfo.index] - Index of data within series
                 *      @param {string} [seriesInfo.name] - Specify name for NestedPie Chart
                 *      @param {string} [seriesInfo.chartType] - Specify which chart to select when using LineArea, LineScatter, and ColumnLine charts.specifies which chart to select when using LineArea, LineScatter, and ColumnLine charts.
                 * @api
                 * @example
                 * chart.selectSeries({index: 1, seriesIndex: 2});
                 */
              }, {
                key: "setTooltipOffset",
                value: (
                  /**
                   * Set tooltip offset.
                   * @param {Object} offset - Offset size
                   *   @param {number} [offset.x] Offset value to move title horizontally
                   *   @param {number} [offset.y] Offset value to move title vertically
                   * @api
                   * @example
                   * chart.setTooltipOffset({x: 10, y: -20});
                   */
                  function(a) {
                    var o = a.x, u = a.y;
                    this.store.dispatch("updateOptions", {
                      options: {
                        tooltip: {
                          offsetX: o,
                          offsetY: u
                        }
                      }
                    });
                  }
                )
              }, {
                key: "dispatchOptionsEvent",
                value: function(a, o) {
                  this.setResizeEventListeners(a, o);
                  var u = this.containerEl, h = u.offsetWidth, v = u.offsetHeight;
                  this.store.dispatch(a, {
                    options: o,
                    containerSize: {
                      width: h,
                      height: v
                    }
                  });
                }
              }]), t;
            }();
            l(8143), l(2023);
            function sT(t, n) {
              return cT(t) || uT(t, n) || Ob(t, n) || lT();
            }
            function lT() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function uT(t, n) {
              var a = t && (typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]);
              if (a != null) {
                var o = [], u = !0, h = !1, v, g;
                try {
                  for (a = a.call(t); !(u = (v = a.next()).done) && (o.push(v.value), !(n && o.length === n)); u = !0)
                    ;
                } catch (b) {
                  h = !0, g = b;
                } finally {
                  try {
                    !u && a.return != null && a.return();
                  } finally {
                    if (h) throw g;
                  }
                }
                return o;
              }
            }
            function cT(t) {
              if (Array.isArray(t)) return t;
            }
            function Ja(t) {
              return hT(t) || dT(t) || Ob(t) || fT();
            }
            function fT() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function Ob(t, n) {
              if (t) {
                if (typeof t == "string") return wv(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return wv(t, n);
              }
            }
            function dT(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function hT(t) {
              if (Array.isArray(t)) return wv(t);
            }
            function wv(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function xv(t) {
              var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, a = {
                min: Math.min.apply(Math, Ja(t)),
                max: Math.max.apply(Math, Ja(t))
              };
              if (t.length === 1) {
                var o = sT(t, 1), u = o[0];
                n ? (a.min = u, a.max = u) : u > 0 ? a.min = 0 : u === 0 ? a.max = 10 : a.max = 0;
              } else a.min === 0 && a.max === 0 ? a.max = 10 : a.min === a.max && (a.min -= a.min / 10, a.max += a.max / 10);
              return a;
            }
            function cc(t, n, a) {
              var o, u, h, v, g = {
                min: Number.MAX_SAFE_INTEGER,
                max: Number.MIN_SAFE_INTEGER
              };
              return {
                min: Math.min(n[a].min, (o = (u = t[a]) === null || u === void 0 ? void 0 : u.min) !== null && o !== void 0 ? o : g.min),
                max: Math.max(n[a].max, (h = (v = t[a]) === null || v === void 0 ? void 0 : v.max) !== null && h !== void 0 ? h : g.max)
              };
            }
            function pT(t) {
              return Object.values(t).reduce(function(n, a) {
                return a.xAxis && (n.xAxis = cc(n, a, "xAxis")), a.yAxis && (n.yAxis = cc(n, a, "yAxis")), a.secondaryYAxis && (n.secondaryYAxis = cc(n, a, "secondaryYAxis")), a.circularAxis && (n.circularAxis = cc(n, a, "circularAxis")), a.verticalAxis && (n.verticalAxis = cc(n, a, "verticalAxis")), n;
              }, {});
            }
            function vT(t) {
              var n = t.options, a = t.seriesName, o = t.values, u = t.valueAxisName, h = t.seriesDataRange, v;
              if (Ve([_r.X, _r.CIRCULAR, _r.VERTICAL], u))
                v = [u];
              else {
                var g = n, b = qa(g), C = b.secondaryYAxis;
                v = ly(g) && C !== null && C !== void 0 && C.chartType ? [C.chartType === a ? "secondaryYAxis" : "yAxis"] : uy(g, u);
              }
              return v.forEach(function(R) {
                h[a][R] = xv(Ja(new Set(o)));
              }), h;
            }
            function mT(t, n) {
              return t[n].data.flatMap(function(a) {
                var o = a.data, u = a.outliers, h = u === void 0 ? [] : u;
                return [].concat(Ja((o ?? []).flatMap(function(v) {
                  return v;
                })), Ja((h ?? []).flatMap(function(v) {
                  return v;
                })));
              });
            }
            function gT(t, n) {
              return t[n].data.flatMap(function(a) {
                var o = a.data, u = a.markers, h = a.ranges;
                return [o].concat(Ja((u ?? []).flatMap(function(v) {
                  return v;
                })), Ja((h ?? []).flatMap(function(v) {
                  return v;
                })));
              });
            }
            function yT(t, n, a) {
              var o = t.filter(function(h) {
                return !Oe(h);
              }).map(function(h) {
                return qo(h);
              }), u = n.map(function(h) {
                return Number(a ? new Date(h) : h);
              });
              return {
                xAxisValues: u,
                yAxisValues: o
              };
            }
            var bT = {
              name: "dataRange",
              state: function() {
                return {
                  dataRange: {}
                };
              },
              action: {
                setDataRange: function(n) {
                  var a = n.state, o = n.initStoreState, u = a.series, h = a.disabledSeries, v = a.stackSeries, g = a.categories, b = a.options, C = {}, R = sa({
                    series: u,
                    options: b,
                    categories: g
                  }), I = ff(R, u), W = I.labelAxisName, Z = I.valueAxisName;
                  Object.keys(u).forEach(function(ke) {
                    var Ee;
                    C[ke] = {};
                    var Le = u[ke].data.flatMap(function(Dt) {
                      var Lt = Dt.data, Wt = Dt.name;
                      return h.includes(Wt) ? [] : Lt;
                    }), je = De(Le);
                    if (_l(o.series)) {
                      var Ke, ut = !!((Ke = b.xAxis) !== null && Ke !== void 0 && Ke.date), bt = yT(Le, g, ut), mt = bt.yAxisValues, Rt = bt.xAxisValues;
                      Le = mt, C[ke][W] = xv(Ja(Rt), !0);
                    } else u[ke].data.length ? ko(je) ? Le = Le.reduce(function(Dt, Lt) {
                      return Oe(Lt) ? Dt : Array.isArray(Lt) ? [].concat(Ja(Dt), Ja(Lt)) : Ja(Lt);
                    }, []) : v && (Ee = v[ke]) !== null && Ee !== void 0 && Ee.stack ? Le = v[ke].dataRangeValues : ke === "boxPlot" ? Le = mT(u, ke) : ke === "bullet" && (Le = gT(u, ke)) : Le = [];
                    Ve(["bar", "column", "radar", "bullet"], ke) && Le.push(0), vT({
                      options: b,
                      seriesName: ke,
                      values: Le,
                      valueAxisName: Z,
                      seriesDataRange: C
                    });
                  });
                  var ue = pT(C);
                  Pt(a.dataRange, ue);
                }
              },
              observe: {
                updateDataRange: function() {
                  this.dispatch("setDataRange");
                }
              }
            }, Vi = bT;
            function Cb(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function ST(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? Cb(Object(a), !0).forEach(function(o) {
                  wT(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : Cb(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function wT(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function Tb(t) {
              return CT(t) || OT(t) || kT(t) || xT();
            }
            function xT() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function kT(t, n) {
              if (t) {
                if (typeof t == "string") return kv(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return kv(t, n);
              }
            }
            function OT(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function CT(t) {
              if (Array.isArray(t)) return kv(t);
            }
            function kv(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            var Ov = [1, 2, 5, 10], TT = 88;
            function AT(t, n, a) {
              var o = t.min, u = t.max;
              return {
                min: a.min ? o - n : o,
                max: a.max ? u + n : u
              };
            }
            function ET(t, n, a) {
              var o = n.min, u = n.max, h = t.limit, v = Me(a == null ? void 0 : a.min), g = Me(a == null ? void 0 : a.max), b = !v && h.min === o && h.min !== 0, C = !g && h.max === u && h.max !== 0;
              return !b && !C ? null : {
                min: b,
                max: C
              };
            }
            function fc(t) {
              var n = t === 0 ? 1 : Math.log(Math.abs(t)) / Math.LN10;
              return Math.pow(10, Math.floor(n));
            }
            function MT(t) {
              for (var n = 0, a = 0, o = Ov.length; a < o; a += 1) {
                n = Ov[a];
                var u = (n + (Ov[a + 1] || n)) / 2;
                if (t <= u)
                  break;
              }
              return n;
            }
            function RT(t) {
              var n = fc(t), a = t / n;
              return MT(a) * n;
            }
            function DT(t, n) {
              var a = t.min, o = t.max, u = Math.min(fc(o), fc(n)), h = u > 1 ? 1 : 1 / u, v = n * h;
              return o = Math.ceil(o * h / v) * v / h, a > n ? a = Math.floor(a * h / v) * v / h : a < 0 ? a = -(Math.ceil(Math.abs(a) * h / v) * v) / h : a = 0, {
                min: a,
                max: o
              };
            }
            function Ab(t, n) {
              var a = 1 / Math.min(fc(t), fc(n));
              return Math.ceil(t * a / (n * a));
            }
            function Eb(t) {
              return Me(t);
            }
            function PT(t, n) {
              var a = Eb(n.stepSize) ? t.stepSize : RT(t.stepSize), o = DT(t.limit, a), u = Math.abs(o.max - o.min), h = Ab(u, a);
              return {
                limit: {
                  min: o.min,
                  max: o.max
                },
                stepSize: a,
                stepCount: h
              };
            }
            function LT(t, n) {
              var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, o = t.min, u = t.max, h = Math.abs(u - o), v = h / n, g = Math.ceil(n / TT), b = n / g, C = v * b;
              return Eb(t.stepSize) ? (C = t.stepSize, g = h / C) : Me(a) && C < a && (C = a, g = h / C), {
                limit: {
                  min: o,
                  max: u
                },
                stepSize: C,
                stepCount: g
              };
            }
            function Mb(t, n) {
              var a, o, u;
              return {
                max: (a = n == null ? void 0 : n.max) !== null && a !== void 0 ? a : t.max,
                min: (o = n == null ? void 0 : n.min) !== null && o !== void 0 ? o : t.min,
                stepSize: (u = n == null ? void 0 : n.stepSize) !== null && u !== void 0 ? u : "auto"
              };
            }
            function dc(t) {
              var n = t.dataRange, a = t.scaleOption, o = t.offsetSize, u = t.minStepSize, h = t.useSpectrumLegend, v = Mb(n, a), g = LT(v, o, u), b = PT(g, v), C = h ? null : ET(b, v, a);
              if (C) {
                var R = b.stepSize, I = b.limit;
                b.limit = AT(I, R, C);
              }
              return b;
            }
            function IT(t) {
              return t === "minusPercentStack" ? {
                limit: {
                  min: -100,
                  max: 0
                },
                stepSize: 25,
                stepCount: 5
              } : t === "dualPercentStack" ? {
                limit: {
                  min: -100,
                  max: 100
                },
                stepSize: 25,
                stepCount: 9
              } : t === "divergingPercentStack" ? {
                limit: {
                  min: -100,
                  max: 100
                },
                stepSize: 25,
                stepCount: 9
              } : {
                limit: {
                  min: 0,
                  max: 100
                },
                stepSize: 25,
                stepCount: 5
              };
            }
            function _T(t, n, a) {
              var o = Kp(n, _r.X), u = a.map(function(ke) {
                return Number(o ? new Date(ke) : ke);
              }), h = t.limit, v = t.stepSize, g = Math.min.apply(Math, Tb(u)), b = Math.max.apply(Math, Tb(u)), C = ST({}, h), R = b - g, I = 0, W = 1;
              R && (h.min < g && (C.min += v, I = (C.min - g) / R, W -= I), h.max > b && (C.max -= v, W -= (b - C.max) / R));
              var Z = Math.abs(C.max - C.min), ue = Ab(Z, v);
              return {
                limit: C,
                stepCount: ue,
                stepSize: v,
                positionRatio: I,
                sizeRatio: W
              };
            }
            function Rb(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function Tf(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? Rb(Object(a), !0).forEach(function(o) {
                  NT(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : Rb(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function NT(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var Db = {
              year: 31536e6,
              month: 26784e5,
              week: 6048e5,
              date: 864e5,
              hour: 36e5,
              minute: 6e4,
              second: 1e3
            };
            function BT(t) {
              var n = t.dataRange, a = t.rawCategoriesSize, o = t.scaleOption, u = zT(n, a, o), h = u.minDate, v = u.divisionNumber, g = u.limit, b = dc(Tf(Tf({}, He(t, "scaleOption")), {}, {
                dataRange: g,
                minStepSize: 1
              }));
              return FT(b, h, v);
            }
            var Cv = ["year", "month", "week", "date", "hour", "minute", "second"];
            function FT(t, n, a) {
              var o = t.limit, u = t.stepSize, h = o.min, v = o.max;
              return Tf(Tf({}, t), {}, {
                stepSize: ju(u, a),
                limit: {
                  min: ju(Hu(h, n), a),
                  max: ju(Hu(v, n), a)
                }
              });
            }
            function zT(t, n, a) {
              var o, u = HT(t, n), h = (o = a == null ? void 0 : a.stepSize) !== null && o !== void 0 ? o : Db[u], v = Mb(t, a), g = qc(Number(new Date(v.min)), h), b = qc(Number(new Date(v.max)), h);
              return {
                divisionNumber: h,
                minDate: g,
                limit: {
                  min: 0,
                  max: b - g
                }
              };
            }
            function HT(t, n) {
              var a = t.max, o = t.min, u = a - o, h = Cv.length - 1, v;
              return u ? Cv.every(function(g, b) {
                var C = Db[g], R = Math.floor(u / C), I;
                return R && (I = b < h && R < 2 && R < n ? b + 1 : b, v = Cv[I]), !oe(I);
              }) : v = "second", v;
            }
            function Pb(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function Lb(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? Pb(Object(a), !0).forEach(function(o) {
                  jT(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : Pb(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function jT(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function Zo(t) {
              return VT(t) || UT(t) || $T(t) || WT();
            }
            function WT() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function $T(t, n) {
              if (t) {
                if (typeof t == "string") return Tv(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return Tv(t, n);
              }
            }
            function UT(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function VT(t) {
              if (Array.isArray(t)) return Tv(t);
            }
            function Tv(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function Af(t) {
              return (t == null ? void 0 : t.type) === "percent";
            }
            function hc(t) {
              return !Array.isArray(t);
            }
            function GT(t) {
              return t ? Object.keys(t).some(function(n) {
                return Af(t[n].stack);
              }) : !1;
            }
            function Av(t) {
              return We(t, ["series", "stack"]) || We(t, ["series", "column", "stack"]) || We(t, ["series", "area", "stack"]);
            }
            function Ib(t) {
              for (var n = t.length, a = t.map(function(b) {
                var C = b.rawData;
                return C.length;
              }), o = Math.max.apply(Math, Zo(a)), u = [], h = 0; h < o; h += 1) {
                for (var v = [], g = 0; g < n; g += 1)
                  v.push(t[g].rawData[h]);
                u[h] = {
                  values: v,
                  sum: lt(v),
                  total: {
                    positive: lt(v.filter(function(b) {
                      return b >= 0;
                    })),
                    negative: lt(v.filter(function(b) {
                      return b < 0;
                    }))
                  }
                };
              }
              return u;
            }
            function YT(t) {
              var n = {}, a = Zo(new Set(t.map(function(o) {
                var u = o.stackGroup;
                return u;
              })));
              return a.forEach(function(o) {
                var u = t.filter(function(h) {
                  var v = h.stackGroup;
                  return o === v;
                });
                n[o] = Ib(u);
              }), n;
            }
            function _b(t) {
              if (t) {
                var n = {
                  type: "normal",
                  connector: !1
                };
                return qT(t) ? Lb(Lb({}, n), t) : n;
              }
            }
            function qT(t) {
              return ot(t);
            }
            function KT(t) {
              return t.some(function(n) {
                return n.hasOwnProperty("stackGroup");
              });
            }
            function XT(t) {
              var n = [];
              if (Array.isArray(t))
                n = [0].concat(Zo(Nb(t)));
              else
                for (var a in t)
                  Object.prototype.hasOwnProperty.call(t, a) && (n = [0].concat(Zo(n), Zo(Nb(t[a]))));
              return n;
            }
            function Nb(t) {
              var n = t.map(function(o) {
                var u = o.total;
                return u.positive;
              }), a = t.map(function(o) {
                var u = o.total;
                return u.negative;
              });
              return [].concat(Zo(a), Zo(n));
            }
            function JT(t) {
              if (!hc(t))
                return t;
              var n = [];
              return hc(t) && Object.keys(t).forEach(function(a) {
                n = [].concat(Zo(n), Zo(t[a]));
              }), n;
            }
            function ZT(t) {
              return {
                hasNegative: t.map(function(n) {
                  var a = n.total;
                  return a.negative;
                }).some(function(n) {
                  return n < 0;
                }),
                hasPositive: t.map(function(n) {
                  var a = n.total;
                  return a.positive;
                }).some(function(n) {
                  return n >= 0;
                })
              };
            }
            function QT(t, n, a) {
              var o = ZT(t), u = o.hasPositive, h = o.hasNegative;
              if (n === "percent") {
                if (a)
                  return "divergingPercentStack";
                if (h && u)
                  return "dualPercentStack";
                if (!h && u)
                  return "percentStack";
                if (h && !u)
                  return "minusPercentStack";
              }
            }
            function eA(t, n) {
              var a = {};
              return Object.keys(t).forEach(function(o) {
                var u = o, h = Av(n);
                h ? (a[u] || (a[u] = {}), a[u].stack = _b(h)) : o === "radialBar" && (a[o] = {
                  stack: !0
                });
              }), a;
            }
            var tA = {
              name: "stackSeriesData",
              state: function(n) {
                var a = n.series, o = n.options;
                return {
                  stackSeries: eA(a, o)
                };
              },
              action: {
                setStackSeriesData: function(n) {
                  var a = n.state, o = a.series, u = a.stackSeries, h = a.options, v = Av(h), g = {};
                  Object.keys(o).forEach(function(b) {
                    var C, R = o[b], I = R.data, W = R.seriesCount, Z = R.seriesGroupCount, ue = b === "radialBar";
                    v ? (u[b] || (u[b] = {}), u[b].stack = _b(v)) : ue || (u[b] = null, delete u[b]);
                    var ke = u[b] || {}, Ee = ke.stack, Le = !!((C = h.series) !== null && C !== void 0 && C.diverging);
                    if (Ee) {
                      var je, Ke = KT(I) ? YT(I) : Ib(I), ut = (je = Ee.type) !== null && je !== void 0 ? je : "normal", bt = XT(Ke);
                      g[b] = {
                        data: I,
                        seriesCount: W,
                        seriesGroupCount: Z,
                        stackData: Ke,
                        dataRangeValues: bt,
                        scaleType: QT(JT(Ke), ut, Le)
                      }, a.stackSeries[b].stackData = Ke;
                    }
                    Pt(a.stackSeries, g);
                  });
                }
              },
              observe: {
                updateStackSeriesData: function() {
                  this.dispatch("setStackSeriesData");
                }
              }
            }, Hl = tA, Ev = 1;
            function rA(t, n, a, o) {
              var u, h, v = t.dataRange, g = t.layout, b = t.series, C = t.options, R = t.categories, I = t.rawCategories, W = df(n), Z = W.labelSizeKey, ue = oe((u = C.xAxis) === null || u === void 0 ? void 0 : u.date), ke = {
                dataRange: v[o],
                offsetSize: Math.max(g.plot[Z], Ev),
                scaleOption: a[o],
                rawCategoriesSize: I.length
              }, Ee;
              return v[o] && (Ee = ue ? BT(ke) : dc(ke)), b.line && R && !((h = C.xAxis) !== null && h !== void 0 && h.pointOnColumn) && (Ee = _T(Ee, C, R)), Ee;
            }
            function nA(t, n, a, o, u) {
              var h = t.dataRange, v = t.layout, g = t.series, b = t.stackSeries, C = df(n), R = C.valueSizeKey, I;
              if (GT(b))
                Object.keys(g).forEach(function(Z) {
                  I = IT(b[Z].scaleType);
                });
              else if (u) {
                var W = {
                  dataRange: h[o],
                  offsetSize: Math.max(v.plot[R], Ev),
                  scaleOption: a[o]
                };
                I = dc(W);
              } else
                I = dc({
                  dataRange: h[o],
                  offsetSize: Math.max(v.plot[R], Ev),
                  scaleOption: a[o]
                });
              return I;
            }
            function iA(t, n, a) {
              var o = {};
              if (sy(n)) {
                var u;
                o[a] = t == null || (u = t[a]) === null || u === void 0 ? void 0 : u.scale;
              } else {
                var h, v = qa(t), g = v.yAxis, b = v.secondaryYAxis;
                o.xAxis = t == null || (h = t.xAxis) === null || h === void 0 ? void 0 : h.scale, o.yAxis = g == null ? void 0 : g.scale, b && (o.secondaryYAxis = b == null ? void 0 : b.scale);
              }
              return o;
            }
            var aA = {
              name: "scale",
              state: function() {
                return {
                  scale: {}
                };
              },
              action: {
                setScale: function(n) {
                  var a = n.state, o = n.initStoreState, u = a.series, h = a.options, v = a.categories, g = sa({
                    series: u,
                    options: h,
                    categories: v
                  }), b = ff(g, u), C = b.labelAxisName, R = b.valueAxisName, I = iA(h, u, R), W = _l(o.series), Z = {};
                  uy(h, R).forEach(function(ue) {
                    Z[ue] = nA(a, g, I, ue, W);
                  }), W && (Z[C] = rA(a, g, I, C)), a.scale = Z;
                }
              },
              observe: {
                updateScale: function() {
                  this.dispatch("setScale");
                }
              }
            }, Gi = aA;
            function Mv(t, n) {
              return t.some(function(a) {
                var o = a.id;
                return !we(o) && !we(n.id) && o === n.id;
              });
            }
            function Bb(t) {
              return lA(t) || sA(t) || zb(t) || oA();
            }
            function oA() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function sA(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function lA(t) {
              if (Array.isArray(t)) return Rv(t);
            }
            function Fb(t, n) {
              return fA(t) || cA(t, n) || zb(t, n) || uA();
            }
            function uA() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function zb(t, n) {
              if (t) {
                if (typeof t == "string") return Rv(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return Rv(t, n);
              }
            }
            function Rv(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function cA(t, n) {
              var a = t && (typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]);
              if (a != null) {
                var o = [], u = !0, h = !1, v, g;
                try {
                  for (a = a.call(t); !(u = (v = a.next()).done) && (o.push(v.value), !(n && o.length === n)); u = !0)
                    ;
                } catch (b) {
                  h = !0, g = b;
                } finally {
                  try {
                    !u && a.return != null && a.return();
                  } finally {
                    if (h) throw g;
                  }
                }
                return o;
              }
            }
            function fA(t) {
              if (Array.isArray(t)) return t;
            }
            function dA(t) {
              var n = t.reduce(function(a, o) {
                var u = o.range, h = Fb(a, 2), v = h[0], g = h[1], b = u, C = Fb(b, 2), R = C[0], I = C[1];
                return [Math.min(v, R), Math.max(g, I)];
              }, [Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]);
              return {
                range: n,
                color: t[0].color
              };
            }
            function hA(t, n) {
              return n.findIndex(function(a) {
                return a === String(t);
              });
            }
            function Hb(t, n) {
              var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
              return a ? Number(new Date(t)) : Ie(t) ? hA(t, n) : t;
            }
            function pA(t, n) {
              var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
              return a.map(function(o) {
                var u = o.value, h = o.color, v = o.opacity;
                return {
                  value: Hb(u, t, n),
                  color: ei(h, v)
                };
              });
            }
            function vA(t, n) {
              var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
              return a.flatMap(function(o) {
                var u = o.range, h = o.mergeOverlappingRanges, v = h === void 0 ? !1 : h, g = o.color, b = o.opacity, C = ei(g, b), R = ko(u[0]) ? u : [u], I = R.map(function(W) {
                  return {
                    range: W.map(function(Z) {
                      return Hb(Z, t, n);
                    }),
                    color: C
                  };
                });
                return v ? dA(I) : I;
              });
            }
            var mA = {
              name: "plot",
              state: function(n) {
                var a, o, u = n.options;
                return {
                  plot: {
                    visible: (a = u == null || (o = u.plot) === null || o === void 0 ? void 0 : o.visible) !== null && a !== void 0 ? a : !0,
                    lines: [],
                    bands: []
                  }
                };
              },
              action: {
                setPlot: function(n) {
                  var a, o, u, h, v = n.state, g = v.series, b = v.options;
                  if (g.area || g.line) {
                    var C = v.rawCategories, R = b, I = pA(C, !!(b != null && (a = b.xAxis) !== null && a !== void 0 && a.date), R == null || (o = R.plot) === null || o === void 0 ? void 0 : o.lines), W = vA(C, !!(b != null && (u = b.xAxis) !== null && u !== void 0 && u.date), R == null || (h = R.plot) === null || h === void 0 ? void 0 : h.bands);
                    Pt(v.plot, {
                      lines: I,
                      bands: W
                    });
                  }
                },
                addPlotLine: function(n, a) {
                  var o, u, h, v = n.state, g = a.data, b = (o = (u = v.options) === null || u === void 0 || (h = u.plot) === null || h === void 0 ? void 0 : h.lines) !== null && o !== void 0 ? o : [];
                  Mv(b, g) || this.dispatch("updateOptions", {
                    options: {
                      plot: {
                        lines: [].concat(Bb(b), [g])
                      }
                    }
                  });
                },
                addPlotBand: function(n, a) {
                  var o, u, h, v = n.state, g = a.data, b = (o = (u = v.options) === null || u === void 0 || (h = u.plot) === null || h === void 0 ? void 0 : h.bands) !== null && o !== void 0 ? o : [];
                  Mv(b, g) || this.dispatch("updateOptions", {
                    options: {
                      plot: {
                        bands: [].concat(Bb(b), [g])
                      }
                    }
                  });
                },
                removePlotLine: function(n, a) {
                  var o, u, h, v = n.state, g = a.id, b = ((o = (u = v.options) === null || u === void 0 || (h = u.plot) === null || h === void 0 ? void 0 : h.lines) !== null && o !== void 0 ? o : []).filter(function(C) {
                    var R = C.id;
                    return R !== g;
                  });
                  this.dispatch("updateOptions", {
                    options: {
                      plot: {
                        lines: b
                      }
                    }
                  });
                },
                removePlotBand: function(n, a) {
                  var o, u, h, v = n.state, g = a.id, b = ((o = (u = v.options) === null || u === void 0 || (h = u.plot) === null || h === void 0 ? void 0 : h.bands) !== null && o !== void 0 ? o : []).filter(function(C) {
                    var R = C.id;
                    return R !== g;
                  });
                  this.dispatch("updateOptions", {
                    options: {
                      plot: {
                        bands: b
                      }
                    }
                  });
                }
              },
              observe: {
                updatePlot: function() {
                  this.dispatch("setPlot");
                }
              }
            }, Za = mA;
            function gA(t) {
              return t.hasOwnProperty("r");
            }
            function yA(t) {
              var n = "";
              return ko(t) ? n = "".concat(t[0], " ~ ").concat(t[1]) : ot(t) && !Array.isArray(t) ? n = "(".concat(t.x, ", ").concat(t.y, ")") + (gA(t) ? ", r: ".concat(t.r) : "") : n = String(t), n;
            }
            function bA(t, n) {
              return xA(t) || wA(t, n) || Wb(t, n) || SA();
            }
            function SA() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function wA(t, n) {
              var a = t && (typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]);
              if (a != null) {
                var o = [], u = !0, h = !1, v, g;
                try {
                  for (a = a.call(t); !(u = (v = a.next()).done) && (o.push(v.value), !(n && o.length === n)); u = !0)
                    ;
                } catch (b) {
                  h = !0, g = b;
                } finally {
                  try {
                    !u && a.return != null && a.return();
                  } finally {
                    if (h) throw g;
                  }
                }
                return o;
              }
            }
            function xA(t) {
              if (Array.isArray(t)) return t;
            }
            function jb(t) {
              return CA(t) || OA(t) || Wb(t) || kA();
            }
            function kA() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function Wb(t, n) {
              if (t) {
                if (typeof t == "string") return Dv(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return Dv(t, n);
              }
            }
            function OA(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function CA(t) {
              if (Array.isArray(t)) return Dv(t);
            }
            function Dv(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function pc(t, n) {
              return `<span class="toastui-chart-series-name">
    <i class="toastui-chart-icon" style="background: `.concat(n, `"></i>
    <span class="toastui-chart-name">`).concat(t, `</span>
  </span>`);
            }
            function $b(t, n) {
              return `<div class="toastui-chart-tooltip-series">
    <span class="toastui-chart-series-name">`.concat(t, `</span>
    <span class="toastui-chart-series-value">`).concat(n, `</span>
  </div>`);
            }
            function TA(t, n) {
              return `<div class="toastui-chart-tooltip-series">
    <i class="toastui-chart-icon" style="background: `.concat(t, `"></i>
    <span class="toastui-chart-series-value">`).concat(n, `</span>
  </div>`);
            }
            function AA(t, n) {
              return t.filter(function(a) {
                var o = a.title;
                return o === n;
              }).sort(function(a, o) {
                return ko(a.value) && ko(o.value) ? a.value[0] - o.value[0] : Me(a.value) && Me(o.value) ? a.value - o.value : 0;
              }).map(function(a) {
                var o = a.formattedValue, u = a.color;
                return TA(u, o);
              }).join("");
            }
            function EA(t, n, a) {
              var o = n.header, u = n.body, h = a.borderColor, v = a.borderWidth, g = a.background, b = a.borderRadius, C = a.borderStyle, R = "border: ".concat(v, "px ").concat(C, " ").concat(h, ";border-radius: ").concat(b, "px;background: ").concat(g, ";");
              return '<div class="toastui-chart-tooltip" style="'.concat(R, '">').concat(o).concat(u, "</div>");
            }
            function MA(t, n) {
              var a = t.category;
              return a ? '<div class="toastui-chart-tooltip-category" style="'.concat(En(n.header), `">
        `).concat(a, `
      </div>`) : "";
            }
            function RA(t, n) {
              var a = t.data;
              return `
    <div class="toastui-chart-tooltip-series-wrapper" style="`.concat(En(n.body), `">
      `).concat(a.map(function(o) {
                var u = o.label, h = o.color, v = o.formattedValue;
                return `<div class="toastui-chart-tooltip-series">
                `.concat(pc(u, h), `
                <span class="toastui-chart-series-value">`).concat(v, `</span>
              </div>`);
              }).join(""), `
    </div>`);
            }
            function DA(t, n) {
              var a = t.data, o = a.reduce(function(u, h, v) {
                return v ? (u.category === h.category && u.label === h.label && (u.value = [].concat(jb(u.value), jb(h.value))), u) : h;
              }, {});
              return `
    <div class="toastui-chart-tooltip-series-wrapper" style="`.concat(En(n.body), `">
      `).concat([o].map(function(u) {
                var h = u.label, v = u.color, g = u.value;
                return `<div class="toastui-chart-tooltip-series">
              `.concat(pc(h, v), `
            </div>
            <div>
          `).concat(g.map(function(b) {
                  var C = b.title, R = b.formattedValue;
                  return $b(C, R);
                }).join(""), `
            </div>`);
              }).join(""), `
    </div>`);
            }
            function PA(t, n) {
              var a = t.data;
              return a.length > 1 ? IA(a, n) : LA(a, n);
            }
            function LA(t, n) {
              return `
    <div class="toastui-chart-tooltip-series-wrapper" style="`.concat(En(n.body), `">
      `).concat(t.map(function(a) {
                var o = a.label, u = a.color, h = a.value;
                return '<div class="toastui-chart-tooltip-series">'.concat(pc(o, u), `</div>
            `).concat(h.map(function(v) {
                  var g = v.title, b = v.formattedValue;
                  return $b(g, b);
                }).join(""));
              }).join(""), `
    </div>`);
            }
            function IA(t, n) {
              var a = t.map(function(b) {
                var C = b.value;
                return C[0];
              }), o = ["Actual", "Range", "Marker"].map(function(b) {
                return AA(a, b);
              }), u = bA(o, 3), h = u[0], v = u[1], g = u[2];
              return '<div class="toastui-chart-tooltip-category" style="'.concat(En(n.header), `">
      `).concat(t[0].label, `
    </div>
    <div class="toastui-chart-tooltip-series-wrapper" style="`).concat(En(n.body), `">
      `).concat(h ? '<div class="toastui-chart-tooltip-title">Actual</div>' : "", " ").concat(h, `
      `).concat(v ? '<div class="toastui-chart-tooltip-title">Ranges</div>' : "", " ").concat(v, `
      `).concat(g ? '<div class="toastui-chart-tooltip-title">Markers</div>' : "", " ").concat(g, `
    </div>`);
            }
            function _A(t, n) {
              var a = t.data;
              return `
    <div class="toastui-chart-tooltip-series-wrapper" style="`.concat(En(n.body), `">
      `).concat(a.map(function(o) {
                var u = o.label, h = o.color, v = o.formattedValue, g = o.percentValue;
                return `<div class="toastui-chart-tooltip-series">
          `.concat(pc(u, h), `
          <span class="toastui-chart-series-value">`).concat(Ht(g), "&nbsp;&nbsp;(").concat(v, `)</span>
        </div>`);
              }).join(""), `
    </div>`);
            }
            function NA(t, n) {
              var a = t.data;
              return "".concat(a.map(function(o) {
                var u = o.label, h = o.color, v = o.formattedValue;
                return '<div class="toastui-chart-tooltip-category" style="'.concat(En(n.header), `">
          `).concat(u, `
        </div>
        <div class="toastui-chart-tooltip-series-wrapper" style="`).concat(En(n.body), `">
          <div class="toastui-chart-tooltip-series">
            `).concat(pc(v, h), `
          </div>
        </div>`);
              }).join(""));
            }
            var Pv = {
              default: EA,
              defaultHeader: MA,
              defaultBody: RA,
              boxPlot: DA,
              bullet: PA,
              pie: _A,
              heatmap: NA
            };
            function BA(t) {
              return Pv[t || "defaultBody"];
            }
            l(7368);
            function Ub(t, n) {
              return t.querySelectorAll(n);
            }
            function FA(t) {
              t.parentNode && t.parentNode.removeChild(t);
            }
            var zA = new RegExp("^(abbr|align|alt|axis|bgcolor|border|cellpadding|cellspacing|class|clear|color|cols|compact|coords|dir|face|headers|height|hreflang|hspace|ismap|lang|language|nohref|nowrap|rel|rev|rows|rules|scope|scrolling|shape|size|span|start|summary|tabindex|target|title|type|valign|value|vspace|width|checked|mathvariant|encoding|id|name|background|cite|href|longdesc|src|usemap|xlink:href|data-+|checked|style)", "g"), HA = new RegExp("^(accent-height|accumulate|additive|alphabetic|arabic-form|ascent|baseProfile|bbox|begin|by|calcMode|cap-height|class|color|color-rendering|content|cx|cy|d|dx|dy|descent|display|dur|end|fill|fill-rule|font-family|font-size|font-stretch|font-style|font-variant|font-weight|from|fx|fy|g1|g2|glyph-name|gradientUnits|hanging|height|horiz-adv-x|horiz-origin-x|ideographic|k|keyPoints|keySplines|keyTimes|lang|marker-end|marker-mid|marker-start|markerHeight|markerUnits|markerWidth|mathematical|max|min|offset|opacity|orient|origin|overline-position|overline-thickness|panose-1|path|pathLength|points|preserveAspectRatio|r|refX|refY|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|rotate|rx|ry|slope|stemh|stemv|stop-color|stop-opacity|strikethrough-position|strikethrough-thickness|stroke|stroke-dasharray|stroke-dashoffset|stroke-linecap|stroke-linejoin|stroke-miterlimit|stroke-opacity|stroke-width|systemLanguage|target|text-anchor|to|transform|type|u1|u2|underline-position|underline-thickness|unicode|unicode-range|units-per-em|values|version|viewBox|visibility|width|widths|x|x-height|x1|x2|xlink:actuate|xlink:arcrole|xlink:role|xlink:show|xlink:title|xlink:type|xml:base|xml:lang|xml:space|xmlns|xmlns:xlink|y|y1|y2|zoomAndPan)", "g"), jA = ["script", "iframe", "textarea", "form", "button", "select", "input", "meta", "style", "link", "title", "embed", "object"], WA = /href|src|background/gi, $A = /((java|vb|live)script|x):/gi, UA = /^on\S+/;
            function VA(t) {
              var n = document.createElement("div");
              return Ie(t) ? (t = t.replace(/<!--[\s\S]*?-->/g, ""), n.innerHTML = t) : n.appendChild(t), GA(n), KA(n), n.innerHTML;
            }
            function GA(t) {
              var n = Ub(t, jA.join(","));
              n.forEach(function(a) {
                FA(a);
              });
            }
            function YA(t, n) {
              return t.match(WA) && n.match($A);
            }
            function qA(t, n) {
              n.forEach(function(a) {
                var o = a.name;
                UA.test(o) && (t[o] = null), t.getAttribute(o) && t.removeAttribute(o);
              });
            }
            function KA(t) {
              Ub(t, "*").forEach(function(n) {
                var a = n.attributes, o = St(a).filter(function(u) {
                  var h = u.name, v = u.value, g = h.match(zA), b = h.match(HA), C = g && YA(h, v);
                  return !g && !b || C;
                });
                qA(n, o);
              });
            }
            function Ef(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Ef = function(a) {
                return typeof a;
              } : Ef = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Ef(t);
            }
            function Vb(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function Mf(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? Vb(Object(a), !0).forEach(function(o) {
                  To(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : Vb(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function XA(t) {
              return eE(t) || QA(t) || ZA(t) || JA();
            }
            function JA() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function ZA(t, n) {
              if (t) {
                if (typeof t == "string") return Lv(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return Lv(t, n);
              }
            }
            function QA(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function eE(t) {
              if (Array.isArray(t)) return Lv(t);
            }
            function Lv(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function tE(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function rE(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function nE(t, n, a) {
              return n && rE(t.prototype, n), t;
            }
            function iE(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Iv(t, n);
            }
            function Iv(t, n) {
              return Iv = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Iv(t, n);
            }
            function aE(t) {
              var n = sE();
              return function() {
                var o = Rf(t), u;
                if (n) {
                  var h = Rf(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return oE(this, u);
              };
            }
            function oE(t, n) {
              return n && (Ef(n) === "object" || typeof n == "function") ? n : Co(t);
            }
            function Co(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function sE() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function Rf(t) {
              return Rf = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, Rf(t);
            }
            function To(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var lE = "transform 0.2s ease", $n = /* @__PURE__ */ function(t) {
              iE(a, t);
              var n = aE(a);
              function a() {
                var o;
                tE(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), To(Co(o), "chartEl", void 0), To(Co(o), "tooltipContainerEl", void 0), To(Co(o), "templateFunc", void 0), To(Co(o), "theme", void 0), To(Co(o), "offsetX", void 0), To(Co(o), "offsetY", void 0), To(Co(o), "formatter", void 0), To(Co(o), "tooltipInfoModels", {}), To(Co(o), "onSeriesPointHovered", function(g) {
                  var b = g.models, C = g.name;
                  o.tooltipInfoModels[C] = b != null && b.length ? XA(b) : [];
                  var R = !!o.getTooltipInfoModels().length;
                  R ? o.renderTooltip() : o.removeTooltip();
                }), o;
              }
              return nE(a, [{
                key: "isTooltipContainerOverflow",
                value: function(u, h) {
                  var v = this.tooltipContainerEl.getBoundingClientRect(), g = v.width, b = v.height, C = this.rect, R = C.x, I = C.y, W = C.width, Z = C.height;
                  return {
                    overflowX: u > R + W || u + g > R + W,
                    overflowY: h > I + Z || h + b > I + Z
                  };
                }
              }, {
                key: "getPositionInRect",
                value: function(u) {
                  var h = u.target, v = this.rect.x + u.x, g = this.rect.y + u.y, b = v + h.radius + h.width + this.offsetX, C = g + this.offsetY, R = this.isTooltipContainerOverflow(b, C), I = R.overflowX, W = R.overflowY, Z = this.tooltipContainerEl.getBoundingClientRect(), ue = Z.width, ke = Z.height;
                  return I && (b = v - (ue + h.radius + this.offsetX) > 0 ? v - (ue + h.radius + this.offsetX) : v + this.offsetX), W && (C = g + h.height - (ke + this.offsetY) > 0 ? g + h.height - (ke + this.offsetY) : C), {
                    x: b,
                    y: C
                  };
                }
              }, {
                key: "setTooltipPosition",
                value: function(u) {
                  var h = this.getPositionInRect(u), v = h.x, g = h.y;
                  this.tooltipContainerEl.style.transform = Bo(v, g);
                }
              }, {
                key: "getTooltipInfoModels",
                value: function() {
                  return Object.values(this.tooltipInfoModels).flatMap(function(u) {
                    return u;
                  });
                }
              }, {
                key: "renderTooltip",
                value: function() {
                  var u = this, h = this.getTooltipInfoModels().reduce(function(v, g) {
                    var b = g.data, C = g.x, R = g.y, I = g.radius, W = g.width, Z = g.height;
                    return v.x = v.x ? (v.x + C) / 2 : C, v.y = v.y ? (v.y + R) / 2 : R, Me(I) && (v.target.radius = I), W && (v.target.width = W), Z && (v.target.height = Z), v.data.push(Mf(Mf({}, b), {}, {
                      value: Array.isArray(b.value) ? b.value.map(function(ue) {
                        return Mf(Mf({}, ue), {}, {
                          formattedValue: u.getFormattedValue(ue.value, b)
                        });
                      }) : b.value,
                      formattedValue: u.getFormattedValue(b.value, b)
                    })), !v.category && b.category && (v.category = b.category), b.templateType && (v.templateType = b.templateType), v;
                  }, {
                    type: "tooltip",
                    x: 0,
                    y: 0,
                    data: [],
                    target: {
                      radius: 0,
                      width: 0,
                      height: 0
                    }
                  });
                  this.tooltipContainerEl.innerHTML = VA(this.templateFunc(h, {
                    header: Pv.defaultHeader(h, this.theme),
                    body: BA(h.templateType)(h, this.theme)
                  }, this.theme)), this.setTooltipPosition(h);
                }
              }, {
                key: "initialize",
                value: function(u) {
                  var h = u.chartEl;
                  this.type = "tooltip", this.name = "tooltip", this.chartEl = h, this.tooltipContainerEl = document.createElement("div"), this.tooltipContainerEl.classList.add("toastui-chart-tooltip-container");
                  var v = this.chartEl.getBoundingClientRect(), g = v.width, b = v.height, C = v.top, R = v.left;
                  this.tooltipContainerEl.style.transform = Bo(R + g / 2, C + b / 2), this.chartEl.appendChild(this.tooltipContainerEl), this.eventBus.on("seriesPointHovered", this.onSeriesPointHovered);
                }
              }, {
                key: "removeTooltip",
                value: function() {
                  this.tooltipContainerEl.innerHTML = "";
                }
              }, {
                key: "setTooltipTransition",
                value: function(u) {
                  var h, v = (h = u.tooltip) === null || h === void 0 ? void 0 : h.transition;
                  Qe(v) && v ? this.tooltipContainerEl.style.transition = lE : Ie(v) && (this.tooltipContainerEl.style.transition = v);
                }
              }, {
                key: "render",
                value: function(u) {
                  var h, v, g, b, C, R, I, W = u.layout, Z = u.options, ue = u.theme;
                  this.setTooltipTransition(Z), this.rect = W.plot, this.theme = ue.tooltip, this.templateFunc = (h = Z == null || (v = Z.tooltip) === null || v === void 0 ? void 0 : v.template) !== null && h !== void 0 ? h : Pv.default, this.offsetX = (g = Z == null || (b = Z.tooltip) === null || b === void 0 ? void 0 : b.offsetX) !== null && g !== void 0 ? g : 10, this.offsetY = (C = Z == null || (R = Z.tooltip) === null || R === void 0 ? void 0 : R.offsetY) !== null && C !== void 0 ? C : 0, this.formatter = Z == null || (I = Z.tooltip) === null || I === void 0 ? void 0 : I.formatter;
                }
              }, {
                key: "getFormattedValue",
                value: function(u, h) {
                  return this.formatter ? this.formatter(u, h) : yA(u);
                }
              }]), a;
            }(Lr);
            function Df(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Df = function(a) {
                return typeof a;
              } : Df = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Df(t);
            }
            function Gb(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function Yb(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? Gb(Object(a), !0).forEach(function(o) {
                  If(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : Gb(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function Qo(t) {
              return fE(t) || cE(t) || qb(t) || uE();
            }
            function uE() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function cE(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function fE(t) {
              if (Array.isArray(t)) return _v(t);
            }
            function dE(t, n) {
              return vE(t) || pE(t, n) || qb(t, n) || hE();
            }
            function hE() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function qb(t, n) {
              if (t) {
                if (typeof t == "string") return _v(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return _v(t, n);
              }
            }
            function _v(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function pE(t, n) {
              var a = t && (typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]);
              if (a != null) {
                var o = [], u = !0, h = !1, v, g;
                try {
                  for (a = a.call(t); !(u = (v = a.next()).done) && (o.push(v.value), !(n && o.length === n)); u = !0)
                    ;
                } catch (b) {
                  h = !0, g = b;
                } finally {
                  try {
                    !u && a.return != null && a.return();
                  } finally {
                    if (h) throw g;
                  }
                }
                return o;
              }
            }
            function vE(t) {
              if (Array.isArray(t)) return t;
            }
            function mE(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function gE(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function yE(t, n, a) {
              return n && gE(t.prototype, n), t;
            }
            function bE(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Nv(t, n);
            }
            function Nv(t, n) {
              return Nv = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Nv(t, n);
            }
            function SE(t) {
              var n = xE();
              return function() {
                var o = Lf(t), u;
                if (n) {
                  var h = Lf(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return wE(this, u);
              };
            }
            function wE(t, n) {
              return n && (Df(n) === "object" || typeof n == "function") ? n : Pf(t);
            }
            function Pf(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function xE() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function Lf(t) {
              return Lf = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, Lf(t);
            }
            function If(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function kE(t) {
              var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
              return ~~t ? t - n : t;
            }
            function Kb(t) {
              var n = t.axisData, a = t.offsetSize, o = t.value, u = t.startIndex, h = u === void 0 ? 0 : u, v = kE(o, h), g = Vu(n, a, o, v);
              return g > 0 ? Math.min(a, g) : 0;
            }
            function _f(t, n) {
              return t ? n.xAxis : n.yAxis;
            }
            var Qa = /* @__PURE__ */ function(t) {
              bE(a, t);
              var n = SE(a);
              function a() {
                var o;
                mE(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), If(Pf(o), "models", {
                  plot: [],
                  line: [],
                  band: []
                }), If(Pf(o), "startIndex", 0), If(Pf(o), "theme", void 0), o;
              }
              return yE(a, [{
                key: "initialize",
                value: function() {
                  this.type = "plot";
                }
              }, {
                key: "getPlotAxisSize",
                value: function(u) {
                  return {
                    offsetSize: u ? this.rect.width : this.rect.height,
                    anchorSize: u ? this.rect.height : this.rect.width
                  };
                }
              }, {
                key: "renderLines",
                value: function(u, h) {
                  var v = this, g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
                  return g.map(function(b) {
                    var C = b.value, R = b.color, I = v.getPlotAxisSize(!0), W = I.offsetSize, Z = Kb({
                      axisData: _f(!0, u),
                      offsetSize: W,
                      value: C,
                      startIndex: v.startIndex
                    });
                    return v.makeLineModel(!0, Z, {
                      color: R
                    });
                  });
                }
              }, {
                key: "renderBands",
                value: function(u, h) {
                  var v = this, g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], b = this.getPlotAxisSize(!0), C = b.offsetSize, R = b.anchorSize;
                  return g.map(function(I) {
                    var W = I.range, Z = I.color, ue = W.map(function(je) {
                      return Kb({
                        axisData: _f(!0, u),
                        offsetSize: C,
                        value: je,
                        startIndex: v.startIndex
                      });
                    }), ke = dE(ue, 2), Ee = ke[0], Le = ke[1];
                    return {
                      type: "rect",
                      x: Cr(Ee),
                      y: Cr(0),
                      width: Le - Ee,
                      height: R,
                      color: Z
                    };
                  });
                }
              }, {
                key: "renderPlotLineModels",
                value: function(u, h) {
                  var v, g = this, b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, C = b.size, R = b.startPosition, I = b.axes, W = this.theme[h ? "vertical" : "horizontal"], Z = W.lineColor, ue = W.lineWidth, ke = W.dashSegments, Ee = ((v = h ? I == null ? void 0 : I.xAxis : I == null ? void 0 : I.yAxis) === null || v === void 0 ? void 0 : v.tickInterval) || 1;
                  return u.filter(function(Le, je) {
                    return !(je % Ee);
                  }).map(function(Le) {
                    return g.makeLineModel(h, Le, {
                      color: Z,
                      lineWidth: ue,
                      dashSegments: ke
                    }, C ?? g.rect.width, R ?? 0);
                  });
                }
              }, {
                key: "renderPlotsForCenterYAxis",
                value: function(u) {
                  var h = u.centerYAxis, v = h.xAxisHalfSize, g = h.secondStartX, b = h.yAxisHeight, C = u.xAxis.tickCount, R = [].concat(Qo(this.renderPlotLineModels(Fi(v, C), !0)), Qo(this.renderPlotLineModels(Fi(v, C, g), !0))), I = u.yAxis.tickCount, W = Fi(b, I), Z = [].concat(Qo(this.renderPlotLineModels(W, !1, {
                    size: v
                  })), Qo(this.renderPlotLineModels(W, !1, {
                    size: v,
                    startPosition: g
                  })));
                  return [].concat(Qo(R), Qo(Z));
                }
              }, {
                key: "renderPlots",
                value: function(u, h) {
                  var v = !0;
                  return u.centerYAxis ? this.renderPlotsForCenterYAxis(u) : [].concat(Qo(this.renderPlotLineModels(this.getHorizontalTickPixelPositions(u), !1, {
                    axes: u
                  })), Qo(this.renderPlotLineModels(this.getVerticalTickPixelPositions(u, h), v, {
                    axes: u
                  })));
                }
              }, {
                key: "getVerticalTickPixelPositions",
                value: function(u, h) {
                  var v = this.getPlotAxisSize(!0), g = v.offsetSize, b = _f(!0, u);
                  if (b != null && b.labelRange) {
                    var C, R, I, W, Z = (C = h == null || (R = h.xAxis) === null || R === void 0 ? void 0 : R.sizeRatio) !== null && C !== void 0 ? C : 1, ue = (I = h == null || (W = h.xAxis) === null || W === void 0 ? void 0 : W.positionRatio) !== null && I !== void 0 ? I : 0, ke = g * Z, Ee = g * ue;
                    return Fi(ke, b.tickCount, Ee);
                  }
                  return Fi(g, b.tickCount);
                }
              }, {
                key: "getHorizontalTickPixelPositions",
                value: function(u) {
                  var h = this.getPlotAxisSize(!1), v = h.offsetSize, g = _f(!1, u);
                  return Fi(v, g.tickCount);
                }
              }, {
                key: "renderPlotBackgroundRect",
                value: function() {
                  return Yb(Yb({
                    type: "rect",
                    x: 0,
                    y: 0
                  }, Ue(this.rect, "width", "height")), {}, {
                    color: this.theme.backgroundColor
                  });
                }
              }, {
                key: "render",
                value: function(u) {
                  var h, v, g = u.layout, b = u.axes, C = u.plot, R = u.zoomRange, I = u.theme, W = u.scale;
                  if (C) {
                    this.rect = g.plot, this.startIndex = (h = R == null ? void 0 : R[0]) !== null && h !== void 0 ? h : 0, this.theme = I.plot;
                    var Z = (v = u.categories) !== null && v !== void 0 ? v : [], ue = C.lines, ke = C.bands, Ee = C.visible;
                    this.models.line = this.renderLines(b, Z, ue), this.models.band = this.renderBands(b, Z, ke), Ee && (this.models.plot = [this.renderPlotBackgroundRect()].concat(Qo(this.renderPlots(b, W))));
                  }
                }
              }, {
                key: "makeLineModel",
                value: function(u, h, v, g) {
                  var b = v.color, C = v.dashSegments, R = C === void 0 ? [] : C, I = v.lineWidth, W = I === void 0 ? 1 : I, Z = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, ue = Cr(u ? h : Z), ke = Cr(u ? 0 : h), Ee = u ? 0 : g ?? this.rect.width, Le = u ? this.rect.height : 0;
                  return {
                    type: "line",
                    x: ue,
                    y: ke,
                    x2: ue + Ee,
                    y2: ke + Le,
                    strokeStyle: b,
                    lineWidth: W,
                    dashSegments: R
                  };
                }
              }, {
                key: "beforeDraw",
                value: function(u) {
                  u.ctx.strokeStyle = "rgba(0, 0, 0, 0.05)", u.ctx.lineWidth = 1;
                }
              }]), a;
            }(Lr);
            function Xb(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function Jb(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? Xb(Object(a), !0).forEach(function(o) {
                  OE(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : Xb(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function OE(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function CE(t) {
              return ME(t) || EE(t) || AE(t) || TE();
            }
            function TE() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function AE(t, n) {
              if (t) {
                if (typeof t == "string") return Bv(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return Bv(t, n);
              }
            }
            function EE(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function ME(t) {
              if (Array.isArray(t)) return Bv(t);
            }
            function Bv(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function Zb(t) {
              var n = t.models, a = t.comparisonModel, o = t.name, u = t.eventDetectType;
              switch (o) {
                case "heatmap":
                  return Fv(n, a);
                case "bullet":
                  return u === "grouped" ? r0(n, a) : Fv(n, a);
                case "radar":
                case "bubble":
                case "scatter":
                case "area":
                case "line":
                  return RE(n, a);
                case "pie":
                  return zv(n, a);
                case "column":
                case "bar":
                  return u === "grouped" ? r0(n, a) : zv(n, a);
                case "boxPlot":
                  return u === "grouped" ? zv(n, a) : PE(n, a);
                case "treemap":
                  return DE(n, a);
                case "gauge":
                  return Fv(n, a);
                default:
                  return !1;
              }
            }
            function jl(t, n, a) {
              var o = 1 / 0, u = [];
              return t.forEach(function(h) {
                var v = h.x, g = h.y, b = h.radius, C = {
                  x: v + a.x,
                  y: g + a.y
                }, R = Uu(C, n);
                o > R ? (o = R, u = [h]) : o === R && (u.length && u[0].radius > b ? u = [h] : u.push(h));
              }), u;
            }
            function Nf(t, n, a) {
              var o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0, u = n.pointOnColumn, h = n.tickDistance, v = n.rectResponderCount, g = t.width, b = t.height, C = u ? [] : [0, v - 1], R = h / 2;
              return Mt(0, v).map(function(I) {
                var W = C.includes(I), Z = W ? R : h, ue = 0;
                return I !== 0 && (ue += u ? h * I : R + h * (I - 1)), {
                  type: "rect",
                  y: o ? 0 : ue,
                  height: o ? b : Z,
                  x: o ? ue : 0,
                  width: o ? Z : g,
                  index: I,
                  label: a[I]
                };
              });
            }
            function Qb(t, n) {
              var a = n.width, o = n.height, u = 0;
              return t.sort(function(h, v) {
                return h.x - v.x;
              }).reduce(function(h, v, g) {
                var b = v.x, C = v.label, R = t[g + 1], I = R ? (R.x + b) / 2 : a, W = {
                  type: "rect",
                  x: u,
                  y: 0,
                  width: I - u,
                  height: o,
                  label: C,
                  index: g
                };
                return u = I, [].concat(CE(h), [W]);
              }, []);
            }
            function e0(t, n) {
              var a = n.reduce(function(o, u) {
                var h = u.index, v = u.seriesIndex;
                return o[v] || (o[v] = []), o[v][h] = u, o;
              }, []);
              return t.reduce(function(o, u) {
                var h = u.seriesIndex, v = u.index, g = a[h][v], b = g.category;
                return b && (o[b] || (o[b] = []), o[b].push(Jb(Jb({}, u), {}, {
                  data: g
                }))), o;
              }, {});
            }
            function t0(t) {
              return t.reduce(function(n, a) {
                return !n.length || a.depth > n[0].depth ? [a] : n;
              }, []);
            }
            function Fv(t, n) {
              return t.length && (n == null ? void 0 : n.length) && t[0].name === n[0].name;
            }
            function RE(t, n) {
              var a = !1;
              return t.length && n !== null && n !== void 0 && n.length && t.length === n.length && (a = t.reduce(function(o, u, h) {
                return o && u.seriesIndex === n[h].seriesIndex && u.index === n[h].index;
              }, !0)), a;
            }
            function zv(t, n) {
              var a = !1;
              return t.length && n !== null && n !== void 0 && n.length && t.length === n.length && (a = t.reduce(function(o, u, h) {
                var v, g, b, C;
                return o && ((v = u.data) === null || v === void 0 ? void 0 : v.label) === ((g = n[h].data) === null || g === void 0 ? void 0 : g.label) && ((b = u.data) === null || b === void 0 ? void 0 : b.category) === ((C = n[h].data) === null || C === void 0 ? void 0 : C.category);
              }, !0)), a;
            }
            function DE(t, n) {
              return t.length && (n == null ? void 0 : n.length) && t[0].label === n[0].label;
            }
            function r0(t, n) {
              return t.length && (n == null ? void 0 : n.length) && t[0].index === n[0].index;
            }
            function PE(t, n) {
              var a = !1;
              if (t.length && n !== null && n !== void 0 && n.length) {
                var o, u, h = t[0], v = h.type, g = h.data;
                a = v === n[0].type && (g == null ? void 0 : g.label) === ((o = n[0].data) === null || o === void 0 ? void 0 : o.label) && (g == null ? void 0 : g.category) === ((u = n[0].data) === null || u === void 0 ? void 0 : u.category);
              }
              return a;
            }
            function LE(t, n, a) {
              var o = n.centerX, u = n.centerY, h = n.angleRange, v = h.start, g = h.end, b = n.clockwise;
              return ws(t, 0).map(function(C, R) {
                return {
                  type: "sector",
                  x: o,
                  y: u,
                  degree: {
                    start: v,
                    end: g
                  },
                  radius: C,
                  name: a[R],
                  clockwise: b,
                  index: R
                };
              });
            }
            function n0(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function Ir(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? n0(Object(a), !0).forEach(function(o) {
                  IE(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : n0(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function IE(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var Bf = 30, _E = 20;
            function NE(t) {
              var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, a = "auto";
              switch (t) {
                case "point":
                  a = "center";
                  break;
                case "rect":
                  a = n ? "center" : "auto";
                  break;
                case "sector":
                case "treemapSeriesName":
                  a = "center";
                  break;
                case "stackTotal":
                  a = "auto";
                  break;
              }
              return a;
            }
            function BE(t, n) {
              var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
              return n !== "stackTotal" && Ve(["center", "start", "end", "auto", "outer"], t.anchor) ? t.anchor : NE(n, a);
            }
            function FE(t, n) {
              var a, o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, u = BE(t, n, o), h = t.offsetX, v = h === void 0 ? 0 : h, g = t.offsetY, b = g === void 0 ? 0 : g, C = Et(t.formatter) ? t.formatter : function(W) {
                return String(W) || "";
              }, R = {
                anchor: u,
                offsetX: v,
                offsetY: b,
                formatter: C
              };
              if (o) {
                var I = t.stackTotal;
                R.stackTotal = {
                  visible: Qe(I == null ? void 0 : I.visible) ? I.visible : !0,
                  formatter: Et(I == null ? void 0 : I.formatter) ? I.formatter : C
                };
              }
              return n === "sector" && (a = t.pieSeriesName) !== null && a !== void 0 && a.visible && (R.pieSeriesName = Ir(Ir({}, {
                anchor: "center"
              }), t.pieSeriesName)), R;
            }
            function zE(t, n, a) {
              var o = a.width, u = a.height, h = n.anchor, v = n.offsetX, g = v === void 0 ? 0 : v, b = n.offsetY, C = b === void 0 ? 0 : b, R = n.formatter, I = t.name, W = t.theme, Z = "middle";
              h === "end" ? Z = "bottom" : h === "start" && (Z = "top");
              var ue = t.x + g, ke = t.y + C, Ee = ue < 0 || ue > o ? t.x : ue, Le = ke < 0 || ke > u ? t.y : ke;
              return {
                type: "point",
                x: Ee,
                y: Le,
                text: R(t.value, t.data),
                textAlign: "center",
                textBaseline: Z,
                name: I,
                theme: W
              };
            }
            function HE(t) {
              return Ve(["left", "right"], t);
            }
            function jE(t, n) {
              var a = t.x, o = t.y, u = t.width, h = t.height, v = t.direction, g = "middle", b = o + h / 2, C = "center", R;
              if (v === "right")
                switch (n) {
                  case "start":
                    C = "left", R = a;
                    break;
                  case "end":
                    C = "right", R = a + u;
                    break;
                  case "center":
                    C = "center", R = a + u / 2;
                    break;
                  default:
                    C = "left", R = a + u;
                }
              else
                switch (n) {
                  case "start":
                    C = "right", R = a + u;
                    break;
                  case "end":
                    C = "left", R = a;
                    break;
                  case "center":
                    C = "center", R = a + u / 2;
                    break;
                  default:
                    C = "right", R = a;
                }
              return {
                x: R,
                y: b,
                textAlign: C,
                textBaseline: g
              };
            }
            function WE(t, n) {
              var a = t.x, o = t.y, u = t.width, h = t.height, v = t.direction, g = "center", b = a + u / 2, C = "middle", R = 0;
              if (v === "top")
                switch (n) {
                  case "end":
                    C = "top", R = o;
                    break;
                  case "start":
                    C = "bottom", R = o + h;
                    break;
                  case "center":
                    C = "middle", R = o + h / 2;
                    break;
                  default:
                    C = "bottom", R = o;
                }
              else
                switch (n) {
                  case "end":
                    C = "bottom", R = o + h;
                    break;
                  case "start":
                    C = "top", R = o;
                    break;
                  case "center":
                    C = "middle", R = o + h / 2;
                    break;
                  default:
                    C = "top", R = o + h;
                    break;
                }
              return {
                x: b,
                y: R,
                textAlign: g,
                textBaseline: C
              };
            }
            function $E(t, n, a) {
              var o = t.width, u = t.value, h = t.direction, v = t.plot, g = t.theme, b = n.formatter, C = Si(g), R = Ie(u) ? u : b(u), I = ni(R, C), W = a.x, Z = a.textAlign, ue = h === "left" && W - I < 0 || W + I > v.size;
              return ue && (W = t.x + o, Z = "right", h === "left" && o >= I && (W = t.x, Z = "left")), {
                x: W,
                textAlign: Z
              };
            }
            function UE(t, n, a) {
              var o = t.height, u = t.direction, h = t.plot, v = t.theme, g = t.value, b = Si(v), C = h.size, R = Vs("".concat(g), b), I = a.y, W = a.textBaseline, Z = u !== "bottom" && I - R < 0 || I + R > C;
              return Z && (I = t.y, W = "top", I + R > C && (I = t.y, W = "bottom"), u === "bottom" && (I = t.y + o, W = "bottom")), {
                y: I,
                textBaseline: W
              };
            }
            function VE(t, n) {
              var a = n.anchor, o = n.offsetX, u = o === void 0 ? 0 : o, h = n.offsetY, v = h === void 0 ? 0 : h, g = t.direction, b = t.plot, C = b.x, R = C === void 0 ? 0 : C, I = b.y, W = I === void 0 ? 0 : I, Z = jE(t, a), ue = Z.x, ke = Z.y, Ee = Z.textAlign;
              if (a === "auto") {
                var Le = $E(t, n, {
                  x: ue,
                  textAlign: Ee
                });
                ue = Le.x, Ee = Le.textAlign;
              }
              ke += v, g === "left" ? ue = ue - u : ue = ue + u;
              var je = 10;
              return Ee === "right" ? ue -= je : Ee === "left" && (ue += je), ue -= R, ke -= W, {
                x: ue,
                y: ke,
                textAlign: Ee,
                textBaseline: Z.textBaseline
              };
            }
            function GE(t, n) {
              var a = n.anchor, o = n.offsetX, u = o === void 0 ? 0 : o, h = n.offsetY, v = h === void 0 ? 0 : h, g = t.direction, b = t.plot, C = b.x, R = C === void 0 ? 0 : C, I = b.y, W = I === void 0 ? 0 : I, Z = WE(t, a), ue = Z.x, ke = Z.y, Ee = Z.textBaseline;
              if (a === "auto") {
                var Le = UE(t, n, Z);
                ke = Le.y, Ee = Le.textBaseline;
              }
              ue += u, g === "top" ? ke = ke + v : g === "bottom" && (ke = ke - v);
              var je = 5;
              return Ee === "bottom" ? ke -= je : Ee === "top" && (ke += je), ue -= R, ke -= W, {
                x: ue,
                y: ke,
                textAlign: Z.textAlign,
                textBaseline: Ee
              };
            }
            function YE(t, n) {
              var a = t.type, o = t.value, u = t.direction, h = t.name, v = t.theme, g = HE(u), b = g ? VE(t, n) : GE(t, n), C = a === "stackTotal" ? n.stackTotal.formatter : n.formatter;
              return Ir(Ir({
                type: a
              }, b), {}, {
                text: Ie(o) ? o : C(o),
                name: h,
                seriesColor: t.color,
                theme: v
              });
            }
            function qE(t, n) {
              var a = n.anchor, o = ka(xa(a, Ir(Ir({}, t), {}, {
                radius: Ir(Ir({}, t.radius), {}, {
                  outer: a === "outer" ? t.radius.outer + Bf : t.radius.outer
                })
              }))), u = Ss(t, a);
              return Ir(Ir({}, o), {}, {
                textAlign: u,
                textBaseline: i0(n) ? "bottom" : "middle"
              });
            }
            function KE(t, n) {
              var a = n.anchor, o = t.clockwise, u = t.degree, h = u.start, v = u.end, g = t.radius, b = g.inner, C = g.outer, R = h, I = v, W = "center", Z = (h + v) / 2;
              a === "start" ? (W = o ? "left" : "right", I = R, Z = h) : a === "end" && (W = o ? "right" : "left", R = I, Z = v);
              var ue = ka(xa(a, Ir(Ir({}, t), {}, {
                degree: {
                  start: R,
                  end: I
                },
                radius: {
                  inner: b,
                  outer: C
                }
              }))), ke = ue.x, Ee = ue.y;
              return {
                x: ke,
                y: Ee,
                textAlign: W,
                textBaseline: "middle",
                radian: Pr(Z, 0)
              };
            }
            function XE(t, n) {
              var a = n.formatter, o = KE(t, n), u = t.value, h = t.name, v = t.theme, g = Ir(Ir({}, v), {}, {
                color: v.useSeriesColor ? t.color : v.color
              });
              return Ir(Ir({
                type: "sector"
              }, o), {}, {
                text: a(u),
                name: h,
                theme: g
              });
            }
            function JE(t, n) {
              var a = n.formatter, o = qE(t, n), u = t.value, h = t.name, v = t.theme, g = n.anchor, b = Ir(Ir({}, v), {}, {
                color: v.useSeriesColor ? t.color : v.color
              });
              return Ir(Ir({
                type: "sector"
              }, o), {}, {
                text: a(u),
                name: h,
                callout: eM(n) ? a0(t, g) : null,
                theme: b
              });
            }
            function ZE(t, n) {
              var a, o = (a = n.pieSeriesName) === null || a === void 0 ? void 0 : a.anchor, u = o === "outer", h = ka(xa(o, Ir(Ir({}, t), {}, {
                radius: Ir(Ir({}, t.radius), {}, {
                  outer: u ? t.radius.outer + Bf : t.radius.outer
                })
              }))), v = Ss(t, o), g = t.theme.pieSeriesName, b = Ir(Ir({}, g), {}, {
                color: g.useSeriesColor ? t.color : g.color
              });
              return Ir(Ir({
                type: "pieSeriesName"
              }, h), {}, {
                text: t.name,
                callout: tM(n) ? a0(t, o) : null,
                textAlign: v,
                textBaseline: i0(n) ? "top" : "middle",
                theme: b
              });
            }
            function Ma(t, n) {
              var a, o, u;
              return (t == null || (a = t.series) === null || a === void 0 || (o = a[n]) === null || o === void 0 ? void 0 : o.dataLabels) || (t == null || (u = t.series) === null || u === void 0 ? void 0 : u.dataLabels) || {};
            }
            function QE(t, n) {
              var a = t.value, o = t.textAlign, u = t.textBaseline, h = n.formatter;
              return Ir(Ir({}, t), {}, {
                x: t.x,
                y: (t.y + t.y2) / 2,
                textAlign: o ?? "center",
                textBaseline: u ?? "middle",
                text: Ie(a) ? a : h(a)
              });
            }
            function i0(t) {
              var n;
              return t.anchor === ((n = t.pieSeriesName) === null || n === void 0 ? void 0 : n.anchor);
            }
            function eM(t) {
              var n;
              return t.anchor === "outer" || ((n = t.pieSeriesName) === null || n === void 0 ? void 0 : n.anchor) !== "outer";
            }
            function tM(t) {
              var n;
              return t.anchor !== "outer" || ((n = t.pieSeriesName) === null || n === void 0 ? void 0 : n.anchor) === "outer";
            }
            function a0(t, n) {
              if (n !== "outer")
                return null;
              var a = ka(xa("outer", Ir(Ir({}, t), {}, {
                radius: Ir(Ir({}, t.radius), {}, {
                  outer: t.radius.outer + _E
                })
              }))), o = a.x, u = a.y, h = ka(xa("outer", Ir({}, t))), v = h.x, g = h.y, b = t.theme.callout, C = Ir(Ir({}, b), {}, {
                lineColor: b.useSeriesColor ? t.color : b.lineColor
              });
              return {
                x: o,
                y: u,
                x2: v,
                y2: g,
                theme: C
              };
            }
            function Ff(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Ff = function(a) {
                return typeof a;
              } : Ff = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Ff(t);
            }
            function o0(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function ai(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? o0(Object(a), !0).forEach(function(o) {
                  ca(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : o0(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function rM(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function nM(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function iM(t, n, a) {
              return n && nM(t.prototype, n), t;
            }
            function aM(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Hv(t, n);
            }
            function Hv(t, n) {
              return Hv = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Hv(t, n);
            }
            function oM(t) {
              var n = lM();
              return function() {
                var o = zf(t), u;
                if (n) {
                  var h = zf(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return sM(this, u);
              };
            }
            function sM(t, n) {
              return n && (Ff(n) === "object" || typeof n == "function") ? n : ua(t);
            }
            function ua(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function lM() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function zf(t) {
              return zf = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, zf(t);
            }
            function ca(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var Hf = /* @__PURE__ */ function(t) {
              aM(a, t);
              var n = oM(a);
              function a() {
                var o;
                rM(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), ca(ua(o), "models", {
                  rect: [],
                  series: [],
                  dot: []
                }), ca(ua(o), "drawModels", void 0), ca(ua(o), "responders", void 0), ca(ua(o), "theme", void 0), ca(ua(o), "activatedResponders", []), ca(ua(o), "eventDetectType", "nearest"), ca(ua(o), "tooltipCircleMap", void 0), ca(ua(o), "startIndex", void 0), ca(ua(o), "yAxisName", "yAxis"), ca(ua(o), "onMouseoutComponent", function() {
                  o.eventBus.emit("seriesPointHovered", {
                    models: [],
                    name: o.name
                  }), o.eventBus.emit("renderHoveredSeries", {
                    models: [],
                    name: o.name,
                    eventDetectType: o.eventDetectType
                  }), o.eventBus.emit("needDraw");
                }), ca(ua(o), "selectSeries", function(g) {
                  var b = g.index, C = g.seriesIndex;
                  if (kf(g, "line")) {
                    var R = o.getResponderCategoryByIndex(b);
                    if (!R)
                      throw new Error(ve.SELECT_SERIES_API_INDEX_ERROR);
                    var I = o.tooltipCircleMap[R][C];
                    if (!I)
                      throw new Error(ve.SELECT_SERIES_API_INDEX_ERROR);
                    var W = o.getResponderSeriesWithTheme([I], "select");
                    o.eventBus.emit("renderSelectedSeries", {
                      models: W,
                      name: o.name
                    }), o.eventBus.emit("needDraw");
                  }
                }), ca(ua(o), "showTooltip", function(g) {
                  var b = g.index, C = g.seriesIndex;
                  if (xf(g, o.eventDetectType, "line")) {
                    var R = o.getResponderCategoryByIndex(b);
                    if (R) {
                      var I = o.eventDetectType === "grouped" ? o.tooltipCircleMap[R] : [o.tooltipCircleMap[R][C]];
                      I != null && I.length && (o.onMousemoveNearType(I), o.eventBus.emit("seriesPointHovered", {
                        models: o.activatedResponders,
                        name: o.name
                      }), o.eventBus.emit("needDraw"));
                    }
                  }
                }), o;
              }
              return iM(a, [{
                key: "initialize",
                value: function() {
                  this.type = "series", this.name = "line", this.eventBus.on("selectSeries", this.selectSeries), this.eventBus.on("showTooltip", this.showTooltip), this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "initUpdate",
                value: function(u) {
                  this.drawModels.rect[0].width = this.models.rect[0].width * u;
                }
              }, {
                key: "setEventDetectType",
                value: function(u, h) {
                  var v;
                  (u.area || u.column) && (this.eventDetectType = "grouped"), h != null && (v = h.series) !== null && v !== void 0 && v.eventDetectType && (this.eventDetectType = h.series.eventDetectType), u.scatter && (this.eventDetectType = "near");
                }
              }, {
                key: "render",
                value: function(u, h) {
                  var v, g, b, C, R = h.viewRange, I = u.layout, W = u.series, Z = u.scale, ue = u.axes, ke = u.legend, Ee = u.theme;
                  if (!W.line)
                    throw new Error(ve.noDataError(this.name));
                  var Le = (v = u.categories) !== null && v !== void 0 ? v : [], je = (g = u.rawCategories) !== null && g !== void 0 ? g : [], Ke = ai({}, u.options);
                  Ke != null && Ke.series && "line" in Ke.series && (Ke.series = ai(ai({}, Ke.series), Ke.series.line)), this.setEventDetectType(W, Ke);
                  var ut = ue.xAxis, bt = (b = Ke.series) !== null && b !== void 0 ? b : {}, mt = W.line.data;
                  this.theme = Ee.series.line, this.rect = I.plot, this.activeSeriesMap = Ea(ke), this.startIndex = (C = R == null ? void 0 : R[0]) !== null && C !== void 0 ? C : 0, this.selectable = this.getSelectableOption(Ke), this.yAxisName = Qu(Ke, this.name, "yAxis");
                  var Rt = this.renderLinePointsModel(mt, Z, ut, bt, Le), Dt = this.renderCircleModel(Rt, bt), Lt = Dt.dotSeriesModel, Wt = Dt.responderModel, Qt = this.makeTooltipData(mt, Le);
                  this.tooltipCircleMap = e0(Wt, Qt), this.models = {
                    rect: [this.renderClipRectAreaModel()],
                    series: Rt,
                    dot: Lt
                  }, this.drawModels || (this.drawModels = ai(ai({}, this.models), {}, {
                    rect: [this.renderClipRectAreaModel(!0)]
                  })), Ma(Ke, this.name).visible && this.renderDataLabels(this.getDataLabels(Rt));
                  var or = _l(W);
                  this.responders = this.getResponders({
                    labelAxisData: ut,
                    responderModel: Wt,
                    tooltipDataArr: Qt,
                    categories: Le,
                    rawCategories: je,
                    coordinateType: or
                  });
                }
              }, {
                key: "getResponders",
                value: function(u) {
                  var h = u.labelAxisData, v = u.responderModel, g = u.tooltipDataArr, b = u.categories, C = u.rawCategories, R = u.coordinateType;
                  if (this.eventDetectType === "near")
                    return this.makeNearTypeResponderModel(v, g, C);
                  if (this.eventDetectType === "point")
                    return this.makeNearTypeResponderModel(v, g, C, 0);
                  if (R) {
                    var I = this.getRectResponderInfoForCoordinateType(v, C);
                    return Qb(I, this.rect);
                  }
                  return Nf(this.rect, h, b);
                }
              }, {
                key: "makeNearTypeResponderModel",
                value: function(u, h, v, g) {
                  return u.map(function(b, C) {
                    return ai(ai({}, b), {}, {
                      data: h[C],
                      detectionSize: g,
                      label: v[b.index]
                    });
                  });
                }
              }, {
                key: "makeTooltipData",
                value: function(u, h) {
                  var v = this;
                  return u.flatMap(function(g, b) {
                    var C = g.rawData, R = g.name, I = g.color;
                    return C.map(function(W, Z) {
                      return Oe(W) ? {} : {
                        label: R,
                        color: I,
                        value: qo(W),
                        category: h[Xp(W, h, Z, v.startIndex)],
                        seriesIndex: b,
                        index: Z
                      };
                    });
                  });
                }
              }, {
                key: "renderClipRectAreaModel",
                value: function(u) {
                  return {
                    type: "clipRectArea",
                    x: 0,
                    y: 0,
                    width: u ? 0 : this.rect.width,
                    height: this.rect.height
                  };
                }
              }, {
                key: "renderLinePointsModel",
                value: function(u, h, v, g, b) {
                  var C = this, R = g.spline, I = h[this.yAxisName].limit, W = this.theme, Z = W.lineWidth, ue = W.dashSegments;
                  return u.map(function(ke, Ee) {
                    var Le = ke.rawData, je = ke.name, Ke = ke.color, ut = [], bt = C.activeSeriesMap[je];
                    return Le.forEach(function(mt, Rt) {
                      if (Oe(mt))
                        return ut.push(null);
                      var Dt = qo(mt), Lt = bo(Dt, I), Wt = (1 - Lt) * C.rect.height, Qt = Vu(v, C.rect.width, Ka(mt), Xp(mt, b, Rt, C.startIndex));
                      ut.push({
                        x: Qt,
                        y: Wt,
                        value: Dt
                      });
                    }), R && Gs(ut), {
                      type: "linePoints",
                      points: ut,
                      seriesIndex: Ee,
                      name: je,
                      color: cr(Ke, bt ? 1 : 0.3),
                      lineWidth: Z,
                      dashSegments: ue
                    };
                  });
                }
              }, {
                key: "getRectResponderInfoForCoordinateType",
                value: function(u, h) {
                  var v = this, g = {}, b = u.filter(function(C) {
                    var R = C.x;
                    return R >= 0 && R <= v.rect.width;
                  });
                  return b.reduce(function(C, R) {
                    var I = R.index, W = R.x;
                    if (!g[W]) {
                      var Z = h[I];
                      g[W] = !0, C.push({
                        x: W,
                        label: Z
                      });
                    }
                    return C;
                  }, []);
                }
              }, {
                key: "renderCircleModel",
                value: function(u, h) {
                  var v = this, g = [], b = [], C = !!h.showDot, R = this.theme, I = R.hover, W = R.dot, Z = I.dot;
                  return u.forEach(function(ue, ke) {
                    var Ee = ue.color, Le = ue.name, je = ue.points, Ke = v.activeSeriesMap[Le];
                    je.forEach(function(ut, bt) {
                      var mt;
                      if (!Oe(ut)) {
                        var Rt = ut.x, Dt = ut.y, Lt = {
                          type: "circle",
                          x: Rt,
                          y: Dt,
                          seriesIndex: ke,
                          name: Le,
                          index: bt
                        };
                        if (C) {
                          var Wt;
                          g.push(ai(ai({}, Lt), {}, {
                            radius: W.radius,
                            color: cr(Ee, Ke ? 1 : 0.3),
                            style: [{
                              lineWidth: W.borderWidth,
                              strokeStyle: (Wt = W.borderColor) !== null && Wt !== void 0 ? Wt : Ee
                            }]
                          }));
                        }
                        b.push(ai(ai({}, Lt), {}, {
                          radius: Z.radius,
                          color: (mt = Z.color) !== null && mt !== void 0 ? mt : cr(Ee, 1),
                          style: ["default"]
                        }));
                      }
                    });
                  }), {
                    dotSeriesModel: g,
                    responderModel: b
                  };
                }
              }, {
                key: "getCircleModelsFromRectResponders",
                value: function(u, h) {
                  var v, g;
                  if (!u.length || !u[0].label)
                    return [];
                  var b = (v = this.tooltipCircleMap[(g = u[0]) === null || g === void 0 ? void 0 : g.label]) !== null && v !== void 0 ? v : [];
                  return this.eventDetectType === "grouped" ? b : jl(b, h, this.rect);
                }
              }, {
                key: "onMousemoveNearType",
                value: function(u) {
                  this.eventBus.emit("renderHoveredSeries", {
                    models: this.getResponderSeriesWithTheme(u, "hover"),
                    name: this.name,
                    eventDetectType: this.eventDetectType
                  }), this.activatedResponders = u;
                }
              }, {
                key: "onMousemoveNearestType",
                value: function(u, h) {
                  var v = this.getCircleModelsFromRectResponders(u, h);
                  this.onMousemoveNearType(v);
                }
              }, {
                key: "onMousemoveGroupedType",
                value: function(u) {
                  var h = this.getCircleModelsFromRectResponders(u);
                  this.onMousemoveNearType(h);
                }
              }, {
                key: "onMousemove",
                value: function(u) {
                  var h = u.responders, v = u.mousePosition;
                  this.eventDetectType === "nearest" ? this.onMousemoveNearestType(h, v) : Ve(["near", "point"], this.eventDetectType) ? this.onMousemoveNearType(h) : this.onMousemoveGroupedType(h), this.eventBus.emit("seriesPointHovered", {
                    models: this.activatedResponders,
                    name: this.name
                  }), this.eventBus.emit("needDraw");
                }
              }, {
                key: "getDataLabels",
                value: function(u) {
                  var h = this.theme.dataLabels;
                  return u.flatMap(function(v) {
                    var g = v.points, b = v.name, C = v.color;
                    return g.map(function(R) {
                      return Oe(R) ? {} : ai(ai({
                        type: "point"
                      }, R), {}, {
                        name: b,
                        theme: ai(ai({}, h), {}, {
                          color: h.useSeriesColor ? C : h.color
                        })
                      });
                    });
                  });
                }
              }, {
                key: "getResponderSeriesWithTheme",
                value: function(u, h) {
                  var v = this.theme[h].dot, g = v.radius, b = v.color, C = v.borderWidth, R = v.borderColor;
                  return u.map(function(I) {
                    var W = b ?? I.color;
                    return ai(ai({}, I), {}, {
                      radius: g,
                      color: W,
                      style: [{
                        lineWidth: C,
                        strokeStyle: R ?? cr(W, 0.5)
                      }]
                    });
                  });
                }
              }, {
                key: "onClick",
                value: function(u) {
                  var h = u.responders, v = u.mousePosition;
                  if (this.selectable) {
                    var g;
                    this.eventDetectType === "near" ? g = h : g = this.getCircleModelsFromRectResponders(h, v), this.eventBus.emit("renderSelectedSeries", {
                      models: this.getResponderSeriesWithTheme(g, "select"),
                      name: this.name
                    }), this.eventBus.emit("needDraw");
                  }
                }
              }, {
                key: "getResponderCategoryByIndex",
                value: function(u) {
                  var h, v = Object.values(this.tooltipCircleMap).flatMap(function(g) {
                    return g;
                  }).find(function(g) {
                    return g.index === u;
                  });
                  return v == null || (h = v.data) === null || h === void 0 ? void 0 : h.category;
                }
              }]), a;
            }(Lr);
            function jf(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? jf = function(a) {
                return typeof a;
              } : jf = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, jf(t);
            }
            function s0(t) {
              return dM(t) || fM(t) || cM(t) || uM();
            }
            function uM() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function cM(t, n) {
              if (t) {
                if (typeof t == "string") return jv(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return jv(t, n);
              }
            }
            function fM(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function dM(t) {
              if (Array.isArray(t)) return jv(t);
            }
            function jv(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function l0(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function tl(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? l0(Object(a), !0).forEach(function(o) {
                  ts(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : l0(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function hM(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function pM(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function vM(t, n, a) {
              return n && pM(t.prototype, n), t;
            }
            function mM(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Wv(t, n);
            }
            function Wv(t, n) {
              return Wv = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Wv(t, n);
            }
            function gM(t) {
              var n = bM();
              return function() {
                var o = Wf(t), u;
                if (n) {
                  var h = Wf(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return yM(this, u);
              };
            }
            function yM(t, n) {
              return n && (jf(n) === "object" || typeof n == "function") ? n : es(t);
            }
            function es(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function bM() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function Wf(t) {
              return Wf = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, Wf(t);
            }
            function ts(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var Oi = /* @__PURE__ */ function(t) {
              mM(a, t);
              var n = gM(a);
              function a() {
                var o;
                hM(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), ts(es(o), "models", void 0), ts(es(o), "responders", void 0), ts(es(o), "theme", void 0), ts(es(o), "activatedResponders", []), ts(es(o), "seriesColorMap", {}), ts(es(o), "seriesIconTypeMap", {}), ts(es(o), "onClickCheckbox", function(g) {
                  var b = g[0], C = b.label, R = b.checked;
                  o.store.dispatch("setAllLegendActiveState", !0), o.store.dispatch("setLegendCheckedState", {
                    name: C,
                    checked: !R
                  }), R ? o.store.dispatch("disableSeries", C) : o.store.dispatch("enableSeries", C), o.eventBus.emit("needDraw");
                }), ts(es(o), "onClickLabel", function(g) {
                  var b = g[0].label;
                  o.eventBus.emit("resetSelectedSeries"), o.activatedResponders.length && o.activatedResponders[0].label === b ? (o.store.dispatch("setAllLegendActiveState", !0), o.activatedResponders = []) : (o.store.dispatch("setAllLegendActiveState", !1), o.store.dispatch("setLegendActiveState", {
                    name: b,
                    active: !0
                  }), o.activatedResponders = g), o.eventBus.emit("needDraw");
                }), o;
              }
              return vM(a, [{
                key: "onClick",
                value: function(u) {
                  var h = u.responders;
                  if (h.length) {
                    var v = h[0].data;
                    (v == null ? void 0 : v.name) === "checkbox" ? this.eventBus.emit("clickLegendCheckbox", ne(h)) : this.eventBus.emit("clickLegendLabel", ne(h));
                  }
                }
              }, {
                key: "initialize",
                value: function() {
                  this.type = "legend", this.name = "legend", this.eventBus.on("clickLegendCheckbox", this.onClickCheckbox), this.eventBus.on("clickLegendLabel", this.onClickLabel);
                }
              }, {
                key: "initColorAndIconTypeMap",
                value: function(u) {
                  var h = this;
                  this.seriesColorMap = {}, this.seriesIconTypeMap = {}, u.forEach(function(v) {
                    var g = v.label, b = v.color, C = v.iconType;
                    h.seriesColorMap[g] = b, h.seriesIconTypeMap[g] = C;
                  });
                }
              }, {
                key: "getXPositionWhenVerticalAlign",
                value: function(u) {
                  var h = u.reduce(function(C, R) {
                    var I = R.rowIndex, W = R.columnIndex, Z = R.width;
                    return we(C.rowWidths[I]) && (C.rowWidths[I] = 0, C.offset[I] = [0]), C.rowWidths[I] += Z + (W ? Zs : 0), C.offset[I][W + 1] = C.offset[I][W] + Zs + Z, C;
                  }, {
                    offset: [],
                    rowWidths: []
                  }), v = h.offset, g = h.rowWidths, b = this.rect.width;
                  return g.forEach(function(C, R) {
                    var I = (b - C) / 2;
                    v[R] = v[R].map(function(W) {
                      return W + I;
                    });
                  }), v;
                }
              }, {
                key: "getXPositionWhenHorizontalAlign",
                value: function(u) {
                  var h = u.reduce(function(v, g) {
                    var b = g.columnIndex, C = g.width;
                    return we(v[b]) && (v[b] = 0), v[b] = Math.max(v[b], C), v;
                  }, []);
                  return u.reduce(function(v, g) {
                    var b = g.rowIndex, C = g.columnIndex;
                    return we(v[b]) && (v[b] = [0]), v[b][C + 1] = v[b][C] + Zs + h[C], v;
                  }, []);
                }
              }, {
                key: "renderLegendModel",
                value: function(u) {
                  var h = this, v = u.data, g = u.showCheckbox, b = u.align, C = u.useScatterChartIcon, R = xo(b), I = wf(this.theme.label.fontSize), W = R ? this.getXPositionWhenVerticalAlign(v) : this.getXPositionWhenHorizontalAlign(v);
                  return [tl({
                    type: "legend",
                    align: b,
                    showCheckbox: g,
                    data: v.map(function(Z) {
                      var ue, ke = Z.label, Ee = Z.iconType, Le = Z.rowIndex, je = Z.columnIndex;
                      return tl(tl({}, Z), {}, {
                        iconType: (ue = h.seriesIconTypeMap[ke]) !== null && ue !== void 0 ? ue : Ee,
                        color: h.seriesColorMap[ke],
                        x: W[Le][je],
                        y: Br.Y + I * Le,
                        useScatterChartIcon: C
                      });
                    })
                  }, this.theme.label)];
                }
              }, {
                key: "makeCheckboxResponder",
                value: function(u, h) {
                  return h ? u.map(function(v) {
                    return tl(tl({}, v), {}, {
                      type: "rect",
                      x: v.x,
                      y: v.y,
                      width: Ui,
                      height: Ui,
                      data: {
                        name: "checkbox"
                      }
                    });
                  }) : [];
                }
              }, {
                key: "makeLabelResponder",
                value: function(u, h) {
                  var v = an(this.theme.label);
                  return u.map(function(g) {
                    return tl(tl({}, g), {}, {
                      type: "rect",
                      x: g.x + (h ? Ui + $i : 0) + Nl + $i,
                      y: g.y,
                      width: ni(g.label, v),
                      data: {
                        name: "label"
                      },
                      height: Ui
                    });
                  });
                }
              }, {
                key: "render",
                value: function(u) {
                  var h = u.layout, v = u.legend, g = u.theme;
                  if (this.isShow = v.visible && !!v.data.length, !!this.isShow) {
                    var b = v.showCheckbox, C = v.data;
                    this.rect = h.legend, this.theme = g.legend, this.initColorAndIconTypeMap(C), this.models = this.renderLegendModel(v);
                    var R = this.models[0].data, I = this.makeCheckboxResponder(R, b), W = this.makeLabelResponder(R, b);
                    this.responders = [].concat(s0(I), s0(W));
                  }
                }
              }]), a;
            }(Lr);
            function $f(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? $f = function(a) {
                return typeof a;
              } : $f = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, $f(t);
            }
            function u0(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function Wl(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? u0(Object(a), !0).forEach(function(o) {
                  As(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : u0(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function $l(t) {
              return kM(t) || xM(t) || wM(t) || SM();
            }
            function SM() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function wM(t, n) {
              if (t) {
                if (typeof t == "string") return $v(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return $v(t, n);
              }
            }
            function xM(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function kM(t) {
              if (Array.isArray(t)) return $v(t);
            }
            function $v(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function OM(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function CM(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function TM(t, n, a) {
              return n && CM(t.prototype, n), t;
            }
            function AM(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Uv(t, n);
            }
            function Uv(t, n) {
              return Uv = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Uv(t, n);
            }
            function EM(t) {
              var n = RM();
              return function() {
                var o = Uf(t), u;
                if (n) {
                  var h = Uf(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return MM(this, u);
              };
            }
            function MM(t, n) {
              return n && ($f(n) === "object" || typeof n == "function") ? n : Ul(t);
            }
            function Ul(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function RM() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function Uf(t) {
              return Uf = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, Uf(t);
            }
            function As(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function DM(t, n, a, o) {
              var u = t.type, h = [];
              if (u === "point")
                h.push(zE(t, n, a));
              else if (u === "sector")
                if (o === "radialBar")
                  h.push(XE(t, n));
                else {
                  var v;
                  if (h.push(JE(t, n)), (v = n.pieSeriesName) !== null && v !== void 0 && v.visible) {
                    var g = ZE(t, n);
                    h.push(g);
                  }
                }
              else u === "line" ? h.push(QE(t, n)) : h.push(YE(t, n));
              return h;
            }
            var Yi = /* @__PURE__ */ function(t) {
              AM(a, t);
              var n = EM(a);
              function a() {
                var o;
                OM(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), As(Ul(o), "models", void 0), As(Ul(o), "drawModels", void 0), As(Ul(o), "options", void 0), As(Ul(o), "dataLabelsMap", {}), As(Ul(o), "renderSeriesDataLabels", function(g) {
                  o.appendDataLabels(g), o.models = o.renderLabelModel(), o.drawModels ? o.sync() : o.drawModels = o.getDrawModelsAppliedOpacity(0);
                }), o;
              }
              return TM(a, [{
                key: "initialize",
                value: function() {
                  this.type = "dataLabels", this.name = "dataLabels", this.eventBus.on("renderDataLabels", this.renderSeriesDataLabels);
                }
              }, {
                key: "initUpdate",
                value: function(u) {
                  this.drawModels && (this.drawModels = this.getDrawModelsAppliedOpacity(u));
                }
              }, {
                key: "render",
                value: function(u) {
                  var h = u.layout, v = u.options, g = u.series, b = u.nestedPieSeries;
                  this.rect = h.plot, this.options = v, this.isShow = this.visibleDataLabels(g, b);
                }
              }, {
                key: "visibleDataLabels",
                value: function(u, h) {
                  var v, g, b = this, C = !!((v = this.options.series) !== null && v !== void 0 && (g = v.dataLabels) !== null && g !== void 0 && g.visible), R = Object.keys(u).some(function(W) {
                    var Z, ue, ke;
                    return !!((Z = b.options.series) !== null && Z !== void 0 && (ue = Z[W]) !== null && ue !== void 0 && (ke = ue.dataLabels) !== null && ke !== void 0 && ke.visible);
                  }), I = !!(h && Object.keys(h).some(function(W) {
                    var Z, ue, ke;
                    return !!((Z = b.options.series) !== null && Z !== void 0 && (ue = Z[W]) !== null && ue !== void 0 && (ke = ue.dataLabels) !== null && ke !== void 0 && ke.visible);
                  }));
                  return C || R || I;
                }
              }, {
                key: "appendDataLabels",
                value: function(u) {
                  var h = this, v = u.name, g = u.data, b = Ma(this.options, v), C = !!Av(this.options), R = [];
                  g.forEach(function(I) {
                    var W, Z = I.type, ue = I.value, ke = FE(b, Z, C), Ee = Z === "stackTotal" && !((W = ke.stackTotal) !== null && W !== void 0 && W.visible);
                    Ee || we(ue) || R.splice.apply(R, [R.length, 0].concat($l(DM(I, ke, h.rect, v))));
                  }), this.dataLabelsMap[v] = {
                    data: R,
                    options: b
                  };
                }
              }, {
                key: "getDrawModelsAppliedOpacity",
                value: function(u) {
                  var h = this;
                  return Object.keys(this.models).reduce(function(v, g) {
                    return Wl(Wl({}, v), {}, As({}, g, h.models[g].map(function(b) {
                      return Wl(Wl({}, b), {}, {
                        opacity: u
                      });
                    })));
                  }, {
                    series: [],
                    total: []
                  });
                }
              }, {
                key: "renderLabelModel",
                value: function() {
                  var u = this;
                  return Object.keys(this.dataLabelsMap).map(function(h) {
                    var v = u.dataLabelsMap[h].data;
                    return u.makeLabelModel(v);
                  }).reduce(function(h, v) {
                    return {
                      series: [].concat($l(h.series), $l(v.series)),
                      total: [].concat($l(h.total), $l(v.total))
                    };
                  }, {
                    series: [],
                    total: []
                  });
                }
              }, {
                key: "makeLabelModel",
                value: function(u) {
                  var h = this;
                  return u.reduce(function(v, g) {
                    var b, C = g.type, R = g.x, I = g.y, W = g.text, Z = g.textAlign, ue = g.textBaseline, ke = g.name, Ee = g.callout, Le = g.theme, je = g.radian;
                    if (!fk(h.rect, {
                      x: R,
                      y: I
                    }))
                      return v;
                    var Ke = C === "stackTotal" ? "total" : "series";
                    return Wl(Wl({}, v), {}, As({}, Ke, [].concat($l((b = v[Ke]) !== null && b !== void 0 ? b : []), [{
                      type: "dataLabel",
                      dataLabelType: C,
                      text: W,
                      x: R,
                      y: I,
                      textAlign: Z,
                      textBaseline: ue,
                      opacity: 1,
                      name: ke,
                      callout: Ee,
                      theme: Le,
                      radian: je
                    }])));
                  }, {
                    series: [],
                    total: []
                  });
                }
              }]), a;
            }(Lr);
            function Vf(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Vf = function(a) {
                return typeof a;
              } : Vf = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Vf(t);
            }
            function PM(t, n) {
              return NM(t) || _M(t, n) || IM(t, n) || LM();
            }
            function LM() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function IM(t, n) {
              if (t) {
                if (typeof t == "string") return c0(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return c0(t, n);
              }
            }
            function c0(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function _M(t, n) {
              var a = t && (typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]);
              if (a != null) {
                var o = [], u = !0, h = !1, v, g;
                try {
                  for (a = a.call(t); !(u = (v = a.next()).done) && (o.push(v.value), !(n && o.length === n)); u = !0)
                    ;
                } catch (b) {
                  h = !0, g = b;
                } finally {
                  try {
                    !u && a.return != null && a.return();
                  } finally {
                    if (h) throw g;
                  }
                }
                return o;
              }
            }
            function NM(t) {
              if (Array.isArray(t)) return t;
            }
            function BM(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function FM(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function zM(t, n, a) {
              return n && FM(t.prototype, n), t;
            }
            function HM(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Vv(t, n);
            }
            function Vv(t, n) {
              return Vv = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Vv(t, n);
            }
            function jM(t) {
              var n = $M();
              return function() {
                var o = Gf(t), u;
                if (n) {
                  var h = Gf(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return WM(this, u);
              };
            }
            function WM(t, n) {
              return n && (Vf(n) === "object" || typeof n == "function") ? n : vc(t);
            }
            function vc(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function $M() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function Gf(t) {
              return Gf = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, Gf(t);
            }
            function Yf(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var Yr = /* @__PURE__ */ function(t) {
              HM(a, t);
              var n = jM(a);
              function a() {
                var o;
                BM(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), Yf(vc(o), "models", void 0), Yf(vc(o), "isYAxis", void 0), Yf(vc(o), "isCircularAxis", void 0), Yf(vc(o), "theme", void 0), o;
              }
              return zM(a, [{
                key: "initialize",
                value: function(u) {
                  var h = u.name;
                  this.type = "axisTitle", this.name = h, this.isYAxis = Ve([_r.Y, _r.SECONDARY_Y], h), this.isCircularAxis = this.name === _r.CIRCULAR;
                }
              }, {
                key: "getTitlePosition",
                value: function(u, h) {
                  return this.isCircularAxis ? [this.rect.width / 2 + u, this.rect.height / 2 + h] : this.isYAxis ? [this.name === _r.Y ? u : this.rect.width + u, h] : [this.rect.width + u, h];
                }
              }, {
                key: "renderAxisTitle",
                value: function(u, h) {
                  var v = u.text, g = u.offsetX, b = u.offsetY, C = this.getTitlePosition(g, b), R = PM(C, 2), I = R[0], W = R[1], Z = an(this.theme), ue = this.theme.color;
                  return [{
                    type: "label",
                    text: v,
                    x: I,
                    y: W,
                    style: ["axisTitle", {
                      textAlign: h,
                      fillStyle: ue,
                      font: Z
                    }]
                  }];
                }
              }, {
                key: "getTextAlign",
                value: function() {
                  var u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
                  return this.name === _r.Y ? u ? "center" : "left" : this.isCircularAxis ? "center" : "right";
                }
              }, {
                key: "getCircularAxisTitleRect",
                value: function(u, h, v) {
                  var g = h.x, b = h.y, C = v.centerX, R = v.centerY, I = v.axisSize, W = v.radius.outer, Z = u.offsetY;
                  return {
                    x: C + g - I / 2,
                    y: R + b - W / 2,
                    width: I,
                    height: this.theme.fontSize + Z
                  };
                }
              }, {
                key: "render",
                value: function(u) {
                  var h, v, g = u.axes, b = u.radialAxes, C = u.layout, R = u.theme, I = this.isCircularAxis ? (h = b[this.name]) === null || h === void 0 ? void 0 : h.title : (v = g[this.name]) === null || v === void 0 ? void 0 : v.title;
                  this.isShow = !!I, this.isShow && (this.theme = Go(R, this.name).title, this.rect = C["".concat(this.name, "Title")], this.models = this.renderAxisTitle(I, this.getTextAlign(!!(g != null && g.centerYAxis))));
                }
              }]), a;
            }(Lr);
            function qf(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? qf = function(a) {
                return typeof a;
              } : qf = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, qf(t);
            }
            function UM(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function VM(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function GM(t, n, a) {
              return n && VM(t.prototype, n), t;
            }
            function YM(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Gv(t, n);
            }
            function Gv(t, n) {
              return Gv = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Gv(t, n);
            }
            function qM(t) {
              var n = XM();
              return function() {
                var o = Kf(t), u;
                if (n) {
                  var h = Kf(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return KM(this, u);
              };
            }
            function KM(t, n) {
              return n && (qf(n) === "object" || typeof n == "function") ? n : Yv(t);
            }
            function Yv(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function XM() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function Kf(t) {
              return Kf = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, Kf(t);
            }
            function f0(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var Un = /* @__PURE__ */ function(t) {
              YM(a, t);
              var n = qM(a);
              function a() {
                var o;
                UM(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), f0(Yv(o), "models", void 0), f0(Yv(o), "theme", void 0), o;
              }
              return GM(a, [{
                key: "initialize",
                value: function() {
                  this.type = "title", this.name = "title";
                }
              }, {
                key: "renderTitle",
                value: function(u) {
                  var h = "", v = 0, g = 0, b = "left";
                  if (Ie(u))
                    h = u;
                  else {
                    var C, R, I;
                    h = u.text, b = (C = u.align) !== null && C !== void 0 ? C : "left", v += (R = u.offsetX) !== null && R !== void 0 ? R : 0, g += (I = u.offsetY) !== null && I !== void 0 ? I : 0;
                  }
                  var W = an(this.theme), Z = ni(h, W);
                  return b === "center" ? v += (this.rect.width - Z) / 2 : b === "right" && (v += this.rect.width - Z), [{
                    type: "label",
                    x: v,
                    y: g,
                    text: h,
                    style: ["title", {
                      font: W,
                      fillStyle: this.theme.color
                    }]
                  }];
                }
              }, {
                key: "render",
                value: function(u) {
                  var h, v = u.options, g = u.layout, b = u.theme;
                  this.isShow = !!((h = v.chart) !== null && h !== void 0 && h.title), this.isShow && (this.theme = b.title, this.rect = g.title, this.models = this.renderTitle(v.chart.title));
                }
              }]), a;
            }(Lr);
            function Xf(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Xf = function(a) {
                return typeof a;
              } : Xf = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Xf(t);
            }
            function JM(t, n) {
              return eR(t) || QM(t, n) || d0(t, n) || ZM();
            }
            function ZM() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function QM(t, n) {
              var a = t && (typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]);
              if (a != null) {
                var o = [], u = !0, h = !1, v, g;
                try {
                  for (a = a.call(t); !(u = (v = a.next()).done) && (o.push(v.value), !(n && o.length === n)); u = !0)
                    ;
                } catch (b) {
                  h = !0, g = b;
                } finally {
                  try {
                    !u && a.return != null && a.return();
                  } finally {
                    if (h) throw g;
                  }
                }
                return o;
              }
            }
            function eR(t) {
              if (Array.isArray(t)) return t;
            }
            function tR(t, n) {
              if (t == null) return {};
              var a = rR(t, n), o, u;
              if (Object.getOwnPropertySymbols) {
                var h = Object.getOwnPropertySymbols(t);
                for (u = 0; u < h.length; u++)
                  o = h[u], !(n.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(t, o) && (a[o] = t[o]);
              }
              return a;
            }
            function rR(t, n) {
              if (t == null) return {};
              var a = {}, o = Object.keys(t), u, h;
              for (h = 0; h < o.length; h++)
                u = o[h], !(n.indexOf(u) >= 0) && (a[u] = t[u]);
              return a;
            }
            function nR(t) {
              return oR(t) || aR(t) || d0(t) || iR();
            }
            function iR() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function d0(t, n) {
              if (t) {
                if (typeof t == "string") return qv(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return qv(t, n);
              }
            }
            function aR(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function oR(t) {
              if (Array.isArray(t)) return qv(t);
            }
            function qv(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function sR(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function lR(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function uR(t, n, a) {
              return n && lR(t.prototype, n), t;
            }
            function cR(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Kv(t, n);
            }
            function Kv(t, n) {
              return Kv = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Kv(t, n);
            }
            function fR(t) {
              var n = hR();
              return function() {
                var o = Jf(t), u;
                if (n) {
                  var h = Jf(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return dR(this, u);
              };
            }
            function dR(t, n) {
              return n && (Xf(n) === "object" || typeof n == "function") ? n : Vl(t);
            }
            function Vl(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function hR() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function Jf(t) {
              return Jf = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, Jf(t);
            }
            function mc(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var h0 = {
              line: "circle",
              area: "circle",
              boxPlot: "boxPlot"
            }, Vn = /* @__PURE__ */ function(t) {
              cR(a, t);
              var n = fR(a);
              function a() {
                var o;
                sR(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), mc(Vl(o), "models", {
                  guideLine: []
                }), mc(Vl(o), "isShow", !1), mc(Vl(o), "modelForGuideLine", void 0), mc(Vl(o), "renderHoveredSeries", function(g) {
                  var b = g.models, C = g.name, R = g.eventDetectType, I = o.getSeriesModels(C);
                  o.models[C] = nR(b), o.isShow = !!o.getSeriesModels().length;
                  var W = !!(I != null && I.length) && !!b.length && Zb({
                    models: b,
                    comparisonModel: I,
                    eventDetectType: R,
                    name: C
                  });
                  I != null && I.length && !b.length ? o.eventBus.emit("unhoverSeries", ne(I)) : b.length && !W && o.eventBus.emit("hoverSeries", ne(b)), o.modelForGuideLine = o.getModelForGuideLine(C), R === "grouped" && o.renderGroupedModels(C);
                }), mc(Vl(o), "resetHoveredSeries", function() {
                  o.models = {
                    guideLine: []
                  };
                }), o;
              }
              return uR(a, [{
                key: "getSeriesModels",
                value: function(u) {
                  var h, v = this.models;
                  v.guideLine;
                  var g = tR(v, ["guideLine"]);
                  return (h = u ? g[u] : Object.values(g)) === null || h === void 0 ? void 0 : h.flatMap(function(b) {
                    return b;
                  });
                }
              }, {
                key: "hasGuideLine",
                value: function() {
                  var u = this.getSeriesModels().filter(function(g) {
                    var b = g.type;
                    return b === "rect";
                  }), h = JM(u, 1), v = h[0];
                  return !we(this.modelForGuideLine) && we(v);
                }
              }, {
                key: "getModelForGuideLine",
                value: function(u) {
                  return this.getSeriesModels().filter(function(h) {
                    var v = h.type;
                    return v === h0[u];
                  })[0];
                }
              }, {
                key: "renderGroupedModels",
                value: function(u) {
                  Ve(Object.keys(h0), u) && (this.isShow && this.hasGuideLine() ? this.models.guideLine = [this.renderGuideLineModel(this.modelForGuideLine)] : this.models.guideLine = []);
                }
              }, {
                key: "renderGuideLineModel",
                value: function(u) {
                  var h = Cr(u.type === "boxPlot" && u.boxPlotDetection ? u.boxPlotDetection.x + u.boxPlotDetection.width / 2 : u.x);
                  return {
                    type: "line",
                    x: h,
                    y: 0,
                    x2: h,
                    y2: this.rect.height,
                    strokeStyle: "#ddd",
                    lineWidth: 1
                  };
                }
              }, {
                key: "initialize",
                value: function() {
                  this.type = "hoveredSeries", this.name = "hoveredSeries", this.eventBus.on("renderHoveredSeries", this.renderHoveredSeries), this.eventBus.on("resetHoveredSeries", this.resetHoveredSeries);
                }
              }, {
                key: "render",
                value: function(u) {
                  var h = u.layout;
                  this.rect = h.plot;
                }
              }]), a;
            }(Lr);
            function Zf(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Zf = function(a) {
                return typeof a;
              } : Zf = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Zf(t);
            }
            function pR(t) {
              return gR(t) || mR(t) || p0(t) || vR();
            }
            function vR() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function mR(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function gR(t) {
              if (Array.isArray(t)) return Xv(t);
            }
            function yR(t, n) {
              return wR(t) || SR(t, n) || p0(t, n) || bR();
            }
            function bR() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function p0(t, n) {
              if (t) {
                if (typeof t == "string") return Xv(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return Xv(t, n);
              }
            }
            function Xv(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function SR(t, n) {
              var a = t && (typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]);
              if (a != null) {
                var o = [], u = !0, h = !1, v, g;
                try {
                  for (a = a.call(t); !(u = (v = a.next()).done) && (o.push(v.value), !(n && o.length === n)); u = !0)
                    ;
                } catch (b) {
                  h = !0, g = b;
                } finally {
                  try {
                    !u && a.return != null && a.return();
                  } finally {
                    if (h) throw g;
                  }
                }
                return o;
              }
            }
            function wR(t) {
              if (Array.isArray(t)) return t;
            }
            function v0(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function Qf(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? v0(Object(a), !0).forEach(function(o) {
                  nl(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : v0(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function xR(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function kR(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function OR(t, n, a) {
              return n && kR(t.prototype, n), t;
            }
            function CR(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Jv(t, n);
            }
            function Jv(t, n) {
              return Jv = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Jv(t, n);
            }
            function TR(t) {
              var n = ER();
              return function() {
                var o = ed(t), u;
                if (n) {
                  var h = ed(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return AR(this, u);
              };
            }
            function AR(t, n) {
              return n && (Zf(n) === "object" || typeof n == "function") ? n : rl(t);
            }
            function rl(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function ER() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function ed(t) {
              return ed = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, ed(t);
            }
            function nl(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var MR = 15, Gl = /* @__PURE__ */ function(t) {
              CR(a, t);
              var n = TR(a);
              function a() {
                var o;
                xR(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), nl(rl(o), "models", {
                  selectionArea: []
                }), nl(rl(o), "responders", void 0), nl(rl(o), "startIndex", void 0), nl(rl(o), "dragStartPosition", null), nl(rl(o), "dragStartPoint", null), nl(rl(o), "isDragging", !1), o;
              }
              return OR(a, [{
                key: "initialize",
                value: function() {
                  this.type = "rangeSelection";
                }
              }, {
                key: "render",
                value: function(u, h) {
                  var v;
                  if (!(!u.selectionRange && !u.zoomRange)) {
                    this.resetSelectionArea();
                    var g = h.viewRange, b = u.layout, C = u.axes, R = u.series, I = u.scale, W = u.categories;
                    this.rect = b.plot, this.startIndex = (v = g == null ? void 0 : g[0]) !== null && v !== void 0 ? v : 0;
                    var Z = _l(R);
                    if (Z) {
                      var ue = this.getRectResponderInfoForCoordinateType(R, I, C.xAxis, W);
                      this.responders = this.makeRectResponderModelForCoordinateType(ue, W);
                    } else
                      this.responders = this.makeRectResponderModel(W, C.xAxis);
                  }
                }
              }, {
                key: "getRectResponderInfoForCoordinateType",
                value: function(u, h, v, g) {
                  var b = this, C = [], R = {};
                  return Object.keys(u).forEach(function(I) {
                    var W = u[I].data;
                    W.forEach(function(Z) {
                      var ue = Z.rawData;
                      ue.forEach(function(ke, Ee) {
                        if (!Oe(ke)) {
                          var Le = Xp(ke, g, Ee, b.startIndex), je = Vu(v, b.rect.width, Ka(ke), Le), Ke = je >= 0 && je <= b.rect.width;
                          !R[je] && Ke && (R[je] = !0, C.push({
                            x: je,
                            label: g[Le]
                          }));
                        }
                      });
                    });
                  }), C;
                }
              }, {
                key: "resetSelectionArea",
                value: function() {
                  this.dragStartPosition = null, this.dragStartPoint = null, this.models.selectionArea = [], this.isDragging = !1;
                }
              }, {
                key: "onMousedown",
                value: function(u) {
                  var h = u.responders, v = u.mousePosition;
                  h.length && (this.dragStartPoint = h.find(function(g) {
                    return g.data.name === "selectionArea";
                  }), this.dragStartPosition = v);
                }
              }, {
                key: "onMouseup",
                value: function(u) {
                  var h = this, v = u.responders;
                  if (this.isDragging && this.dragStartPoint && v.length) {
                    var g = [this.dragStartPoint, v[0]].sort(function(W, Z) {
                      return W.index - Z.index;
                    }).map(function(W) {
                      var Z;
                      return (Z = W.data) === null || Z === void 0 ? void 0 : Z.value;
                    }), b = this.store.state, C = b.series, R = b.options, I = R.series;
                    !C.column && I !== null && I !== void 0 && I.zoomable && (this.store.dispatch("zoom", g), this.eventBus.emit("zoom", ne(g))), I != null && I.rangeSelectable && this.eventBus.emit("rangeSelection", g), this.eventBus.emit("resetHoveredSeries"), this.eventBus.emit("hideTooltip"), setTimeout(function() {
                      h.eventBus.emit("resetSelectedSeries");
                    });
                  }
                  this.resetSelectionArea();
                }
              }, {
                key: "makeRectResponderModel",
                value: function(u, h) {
                  var v = u.length, g = h.pointOnColumn, b = h.tickDistance, C = this.rect.height, R = g ? [] : [0, v - 1], I = b / 2;
                  return Mt(0, v).map(function(W) {
                    var Z = R.includes(W), ue = Z ? I : b, ke = 0;
                    return W !== 0 && (ke += g ? b * W : I + b * (W - 1)), {
                      type: "rect",
                      x: ke,
                      y: 0,
                      height: C,
                      width: ue,
                      index: W,
                      data: {
                        name: "selectionArea",
                        value: u[W]
                      }
                    };
                  });
                }
              }, {
                key: "makeRectResponderModelForCoordinateType",
                value: function(u, h) {
                  var v = Qb(u, this.rect);
                  return v.map(function(g, b) {
                    return Qf(Qf({}, g), {}, {
                      data: {
                        name: "selectionArea",
                        value: h[b]
                      }
                    });
                  });
                }
              }, {
                key: "onMousemove",
                value: function(u) {
                  var h = u.responders, v = u.mousePosition;
                  if (h.length) {
                    if (this.dragStartPosition && !this.isDragging) {
                      var g = v.x, b = this.dragStartPosition.x;
                      this.isDragging = Math.abs(b - g) > MR;
                    }
                    if (this.isDragging) {
                      var C = this.dragStartPoint.index, R = h[0].index, I = [C, R].sort(qe), W = yR(I, 2), Z = W[0], ue = W[1], ke = this.responders.slice(Z, ue + 1);
                      this.models.selectionArea = pR(ke.map(function(Ee) {
                        return Qf(Qf({}, Ee), {}, {
                          x: Ee.x,
                          y: 0,
                          type: "rect",
                          color: "rgba(0, 0, 0, 0.2)"
                        });
                      })), this.eventBus.emit("needDraw");
                    }
                  }
                }
              }, {
                key: "onMouseoutComponent",
                value: function() {
                  this.resetSelectionArea();
                }
              }]), a;
            }(Lr);
            function td(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? td = function(a) {
                return typeof a;
              } : td = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, td(t);
            }
            function RR(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function DR(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function PR(t, n, a) {
              return n && DR(t.prototype, n), t;
            }
            function LR(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Zv(t, n);
            }
            function Zv(t, n) {
              return Zv = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Zv(t, n);
            }
            function IR(t) {
              var n = NR();
              return function() {
                var o = rd(t), u;
                if (n) {
                  var h = rd(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return _R(this, u);
              };
            }
            function _R(t, n) {
              return n && (td(n) === "object" || typeof n == "function") ? n : Qv(t);
            }
            function Qv(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function NR() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function rd(t) {
              return rd = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, rd(t);
            }
            function m0(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var em = /* @__PURE__ */ function(t) {
              LR(a, t);
              var n = IR(a);
              function a() {
                var o;
                RR(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), m0(Qv(o), "responders", void 0), m0(Qv(o), "models", void 0), o;
              }
              return PR(a, [{
                key: "initialize",
                value: function() {
                  this.type = "resetButton", this.name = "resetButton";
                }
              }, {
                key: "onClick",
                value: function(u) {
                  var h = u.responders;
                  h.length && (this.eventBus.emit("resetZoom"), this.store.dispatch("resetZoom"));
                }
              }, {
                key: "render",
                value: function(u, h) {
                  var v = u.options, g = u.layout;
                  ov(v) && (this.rect = g.resetButton, this.isShow = h.isLineTypeSeriesZooming, this.models = this.isShow ? [{
                    type: "resetButton",
                    x: 0,
                    y: 0
                  }] : [], this.responders = this.isShow ? [{
                    type: "rect",
                    x: 0,
                    y: 0,
                    width: sn,
                    height: sn
                  }] : []);
                }
              }]), a;
            }(Lr);
            function nd(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? nd = function(a) {
                return typeof a;
              } : nd = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, nd(t);
            }
            function g0(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function y0(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? g0(Object(a), !0).forEach(function(o) {
                  al(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : g0(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function BR(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function FR(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function zR(t, n, a) {
              return n && FR(t.prototype, n), t;
            }
            function HR(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && tm(t, n);
            }
            function tm(t, n) {
              return tm = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, tm(t, n);
            }
            function jR(t) {
              var n = $R();
              return function() {
                var o = id(t), u;
                if (n) {
                  var h = id(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return WR(this, u);
              };
            }
            function WR(t, n) {
              return n && (nd(n) === "object" || typeof n == "function") ? n : il(t);
            }
            function il(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function $R() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function id(t) {
              return id = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, id(t);
            }
            function al(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var Gn = /* @__PURE__ */ function(t) {
              HR(a, t);
              var n = jR(a);
              function a() {
                var o;
                BR(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), al(il(o), "models", {}), al(il(o), "seriesModels", {}), al(il(o), "activeSeriesNames", {}), al(il(o), "isShow", !1), al(il(o), "renderSelectedSeries", function(g) {
                  var b = g.name, C = g.alias, R = o.getSelectedSeriesModelsForRendering(g);
                  o.models[C || b] = Zb(y0(y0({}, g), {}, {
                    models: R,
                    comparisonModel: o.models[C || b]
                  })) ? [] : R, o.seriesModels[C || b] = o.getSelectedSeriesModels(g), o.isShow = !!Object.values(o.models).flatMap(function(I) {
                    return I;
                  }).length, o.eventBus.emit(o.isShow ? "selectSeries" : "unselectSeries", ne(o.seriesModels)), o.activeSeriesNames[b] = o.getSeriesNames(g.models, b), o.setActiveState();
                }), al(il(o), "resetSelectedSeries", function() {
                  o.models = {}, o.store.dispatch("setAllLegendActiveState", !0);
                }), o;
              }
              return zR(a, [{
                key: "getSeriesNames",
                value: function(u, h) {
                  var v = this, g = [];
                  return Ve(["line", "area", "radar", "bubble", "scatter", "bullet", "boxPlot"], h) ? u.forEach(function(b) {
                    var C = b.name;
                    C && g.push(C);
                  }) : Ve(["bar", "column", "radialBar"], h) ? u.forEach(function(b) {
                    var C, R = (C = b.data) === null || C === void 0 ? void 0 : C.label;
                    R && g.push(R);
                  }) : h === "pie" && Object.keys(this.models).flatMap(function(b) {
                    return v.models[b];
                  }).forEach(function(b) {
                    var C, R, I = ((C = b.data) === null || C === void 0 ? void 0 : C.rootParentName) || ((R = b.data) === null || R === void 0 ? void 0 : R.label);
                    I && g.push(I);
                  }), g;
                }
              }, {
                key: "getSelectedSeriesModelsForRendering",
                value: function(u) {
                  var h = u.models, v = u.eventDetectType, g = u.name, b = h;
                  return (g === "column" || g === "bar" || g === "bullet") && v === "grouped" ? b = h.filter(function(C) {
                    return !C.data;
                  }) : g === "radialBar" && v === "grouped" && (b = h.filter(function(C) {
                    return !C.data;
                  })), b;
                }
              }, {
                key: "getSelectedSeriesModels",
                value: function(u) {
                  var h = u.models, v = u.eventDetectType, g = u.name, b = h;
                  return (g === "column" || g === "bar" || g === "bullet") && v === "grouped" ? b = h.filter(function(C) {
                    return C.data;
                  }) : g === "radialBar" && v === "grouped" && (b = h.filter(function(C) {
                    return C.data;
                  })), b;
                }
              }, {
                key: "setActiveState",
                value: function() {
                  var u = this;
                  this.isShow ? (this.store.dispatch("setAllLegendActiveState", !1), Object.values(this.activeSeriesNames).forEach(function(h) {
                    h.forEach(function(v) {
                      u.store.dispatch("setLegendActiveState", {
                        name: v,
                        active: !0
                      });
                    });
                  })) : this.store.dispatch("setAllLegendActiveState", !0), this.eventBus.emit("needDraw");
                }
              }, {
                key: "initialize",
                value: function() {
                  this.type = "selectedSeries", this.name = "selectedSeries", this.eventBus.on("renderSelectedSeries", this.renderSelectedSeries), this.eventBus.on("resetSelectedSeries", this.resetSelectedSeries);
                }
              }, {
                key: "render",
                value: function(u) {
                  var h = u.layout;
                  this.rect = h.plot;
                }
              }]), a;
            }(Lr);
            function ad(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? ad = function(a) {
                return typeof a;
              } : ad = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, ad(t);
            }
            function b0(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function S0(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? b0(Object(a), !0).forEach(function(o) {
                  im(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : b0(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function UR(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function VR(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function GR(t, n, a) {
              return n && VR(t.prototype, n), t;
            }
            function YR(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && rm(t, n);
            }
            function rm(t, n) {
              return rm = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, rm(t, n);
            }
            function qR(t) {
              var n = XR();
              return function() {
                var o = od(t), u;
                if (n) {
                  var h = od(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return KR(this, u);
              };
            }
            function KR(t, n) {
              return n && (ad(n) === "object" || typeof n == "function") ? n : nm(t);
            }
            function nm(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function XR() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function od(t) {
              return od = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, od(t);
            }
            function im(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var Yn = /* @__PURE__ */ function(t) {
              YR(a, t);
              var n = qR(a);
              function a() {
                var o;
                UR(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), im(nm(o), "models", void 0), im(nm(o), "theme", void 0), o;
              }
              return GR(a, [{
                key: "initialize",
                value: function() {
                  this.type = "background", this.name = "background";
                }
              }, {
                key: "render",
                value: function(u) {
                  var h = u.layout, v = u.theme, g = h.chart, b = g.width, C = g.height;
                  this.theme = v.chart, this.rect = {
                    x: 0,
                    y: 0,
                    width: b,
                    height: C
                  }, this.models = [S0(S0({
                    type: "rect"
                  }, this.rect), {}, {
                    color: this.theme.backgroundColor
                  })];
                }
              }]), a;
            }(Lr);
            function sd(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? sd = function(a) {
                return typeof a;
              } : sd = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, sd(t);
            }
            function w0(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function x0(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? w0(Object(a), !0).forEach(function(o) {
                  O0(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : w0(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function JR(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function ZR(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function QR(t, n, a) {
              return n && ZR(t.prototype, n), t;
            }
            function eD(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && am(t, n);
            }
            function am(t, n) {
              return am = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, am(t, n);
            }
            function tD(t) {
              var n = nD();
              return function() {
                var o = ld(t), u;
                if (n) {
                  var h = ld(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return rD(this, u);
              };
            }
            function rD(t, n) {
              return n && (sd(n) === "object" || typeof n == "function") ? n : k0(t);
            }
            function k0(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function nD() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function ld(t) {
              return ld = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, ld(t);
            }
            function O0(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var iD = "No data to display", qn = /* @__PURE__ */ function(t) {
              eD(a, t);
              var n = tD(a);
              function a() {
                var o;
                JR(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), O0(k0(o), "models", void 0), o;
              }
              return QR(a, [{
                key: "initialize",
                value: function() {
                  this.type = "noDataText", this.name = "noDataText";
                }
              }, {
                key: "getCenterPosition",
                value: function(u, h) {
                  var v = ni(u, h), g = Vs(u, h);
                  return {
                    x: (this.rect.width - v) / 2,
                    y: (this.rect.height - g) / 2
                  };
                }
              }, {
                key: "render",
                value: function(u) {
                  var h, v, g = u.layout, b = u.series, C = u.options, R = u.theme, I = (h = C == null || (v = C.lang) === null || v === void 0 ? void 0 : v.noData) !== null && h !== void 0 ? h : iD, W = R.noData, Z = an(W), ue = W.color;
                  this.isShow = pv(b), this.rect = g.plot, this.models = [x0(x0({
                    type: "label"
                  }, this.getCenterPosition(I, Z)), {}, {
                    text: I,
                    style: [{
                      font: Z,
                      fillStyle: ue
                    }]
                  })];
                }
              }]), a;
            }(Lr);
            function C0(t, n) {
              var a = n.color, o = n.lineWidth, u = n.points, h = n.dashSegments, v = h === void 0 ? [] : h;
              t.lineCap = "round", t.beginPath(), v && ta(t, v);
              var g = !1;
              u.forEach(function(b, C) {
                var R, I;
                if (Oe(b)) {
                  g = !1;
                  return;
                }
                if (!g) {
                  t.moveTo(b.x, b.y), g = !0;
                  return;
                }
                if (b.controlPoint && (R = u[C - 1]) !== null && R !== void 0 && (I = R.controlPoint) !== null && I !== void 0 && I.next) {
                  var W = u[C - 1].controlPoint.next, Z = W.x, ue = W.y, ke = b.controlPoint, Ee = b.x, Le = b.y;
                  t.bezierCurveTo(Z, ue, ke.prev.x, ke.prev.y, Ee, Le);
                } else
                  t.lineTo(b.x, b.y);
              }), Ii(t, {
                lineWidth: o,
                strokeStyle: a
              }), t.closePath(), ta(t, []);
            }
            function om(t, n) {
              var a = n.fillColor;
              t.beginPath(), C0(t, n), Li(t, a), t.closePath();
            }
            function T0(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function ud(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? T0(Object(a), !0).forEach(function(o) {
                  aD(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : T0(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function aD(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function oD(t, n, a) {
              var o = n.x, u = n.y, h = n.theme, v = h.color, g = h.lineWidth, b = a / 3, C = o + b, R = u + b, I = o + b * 2, W = u + b * 2, Z = [{
                x: C,
                y: R,
                x2: I,
                y2: W
              }, {
                x: C,
                y: W,
                x2: I,
                y2: R
              }];
              Z.forEach(function(ue) {
                Wr(t, ud(ud({
                  type: "line"
                }, ue), {}, {
                  strokeStyle: v,
                  lineWidth: g
                }));
              });
            }
            function sD(t, n, a) {
              var o = n.x, u = n.y, h = n.theme, v = h.color, g = h.width, b = h.height, C = h.gap, R = (a - g) / 2, I = (a - (b * 3 + C * 2)) / 2, W = o + R, Z = [{
                x: W,
                y: u + I
              }, {
                x: W,
                y: u + I + b + C
              }, {
                x: W,
                y: u + I + (b + C) * 2
              }];
              Z.forEach(function(ue) {
                cn(t, ud(ud({
                  type: "rect"
                }, ue), {}, {
                  color: v,
                  width: g,
                  height: b
                }));
              });
            }
            function lD(t, n) {
              var a = n.opened, o = n.x, u = n.y, h = n.theme, v = h, g = v.borderColor, b = v.backgroundColor, C = v.borderWidth, R = v.borderRadius, I = v.xIcon, W = v.dotIcon, Z = o + C, ue = u + C, ke = sn - 2 * C;
              hr(t, {
                x: Z,
                y: ue,
                fill: b,
                stroke: g,
                width: ke,
                height: ke,
                radius: R,
                lineWidth: C
              }), a ? oD(t, {
                x: Z,
                y: ue,
                theme: I
              }, ke) : sD(t, {
                x: Z,
                y: ue,
                theme: W
              }, ke);
            }
            var A0 = 3, cd = 6;
            function uD(t, n) {
              var a = n.x, o = n.y, u = a + sn / 2, h = o + sn / 2, v = sn / 10, g = "#545454";
              Rr(t, {
                x: u,
                y: h,
                radius: v * 2,
                angle: {
                  start: 0,
                  end: Math.PI / 2
                },
                color: "transparent",
                style: [{
                  lineWidth: 2,
                  strokeStyle: g
                }]
              });
              var b = u + v * 2, C = h, R = [{
                x: b - cd / 2,
                y: C
              }, {
                x: b + cd / 2,
                y: C
              }, {
                x: b,
                y: C + A0
              }];
              om(t, {
                points: R,
                lineWidth: 1,
                color: g,
                fillColor: g
              });
            }
            function cD(t, n) {
              var a = 4, o = sn / 7, u = n.x, h = n.y, v = u + sn / 2, g = h + sn / 2, b = "#545454";
              Wr(t, {
                lineWidth: 2,
                x: v - a / 2,
                y: g + o,
                x2: v + a / 2,
                y2: g + o,
                strokeStyle: b
              }), Wr(t, {
                lineWidth: 2,
                x: v - a / 2,
                y: g - o,
                x2: v + a / 2,
                y2: g - o,
                strokeStyle: b
              }), Rr(t, {
                x: v + a / 2,
                y: g,
                radius: o,
                angle: {
                  start: Math.PI / 2,
                  end: Math.PI * 3 / 2
                },
                color: "transparent",
                style: [{
                  lineWidth: 2,
                  strokeStyle: b
                }]
              });
              var C = v - a / 2, R = g - o, I = [{
                x: C - A0,
                y: R
              }, {
                x: C,
                y: R - cd / 2
              }, {
                x: C,
                y: R + cd / 2
              }];
              om(t, {
                points: I,
                lineWidth: 1,
                color: b,
                fillColor: b
              });
            }
            function fD(t, n) {
              var a = n.x, o = n.y;
              hr(t, {
                x: a,
                y: o,
                fill: "#f4f4f4",
                stroke: "#f4f4f4",
                width: sn,
                height: sn,
                radius: 5
              }), cD(t, {
                x: a,
                y: o
              });
            }
            function dD(t, n) {
              var a = n.x, o = n.y;
              hr(t, {
                x: a,
                y: o,
                fill: "#f4f4f4",
                stroke: "#f4f4f4",
                width: sn,
                height: sn,
                radius: 5
              }), uD(t, {
                x: a,
                y: o
              });
            }
            function fd(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? fd = function(a) {
                return typeof a;
              } : fd = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, fd(t);
            }
            function E0(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function hD(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? E0(Object(a), !0).forEach(function(o) {
                  pD(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : E0(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function pD(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function vD(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function mD(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function gD(t, n, a) {
              return n && mD(t.prototype, n), t;
            }
            function dd(t, n, a) {
              return typeof Reflect < "u" && Reflect.get ? dd = Reflect.get : dd = function(u, h, v) {
                var g = yD(u, h);
                if (g) {
                  var b = Object.getOwnPropertyDescriptor(g, h);
                  return b.get ? b.get.call(v) : b.value;
                }
              }, dd(t, n, a || t);
            }
            function yD(t, n) {
              for (; !Object.prototype.hasOwnProperty.call(t, n) && (t = Yl(t), t !== null); )
                ;
              return t;
            }
            function bD(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && sm(t, n);
            }
            function sm(t, n) {
              return sm = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, sm(t, n);
            }
            function SD(t) {
              var n = kD();
              return function() {
                var o = Yl(t), u;
                if (n) {
                  var h = Yl(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return wD(this, u);
              };
            }
            function wD(t, n) {
              return n && (fd(n) === "object" || typeof n == "function") ? n : xD(t);
            }
            function xD(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function kD() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function Yl(t) {
              return Yl = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, Yl(t);
            }
            var OD = /* @__PURE__ */ function(t) {
              bD(a, t);
              var n = SD(a);
              function a(o) {
                var u;
                return vD(this, a), n.call(this, {
                  el: o.el,
                  options: o.options,
                  series: {
                    line: o.data.series
                  },
                  categories: (u = o.data) === null || u === void 0 ? void 0 : u.categories,
                  modules: [Vi, Gi, Xa, Za]
                });
              }
              return gD(a, [{
                key: "initialize",
                value: function() {
                  dd(Yl(a.prototype), "initialize", this).call(this), this.componentManager.add(Yn), this.componentManager.add(Un), this.componentManager.add(Qa), this.componentManager.add(Oi), this.componentManager.add(Hf), this.componentManager.add(Vr, {
                    name: "yAxis"
                  }), this.componentManager.add(Vr, {
                    name: "xAxis"
                  }), this.componentManager.add(Vr, {
                    name: "secondaryYAxis"
                  }), this.componentManager.add(Yi), this.componentManager.add(Yr, {
                    name: "xAxis"
                  }), this.componentManager.add(Yr, {
                    name: "yAxis"
                  }), this.componentManager.add(Yr, {
                    name: "secondaryYAxis"
                  }), this.componentManager.add(Hn, {
                    chartEl: this.el
                  }), this.componentManager.add(Vn), this.componentManager.add(Gn), this.componentManager.add($n, {
                    chartEl: this.el
                  }), this.componentManager.add(Gl), this.componentManager.add(em), this.componentManager.add(qn), this.painter.addGroups([p, d, k, w, f, O, m, T]);
                }
                /**
                 * Add data.
                 * @param {Array<number|Object|Array>} data - Array of data to be added.
                 * @param {string} category - Category to be added.
                 * @api
                 * @example
                 * chart.addData([10, 20], '6');
                 */
              }, {
                key: "addData",
                value: function(u, h) {
                  var v;
                  (v = this.store.state.options.series) !== null && v !== void 0 && v.showDot && (this.animationControlFlag.updating = !0), this.resetSeries(), this.store.dispatch("addData", {
                    data: u,
                    category: h
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<number|Object|Array>} data.data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function(u) {
                  this.resetSeries(), this.store.dispatch("addSeries", {
                    data: u
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set.
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['1', '2', '3'],
                 *   series: [
                 *     {
                 *       name: 'new series',
                 *       data: [1, 2, 3],
                 *     },
                 *     {
                 *       name: 'new series2',
                 *       data: [4, 5, 6],
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function(u) {
                  var h = u.categories, v = u.series;
                  this.resetSeries(), this.store.dispatch("setData", {
                    series: {
                      line: v
                    },
                    categories: h
                  });
                }
                /**
                 * Add plot line.
                 * @param {Object} data - Plot info.
                 *    @param {string|number} data.value - The value where the plot line will be drawn.
                 *    @param {string} data.color - Plot line color.
                 *    @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
                 * @api
                 * @example
                 * chart.addPlotLine({
                 *   value: 2,
                 *   color: '#00ff22',
                 *   id: 'plot-1',
                 * });
                 */
              }, {
                key: "addPlotLine",
                value: function(u) {
                  this.store.dispatch("addPlotLine", {
                    data: u
                  });
                }
                /**
                 * Remove plot line with id.
                 * @param {string} id - Id of the plot line to be removed.
                 * @api
                 * @example
                 * chart.removePlotLine('plot-1');
                 */
              }, {
                key: "removePlotLine",
                value: function(u) {
                  this.store.dispatch("removePlotLine", {
                    id: u
                  });
                }
                /**
                 * Add plot band.
                 * @param {Object} data - Plot info.
                 *   @param {Array<string|number>} data.range - The range to be drawn.
                 *   @param {string} data.color - Plot band color.
                 *   @param {string} [data.id] - Plot id. The value on which the removePlotBand is based.
                 * @api
                 * @example
                 * chart.addPlotBand({
                 *   value: [2, 4],
                 *   color: '#00ff22',
                 *   id: 'plot-1',
                 * });
                 */
              }, {
                key: "addPlotBand",
                value: function(u) {
                  this.store.dispatch("addPlotBand", {
                    data: u
                  });
                }
                /**
                 * Remove plot band with id.
                 * @param {string} id - id of the plot band to be removed
                 * @api
                 * @example
                 * chart.removePlotBand('plot-1');
                 */
              }, {
                key: "removePlotBand",
                value: function(u) {
                  this.store.dispatch("removePlotBand", {
                    id: u
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !1
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !0
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *     date: { format: 'yy/MM' },
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("initOptions", u);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("updateOptions", u);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only seriesIndex is needed.
                 *      @param {number} [seriesInfo.seriesIndex] - Index of series.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2});
                 */
              }, {
                key: "showTooltip",
                value: function(u) {
                  this.eventBus.emit("showTooltip", hD({}, u));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function() {
                  this.eventBus.emit("hideTooltip");
                }
              }]), a;
            }(Wn);
            function hd(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? hd = function(a) {
                return typeof a;
              } : hd = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, hd(t);
            }
            function M0(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function Dn(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? M0(Object(a), !0).forEach(function(o) {
                  eo(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : M0(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function CD(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function TD(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function AD(t, n, a) {
              return n && TD(t.prototype, n), t;
            }
            function ED(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && lm(t, n);
            }
            function lm(t, n) {
              return lm = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, lm(t, n);
            }
            function MD(t) {
              var n = DD();
              return function() {
                var o = pd(t), u;
                if (n) {
                  var h = pd(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return RD(this, u);
              };
            }
            function RD(t, n) {
              return n && (hd(n) === "object" || typeof n == "function") ? n : Ao(t);
            }
            function Ao(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function DD() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function pd(t) {
              return pd = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, pd(t);
            }
            function eo(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function PD(t) {
              var n = t.alias, a = t.renderOptions, o = t.radiusRangeMap, u = t.pieIndex, h = t.radiusRanges, v = t.totalPieAliasCount, g = Object.keys(o).length, b = a.defaultRadius, C = b === void 0 ? 0 : b, R = a.radiusRange, I = R.inner, W = R.outer;
              if (!o[n])
                if (g) {
                  var ue;
                  if (u && h[u - 1].outer && (I = h[u - 1].outer), (ue = h[u + 1]) !== null && ue !== void 0 && ue.inner)
                    W = h[u + 1].inner;
                  else if (u === v - 1)
                    W = C;
                  else {
                    var ke, Ee, Le, je, Ke = (C - ((ke = (Ee = h[u - 1]) === null || Ee === void 0 ? void 0 : Ee.outer) !== null && ke !== void 0 ? ke : 0) - ((Le = (je = h[u + 1]) === null || je === void 0 ? void 0 : je.inner) !== null && Le !== void 0 ? Le : 0)) / (v - g);
                    W = I + Ke;
                  }
                } else {
                  var Z = C / v;
                  I = u * Z, W = (u + 1) * Z;
                }
              return {
                inner: I,
                outer: W
              };
            }
            function LD(t, n, a) {
              var o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0.85, u = Number((t * Math.pow(o, n)).toFixed(2));
              return Number(Math.pow(u, a + 1).toFixed(2));
            }
            function R0(t, n, a) {
              var o, u, h = [{
                hasOuterLabel: n.visible && n.anchor === "outer",
                labels: ["00.00%"],
                // up to 5 digits
                theme: a
              }, {
                hasOuterLabel: ((o = n.pieSeriesName) === null || o === void 0 ? void 0 : o.visible) && ((u = n.pieSeriesName) === null || u === void 0 ? void 0 : u.anchor) === "outer",
                labels: t,
                theme: a.pieSeriesName
              }];
              return h.reduce(function(v, g) {
                var b = v.width, C = v.height, R = g.hasOuterLabel, I = g.labels, W = g.theme;
                if (R) {
                  var Z = Yo(I, 0, Si(W)), ue = Z.maxLabelWidth, ke = Z.maxLabelHeight;
                  return {
                    width: Math.max(ue + Bf, b),
                    height: Math.max(ke + Bf, C)
                  };
                }
                return v;
              }, {
                width: 0,
                height: 0
              });
            }
            var gc = /* @__PURE__ */ function(t) {
              ED(a, t);
              var n = MD(a);
              function a() {
                var o;
                CD(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), eo(Ao(o), "models", {
                  series: []
                }), eo(Ao(o), "drawModels", void 0), eo(Ao(o), "responders", void 0), eo(Ao(o), "activatedResponders", []), eo(Ao(o), "alias", void 0), eo(Ao(o), "theme", void 0), eo(Ao(o), "onMouseoutComponent", function() {
                  o.eventBus.emit("seriesPointHovered", {
                    models: [],
                    name: o.alias || o.name
                  }), o.eventBus.emit("renderHoveredSeries", {
                    models: [],
                    name: o.alias || o.name
                  }), o.eventBus.emit("needDraw");
                }), eo(Ao(o), "selectSeries", function(g) {
                  var b = g.seriesIndex, C = g.name;
                  if (!(!Me(b) || !we(C) && C !== o.alias)) {
                    var R = o.responders[b];
                    if (!R)
                      throw new Error(ve.SELECT_SERIES_API_INDEX_ERROR);
                    o.eventBus.emit("renderSelectedSeries", {
                      models: o.getResponderModelsWithTheme([R], "select"),
                      name: o.name,
                      alias: o.alias
                    }), o.eventBus.emit("needDraw");
                  }
                }), eo(Ao(o), "showTooltip", function(g) {
                  var b = g.seriesIndex, C = g.name;
                  if (!(!Me(b) || !we(C) && C !== o.alias)) {
                    var R = [o.responders[b]];
                    R.length && (o.eventBus.emit("renderHoveredSeries", {
                      models: o.getResponderModelsWithTheme(R, "hover"),
                      name: o.name,
                      alias: o.alias
                    }), o.activatedResponders = o.makeTooltipResponder(R), o.eventBus.emit("seriesPointHovered", {
                      models: o.activatedResponders,
                      name: o.alias || o.name
                    }), o.eventBus.emit("needDraw"));
                  }
                }), o;
              }
              return AD(a, [{
                key: "initUpdate",
                value: function(u) {
                  if (this.drawModels) {
                    var h, v = this.models.series.findIndex(function(g) {
                      var b = g.clockwise, C = g.degree, R = C.start, I = C.end, W = g.totalAngle;
                      return h = b ? W * u : Dr - W * u, go(b, R, I, h);
                    });
                    this.syncEndAngle(v < 0 ? this.models.series.length : v), ~v && (this.drawModels.series[v].degree.end = h);
                  }
                }
              }, {
                key: "syncEndAngle",
                value: function(u) {
                  if (!(u < 1))
                    for (var h = 0; h < u; h += 1) {
                      var v = this.models.series[h].degree.end;
                      this.drawModels.series[h].degree.end !== v && (this.drawModels.series[h].degree.end = v);
                    }
                }
              }, {
                key: "initialize",
                value: function(u) {
                  var h;
                  this.type = "series", this.name = "pie", this.alias = (h = u == null ? void 0 : u.alias) !== null && h !== void 0 ? h : "", this.eventBus.on("selectSeries", this.selectSeries), this.eventBus.on("showTooltip", this.showTooltip), this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "render",
                value: function(u) {
                  var h, v = this, g = u.layout, b = u.series, C = u.legend, R = u.options, I = u.nestedPieSeries, W = u.theme, Z = (h = u.categories) !== null && h !== void 0 ? h : [];
                  if (!b.pie)
                    throw new Error(ve.noDataError(this.name));
                  var ue = W.series.pie;
                  this.theme = this.alias ? ue[this.alias] : ue, this.rect = g.plot, this.activeSeriesMap = Ea(C), this.selectable = this.getSelectableOption(R);
                  var ke, Ee, Le = Ma(R, this.alias);
                  if (I) {
                    var je = I[this.alias].data, Ke = Object.keys(I), ut = Ke.findIndex(function(yr) {
                      return yr === v.alias;
                    }), bt = _e(Ke), mt = I[bt], Rt = R0(mt.data.map(function(yr) {
                      var Ar = yr.name;
                      return Ar;
                    }), Ma(R, bt), this.theme.dataLabels), Dt = this.getRenderOptionsMap(R, Ke, Rt);
                    ke = this.renderPieModel(je, Dt[this.alias], ut), Ee = Tt(je, Z == null ? void 0 : Z[ut]);
                  } else {
                    var Lt, Wt = (Lt = b.pie) === null || Lt === void 0 ? void 0 : Lt.data, Qt = R0(Wt.map(function(yr) {
                      var Ar = yr.name;
                      return Ar;
                    }), Le, this.theme.dataLabels), or = Qt.width, lr = Qt.height, xr = this.makeRenderOptions(R, or, lr);
                    ke = this.renderPieModel(Wt, xr), Ee = Tt(Wt, Z == null ? void 0 : Z[0]);
                  }
                  if (this.models.series = ke, this.drawModels || (this.drawModels = {
                    series: this.models.series.map(function(yr) {
                      return Dn(Dn({}, yr), {}, {
                        degree: Dn(Dn({}, yr.degree), {}, {
                          end: yr.degree.start
                        })
                      });
                    })
                  }), Le.visible) {
                    var br = ke.map(function(yr) {
                      return Dn(Dn({}, yr), {}, {
                        value: "".concat(Ht(yr.percentValue)),
                        theme: v.theme.dataLabels
                      });
                    });
                    this.renderDataLabels(br, this.alias);
                  }
                  this.responders = ke.map(function(yr, Ar) {
                    return Dn(Dn({}, yr), {}, {
                      type: "sector",
                      radius: yr.radius,
                      seriesIndex: Ar,
                      data: Dn(Dn({}, Ee[Ar]), {}, {
                        percentValue: yr.percentValue
                      }),
                      color: cr(yr.color, 1)
                    });
                  });
                }
              }, {
                key: "getRadiusRangeMap",
                value: function(u, h) {
                  var v = this;
                  return h.reduce(function(g, b) {
                    var C = v.getOptions(u, b).series;
                    return C != null && C.radiusRange && (g[b] = C == null ? void 0 : C.radiusRange), g;
                  }, {});
                }
              }, {
                key: "getRenderOptionsMap",
                value: function(u, h, v) {
                  var g = this.initRenderOptionsMap(u, h, v), b = this.getRadiusRangeMap(u, h);
                  return h.forEach(function(C, R) {
                    var I = Object.values(g).map(function(W) {
                      var Z = W.radiusRange;
                      return Z;
                    });
                    g[C].radiusRange = PD({
                      alias: C,
                      renderOptions: g[C],
                      radiusRangeMap: b,
                      pieIndex: R,
                      radiusRanges: I,
                      totalPieAliasCount: h.length
                    });
                  }), g;
                }
              }, {
                key: "initRenderOptionsMap",
                value: function(u, h, v) {
                  var g = this, b = v.width, C = v.height;
                  return h.reduce(function(R, I) {
                    return Dn(Dn({}, R), {}, eo({}, I, g.makeRenderOptions(g.getOptions(u, I), b, C)));
                  }, {});
                }
              }, {
                key: "getOptions",
                value: function(u, h) {
                  var v = Dn({}, u);
                  return v != null && v.series && h && (v.series = Dn(Dn({}, v.series), v.series[h])), v;
                }
              }, {
                key: "makeRenderOptions",
                value: function(u) {
                  var h, v, g, b, C, R, I, W, Z, ue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, ke = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, Ee = u.series, Le = (h = Ee == null ? void 0 : Ee.clockwise) !== null && h !== void 0 ? h : !0, je = (v = Ee == null || (g = Ee.angleRange) === null || g === void 0 ? void 0 : g.start) !== null && v !== void 0 ? v : gn, Ke = (b = Ee == null || (C = Ee.angleRange) === null || C === void 0 ? void 0 : C.end) !== null && b !== void 0 ? b : Dr, ut = Pe(Le, je, Ke), bt = $e(Le, je, Ke), mt = this.rect, Rt = mt.width, Dt = mt.height, Lt = xi(this.rect, bt, ue, ke), Wt = be(Lt, (R = Ee == null || (I = Ee.radiusRange) === null || I === void 0 ? void 0 : I.inner) !== null && R !== void 0 ? R : 0), Qt = be(Lt, (W = Ee == null || (Z = Ee.radiusRange) === null || Z === void 0 ? void 0 : Z.outer) !== null && W !== void 0 ? W : this.alias ? 0 : Lt), or = Rt / 2, lr = bt ? st(this.rect.height, Le) : Dt / 2;
                  return {
                    clockwise: Le,
                    cx: or,
                    cy: lr,
                    drawingStartAngle: je - ri,
                    radiusRange: {
                      inner: Wt,
                      outer: Qt
                    },
                    angleRange: {
                      start: je,
                      end: Ke
                    },
                    totalAngle: ut,
                    defaultRadius: Lt
                  };
                }
              }, {
                key: "renderPieModel",
                value: function(u, h, v) {
                  var g = this, b = [], C = u.reduce(function(mt, Rt) {
                    var Dt = Rt.data;
                    return mt + (Dt ?? 0);
                  }, 0), R = h.clockwise, I = h.cx, W = h.cy, Z = h.drawingStartAngle, ue = h.radiusRange, ke = ue.inner, Ee = ue.outer, Le = h.totalAngle, je = R ? gn : Dr, Ke = this.theme, ut = Ke.lineWidth, bt = Ke.strokeStyle;
                  return u.forEach(function(mt, Rt) {
                    var Dt = g.alias ? g.getAliasSeriesColor(mt, u, v) : g.getSeriesColor(mt), Lt = mt.data, Wt = mt.name;
                    if (Lt) {
                      var Qt = Math.max(Lt / C * Le, 1) * (R ? 1 : -1), or = Lt / C * 100, lr = b[b.length - 1], xr = Rt && lr ? lr.degree.end : je, br = R ? Math.min(xr + Qt, Dr) : Math.max(xr + Qt, gn);
                      b.push({
                        type: "sector",
                        name: Wt,
                        color: Dt,
                        x: I,
                        y: W,
                        degree: {
                          start: xr,
                          end: br
                        },
                        radius: {
                          inner: ke,
                          outer: Ee
                        },
                        value: Lt,
                        style: [{
                          strokeStyle: bt
                        }],
                        lineWidth: ut,
                        clockwise: R,
                        drawingStartAngle: Z,
                        totalAngle: Le,
                        percentValue: or
                      });
                    }
                  }), b;
                }
              }, {
                key: "makeTooltipResponder",
                value: function(u) {
                  var h = this;
                  return u.map(function(v) {
                    return Dn(Dn({}, v), ka(xa("center", h.models.series[v.seriesIndex])));
                  });
                }
              }, {
                key: "onMousemove",
                value: function(u) {
                  var h = u.responders;
                  this.eventBus.emit("renderHoveredSeries", {
                    models: this.getResponderModelsWithTheme(h, "hover"),
                    name: this.alias || this.name
                  }), this.activatedResponders = this.makeTooltipResponder(h), this.eventBus.emit("seriesPointHovered", {
                    models: this.activatedResponders,
                    name: this.alias || this.name
                  }), this.eventBus.emit("needDraw");
                }
              }, {
                key: "onClick",
                value: function(u) {
                  var h = u.responders;
                  this.selectable && (this.eventBus.emit("renderSelectedSeries", {
                    models: this.getResponderModelsWithTheme(h, "select"),
                    name: this.name,
                    alias: this.alias
                  }), this.eventBus.emit("needDraw"));
                }
              }, {
                key: "getResponderModelsWithTheme",
                value: function(u, h) {
                  var v = this.theme[h], g = v.lineWidth, b = this.theme.lineWidth === g, C = b ? 0 : g * 0.5;
                  return u.map(function(R) {
                    var I;
                    return Dn(Dn({}, R), {}, {
                      color: (I = v == null ? void 0 : v.color) !== null && I !== void 0 ? I : R.color,
                      lineWidth: g,
                      style: [Ue(v, "strokeStyle", "shadowBlur", "shadowColor", "shadowOffsetX", "shadowOffsetY")],
                      radius: {
                        inner: Math.max(R.radius.inner - C, 0),
                        outer: R.radius.outer + C
                      }
                    });
                  });
                }
              }, {
                key: "getOpacity",
                value: function(u, h) {
                  var v = this.theme, g = v.select, b = v.areaOpacity, C = g, R = C.areaOpacity, I = C.restSeries.areaOpacity, W = u ? R : I;
                  return h ? W : b;
                }
              }, {
                key: "getIndexOfGroup",
                value: function(u, h, v) {
                  return u.filter(function(g) {
                    return h === g.parentName;
                  }).findIndex(function(g) {
                    return v === g.name;
                  });
                }
              }, {
                key: "getSeriesColor",
                value: function(u) {
                  var h = u.color, v = u.name, g = this.activeSeriesMap[v], b = this.getOpacity(g, this.hasActiveSeries());
                  return cr(h, b);
                }
              }, {
                key: "getAliasSeriesColor",
                value: function(u, h, v) {
                  var g = u.color, b = u.name, C = this.theme.select.color, R = u.rootParentName, I = u.parentName, W = this.getIndexOfGroup(h, I, b), Z = this.getAliasSeriesOpacity(R, I, v, W, b), ue = this.activeSeriesMap[R ?? b], ke = ue ? C ?? g : g;
                  return cr(ke, Z);
                }
              }, {
                key: "getAliasSeriesOpacity",
                value: function(u, h, v, g, b) {
                  var C = this.activeSeriesMap[u ?? b], R = this.getOpacity(C, this.hasActiveSeries());
                  return v && h ? LD(R, v, g) : R;
                }
              }, {
                key: "hasActiveSeries",
                value: function() {
                  return Object.values(this.activeSeriesMap).some(function(u) {
                    return !u;
                  });
                }
              }]), a;
            }(Lr);
            function ID(t, n) {
              var a = n.degree, o = a.start, u = a.end, h = n.color, v = n.style, g = n.lineWidth;
              if (o !== u) {
                var b = Math.abs(o - u) === Dr;
                if (t.beginPath(), v) {
                  var C = Pi(v, {});
                  Object.keys(C).forEach(function(R) {
                    t[R] = C[R];
                  });
                }
                b ? ND(t, n) : _D(t, n), t.closePath(), Li(t, h), g && (t.lineWidth = g, t.stroke());
              }
            }
            function _D(t, n) {
              var a = n.x, o = n.y, u = n.radius, h = u.inner, v = u.outer, g = n.degree, b = g.start, C = g.end, R = n.clockwise, I = n.drawingStartAngle;
              if (!(h < 0 || v < 0)) {
                var W = Pr(b, I), Z = Pr(C, I);
                h || t.moveTo(a, o), t.arc(a, o, v, W, Z, !R), h && t.arc(a, o, h, Z, W, R);
              }
            }
            function ND(t, n) {
              var a = n.x, o = n.y, u = n.radius, h = u.inner, v = u.outer, g = n.clockwise;
              if (t.arc(a, o, v, 0, 2 * Math.PI, !g), h) {
                var b = hn(a, o, h, 0), C = b.x, R = b.y, I = h ? C : a, W = h ? R : o;
                t.moveTo(I, W), t.arc(a, o, h, 0, 2 * Math.PI, g);
              }
            }
            function vd(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? vd = function(a) {
                return typeof a;
              } : vd = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, vd(t);
            }
            function D0(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function P0(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? D0(Object(a), !0).forEach(function(o) {
                  BD(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : D0(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function BD(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function FD(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function zD(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function HD(t, n, a) {
              return n && zD(t.prototype, n), t;
            }
            function md(t, n, a) {
              return typeof Reflect < "u" && Reflect.get ? md = Reflect.get : md = function(u, h, v) {
                var g = jD(u, h);
                if (g) {
                  var b = Object.getOwnPropertyDescriptor(g, h);
                  return b.get ? b.get.call(v) : b.value;
                }
              }, md(t, n, a || t);
            }
            function jD(t, n) {
              for (; !Object.prototype.hasOwnProperty.call(t, n) && (t = ql(t), t !== null); )
                ;
              return t;
            }
            function WD(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && um(t, n);
            }
            function um(t, n) {
              return um = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, um(t, n);
            }
            function $D(t) {
              var n = GD();
              return function() {
                var o = ql(t), u;
                if (n) {
                  var h = ql(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return UD(this, u);
              };
            }
            function UD(t, n) {
              return n && (vd(n) === "object" || typeof n == "function") ? n : VD(t);
            }
            function VD(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function GD() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function ql(t) {
              return ql = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, ql(t);
            }
            var YD = /* @__PURE__ */ function(t) {
              WD(a, t);
              var n = $D(a);
              function a(o) {
                var u = o.el, h = o.options, v = o.data;
                return FD(this, a), n.call(this, {
                  el: u,
                  options: h,
                  series: {
                    pie: v.series
                  },
                  categories: v.categories
                });
              }
              return HD(a, [{
                key: "initialize",
                value: function() {
                  md(ql(a.prototype), "initialize", this).call(this), this.componentManager.add(Yn), this.componentManager.add(Un), this.componentManager.add(Oi), this.componentManager.add(gc), this.componentManager.add(Hn, {
                    chartEl: this.el
                  }), this.componentManager.add(Vn), this.componentManager.add(Gn), this.componentManager.add(Yi), this.componentManager.add($n, {
                    chartEl: this.el
                  }), this.componentManager.add(qn), this.painter.addGroups([p, w, f, O, L, m]);
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<Object>} data.data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: 10,
                 * });
                 */
              }, {
                key: "addSeries",
                value: function(u) {
                  this.resetSeries(), this.store.dispatch("addSeries", {
                    data: u
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set.
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['A'],
                 *   series: [
                 *     {name: 'a', data: 10},
                 *     {name: 'b', data: 20},
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function(u) {
                  var h = u.categories, v = u.series;
                  this.resetSeries(), this.store.dispatch("setData", {
                    series: {
                      pie: v
                    },
                    categories: h
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !1
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !0
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("initOptions", u);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("updateOptions", u);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.seriesIndex - Index of series.
                 *      @param {number} seriesInfo.alias - alias name.
                 * @api
                 * @example
                 * chart.showTooltip({seriesIndex: 1, alias: 'name'});
                 */
              }, {
                key: "showTooltip",
                value: function(u) {
                  this.eventBus.emit("showTooltip", P0(P0({}, u), {}, {
                    state: this.store.state
                  }));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function() {
                  this.eventBus.emit("hideTooltip");
                }
              }]), a;
            }(Wn);
            function L0(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function cm(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? L0(Object(a), !0).forEach(function(o) {
                  qD(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : L0(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function qD(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function I0(t, n) {
              var a, o, u, h, v, g, b, C = t.categories, R = t.axisSize, I = t.axisLayout, W = t.options, Z = t.theme, ue = n === _r.X, ke = ue ? "x" : "y", Ee = Kp(W, n), Le = py(C[ke], W, Ee, n), je = Le.length, Ke = je ? R / je : R, ut = R / je, bt = !0, mt = je + 1, Rt = (a = (o = W[n]) === null || o === void 0 || (u = o.tick) === null || u === void 0 ? void 0 : u.interval) !== null && a !== void 0 ? a : 1, Dt = (h = (v = W[n]) === null || v === void 0 || (g = v.label) === null || g === void 0 ? void 0 : g.interval) !== null && h !== void 0 ? h : 1, Lt = Gp({
                labels: Le,
                pointOnColumn: bt,
                tickDistance: Ke,
                tickCount: mt,
                tickInterval: Rt,
                labelInterval: Dt
              }, R), Wt = qp(n, W), Qt = Yo(Le, Wt, an(Z.label)), or = Qt.maxLabelWidth, lr = Qt.maxLabelHeight, xr = {
                labels: Le,
                viewLabels: Lt,
                pointOnColumn: bt,
                isLabelAxis: ue,
                tickCount: mt,
                tickDistance: Ke,
                labelDistance: ut,
                tickInterval: Rt,
                labelInterval: Dt,
                title: Yp((b = W[n]) === null || b === void 0 ? void 0 : b.title),
                maxLabelWidth: or,
                maxLabelHeight: lr
              };
              if (n === _r.X) {
                var br, yr, Ar, qr = (br = (yr = W.xAxis) === null || yr === void 0 || (Ar = yr.label) === null || Ar === void 0 ? void 0 : Ar.margin) !== null && br !== void 0 ? br : 0, nn = jo(lr) + qr, tn = R / Lt.length, bn = vy(or, lr, tn, dy(W), I), Tn = bn.needRotateLabel, un = bn.rotationHeight, Ln = (Tn ? un : lr) + nn;
                return cm(cm(cm({}, xr), bn), {}, {
                  maxHeight: Ln,
                  offsetY: nn
                });
              }
              return xr;
            }
            var KD = {
              name: "axes",
              state: function() {
                return {
                  axes: {
                    xAxis: {},
                    yAxis: {}
                  }
                };
              },
              action: {
                setAxesData: function(n) {
                  var a = n.state, o = a.layout, u = a.theme, h = o.plot, v = h.width, g = h.height, b = a.categories, C = a.options, R = I0({
                    axisSize: v,
                    categories: b,
                    options: C,
                    theme: Go(u, _r.X),
                    axisLayout: o[_r.X]
                  }, _r.X), I = I0({
                    axisSize: g,
                    categories: b,
                    options: C,
                    theme: Go(u, _r.Y)
                  }, _r.Y), W = {
                    xAxis: R,
                    yAxis: I
                  };
                  fy(a.axes, W) && this.notify(a, "layout"), a.axes = W;
                }
              },
              computed: {},
              observe: {
                updateAxes: function() {
                  this.dispatch("setAxesData");
                }
              }
            }, XD = KD;
            function JD(t, n, a) {
              return t.heatmap ? t.heatmap.data.map(function(o, u) {
                var h = o.yCategory, v = o.data;
                return Ts(v, a).map(function(g, b) {
                  return {
                    colorValue: g,
                    category: {
                      x: n.x[b],
                      y: h
                    },
                    indexes: [b, u]
                  };
                });
              }) : [];
            }
            var ZD = {
              name: "heatmapSeriesData",
              state: function() {
                return {
                  heatmapSeries: []
                };
              },
              action: {
                setHeatmapSeriesData: function(n) {
                  var a = n.state, o = n.computed;
                  a.heatmapSeries = JD(a.series, a.categories, o.viewRange);
                }
              },
              observe: {
                updateTreemapSeriesData: function() {
                  this.dispatch("setHeatmapSeriesData");
                }
              }
            }, QD = ZD;
            function _0(t) {
              return nP(t) || rP(t) || tP(t) || eP();
            }
            function eP() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function tP(t, n) {
              if (t) {
                if (typeof t == "string") return fm(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return fm(t, n);
              }
            }
            function rP(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function nP(t) {
              if (Array.isArray(t)) return fm(t);
            }
            function fm(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            var N0 = "__TOAST_UI_TREEMAP", ol = "".concat(N0, "_ROOT");
            function B0(t, n, a, o) {
              var u, h = _e(n), v = o ? "".concat(o, "_").concat(h) : "".concat(N0, "_").concat(h), g = t.colorValue, b = [{
                label: t.label,
                hasChild: !!t.children,
                id: v,
                indexes: n,
                parentId: o || ol,
                depth: a,
                data: (u = t.data) !== null && u !== void 0 ? u : 0,
                colorValue: g
              }];
              return t.children && t.children.forEach(function(C, R) {
                Oe(C.data) || b.push.apply(b, _0(B0(C, [].concat(_0(n), [R]), a + 1, v)));
              }), b;
            }
            function iP(t) {
              t.forEach(function(n) {
                var a = n.parentId, o = n.data;
                a !== ol && (t.find(function(u) {
                  var h = u.id;
                  return h === a;
                }).data += o);
              });
            }
            function aP(t) {
              t.forEach(function(n) {
                var a = n.id, o = n.colorValue;
                if (we(o)) {
                  var u = t.filter(function(v) {
                    var g = v.parentId;
                    return g === a;
                  }), h = u.reduce(function(v, g) {
                    return v + (we(g.colorValue) ? 0 : g.colorValue);
                  }, 0);
                  n.colorValue = h / u.length;
                }
              });
            }
            function oP(t) {
              var n = t.filter(function(a) {
                var o = a.parentId;
                return o === ol;
              }).reduce(function(a, o) {
                var u = o.data;
                return a + u;
              }, 0);
              t.forEach(function(a) {
                var o = a.parentId === ol ? n : t.find(function(u) {
                  var h = u.id;
                  return h === a.parentId;
                }).data;
                a.ratio = a.data / o;
              });
            }
            function sP(t, n) {
              var a;
              if (!t.treemap)
                return [];
              var o = t.treemap.data.filter(function(u) {
                return !Oe(u.data);
              }).map(function(u, h) {
                return B0(u, [h], 0);
              }).flatMap(function(u) {
                return u;
              }).sort(function(u, h) {
                return h.depth - u.depth;
              });
              return iP(o), oP(o), (a = n.series) !== null && a !== void 0 && a.useColorValue && aP(o), o;
            }
            var lP = {
              name: "treemapSeriesData",
              state: function() {
                return {
                  treemapSeries: []
                };
              },
              action: {
                setTreemapSeriesData: function(n) {
                  var a = n.state;
                  a.treemapSeries = sP(a.series, a.options);
                }
              },
              observe: {
                updateTreemapSeriesData: function() {
                  this.dispatch("setTreemapSeriesData");
                }
              }
            }, uP = lP;
            function F0(t) {
              return hP(t) || dP(t) || fP(t) || cP();
            }
            function cP() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function fP(t, n) {
              if (t) {
                if (typeof t == "string") return dm(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return dm(t, n);
              }
            }
            function dP(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function hP(t) {
              if (Array.isArray(t)) return dm(t);
            }
            function dm(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            var pP = {
              name: "colorValueScale",
              state: function() {
                return {
                  treemapZoomId: {
                    prev: ol,
                    cur: ol
                  },
                  colorValueScale: {}
                };
              },
              action: {
                setColorValueScale: function(n) {
                  var a = n.state, o = a.layout, u = a.treemapSeries, h = a.legend, v = a.heatmapSeries;
                  if (h.useSpectrumLegend) {
                    var g = u ?? v.flatMap(function(I) {
                      return I;
                    }), b = g.reduce(function(I, W) {
                      var Z = W.colorValue;
                      return Z ? [].concat(F0(I), [Z]) : I;
                    }, []), C = xv(F0(new Set(b))), R = xo(h.align) ? o.plot.width / 2 : o.plot.height;
                    Pt(a.colorValueScale, dc({
                      dataRange: C,
                      offsetSize: R,
                      useSpectrumLegend: !0,
                      scaleOption: {}
                    }));
                  }
                },
                setTreemapZoomId: function(n, a) {
                  var o = n.state;
                  o.treemapZoomId.prev = o.treemapZoomId.cur, o.treemapZoomId.cur = a;
                },
                zoomBack: function(n) {
                  var a, o = n.state, u = o.treemapSeries, h = o.treemapZoomId, v = h.prev, g = u.find(function(b) {
                    var C = b.id;
                    return C === v;
                  });
                  o.treemapZoomId.prev = (a = g == null ? void 0 : g.parentId) !== null && a !== void 0 ? a : ol, o.treemapZoomId.cur = v;
                }
              },
              observe: {
                updateColorValueScale: function() {
                  this.dispatch("setColorValueScale");
                }
              },
              computed: {
                isTreemapSeriesZooming: function(n) {
                  var a = n.treemapZoomId;
                  return a && a.cur !== a.prev;
                }
              }
            }, z0 = pP;
            function gd(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? gd = function(a) {
                return typeof a;
              } : gd = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, gd(t);
            }
            function vP(t) {
              return yP(t) || gP(t) || H0(t) || mP();
            }
            function mP() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function gP(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function yP(t) {
              if (Array.isArray(t)) return hm(t);
            }
            function bP(t, n) {
              return xP(t) || wP(t, n) || H0(t, n) || SP();
            }
            function SP() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function H0(t, n) {
              if (t) {
                if (typeof t == "string") return hm(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return hm(t, n);
              }
            }
            function hm(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function wP(t, n) {
              var a = t && (typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]);
              if (a != null) {
                var o = [], u = !0, h = !1, v, g;
                try {
                  for (a = a.call(t); !(u = (v = a.next()).done) && (o.push(v.value), !(n && o.length === n)); u = !0)
                    ;
                } catch (b) {
                  h = !0, g = b;
                } finally {
                  try {
                    !u && a.return != null && a.return();
                  } finally {
                    if (h) throw g;
                  }
                }
                return o;
              }
            }
            function xP(t) {
              if (Array.isArray(t)) return t;
            }
            function kP(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function OP(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function CP(t, n, a) {
              return n && OP(t.prototype, n), t;
            }
            function TP(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && pm(t, n);
            }
            function pm(t, n) {
              return pm = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, pm(t, n);
            }
            function AP(t) {
              var n = MP();
              return function() {
                var o = yd(t), u;
                if (n) {
                  var h = yd(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return EP(this, u);
              };
            }
            function EP(t, n) {
              return n && (gd(n) === "object" || typeof n == "function") ? n : Kl(t);
            }
            function Kl(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function MP() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function yd(t) {
              return yd = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, yd(t);
            }
            function bd(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var j0 = /* @__PURE__ */ function(t) {
              TP(a, t);
              var n = AP(a);
              function a() {
                var o;
                kP(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), bd(Kl(o), "models", void 0), bd(Kl(o), "labels", []), bd(Kl(o), "align", void 0), bd(Kl(o), "renderSpectrumTooltip", function(g) {
                  var b = bP(g, 1), C = b[0];
                  if (C) {
                    var R = Kl(o), I = R.labels, W = R.align, Z = C.colorValue, ue = C.color, ke = o.rect, Ee = ke.width, Le = ke.height;
                    o.models.tooltip = [{
                      type: "spectrumTooltip",
                      width: Ee,
                      height: Le,
                      x: 0,
                      y: 0,
                      labels: I,
                      align: W,
                      colorRatio: C.colorRatio,
                      color: ue,
                      text: String(Z),
                      verticalAlign: xo(W)
                    }];
                  } else
                    o.models.tooltip = [];
                }), o;
              }
              return CP(a, [{
                key: "initialize",
                value: function() {
                  this.type = "spectrumLegend", this.name = "spectrumLegend";
                }
              }, {
                key: "makeLabels",
                value: function(u) {
                  var h = u.stepCount, v = u.limit, g = u.stepSize, b = v.min;
                  return Mt(0, h + 1).reduce(function(C, R) {
                    return [].concat(vP(C), [String(b + g * R)]);
                  }, []);
                }
              }, {
                key: "renderSpectrumLegendModel",
                value: function(u, h) {
                  var v = this.labels, g = this.align, b = this.rect, C = b.width, R = b.height;
                  return [{
                    type: "spectrumLegend",
                    width: C,
                    height: R,
                    x: 0,
                    y: 0,
                    labels: v,
                    align: g,
                    startColor: u,
                    endColor: h,
                    verticalAlign: xo(this.align)
                  }];
                }
              }, {
                key: "render",
                value: function(u) {
                  var h, v, g = u.layout, b = u.legend, C = u.colorValueScale, R = u.theme;
                  if (this.rect = g.legend, this.align = b.align, this.isShow = b.visible && !!b.data.length, !!this.isShow) {
                    this.labels = this.makeLabels(C);
                    var I = ((h = R.series) === null || h === void 0 ? void 0 : h.heatmap) || ((v = R.series) === null || v === void 0 ? void 0 : v.treemap), W = I.startColor, Z = I.endColor;
                    this.models = {
                      legend: this.renderSpectrumLegendModel(W, Z),
                      tooltip: []
                    }, this.eventBus.on("renderSpectrumTooltip", this.renderSpectrumTooltip);
                  }
                }
              }]), a;
            }(Lr);
            function RP(t) {
              return IP(t) || LP(t) || PP(t) || DP();
            }
            function DP() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function PP(t, n) {
              if (t) {
                if (typeof t == "string") return vm(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return vm(t, n);
              }
            }
            function LP(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function IP(t) {
              if (Array.isArray(t)) return vm(t);
            }
            function vm(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function W0(t, n) {
              return t.map(function(a, o) {
                return n[o] - a;
              });
            }
            function $0(t, n) {
              if (!we(n)) {
                var a = Math.abs(t.max - t.min);
                return a && !Oe(n) ? (n - t.min) / a : 0;
              }
            }
            function U0(t, n, a) {
              var o = a.map(function(h, v) {
                return h + parseInt(String(n[v] * t), 10);
              }), u = on.apply(void 0, RP(o));
              return Ie(u) ? u : "";
            }
            function Sd(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Sd = function(a) {
                return typeof a;
              } : Sd = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Sd(t);
            }
            function _P(t, n) {
              return FP(t) || BP(t, n) || Y0(t, n) || NP();
            }
            function NP() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function BP(t, n) {
              var a = t && (typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]);
              if (a != null) {
                var o = [], u = !0, h = !1, v, g;
                try {
                  for (a = a.call(t); !(u = (v = a.next()).done) && (o.push(v.value), !(n && o.length === n)); u = !0)
                    ;
                } catch (b) {
                  h = !0, g = b;
                } finally {
                  try {
                    !u && a.return != null && a.return();
                  } finally {
                    if (h) throw g;
                  }
                }
                return o;
              }
            }
            function FP(t) {
              if (Array.isArray(t)) return t;
            }
            function V0(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function Eo(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? V0(Object(a), !0).forEach(function(o) {
                  Ms(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : V0(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function G0(t) {
              return jP(t) || HP(t) || Y0(t) || zP();
            }
            function zP() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function Y0(t, n) {
              if (t) {
                if (typeof t == "string") return mm(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return mm(t, n);
              }
            }
            function HP(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function jP(t) {
              if (Array.isArray(t)) return mm(t);
            }
            function mm(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function WP(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function $P(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function UP(t, n, a) {
              return n && $P(t.prototype, n), t;
            }
            function VP(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && gm(t, n);
            }
            function gm(t, n) {
              return gm = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, gm(t, n);
            }
            function GP(t) {
              var n = qP();
              return function() {
                var o = wd(t), u;
                if (n) {
                  var h = wd(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return YP(this, u);
              };
            }
            function YP(t, n) {
              return n && (Sd(n) === "object" || typeof n == "function") ? n : Es(t);
            }
            function Es(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function qP() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function wd(t) {
              return wd = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, wd(t);
            }
            function Ms(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var KP = /* @__PURE__ */ function(t) {
              VP(a, t);
              var n = GP(a);
              function a() {
                var o;
                WP(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), Ms(Es(o), "models", void 0), Ms(Es(o), "responders", void 0), Ms(Es(o), "theme", void 0), Ms(Es(o), "activatedResponders", []), Ms(Es(o), "onMouseoutComponent", function() {
                  o.emitMouseEvent([]);
                }), Ms(Es(o), "selectSeries", function(g) {
                  var b, C = g.index, R = g.seriesIndex, I = g.state;
                  if (!(!Me(C) || !Me(R))) {
                    var W = (b = I.series.heatmap) === null || b === void 0 ? void 0 : b[0].data.length, Z = R * W + C, ue = o.responders[Z];
                    if (!ue)
                      throw new Error(ve.SELECT_SERIES_API_INDEX_ERROR);
                    o.eventBus.emit("renderSelectedSeries", {
                      models: o.getRespondersWithTheme([ue], "select"),
                      name: o.name
                    }), o.eventBus.emit("needDraw");
                  }
                }), Ms(Es(o), "showTooltip", function(g) {
                  var b, C = g.index, R = g.seriesIndex, I = g.state;
                  if (!(!Me(C) || !Me(R))) {
                    var W = (b = I.series.heatmap) === null || b === void 0 ? void 0 : b[0].data.length, Z = R * W + C, ue = o.responders[Z];
                    ue && o.emitMouseEvent([ue]);
                  }
                }), o;
              }
              return UP(a, [{
                key: "initialize",
                value: function() {
                  this.type = "series", this.name = "heatmap", this.eventBus.on("selectSeries", this.selectSeries), this.eventBus.on("showTooltip", this.showTooltip), this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "render",
                value: function(u) {
                  var h = u.layout, v = u.heatmapSeries, g = u.axes, b = u.theme, C = u.colorValueScale, R = u.options;
                  if (!v)
                    throw new Error(ve.noDataError(this.name));
                  this.theme = b.series.heatmap, this.selectable = this.getSelectableOption(R), this.rect = h.plot;
                  var I = {
                    height: g.yAxis.tickDistance,
                    width: g.xAxis.tickDistance
                  };
                  this.models = {
                    series: this.renderHeatmapSeries(v, I, C)
                  }, Ma(R, this.name).visible && this.renderDataLabels(this.makeDataLabels()), this.responders = this.makeHeatmapSeriesResponder();
                }
              }, {
                key: "makeDataLabels",
                value: function() {
                  var u = this.theme.dataLabels;
                  return this.models.series.reduce(function(h, v) {
                    return Oe(v.colorValue) ? h : [].concat(G0(h), [Eo(Eo({}, v), {}, {
                      type: "treemapSeriesName",
                      value: v.colorValue,
                      direction: "left",
                      plot: {
                        x: 0,
                        y: 0,
                        size: 0
                      },
                      theme: Eo(Eo({}, u), {}, {
                        color: u.useSeriesColor ? v.color : u.color
                      })
                    })]);
                  }, []);
                }
              }, {
                key: "makeHeatmapSeriesResponder",
                value: function() {
                  return this.models.series.reduce(function(u, h) {
                    return Oe(h.colorValue) ? u : [].concat(G0(u), [Eo(Eo({}, h), {}, {
                      data: Eo(Eo({}, h), {}, {
                        label: h.name,
                        value: h.colorValue,
                        templateType: "heatmap"
                      }),
                      thickness: hi.HOVER_THICKNESS,
                      style: ["shadow"]
                    })]);
                  }, []);
                }
              }, {
                key: "renderHeatmapSeries",
                value: function(u, h, v) {
                  var g = this.theme, b = g.startColor, C = g.endColor, R = g.borderColor, I = g.borderWidth, W = kr(b), Z = W0(W, kr(C)), ue = h.height, ke = h.width;
                  return u.flatMap(function(Ee) {
                    return Ee.flatMap(function(Le) {
                      var je = Le.indexes, Ke = Le.colorValue, ut = Le.category, bt = "".concat(ut.x, ", ").concat(ut.y), mt = _P(je, 2), Rt = mt[0], Dt = mt[1], Lt = $0(v.limit, Ke), Wt = Oe(Ke) ? "rgba(0, 0, 0, 0)" : U0(Lt, Z, W), Qt = I;
                      return {
                        type: "rect",
                        name: bt,
                        width: ke - Qt * 2,
                        height: ue - Qt * 2,
                        x: ke * Rt + Qt,
                        y: ue * Dt + Qt,
                        colorValue: Ke,
                        colorRatio: Lt,
                        color: Wt,
                        thickness: Qt,
                        borderColor: R
                      };
                    });
                  });
                }
              }, {
                key: "getRespondersWithTheme",
                value: function(u, h) {
                  var v = this;
                  return u.map(function(g) {
                    return Ye(g, Eo(Eo({}, v.theme[h]), {}, {
                      style: ["shadow"]
                    }));
                  });
                }
              }, {
                key: "onClick",
                value: function(u) {
                  var h = u.responders;
                  this.selectable && (this.eventBus.emit("renderSelectedSeries", {
                    models: this.getRespondersWithTheme(h, "select"),
                    name: this.name
                  }), this.eventBus.emit("needDraw"));
                }
              }, {
                key: "onMousemove",
                value: function(u) {
                  var h = u.responders;
                  this.activatedResponders = h, this.emitMouseEvent(h);
                }
              }, {
                key: "emitMouseEvent",
                value: function(u) {
                  this.eventBus.emit("renderHoveredSeries", {
                    models: this.getRespondersWithTheme(u, "hover"),
                    name: this.name
                  }), this.eventBus.emit("seriesPointHovered", {
                    models: u,
                    name: this.name
                  }), this.eventBus.emit("renderSpectrumTooltip", u), this.eventBus.emit("needDraw");
                }
              }]), a;
            }(Lr);
            function xd(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? xd = function(a) {
                return typeof a;
              } : xd = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, xd(t);
            }
            function q0(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function ym(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? q0(Object(a), !0).forEach(function(o) {
                  XP(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : q0(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function XP(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function JP(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function ZP(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function QP(t, n, a) {
              return n && ZP(t.prototype, n), t;
            }
            function kd(t, n, a) {
              return typeof Reflect < "u" && Reflect.get ? kd = Reflect.get : kd = function(u, h, v) {
                var g = eL(u, h);
                if (g) {
                  var b = Object.getOwnPropertyDescriptor(g, h);
                  return b.get ? b.get.call(v) : b.value;
                }
              }, kd(t, n, a || t);
            }
            function eL(t, n) {
              for (; !Object.prototype.hasOwnProperty.call(t, n) && (t = Xl(t), t !== null); )
                ;
              return t;
            }
            function tL(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && bm(t, n);
            }
            function bm(t, n) {
              return bm = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, bm(t, n);
            }
            function rL(t) {
              var n = aL();
              return function() {
                var o = Xl(t), u;
                if (n) {
                  var h = Xl(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return nL(this, u);
              };
            }
            function nL(t, n) {
              return n && (xd(n) === "object" || typeof n == "function") ? n : iL(t);
            }
            function iL(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function aL() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function Xl(t) {
              return Xl = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, Xl(t);
            }
            function K0(t, n) {
              return t.map(function(a, o) {
                return {
                  data: a,
                  yCategory: n.y[o]
                };
              });
            }
            var oL = /* @__PURE__ */ function(t) {
              tL(a, t);
              var n = rL(a);
              function a(o) {
                return JP(this, a), n.call(this, {
                  el: o.el,
                  categories: o.data.categories,
                  options: o.options,
                  series: {
                    heatmap: K0(o.data.series, o.data.categories)
                  },
                  modules: [QD, z0, XD]
                });
              }
              return QP(a, [{
                key: "initialize",
                value: function() {
                  kd(Xl(a.prototype), "initialize", this).call(this), this.componentManager.add(Yn), this.componentManager.add(Un), this.componentManager.add(j0), this.componentManager.add(Hn, {
                    chartEl: this.el
                  }), this.componentManager.add(KP), this.componentManager.add(Vr, {
                    name: "yAxis"
                  }), this.componentManager.add(Vr, {
                    name: "xAxis"
                  }), this.componentManager.add(Yr, {
                    name: "xAxis"
                  }), this.componentManager.add(Yr, {
                    name: "yAxis"
                  }), this.componentManager.add(Vn), this.componentManager.add(Gn), this.componentManager.add(Yi), this.componentManager.add($n, {
                    chartEl: this.el
                  }), this.componentManager.add(qn), this.painter.addGroups([p, d, w, f, O, m, y]);
                }
                /**
                 * Add data.
                 * @param {Array} data - Array of data to be added.
                 * @param {string} category - Category to be added.
                 * @api
                 * @example
                 * chart.addData([10, 20], '6');
                 */
              }, {
                key: "addData",
                value: function(u, h) {
                  this.animationControlFlag.updating = !0, this.resetSeries(), this.store.dispatch("addData", {
                    data: u,
                    category: h
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<number>} data.data - Array of data to be added.
                 * @param {Object} dataInfo - Category information of the series.
                 *   @param {Object} dataInfo.category - Y category.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function(u, h) {
                  this.resetSeries(), this.store.dispatch("addHeatmapSeries", ym({
                    data: u
                  }, h));
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set.
                 *   @param {Array<string>} data.categories.x - X Categories.
                 *   @param {Array<string>} data.categories.y - Y Categories.
                 * @param {Array<Array<number>>} data.series - Series data.
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: {
                 *     x: ['1', '2', '3' ],
                 *     y: ['A', 'B'],
                 *   },
                 *   series: [
                 *     [1, 2, 3],
                 *     [4, 5, 6],
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function(u) {
                  var h = u.categories, v = u.series;
                  this.resetSeries(), this.store.dispatch("setData", {
                    series: {
                      heatmap: K0(v, h)
                    },
                    categories: h
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !1
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !0
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("initOptions", u);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("updateOptions", u);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.seriesIndex - Index of series.
                 *      @param {number} seriesInfo.index - Index of data within series.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2});
                 */
              }, {
                key: "showTooltip",
                value: function(u) {
                  this.eventBus.emit("showTooltip", ym(ym({}, u), {}, {
                    state: this.store.state
                  }));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function() {
                  this.eventBus.emit("hideTooltip");
                }
              }]), a;
            }(Wn);
            function Od(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Od = function(a) {
                return typeof a;
              } : Od = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Od(t);
            }
            function qi(t) {
              return cL(t) || uL(t) || lL(t) || sL();
            }
            function sL() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function lL(t, n) {
              if (t) {
                if (typeof t == "string") return Sm(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return Sm(t, n);
              }
            }
            function uL(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function cL(t) {
              if (Array.isArray(t)) return Sm(t);
            }
            function Sm(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function X0(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function vn(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? X0(Object(a), !0).forEach(function(o) {
                  si(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : X0(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function fL(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function dL(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function hL(t, n, a) {
              return n && dL(t.prototype, n), t;
            }
            function pL(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && wm(t, n);
            }
            function wm(t, n) {
              return wm = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, wm(t, n);
            }
            function vL(t) {
              var n = gL();
              return function() {
                var o = Cd(t), u;
                if (n) {
                  var h = Cd(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return mL(this, u);
              };
            }
            function mL(t, n) {
              return n && (Od(n) === "object" || typeof n == "function") ? n : oi(t);
            }
            function oi(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function gL() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function Cd(t) {
              return Cd = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, Cd(t);
            }
            function si(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var J0 = {
              INACTIVE: 0.06,
              ACTIVE: 1
            }, Z0 = /* @__PURE__ */ function(t) {
              pL(a, t);
              var n = vL(a);
              function a() {
                var o;
                fL(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), si(oi(o), "models", {
                  rect: [],
                  series: [],
                  dot: []
                }), si(oi(o), "drawModels", void 0), si(oi(o), "theme", void 0), si(oi(o), "responders", void 0), si(oi(o), "activatedResponders", []), si(oi(o), "eventDetectType", "nearest"), si(oi(o), "tooltipCircleMap", void 0), si(oi(o), "linePointsModel", void 0), si(oi(o), "baseYPosition", void 0), si(oi(o), "isStackChart", !1), si(oi(o), "isRangeChart", !1), si(oi(o), "isSplineChart", !1), si(oi(o), "startIndex", void 0), si(oi(o), "onMouseoutComponent", function() {
                  o.eventBus.emit("seriesPointHovered", {
                    models: [],
                    name: o.name
                  }), o.eventBus.emit("renderHoveredSeries", {
                    models: [],
                    name: o.name,
                    eventDetectType: o.eventDetectType
                  }), o.eventBus.emit("needDraw");
                }), si(oi(o), "selectSeries", function(g) {
                  var b = g.index, C = g.seriesIndex;
                  if (kf(g, "area")) {
                    var R = o.getResponderCategoryByIndex(b);
                    if (!R)
                      throw new Error(ve.SELECT_SERIES_API_INDEX_ERROR);
                    var I = o.tooltipCircleMap[R][C];
                    if (!I)
                      throw new Error(ve.SELECT_SERIES_API_INDEX_ERROR);
                    var W = o.getResponderSeriesWithTheme([I], "select");
                    o.eventBus.emit("renderSelectedSeries", {
                      models: W,
                      name: o.name
                    }), o.eventBus.emit("needDraw");
                  }
                }), si(oi(o), "showTooltip", function(g) {
                  var b = g.index, C = g.seriesIndex;
                  if (xf(g, o.eventDetectType, "area")) {
                    var R = o.getResponderCategoryByIndex(b);
                    if (R) {
                      var I = o.eventDetectType === "grouped" ? o.tooltipCircleMap[R] : [o.tooltipCircleMap[R][C]];
                      I.length && (o.onMousemoveNearType(I), o.eventBus.emit("seriesPointHovered", {
                        models: o.activatedResponders,
                        name: o.name
                      }), o.eventBus.emit("needDraw"));
                    }
                  }
                }), o;
              }
              return hL(a, [{
                key: "initialize",
                value: function() {
                  this.type = "series", this.name = "area", this.eventBus.on("selectSeries", this.selectSeries), this.eventBus.on("showTooltip", this.showTooltip), this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "initUpdate",
                value: function(u) {
                  this.drawModels && (this.drawModels.rect[0].width = this.models.rect[0].width * u);
                }
              }, {
                key: "getBaseYPosition",
                value: function(u) {
                  var h = u.min >= 0 ? u.min : Math.min(u.max, 0), v = this.rect.height / (u.max - u.min);
                  return (u.max - h) * v;
                }
              }, {
                key: "getStackValue",
                value: function(u, h, v) {
                  var g = u.stack.type, b = u.stackData[v], C = b.values, R = b.sum, I = lt(C.slice(0, h + 1));
                  return g === "percent" ? I * 100 / R : I;
                }
              }, {
                key: "setEventDetectType",
                value: function(u, h) {
                  var v;
                  h != null && (v = h.series) !== null && v !== void 0 && v.eventDetectType && (this.eventDetectType = h.series.eventDetectType), (u.line || this.isStackChart) && (this.eventDetectType = "grouped");
                }
              }, {
                key: "getAreaOptions",
                value: function(u) {
                  var h, v = vn({}, u);
                  return (h = v.series) !== null && h !== void 0 && h.area && (v.series = vn(vn({}, v.series), v.series.area)), v;
                }
              }, {
                key: "render",
                value: function(u, h) {
                  var v, g, b, C, R, I, W = h.viewRange, Z = u.layout, ue = u.series, ke = u.scale, Ee = u.axes, Le = u.legend, je = u.stackSeries, Ke = u.theme;
                  if (!ue.area)
                    throw new Error(ve.noDataError(this.name));
                  var ut, bt = this.getAreaOptions(u.options), mt = u.categories, Rt = (v = u.rawCategories) !== null && v !== void 0 ? v : [];
                  this.theme = Ke.series.area, this.rect = Z.plot, this.activeSeriesMap = Ea(Le), this.startIndex = (g = W == null ? void 0 : W[0]) !== null && g !== void 0 ? g : 0, this.selectable = this.getSelectableOption(bt), this.isSplineChart = (b = (C = bt.series) === null || C === void 0 ? void 0 : C.spline) !== null && b !== void 0 ? b : !1;
                  var Dt = ke[Qu(bt, this.name, "yAxis")].limit, Lt = Ee.xAxis, Wt = Lt.tickDistance, Qt = Lt.pointOnColumn, or = Lt.tickCount, lr = ue.area.data;
                  this.baseYPosition = this.getBaseYPosition(Dt), je != null && je.area ? (this.isStackChart = !0, ut = je.area) : By((R = De(lr)) === null || R === void 0 ? void 0 : R.data) && (this.isRangeChart = !0), this.setEventDetectType(ue, bt);
                  var xr = {
                    pointOnColumn: Qt,
                    options: bt.series || {},
                    tickDistance: Wt,
                    tickCount: or,
                    areaStackSeries: ut
                  };
                  this.linePointsModel = this.renderLinePointsModel(lr, Dt, xr);
                  var br = this.renderAreaPointsModel(), yr = !!((I = bt.series) !== null && I !== void 0 && I.showDot), Ar = this.renderCircleModel(yr), qr = Ar.dotSeriesModel, nn = Ar.responderModel, tn = this.makeTooltipData(lr, Rt);
                  this.models = wt({
                    rect: [this.renderClipRectAreaModel()],
                    series: [].concat(qi(this.linePointsModel), qi(br)),
                    dot: qr
                  }), this.drawModels || (this.drawModels = vn(vn({}, this.models), {}, {
                    rect: [this.renderClipRectAreaModel(!0)]
                  })), Ma(bt, this.name).visible && this.renderDataLabels(this.getDataLabels(br)), this.tooltipCircleMap = e0(nn, tn), this.responders = this.getResponders(nn, tn, mt, Rt, Ee.xAxis);
                }
              }, {
                key: "getResponders",
                value: function(u, h, v, g, b) {
                  return this.eventDetectType === "near" ? this.makeNearTypeResponderModel(u, h, g) : this.eventDetectType === "point" ? this.makeNearTypeResponderModel(u, h, g, 0) : Nf(this.rect, b, v);
                }
              }, {
                key: "makeNearTypeResponderModel",
                value: function(u, h, v, g) {
                  var b = h.length;
                  return u.map(function(C, R) {
                    return vn(vn({}, C), {}, {
                      data: h[R % b],
                      detectionSize: g,
                      label: v[C.index]
                    });
                  });
                }
              }, {
                key: "renderClipRectAreaModel",
                value: function(u) {
                  return {
                    type: "clipRectArea",
                    x: 0,
                    y: 0,
                    width: u ? 0 : this.rect.width,
                    height: this.rect.height
                  };
                }
              }, {
                key: "makeTooltipData",
                value: function(u, h) {
                  var v = this;
                  return u.flatMap(function(g, b) {
                    var C = g.rawData, R = g.name, I = g.color, W = [];
                    return C.forEach(function(Z, ue) {
                      if (!Oe(Z)) {
                        var ke = v.isRangeChart ? "".concat(Z[0], " ~ ").concat(Z[1]) : Z;
                        W.push({
                          label: R,
                          color: I,
                          value: ke,
                          category: h[ue],
                          seriesIndex: b,
                          index: ue
                        });
                      }
                    }), W;
                  });
                }
              }, {
                key: "getLinePointModelValue",
                value: function(u, h) {
                  return this.isRangeChart ? h ? u[0] : u[1] : u;
                }
              }, {
                key: "getLinePointModel",
                value: function(u, h, v, g) {
                  var b = this, C = g.pointOnColumn, R = g.tickDistance, I = g.pairModel, W = g.areaStackSeries, Z = u.rawData, ue = u.name, ke = u.color, Ee = this.activeSeriesMap[ue], Le = [], je = cr(ke, Ee ? J0.ACTIVE : J0.INACTIVE), Ke = this.theme, ut = Ke.lineWidth, bt = Ke.dashSegments;
                  return Z.forEach(function(mt, Rt) {
                    if (Oe(mt)) {
                      Le.push(null);
                      return;
                    }
                    var Dt = b.getLinePointModelValue(mt, I), Lt = b.isStackChart ? b.getStackValue(W, h, Rt) : Dt, Wt = bo(Lt, v), Qt = R * (Rt - b.startIndex) + (C ? R / 2 : 0), or = (1 - Wt) * b.rect.height;
                    Le.push({
                      x: Qt,
                      y: or,
                      value: Dt
                    });
                  }), I && Le.reverse(), this.isSplineChart && Gs(Le), {
                    type: "linePoints",
                    lineWidth: ut,
                    dashSegments: bt,
                    color: je,
                    points: Le,
                    seriesIndex: h,
                    name: ue
                  };
                }
              }, {
                key: "renderLinePointsModel",
                value: function(u, h, v) {
                  var g = this, b = u.map(function(I, W) {
                    return g.getLinePointModel(I, W, h, v);
                  });
                  if (this.isRangeChart) {
                    var C = Ye(v, {
                      pairModel: !0
                    }), R = u.map(function(I, W) {
                      return g.getLinePointModel(I, W, h, C);
                    });
                    b.push.apply(b, qi(R));
                  }
                  return b;
                }
              }, {
                key: "getCombinedPoints",
                value: function(u, h) {
                  var v = u >= 0 ? this.linePointsModel[u].points : [], g = qi(this.linePointsModel[h].points).reverse();
                  return [].concat(qi(v), qi(g));
                }
              }, {
                key: "renderRangeAreaSeries",
                value: function(u) {
                  var h = this, v = [];
                  return u.forEach(function(g) {
                    var b = [], C = g.points;
                    C.slice(0, C.length / 2 + 1).forEach(function(R, I) {
                      var W = I === C.length / 2 - 1, Z = Oe(R);
                      if (Z || b.push(R), b.length && (W || Z)) {
                        var ue = b.map(function(ke, Ee) {
                          var Le = C.length / 2 + I - b.length + Ee + (!Z && W ? 1 : 0);
                          return C[Le];
                        }).reverse();
                        v.push(vn(vn({}, g), {}, {
                          type: "areaPoints",
                          lineWidth: 0,
                          color: "rgba(0, 0, 0, 0)",
                          // make area border transparent
                          fillColor: h.getAreaOpacity(g.name, g.color),
                          points: [].concat(qi(b), qi(ue))
                        })), b = [];
                      }
                    });
                  }), v;
                }
              }, {
                key: "renderAreaSeries",
                value: function(u) {
                  var h = this, v = [], g = [];
                  return u.forEach(function(b) {
                    var C = [], R = [].concat(g), I = b.points;
                    I.forEach(function(W, Z) {
                      var ue = Z === I.length - 1, ke = Oe(W);
                      if (Oe(W) || C.push(W), C.length && (ke || ue)) {
                        var Ee = C.map(function(Le, je) {
                          var Ke = Z - C.length + je + (!ke && ue ? 1 : 0), ut = we(R[Ke]) ? h.baseYPosition : R[Ke];
                          return h.isStackChart && (g[Ke] = Le.y), {
                            x: Le.x,
                            y: ut
                          };
                        }).reverse();
                        h.isStackChart && h.isSplineChart && Gs(Ee), v.push(vn(vn({}, b), {}, {
                          type: "areaPoints",
                          lineWidth: 0,
                          color: "rgba(0, 0, 0, 0)",
                          // make area border transparent
                          fillColor: h.getAreaOpacity(b.name, b.color),
                          points: [].concat(qi(C), qi(Ee))
                        })), C = [];
                      }
                    });
                  }), v;
                }
              }, {
                key: "getCombinedLinePointsModel",
                value: function() {
                  var u = this;
                  if (!this.isRangeChart)
                    return this.linePointsModel;
                  var h = this.linePointsModel.length / 2;
                  return Mt(0, h).reduce(function(v, g) {
                    var b = g, C = h + g, R = u.getCombinedPoints(b, C);
                    return [].concat(qi(v), [vn(vn({}, u.linePointsModel[g]), {}, {
                      points: R
                    })]);
                  }, []);
                }
              }, {
                key: "getAreaOpacity",
                value: function(u, h) {
                  var v = this.theme, g = v.select, b = v.areaOpacity, C = this.activeSeriesMap[u], R = Object.values(this.activeSeriesMap).some(function(I) {
                    return !I;
                  });
                  return R ? cr(h, C ? g.areaOpacity : g.restSeries.areaOpacity) : cr(h, b);
                }
              }, {
                key: "renderAreaPointsModel",
                value: function() {
                  var u = this.getCombinedLinePointsModel();
                  return this.isRangeChart ? this.renderRangeAreaSeries(u) : this.renderAreaSeries(u);
                }
              }, {
                key: "renderCircleModel",
                value: function(u) {
                  var h = this, v = [], g = [], b = this.theme.dot;
                  return this.linePointsModel.forEach(function(C, R) {
                    var I = C.points, W = C.color, Z = C.seriesIndex, ue = C.name, ke = h.isRangeChart && R >= h.linePointsModel.length / 2, Ee = h.activeSeriesMap[ue];
                    I.forEach(function(Le, je) {
                      if (!Oe(Le)) {
                        var Ke = vn(vn({
                          type: "circle"
                        }, Le), {}, {
                          seriesIndex: Z,
                          name: ue,
                          index: ke ? I.length - je - 1 : je
                        });
                        if (u) {
                          var ut;
                          v.push(vn(vn({}, Ke), {}, {
                            radius: b.radius,
                            color: cr(W, Ee ? 1 : 0.3),
                            style: [{
                              lineWidth: b.borderWidth,
                              strokeStyle: (ut = b.borderColor) !== null && ut !== void 0 ? ut : W
                            }]
                          }));
                        }
                        g.push.apply(g, qi(h.getResponderSeriesWithTheme([Ke], "hover", W)));
                      }
                    });
                  }), {
                    dotSeriesModel: v,
                    responderModel: g
                  };
                }
              }, {
                key: "getPairCircleModel",
                value: function(u) {
                  var h = this, v = [];
                  return u.forEach(function(g) {
                    var b = g.seriesIndex, C = g.y, R = g.data, I = R.category, W = h.tooltipCircleMap[I].find(function(Z) {
                      return Z.seriesIndex === b && Z.y !== C;
                    });
                    v.push(W);
                  }), v;
                }
              }, {
                key: "getCircleModelsFromRectResponders",
                value: function(u, h) {
                  var v;
                  if (!u.length || !u[0].label)
                    return [];
                  var g = (v = this.tooltipCircleMap[u[0].label]) !== null && v !== void 0 ? v : [];
                  return this.eventDetectType === "grouped" ? g : jl(g, h, this.rect);
                }
              }, {
                key: "onMousemoveGroupedType",
                value: function(u) {
                  var h = this.getCircleModelsFromRectResponders(u);
                  this.eventBus.emit("renderHoveredSeries", {
                    models: h,
                    name: this.name,
                    eventDetectType: this.eventDetectType
                  }), this.activatedResponders = this.isRangeChart ? h.slice(0, h.length / 2) : h;
                }
              }, {
                key: "onMousemoveNearestType",
                value: function(u, h) {
                  var v = this.getCircleModelsFromRectResponders(u, h);
                  this.onMousemoveNearType(v);
                }
              }, {
                key: "onMousemoveNearType",
                value: function(u) {
                  var h = [];
                  this.isRangeChart && (h = this.getPairCircleModel(u));
                  var v = [].concat(qi(u), qi(h));
                  this.eventBus.emit("renderHoveredSeries", {
                    models: v,
                    name: this.name,
                    eventDetectType: this.eventDetectType
                  }), this.activatedResponders = u;
                }
              }, {
                key: "onMousemove",
                value: function(u) {
                  var h = u.responders, v = u.mousePosition;
                  this.eventDetectType === "nearest" ? this.onMousemoveNearestType(h, v) : ["near", "point"].includes(this.eventDetectType) ? this.onMousemoveNearType(h) : this.onMousemoveGroupedType(h), this.eventBus.emit("seriesPointHovered", {
                    models: this.activatedResponders,
                    name: this.name
                  }), this.eventBus.emit("needDraw");
                }
              }, {
                key: "getDataLabels",
                value: function(u) {
                  var h = this.theme.dataLabels;
                  return u.flatMap(function(v) {
                    var g = v.points, b = v.name, C = v.fillColor;
                    return g.map(function(R) {
                      return Oe(R) ? {} : vn(vn({
                        type: "point"
                      }, R), {}, {
                        name: b,
                        theme: vn(vn({}, h), {}, {
                          color: h.useSeriesColor ? cr(C, 1) : h.color
                        })
                      });
                    });
                  });
                }
              }, {
                key: "getResponderSeriesWithTheme",
                value: function(u, h, v) {
                  var g = this.theme[h].dot, b = g.radius, C = g.color, R = g.borderWidth, I = g.borderColor;
                  return u.map(function(W) {
                    var Z, ue = (Z = C ?? W.color) !== null && Z !== void 0 ? Z : v;
                    return vn(vn({}, W), {}, {
                      radius: b,
                      color: ue,
                      style: [{
                        lineWidth: R,
                        strokeStyle: I ?? cr(ue, 0.5)
                      }]
                    });
                  });
                }
              }, {
                key: "onClick",
                value: function(u) {
                  var h = u.responders, v = u.mousePosition;
                  if (this.selectable) {
                    var g;
                    this.eventDetectType === "near" ? g = h : g = this.getCircleModelsFromRectResponders(h, v), this.eventBus.emit("renderSelectedSeries", {
                      models: this.getResponderSeriesWithTheme(g, "select"),
                      name: this.name
                    }), this.eventBus.emit("needDraw");
                  }
                }
              }, {
                key: "getResponderCategoryByIndex",
                value: function(u) {
                  var h, v = Object.values(this.tooltipCircleMap).flatMap(function(g) {
                    return g;
                  }).find(function(g) {
                    return g.index === u;
                  });
                  return v == null || (h = v.data) === null || h === void 0 ? void 0 : h.category;
                }
              }]), a;
            }(Lr);
            function Td(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Td = function(a) {
                return typeof a;
              } : Td = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Td(t);
            }
            function Q0(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function yL(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? Q0(Object(a), !0).forEach(function(o) {
                  bL(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : Q0(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function bL(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function SL(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function wL(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function xL(t, n, a) {
              return n && wL(t.prototype, n), t;
            }
            function Ad(t, n, a) {
              return typeof Reflect < "u" && Reflect.get ? Ad = Reflect.get : Ad = function(u, h, v) {
                var g = kL(u, h);
                if (g) {
                  var b = Object.getOwnPropertyDescriptor(g, h);
                  return b.get ? b.get.call(v) : b.value;
                }
              }, Ad(t, n, a || t);
            }
            function kL(t, n) {
              for (; !Object.prototype.hasOwnProperty.call(t, n) && (t = Jl(t), t !== null); )
                ;
              return t;
            }
            function OL(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && xm(t, n);
            }
            function xm(t, n) {
              return xm = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, xm(t, n);
            }
            function CL(t) {
              var n = EL();
              return function() {
                var o = Jl(t), u;
                if (n) {
                  var h = Jl(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return TL(this, u);
              };
            }
            function TL(t, n) {
              return n && (Td(n) === "object" || typeof n == "function") ? n : AL(t);
            }
            function AL(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function EL() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function Jl(t) {
              return Jl = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, Jl(t);
            }
            var ML = /* @__PURE__ */ function(t) {
              OL(a, t);
              var n = CL(a);
              function a(o) {
                return SL(this, a), n.call(this, {
                  el: o.el,
                  options: o.options,
                  series: {
                    area: o.data.series
                  },
                  categories: o.data.categories,
                  modules: [Hl, Vi, Gi, Xa, Za]
                });
              }
              return xL(a, [{
                key: "initialize",
                value: function() {
                  Ad(Jl(a.prototype), "initialize", this).call(this), this.componentManager.add(Yn), this.componentManager.add(Un), this.componentManager.add(Qa), this.componentManager.add(Oi), this.componentManager.add(Z0), this.componentManager.add(Vr, {
                    name: "xAxis"
                  }), this.componentManager.add(Vr, {
                    name: "yAxis"
                  }), this.componentManager.add(Vr, {
                    name: "secondaryYAxis"
                  }), this.componentManager.add(Yi), this.componentManager.add(Yr, {
                    name: "xAxis"
                  }), this.componentManager.add(Yr, {
                    name: "yAxis"
                  }), this.componentManager.add(Yr, {
                    name: "secondaryYAxis"
                  }), this.componentManager.add(Hn, {
                    chartEl: this.el
                  }), this.componentManager.add(Vn), this.componentManager.add(Gn), this.componentManager.add($n, {
                    chartEl: this.el
                  }), this.componentManager.add(em), this.componentManager.add(Gl), this.componentManager.add(qn), this.painter.addGroups([p, d, k, w, f, O, m, T]);
                }
                /**
                 * Add data.
                 * @param {Array} data - Array of data to be added.
                 * @param {string} category - Category to be added.
                 * @api
                 * @example
                 * chart.addData([10, 20], '6');
                 */
              }, {
                key: "addData",
                value: function(u, h) {
                  this.resetSeries(), this.animationControlFlag.updating = !0, this.store.dispatch("addData", {
                    data: u,
                    category: h
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<number|Array<number>>} data.data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function(u) {
                  this.resetSeries(), this.store.dispatch("addSeries", {
                    data: u
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['1', '2', '3'],
                 *   series: [
                 *     {
                 *       name: 'new series',
                 *       data: [1, 2, 3],
                 *     },
                 *     {
                 *       name: 'new series2',
                 *       data: [4, 5, 6],
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function(u) {
                  var h = u.categories, v = u.series;
                  this.resetSeries(), this.store.dispatch("setData", {
                    series: {
                      area: v
                    },
                    categories: h
                  });
                }
                /**
                 * Add plot line.
                 * @param {Object} data - Plot info.
                 *   @param {string|number} data.value - The value where the plot line will be drawn.
                 *   @param {string} data.color - Plot line color.
                 *   @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
                 * @api
                 * @example
                 * chart.addPlotLine({
                 *   value: 2,
                 *   color: '#00ff22',
                 *   id: 'plot-1',
                 * });
                 */
              }, {
                key: "addPlotLine",
                value: function(u) {
                  this.store.dispatch("addPlotLine", {
                    data: u
                  });
                }
                /**
                 * Remove plot line with id.
                 * @param {string} id - Id of the plot line to be removed.
                 * @api
                 * @example
                 * chart.removePlotLine('plot-1');
                 */
              }, {
                key: "removePlotLine",
                value: function(u) {
                  this.store.dispatch("removePlotLine", {
                    id: u
                  });
                }
                /**
                 * Add plot band.
                 * @param {Object} data - Plot info.
                 * @param {Array<string|number>} data.range - The range to be drawn.
                 * @param {string} data.color - Plot band color.
                 * @param {string} [data.id] - Plot id. The value on which the removePlotBand is based.
                 * @api
                 * @example
                 * chart.addPlotBand({
                 *   value: [2, 4],
                 *   color: '#00ff22',
                 *   id: 'plot-1',
                 * });
                 */
              }, {
                key: "addPlotBand",
                value: function(u) {
                  this.store.dispatch("addPlotBand", {
                    data: u
                  });
                }
                /**
                 * Remove plot band with id.
                 * @param {string} id - id of the plot band to be removed.
                 * @api
                 * @example
                 * chart.removePlotBand('plot-1');
                 */
              }, {
                key: "removePlotBand",
                value: function(u) {
                  this.store.dispatch("removePlotBand", {
                    id: u
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !1
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !0
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *     date: { format: 'yy/MM' },
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("initOptions", u);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("updateOptions", u);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only seriesIndex is needed.
                 *      @param {number} [seriesInfo.seriesIndex] - Index of series.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2});
                 */
              }, {
                key: "showTooltip",
                value: function(u) {
                  this.eventBus.emit("showTooltip", yL({}, u));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function() {
                  this.eventBus.emit("hideTooltip");
                }
              }]), a;
            }(Wn);
            function Ed(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Ed = function(a) {
                return typeof a;
              } : Ed = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Ed(t);
            }
            function RL(t) {
              return IL(t) || LL(t) || PL(t) || DL();
            }
            function DL() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function PL(t, n) {
              if (t) {
                if (typeof t == "string") return km(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return km(t, n);
              }
            }
            function LL(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function IL(t) {
              if (Array.isArray(t)) return km(t);
            }
            function km(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function eS(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function yc(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? eS(Object(a), !0).forEach(function(o) {
                  ro(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : eS(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function _L(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function NL(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function BL(t, n, a) {
              return n && NL(t.prototype, n), t;
            }
            function FL(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Om(t, n);
            }
            function Om(t, n) {
              return Om = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Om(t, n);
            }
            function zL(t) {
              var n = jL();
              return function() {
                var o = Md(t), u;
                if (n) {
                  var h = Md(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return HL(this, u);
              };
            }
            function HL(t, n) {
              return n && (Ed(n) === "object" || typeof n == "function") ? n : to(t);
            }
            function to(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function jL() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function Md(t) {
              return Md = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, Md(t);
            }
            function ro(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var tS = /* @__PURE__ */ function(t) {
              FL(a, t);
              var n = zL(a);
              function a() {
                var o;
                _L(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), ro(to(o), "theme", void 0), ro(to(o), "models", {
                  series: []
                }), ro(to(o), "drawModels", void 0), ro(to(o), "responders", void 0), ro(to(o), "activatedResponders", []), ro(to(o), "rect", void 0), ro(to(o), "onMouseoutComponent", function() {
                  o.eventBus.emit("seriesPointHovered", {
                    models: [],
                    name: o.name
                  }), o.eventBus.emit("renderHoveredSeries", {
                    models: [],
                    name: o.name
                  }), o.eventBus.emit("needDraw");
                }), ro(to(o), "getModelsForSelectInfo", function(g) {
                  var b = g.index, C = g.seriesIndex, R = g.state;
                  if (!(!Me(b) || !Me(C) || !kf(g, "scatter"))) {
                    var I = R.series.scatter.data[C].name;
                    return [o.responders.filter(function(W) {
                      var Z = W.name;
                      return Z === I;
                    })[b]];
                  }
                }), ro(to(o), "selectSeries", function(g) {
                  var b = o.getModelsForSelectInfo(g);
                  if (b) {
                    var C = o.getClosestModel(b);
                    if (!b.length)
                      throw new Error(ve.SELECT_SERIES_API_INDEX_ERROR);
                    o.eventBus.emit("renderSelectedSeries", {
                      models: o.getResponderAppliedTheme(C, "select"),
                      name: o.name
                    }), o.eventBus.emit("needDraw");
                  }
                }), ro(to(o), "showTooltip", function(g) {
                  var b = o.getModelsForSelectInfo(g);
                  b && (o.eventBus.emit("renderHoveredSeries", {
                    models: b,
                    name: o.name
                  }), o.activatedResponders = b, o.eventBus.emit("seriesPointHovered", {
                    models: o.activatedResponders,
                    name: o.name
                  }), o.eventBus.emit("needDraw"));
                }), o;
              }
              return BL(a, [{
                key: "initialize",
                value: function() {
                  this.type = "series", this.name = "scatter", this.eventBus.on("selectSeries", this.selectSeries), this.eventBus.on("showTooltip", this.showTooltip), this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "initUpdate",
                value: function(u) {
                  var h = this;
                  this.drawModels.series.forEach(function(v, g) {
                    v.size = h.models.series[g].size * u;
                  });
                }
              }, {
                key: "render",
                value: function(u) {
                  var h, v, g = this, b = u.layout, C = u.series, R = u.scale, I = u.legend, W = u.options, Z = u.theme, ue = u.axes;
                  if (!C.scatter)
                    throw new Error(ve.noDataError(this.name));
                  var ke = C.scatter.data;
                  this.theme = Z.series.scatter, this.rect = b.plot, this.activeSeriesMap = Ea(I), this.selectable = this.getSelectableOption(W);
                  var Ee = (h = (v = ue.xAxis) === null || v === void 0 ? void 0 : v.labelRange) !== null && h !== void 0 ? h : R.xAxis.limit, Le = this.renderScatterPointsModel(ke, Ee, R[Qu(W, this.name, "yAxis")].limit), je = this.makeTooltipModel(ke);
                  this.models.series = Le, this.drawModels || (this.drawModels = wt(this.models)), this.responders = Le.map(function(Ke, ut) {
                    return yc(yc({}, Ke), {}, {
                      type: "circle",
                      detectionSize: 0,
                      radius: g.theme.size / 2,
                      color: Ke.fillColor,
                      style: [{
                        strokeStyle: Ke.borderColor,
                        lineWidth: Ke.borderWidth
                      }],
                      data: je[ut]
                    });
                  });
                }
              }, {
                key: "renderScatterPointsModel",
                value: function(u, h, v) {
                  var g = this;
                  return u.flatMap(function(b, C) {
                    var R = b.data, I = b.name, W = b.color, Z = b.iconType, ue = [], ke = g.activeSeriesMap[I], Ee = cr(W, ke ? 1 : 0.3);
                    return R.forEach(function(Le, je) {
                      var Ke = Ka(Le), ut = Ie(Ke) ? Number(new Date(Ke)) : Number(Ke), bt = qo(Le), mt = bo(ut, h), Rt = bo(bt, v), Dt = mt * g.rect.width, Lt = (1 - Rt) * g.rect.height;
                      ue.push(yc({
                        x: Dt,
                        y: Lt,
                        type: "scatterSeries",
                        iconType: Z,
                        seriesIndex: C,
                        name: I,
                        borderColor: Ee,
                        index: je
                      }, Ue(g.theme, "borderWidth", "size", "fillColor")));
                    }), ue;
                  });
                }
              }, {
                key: "makeTooltipModel",
                value: function(u) {
                  return RL(u).flatMap(function(h) {
                    var v = h.data, g = h.name, b = h.color, C = [];
                    return v.forEach(function(R) {
                      var I = {
                        x: Ka(R),
                        y: qo(R)
                      };
                      C.push({
                        label: g,
                        color: b,
                        value: I
                      });
                    }), C;
                  });
                }
              }, {
                key: "getClosestModel",
                value: function(u) {
                  if (!u.length)
                    return [];
                  var h = this.models.series.find(function(v) {
                    var g = v.index, b = v.seriesIndex;
                    return Me(g) && Me(b) && g === u[0].index && b === u[0].seriesIndex;
                  });
                  return h ? [h] : [];
                }
              }, {
                key: "getResponderAppliedTheme",
                value: function(u, h) {
                  var v = this, g = this.theme[h], b = g.fillColor, C = g.size;
                  return u.map(function(R) {
                    return Ye(R, yc(yc({}, v.theme[h]), {}, {
                      color: b,
                      radius: C / 2
                    }));
                  });
                }
              }, {
                key: "onMousemove",
                value: function(u) {
                  var h = u.responders, v = u.mousePosition, g = jl(h, v, this.rect), b = this.getClosestModel(g);
                  b = this.getResponderAppliedTheme(b, "hover"), this.eventBus.emit("renderHoveredSeries", {
                    models: b,
                    name: this.name
                  }), this.activatedResponders = g, this.eventBus.emit("seriesPointHovered", {
                    models: this.activatedResponders,
                    name: this.name
                  }), this.eventBus.emit("needDraw");
                }
              }, {
                key: "onClick",
                value: function(u) {
                  var h = u.responders, v = u.mousePosition;
                  if (this.selectable) {
                    var g = jl(h, v, this.rect), b = this.getClosestModel(g);
                    b = this.getResponderAppliedTheme(b, "select"), this.eventBus.emit("renderSelectedSeries", {
                      models: b,
                      name: this.name
                    }), this.eventBus.emit("needDraw");
                  }
                }
              }]), a;
            }(Lr);
            function Rd(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Rd = function(a) {
                return typeof a;
              } : Rd = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Rd(t);
            }
            function rS(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function Cm(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? rS(Object(a), !0).forEach(function(o) {
                  WL(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : rS(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function WL(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function $L(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function UL(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function VL(t, n, a) {
              return n && UL(t.prototype, n), t;
            }
            function Dd(t, n, a) {
              return typeof Reflect < "u" && Reflect.get ? Dd = Reflect.get : Dd = function(u, h, v) {
                var g = GL(u, h);
                if (g) {
                  var b = Object.getOwnPropertyDescriptor(g, h);
                  return b.get ? b.get.call(v) : b.value;
                }
              }, Dd(t, n, a || t);
            }
            function GL(t, n) {
              for (; !Object.prototype.hasOwnProperty.call(t, n) && (t = Zl(t), t !== null); )
                ;
              return t;
            }
            function YL(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Tm(t, n);
            }
            function Tm(t, n) {
              return Tm = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Tm(t, n);
            }
            function qL(t) {
              var n = JL();
              return function() {
                var o = Zl(t), u;
                if (n) {
                  var h = Zl(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return KL(this, u);
              };
            }
            function KL(t, n) {
              return n && (Rd(n) === "object" || typeof n == "function") ? n : XL(t);
            }
            function XL(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function JL() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function Zl(t) {
              return Zl = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, Zl(t);
            }
            var ZL = /* @__PURE__ */ function(t) {
              YL(a, t);
              var n = qL(a);
              function a(o) {
                return $L(this, a), n.call(this, {
                  el: o.el,
                  options: o.options,
                  series: o.data.series,
                  modules: [Vi, Gi, Xa, Za]
                });
              }
              return VL(a, [{
                key: "initialize",
                value: function() {
                  Dd(Zl(a.prototype), "initialize", this).call(this), this.componentManager.add(Yn), this.componentManager.add(Un), this.componentManager.add(Qa), this.componentManager.add(Oi), this.componentManager.add(Hf), this.componentManager.add(tS), this.componentManager.add(Vr, {
                    name: "yAxis"
                  }), this.componentManager.add(Vr, {
                    name: "xAxis"
                  }), this.componentManager.add(Vr, {
                    name: "secondaryYAxis"
                  }), this.componentManager.add(Yi), this.componentManager.add(Yr, {
                    name: "xAxis"
                  }), this.componentManager.add(Yr, {
                    name: "yAxis"
                  }), this.componentManager.add(Yr, {
                    name: "secondaryYAxis"
                  }), this.componentManager.add(Hn, {
                    chartEl: this.el
                  }), this.componentManager.add(Vn), this.componentManager.add(Gn), this.componentManager.add($n, {
                    chartEl: this.el
                  }), this.componentManager.add(Gl), this.componentManager.add(qn), this.painter.addGroups([p, d, k, w, f, O, m, T, x]);
                }
                /**
                 * Add data.
                 * @param {Array} data - Array of data to be added.
                 * @param {string} chartType - Which type of chart to add.
                 * @api
                 * @example
                 * chart.addData([{x: 10, y: 20}, {x: 30, y: 40}], 'line');
                 */
              }, {
                key: "addData",
                value: function(u, h) {
                  this.animationControlFlag.updating = !0, this.resetSeries(), this.store.dispatch("addData", {
                    data: u,
                    chartType: h
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<Object>} data.data - Array of data to be added.
                 * @param {Object} dataInfo - Which type of chart to add.
                 *   @param {Object} dataInfo.chartType - Chart type.
                 * @api
                 * @example
                 * chart.addSeries(
                 *   {
                 *     name: 'newSeries',
                 *     data: [{x: 10, y: 20}, {x: 30, y: 40}],
                 *   },
                 *   {
                 *     chartType: 'line'
                 *   });
                 */
              }, {
                key: "addSeries",
                value: function(u, h) {
                  this.resetSeries(), this.store.dispatch("addSeries", Cm({
                    data: u
                  }, h));
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set
                 * @api
                 * @example
                 * chart.setData({
                 *   series: {
                 *     line: [
                 *       {
                 *         name: 'A',
                 *         data: [{x: 10, y: 20}, {x: 30, y: 40}],
                 *       }
                 *     ],
                 *     scatter: [
                 *       {
                 *         name: 'B',
                 *         data: [{x: 30, y: 20}, {x: 40, y: 40}],
                 *       }
                 *     ]
                 *   }
                 * });
                 */
              }, {
                key: "setData",
                value: function(u) {
                  this.resetSeries(), this.store.dispatch("setData", u);
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *     date: { format: 'yy/MM' },
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     line: {
                 *       showDot: true,
                 *     },
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("initOptions", u);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   series: {
                 *     line: {
                 *       showDot: true,
                 *     },
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("updateOptions", u);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed
                 *      @param {number} seriesInfo.seriesIndex - Index of series
                 *      @param {number} seriesInfo.index - Index of data within series
                 *      @param {string} seriesInfo.chartType - Specify which chart to select.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2, chartType: 'scatter'});
                 */
              }, {
                key: "showTooltip",
                value: function(u) {
                  this.eventBus.emit("showTooltip", Cm(Cm({}, u), {}, {
                    state: this.store.state
                  }));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function() {
                  this.eventBus.emit("hideTooltip");
                }
              }]), a;
            }(Wn);
            function Pd(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Pd = function(a) {
                return typeof a;
              } : Pd = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Pd(t);
            }
            function nS(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function iS(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? nS(Object(a), !0).forEach(function(o) {
                  QL(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : nS(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function QL(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function eI(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function tI(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function rI(t, n, a) {
              return n && tI(t.prototype, n), t;
            }
            function Ld(t, n, a) {
              return typeof Reflect < "u" && Reflect.get ? Ld = Reflect.get : Ld = function(u, h, v) {
                var g = nI(u, h);
                if (g) {
                  var b = Object.getOwnPropertyDescriptor(g, h);
                  return b.get ? b.get.call(v) : b.value;
                }
              }, Ld(t, n, a || t);
            }
            function nI(t, n) {
              for (; !Object.prototype.hasOwnProperty.call(t, n) && (t = Ql(t), t !== null); )
                ;
              return t;
            }
            function iI(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Am(t, n);
            }
            function Am(t, n) {
              return Am = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Am(t, n);
            }
            function aI(t) {
              var n = lI();
              return function() {
                var o = Ql(t), u;
                if (n) {
                  var h = Ql(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return oI(this, u);
              };
            }
            function oI(t, n) {
              return n && (Pd(n) === "object" || typeof n == "function") ? n : sI(t);
            }
            function sI(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function lI() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function Ql(t) {
              return Ql = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, Ql(t);
            }
            var uI = /* @__PURE__ */ function(t) {
              iI(a, t);
              var n = aI(a);
              function a(o) {
                return eI(this, a), n.call(this, {
                  el: o.el,
                  options: o.options,
                  series: o.data.series,
                  categories: o.data.categories,
                  modules: [Hl, Vi, Gi, Xa, Za]
                });
              }
              return rI(a, [{
                key: "initialize",
                value: function() {
                  Ld(Ql(a.prototype), "initialize", this).call(this), this.componentManager.add(Yn), this.componentManager.add(Un), this.componentManager.add(Qa), this.componentManager.add(Oi), this.componentManager.add(Z0), this.componentManager.add(Hf), this.componentManager.add(Vr, {
                    name: "yAxis"
                  }), this.componentManager.add(Vr, {
                    name: "xAxis"
                  }), this.componentManager.add(Vr, {
                    name: "secondaryYAxis"
                  }), this.componentManager.add(Yi), this.componentManager.add(Yr, {
                    name: "xAxis"
                  }), this.componentManager.add(Yr, {
                    name: "yAxis"
                  }), this.componentManager.add(Yr, {
                    name: "secondaryYAxis"
                  }), this.componentManager.add(Hn, {
                    chartEl: this.el
                  }), this.componentManager.add(Vn), this.componentManager.add(Gn), this.componentManager.add($n, {
                    chartEl: this.el
                  }), this.componentManager.add(Gl), this.componentManager.add(em), this.componentManager.add(qn), this.painter.addGroups([p, d, k, w, f, O, m, T]);
                }
                /**
                 * Add data.
                 * @param {Array<number>} data - Array of data to be added.
                 * @param {string} category - Category to be added.
                 * @param {string} chartType - Which type of chart to add.
                 * @api
                 * @example
                 * chart.addData([10, 20], '6', 'line');
                 */
              }, {
                key: "addData",
                value: function(u, h, v) {
                  this.animationControlFlag.updating = !0, this.resetSeries(), this.store.dispatch("addData", {
                    data: u,
                    category: h,
                    chartType: v
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<number>} data.data - Array of data to be added.
                 * @param {Object} dataInfo - Which type of chart to add.
                 *   @param {Object} dataInfo.chartType - Chart type.
                 * @api
                 * @example
                 * chart.addSeries(
                 *   {
                 *     name: 'newSeries',
                 *     data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
                 *   },
                 *   {
                 *     chartType: 'line'
                 *   });
                 */
              }, {
                key: "addSeries",
                value: function(u, h) {
                  this.resetSeries(), this.store.dispatch("addSeries", iS({
                    data: u
                  }, h));
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['1', '2', '3'],
                 *   series: {
                 *     line: [
                 *       {
                 *         name: 'A',
                 *         data: [1, 2, 3],
                 *       }
                 *     ],
                 *     area: [
                 *       {
                 *         name: 'B',
                 *         data: [4, 5, 6],
                 *       }
                 *     ]
                 *   }
                 * });
                 */
              }, {
                key: "setData",
                value: function(u) {
                  this.resetSeries(), this.store.dispatch("setData", u);
                }
                /**
                 * Add plot line.
                 * @param {Object} data - plot info
                 *   @param {string|number} data.value - The value where the plot line will be drawn.
                 *   @param {string} data.color - Plot line color.
                 *   @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
                 * @api
                 * @example
                 * chart.addPlotLine({
                 *   value: 2,
                 *   color: '#00ff22',
                 *   id: 'plot-1',
                 * });
                 */
              }, {
                key: "addPlotLine",
                value: function(u) {
                  this.store.dispatch("addPlotLine", {
                    data: u
                  });
                }
                /**
                 * Remove plot line with id.
                 * @param {string} id - Id of the plot line to be removed.
                 * @api
                 * @example
                 * chart.removePlotLine('plot-1');
                 */
              }, {
                key: "removePlotLine",
                value: function(u) {
                  this.store.dispatch("removePlotLine", {
                    id: u
                  });
                }
                /**
                 * Add plot band.
                 * @param {Object} data - Plot info.
                 * @param {Array<string|number>} data.range - The range to be drawn.
                 * @param {string} data.color - Plot band color.
                 * @param {string} [data.id] - Plot id. The value on which the removePlotBand is based.
                 * @api
                 * @example
                 * chart.addPlotBand({
                 *   value: [2, 4],
                 *   color: '#00ff22',
                 *   id: 'plot-1',
                 * });
                 */
              }, {
                key: "addPlotBand",
                value: function(u) {
                  this.store.dispatch("addPlotBand", {
                    data: u
                  });
                }
                /**
                 * Remove plot band with id.
                 * @param {string} id - Id of the plot band to be removed.
                 * @api
                 * @example
                 * chart.removePlotBand('plot-1');
                 */
              }, {
                key: "removePlotBand",
                value: function(u) {
                  this.store.dispatch("removePlotBand", {
                    id: u
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !1
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !0
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *     date: { format: 'yy/MM' },
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     line: {
                 *       showDot: true
                 *     },
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("initOptions", u);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   series: {
                 *     line: {
                 *       showDot: true,
                 *     },
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("updateOptions", u);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.seriesIndex - Index of series.
                 *      @param {number} seriesInfo.index - Index of data within series.
                 *      @param {string} seriesInfo.chartType - Specify which chart to select.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2, chartType: 'line'});
                 */
              }, {
                key: "showTooltip",
                value: function(u) {
                  this.eventBus.emit("showTooltip", iS({}, u));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function() {
                  this.eventBus.emit("hideTooltip");
                }
              }]), a;
            }(Wn);
            function cI(t, n, a) {
              var o = t;
              return o >= a ? 0 : (a < 0 && (o = Math.min(t - a, 0)), t < n && (o -= t - n), o);
            }
            function fI(t, n, a) {
              var o = t;
              return n > 0 && (o = Math.max(t - n, 0)), t > a && (o -= t - a), o;
            }
            function aS(t, n, a) {
              return t < 0 ? cI(t, n, a) : fI(t, n, a);
            }
            function Rs(t, n) {
              var a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, o = t[n];
              return t.reduce(function(u, h, v) {
                var g = a ? v <= n : v < n, b = h * o >= 0;
                return g && b ? u + h : u;
              }, 0);
            }
            function dI(t, n, a, o) {
              var u = t[n], h = Rs(t, n, !1), v = u >= 0, g = u < 0;
              return v && h >= o || g && h <= a || n === 0 && v && u < a || n === 0 && g && u > o;
            }
            function hI(t, n, a, o) {
              var u = Rs(t, n, !1), h = Rs(t, n, !0);
              if (dI(t, n, a, o))
                return null;
              if (n === 0)
                return aS(t[n], a, o);
              if (u < a && h > o)
                return o - a;
              var v = t[n];
              return h > o ? v = o - u : h < a ? v = a - u : u < a ? v = h - a : u > o && (v = h - o), v;
            }
            function Id(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Id = function(a) {
                return typeof a;
              } : Id = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Id(t);
            }
            function sl(t) {
              return mI(t) || vI(t) || sS(t) || pI();
            }
            function pI() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function vI(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function mI(t) {
              if (Array.isArray(t)) return Rm(t);
            }
            function oS(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function mn(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? oS(Object(a), !0).forEach(function(o) {
                  xn(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : oS(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function gI(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function yI(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function bI(t, n, a) {
              return n && yI(t.prototype, n), t;
            }
            function SI(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Em(t, n);
            }
            function Em(t, n) {
              return Em = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Em(t, n);
            }
            function wI(t) {
              var n = kI();
              return function() {
                var o = _d(t), u;
                if (n) {
                  var h = _d(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return xI(this, u);
              };
            }
            function xI(t, n) {
              return n && (Id(n) === "object" || typeof n == "function") ? n : wn(t);
            }
            function wn(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function kI() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function _d(t) {
              return _d = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, _d(t);
            }
            function xn(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function Mm(t, n) {
              return TI(t) || CI(t, n) || sS(t, n) || OI();
            }
            function OI() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function sS(t, n) {
              if (t) {
                if (typeof t == "string") return Rm(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return Rm(t, n);
              }
            }
            function Rm(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function CI(t, n) {
              var a = t && (typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]);
              if (a != null) {
                var o = [], u = !0, h = !1, v, g;
                try {
                  for (a = a.call(t); !(u = (v = a.next()).done) && (o.push(v.value), !(n && o.length === n)); u = !0)
                    ;
                } catch (b) {
                  h = !0, g = b;
                } finally {
                  try {
                    !u && a.return != null && a.return();
                  } finally {
                    if (h) throw g;
                  }
                }
                return o;
              }
            }
            function TI(t) {
              if (Array.isArray(t)) return t;
            }
            var fa;
            (function(t) {
              t[t.POSITIVE = 0] = "POSITIVE", t[t.NEGATIVE = 1] = "NEGATIVE", t[t.BOTH = 2] = "BOTH";
            })(fa || (fa = {}));
            var AI = {
              BAR: "bar"
            };
            function Nd(t) {
              return !!(t % 2);
            }
            function EI(t, n, a) {
              if (ko(t)) {
                var o = Mm(t, 2), u = o[0], h = o[1];
                return u < n && (u = n), h > a && (h = a), h - u;
              }
              return aS(t, n, a);
            }
            var Bd = /* @__PURE__ */ function(t) {
              SI(a, t);
              var n = wI(a);
              function a() {
                var o;
                gI(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), xn(wn(o), "models", {
                  series: []
                }), xn(wn(o), "drawModels", void 0), xn(wn(o), "responders", void 0), xn(wn(o), "activatedResponders", []), xn(wn(o), "isBar", !0), xn(wn(o), "valueAxis", "xAxis"), xn(wn(o), "labelAxis", "yAxis"), xn(wn(o), "anchorSizeKey", "height"), xn(wn(o), "offsetSizeKey", "width"), xn(wn(o), "basePosition", 0), xn(wn(o), "leftBasePosition", 0), xn(wn(o), "rightBasePosition", 0), xn(wn(o), "isRangeData", !1), xn(wn(o), "offsetKey", "x"), xn(wn(o), "eventDetectType", "point"), xn(wn(o), "tooltipRectMap", void 0), xn(wn(o), "theme", void 0), xn(wn(o), "onMouseoutComponent", function() {
                  o.eventBus.emit("seriesPointHovered", {
                    models: [],
                    name: o.name
                  }), o.eventBus.emit("renderHoveredSeries", {
                    models: [],
                    name: o.name,
                    eventDetectType: o.eventDetectType
                  }), o.eventBus.emit("needDraw");
                }), xn(wn(o), "selectSeries", function(g) {
                  var b = g.index, C = g.seriesIndex;
                  if (kf(g, "column")) {
                    var R = o.tooltipRectMap[C][b];
                    if (!R)
                      throw new Error(ve.SELECT_SERIES_API_INDEX_ERROR);
                    o.eventBus.emit("renderSelectedSeries", {
                      models: o.getRespondersWithTheme([R], "select"),
                      name: o.name
                    }), o.eventBus.emit("needDraw");
                  }
                }), xn(wn(o), "showTooltip", function(g) {
                  var b = g.index, C = g.seriesIndex;
                  if (xf(g, o.eventDetectType, "column")) {
                    var R = o.eventDetectType === "grouped" ? o.getGroupedRect([o.responders[b]], "hover") : o.getRespondersWithTheme([o.tooltipRectMap[b][C]], "hover");
                    R.length && (o.eventBus.emit("renderHoveredSeries", {
                      models: R,
                      name: o.name,
                      eventDetectType: o.eventDetectType
                    }), o.activatedResponders = o.eventDetectType === "grouped" ? o.tooltipRectMap[b] : R, o.eventBus.emit("seriesPointHovered", {
                      models: o.activatedResponders,
                      name: o.name
                    }), o.eventBus.emit("needDraw"));
                  }
                }), o;
              }
              return bI(a, [{
                key: "initialize",
                value: function(u) {
                  var h = u.name, v = u.stackChart;
                  this.initializeFields(h), v || (this.eventBus.on("selectSeries", this.selectSeries), this.eventBus.on("showTooltip", this.showTooltip), this.eventBus.on("hideTooltip", this.onMouseoutComponent));
                }
              }, {
                key: "initializeFields",
                value: function(u) {
                  this.type = "series", this.name = u, this.isBar = u === AI.BAR, this.offsetKey = this.isBar ? "x" : "y", this.valueAxis = this.isBar ? "xAxis" : "yAxis", this.labelAxis = this.isBar ? "yAxis" : "xAxis", this.anchorSizeKey = this.isBar ? "height" : "width", this.offsetSizeKey = this.isBar ? "width" : "height";
                }
              }, {
                key: "initUpdate",
                value: function(u) {
                  if (this.drawModels) {
                    if (this.isRangeData) {
                      this.initUpdateRangeData(u);
                      return;
                    }
                    this.initUpdateClipRect(u), this.initUpdateConnector(u);
                  }
                }
              }, {
                key: "initUpdateRangeData",
                value: function(u) {
                  var h = this, v = this.drawModels.series;
                  this.drawModels.clipRect = this.models.clipRect;
                  var g = this.models.series;
                  v.forEach(function(b, C) {
                    var R = g[C];
                    u === 0 && (b[h.offsetSizeKey] = 0);
                    var I = b[h.offsetSizeKey] + (R[h.offsetSizeKey] - b[h.offsetSizeKey]) * u;
                    b[h.offsetSizeKey] = I, h.isBar || (b[h.offsetKey] = R[h.offsetKey] + R[h.offsetSizeKey] - I);
                  });
                }
              }, {
                key: "initUpdateClipRect",
                value: function(u) {
                  var h = this.drawModels.clipRect;
                  if (h) {
                    var v = h[0], g = this.offsetSizeKey, b = this.models.clipRect[0], C = v[g] + (b[g] - v[g]) * u;
                    v[g] = C, v[this.offsetKey] = Math.max(this.basePosition - C * this.basePosition / b[g], 0);
                  }
                }
              }, {
                key: "initUpdateConnector",
                value: function(u) {
                  var h = this.drawModels.connector;
                  if (h) {
                    var v = this.models.connector;
                    h.forEach(function(g, b) {
                      var C = An(v[b].strokeStyle) * u;
                      g.strokeStyle = cr(g.strokeStyle, C);
                    });
                  }
                }
              }, {
                key: "setEventDetectType",
                value: function(u, h) {
                  var v;
                  u.line && (this.eventDetectType = "grouped"), h != null && (v = h.series) !== null && v !== void 0 && v.eventDetectType && (this.eventDetectType = h.series.eventDetectType);
                }
              }, {
                key: "getOptions",
                value: function(u) {
                  var h = mn({}, u);
                  return h != null && h.series && h.series.column && (h.series = mn(mn({}, h.series), h.series.column)), h;
                }
              }, {
                key: "render",
                value: function(u, h) {
                  var v, g, b = this, C = u.layout, R = u.series, I = u.axes, W = u.stackSeries, Z = u.legend, ue = u.theme, ke = u.scale;
                  if (this.isShow = !(W && W[this.name]), !!this.isShow) {
                    var Ee = (v = u.categories) !== null && v !== void 0 ? v : [], Le = this.getOptions(u.options);
                    this.setEventDetectType(R, Le), this.theme = ue.series[this.name], this.rect = C.plot, this.activeSeriesMap = Ea(Z), this.selectable = this.getSelectableOption(Le), this.valueAxis = Qu(Le, this.name, this.isBar ? "xAxis" : "yAxis");
                    var je = R[this.name].data.map(function(un) {
                      return mn(mn({}, un), {}, {
                        data: Ts(un.data, h.viewRange)
                      });
                    });
                    I.centerYAxis && (this.valueAxis = "centerYAxis");
                    var Ke = I[this.labelAxis].tickDistance, ut = !!((g = Le.series) !== null && g !== void 0 && g.diverging), bt = this.getScaleData(ke), mt = bt.limit, Rt = bt.stepSize, Dt = yo(mt, Rt), Lt = Vp(Dt), Wt = Lt.min, Qt = Lt.max;
                    this.basePosition = this.getBasePosition(I[this.valueAxis]);
                    var or = this.getOffsetSize(), lr = I.centerYAxis;
                    if (ut) {
                      var xr = this.getDivergingBasePosition(lr), br = Mm(xr, 2), yr = br[0], Ar = br[1];
                      this.basePosition = this.getOffsetSize() / 2, this.leftBasePosition = yr, this.rightBasePosition = Ar, or = this.getOffsetSizeWithDiverging(lr);
                    }
                    var qr = {
                      min: Wt,
                      max: Qt,
                      tickDistance: Ke,
                      diverging: ut,
                      ratio: this.getValueRatio(Wt, Qt, or),
                      hasNegativeValue: Xe(Dt),
                      seriesDirection: this.getSeriesDirection(Dt),
                      defaultPadding: Fo(Ke)
                    }, nn = this.renderSeriesModel(je, qr), tn = this.makeTooltipData(je, qr, Ee), bn = this.renderClipRectAreaModel();
                    if (this.models = {
                      clipRect: [bn],
                      series: nn
                    }, this.drawModels || (this.drawModels = {
                      clipRect: [this.initClipRect(bn)],
                      series: tt(nn)
                    }), Ma(Le, this.name).visible) {
                      var Tn = nn.reduce(function(un, Ln) {
                        return ko(Ln.value) ? [].concat(sl(un), sl(b.makeDataLabelRangeData(Ln))) : [].concat(sl(un), [b.makeDataLabel(Ln, lr)]);
                      }, []);
                      this.renderDataLabels(Tn);
                    }
                    this.tooltipRectMap = this.makeTooltipRectMap(nn, tn), this.responders = this.getBoxSeriesResponders(nn, tn, I, Ee);
                  }
                }
              }, {
                key: "getScaleData",
                value: function(u) {
                  return u[this.valueAxis === "centerYAxis" ? "xAxis" : this.valueAxis];
                }
              }, {
                key: "getBoxSeriesResponders",
                value: function(u, h, v, g) {
                  var b = this.renderHoveredSeriesModel(u);
                  return this.eventDetectType === "grouped" ? Nf(this.rect, this.isBar ? v.yAxis : v.xAxis, g, !this.isBar) : b.map(function(C, R) {
                    return mn(mn({}, C), {}, {
                      data: h[R]
                    });
                  });
                }
              }, {
                key: "makeTooltipRectMap",
                value: function(u, h) {
                  return u.reduce(function(v, g, b) {
                    var C = g.index, R = mn(mn({}, g), {}, {
                      data: h[b]
                    });
                    return v[C] || (v[C] = []), v[C].push(R), v;
                  }, []);
                }
              }, {
                key: "renderClipRectAreaModel",
                value: function() {
                  return {
                    type: "clipRectArea",
                    x: 0,
                    y: 0,
                    width: this.rect.width,
                    height: this.rect.height
                  };
                }
              }, {
                key: "initClipRect",
                value: function(u) {
                  return {
                    type: "clipRectArea",
                    width: this.isBar ? 0 : u.width,
                    height: this.isBar ? u.height : 0,
                    x: this.isBar ? 0 : u.x,
                    y: this.isBar ? u.y : 0
                  };
                }
              }, {
                key: "renderSeriesModel",
                value: function(u, h) {
                  var v = this, g = h.tickDistance, b = h.diverging, C = u.length, R = b && u.length === 2, I = this.getColumnWidth(h, C, R), W = [], Z = (g - I * (R ? 1 : C)) / 2;
                  return u.forEach(function(ue, ke) {
                    var Ee = ue.data, Le = ue.color, je = ue.name, Ke = ue.colorByCategories, ut = (b ? 0 : ke) * I + Z, bt = b && Nd(ke), mt = Ke ? Le.length : 1;
                    v.isRangeData = By(Ee), Ee.forEach(function(Rt, Dt) {
                      var Lt = ut + Dt * g, Wt = v.makeBarLength(Rt, h), Qt = v.getSeriesColor(je, Ke ? Le[Dt % mt] : Le);
                      if (Me(Wt)) {
                        var or = v.getStartPosition(Wt, Rt, h, bt);
                        W.push(mn(mn({
                          type: "rect",
                          color: Qt,
                          value: Rt
                        }, v.getAdjustedRect(Lt, or, Wt, I)), {}, {
                          name: je,
                          index: Dt
                        }));
                      }
                    });
                  }), W;
                }
              }, {
                key: "renderHoveredSeriesModel",
                value: function(u) {
                  var h = this;
                  return u.map(function(v) {
                    return h.makeHoveredSeriesModel(v);
                  });
                }
              }, {
                key: "makeHoveredSeriesModel",
                value: function(u) {
                  var h = u, v = h.x, g = h.y, b = h.width, C = h.height, R = h.color, I = h.index;
                  return {
                    type: "rect",
                    color: cr(R, 1),
                    x: v,
                    y: g,
                    width: b,
                    height: C,
                    index: I
                  };
                }
              }, {
                key: "getRectModelsFromRectResponders",
                value: function(u) {
                  var h;
                  return u.length ? (h = this.tooltipRectMap[u[0].index]) !== null && h !== void 0 ? h : [] : [];
                }
              }, {
                key: "getGroupedRect",
                value: function(u, h) {
                  var v = this.getRectModelsFromRectResponders(u), g = this.theme[h].groupedRect, b = g.color, C = g.opacity;
                  return v.length ? u.map(function(R) {
                    return mn(mn({}, R), {}, {
                      color: cr(b, C)
                    });
                  }) : [];
                }
              }, {
                key: "onMousemoveGroupedType",
                value: function(u) {
                  var h = this.getRectModelsFromRectResponders(u);
                  this.eventBus.emit("renderHoveredSeries", {
                    models: this.getGroupedRect(u, "hover"),
                    name: this.name,
                    eventDetectType: this.eventDetectType
                  }), this.activatedResponders = h;
                }
              }, {
                key: "onMousemove",
                value: function(u) {
                  var h = u.responders;
                  this.eventDetectType === "grouped" ? this.onMousemoveGroupedType(h) : (this.eventBus.emit("renderHoveredSeries", {
                    models: this.getRespondersWithTheme(h, "hover"),
                    name: this.name,
                    eventDetectType: this.eventDetectType
                  }), this.activatedResponders = h), this.eventBus.emit("seriesPointHovered", {
                    models: this.activatedResponders,
                    name: this.name
                  }), this.eventBus.emit("needDraw");
                }
              }, {
                key: "makeTooltipData",
                value: function(u, h, v) {
                  var g = this, b = [];
                  return u.forEach(function(C) {
                    var R = C.data, I = C.name, W = C.color, Z = C.colorByCategories;
                    R.forEach(function(ue, ke) {
                      if (!Oe(ue)) {
                        var Ee = g.makeBarLength(ue, h);
                        Me(Ee) && b.push({
                          label: I,
                          color: Z ? W[ke] : W,
                          value: g.getTooltipValue(ue),
                          category: v.length ? v[ke] : ""
                        });
                      }
                    });
                  }), b;
                }
              }, {
                key: "getTooltipValue",
                value: function(u) {
                  return ko(u) ? "".concat(u[0], " ~ ").concat(u[1]) : u;
                }
              }, {
                key: "getBasePosition",
                value: function(u) {
                  var h = u.labels, v = u.tickCount, g = u.zeroPosition, b = this.isBar ? h : sl(h).reverse(), C = Fi(this.getOffsetSize(), v), R = this.getSeriesDirection(b);
                  return g || this.getTickPositionIfNotZero(C, R);
                }
              }, {
                key: "getDivergingBasePosition",
                value: function(u) {
                  var h, v;
                  if (u)
                    h = u.xAxisHalfSize, v = u.secondStartX;
                  else {
                    var g = this.getOffsetSize() / 2;
                    h = v = g;
                  }
                  return [h, v];
                }
              }, {
                key: "getOffsetSize",
                value: function() {
                  return this.rect[this.offsetSizeKey];
                }
              }, {
                key: "getValueRatio",
                value: function(u, h, v) {
                  return v / (h - u);
                }
              }, {
                key: "makeBarLength",
                value: function(u, h) {
                  if (Oe(u))
                    return null;
                  var v = h.min, g = h.max, b = h.ratio, C = EI(u, v, g);
                  return Math.max(this.getBarLength(C, b), 2);
                }
              }, {
                key: "getBarLength",
                value: function(u, h) {
                  return u < 0 ? Math.abs(u) * h : u * h;
                }
              }, {
                key: "getStartPositionWithRangeValue",
                value: function(u, h, v) {
                  var g = v.min, b = v.ratio, C = Mm(u, 1), R = C[0];
                  R < g && (R = g);
                  var I = (R - g) * b;
                  return this.isBar ? I : this.getOffsetSize() - I - h;
                }
              }, {
                key: "getStartPosition",
                value: function(u, h, v, g) {
                  var b = v.diverging, C = v.seriesDirection, R;
                  return ko(h) ? R = this.getStartPositionWithRangeValue(h, u, v) : b ? R = g ? this.getStartPosOnLeftBottomSide(u, b) : this.getStartPosOnRightTopSide(u, b) : C === fa.POSITIVE ? R = this.getStartPosOnRightTopSide(u) : C === fa.NEGATIVE ? R = this.getStartPosOnLeftBottomSide(u) : R = h < 0 ? this.getStartPosOnLeftBottomSide(u) : this.getStartPosOnRightTopSide(u), R;
                }
              }, {
                key: "getStartPosOnRightTopSide",
                value: function(u) {
                  var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, v;
                  return h ? v = this.isBar ? this.rightBasePosition : this.rightBasePosition - u : v = this.isBar ? this.basePosition : this.basePosition - u, v;
                }
              }, {
                key: "getStartPosOnLeftBottomSide",
                value: function(u) {
                  var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, v;
                  return h ? v = this.isBar ? this.leftBasePosition - u : this.leftBasePosition : v = this.isBar ? this.basePosition - u : this.basePosition, v;
                }
              }, {
                key: "getAdjustedRect",
                value: function(u, h, v, g) {
                  return {
                    x: this.isBar ? h : u,
                    y: this.isBar ? u : h,
                    width: this.isBar ? v : g,
                    height: this.isBar ? g : v
                  };
                }
              }, {
                key: "getColumnWidth",
                value: function(u, h) {
                  var v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, g = u.tickDistance, b = u.defaultPadding;
                  h = v ? 1 : h;
                  var C = this.theme.barWidth;
                  return C ? be(g, C) : (g - b * 2) / h;
                }
              }, {
                key: "getSeriesDirection",
                value: function(u) {
                  var h = fa.BOTH;
                  return Q(u) ? h = fa.POSITIVE : te(u) && (h = fa.NEGATIVE), h;
                }
              }, {
                key: "getTickPositionIfNotZero",
                value: function(u, h) {
                  if (!u.length)
                    return 0;
                  var v = Number(pe(u)), g = Number(_e(u));
                  return h === fa.POSITIVE ? this.isBar ? v : g : h === fa.NEGATIVE ? this.isBar ? g : v : 0;
                }
              }, {
                key: "makeDataLabel",
                value: function(u, h) {
                  var v = this.theme.dataLabels;
                  return mn(mn({}, u), {}, {
                    direction: this.getDataLabelDirection(u, h),
                    plot: {
                      x: 0,
                      y: 0,
                      size: this.getOffsetSize()
                    },
                    theme: mn(mn({}, He(v, "stackTotal")), {}, {
                      color: v.useSeriesColor ? u.color : v.color
                    })
                  });
                }
              }, {
                key: "makeDataLabelRangeData",
                value: function(u) {
                  var h = this, v = this.theme.dataLabels;
                  return u.value.reduce(function(g, b, C) {
                    return [].concat(sl(g), [mn(mn({}, u), {}, {
                      value: b,
                      direction: h.getDataLabelRangeDataDirection(C % 2 === 0),
                      plot: {
                        x: 0,
                        y: 0,
                        size: h.getOffsetSize()
                      },
                      theme: mn(mn({}, He(v, "stackTotal")), {}, {
                        color: v.useSeriesColor ? u.color : v.color
                      })
                    })]);
                  }, []);
                }
              }, {
                key: "getDataLabelRangeDataDirection",
                value: function(u) {
                  var h;
                  return this.isBar ? h = u ? "left" : "right" : h = u ? "bottom" : "top", h;
                }
              }, {
                key: "getDataLabelDirection",
                value: function(u, h) {
                  var v;
                  if (this.isBar) {
                    var g = h ? this.leftBasePosition : this.basePosition;
                    v = u.x < g ? "left" : "right";
                  } else
                    v = u.y >= this.basePosition ? "bottom" : "top";
                  return v;
                }
              }, {
                key: "getOffsetSizeWithDiverging",
                value: function(u) {
                  return u ? u.xAxisHalfSize : this.getOffsetSize() / 2;
                }
              }, {
                key: "onClick",
                value: function(u) {
                  var h = u.responders;
                  if (this.selectable) {
                    var v;
                    this.eventDetectType === "grouped" ? v = [].concat(sl(this.getGroupedRect(h, "select")), sl(this.getRectModelsFromRectResponders(h))) : v = this.getRespondersWithTheme(h, "select"), this.eventBus.emit("renderSelectedSeries", {
                      models: v,
                      name: this.name,
                      eventDetectType: this.eventDetectType
                    }), this.eventBus.emit("needDraw");
                  }
                }
              }, {
                key: "getRespondersWithTheme",
                value: function(u, h) {
                  var v = this.theme[h], g = v.color, b = v.borderColor, C = v.borderWidth, R = v.shadowBlur, I = v.shadowColor, W = v.shadowOffsetX, Z = v.shadowOffsetY;
                  return u.map(function(ue) {
                    return mn(mn({}, ue), {}, {
                      color: g ?? ue.color,
                      thickness: C,
                      borderColor: b,
                      style: [{
                        shadowBlur: R,
                        shadowColor: I,
                        shadowOffsetX: W,
                        shadowOffsetY: Z
                      }]
                    });
                  });
                }
              }, {
                key: "getSeriesColor",
                value: function(u, h) {
                  var v = this.theme, g = v.select, b = v.areaOpacity, C = this.activeSeriesMap[u], R = Object.values(this.activeSeriesMap).some(function(I) {
                    return !I;
                  });
                  return R ? cr(h, C ? g.areaOpacity : g.restSeries.areaOpacity) : cr(h, b);
                }
              }]), a;
            }(Lr);
            function Fd(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Fd = function(a) {
                return typeof a;
              } : Fd = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Fd(t);
            }
            function Mo(t) {
              return DI(t) || RI(t) || lS(t) || MI();
            }
            function MI() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function RI(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function DI(t) {
              if (Array.isArray(t)) return Dm(t);
            }
            function PI(t, n) {
              return _I(t) || II(t, n) || lS(t, n) || LI();
            }
            function LI() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function lS(t, n) {
              if (t) {
                if (typeof t == "string") return Dm(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return Dm(t, n);
              }
            }
            function Dm(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function II(t, n) {
              var a = t && (typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]);
              if (a != null) {
                var o = [], u = !0, h = !1, v, g;
                try {
                  for (a = a.call(t); !(u = (v = a.next()).done) && (o.push(v.value), !(n && o.length === n)); u = !0)
                    ;
                } catch (b) {
                  h = !0, g = b;
                } finally {
                  try {
                    !u && a.return != null && a.return();
                  } finally {
                    if (h) throw g;
                  }
                }
                return o;
              }
            }
            function _I(t) {
              if (Array.isArray(t)) return t;
            }
            function NI(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function BI(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function FI(t, n, a) {
              return n && BI(t.prototype, n), t;
            }
            function zI(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Pm(t, n);
            }
            function Pm(t, n) {
              return Pm = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Pm(t, n);
            }
            function HI(t) {
              var n = WI();
              return function() {
                var o = zd(t), u;
                if (n) {
                  var h = zd(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return jI(this, u);
              };
            }
            function jI(t, n) {
              return n && (Fd(n) === "object" || typeof n == "function") ? n : uS(t);
            }
            function uS(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function WI() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function zd(t) {
              return zd = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, zd(t);
            }
            function cS(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function Ra(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? cS(Object(a), !0).forEach(function(o) {
                  Lm(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : cS(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function Lm(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function $I(t, n, a) {
              var o = a.stack, u = a.min, h = a.max;
              return Af(o) ? t[n] : hI(t, n, u, h);
            }
            function UI(t, n) {
              var a = t.positive, o = t.negative, u = a + Math.abs(o);
              return Ve(["dualPercentStack", "divergingPercentStack"], n) && (u *= 2), u;
            }
            function VI(t) {
              var n = ["positive", "negative"];
              return t === fa.POSITIVE ? n = ["positive"] : t === fa.NEGATIVE && (n = ["negative"]), n;
            }
            function GI(t, n) {
              if (!n)
                return t;
              var a = Array.isArray(t.stackData) ? Ts(t.stackData, n) : Ra({}, Object.keys(t.stackData).reduce(function(u, h) {
                return Ra(Ra({}, u), {}, Lm({}, h, Ts(t.stackData[h], n)));
              }, {})), o = t.data.map(function(u) {
                return Ra(Ra({}, u), {}, {
                  data: Ts(u.data, n)
                });
              });
              return Ra(Ra({}, t), {}, {
                data: o,
                stackData: a
              });
            }
            var Im = /* @__PURE__ */ function(t) {
              zI(a, t);
              var n = HI(a);
              function a() {
                var o;
                NI(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), Lm(uS(o), "selectSeries", function(g) {
                  var b = g.index, C = g.seriesIndex, R = g.state;
                  if (!(!Me(b) || !Me(C))) {
                    var I = R.stackSeries, W = I[o.name], Z = W.data[C].name, ue = o.tooltipRectMap[b].find(function(ke) {
                      var Ee = ke.name;
                      return Ee === Z;
                    });
                    if (!ue)
                      throw new Error(ve.SELECT_SERIES_API_INDEX_ERROR);
                    o.eventBus.emit("renderSelectedSeries", {
                      models: o.getRespondersWithTheme([ue], "select"),
                      name: o.name,
                      eventDetectType: o.eventDetectType
                    }), o.eventBus.emit("needDraw");
                  }
                }), o;
              }
              return FI(a, [{
                key: "initialize",
                value: function(u) {
                  var h = u.name, v = u.stackChart;
                  this.initializeFields(h), v && (this.eventBus.on("selectSeries", this.selectSeries), this.eventBus.on("showTooltip", this.showTooltip), this.eventBus.on("hideTooltip", this.onMouseoutComponent));
                }
              }, {
                key: "render",
                value: function(u, h) {
                  var v, g, b = u.layout, C = u.series, R = u.axes, I = u.stackSeries, W = u.legend, Z = u.theme, ue = u.scale, ke = h.viewRange;
                  if (this.isShow = !!I[this.name], !!this.isShow) {
                    var Ee = (v = u.categories) !== null && v !== void 0 ? v : [], Le = this.getOptions(u.options);
                    this.setEventDetectType(C, Le), this.theme = Z.series[this.name], this.rect = b.plot, this.activeSeriesMap = Ea(W), this.selectable = this.getSelectableOption(Le);
                    var je = GI(I[this.name], ke), Ke = R[this.labelAxis].tickDistance, ut = !!((g = Le.series) !== null && g !== void 0 && g.diverging), bt = this.getScaleData(ue), mt = bt.limit, Rt = bt.stepSize, Dt = yo(mt, Rt), Lt = Vp(Dt), Wt = Lt.min, Qt = Lt.max, or = je.stack, lr = je.scaleType;
                    this.basePosition = this.getBasePosition(R[this.valueAxis]);
                    var xr = this.getOffsetSize(), br = R.centerYAxis;
                    if (ut) {
                      var yr = this.getDivergingBasePosition(br), Ar = PI(yr, 2), qr = Ar[0], nn = Ar[1];
                      this.basePosition = this.getOffsetSize() / 2, this.leftBasePosition = qr, this.rightBasePosition = nn, xr = this.getOffsetSizeWithDiverging(br);
                    }
                    var tn = {
                      stack: or,
                      scaleType: lr,
                      tickDistance: Ke,
                      min: Wt,
                      max: Qt,
                      diverging: ut,
                      hasNegativeValue: Xe(Dt),
                      seriesDirection: this.getSeriesDirection(Dt),
                      defaultPadding: Fo(Ke),
                      offsetSize: xr,
                      centerYAxis: br
                    }, bn = this.renderStackSeriesModel(je, tn), Tn = bn.series, un = bn.connector, Ln = this.renderClipRectAreaModel(), so = this.getTooltipData(je, Ee);
                    if (this.models = {
                      clipRect: [Ln],
                      series: Tn,
                      connector: un
                    }, this.drawModels || (this.drawModels = {
                      clipRect: [this.initClipRect(Ln)],
                      series: tt(Tn),
                      connector: tt(un)
                    }), Ma(Le, this.name).visible) {
                      var Ro = this.getDataLabels(Tn, tn), Ds = this.getTotalDataLabels(je, tn);
                      this.renderDataLabels([].concat(Mo(Ro), Mo(Ds)));
                    }
                    this.tooltipRectMap = this.makeTooltipRectMap(Tn, so), this.responders = this.getBoxSeriesResponders(Tn, so, R, Ee);
                  }
                }
              }, {
                key: "renderStackSeriesModel",
                value: function(u, h) {
                  var v = u.stackData;
                  return hc(v) ? this.makeStackGroupSeriesModel(u, h) : this.makeStackSeriesModel(v, h, u.data);
                }
              }, {
                key: "makeStackSeriesModel",
                value: function(u, h, v) {
                  var g = this, b = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1, C = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, R = [], I = this.getStackColumnWidth(h, b), W = h.diverging, Z = W && Nd(C);
                  return u.forEach(function(ue, ke) {
                    var Ee = ue.values, Le = ue.total, je = g.getSeriesPosition(h, I, ke, C, b), Ke = g.getStackValueRatio(Le, h);
                    Ee.forEach(function(ut, bt) {
                      var mt = g.getStackRectInfo(Ee, bt, Ke, h, Z), Rt = mt.barLength, Dt = mt.dataPosition, Lt = v[bt], Wt = Lt.name, Qt = Lt.colorByCategories, or = Lt.color, lr = g.activeSeriesMap[Wt], xr = or.length || 1, br = Qt ? or[ke % xr] : or, yr = cr(br, lr ? 1 : 0.2);
                      R.push(Ra(Ra({
                        type: "rect",
                        color: yr,
                        name: Wt,
                        value: ut
                      }, g.getAdjustedRect(je, Dt, Rt ?? 0, I)), {}, {
                        index: ke
                      }));
                    });
                  }), {
                    series: R,
                    connector: this.makeConnectorSeriesModel(u, h, b, C)
                  };
                }
              }, {
                key: "makeStackGroupSeriesModel",
                value: function(u, h) {
                  var v = this, g = h.stack, b = u.stackData, C = u.data, R = Object.keys(b), I = [], W = [];
                  return R.forEach(function(Z, ue) {
                    var ke = C.filter(function(Ke) {
                      var ut = Ke.stackGroup;
                      return ut === Z;
                    }), Ee = v.makeStackSeriesModel(b[Z], h, ke, R.length, ue), Le = Ee.series, je = Ee.connector;
                    I = [].concat(Mo(I), Mo(Le)), g.connector && (W = [].concat(Mo(W), Mo(je)));
                  }), {
                    series: I,
                    connector: W
                  };
                }
              }, {
                key: "makeConnectorSeriesModel",
                value: function(u, h) {
                  var v = this, g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, b = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, C = h.diverging, R = h.stack.connector;
                  if (!R)
                    return [];
                  var I = this.getStackColumnWidth(h, g), W = C && Nd(b), Z = [];
                  return u.forEach(function(ue, ke) {
                    var Ee = ue.values, Le = ue.total, je = v.getSeriesPosition(h, I, ke, b, g), Ke = [], ut = v.getStackValueRatio(Le, h);
                    Ee.forEach(function(bt, mt) {
                      var Rt = v.getStackRectInfo(Ee, mt, ut, h, W), Dt = Rt.barLength, Lt = Rt.dataPosition, Wt = v.getAdjustedRect(je, Lt, Dt, I), Qt = Wt.x, or = Wt.y, lr = !W && v.isBar ? Qt + Dt : Qt, xr = W && !v.isBar ? or + Dt : or;
                      Ke.push({
                        x: lr,
                        y: xr
                      });
                    }), Z.push(Ke);
                  }), this.makeConnectorModel(Z, R, I);
                }
              }, {
                key: "getTooltipData",
                value: function(u, h) {
                  var v = u.data, g = u.stackData, b = v.map(function(C) {
                    var R = C.color;
                    return R;
                  });
                  return hc(g) ? this.makeGroupStackTooltipData(v, g, h) : this.makeStackTooltipData(v, g, b, h);
                }
              }, {
                key: "makeGroupStackTooltipData",
                value: function(u, h, v) {
                  var g = this;
                  return Object.keys(h).flatMap(function(b) {
                    var C = u.filter(function(I) {
                      var W = I.stackGroup;
                      return W === b;
                    }), R = C.map(function(I) {
                      var W = I.color;
                      return W;
                    });
                    return g.makeStackTooltipData(C, h[b], R, v);
                  });
                }
              }, {
                key: "makeStackTooltipData",
                value: function(u, h, v, g) {
                  var b = [];
                  return h.forEach(function(C, R) {
                    var I = C.values;
                    I.forEach(function(W, Z) {
                      b.push({
                        label: u[Z].name,
                        color: v[Z],
                        value: W,
                        category: g.length ? g[R] : ""
                      });
                    });
                  }), b;
                }
              }, {
                key: "makeConnectorModel",
                value: function(u, h, v) {
                  var g = this;
                  if (!h || !u.length)
                    return [];
                  for (var b = this.theme.connector, C = b.color, R = b.lineWidth, I = b.dashSegments, W = [], Z = u.length, ue = u[0].length, ke = function(je) {
                    for (var Ke = [], ut = 0; ut < Z; ut += 1)
                      Ke.push(u[ut][je]);
                    Ke.forEach(function(bt, mt) {
                      var Rt = bt.x, Dt = bt.y;
                      if (mt < Ke.length - 1) {
                        var Lt = Ke[mt + 1], Wt = Lt.x, Qt = Lt.y;
                        W.push({
                          type: "line",
                          x: g.isBar ? Rt : Rt + v,
                          y: g.isBar ? Dt + v : Dt,
                          x2: Wt,
                          y2: Qt,
                          dashSegments: I,
                          strokeStyle: C,
                          lineWidth: R
                        });
                      }
                    });
                  }, Ee = 0; Ee < ue; Ee += 1)
                    ke(Ee);
                  return W;
                }
              }, {
                key: "getStackValueRatio",
                value: function(u, h) {
                  var v = h.stack.type, g = h.scaleType, b = h.min, C = h.max, R = h.offsetSize;
                  return v === "percent" ? R / UI(u, g) : this.getValueRatio(b, C, R);
                }
              }, {
                key: "getStackBarLength",
                value: function(u, h, v, g) {
                  var b = $I(u, h, g);
                  return Me(b) ? this.getBarLength(b, v) : null;
                }
              }, {
                key: "getStackColumnWidth",
                value: function(u, h) {
                  var v = u.tickDistance, g = u.diverging, b = u.defaultPadding, C = g ? 1 : h, R = this.theme.barWidth;
                  return R ? be(v, R) : (v - b * 2) / C;
                }
              }, {
                key: "getSeriesPosition",
                value: function(u, h, v, g, b) {
                  var C = u.tickDistance, R = u.diverging, I = R ? 0 : g, W = R ? 1 : b, Z = (C - h * W) / 2;
                  return v * C + Z + h * I;
                }
              }, {
                key: "getStackStartPosition",
                value: function(u, h, v, g, b) {
                  var C = g.stack, R = g.diverging, I = g.seriesDirection, W;
                  return R ? W = b ? this.calcStartPosOnLeftBottomSide(u, h, g, v) : this.calcStartPosOnRightTopSide(u, h, g, v) : Af(C) ? W = this.calcStartPositionWithPercent(u, h, v) : I === fa.POSITIVE ? W = this.calcStartPosOnRightTopSide(u, h, g, v) : I === fa.NEGATIVE ? W = this.calcStartPosOnLeftBottomSide(u, h, g, v) : W = this.calcStartPositionWithStack(u, h, g, v), W;
                }
              }, {
                key: "calcStartPosOnLeftBottomSide",
                value: function(u, h, v, g) {
                  var b = v.min, C = v.max, R = v.diverging, I = R ? this.leftBasePosition : this.basePosition, W = Rs(u, h, !1), Z = Rs(u, h, !0), ue = Z < b, ke = this.isBar ? Z : W, Ee = C < 0 ? Math.min(ke - C, 0) : ke, Le;
                  return this.isBar ? Le = ue ? 0 : I - Math.abs(Ee) * g : Le = I + Math.abs(Ee) * g, Le;
                }
              }, {
                key: "calcStartPosOnRightTopSide",
                value: function(u, h, v, g) {
                  var b = v.min, C = v.max, R = v.diverging, I = R ? this.rightBasePosition : this.basePosition, W = Rs(u, h, !1), Z = Rs(u, h, !0), ue = Z > C, ke = this.isBar ? W : Z, Ee = b > 0 ? Math.max(ke - b, 0) : ke, Le = Ee * g, je;
                  return this.isBar ? je = I + Le : je = ue ? 0 : I - Le, je;
                }
              }, {
                key: "calcStartPositionWithStack",
                value: function(u, h, v, g) {
                  return u[h] < 0 ? this.calcStartPosOnLeftBottomSide(u, h, v, g) : this.calcStartPosOnRightTopSide(u, h, v, g);
                }
              }, {
                key: "calcStartPositionWithPercent",
                value: function(u, h, v) {
                  var g = this.basePosition, b = Rs(u, h, this.isBar ? u[h] < 0 : u[h] > 0);
                  return this.isBar ? b * v + g : g - b * v;
                }
              }, {
                key: "getStackRectInfo",
                value: function(u, h, v, g, b) {
                  var C = this.getStackBarLength(u, h, v, g), R = this.getStackStartPosition(u, h, v, g, b);
                  return {
                    barLength: C,
                    dataPosition: R
                  };
                }
              }, {
                key: "getDataLabels",
                value: function(u, h) {
                  var v = this;
                  return u.map(function(g) {
                    return v.makeDataLabel(g, h.centerYAxis);
                  });
                }
              }, {
                key: "getTotalDataLabels",
                value: function(u, h) {
                  var v = u.stackData, g = u.stack;
                  return Af(g) ? [] : hc(v) ? this.makeGroupTotalDataLabels(u, h) : this.makeTotalDataLabels(v, h);
                }
              }, {
                key: "makeGroupTotalDataLabels",
                value: function(u, h) {
                  var v = this, g = [], b = u.stackData, C = Object.keys(b);
                  return C.forEach(function(R, I) {
                    var W = v.makeTotalDataLabels(b[R], h, C.length, I);
                    g = [].concat(Mo(g), Mo(W));
                  }), g;
                }
              }, {
                key: "makeTotalDataLabels",
                value: function(u, h) {
                  var v = this, g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, b = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, C = [], R = h.min, I = h.max, W = h.seriesDirection, Z = h.diverging, ue = h.centerYAxis, ke = this.getStackColumnWidth(h, g);
                  return u.forEach(function(Ee, Le) {
                    var je = Ee.total, Ke = v.getSeriesPosition(h, ke, Le, b, g), ut = v.getStackValueRatio(je, h), bt = VI(W);
                    bt.forEach(function(mt) {
                      var Rt = je[mt];
                      if (Rt) {
                        var Dt = v.makeBarLength(Rt, {
                          min: R,
                          max: I,
                          ratio: ut
                        }), Lt = v.getStartPosition(Dt, Rt, h, Z && Nd(b)), Wt = Ra({
                          type: "stackTotal",
                          value: Rt,
                          name: "totalLabel-".concat(mt),
                          theme: v.theme.dataLabels.stackTotal
                        }, v.getAdjustedRect(Ke, Lt, Dt, ke));
                        C.push(v.makeTotalDataLabel(Wt, ue));
                      }
                    });
                  }), C;
                }
              }, {
                key: "makeTotalDataLabel",
                value: function(u, h) {
                  return Ra(Ra({}, u), {}, {
                    direction: this.getDataLabelDirection(u, h),
                    plot: {
                      x: 0,
                      y: 0,
                      size: this.getOffsetSize()
                    }
                  });
                }
              }, {
                key: "onMousemoveGroupedType",
                value: function(u) {
                  var h = this.getRectModelsFromRectResponders(u);
                  this.eventBus.emit("renderHoveredSeries", {
                    models: [].concat(Mo(h), Mo(this.getGroupedRect(u, "hover"))),
                    name: this.name,
                    eventDetectType: this.eventDetectType
                  }), this.activatedResponders = h;
                }
              }]), a;
            }(Bd);
            function Hd(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Hd = function(a) {
                return typeof a;
              } : Hd = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Hd(t);
            }
            function YI(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function qI(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function KI(t, n, a) {
              return n && qI(t.prototype, n), t;
            }
            function XI(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && _m(t, n);
            }
            function _m(t, n) {
              return _m = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, _m(t, n);
            }
            function JI(t) {
              var n = QI();
              return function() {
                var o = jd(t), u;
                if (n) {
                  var h = jd(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return ZI(this, u);
              };
            }
            function ZI(t, n) {
              return n && (Hd(n) === "object" || typeof n == "function") ? n : fS(t);
            }
            function fS(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function QI() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function jd(t) {
              return jd = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, jd(t);
            }
            function e_(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var Nm = /* @__PURE__ */ function(t) {
              XI(a, t);
              var n = JI(a);
              function a() {
                var o;
                YI(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), e_(fS(o), "models", []), o;
              }
              return KI(a, [{
                key: "initialize",
                value: function() {
                  this.type = "zeroAxis", this.name = "zeroAxis";
                }
              }, {
                key: "render",
                value: function(u) {
                  var h = u.layout, v = u.axes, g = u.series, b = u.options;
                  this.rect = h.plot;
                  var C = sa({
                    series: g,
                    options: b
                  }), R = C ? "xAxis" : "yAxis", I = v[R], W = I.zeroPosition;
                  Me(W) && (this.models = this.renderZeroModel(W, C));
                }
              }, {
                key: "renderZeroModel",
                value: function(u, h) {
                  var v = Cr(0), g = Cr(u), b;
                  return h ? b = {
                    type: "line",
                    x: g,
                    y: v,
                    x2: g,
                    y2: Cr(this.rect.height),
                    strokeStyle: "rgba(0, 0, 0, 0.5)"
                  } : b = {
                    type: "line",
                    x: v,
                    y: g,
                    x2: Cr(this.rect.width),
                    y2: g,
                    strokeStyle: "rgba(0, 0, 0, 0.5)"
                  }, [b];
                }
              }]), a;
            }(Lr);
            function Wd(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Wd = function(a) {
                return typeof a;
              } : Wd = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Wd(t);
            }
            function Bm(t) {
              return i_(t) || n_(t) || r_(t) || t_();
            }
            function t_() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function r_(t, n) {
              if (t) {
                if (typeof t == "string") return Fm(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return Fm(t, n);
              }
            }
            function n_(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function i_(t) {
              if (Array.isArray(t)) return Fm(t);
            }
            function Fm(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function dS(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function eu(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? dS(Object(a), !0).forEach(function(o) {
                  Da(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : dS(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function a_(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function o_(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function s_(t, n, a) {
              return n && o_(t.prototype, n), t;
            }
            function l_(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && zm(t, n);
            }
            function zm(t, n) {
              return zm = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, zm(t, n);
            }
            function u_(t) {
              var n = f_();
              return function() {
                var o = $d(t), u;
                if (n) {
                  var h = $d(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return c_(this, u);
              };
            }
            function c_(t, n) {
              return n && (Wd(n) === "object" || typeof n == "function") ? n : tu(t);
            }
            function tu(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function f_() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function $d(t) {
              return $d = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, $d(t);
            }
            function Da(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var hS = /* @__PURE__ */ function(t) {
              l_(a, t);
              var n = u_(a);
              function a() {
                var o;
                a_(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), Da(tu(o), "name", void 0), Da(tu(o), "models", {
                  label: [],
                  tick: [],
                  axisLine: []
                }), Da(tu(o), "drawModels", void 0), Da(tu(o), "yAxisComponent", void 0), Da(tu(o), "theme", void 0), o;
              }
              return s_(a, [{
                key: "initialize",
                value: function(u) {
                  var h = u.name;
                  this.type = "axis", this.name = h, this.yAxisComponent = h === _r.Y;
                }
              }, {
                key: "render",
                value: function(u) {
                  var h = this, v = u.layout, g = u.axes, b = u.theme, C = g.centerYAxis;
                  if (C) {
                    this.theme = Go(b, this.name), this.rect = v[this.name], this.name === "yAxis" && (this.rect = eu(eu({}, this.rect), {}, {
                      x: C.x
                    }));
                    var R = g[this.name], I = R.viewLabels, W = R.tickCount, Z = R.tickInterval, ue = R.needRotateLabel, ke = R.radian, Ee = R.offsetY, Le = {
                      tickInterval: Z,
                      centerYAxis: C,
                      needRotateLabel: ue,
                      radian: ke,
                      offsetY: Ee,
                      relativePositions: Fi(this.axisSize(C), W)
                    }, je = this.yAxisComponent ? "y" : "x", Ke = this.yAxisComponent ? "x" : "y";
                    this.models.label = this.renderLabelModels(I, je, Ke, Le), this.models.tick = this.renderTickModels(je, Ke, Le), this.models.axisLine = this.renderAxisLineModel(C), this.drawModels || (this.drawModels = {
                      tick: [],
                      label: [],
                      axisLine: this.models.axisLine
                    }, ["tick", "label"].forEach(function(ut) {
                      h.drawModels[ut] = h.models[ut].map(function(bt) {
                        var mt = eu({}, bt);
                        return h.yAxisComponent ? mt.y = 0 : mt.x = 0, mt;
                      });
                    }));
                  }
                }
              }, {
                key: "renderAxisLineModel",
                value: function(u) {
                  var h = u.xAxisHalfSize, v = u.secondStartX, g = Cr(0), b = Cr(this.rect.width), C;
                  if (this.yAxisComponent) {
                    var R = Cr(this.rect.height);
                    C = [{
                      type: "line",
                      x: b,
                      y: g,
                      x2: b,
                      y2: R
                    }, {
                      type: "line",
                      x: g,
                      y: g,
                      x2: g,
                      y2: R
                    }];
                  } else
                    C = [{
                      type: "line",
                      x: g,
                      y: g,
                      x2: Cr(h),
                      y2: g
                    }, {
                      type: "line",
                      x: Cr(v),
                      y: g,
                      x2: b,
                      y2: g
                    }];
                  return C;
                }
              }, {
                key: "renderTickModels",
                value: function(u, h, v) {
                  var g = this, b = this.yAxisComponent ? Cr(this.rect.width) : Cr(0), C = v.tickInterval, R = v.centerYAxis.secondStartX, I = v.relativePositions;
                  return I.reduce(function(W, Z, ue) {
                    var ke;
                    if (ue % C)
                      return W;
                    var Ee = (ke = {
                      type: "tick",
                      isYAxis: g.yAxisComponent,
                      tickSize: g.yAxisComponent ? -5 : 5
                    }, Da(ke, u, Cr(Z)), Da(ke, h, b), ke), Le = eu({}, Ee);
                    return g.yAxisComponent ? (Le[h] = Cr(0), Le.tickSize = 5) : Le[u] = Cr(Z + R), [].concat(Bm(W), [Ee, Le]);
                  }, []);
                }
              }, {
                key: "renderLabelModels",
                value: function(u, h, v, g) {
                  var b = this, C = g.centerYAxis, R = C.secondStartX, I = C.yAxisLabelAnchorPoint, W = g.offsetY, Z = g.needRotateLabel, ue = g.radian, ke = this.theme.label, Ee = an(ke), Le, je, Ke;
                  this.yAxisComponent ? (Le = Cr(I), je = "center", Ke = u) : (Le = W, Ke = Bm(u).reverse(), je = Z ? "left" : "center");
                  var ut = ["default", {
                    textAlign: je,
                    font: Ee,
                    fillStyle: ke.color
                  }];
                  return Ke.reduce(function(bt, mt, Rt) {
                    var Dt, Lt = mt.text, Wt = mt.offsetPos, Qt = (Dt = {
                      type: "label",
                      text: Lt,
                      style: ut
                    }, Da(Dt, h, Cr(Wt) + (b.yAxisComponent ? 0 : R)), Da(Dt, v, Le), Da(Dt, "radian", ue), Dt), or = [Qt];
                    if (!b.yAxisComponent) {
                      var lr = eu(eu({}, Qt), {}, Da({
                        text: u[Rt].text
                      }, h, Cr(Qt[h] - R)));
                      or.push(lr);
                    }
                    return [].concat(Bm(bt), or);
                  }, []);
                }
              }, {
                key: "axisSize",
                value: function(u) {
                  var h;
                  return this.yAxisComponent ? h = this.rect.height : h = u.xAxisHalfSize, h;
                }
              }, {
                key: "beforeDraw",
                value: function(u) {
                  u.ctx.strokeStyle = "rgba(0, 0, 0, 0.5)", u.ctx.lineWidth = 1;
                }
              }]), a;
            }(Lr);
            function Ud(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Ud = function(a) {
                return typeof a;
              } : Ud = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Ud(t);
            }
            function pS(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function d_(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? pS(Object(a), !0).forEach(function(o) {
                  h_(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : pS(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function h_(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function p_(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function v_(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function m_(t, n, a) {
              return n && v_(t.prototype, n), t;
            }
            function Vd(t, n, a) {
              return typeof Reflect < "u" && Reflect.get ? Vd = Reflect.get : Vd = function(u, h, v) {
                var g = g_(u, h);
                if (g) {
                  var b = Object.getOwnPropertyDescriptor(g, h);
                  return b.get ? b.get.call(v) : b.value;
                }
              }, Vd(t, n, a || t);
            }
            function g_(t, n) {
              for (; !Object.prototype.hasOwnProperty.call(t, n) && (t = ru(t), t !== null); )
                ;
              return t;
            }
            function y_(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Hm(t, n);
            }
            function Hm(t, n) {
              return Hm = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Hm(t, n);
            }
            function b_(t) {
              var n = x_();
              return function() {
                var o = ru(t), u;
                if (n) {
                  var h = ru(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return S_(this, u);
              };
            }
            function S_(t, n) {
              return n && (Ud(n) === "object" || typeof n == "function") ? n : w_(t);
            }
            function w_(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function x_() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function ru(t) {
              return ru = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, ru(t);
            }
            var k_ = /* @__PURE__ */ function(t) {
              y_(a, t);
              var n = b_(a);
              function a(o) {
                var u = o.el, h = o.options, v = o.data;
                return p_(this, a), n.call(this, {
                  el: u,
                  options: h,
                  series: {
                    bar: v.series
                  },
                  categories: v.categories,
                  modules: [Hl, Vi, Gi, Xa, Za]
                });
              }
              return m_(a, [{
                key: "initialize",
                value: function() {
                  var u;
                  Vd(ru(a.prototype), "initialize", this).call(this);
                  var h = !!((u = this.store.initStoreState.options.series) !== null && u !== void 0 && u.stack);
                  this.componentManager.add(Yn), this.componentManager.add(Un), this.componentManager.add(Qa), this.componentManager.add(Oi), this.componentManager.add(Bd, {
                    name: "bar",
                    stackChart: h
                  }), this.componentManager.add(Im, {
                    name: "bar",
                    stackChart: h
                  }), this.componentManager.add(Nm), this.componentManager.add(Vr, {
                    name: "yAxis"
                  }), this.componentManager.add(Vr, {
                    name: "xAxis"
                  }), this.componentManager.add(Vr, {
                    name: "secondaryYAxis"
                  }), this.componentManager.add(hS, {
                    name: "yAxis"
                  }), this.componentManager.add(hS, {
                    name: "xAxis"
                  }), this.componentManager.add(Yr, {
                    name: "secondaryYAxis"
                  }), this.componentManager.add(Yr, {
                    name: "xAxis"
                  }), this.componentManager.add(Yr, {
                    name: "yAxis"
                  }), this.componentManager.add(Hn, {
                    chartEl: this.el
                  }), this.componentManager.add(Vn), this.componentManager.add(Gn), this.componentManager.add(Yi), this.componentManager.add($n, {
                    chartEl: this.el
                  }), this.componentManager.add(qn), this.painter.addGroups([p, d, w, f, O, m]);
                }
                /**
                 * Add data.
                 * @param {Array} data - Array of data to be added.
                 * @param {string} category - Category to be added.
                 * @api
                 * @example
                 * chart.addData([10, 20], '6');
                 */
              }, {
                key: "addData",
                value: function(u, h) {
                  this.animationControlFlag.updating = !0, this.resetSeries(), this.store.dispatch("addData", {
                    data: u,
                    category: h
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<number|Array<number>>} data.data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function(u) {
                  this.resetSeries(), this.store.dispatch("addSeries", {
                    data: u
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set.
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['1', '2', '3'],
                 *   series: [
                 *     {
                 *       name: 'new series',
                 *       data: [1, 2, 3],
                 *     },
                 *     {
                 *       name: 'new series2',
                 *       data: [4, 5, 6],
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function(u) {
                  var h = u.categories, v = u.series;
                  this.resetSeries(), this.store.dispatch("setData", {
                    series: {
                      bar: v
                    },
                    categories: h
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !1
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !0
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *     date: { format: 'yy/MM' },
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("initOptions", u);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("updateOptions", u);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *   @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only seriesIndex is needed.
                 *   @param {number} [seriesInfo.seriesIndex] - Index of series
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2});
                 */
              }, {
                key: "showTooltip",
                value: function(u) {
                  this.eventBus.emit("showTooltip", d_({}, u));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function() {
                  this.eventBus.emit("hideTooltip");
                }
              }]), a;
            }(Wn);
            function Gd(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Gd = function(a) {
                return typeof a;
              } : Gd = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Gd(t);
            }
            function vS(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function O_(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? vS(Object(a), !0).forEach(function(o) {
                  C_(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : vS(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function C_(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function T_(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function A_(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function E_(t, n, a) {
              return n && A_(t.prototype, n), t;
            }
            function Yd(t, n, a) {
              return typeof Reflect < "u" && Reflect.get ? Yd = Reflect.get : Yd = function(u, h, v) {
                var g = M_(u, h);
                if (g) {
                  var b = Object.getOwnPropertyDescriptor(g, h);
                  return b.get ? b.get.call(v) : b.value;
                }
              }, Yd(t, n, a || t);
            }
            function M_(t, n) {
              for (; !Object.prototype.hasOwnProperty.call(t, n) && (t = nu(t), t !== null); )
                ;
              return t;
            }
            function R_(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && jm(t, n);
            }
            function jm(t, n) {
              return jm = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, jm(t, n);
            }
            function D_(t) {
              var n = I_();
              return function() {
                var o = nu(t), u;
                if (n) {
                  var h = nu(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return P_(this, u);
              };
            }
            function P_(t, n) {
              return n && (Gd(n) === "object" || typeof n == "function") ? n : L_(t);
            }
            function L_(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function I_() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function nu(t) {
              return nu = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, nu(t);
            }
            var __ = /* @__PURE__ */ function(t) {
              R_(a, t);
              var n = D_(a);
              function a(o) {
                var u = o.el, h = o.options, v = o.data;
                return T_(this, a), n.call(this, {
                  el: u,
                  options: h,
                  series: {
                    column: v.series
                  },
                  categories: v.categories,
                  modules: [Hl, Vi, Gi, Xa, Za]
                });
              }
              return E_(a, [{
                key: "initialize",
                value: function() {
                  var u;
                  Yd(nu(a.prototype), "initialize", this).call(this);
                  var h = !!((u = this.store.initStoreState.options.series) !== null && u !== void 0 && u.stack);
                  this.componentManager.add(Yn), this.componentManager.add(Un), this.componentManager.add(Qa), this.componentManager.add(Oi), this.componentManager.add(Im, {
                    name: "column",
                    stackChart: h
                  }), this.componentManager.add(Bd, {
                    name: "column",
                    stackChart: h
                  }), this.componentManager.add(Nm), this.componentManager.add(Vr, {
                    name: "xAxis"
                  }), this.componentManager.add(Vr, {
                    name: "yAxis"
                  }), this.componentManager.add(Yr, {
                    name: "xAxis"
                  }), this.componentManager.add(Yr, {
                    name: "yAxis"
                  }), this.componentManager.add(Hn, {
                    chartEl: this.el
                  }), this.componentManager.add(Vn), this.componentManager.add(Gn), this.componentManager.add(Yi), this.componentManager.add($n, {
                    chartEl: this.el
                  }), this.componentManager.add(qn), this.componentManager.add(Gl), this.painter.addGroups([p, d, w, f, O, m]);
                }
                /**
                 * Add data.
                 * @param {Array<number|Array<number>>} data - Array of data to be added
                 * @param {string} category - Category to be added
                 * @api
                 * @example
                 * chart.addData([10, 20], '6');
                 */
              }, {
                key: "addData",
                value: function(u, h) {
                  this.animationControlFlag.updating = !0, this.resetSeries(), this.store.dispatch("addData", {
                    data: u,
                    category: h
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added
                 *   @param {string} data.name - Series name
                 *   @param {Array<number|Array<number>>} data.data - Array of data to be added
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function(u) {
                  this.resetSeries(), this.store.dispatch("addSeries", {
                    data: u
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['1', '2', '3'],
                 *   series: [
                 *     {
                 *       name: 'new series',
                 *       data: [1, 2, 3],
                 *     },
                 *     {
                 *       name: 'new series2',
                 *       data: [4, 5, 6],
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function(u) {
                  var h = u.categories, v = u.series;
                  this.resetSeries(), this.store.dispatch("setData", {
                    series: {
                      column: v
                    },
                    categories: h
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !1
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !0
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *     date: { format: 'yy/MM' },
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("initOptions", u);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("updateOptions", u);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only seriesIndex is needed.
                 *      @param {number} [seriesInfo.seriesIndex] - Index of series.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2});
                 */
              }, {
                key: "showTooltip",
                value: function(u) {
                  this.eventBus.emit("showTooltip", O_({}, u));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function() {
                  this.eventBus.emit("hideTooltip");
                }
              }]), a;
            }(Wn);
            function qd(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? qd = function(a) {
                return typeof a;
              } : qd = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, qd(t);
            }
            function mS(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function gS(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? mS(Object(a), !0).forEach(function(o) {
                  N_(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : mS(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function N_(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function B_(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function F_(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function z_(t, n, a) {
              return n && F_(t.prototype, n), t;
            }
            function Kd(t, n, a) {
              return typeof Reflect < "u" && Reflect.get ? Kd = Reflect.get : Kd = function(u, h, v) {
                var g = H_(u, h);
                if (g) {
                  var b = Object.getOwnPropertyDescriptor(g, h);
                  return b.get ? b.get.call(v) : b.value;
                }
              }, Kd(t, n, a || t);
            }
            function H_(t, n) {
              for (; !Object.prototype.hasOwnProperty.call(t, n) && (t = iu(t), t !== null); )
                ;
              return t;
            }
            function j_(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Wm(t, n);
            }
            function Wm(t, n) {
              return Wm = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Wm(t, n);
            }
            function W_(t) {
              var n = V_();
              return function() {
                var o = iu(t), u;
                if (n) {
                  var h = iu(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return $_(this, u);
              };
            }
            function $_(t, n) {
              return n && (qd(n) === "object" || typeof n == "function") ? n : U_(t);
            }
            function U_(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function V_() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function iu(t) {
              return iu = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, iu(t);
            }
            function yS(t, n) {
              return t.find(function(a) {
                var o = a.component;
                return o.name === n && o.eventDetectType === "point";
              });
            }
            function G_(t) {
              return oe(yS(t, "column")) && oe(yS(t, "line"));
            }
            var Y_ = /* @__PURE__ */ function(t) {
              j_(a, t);
              var n = W_(a);
              function a(o) {
                var u = o.el, h = o.options, v = o.data, g = v.series, b = v.categories;
                return B_(this, a), n.call(this, {
                  el: u,
                  options: h,
                  series: g,
                  categories: b,
                  modules: [Hl, Vi, Gi, Xa, Za]
                });
              }
              return z_(a, [{
                key: "initialize",
                value: function() {
                  Kd(iu(a.prototype), "initialize", this).call(this), this.componentManager.add(Yn), this.componentManager.add(Un), this.componentManager.add(Qa), this.componentManager.add(Oi), this.componentManager.add(Im, {
                    name: "column"
                  }), this.componentManager.add(Bd, {
                    name: "column"
                  }), this.componentManager.add(Hf), this.componentManager.add(Nm), this.componentManager.add(Vr, {
                    name: "xAxis"
                  }), this.componentManager.add(Vr, {
                    name: "yAxis"
                  }), this.componentManager.add(Vr, {
                    name: "secondaryYAxis"
                  }), this.componentManager.add(Yr, {
                    name: "xAxis"
                  }), this.componentManager.add(Yr, {
                    name: "yAxis"
                  }), this.componentManager.add(Yr, {
                    name: "secondaryYAxis"
                  }), this.componentManager.add(Hn, {
                    chartEl: this.el
                  }), this.componentManager.add(Vn), this.componentManager.add(Gn), this.componentManager.add(Yi), this.componentManager.add(Gl), this.componentManager.add($n, {
                    chartEl: this.el
                  }), this.componentManager.add(qn), this.painter.addGroups([p, d, w, f, O, m, k]);
                }
              }, {
                key: "handleEventForAllResponders",
                value: function(u, h, v, g) {
                  if (G_(h)) {
                    var b = h.find(function(C) {
                      var R = C.component;
                      return R.name === "column";
                    });
                    b.component[v]({
                      mousePosition: g,
                      responders: []
                    }, u);
                  }
                }
                /**
                 * Add data.
                 * @param {Array} data - Array of data to be added.
                 * @param {string} category - Category to be added.
                 * @param {string} chartType - Which type of chart to add.
                 * @api
                 * @example
                 * chart.addData([10, 20], '6', 'line');
                 */
              }, {
                key: "addData",
                value: function(u, h, v) {
                  this.animationControlFlag.updating = !0, this.resetSeries(), this.store.dispatch("addData", {
                    data: u,
                    category: h,
                    chartType: v
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 * @param {string} data.name - Series name.
                 * @param {Array<number>} data.data - Array of data to be added.
                 * @param {Object} dataInfo - Which type of chart to add.
                 * @param {Object} dataInfo.chartType - Chart type.
                 * @api
                 * @example
                 * chart.addSeries(
                 *   {
                 *     name: 'newSeries',
                 *     data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
                 *   },
                 *   {
                 *     chartType: 'line'
                 *   });
                 */
              }, {
                key: "addSeries",
                value: function(u, h) {
                  this.resetSeries(), this.store.dispatch("addSeries", gS({
                    data: u
                  }, h));
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['1', '2', '3'],
                 *   series: {
                 *     column: [
                 *       {
                 *         name: 'A',
                 *         data: [1, 2, 3],
                 *       }
                 *     ],
                 *     line: [
                 *       {
                 *         name: 'B',
                 *         data: [4, 5, 6],
                 *       }
                 *     ]
                 *   }
                 * });
                 */
              }, {
                key: "setData",
                value: function(u) {
                  this.resetSeries(), this.store.dispatch("setData", u);
                }
                /**
                 * Add plot line.
                 * @param {Object} data - Plot info.
                 *   @param {string|number} data.value - The value where the plot line will be drawn.
                 *   @param {string} data.color - Plot line color.
                 *   @param {string} [data.id] - Plot id. The value on which the removePlotLine is based.
                 * @api
                 * @example
                 * chart.addPlotLine({
                 *   value: 2,
                 *   color: '#00ff22',
                 *   id: 'plot-1',
                 * });
                 */
              }, {
                key: "addPlotLine",
                value: function(u) {
                  this.store.dispatch("addPlotLine", {
                    data: u
                  });
                }
                /**
                 * Remove plot line with id.
                 * @param {string} id - Id of the plot line to be removed
                 * @api
                 * @example
                 * chart.removePlotLine('plot-1');
                 */
              }, {
                key: "removePlotLine",
                value: function(u) {
                  this.store.dispatch("removePlotLine", {
                    id: u
                  });
                }
                /**
                 * Add plot band.
                 * @param {Object} data - plot info
                 *   @param {Array<string|number>} data.range - The range to be drawn
                 *   @param {string} data.color - Plot band color
                 *   @param {string} [data.id] - Plot id. The value on which the removePlotBand is based
                 * @api
                 * @example
                 * chart.addPlotBand({
                 *   value: [2, 4],
                 *   color: '#00ff22',
                 *   id: 'plot-1',
                 * });
                 */
              }, {
                key: "addPlotBand",
                value: function(u) {
                  this.store.dispatch("addPlotBand", {
                    data: u
                  });
                }
                /**
                 * Remove plot band with id.
                 * @param {string} id - id of the plot band to be removed
                 * @api
                 * @example
                 * chart.removePlotBand('plot-1');
                 */
              }, {
                key: "removePlotBand",
                value: function(u) {
                  this.store.dispatch("removePlotBand", {
                    id: u
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !1
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !0
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *     date: { format: 'yy/MM' },
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     line: {
                 *       showDot: true,
                 *     },
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("initOptions", u);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   series: {
                 *     line: {
                 *       showDot: true,
                 *     },
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("updateOptions", u);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.seriesIndex - Index of series.
                 *      @param {number} seriesInfo.index - Index of data within series.
                 *      @param {string} seriesInfo.chartType - Specify which chart to select.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2, chartType: 'column'});
                 */
              }, {
                key: "showTooltip",
                value: function(u) {
                  this.eventBus.emit("showTooltip", gS({}, u));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function() {
                  this.eventBus.emit("hideTooltip");
                }
              }]), a;
            }(Wn);
            function Xd(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Xd = function(a) {
                return typeof a;
              } : Xd = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Xd(t);
            }
            function bS(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function SS(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? bS(Object(a), !0).forEach(function(o) {
                  La(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : bS(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function q_(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function K_(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function X_(t, n, a) {
              return n && K_(t.prototype, n), t;
            }
            function J_(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && $m(t, n);
            }
            function $m(t, n) {
              return $m = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, $m(t, n);
            }
            function Z_(t) {
              var n = eN();
              return function() {
                var o = Jd(t), u;
                if (n) {
                  var h = Jd(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return Q_(this, u);
              };
            }
            function Q_(t, n) {
              return n && (Xd(n) === "object" || typeof n == "function") ? n : Pa(t);
            }
            function Pa(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function eN() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function Jd(t) {
              return Jd = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, Jd(t);
            }
            function La(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function wS(t) {
              return iN(t) || nN(t) || rN(t) || tN();
            }
            function tN() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function rN(t, n) {
              if (t) {
                if (typeof t == "string") return Um(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return Um(t, n);
              }
            }
            function nN(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function iN(t) {
              if (Array.isArray(t)) return Um(t);
            }
            function Um(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            var aN = 0.5, oN = 1;
            function xS(t) {
              return t.reduce(function(n, a) {
                var o = a.data.filter(function(u) {
                  return !Oe(u);
                });
                return Math.max.apply(Math, [n].concat(wS(o.map(function(u) {
                  var h = u.r;
                  return h;
                }))));
              }, 0);
            }
            var sN = /* @__PURE__ */ function(t) {
              J_(a, t);
              var n = Z_(a);
              function a() {
                var o;
                q_(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), La(Pa(o), "models", {
                  series: []
                }), La(Pa(o), "drawModels", void 0), La(Pa(o), "responders", void 0), La(Pa(o), "activatedResponders", []), La(Pa(o), "theme", void 0), La(Pa(o), "rect", void 0), La(Pa(o), "maxRadius", -1), La(Pa(o), "maxValue", -1), La(Pa(o), "onMouseoutComponent", function() {
                  o.eventBus.emit("seriesPointHovered", {
                    models: [],
                    name: o.name
                  }), o.eventBus.emit("renderHoveredSeries", {
                    models: [],
                    name: o.name
                  }), o.eventBus.emit("needDraw");
                }), La(Pa(o), "selectSeries", function(g) {
                  var b = g.index, C = g.seriesIndex, R = g.state;
                  if (!(!Me(b) || !Me(C))) {
                    var I = R.series.bubble.data[b].name, W = o.responders.filter(function(ue) {
                      var ke = ue.name;
                      return ke === I;
                    })[C];
                    if (!W)
                      throw new Error(ve.SELECT_SERIES_API_INDEX_ERROR);
                    var Z = o.getResponderAppliedTheme([W], "select");
                    o.eventBus.emit("renderSelectedSeries", {
                      models: Z,
                      name: o.name
                    }), o.eventBus.emit("needDraw");
                  }
                }), La(Pa(o), "showTooltip", function(g) {
                  var b = g.index, C = g.seriesIndex, R = g.state;
                  if (!(!Me(b) || !Me(C))) {
                    var I = R.series.bubble.data[C].name, W = [o.responders.filter(function(Z) {
                      var ue = Z.name;
                      return ue === I;
                    })[b]];
                    W.length && (o.eventBus.emit("renderHoveredSeries", {
                      models: W,
                      name: o.name
                    }), o.activatedResponders = W, o.eventBus.emit("seriesPointHovered", {
                      models: o.activatedResponders,
                      name: o.name
                    }), o.eventBus.emit("needDraw"));
                  }
                }), o;
              }
              return X_(a, [{
                key: "initialize",
                value: function() {
                  this.type = "series", this.name = "bubble", this.eventBus.on("selectSeries", this.selectSeries), this.eventBus.on("showTooltip", this.showTooltip), this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "initUpdate",
                value: function(u) {
                  var h = this;
                  this.drawModels.series.forEach(function(v, g) {
                    v.radius = h.models.series[g].radius * u;
                  });
                }
              }, {
                key: "render",
                value: function(u) {
                  var h = u.layout, v = u.series, g = u.scale, b = u.axes, C = u.circleLegend, R = u.legend, I = u.options, W = u.theme, Z = h.plot;
                  if (!v.bubble)
                    throw new Error(ve.noDataError(this.name));
                  var ue = b.xAxis, ke = b.yAxis, Ee = v.bubble.data;
                  this.theme = W.series.bubble, this.rect = Z, this.activeSeriesMap = Ea(R), this.selectable = this.getSelectableOption(I);
                  var Le = this.rect.width / ue.tickCount, je = this.rect.height / ke.tickCount;
                  this.maxRadius = C.radius ? C.radius : Math.min(Le, je), this.maxValue = xS(Ee);
                  var Ke = this.renderBubblePointsModel(Ee, g), ut = this.makeTooltipModel(Ee);
                  this.models.series = Ke, this.drawModels || (this.drawModels = wt(this.models)), this.responders = Ke.map(function(bt, mt) {
                    return SS(SS({}, bt), {}, {
                      type: "circle",
                      detectionSize: 0,
                      radius: bt.radius + oN,
                      color: cr(bt.color, 0.85),
                      data: ut[mt],
                      index: mt
                    });
                  });
                }
              }, {
                key: "renderBubblePointsModel",
                value: function(u, h) {
                  var v = this, g = h.xAxis.limit, b = h.yAxis.limit, C = this.theme, R = C.borderWidth, I = C.borderColor;
                  return u.flatMap(function(W, Z) {
                    var ue = W.data, ke = W.name, Ee = W.color, Le = [], je = v.activeSeriesMap[ke], Ke = cr(Ee, je ? 0.8 : 0.1), ut = ue.filter(function(bt) {
                      return !Oe(bt);
                    });
                    return ut.forEach(function(bt) {
                      var mt = Ka(bt), Rt = Ie(mt) ? Number(new Date(mt)) : Number(mt), Dt = qo(bt), Lt = bo(Rt, g), Wt = bo(Dt, b), Qt = Lt * v.rect.width, or = (1 - Wt) * v.rect.height, lr = Math.max(aN, bt.r / v.maxValue * v.maxRadius);
                      Le.push({
                        x: Qt,
                        y: or,
                        type: "circle",
                        radius: lr,
                        color: Ke,
                        style: ["default"],
                        seriesIndex: Z,
                        name: ke,
                        borderWidth: R,
                        borderColor: I
                      });
                    }), Le;
                  });
                }
              }, {
                key: "makeTooltipModel",
                value: function(u) {
                  return wS(u).flatMap(function(h) {
                    var v = h.data, g = h.name, b = h.color, C = [], R = v.filter(function(I) {
                      return !Oe(I);
                    });
                    return R.forEach(function(I) {
                      var W = I.r, Z = I.label;
                      C.push({
                        label: "".concat(g, "/").concat(Z),
                        color: b,
                        value: {
                          x: Ka(I),
                          y: qo(I),
                          r: W
                        }
                      });
                    }), C;
                  });
                }
              }, {
                key: "getResponderAppliedTheme",
                value: function(u, h) {
                  var v = this;
                  return u.map(function(g) {
                    return Ye(g, v.theme[h]);
                  });
                }
              }, {
                key: "onMousemove",
                value: function(u) {
                  var h = u.responders, v = u.mousePosition, g = jl(h, v, this.rect), b = this.getResponderAppliedTheme(g, "hover");
                  this.eventBus.emit("renderHoveredSeries", {
                    models: b,
                    name: this.name
                  }), this.activatedResponders = g, this.eventBus.emit("seriesPointHovered", {
                    models: this.activatedResponders,
                    name: this.name
                  }), this.eventBus.emit("needDraw");
                }
              }, {
                key: "onClick",
                value: function(u) {
                  var h = u.responders, v = u.mousePosition;
                  if (this.selectable) {
                    var g = jl(h, v, this.rect), b = this.getResponderAppliedTheme(g, "select");
                    this.eventBus.emit("renderSelectedSeries", {
                      models: b,
                      name: this.name
                    }), this.eventBus.emit("needDraw");
                  }
                }
              }]), a;
            }(Lr);
            function Zd(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Zd = function(a) {
                return typeof a;
              } : Zd = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Zd(t);
            }
            function lN(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function uN(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function cN(t, n, a) {
              return n && uN(t.prototype, n), t;
            }
            function fN(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Vm(t, n);
            }
            function Vm(t, n) {
              return Vm = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Vm(t, n);
            }
            function dN(t) {
              var n = pN();
              return function() {
                var o = Qd(t), u;
                if (n) {
                  var h = Qd(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return hN(this, u);
              };
            }
            function hN(t, n) {
              return n && (Zd(n) === "object" || typeof n == "function") ? n : kS(t);
            }
            function kS(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function pN() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function Qd(t) {
              return Qd = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, Qd(t);
            }
            function vN(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var mN = /* @__PURE__ */ function(t) {
              fN(a, t);
              var n = dN(a);
              function a() {
                var o;
                lN(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), vN(kS(o), "models", {
                  circleLegend: []
                }), o;
              }
              return cN(a, [{
                key: "initialize",
                value: function() {
                  this.type = "circleLegend";
                }
              }, {
                key: "render",
                value: function(u) {
                  var h = u.layout, v = u.series, g = u.circleLegend;
                  if (!v.bubble)
                    throw new Error(ve.CIRCLE_LEGEND_RENDER_ERROR);
                  if (this.isShow = g.visible, !!this.isShow) {
                    var b = v.bubble.data;
                    this.rect = h.circleLegend, this.renderCircleLegend(b, g);
                  }
                }
              }, {
                key: "renderCircleLegend",
                value: function(u, h) {
                  var v = xS(u), g = h.radius;
                  this.models.circleLegend = [{
                    type: "circleLegend",
                    radius: g,
                    value: v,
                    x: g,
                    y: this.rect.height - g
                  }];
                }
              }]), a;
            }(Lr);
            function gN(t, n) {
              var a = n.x, o = n.y, u = n.radius, h = n.value, v = [1, 0.5, 0.25];
              v.forEach(function(g, b) {
                var C = g * u, R = o + (b ? (1 - g) * u : 0);
                Rr(t, {
                  x: a,
                  y: R,
                  radius: C,
                  color: "#fff",
                  style: ["default", {
                    strokeStyle: "#888",
                    lineWidth: 1
                  }]
                }), Ni(t, {
                  x: a,
                  y: R - C,
                  text: String(h * g),
                  style: ["default", {
                    textAlign: "center",
                    textBaseline: "bottom"
                  }]
                });
              });
            }
            function eh(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? eh = function(a) {
                return typeof a;
              } : eh = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, eh(t);
            }
            function OS(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function CS(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? OS(Object(a), !0).forEach(function(o) {
                  yN(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : OS(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function yN(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function bN(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function SN(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function wN(t, n, a) {
              return n && SN(t.prototype, n), t;
            }
            function th(t, n, a) {
              return typeof Reflect < "u" && Reflect.get ? th = Reflect.get : th = function(u, h, v) {
                var g = xN(u, h);
                if (g) {
                  var b = Object.getOwnPropertyDescriptor(g, h);
                  return b.get ? b.get.call(v) : b.value;
                }
              }, th(t, n, a || t);
            }
            function xN(t, n) {
              for (; !Object.prototype.hasOwnProperty.call(t, n) && (t = au(t), t !== null); )
                ;
              return t;
            }
            function kN(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Gm(t, n);
            }
            function Gm(t, n) {
              return Gm = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Gm(t, n);
            }
            function ON(t) {
              var n = AN();
              return function() {
                var o = au(t), u;
                if (n) {
                  var h = au(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return CN(this, u);
              };
            }
            function CN(t, n) {
              return n && (eh(n) === "object" || typeof n == "function") ? n : TN(t);
            }
            function TN(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function AN() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function au(t) {
              return au = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, au(t);
            }
            var EN = /* @__PURE__ */ function(t) {
              kN(a, t);
              var n = ON(a);
              function a(o) {
                return bN(this, a), n.call(this, {
                  el: o.el,
                  options: o.options,
                  series: {
                    bubble: o.data.series
                  },
                  modules: [Vi, Gi, Xa, Za]
                });
              }
              return wN(a, [{
                key: "initialize",
                value: function() {
                  th(au(a.prototype), "initialize", this).call(this), this.componentManager.add(Yn), this.componentManager.add(Un), this.componentManager.add(Qa), this.componentManager.add(Oi), this.componentManager.add(sN), this.componentManager.add(Vr, {
                    name: "xAxis"
                  }), this.componentManager.add(Vr, {
                    name: "yAxis"
                  }), this.componentManager.add(Yr, {
                    name: "xAxis"
                  }), this.componentManager.add(Yr, {
                    name: "yAxis"
                  }), this.componentManager.add(Hn, {
                    chartEl: this.el
                  }), this.componentManager.add(Vn), this.componentManager.add(Gn), this.componentManager.add($n, {
                    chartEl: this.el
                  }), this.componentManager.add(mN), this.componentManager.add(qn), this.painter.addGroups([p, d, j, w, f, O]);
                }
                /**
                 * Add data.
                 * @param {Array<Object>} data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addData([
                 *   {x: 10, y: 20, r: 10, label: 'label1'},
                 *   {x: 30, y: 40, r: 10, label: 'label2'},
                 * ]);
                 */
              }, {
                key: "addData",
                value: function(u) {
                  this.animationControlFlag.updating = !0, this.resetSeries(), this.store.dispatch("addData", {
                    data: u
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<Object>} data.data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: [
                 *     {x: 10, y: 20, r: 10, label: 'label1'},
                 *     {x: 30, y: 40, r: 10, label: 'label2'},
                 *   ],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function(u) {
                  this.resetSeries(), this.store.dispatch("addSeries", {
                    data: u
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set.
                 * @api
                 * @example
                 * chart.setData({
                 *   series: [
                 *     {
                 *       name: 'name'
                 *       data: [
                 *         {x: 10, y: 20, r: 10, label: 'label1'},
                 *         {x: 30, y: 40, r: 10, label: 'label2'},
                 *       ]
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function(u) {
                  this.resetSeries(), this.store.dispatch("setData", {
                    series: {
                      bubble: u.series
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *     date: { format: 'yy/MM' },
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("initOptions", u);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("updateOptions", u);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.seriesIndex - Index of series.
                 *      @param {number} seriesInfo.index - Index of data within series.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2});
                 */
              }, {
                key: "showTooltip",
                value: function(u) {
                  this.eventBus.emit("showTooltip", CS(CS({}, u), {}, {
                    state: this.store.state
                  }));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function() {
                  this.eventBus.emit("hideTooltip");
                }
              }]), a;
            }(Wn);
            function rh(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? rh = function(a) {
                return typeof a;
              } : rh = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, rh(t);
            }
            function MN(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function RN(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function DN(t, n, a) {
              return n && RN(t.prototype, n), t;
            }
            function nh(t, n, a) {
              return typeof Reflect < "u" && Reflect.get ? nh = Reflect.get : nh = function(u, h, v) {
                var g = PN(u, h);
                if (g) {
                  var b = Object.getOwnPropertyDescriptor(g, h);
                  return b.get ? b.get.call(v) : b.value;
                }
              }, nh(t, n, a || t);
            }
            function PN(t, n) {
              for (; !Object.prototype.hasOwnProperty.call(t, n) && (t = ou(t), t !== null); )
                ;
              return t;
            }
            function LN(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Ym(t, n);
            }
            function Ym(t, n) {
              return Ym = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Ym(t, n);
            }
            function IN(t) {
              var n = BN();
              return function() {
                var o = ou(t), u;
                if (n) {
                  var h = ou(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return _N(this, u);
              };
            }
            function _N(t, n) {
              return n && (rh(n) === "object" || typeof n == "function") ? n : NN(t);
            }
            function NN(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function BN() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function ou(t) {
              return ou = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, ou(t);
            }
            function FN(t) {
              return WN(t) || jN(t) || HN(t) || zN();
            }
            function zN() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function HN(t, n) {
              if (t) {
                if (typeof t == "string") return qm(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return qm(t, n);
              }
            }
            function jN(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function WN(t) {
              if (Array.isArray(t)) return qm(t);
            }
            function qm(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function TS(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function ih(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? TS(Object(a), !0).forEach(function(o) {
                  $N(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : TS(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function $N(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function UN(t) {
              return t.map(function(n) {
                var a = {};
                return ih(ih({}, n), {}, {
                  data: n.data.filter(function(o) {
                    return !Oe(o);
                  }).reduce(function(o, u) {
                    var h = Ka(u), v = qo(u), g = "".concat(h, "-").concat(v);
                    return a[g] ? o : (a[g] = !0, [].concat(FN(o), [u]));
                  }, [])
                });
              });
            }
            var VN = /* @__PURE__ */ function(t) {
              LN(a, t);
              var n = IN(a);
              function a(o) {
                var u;
                return MN(this, a), n.call(this, {
                  el: o.el,
                  options: o.options,
                  series: {
                    scatter: UN(o.data.series)
                  },
                  categories: (u = o.data) === null || u === void 0 ? void 0 : u.categories,
                  modules: [Vi, Gi, Xa, Za]
                });
              }
              return DN(a, [{
                key: "initialize",
                value: function() {
                  nh(ou(a.prototype), "initialize", this).call(this), this.componentManager.add(Yn), this.componentManager.add(Un), this.componentManager.add(Qa), this.componentManager.add(Oi), this.componentManager.add(tS), this.componentManager.add(Vr, {
                    name: "xAxis"
                  }), this.componentManager.add(Vr, {
                    name: "yAxis"
                  }), this.componentManager.add(Yr, {
                    name: "xAxis"
                  }), this.componentManager.add(Yr, {
                    name: "yAxis"
                  }), this.componentManager.add(Hn, {
                    chartEl: this.el
                  }), this.componentManager.add(Vn), this.componentManager.add(Gn), this.componentManager.add($n, {
                    chartEl: this.el
                  }), this.componentManager.add(qn), this.painter.addGroups([p, d, w, f, O, x]);
                }
                /**
                 * Add data.
                 * @param {Array<Object>} data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addData([
                 *   {x: 10, y: 20},
                 *   {x: 30, y: 40},
                 * ]);
                 */
              }, {
                key: "addData",
                value: function(u) {
                  this.animationControlFlag.updating = !0, this.resetSeries(), this.store.dispatch("addData", {
                    data: u
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array} data.data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: [
                 *     {x: 10, y: 20},
                 *     {x: 30, y: 40},
                 *   ],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function(u) {
                  this.resetSeries(), this.store.dispatch("addSeries", {
                    data: u
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set.
                 * @api
                 * @example
                 * chart.setData({
                 *   series: [
                 *     {
                 *       name: 'name'
                 *       data: [
                 *         {x: 10, y: 20},
                 *         {x: 30, y: 40},
                 *       ]
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function(u) {
                  var h = u.categories, v = u.series;
                  this.resetSeries(), this.store.dispatch("setData", {
                    series: {
                      scatter: v
                    },
                    categories: h
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("initOptions", u);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("updateOptions", u);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.seriesIndex - Index of series.
                 *      @param {number} seriesInfo.index - Index of data within series.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2});
                 */
              }, {
                key: "showTooltip",
                value: function(u) {
                  this.eventBus.emit("showTooltip", ih(ih({}, u), {}, {
                    state: this.store.state
                  }));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function() {
                  this.eventBus.emit("hideTooltip");
                }
              }]), a;
            }(Wn);
            function ah(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? ah = function(a) {
                return typeof a;
              } : ah = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, ah(t);
            }
            function GN(t, n) {
              return KN(t) || qN(t, n) || ES(t, n) || YN();
            }
            function YN() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function qN(t, n) {
              var a = t && (typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]);
              if (a != null) {
                var o = [], u = !0, h = !1, v, g;
                try {
                  for (a = a.call(t); !(u = (v = a.next()).done) && (o.push(v.value), !(n && o.length === n)); u = !0)
                    ;
                } catch (b) {
                  h = !0, g = b;
                } finally {
                  try {
                    !u && a.return != null && a.return();
                  } finally {
                    if (h) throw g;
                  }
                }
                return o;
              }
            }
            function KN(t) {
              if (Array.isArray(t)) return t;
            }
            function XN(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function JN(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function ZN(t, n, a) {
              return n && JN(t.prototype, n), t;
            }
            function QN(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Km(t, n);
            }
            function Km(t, n) {
              return Km = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Km(t, n);
            }
            function eB(t) {
              var n = rB();
              return function() {
                var o = oh(t), u;
                if (n) {
                  var h = oh(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return tB(this, u);
              };
            }
            function tB(t, n) {
              return n && (ah(n) === "object" || typeof n == "function") ? n : da(t);
            }
            function da(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function rB() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function oh(t) {
              return oh = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, oh(t);
            }
            function AS(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function ln(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? AS(Object(a), !0).forEach(function(o) {
                  ha(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : AS(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function ha(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function Ia(t) {
              return aB(t) || iB(t) || ES(t) || nB();
            }
            function nB() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function ES(t, n) {
              if (t) {
                if (typeof t == "string") return Xm(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return Xm(t, n);
              }
            }
            function iB(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function aB(t) {
              if (Array.isArray(t)) return Xm(t);
            }
            function Xm(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            var oB = 0.6, sB = 5;
            function MS(t, n, a) {
              return {
                width: t ? n : a,
                height: t ? a : n
              };
            }
            function Jm(t, n, a) {
              return t * n + (n - a) / 2;
            }
            function lB(t, n) {
              var a = t.range, o = t.marker, u = t.bullet, h = n.range, v = n.marker, g = n.bullet;
              return [].concat(Ia(a.map(function(b, C) {
                return ln(ln({}, b), {}, {
                  data: h[C]
                });
              })), Ia(u.map(function(b, C) {
                return ln(ln({}, b), {}, {
                  data: g[C]
                });
              })), Ia(o.map(function(b, C) {
                return ln(ln({}, b), {}, {
                  detectionSize: sB,
                  data: v[C]
                });
              })));
            }
            var uB = /* @__PURE__ */ function(t) {
              QN(a, t);
              var n = eB(a);
              function a() {
                var o;
                XN(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), ha(da(o), "models", {
                  range: [],
                  bullet: [],
                  marker: []
                }), ha(da(o), "drawModels", void 0), ha(da(o), "responders", void 0), ha(da(o), "activatedResponders", []), ha(da(o), "theme", void 0), ha(da(o), "eventDetectType", "point"), ha(da(o), "tooltipRectMap", void 0), ha(da(o), "vertical", !1), ha(da(o), "basePosition", void 0), ha(da(o), "onMouseoutComponent", function() {
                  o.eventBus.emit("seriesPointHovered", {
                    models: [],
                    name: o.name
                  }), o.eventBus.emit("renderHoveredSeries", {
                    models: [],
                    name: o.name
                  }), o.eventBus.emit("needDraw");
                }), ha(da(o), "selectSeries", function(g) {
                  var b, C = g.seriesIndex, R = g.state;
                  if (Me(C)) {
                    var I = (b = R.series.bullet) === null || b === void 0 ? void 0 : b[C], W = I.name, Z = o.filterBulletResponder(o.responders).filter(function(ue) {
                      var ke = ue.name;
                      return ke === W;
                    });
                    if (!Z)
                      throw new Error(ve.SELECT_SERIES_API_INDEX_ERROR);
                    o.eventBus.emit("renderSelectedSeries", {
                      models: o.getRespondersWithTheme(Z, "select"),
                      name: o.name
                    }), o.eventBus.emit("needDraw");
                  }
                }), ha(da(o), "showTooltip", function(g) {
                  var b, C = g.seriesIndex, R = g.state;
                  if (Me(C)) {
                    var I = (b = R.series.bullet) === null || b === void 0 ? void 0 : b[C], W = I.name, Z = o.filterBulletResponder(o.responders).filter(function(ue) {
                      var ke = ue.name;
                      return ke === W;
                    });
                    Z.length && o.onMousemove({
                      responders: Z
                    });
                  }
                }), o;
              }
              return ZN(a, [{
                key: "initialize",
                value: function() {
                  this.type = "series", this.name = "bullet", this.eventBus.on("selectSeries", this.selectSeries), this.eventBus.on("showTooltip", this.showTooltip), this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "initUpdate",
                value: function(u) {
                  if (this.drawModels) {
                    var h = this.drawModels.clipRect;
                    if (h) {
                      var v = this.vertical ? "y" : "x", g = this.vertical ? "height" : "width", b = h[0], C = this.models.clipRect[0], R = b[g] + (C[g] - b[g]) * u;
                      b[g] = R, b[v] = Math.max(this.basePosition - R * this.basePosition / C[g], 0);
                    }
                  }
                }
              }, {
                key: "render",
                value: function(u) {
                  var h, v = u.layout, g = u.axes, b = u.series, C = u.scale, R = u.legend, I = u.options, W = u.theme, Z = u.categories;
                  if (!b.bullet)
                    throw new Error(ve.noDataError(this.name));
                  this.setEventDetectType(b, I), this.theme = W.series.bullet, this.rect = v.plot, this.activeSeriesMap = Ea(R), this.selectable = this.getSelectableOption(I), this.vertical = !!(I != null && (h = I.series) !== null && h !== void 0 && h.vertical);
                  var ue = sa({
                    series: b,
                    options: I
                  }), ke = ff(ue, b), Ee = ke.labelAxisName, Le = ke.valueAxisName, je = df(ue), Ke = je.valueSizeKey, ut = g[Ee].tickDistance, bt = g[Le].zeroPosition, mt = C[Le].limit, Rt = mt.min, Dt = mt.max, Lt = b.bullet.data;
                  this.basePosition = bt ?? 0;
                  var Wt = ln({
                    ratio: this.rect[Ke] / (Dt - Rt),
                    tickDistance: ut,
                    zeroPosition: bt
                  }, this.getBulletBarWidths(ut)), Qt = this.renderRanges(Lt, Wt), or = this.renderBullet(Lt, Wt), lr = this.renderMarkers(Lt, Wt), xr = this.renderClipRectArea();
                  this.models.clipRect = [xr], this.models.range = Qt, this.models.bullet = or, this.models.marker = lr, this.drawModels || (this.drawModels = {
                    clipRect: [this.makeInitialClipRectModel(xr)],
                    range: tt(Qt),
                    bullet: tt(or),
                    marker: tt(lr)
                  });
                  var br = {
                    range: Qt,
                    bullet: or,
                    marker: lr
                  }, yr = this.makeTooltipModel(br);
                  this.tooltipRectMap = this.makeTooltipRectMap(br, yr), this.responders = this.getBulletSeriesResponders(br, yr, g, Z), Ma(I, this.name).visible && this.renderDataLabels(this.getDataLabels([].concat(Ia(Qt), Ia(or), Ia(lr)), this.vertical, this.rect[Ke]));
                }
              }, {
                key: "renderClipRectArea",
                value: function() {
                  return {
                    type: "clipRectArea",
                    x: 0,
                    y: 0,
                    width: this.rect.width,
                    height: this.rect.height
                  };
                }
              }, {
                key: "makeInitialClipRectModel",
                value: function(u) {
                  var h = this.vertical ? u.width : 0, v = this.vertical ? 0 : u.height, g = this.vertical ? u.x : 0, b = this.vertical ? 0 : u.y;
                  return {
                    type: "clipRectArea",
                    width: h,
                    height: v,
                    x: g,
                    y: b
                  };
                }
              }, {
                key: "getDataLabels",
                value: function(u, h, v) {
                  var g = this.theme.dataLabels, b = He(g, "marker"), C = b.useSeriesColor, R = b.color, I = g.marker;
                  return u.filter(function(W) {
                    return W.type === "line" || W.modelType !== "range";
                  }).map(function(W) {
                    if (W.type === "line")
                      return ln(ln({}, W), {}, {
                        x: h ? (W.x + W.x2) / 2 : W.x,
                        theme: ln(ln({}, I), {}, {
                          color: I.useSeriesColor ? W.strokeStyle : I.color
                        })
                      });
                    var Z = Me(W.value) && (W == null ? void 0 : W.value) < 0, ue = h ? "top" : "right";
                    return Z && (ue = h ? "bottom" : "left"), ln(ln({}, W), {}, {
                      direction: ue,
                      plot: {
                        x: 0,
                        y: 0,
                        size: v
                      },
                      theme: ln(ln({}, b), {}, {
                        color: C ? W.color : R
                      })
                    });
                  });
                }
              }, {
                key: "setEventDetectType",
                value: function(u, h) {
                  var v;
                  h != null && (v = h.series) !== null && v !== void 0 && v.eventDetectType && (this.eventDetectType = h.series.eventDetectType);
                }
              }, {
                key: "getBulletSeriesResponders",
                value: function(u, h, v, g) {
                  return this.eventDetectType === "grouped" ? Nf(this.rect, this.vertical ? v.xAxis : v.yAxis, g, this.vertical) : lB(u, h);
                }
              }, {
                key: "makeTooltipRectMap",
                value: function(u, h) {
                  var v = {};
                  return Object.keys(u).forEach(function(g) {
                    u[g].forEach(function(b, C) {
                      var R = b.name;
                      v[R] || (v[R] = []);
                      var I = ln(ln({}, b), {}, {
                        data: h[g][C]
                      });
                      v[R].push(I);
                    });
                  }), v;
                }
              }, {
                key: "getBulletSeriesModelsFromRectResponders",
                value: function(u) {
                  var h;
                  return u.length ? (h = this.tooltipRectMap[u[0].label]) !== null && h !== void 0 ? h : [] : [];
                }
              }, {
                key: "getGroupedRect",
                value: function(u, h) {
                  var v = this.getBulletSeriesModelsFromRectResponders(u), g = this.theme[h].groupedRect, b = g.color, C = g.opacity;
                  return v.length ? u.map(function(R) {
                    return ln(ln({}, R), {}, {
                      color: cr(b, C)
                    });
                  }) : [];
                }
              }, {
                key: "onMousemoveGroupedType",
                value: function(u) {
                  var h = this.getBulletSeriesModelsFromRectResponders(u);
                  this.eventBus.emit("renderHoveredSeries", {
                    models: [].concat(Ia(this.getGroupedRect(u, "hover")), Ia(this.getRespondersWithTheme(h, "hover"))),
                    name: this.name,
                    eventDetectType: this.eventDetectType
                  }), this.activatedResponders = h;
                }
              }, {
                key: "onMousemove",
                value: function(u) {
                  var h = u.responders;
                  this.eventDetectType === "grouped" ? this.onMousemoveGroupedType(h) : (this.eventBus.emit("renderHoveredSeries", {
                    models: this.getRespondersWithTheme(h, "hover"),
                    name: this.name
                  }), this.activatedResponders = h.length ? [h[h.length - 1]] : []), this.eventBus.emit("seriesPointHovered", {
                    models: this.activatedResponders,
                    name: this.name
                  }), this.eventBus.emit("needDraw");
                }
              }, {
                key: "onClick",
                value: function(u) {
                  var h = u.responders;
                  if (this.selectable) {
                    var v = this.eventDetectType === "grouped" ? [].concat(Ia(this.getGroupedRect(h, "select")), Ia(this.getRespondersWithTheme(this.getBulletSeriesModelsFromRectResponders(h), "select"))) : this.getRespondersWithTheme(h, "select");
                    this.eventBus.emit("renderSelectedSeries", {
                      models: v,
                      name: this.name,
                      eventDetectType: this.eventDetectType
                    }), this.eventBus.emit("needDraw");
                  }
                }
              }, {
                key: "filterBulletResponder",
                value: function(u) {
                  return u.filter(function(h) {
                    return (h == null ? void 0 : h.modelType) === "bullet";
                  });
                }
              }, {
                key: "renderRanges",
                value: function(u, h) {
                  var v = this, g = h.tickDistance, b = h.ratio, C = h.zeroPosition, R = h.rangeWidth, I = [];
                  return u.forEach(function(W, Z) {
                    var ue = W.ranges, ke = W.color, Ee = W.name;
                    (ue ?? []).forEach(function(Le, je) {
                      if (!Oe(Le)) {
                        var Ke = GN(Le, 2), ut = Ke[0], bt = Ke[1], mt = (bt - ut) * b, Rt = Jm(Z, g, R);
                        I.push(ln(ln({
                          type: "rect",
                          name: Ee,
                          color: v.getRangeColor(cr(ke, v.getSeriesOpacity(Ee)), je, Ee),
                          x: v.vertical ? Rt : ut * b + C,
                          y: v.vertical ? C - bt * b : Rt
                        }, MS(v.vertical, R, mt)), {}, {
                          modelType: "range",
                          seriesColor: ke,
                          tooltipColor: v.getRangeColor(ke, je, Ee, !0),
                          value: Le
                        }));
                      }
                    });
                  }), I;
                }
              }, {
                key: "renderBullet",
                value: function(u, h) {
                  var v = this, g = h.tickDistance, b = h.ratio, C = h.zeroPosition, R = h.bulletWidth, I = this.theme, W = I.borderColor, Z = I.borderWidth;
                  return u.reduce(function(ue, ke, Ee) {
                    var Le = ke.data, je = ke.color, Ke = ke.name;
                    if (Oe(Le))
                      return Ia(ue);
                    var ut = Math.max(Math.abs(Le * b), 2), bt = Jm(Ee, g, R), mt = v.vertical ? bt : C - (Le < 0 ? ut : 0), Rt = v.vertical ? C - ut + (Le < 0 ? ut : 0) : bt, Dt = ln({
                      type: "rect",
                      name: Ke,
                      color: cr(je, v.getSeriesOpacity(Ke)),
                      x: mt,
                      y: Rt,
                      thickness: Z,
                      borderColor: W,
                      modelType: "bullet",
                      seriesColor: je,
                      tooltipColor: je,
                      value: Le
                    }, MS(v.vertical, R, ut));
                    return [].concat(Ia(ue), [Dt]);
                  }, []);
                }
              }, {
                key: "renderMarkers",
                value: function(u, h) {
                  var v = this, g = h.tickDistance, b = h.ratio, C = h.zeroPosition, R = h.markerWidth, I = this.theme.markerLineWidth, W = [];
                  return u.forEach(function(Z, ue) {
                    var ke = Z.markers, Ee = Z.color, Le = Z.name, je = Jm(ue, g, R);
                    (ke ?? []).forEach(function(Ke) {
                      if (!Oe(Ke)) {
                        var ut = Ke * b, bt = v.vertical ? je : ut + C, mt = v.vertical ? C - ut : je;
                        W.push({
                          type: "line",
                          name: Le,
                          x: bt,
                          y: mt,
                          x2: v.vertical ? bt + R : bt,
                          y2: v.vertical ? mt : mt + R,
                          strokeStyle: cr(Ee, v.getSeriesOpacity(Le)),
                          lineWidth: I,
                          seriesColor: Ee,
                          tooltipColor: Ee,
                          value: Ke
                        });
                      }
                    });
                  }), W;
                }
              }, {
                key: "makeTooltipModel",
                value: function(u) {
                  var h = u.range, v = u.bullet, g = u.marker;
                  return {
                    range: this.makeTooltipData(h, "Range"),
                    bullet: this.makeTooltipData(v, "Actual"),
                    marker: this.makeTooltipData(g, "Marker")
                  };
                }
              }, {
                key: "makeTooltipData",
                value: function(u, h) {
                  return u.map(function(v) {
                    var g = v.name, b = v.seriesColor, C = v.tooltipColor, R = v.value;
                    return {
                      label: g,
                      color: cr(b, 1),
                      value: [{
                        title: h,
                        value: R,
                        color: C
                      }],
                      templateType: "bullet"
                    };
                  });
                }
              }, {
                key: "getBulletBarWidths",
                value: function(u) {
                  var h = this.theme, v = h.barWidth, g = h.barWidthRatios, b = g.rangeRatio, C = g.bulletRatio, R = g.markerRatio, I = v ? be(u, v) : u * oB;
                  return {
                    rangeWidth: I * b,
                    bulletWidth: I * C,
                    markerWidth: I * R
                  };
                }
              }, {
                key: "getRangeColor",
                value: function(u, h, v) {
                  var g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, b = this.theme.rangeColors, C = Array.isArray(b) && b[h], R = C ? b[h] : u, I = C ? An(b[h]) : RC[h];
                  return cr(R, I * this.getSeriesOpacity(v, g));
                }
              }, {
                key: "getSeriesOpacity",
                value: function(u) {
                  var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, v = this.theme, g = v.select, b = v.areaOpacity, C = this.activeSeriesMap[u], R = Object.values(this.activeSeriesMap).some(function(Z) {
                    return !Z;
                  }), I = h ? b : g.restSeries.areaOpacity, W = C ? g.areaOpacity : I;
                  return R ? W : b;
                }
              }, {
                key: "getRespondersWithTheme",
                value: function(u, h) {
                  var v = this, g = this.theme[h], b = g.color, C = g.borderColor, R = g.borderWidth;
                  return this.filterBulletResponder(u).map(function(I) {
                    return ln(ln({}, I), {}, {
                      color: b ?? I.tooltipColor,
                      thickness: R,
                      borderColor: C,
                      style: [ln({}, Ue(v.theme[h], "shadowBlur", "shadowColor", "shadowOffsetX", "shadowOffsetY"))]
                    });
                  });
                }
              }]), a;
            }(Lr);
            function sh(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? sh = function(a) {
                return typeof a;
              } : sh = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, sh(t);
            }
            function RS(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function DS(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? RS(Object(a), !0).forEach(function(o) {
                  LS(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : RS(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function cB(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function fB(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function dB(t, n, a) {
              return n && fB(t.prototype, n), t;
            }
            function lh(t, n, a) {
              return typeof Reflect < "u" && Reflect.get ? lh = Reflect.get : lh = function(u, h, v) {
                var g = hB(u, h);
                if (g) {
                  var b = Object.getOwnPropertyDescriptor(g, h);
                  return b.get ? b.get.call(v) : b.value;
                }
              }, lh(t, n, a || t);
            }
            function hB(t, n) {
              for (; !Object.prototype.hasOwnProperty.call(t, n) && (t = su(t), t !== null); )
                ;
              return t;
            }
            function pB(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Zm(t, n);
            }
            function Zm(t, n) {
              return Zm = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Zm(t, n);
            }
            function vB(t) {
              var n = gB();
              return function() {
                var o = su(t), u;
                if (n) {
                  var h = su(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return mB(this, u);
              };
            }
            function mB(t, n) {
              return n && (sh(n) === "object" || typeof n == "function") ? n : PS(t);
            }
            function PS(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function gB() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function su(t) {
              return su = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, su(t);
            }
            function LS(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var yB = /* @__PURE__ */ function(t) {
              pB(a, t);
              var n = vB(a);
              function a(o) {
                var u, h = o.el, v = o.options, g = o.data.series;
                return cB(this, a), u = n.call(this, {
                  el: h,
                  options: v,
                  series: {
                    bullet: g
                  },
                  modules: [Vi, Gi, Xa, Za]
                }), LS(PS(u), "hideTooltip", function() {
                  u.eventBus.emit("hideTooltip");
                }), u;
              }
              return dB(a, [{
                key: "initialize",
                value: function() {
                  lh(su(a.prototype), "initialize", this).call(this), this.componentManager.add(Yn), this.componentManager.add(Un), this.componentManager.add(Qa), this.componentManager.add(Oi), this.componentManager.add(uB), this.componentManager.add(Vr, {
                    name: "yAxis"
                  }), this.componentManager.add(Vr, {
                    name: "xAxis"
                  }), this.componentManager.add(Yr, {
                    name: "xAxis"
                  }), this.componentManager.add(Yr, {
                    name: "yAxis"
                  }), this.componentManager.add(Hn, {
                    chartEl: this.el
                  }), this.componentManager.add(Vn), this.componentManager.add(Gn), this.componentManager.add(Yi), this.componentManager.add($n, {
                    chartEl: this.el
                  }), this.componentManager.add(qn), this.painter.addGroups([p, d, w, f, O, m]);
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added
                 *   @param {string} data.name - Series name
                 *   @param {Array<<Array<number>>} data.data - Array of data to be added
                 *   @param {Array<number>} data.markers - Series markers. It specifies the marker for comparing.
                 *   @param {Array<Array<number>>} data.ranges - Series ranges. It specifies the range of values that can be compared.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: 20,
                 *   markers: [28, 2, 15],
                 *   ranges: [
                 *     [-1, 10],
                 *     [10, 20],
                 *     [20, 30],
                 *   ],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function(u) {
                  this.resetSeries(), this.store.dispatch("addSeries", {
                    data: u
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set
                 * @api
                 * @example
                 * chart.setData({
                 *   series: [
                 *     {
                 *       name: 'newSeries',
                 *       data: 20,
                 *       markers: [28, 2, 15],
                 *       ranges: [
                 *         [-1, 10],
                 *         [10, 20],
                 *         [20, 30],
                 *       ],
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function(u) {
                  this.resetSeries(), this.store.dispatch("setData", {
                    series: {
                      bullet: u.series
                    }
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !1
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !0
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("initOptions", u);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("updateOptions", u);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.seriesIndex - Index of series.
                 * @api
                 * @example
                 * chart.showTooltip({seriesIndex: 1});
                 */
              }, {
                key: "showTooltip",
                value: function(u) {
                  this.eventBus.emit("showTooltip", DS(DS({}, u), {}, {
                    state: this.store.state
                  }));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }]), a;
            }(Wn);
            function IS(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function _S(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? IS(Object(a), !0).forEach(function(o) {
                  bB(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : IS(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function bB(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function NS(t, n, a) {
              var o, u = (o = t.pie) === null || o === void 0 ? void 0 : o[n].data.find(function(h) {
                var v = h.name;
                return v === a;
              });
              return u != null && u.parentName ? NS(t, n - 1, u.parentName) : a;
            }
            var SB = {
              name: "seriesData",
              state: function() {
                return {
                  nestedPieSeries: {}
                };
              },
              action: {
                setNestedPieSeriesData: function(n) {
                  var a = n.state, o = n.initStoreState, u = a.theme, h = a.disabledSeries, v = o.series, g = {}, b = {};
                  v.pie.forEach(function(C, R) {
                    var I = C.name, W = C.data, Z = u.series.pie[I].colors, ue = [], ke = W.map(function(Ee, Le) {
                      var je = Ee.parentName, Ke = Ee.name, ut = je && R ? b[je] : Z == null ? void 0 : Z[Le];
                      ue.push(ut), b[Ke] = ut;
                      var bt = je && R ? NS(v, R - 1, je) : Ke;
                      return _S(_S({}, Ee), {}, {
                        data: Ee.data,
                        rootParentName: bt,
                        color: ut
                      });
                    });
                    g[I] = {
                      data: ke.filter(function(Ee) {
                        var Le = Ee.rootParentName;
                        return !h.includes(Le);
                      }),
                      colors: ue
                    };
                  }), a.nestedPieSeries = g, this.dispatch("updateNestedPieChartLegend");
                }
              },
              observe: {
                updateNestedPieSeriesData: function() {
                  this.dispatch("setNestedPieSeriesData");
                }
              }
            }, wB = SB;
            function uh(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? uh = function(a) {
                return typeof a;
              } : uh = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, uh(t);
            }
            function BS(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function FS(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? BS(Object(a), !0).forEach(function(o) {
                  xB(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : BS(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function xB(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function kB(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function OB(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function CB(t, n, a) {
              return n && OB(t.prototype, n), t;
            }
            function ch(t, n, a) {
              return typeof Reflect < "u" && Reflect.get ? ch = Reflect.get : ch = function(u, h, v) {
                var g = TB(u, h);
                if (g) {
                  var b = Object.getOwnPropertyDescriptor(g, h);
                  return b.get ? b.get.call(v) : b.value;
                }
              }, ch(t, n, a || t);
            }
            function TB(t, n) {
              for (; !Object.prototype.hasOwnProperty.call(t, n) && (t = lu(t), t !== null); )
                ;
              return t;
            }
            function AB(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Qm(t, n);
            }
            function Qm(t, n) {
              return Qm = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Qm(t, n);
            }
            function EB(t) {
              var n = DB();
              return function() {
                var o = lu(t), u;
                if (n) {
                  var h = lu(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return MB(this, u);
              };
            }
            function MB(t, n) {
              return n && (uh(n) === "object" || typeof n == "function") ? n : RB(t);
            }
            function RB(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function DB() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function lu(t) {
              return lu = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, lu(t);
            }
            var PB = /* @__PURE__ */ function(t) {
              AB(a, t);
              var n = EB(a);
              function a(o) {
                var u = o.el, h = o.options, v = o.data, g = v.series, b = v.categories;
                return kB(this, a), n.call(this, {
                  el: u,
                  options: h,
                  series: {
                    pie: g
                  },
                  categories: b,
                  modules: [wB]
                });
              }
              return CB(a, [{
                key: "initialize",
                value: function() {
                  var u, h = this;
                  ch(lu(a.prototype), "initialize", this).call(this), this.componentManager.add(Yn), this.componentManager.add(Un), this.componentManager.add(Oi), ((u = this.store.initStoreState.series.pie) !== null && u !== void 0 ? u : []).forEach(function(v) {
                    var g = v.name;
                    h.componentManager.add(gc, {
                      alias: g
                    });
                  }), this.componentManager.add(Hn, {
                    chartEl: this.el
                  }), this.componentManager.add(Vn), this.componentManager.add(Gn), this.componentManager.add(Yi), this.componentManager.add($n, {
                    chartEl: this.el
                  }), this.componentManager.add(qn), this.painter.addGroups([p, w, f, O, L, m]);
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<Object>} data.data - Array of data to be added.
                 * @param {Object} dataInfo - Which name of chart to add.
                 *   @param {string} dataInfo.name - Chart series name.
                 * @api
                 * @example
                 * chart.addSeries(
                 *   {
                 *     name: 'newSeries',
                 *     data: [
                 *       { name: 'A', data: 10 },
                 *       { name: 'B', data: 20 },
                 *     ],
                 *   },
                 *   {
                 *     name: 'series name'
                 *   });
                 */
              }, {
                key: "addSeries",
                value: function(u, h) {
                  this.resetSeries(), this.store.dispatch("addSeries", FS({
                    data: u
                  }, h)), this.componentManager.add(gc, {
                    alias: u.name
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['A', 'B'],
                 *   series: [
                 *     {
                 *       name: 'browsers',
                 *       data: [
                 *         {
                 *           name: 'Chrome',
                 *           data: 50,
                 *         },
                 *         {
                 *           name: 'Safari',
                 *           data: 20,
                 *         },
                 *       ]
                 *     },
                 *     {
                 *       name: 'versions',
                 *       data: [
                 *         {
                 *           name: '1',
                 *           data: 50,
                 *         },
                 *         {
                 *           name: '2',
                 *           data: 20,
                 *         },
                 *       ]
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function(u) {
                  var h, v = this;
                  this.componentManager.remove(gc), this.resetSeries(), this.store.dispatch("setData", {
                    series: {
                      pie: u.series
                    }
                  }), ((h = this.store.initStoreState.series.pie) !== null && h !== void 0 ? h : []).forEach(function(g) {
                    var b = g.name;
                    v.componentManager.add(gc, {
                      alias: b
                    });
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !1
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !0
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   series: {
                 *     alias2: {
                 *       radiusRange: [20%, 50%],
                 *     },
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("initOptions", u);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   series: {
                 *     alias1: {
                 *       showDot: true,
                 *     },
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("updateOptions", u);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.seriesIndex - Index of series.
                 *      @param {number} seriesInfo.alias - alias name.
                 * @api
                 * @example
                 * chart.showTooltip({seriesIndex: 1, alias: 'name'});
                 */
              }, {
                key: "showTooltip",
                value: function(u) {
                  this.eventBus.emit("showTooltip", FS({}, u));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function() {
                  this.eventBus.emit("hideTooltip");
                }
              }]), a;
            }(Wn);
            function fh(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? fh = function(a) {
                return typeof a;
              } : fh = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, fh(t);
            }
            function uu(t) {
              return NB(t) || _B(t) || IB(t) || LB();
            }
            function LB() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function IB(t, n) {
              if (t) {
                if (typeof t == "string") return eg(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return eg(t, n);
              }
            }
            function _B(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function NB(t) {
              if (Array.isArray(t)) return eg(t);
            }
            function eg(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function zS(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function _a(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? zS(Object(a), !0).forEach(function(o) {
                  ns(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : zS(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function BB(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function FB(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function zB(t, n, a) {
              return n && FB(t.prototype, n), t;
            }
            function HB(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && tg(t, n);
            }
            function tg(t, n) {
              return tg = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, tg(t, n);
            }
            function jB(t) {
              var n = $B();
              return function() {
                var o = dh(t), u;
                if (n) {
                  var h = dh(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return WB(this, u);
              };
            }
            function WB(t, n) {
              return n && (fh(n) === "object" || typeof n == "function") ? n : rs(t);
            }
            function rs(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function $B() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function dh(t) {
              return dh = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, dh(t);
            }
            function ns(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var UB = 0, HS = {
              INACTIVE: 0.2,
              ACTIVE: 1
            }, VB = /* @__PURE__ */ function(t) {
              HB(a, t);
              var n = jB(a);
              function a() {
                var o;
                BB(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), ns(rs(o), "models", {
                  area: [],
                  line: [],
                  dot: []
                }), ns(rs(o), "drawModels", void 0), ns(rs(o), "responders", void 0), ns(rs(o), "activatedResponders", []), ns(rs(o), "theme", void 0), ns(rs(o), "onMouseoutComponent", function() {
                  o.eventBus.emit("seriesPointHovered", {
                    models: [],
                    name: o.name
                  }), o.eventBus.emit("renderHoveredSeries", {
                    models: [],
                    name: o.name
                  }), o.eventBus.emit("needDraw");
                }), ns(rs(o), "selectSeries", function(g) {
                  var b = g.index, C = g.seriesIndex, R = g.state;
                  if (!(!Me(b) || !Me(C))) {
                    var I = R.series.radar.data[C].name, W = o.responders.filter(function(Z) {
                      var ue = Z.name;
                      return ue === I;
                    })[b];
                    if (!W)
                      throw new Error(ve.SELECT_SERIES_API_INDEX_ERROR);
                    o.eventBus.emit("renderSelectedSeries", {
                      models: o.getRespondersWithTheme([W], "select"),
                      name: o.name
                    }), o.eventBus.emit("needDraw");
                  }
                }), ns(rs(o), "showTooltip", function(g) {
                  var b = g.index, C = g.seriesIndex, R = g.state;
                  if (!(!Me(b) || !Me(C))) {
                    var I = R.series.radar.data[C].name, W = [o.responders.filter(function(Z) {
                      var ue = Z.name;
                      return ue === I;
                    })[b]];
                    W.length && (o.eventBus.emit("renderHoveredSeries", {
                      models: o.getRespondersWithTheme(W, "hover"),
                      name: o.name
                    }), o.activatedResponders = W, o.eventBus.emit("seriesPointHovered", {
                      models: o.activatedResponders,
                      name: o.name
                    }), o.eventBus.emit("needDraw"));
                  }
                }), o;
              }
              return zB(a, [{
                key: "initialize",
                value: function() {
                  this.type = "series", this.name = "radar", this.eventBus.on("selectSeries", this.selectSeries), this.eventBus.on("showTooltip", this.showTooltip), this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "render",
                value: function(u) {
                  var h, v, g, b, C, R = u.layout, I = u.radialAxes, W = u.series, Z = u.legend, ue = u.options, ke = u.theme, Ee = u.scale;
                  if (!W.radar)
                    throw new Error(ve.noDataError(this.name));
                  this.theme = ke.series.radar, this.rect = R.plot, this.activeSeriesMap = Ea(Z), this.selectable = this.getSelectableOption(ue);
                  var Le = u.categories, je = I.verticalAxis, Ke = je.axisSize, ut = je.centerX, bt = je.centerY, mt = Ee.verticalAxis, Rt = mt.limit, Dt = mt.stepSize, Lt = yo(Rt, Dt), Wt = Vp(Lt), Qt = Wt.min, or = Wt.max, lr = {
                    categories: Le,
                    degree: Dr / Le.length,
                    centerX: ut,
                    centerY: bt,
                    showArea: (h = ue == null || (v = ue.series) === null || v === void 0 ? void 0 : v.showArea) !== null && h !== void 0 ? h : !1,
                    ratio: Ke / (or - Qt)
                  }, xr = (g = W.radar) === null || g === void 0 ? void 0 : g.data, br = this.makeRadarPointsData(xr, lr), yr = this.renderDotModels(br);
                  this.models.area = ue != null && (b = ue.series) !== null && b !== void 0 && b.showArea ? this.renderAreaModels(br) : [], this.models.line = this.renderLineModels(br), this.models.dot = ue != null && (C = ue.series) !== null && C !== void 0 && C.showDot ? yr : [], this.drawModels || (this.drawModels = {
                    area: this.initDrawModels("area", ut, bt),
                    line: this.initDrawModels("line", ut, bt),
                    dot: this.models.dot.map(function(qr) {
                      return _a(_a({}, qr), {}, {
                        x: ut,
                        y: bt
                      });
                    })
                  });
                  var Ar = this.makeTooltipModel(yr, Le);
                  this.responders = yr.map(function(qr, nn) {
                    return _a(_a({}, qr), {}, {
                      data: Ar[nn],
                      color: cr(qr.color, 1)
                    });
                  });
                }
              }, {
                key: "initDrawModels",
                value: function(u, h, v) {
                  return this.models[u].map(function(g) {
                    var b;
                    return _a(_a({}, g), {}, {
                      distances: (b = g.distances) === null || b === void 0 ? void 0 : b.map(function() {
                        return 0;
                      }),
                      points: g.points.map(function() {
                        return {
                          x: h,
                          y: v
                        };
                      })
                    });
                  });
                }
              }, {
                key: "makeTooltipModel",
                value: function(u, h) {
                  return u.map(function(v) {
                    var g = v.name, b = v.color, C = v.value, R = v.index;
                    return {
                      label: g,
                      color: b,
                      value: C,
                      category: h[R]
                    };
                  });
                }
              }, {
                key: "getRespondersWithTheme",
                value: function(u, h) {
                  var v = this.theme[h].dot, g = v.radius, b = v.borderWidth, C = v.borderColor, R = v.color;
                  return u.map(function(I) {
                    var W = R ?? I.color;
                    return _a(_a({}, I), {}, {
                      radius: g,
                      color: W,
                      borderColor: C ?? cr(W, 0.5),
                      borderWidth: b
                    });
                  });
                }
              }, {
                key: "onClick",
                value: function(u) {
                  var h = u.responders;
                  this.selectable && (this.eventBus.emit("renderSelectedSeries", {
                    models: this.getRespondersWithTheme(h, "select"),
                    name: this.name
                  }), this.eventBus.emit("needDraw"));
                }
              }, {
                key: "onMousemove",
                value: function(u) {
                  var h = u.responders;
                  this.eventBus.emit("renderHoveredSeries", {
                    models: this.getRespondersWithTheme(h, "hover"),
                    name: this.name
                  }), this.activatedResponders = h, this.eventBus.emit("seriesPointHovered", {
                    models: this.activatedResponders,
                    name: this.name
                  }), this.eventBus.emit("needDraw");
                }
              }, {
                key: "makeRadarPointsData",
                value: function(u, h) {
                  var v = this, g = h.centerX, b = h.centerY, C = h.degree, R = h.ratio, I = h.showArea;
                  return u.map(function(W) {
                    var Z = W.data, ue = W.color, ke = W.name, Ee = Z.reduce(function(Le, je, Ke) {
                      if (Oe(je))
                        return {
                          distances: [].concat(uu(Le.distances), [0]),
                          linePoints: [].concat(uu(Le.linePoints), [null]),
                          areaPoints: [].concat(uu(Le.areaPoints), [{
                            x: g,
                            y: b
                          }])
                        };
                      var ut = je * R, bt = hn(g, b, ut, Pr(C * Ke));
                      return {
                        distances: [].concat(uu(Le.distances), [ut]),
                        linePoints: [].concat(uu(Le.linePoints), [bt]),
                        areaPoints: [].concat(uu(Le.areaPoints), [bt])
                      };
                    }, {
                      linePoints: [],
                      distances: [],
                      areaPoints: []
                    });
                    return !Oe(Z[0]) && !Oe(Z[Z.length - 1]) && (Ee.linePoints.push(Ee.linePoints[0]), Ee.areaPoints.push(Ee.areaPoints[0])), _a(_a({
                      name: ke,
                      seriesColor: ue,
                      data: Z
                    }, Ee), v.getSeriesColor(I, ue, ke));
                  });
                }
              }, {
                key: "renderAreaModels",
                value: function(u) {
                  return u.map(function(h) {
                    var v = h.distances, g = h.areaPoints, b = h.name, C = h.fillColor, R = h.seriesColor;
                    return {
                      type: "areaPoints",
                      name: b,
                      distances: v,
                      points: g,
                      fillColor: C,
                      color: cr(R, 0),
                      lineWidth: 0
                    };
                  });
                }
              }, {
                key: "renderLineModels",
                value: function(u) {
                  var h = this.theme, v = h.lineWidth, g = h.dashSegments;
                  return u.map(function(b) {
                    var C = b.distances, R = b.linePoints, I = b.name, W = b.lineColor;
                    return {
                      type: "linePoints",
                      lineWidth: v ?? Xo.LINE_WIDTH,
                      name: I,
                      distances: C,
                      points: R,
                      color: W,
                      dashSegments: g
                    };
                  });
                }
              }, {
                key: "renderDotModels",
                value: function(u) {
                  var h = this.theme.dot, v = h.radius, g = h.color, b = [];
                  return u.forEach(function(C, R) {
                    var I = C.linePoints, W = C.lineColor, Z = C.name, ue = C.data;
                    return I.slice(0, I.length - 1).forEach(function(ke, Ee) {
                      Oe(ke) || b.push(_a(_a({
                        type: "circle"
                      }, ke), {}, {
                        radius: v,
                        color: g ?? W,
                        style: [{
                          strokeStyle: "rgba(0, 0, 0, 0)"
                        }],
                        name: Z,
                        seriesIndex: R,
                        index: Ee,
                        value: ue == null ? void 0 : ue[Ee]
                      }));
                    });
                  }), b;
                }
              }, {
                key: "getSeriesColor",
                value: function(u, h, v) {
                  var g = this.activeSeriesMap[v], b = this.theme, C = b.select, R = b.areaOpacity, I = Object.values(this.activeSeriesMap).some(function(ke) {
                    return !ke;
                  }), W = cr(h, g ? HS.ACTIVE : HS.INACTIVE), Z = UB;
                  if (u) {
                    var ue = g ? C.areaOpacity : C.restSeries.areaOpacity;
                    Z = I ? ue : R;
                  }
                  return {
                    lineColor: W,
                    fillColor: cr(W, Z)
                  };
                }
              }]), a;
            }(Lr);
            function hh(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? hh = function(a) {
                return typeof a;
              } : hh = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, hh(t);
            }
            function GB(t) {
              return XB(t) || KB(t) || qB(t) || YB();
            }
            function YB() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function qB(t, n) {
              if (t) {
                if (typeof t == "string") return rg(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return rg(t, n);
              }
            }
            function KB(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function XB(t) {
              if (Array.isArray(t)) return rg(t);
            }
            function rg(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function JB(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function ZB(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function QB(t, n, a) {
              return n && ZB(t.prototype, n), t;
            }
            function e2(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && ng(t, n);
            }
            function ng(t, n) {
              return ng = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, ng(t, n);
            }
            function t2(t) {
              var n = n2();
              return function() {
                var o = ph(t), u;
                if (n) {
                  var h = ph(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return r2(this, u);
              };
            }
            function r2(t, n) {
              return n && (hh(n) === "object" || typeof n == "function") ? n : ig(t);
            }
            function ig(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function n2() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function ph(t) {
              return ph = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, ph(t);
            }
            function jS(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function WS(t, n) {
              var a = t.limit.max, o = t.stepSize;
              return a + (n < Dr ? gn : o);
            }
            function $S(t, n) {
              return t.findIndex(function(a) {
                return a === n;
              });
            }
            var ag = /* @__PURE__ */ function(t) {
              e2(a, t);
              var n = t2(a);
              function a() {
                var o;
                JB(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), jS(ig(o), "models", {
                  plot: [],
                  line: [],
                  band: []
                }), jS(ig(o), "circularAxisTheme", void 0), o;
              }
              return QB(a, [{
                key: "initialize",
                value: function(u) {
                  var h;
                  this.type = "plot", this.name = (h = u == null ? void 0 : u.name) !== null && h !== void 0 ? h : "radialPlot";
                }
              }, {
                key: "render",
                value: function(u) {
                  var h, v = u.layout, g = u.radialAxes, b = u.options, C = u.series, R = u.theme, I = u.scale;
                  this.rect = v.plot, this.circularAxisTheme = R.circularAxis;
                  var W = (h = u.categories) !== null && h !== void 0 ? h : [];
                  if (this.name === "gauge") {
                    var Z, ue, ke = (Z = b == null || (ue = b.plot) === null || ue === void 0 ? void 0 : ue.bands) !== null && Z !== void 0 ? Z : [], Ee = !sa({
                      series: C,
                      categories: W
                    }), Le = this.makeRenderOptionsOnGauge(Ee, g.circularAxis, W, I);
                    this.models.band = this.renderBands(ke, Le, W);
                  } else {
                    var je, Ke, ut = !!C.radar, bt = (je = (Ke = b.plot) === null || Ke === void 0 ? void 0 : Ke.type) !== null && je !== void 0 ? je : ut ? "spiderweb" : "circle", mt = this.makeRenderOptions(g, bt, W);
                    this.models.plot = this.renderPlot(mt), this.models.line = C.radialBar ? this.renderLine(mt) : [];
                  }
                }
              }, {
                key: "makeRenderOptionsOnGauge",
                value: function(u, h, v, g) {
                  var b = h.angle, C = b.total, R = b.start, I = h.radius.outer, W = h.clockwise, Z = h.centerX, ue = h.centerY, ke = h.band, Ee = ke.width, Le = ke.margin;
                  return {
                    centerX: Z,
                    centerY: ue,
                    clockwise: W,
                    totalAngle: C,
                    scaleMaxLimitValue: u ? v.length : WS(g.circularAxis, C),
                    startAngle: R,
                    outerRadius: I,
                    bandWidth: Ee,
                    bandMargin: Le,
                    hasCategoryAxis: u
                  };
                }
              }, {
                key: "makeRenderOptions",
                value: function(u, h) {
                  var v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], g = u.verticalAxis, b = g.centerX, C = g.centerY, R = g.radius, I = R.ranges, W = R.inner, Z = R.outer, ue = u.circularAxis, ke = ue.angle, Ee = ke.central, Le = ke.total, je = ke.start, Ke = ke.end, ut = ke.drawingStart, bt = ue.label.labels, mt = ue.tickInterval, Rt = ue.clockwise, Dt = Le !== Dr, Lt = bt.length;
                  return {
                    type: h,
                    categories: v,
                    centralAngle: Ee,
                    centerX: b,
                    centerY: C,
                    initialRadius: W,
                    radius: Z,
                    radiusRanges: I,
                    lineCount: Lt,
                    tickInterval: mt,
                    drawingStartAngle: ut,
                    usingArcPlot: Dt,
                    startAngle: je,
                    endAngle: Ke,
                    clockwise: Rt
                  };
                }
              }, {
                key: "renderPlot",
                value: function(u) {
                  var h = u.type, v = u.usingArcPlot;
                  return v ? this.makeArc(u) : h === "spiderweb" ? this.makeSpiderwebPlot(u) : this.makeCirclePlot(u);
                }
              }, {
                key: "makeSpiderwebPlot",
                value: function(u) {
                  var h = u.centralAngle, v = u.centerX, g = u.centerY, b = u.categories, C = u.radiusRanges, R = this.circularAxisTheme, I = R.strokeStyle, W = R.lineWidth;
                  return C.map(function(Z) {
                    var ue = b.map(function(ke, Ee) {
                      return hn(v, g, Z, Pr(h * Ee));
                    });
                    return {
                      type: "polygon",
                      color: I,
                      lineWidth: W,
                      points: ue
                    };
                  });
                }
              }, {
                key: "makeCirclePlot",
                value: function(u) {
                  var h = u.centerX, v = u.centerY, g = u.radiusRanges, b = this.circularAxisTheme, C = b.strokeStyle, R = b.lineWidth;
                  return g.map(function(I) {
                    return {
                      type: "circle",
                      color: "rgba(0, 0, 0, 0)",
                      radius: I,
                      x: h,
                      y: v,
                      borderColor: C,
                      borderWidth: R
                    };
                  });
                }
              }, {
                key: "makeArc",
                value: function(u) {
                  var h = u.centerX, v = u.centerY, g = u.radiusRanges, b = u.startAngle, C = u.endAngle, R = u.clockwise, I = this.circularAxisTheme, W = I.strokeStyle, Z = I.lineWidth;
                  return g.map(function(ue) {
                    return {
                      type: "arc",
                      borderWidth: Z,
                      borderColor: W,
                      x: h,
                      y: v,
                      angle: {
                        start: b,
                        end: C
                      },
                      drawingStartAngle: ti,
                      radius: ue,
                      clockwise: R
                    };
                  });
                }
              }, {
                key: "renderLine",
                value: function(u) {
                  var h = u.centerX, v = u.centerY, g = u.initialRadius, b = u.radius, C = u.lineCount, R = u.centralAngle, I = u.tickInterval, W = u.drawingStartAngle, Z = u.clockwise, ue = this.circularAxisTheme, ke = ue.strokeStyle, Ee = ue.lineWidth;
                  return Mt(0, C).reduce(function(Le, je, Ke) {
                    var ut = W + R * Ke * (Z ? 1 : -1), bt = hn(h, v, g, Pr(ut)), mt = bt.x, Rt = bt.y, Dt = hn(h, v, b, Pr(ut)), Lt = Dt.x, Wt = Dt.y;
                    return Ke % I === 0 ? [].concat(GB(Le), [{
                      type: "line",
                      x: mt,
                      y: Rt,
                      x2: Lt,
                      y2: Wt,
                      strokeStyle: ke,
                      lineWidth: Ee
                    }]) : Le;
                  }, []);
                }
              }, {
                key: "renderBands",
                value: function(u, h, v) {
                  var g = [], b = h.centerX, C = h.centerY, R = h.clockwise, I = h.totalAngle, W = h.scaleMaxLimitValue, Z = h.startAngle, ue = h.outerRadius, ke = h.bandWidth, Ee = h.bandMargin, Le = h.hasCategoryAxis;
                  return u.forEach(function(je, Ke) {
                    var ut = je.range, bt = je.color, mt = Le ? $S(v, ut[1].toString()) - $S(v, ut[0].toString()) : Number(ut[1]) - Number(ut[0]), Rt = mt / W * I * (R ? 1 : -1), Dt = zn(Rt), Lt = g[g.length - 1], Wt = Ke && Lt ? Lt.degree.end : Z, Qt = zn(Wt + Dt);
                    g.push({
                      type: "sector",
                      color: bt,
                      x: b,
                      y: C,
                      clockwise: R,
                      degree: {
                        start: Wt,
                        end: Qt
                      },
                      radius: {
                        inner: ue + Ee,
                        outer: ue + ke
                      }
                    });
                  }), g;
                }
              }]), a;
            }(Lr);
            function vh(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? vh = function(a) {
                return typeof a;
              } : vh = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, vh(t);
            }
            function US(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function i2(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? US(Object(a), !0).forEach(function(o) {
                  bh(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : US(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function mh(t) {
              return l2(t) || s2(t) || o2(t) || a2();
            }
            function a2() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function o2(t, n) {
              if (t) {
                if (typeof t == "string") return og(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return og(t, n);
              }
            }
            function s2(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function l2(t) {
              if (Array.isArray(t)) return og(t);
            }
            function og(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function u2(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function c2(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function f2(t, n, a) {
              return n && c2(t.prototype, n), t;
            }
            function d2(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && sg(t, n);
            }
            function sg(t, n) {
              return sg = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, sg(t, n);
            }
            function h2(t) {
              var n = v2();
              return function() {
                var o = yh(t), u;
                if (n) {
                  var h = yh(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return p2(this, u);
              };
            }
            function p2(t, n) {
              return n && (vh(n) === "object" || typeof n == "function") ? n : gh(t);
            }
            function gh(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function v2() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function yh(t) {
              return yh = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, yh(t);
            }
            function bh(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var Sh = 4, VS = 5;
            function m2(t, n, a, o, u) {
              return !n && t === 0 ? !1 : !(t % a) && (n && o <= u || !n && o < u);
            }
            var lg = /* @__PURE__ */ function(t) {
              d2(a, t);
              var n = h2(a);
              function a() {
                var o;
                u2(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), bh(gh(o), "models", {
                  verticalAxisLabel: [],
                  circularAxisLabel: [],
                  dot: [],
                  line: [],
                  tick: []
                }), bh(gh(o), "verticalAxisTheme", void 0), bh(gh(o), "circularAxisTheme", void 0), o;
              }
              return f2(a, [{
                key: "initialize",
                value: function(u) {
                  var h;
                  this.type = "axis", this.name = (h = u == null ? void 0 : u.name) !== null && h !== void 0 ? h : "radial";
                }
              }, {
                key: "render",
                value: function(u) {
                  var h = u.layout, v = u.radialAxes, g = u.theme, b = u.series;
                  if (this.isShow = !pv(b), this.rect = h.plot, !!v) {
                    this.circularAxisTheme = g.circularAxis;
                    var C = v.circularAxis, R = v.verticalAxis;
                    R && (this.verticalAxisTheme = g.verticalAxis, this.models.verticalAxisLabel = this.renderVerticalAxisLabel(R)), this.models.circularAxisLabel = this.renderCircularAxisLabel(C), this.name === "gauge" ? (this.models.line = this.renderArcLine(C), this.models.tick = this.renderTick(C)) : this.models.dot = this.renderDotModel(C);
                  }
                }
              }, {
                key: "getBubbleShadowStyle",
                value: function() {
                  var u = this.verticalAxisTheme.label.textBubble, h = u.visible, v = u.shadowColor, g = u.shadowOffsetX, b = u.shadowOffsetY, C = u.shadowBlur;
                  return h && v ? [{
                    shadowColor: v,
                    shadowOffsetX: g,
                    shadowOffsetY: b,
                    shadowBlur: C
                  }] : null;
                }
              }, {
                key: "renderVerticalAxisLabel",
                value: function(u) {
                  var h = this, v = u.radius, g = v.ranges, b = v.outer, C = u.label, R = C.labels, I = C.interval, W = C.maxWidth, Z = C.maxHeight, ue = C.margin, ke = C.align, Ee = u.angle.start, Le = u.pointOnColumn, je = u.centerX, Ke = u.centerY, ut = u.tickDistance, bt = Le ? ut / 2 : 0, mt = an(this.verticalAxisTheme.label), Rt = this.verticalAxisTheme.label.textBubble, Dt = Rt.visible, Lt = Rt.backgroundColor, Wt = Rt.borderRadius, Qt = Rt.borderColor, or = Rt.borderWidth, lr = Rt.paddingX, xr = Rt.paddingY, br = Dt ? lr : 0, yr = Dt ? xr : 0, Ar = W + br * 2 - ue, qr = Z + yr * 2, nn = this.verticalAxisTheme.label.color;
                  return g.reduce(function(tn, bn, Tn) {
                    var un = hn(je, Ke, bn - bt, Pr(Ee)), Ln = un.x, so = un.y, Ro = m2(Tn, Le, I, bn, b), Ds = Ln + ue, gu = Ln + ue + br;
                    return ke === "center" ? (Ds = Ln - ue - Ar / 2, gu = Ln - ue) : Ve(["right", "end"], ke) && (Ds = Ln - ue - Ar, gu = Ln - ue - br), Ro ? [].concat(mh(tn), [{
                      type: "bubbleLabel",
                      rotationPosition: {
                        x: Ln,
                        y: so
                      },
                      radian: Pr(Ee, 0),
                      bubble: {
                        x: Ds,
                        y: so - qr / 2,
                        width: Ar,
                        height: qr,
                        align: ke,
                        radius: Wt,
                        fill: Lt,
                        lineWidth: or,
                        strokeStyle: Qt,
                        style: h.getBubbleShadowStyle()
                      },
                      label: {
                        text: R[Tn],
                        x: gu,
                        y: so,
                        style: [{
                          font: mt,
                          fillStyle: nn,
                          textAlign: ke,
                          textBaseline: "middle"
                        }]
                      }
                    }]) : tn;
                  }, []);
                }
              }, {
                key: "renderDotModel",
                value: function(u) {
                  var h = u.angle, v = h.central, g = h.drawingStart, b = u.label, C = b.labels, R = b.interval, I = u.radius.outer, W = u.centerX, Z = u.centerY, ue = u.clockwise, ke = this.circularAxisTheme.dotColor;
                  return C.reduce(function(Ee, Le, je) {
                    var Ke = g + v * je * (ue ? 1 : -1), ut = hn(W, Z, I, Pr(zn(Ke))), bt = ut.x, mt = ut.y;
                    return je % R === 0 ? [].concat(mh(Ee), [{
                      type: "rect",
                      color: ke,
                      width: Sh,
                      height: Sh,
                      x: bt - Sh / 2,
                      y: mt - Sh / 2
                    }]) : Ee;
                  }, []);
                }
              }, {
                key: "renderCircularAxisLabel",
                value: function(u) {
                  var h = u.centerX, v = u.centerY, g = u.clockwise, b = u.label, C = b.labels, R = b.interval, I = b.margin, W = b.maxHeight, Z = u.angle, ue = Z.drawingStart, ke = Z.central, Ee = u.radius.outer, Le = Ee + (I + W / 2) * (this.name === "gauge" ? -1 : 1), je = this.circularAxisTheme.label, Ke = an(je), ut = ke * (g ? 1 : -1);
                  return C.reduce(function(bt, mt, Rt) {
                    var Dt = ue + ut * Rt, Lt = zn(Dt);
                    return Rt % R === 0 ? [].concat(mh(bt), [i2({
                      type: "label",
                      style: [{
                        textAlign: "center",
                        textBaseline: "middle",
                        font: Ke,
                        fillStyle: je.color
                      }],
                      text: mt
                    }, hn(h, v, Le, Pr(Lt)))]) : bt;
                  }, []);
                }
              }, {
                key: "renderTick",
                value: function(u) {
                  var h = u.centerX, v = u.centerY, g = u.tickInterval, b = u.clockwise, C = u.angle, R = C.central, I = C.drawingStart, W = u.label.labels, Z = u.radius.outer, ue = this.circularAxisTheme.tick, ke = ue.strokeStyle, Ee = ue.lineWidth;
                  return W.reduce(function(Le, je, Ke) {
                    var ut = I + R * Ke * (b ? 1 : -1), bt = hn(h, v, Z - VS, Pr(zn(ut))), mt = bt.x, Rt = bt.y, Dt = hn(h, v, Z + VS, Pr(zn(ut))), Lt = Dt.x, Wt = Dt.y;
                    return Ke % g === 0 ? [].concat(mh(Le), [{
                      type: "line",
                      lineWidth: Ee,
                      strokeStyle: ke,
                      x: mt,
                      y: Rt,
                      x2: Lt,
                      y2: Wt
                    }]) : Le;
                  }, []);
                }
              }, {
                key: "renderArcLine",
                value: function(u) {
                  var h = u.centerX, v = u.centerY, g = u.clockwise, b = u.angle, C = b.start, R = b.end, I = b.total, W = u.radius.outer, Z = this.circularAxisTheme, ue = Z.strokeStyle, ke = Z.lineWidth;
                  return I === Dr ? [{
                    type: "circle",
                    x: h,
                    y: v,
                    radius: W,
                    borderWidth: ke,
                    borderColor: ue,
                    color: "rgba(0, 0, 0, 0)"
                  }] : [{
                    type: "arc",
                    borderWidth: ke,
                    borderColor: ue,
                    x: h,
                    y: v,
                    angle: {
                      start: C,
                      end: R
                    },
                    drawingStartAngle: ti,
                    radius: W,
                    clockwise: g
                  }];
                }
              }]), a;
            }(Lr);
            function wh(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? wh = function(a) {
                return typeof a;
              } : wh = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, wh(t);
            }
            function GS(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function YS(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? GS(Object(a), !0).forEach(function(o) {
                  g2(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : GS(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function g2(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function y2(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function b2(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function S2(t, n, a) {
              return n && b2(t.prototype, n), t;
            }
            function xh(t, n, a) {
              return typeof Reflect < "u" && Reflect.get ? xh = Reflect.get : xh = function(u, h, v) {
                var g = w2(u, h);
                if (g) {
                  var b = Object.getOwnPropertyDescriptor(g, h);
                  return b.get ? b.get.call(v) : b.value;
                }
              }, xh(t, n, a || t);
            }
            function w2(t, n) {
              for (; !Object.prototype.hasOwnProperty.call(t, n) && (t = cu(t), t !== null); )
                ;
              return t;
            }
            function x2(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && ug(t, n);
            }
            function ug(t, n) {
              return ug = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, ug(t, n);
            }
            function k2(t) {
              var n = T2();
              return function() {
                var o = cu(t), u;
                if (n) {
                  var h = cu(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return O2(this, u);
              };
            }
            function O2(t, n) {
              return n && (wh(n) === "object" || typeof n == "function") ? n : C2(t);
            }
            function C2(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function T2() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function cu(t) {
              return cu = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, cu(t);
            }
            var A2 = /* @__PURE__ */ function(t) {
              x2(a, t);
              var n = k2(a);
              function a(o) {
                var u = o.el, h = o.options, v = o.data;
                return y2(this, a), n.call(this, {
                  el: u,
                  options: h,
                  series: {
                    radar: v.series
                  },
                  categories: v.categories,
                  modules: [Vi, Gi, ia]
                });
              }
              return S2(a, [{
                key: "initialize",
                value: function() {
                  xh(cu(a.prototype), "initialize", this).call(this), this.componentManager.add(Yn), this.componentManager.add(Un), this.componentManager.add(Oi), this.componentManager.add(ag), this.componentManager.add(lg), this.componentManager.add(VB), this.componentManager.add(Hn, {
                    chartEl: this.el
                  }), this.componentManager.add(Vn), this.componentManager.add(Gn), this.componentManager.add($n, {
                    chartEl: this.el
                  }), this.componentManager.add(qn), this.painter.addGroups([p, w, f, O, S, d, k]);
                }
                /**
                 * Add data.
                 * @param {Array<number>} data - Array of data to be added.
                 * @param {string} category - Category to be added.
                 * @api
                 * @example
                 * chart.addData([10, 20], '6');
                 */
              }, {
                key: "addData",
                value: function(u, h) {
                  this.animationControlFlag.updating = !0, this.resetSeries(), this.store.dispatch("addData", {
                    data: u,
                    category: h
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<number>} data.data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function(u) {
                  this.resetSeries(), this.store.dispatch("addSeries", {
                    data: u
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set.
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['1', '2', '3'],
                 *   series: [
                 *     {
                 *       name: 'new series',
                 *       data: [1, 2, 3],
                 *     },
                 *     {
                 *       name: 'new series2',
                 *       data: [4, 5, 6],
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function(u) {
                  var h = u.categories, v = u.series;
                  this.resetSeries(), this.store.dispatch("setData", {
                    series: {
                      radar: v
                    },
                    categories: h
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function(u) {
                  this.dispatchOptionsEvent("initOptions", u);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("updateOptions", u);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.seriesIndex - Index of series.
                 *      @param {number} seriesInfo.index - Index of data within series.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2});
                 */
              }, {
                key: "showTooltip",
                value: function(u) {
                  this.eventBus.emit("showTooltip", YS(YS({}, u), {}, {
                    state: this.store.state
                  }));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function() {
                  this.eventBus.emit("hideTooltip");
                }
              }]), a;
            }(Wn);
            function qS(t) {
              return D2(t) || R2(t) || M2(t) || E2();
            }
            function E2() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function M2(t, n) {
              if (t) {
                if (typeof t == "string") return cg(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return cg(t, n);
              }
            }
            function R2(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function D2(t) {
              if (Array.isArray(t)) return cg(t);
            }
            function cg(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function P2(t, n, a) {
              return n * a / Wu(t);
            }
            function KS(t) {
              var n = t.height, a = t.width;
              return n < a;
            }
            function L2(t) {
              return KS(t) ? t.height : t.width;
            }
            function I2(t, n) {
              var a = n.width, o = n.height, u = P2(Wo(t, "data"), a, o);
              return t.map(function(h) {
                return {
                  id: h.id,
                  weight: h.data * u
                };
              }).sort(function(h, v) {
                return v.weight - h.weight;
              });
            }
            function XS(t, n, a, o) {
              var u = t * t, h = o * o;
              return Math.max(h * a / u, u / (h * n));
            }
            function _2(t, n, a, o) {
              var u = Math.min.apply(Math, qS(n)), h = Math.max.apply(Math, qS(n)), v = XS(t, u, h, a), g = XS(t + o, Math.min(u, o), Math.max(h, o), a);
              return g >= v;
            }
            function JS(t, n, a) {
              if (!n) {
                var o = Wo(a, "weight");
                n = Wu(o);
              }
              return n / t;
            }
            function ZS(t, n, a, o) {
              n.reduce(function(u, h) {
                var v = h.weight / a;
                return o(v, u, h.id), u + v;
              }, t);
            }
            function QS(t, n, a) {
              t[n] = a;
            }
            function N2(t, n, a, o, u) {
              var h = JS(o, u, n);
              ZS(a.y, n, h, function(v, g, b) {
                QS(t, b, {
                  x: a.x,
                  y: g,
                  width: h,
                  height: v
                });
              }), a.x += h, a.width -= h;
            }
            function B2(t, n, a, o, u) {
              var h = JS(o, u, n);
              ZS(a.x, n, h, function(v, g, b) {
                QS(t, b, {
                  x: g,
                  y: a.y,
                  width: v,
                  height: h
                });
              }), a.y += h, a.height -= h;
            }
            function F2(t) {
              return KS(t) ? N2 : B2;
            }
            function z2(t, n) {
              var a = t, o = I2(n, a), u = [], h, v, g = {};
              return o.forEach(function(b) {
                var C = Wo(u, "weight"), R = Wu(C);
                u.length && _2(R, C, h, b.weight) && (v(g, u, a, h, R), u = []), u.length || (h = L2(a), v = F2(a)), u.push(b);
              }), u.length && v(g, u, a, h), g;
            }
            function kh(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? kh = function(a) {
                return typeof a;
              } : kh = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, kh(t);
            }
            function ew(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function Kn(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? ew(Object(a), !0).forEach(function(o) {
                  as(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : ew(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function H2(t) {
              return U2(t) || $2(t) || W2(t) || j2();
            }
            function j2() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function W2(t, n) {
              if (t) {
                if (typeof t == "string") return fg(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return fg(t, n);
              }
            }
            function $2(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function U2(t) {
              if (Array.isArray(t)) return fg(t);
            }
            function fg(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function V2(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function G2(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function Y2(t, n, a) {
              return n && G2(t.prototype, n), t;
            }
            function q2(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && dg(t, n);
            }
            function dg(t, n) {
              return dg = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, dg(t, n);
            }
            function K2(t) {
              var n = J2();
              return function() {
                var o = Oh(t), u;
                if (n) {
                  var h = Oh(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return X2(this, u);
              };
            }
            function X2(t, n) {
              return n && (kh(n) === "object" || typeof n == "function") ? n : is(t);
            }
            function is(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function J2() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function Oh(t) {
              return Oh = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, Oh(t);
            }
            function as(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var Z2 = /* @__PURE__ */ function(t) {
              q2(a, t);
              var n = K2(a);
              function a() {
                var o;
                V2(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), as(is(o), "models", {
                  series: [],
                  layer: []
                }), as(is(o), "responders", void 0), as(is(o), "theme", void 0), as(is(o), "activatedResponders", []), as(is(o), "zoomable", void 0), as(is(o), "onMouseoutComponent", function() {
                  o.emitMouseEvent([]);
                }), as(is(o), "selectSeries", function(g) {
                  var b = g.seriesIndex;
                  if (Me(b)) {
                    var C = o.responders.find(function(I) {
                      var W = I.indexes;
                      return _e(W) === b;
                    });
                    if (!C)
                      throw new Error(ve.SELECT_SERIES_API_INDEX_ERROR);
                    var R = o.getRespondersWithTheme([C], "select");
                    o.eventBus.emit("renderSelectedSeries", {
                      models: R,
                      name: o.name
                    }), o.eventBus.emit("needDraw");
                  }
                }), as(is(o), "showTooltip", function(g) {
                  var b = g.seriesIndex;
                  if (Me(b)) {
                    var C = o.responders.find(function(R) {
                      var I = R.indexes;
                      return _e(I) === b;
                    });
                    C && o.emitMouseEvent([C]);
                  }
                }), o;
              }
              return Y2(a, [{
                key: "initialize",
                value: function() {
                  this.type = "series", this.name = "treemap", this.eventBus.on("selectSeries", this.selectSeries), this.eventBus.on("showTooltip", this.showTooltip), this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "getAllChildSeries",
                value: function(u, h) {
                  var v = this, g = [];
                  return u.forEach(function(b) {
                    if (b.parentId === h && (g.push(b), b.hasChild)) {
                      var C = v.getAllChildSeries(u, b.id);
                      g.push.apply(g, H2(C));
                    }
                  }), g;
                }
              }, {
                key: "render",
                value: function(u) {
                  var h, v, g = u.layout, b = u.treemapSeries, C = u.colorValueScale, R = u.options, I = u.theme, W = u.treemapZoomId;
                  if (!b)
                    throw new Error(ve.noDataError(this.name));
                  var Z = W.cur, ue = this.getAllChildSeries(b, Z);
                  if (this.theme = I.series.treemap, this.rect = g.plot, this.selectable = this.getSelectableOption(R), this.models = this.renderTreemapSeries(ue, R, C, Z), this.zoomable = (h = (v = R.series) === null || v === void 0 ? void 0 : v.zoomable) !== null && h !== void 0 ? h : !1, Ma(R, this.name).visible) {
                    var ke, Ee, Le, je = (ke = (Ee = R.series) === null || Ee === void 0 || (Le = Ee.dataLabels) === null || Le === void 0 ? void 0 : Le.useTreemapLeaf) !== null && ke !== void 0 ? ke : !1, Ke = this.makeDataLabel(je, Z);
                    this.renderDataLabels(Ke);
                  }
                  this.responders = this.makeTreemapSeriesResponder(Z);
                }
              }, {
                key: "makeTreemapSeriesResponder",
                value: function(u) {
                  var h = this.makeTooltipData(), v = this.models.series;
                  return this.zoomable && (v = v.filter(function(g) {
                    var b = g.parentId;
                    return b === u;
                  })), v.map(function(g, b) {
                    return Kn(Kn({}, g), {}, {
                      data: h[b],
                      thickness: hi.HOVER_THICKNESS,
                      style: ["shadow"]
                    });
                  });
                }
              }, {
                key: "makeTooltipData",
                value: function() {
                  return this.models.series.map(function(u) {
                    var h = u.label, v = u.data, g = u.color;
                    return {
                      label: h,
                      color: g,
                      value: v
                    };
                  });
                }
              }, {
                key: "makeBoundMap",
                value: function(u, h, v) {
                  var g = this, b = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, C = u.filter(function(R) {
                    return R.parentId === h;
                  });
                  return b = Kn(Kn({}, b), z2(Kn({}, v), C)), C.forEach(function(R) {
                    b = g.makeBoundMap(u, R.id, b[R.id], b);
                  }), b;
                }
              }, {
                key: "makeDataLabel",
                value: function(u, h) {
                  var v = u ? this.models.series.filter(function(b) {
                    var C = b.hasChild;
                    return !C;
                  }) : this.models.series.filter(function(b) {
                    var C = b.parentId;
                    return C === h;
                  }), g = this.theme.dataLabels;
                  return v.map(function(b) {
                    return Kn(Kn({}, b), {}, {
                      type: "treemapSeriesName",
                      value: b.label,
                      direction: "left",
                      plot: {
                        x: 0,
                        y: 0,
                        size: 0
                      },
                      theme: Kn(Kn({}, g), {}, {
                        color: g.useSeriesColor ? b.color : g.color
                      })
                    });
                  });
                }
              }, {
                key: "getColor",
                value: function(u, h) {
                  var v = u.indexes, g = pe(v);
                  return h[g];
                }
              }, {
                key: "getOpacity",
                value: function(u) {
                  var h = u.indexes, v = u.depth, g = _e(h);
                  return h.length === 1 ? 0 : Number((0.1 * v + 0.05 * g).toFixed(2));
                }
              }, {
                key: "renderTreemapSeries",
                value: function(u, h, v, g) {
                  var b, C, R = this, I, W = [], Z = this.makeBoundMap(u, g, Kn(Kn({}, this.rect), {}, {
                    x: 0,
                    y: 0
                  })), ue = this.theme, ke = ue.colors, Ee = ue.startColor, Le = ue.endColor, je = ue.borderWidth, Ke = ue.borderColor, ut, bt, mt = (b = (C = h.series) === null || C === void 0 ? void 0 : C.useColorValue) !== null && b !== void 0 ? b : !1;
                  mt && Ee && Le && (ut = kr(Ee), bt = W0(ut, kr(Le)));
                  var Rt = Object.keys(Z).map(function(Dt) {
                    var Lt = u.find(function(Qt) {
                      return Qt.id === Dt;
                    }), Wt;
                    return mt && (Wt = $0(v.limit, Lt.colorValue)), Kn(Kn(Kn({}, Lt), Z[Dt]), {}, {
                      type: "rect",
                      colorRatio: Wt,
                      color: mt ? U0(Wt, bt, ut) : R.getColor(Lt, ke),
                      opacity: mt ? 0 : R.getOpacity(Lt),
                      thickness: je,
                      borderColor: Ke
                    });
                  });
                  return (I = h.series) !== null && I !== void 0 && I.useColorValue || (W = Rt.map(function(Dt) {
                    return Kn(Kn({}, Dt), {}, {
                      color: cr("#000000", Dt.opacity)
                    });
                  })), {
                    series: Rt,
                    layer: W
                  };
                }
              }, {
                key: "getRespondersWithTheme",
                value: function(u, h) {
                  var v = this;
                  return u.map(function(g) {
                    return Ye(g, Kn(Kn({}, v.theme[h]), {}, {
                      style: ["shadow"]
                    }));
                  });
                }
              }, {
                key: "onClick",
                value: function(u) {
                  var h = u.responders;
                  if (h.length) {
                    if (this.zoomable) {
                      var v = h[0], g = v.id, b = v.hasChild;
                      b ? (this.emitMouseEvent([]), this.store.dispatch("setTreemapZoomId", g), this.eventBus.emit("resetSelectedSeries")) : this.selectable && this.eventBus.emit("renderSelectedSeries", {
                        models: this.getRespondersWithTheme(h, "select"),
                        name: this.name
                      });
                    } else if (this.selectable) {
                      var C = t0(h);
                      this.eventBus.emit("renderSelectedSeries", {
                        models: this.getRespondersWithTheme(C, "select"),
                        name: this.name
                      });
                    }
                  }
                }
              }, {
                key: "onMousemove",
                value: function(u) {
                  var h = u.responders, v = t0(h);
                  this.activatedResponders = v, this.emitMouseEvent(v);
                }
              }, {
                key: "emitMouseEvent",
                value: function(u) {
                  this.eventBus.emit("renderHoveredSeries", {
                    models: this.getRespondersWithTheme(u, "hover"),
                    name: this.name
                  }), this.eventBus.emit("seriesPointHovered", {
                    models: u,
                    name: this.name
                  }), this.eventBus.emit("renderSpectrumTooltip", u), this.eventBus.emit("needDraw");
                }
              }]), a;
            }(Lr);
            function Ch(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Ch = function(a) {
                return typeof a;
              } : Ch = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Ch(t);
            }
            function Q2(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function eF(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function tF(t, n, a) {
              return n && eF(t.prototype, n), t;
            }
            function rF(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && hg(t, n);
            }
            function hg(t, n) {
              return hg = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, hg(t, n);
            }
            function nF(t) {
              var n = aF();
              return function() {
                var o = Th(t), u;
                if (n) {
                  var h = Th(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return iF(this, u);
              };
            }
            function iF(t, n) {
              return n && (Ch(n) === "object" || typeof n == "function") ? n : pg(t);
            }
            function pg(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function aF() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function Th(t) {
              return Th = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, Th(t);
            }
            function tw(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var oF = /* @__PURE__ */ function(t) {
              rF(a, t);
              var n = nF(a);
              function a() {
                var o;
                Q2(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), tw(pg(o), "responders", void 0), tw(pg(o), "models", void 0), o;
              }
              return tF(a, [{
                key: "initialize",
                value: function() {
                  this.type = "backButton", this.name = "backButton";
                }
              }, {
                key: "onClick",
                value: function(u) {
                  var h = u.responders;
                  h.length && (this.store.dispatch("zoomBack"), this.eventBus.emit("resetSelectedSeries"));
                }
              }, {
                key: "render",
                value: function(u, h) {
                  var v = u.options, g = u.layout;
                  ov(v) && (this.rect = g.resetButton, this.isShow = h.isTreemapSeriesZooming, this.models = this.isShow ? [{
                    type: "backButton",
                    x: 0,
                    y: 0
                  }] : [], this.responders = this.isShow ? [{
                    type: "rect",
                    x: 0,
                    y: 0,
                    width: sn,
                    height: sn
                  }] : []);
                }
              }]), a;
            }(Lr);
            function Ah(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Ah = function(a) {
                return typeof a;
              } : Ah = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Ah(t);
            }
            function rw(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function vg(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? rw(Object(a), !0).forEach(function(o) {
                  sF(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : rw(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function sF(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function lF(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function uF(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function cF(t, n, a) {
              return n && uF(t.prototype, n), t;
            }
            function Eh(t, n, a) {
              return typeof Reflect < "u" && Reflect.get ? Eh = Reflect.get : Eh = function(u, h, v) {
                var g = fF(u, h);
                if (g) {
                  var b = Object.getOwnPropertyDescriptor(g, h);
                  return b.get ? b.get.call(v) : b.value;
                }
              }, Eh(t, n, a || t);
            }
            function fF(t, n) {
              for (; !Object.prototype.hasOwnProperty.call(t, n) && (t = fu(t), t !== null); )
                ;
              return t;
            }
            function dF(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && mg(t, n);
            }
            function mg(t, n) {
              return mg = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, mg(t, n);
            }
            function hF(t) {
              var n = mF();
              return function() {
                var o = fu(t), u;
                if (n) {
                  var h = fu(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return pF(this, u);
              };
            }
            function pF(t, n) {
              return n && (Ah(n) === "object" || typeof n == "function") ? n : vF(t);
            }
            function vF(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function mF() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function fu(t) {
              return fu = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, fu(t);
            }
            var gF = /* @__PURE__ */ function(t) {
              dF(a, t);
              var n = hF(a);
              function a(o) {
                return lF(this, a), n.call(this, {
                  el: o.el,
                  options: o.options,
                  series: {
                    treemap: o.data.series
                  },
                  modules: [uP, z0]
                });
              }
              return cF(a, [{
                key: "initialize",
                value: function() {
                  Eh(fu(a.prototype), "initialize", this).call(this), this.componentManager.add(Yn), this.componentManager.add(Un), this.componentManager.add(j0), this.componentManager.add(Z2), this.componentManager.add(Hn, {
                    chartEl: this.el
                  }), this.componentManager.add(Vn), this.componentManager.add(Gn), this.componentManager.add(Yi), this.componentManager.add($n, {
                    chartEl: this.el
                  }), this.componentManager.add(oF), this.componentManager.add(qn), this.painter.addGroups([p, w, f, O, m, y, T]);
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<Object>} data.data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   label: 'Documents',
                 *   children: [
                 *     {label: 'A', data: 20},
                 *     {label: 'B', data: 40},
                 *   ],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function(u, h) {
                  this.resetSeries(), this.store.dispatch("addTreemapSeries", vg({
                    data: u
                  }, h));
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set.
                 * @api
                 * @example
                 * chart.setData(
                 *   series: [
                 *     {
                 *       label: 'Documents',
                 *       children: [
                 *         {label: 'A', data: 20},
                 *         {label: 'B', data: 40},
                 *       ],
                 *     },
                 *     {
                 *       label: 'Documents',
                 *       data: 30,
                 *     }
                 *   ]
                 * );
                 */
              }, {
                key: "setData",
                value: function(u) {
                  this.resetSeries(), this.store.dispatch("setData", {
                    series: {
                      treemap: u.series
                    }
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !1
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !0
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("initOptions", u);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("updateOptions", u);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.seriesIndex - Index of series.
                 * @api
                 * @example
                 * chart.showTooltip({seriesIndex: 1});
                 */
              }, {
                key: "showTooltip",
                value: function(u) {
                  this.eventBus.emit("showTooltip", vg(vg({}, u), {}, {
                    state: this.store.state
                  }));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function() {
                  this.eventBus.emit("hideTooltip");
                }
              }]), a;
            }(Wn);
            function Mh(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Mh = function(a) {
                return typeof a;
              } : Mh = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Mh(t);
            }
            function nw(t) {
              return SF(t) || bF(t) || iw(t) || yF();
            }
            function yF() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function bF(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function SF(t) {
              if (Array.isArray(t)) return gg(t);
            }
            function Rh(t, n) {
              return kF(t) || xF(t, n) || iw(t, n) || wF();
            }
            function wF() {
              throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function iw(t, n) {
              if (t) {
                if (typeof t == "string") return gg(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return gg(t, n);
              }
            }
            function gg(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function xF(t, n) {
              var a = t && (typeof Symbol < "u" && t[Symbol.iterator] || t["@@iterator"]);
              if (a != null) {
                var o = [], u = !0, h = !1, v, g;
                try {
                  for (a = a.call(t); !(u = (v = a.next()).done) && (o.push(v.value), !(n && o.length === n)); u = !0)
                    ;
                } catch (b) {
                  h = !0, g = b;
                } finally {
                  try {
                    !u && a.return != null && a.return();
                  } finally {
                    if (h) throw g;
                  }
                }
                return o;
              }
            }
            function kF(t) {
              if (Array.isArray(t)) return t;
            }
            function aw(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function $r(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? aw(Object(a), !0).forEach(function(o) {
                  io(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : aw(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function OF(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function CF(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function TF(t, n, a) {
              return n && CF(t.prototype, n), t;
            }
            function AF(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && yg(t, n);
            }
            function yg(t, n) {
              return yg = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, yg(t, n);
            }
            function EF(t) {
              var n = RF();
              return function() {
                var o = Dh(t), u;
                if (n) {
                  var h = Dh(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return MF(this, u);
              };
            }
            function MF(t, n) {
              return n && (Mh(n) === "object" || typeof n == "function") ? n : no(t);
            }
            function no(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function RF() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function Dh(t) {
              return Dh = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, Dh(t);
            }
            function io(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var DF = 5;
            function PF(t, n, a) {
              return (t - n * a) / (a + 1);
            }
            function du(t, n) {
              return n ?? t;
            }
            var LF = /* @__PURE__ */ function(t) {
              AF(a, t);
              var n = EF(a);
              function a() {
                var o;
                OF(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), io(no(o), "models", {
                  rect: [],
                  line: [],
                  circle: []
                }), io(no(o), "drawModels", void 0), io(no(o), "responders", void 0), io(no(o), "activatedResponders", []), io(no(o), "eventDetectType", "point"), io(no(o), "tooltipRectMap", void 0), io(no(o), "theme", void 0), io(no(o), "onMouseoutComponent", function() {
                  o.eventBus.emit("seriesPointHovered", {
                    models: [],
                    name: o.name
                  }), o.eventBus.emit("renderHoveredSeries", {
                    models: [],
                    name: o.name,
                    eventDetectType: o.eventDetectType
                  }), o.eventBus.emit("needDraw");
                }), io(no(o), "selectSeries", function(g) {
                  var b = g.index, C = g.seriesIndex, R = g.state;
                  if (!(!Me(b) || !Me(C))) {
                    var I = R.series.boxPlot[C].name, W = o.getRespondersWithTheme(o.tooltipRectMap["".concat(I, "-").concat(b)], "select");
                    o.eventBus.emit("renderSelectedSeries", {
                      models: W,
                      name: o.name,
                      eventDetectType: o.eventDetectType
                    }), o.eventBus.emit("needDraw");
                  }
                }), io(no(o), "showTooltip", function(g) {
                  var b = g.index, C = g.seriesIndex, R = g.state;
                  if (!(!Me(b) || !Me(C))) {
                    var I = R.series.boxPlot[C].name, W = o.getRespondersWithTheme(o.tooltipRectMap["".concat(I, "-").concat(b)], "hover");
                    o.eventBus.emit("renderHoveredSeries", {
                      models: W,
                      name: o.name,
                      eventDetectType: o.eventDetectType
                    }), o.activatedResponders = W, o.eventBus.emit("seriesPointHovered", {
                      models: o.activatedResponders,
                      name: o.name
                    }), o.eventBus.emit("needDraw");
                  }
                }), o;
              }
              return TF(a, [{
                key: "initialize",
                value: function() {
                  this.type = "series", this.name = "boxPlot", this.eventBus.on("selectSeries", this.selectSeries), this.eventBus.on("showTooltip", this.showTooltip), this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "render",
                value: function(u) {
                  var h, v = u.layout, g = u.axes, b = u.series, C = u.scale, R = u.legend, I = u.options, W = u.theme;
                  if (!b.boxPlot)
                    throw new Error(ve.noDataError(this.name));
                  I != null && (h = I.series) !== null && h !== void 0 && h.eventDetectType && (this.eventDetectType = I.series.eventDetectType), this.theme = W.series.boxPlot, this.rect = v.plot, this.activeSeriesMap = Ea(R), this.selectable = this.getSelectableOption(I);
                  var Z = u.categories, ue = g.xAxis.tickDistance, ke = C.yAxis.limit, Ee = ke.min, Le = ke.max, je = b.boxPlot.data, Ke = je.length, ut = $r({
                    ratio: this.rect.height / (Le - Ee),
                    tickDistance: ue
                  }, this.getBarWidths(ue, Ke)), bt = this.makeBoxPlots(je, ut), mt = this.renderSeriesModels(bt);
                  this.models = mt, this.drawModels || (this.drawModels = {
                    rect: mt.rect.map(function(Dt) {
                      return $r($r({}, Dt), {}, {
                        y: Dt.y + Dt.height,
                        height: 0
                      });
                    }),
                    line: mt.line,
                    circle: mt.circle
                  });
                  var Rt = this.makeTooltipModel(je, Z);
                  this.tooltipRectMap = this.makeTooltipRectMap(bt, Rt), this.responders = this.eventDetectType === "grouped" ? this.makeGroupedResponderModel(bt) : this.makeDefaultResponderModel(bt, Rt);
                }
              }, {
                key: "makeTooltipRectMap",
                value: function(u, h) {
                  var v = this, g = {};
                  return u.forEach(function(b, C) {
                    if (!Oe(b)) {
                      var R = "".concat(b.name, "-").concat(b.index);
                      g[R] || (g[R] = []), g[R].push($r($r({}, v.makeHoveredModel(b)), {}, {
                        data: h[C]
                      }));
                    }
                  }), g;
                }
              }, {
                key: "makeGroupedResponderModel",
                value: function(u) {
                  var h = this, v = [];
                  return u.forEach(function(g) {
                    var b = g.type, C = g.index, R = g.name, I = "".concat(R, "-").concat(C);
                    if (b === "boxPlot" && !v[I]) {
                      var W = g, Z = W.boxPlotDetection;
                      v.push($r($r({
                        type: "rect",
                        name: I
                      }, Z), {}, {
                        y: 0,
                        height: h.rect.height
                      }));
                    }
                  }), v;
                }
              }, {
                key: "makeDefaultResponderModel",
                value: function(u, h) {
                  var v = this;
                  return u.map(function(g, b) {
                    return $r($r({}, v.makeHoveredModel(g)), {}, {
                      data: h[b],
                      color: cr(g.color, 1)
                    });
                  });
                }
              }, {
                key: "makeHoveredModel",
                value: function(u) {
                  var h = u.type === "boxPlot" && u.rect ? {
                    x: u.rect.x,
                    y: u.rect.y
                  } : {
                    x: u.x,
                    y: u.y
                  }, v = $r({}, u);
                  return u.type === "boxPlot" && (["lowerWhisker", "upperWhisker", "maximum", "minimum", "median"].forEach(function(g) {
                    u[g] && (u[g].detectionSize = 3);
                  }), u.color = cr(v.color, 1)), $r($r({}, v), h);
                }
              }, {
                key: "getResponderModelFromMap",
                value: function(u) {
                  if (!u.length)
                    return [];
                  var h = u[0].name;
                  return this.tooltipRectMap[h];
                }
              }, {
                key: "onMousemove",
                value: function(u) {
                  var h = u.responders;
                  if (this.eventDetectType === "grouped") {
                    var v = this.getResponderModelFromMap(h);
                    this.eventBus.emit("renderHoveredSeries", {
                      models: this.getRespondersWithTheme(v, "select"),
                      name: this.name,
                      eventDetectType: this.eventDetectType
                    }), this.activatedResponders = v;
                  } else
                    this.eventBus.emit("renderHoveredSeries", {
                      models: this.getRespondersWithTheme(h, "hover"),
                      name: this.name,
                      eventDetectType: this.eventDetectType
                    }), this.activatedResponders = h;
                  this.eventBus.emit("seriesPointHovered", {
                    models: this.activatedResponders,
                    name: this.name
                  }), this.eventBus.emit("needDraw");
                }
              }, {
                key: "onClick",
                value: function(u) {
                  var h = u.responders;
                  if (this.selectable) {
                    var v;
                    this.eventDetectType === "grouped" ? v = this.getRespondersWithTheme(this.getResponderModelFromMap(h), "select") : v = this.getRespondersWithTheme(h, "select"), this.eventBus.emit("renderSelectedSeries", {
                      models: v,
                      name: this.name,
                      eventDetectType: this.eventDetectType
                    }), this.eventBus.emit("needDraw");
                  }
                }
              }, {
                key: "renderSeriesModels",
                value: function(u) {
                  return u.reduce(function(h, v) {
                    var g = v.type, b = v.name;
                    return g === "boxPlot" ? (h.rect.push($r({
                      name: b
                    }, v.rect)), ["maximum", "minimum", "median", "upperWhisker", "lowerWhisker"].forEach(function(C) {
                      h.line.push($r({
                        name: b
                      }, v[C]));
                    })) : h.circle.push($r({}, v)), h;
                  }, {
                    rect: [],
                    line: [],
                    circle: []
                  });
                }
              }, {
                key: "makeBoxPlots",
                value: function(u, h) {
                  var v = this, g = h.ratio, b = h.barWidth, C = [], R = u.length, I = this.theme.dot;
                  return u.forEach(function(W, Z) {
                    var ue = W.outliers, ke = W.data, Ee = W.name, Le = W.color, je = v.getSeriesColor(Ee, Le);
                    (ke ?? []).forEach(function(Lt, Wt) {
                      if (!Oe(Lt)) {
                        var Qt = v.getStartX(Z, Wt, h, R), or = v.getRect(Lt, Qt, je, h);
                        C.push($r($r({
                          type: "boxPlot",
                          color: je,
                          name: Ee,
                          rect: or,
                          median: v.getMedian(Lt, Qt, je, h),
                          minimum: v.getMinimum(Lt, Qt, je, h),
                          maximum: v.getMaximum(Lt, Qt, je, h)
                        }, v.getWhisker(Lt, Qt, je, h, or)), {}, {
                          index: Wt,
                          boxPlotDetection: {
                            x: Qt,
                            width: b
                          }
                        }));
                      }
                    });
                    var Ke = I, ut = Ke.color, bt = Ke.radius, mt = Ke.borderColor, Rt = Ke.borderWidth, Dt = Ke.useSeriesColor;
                    (ue ?? []).forEach(function(Lt) {
                      var Wt = Rh(Lt, 2), Qt = Wt[0], or = Wt[1], lr = v.getStartX(Z, Qt, h, R);
                      C.push({
                        type: "circle",
                        name: Ee,
                        x: lr + b / 2,
                        y: v.getYPos(or, g),
                        radius: bt,
                        style: [{
                          strokeStyle: mt ?? je,
                          lineWidth: Rt
                        }],
                        color: Dt ? je : ut,
                        index: Qt
                      });
                    });
                  }), C;
                }
              }, {
                key: "makeTooltipModel",
                value: function(u, h) {
                  var v = [];
                  return u.forEach(function(g) {
                    var b = g.outliers, C = g.data, R = g.name, I = g.color;
                    (C ?? []).forEach(function(W, Z) {
                      if (!Oe(W)) {
                        var ue = nw(W).reverse();
                        v.push({
                          label: R,
                          color: I,
                          value: ["Maximum", "Upper Quartile", "Median", "Lower Quartile", "Minimum"].reduce(function(ke, Ee, Le) {
                            var je = ue[Le];
                            return Oe(je) ? ke : [].concat(nw(ke), [{
                              title: Ee,
                              value: je
                            }]);
                          }, []),
                          category: h[Z],
                          templateType: "boxPlot"
                        });
                      }
                    }), (b ?? []).forEach(function(W) {
                      if (!Oe(W)) {
                        var Z = Rh(W, 2), ue = Z[0], ke = Z[1];
                        v.push({
                          label: R,
                          color: I,
                          value: [{
                            title: "Outlier",
                            value: ke
                          }],
                          category: h[ue],
                          templateType: "boxPlot"
                        });
                      }
                    });
                  }), v;
                }
              }, {
                key: "getStartX",
                value: function(u, h, v, g) {
                  var b = v.tickDistance, C = v.barWidth, R = PF(b, C, g);
                  return h * b + (u + 1) * R + C * u;
                }
              }, {
                key: "getYPos",
                value: function(u, h, v) {
                  return Me(v) ? Cr(this.rect.height - u * h, v) : this.rect.height - u * h;
                }
              }, {
                key: "getBarWidths",
                value: function(u, h) {
                  var v = this.theme, g = v.barWidth, b = v.barWidthRatios, C = b.barRatio, R = b.minMaxBarRatio, I = Math.max((u - Fo(u) * (2 + (h - 1))) / h, DF), W = g ? be(u / h, g) : I;
                  return {
                    barWidth: W * C,
                    minMaxBarWidth: W * R
                  };
                }
              }, {
                key: "getRespondersWithTheme",
                value: function(u, h) {
                  var v = this.theme[h], g = v.color, b = v.rect, C = v.dot, R = v.line, I = v.shadowColor, W = v.shadowOffsetX, Z = v.shadowOffsetY, ue = v.shadowBlur, ke = R, Ee = ke.whisker, Le = ke.median, je = ke.maximum, Ke = ke.minimum, ut = C, bt = ut.color, mt = ut.radius, Rt = ut.borderColor, Dt = ut.borderWidth, Lt = ut.useSeriesColor;
                  return u.map(function(Wt) {
                    var Qt = Wt.type, or = Wt.data, lr = Wt.color, xr;
                    if (Qt === "circle")
                      lr = or.color, xr = $r($r({}, Wt), {}, {
                        radius: mt,
                        color: Lt ? lr : bt,
                        style: [{
                          strokeStyle: du(lr, Rt),
                          lineWidth: Dt
                        }]
                      });
                    else {
                      var br = Wt, yr = br.rect, Ar = br.upperWhisker, qr = br.lowerWhisker, nn = br.median, tn = br.maximum, bn = br.minimum;
                      xr = $r($r({}, Wt), {}, {
                        rect: $r($r({}, yr), {}, {
                          color: g ?? cr(lr, 1),
                          thickness: b.borderWidth,
                          borderColor: b.borderColor,
                          style: [{
                            shadowColor: I,
                            shadowOffsetX: W,
                            shadowOffsetY: Z,
                            shadowBlur: ue
                          }]
                        }),
                        upperWhisker: $r($r({}, Ar), {}, {
                          strokeStyle: du(lr, Ee.color),
                          lineWidth: Ee.lineWidth
                        }),
                        lowerWhisker: $r($r({}, qr), {}, {
                          strokeStyle: du(lr, Ee.color),
                          lineWidth: Ee.lineWidth
                        }),
                        median: $r($r({}, nn), {}, {
                          strokeStyle: du(lr, Le.color),
                          lineWidth: Le.lineWidth
                        }),
                        maximum: $r($r({}, tn), {}, {
                          strokeStyle: du(lr, je.color),
                          lineWidth: je.lineWidth
                        }),
                        minimum: $r($r({}, bn), {}, {
                          strokeStyle: du(lr, Ke.color),
                          lineWidth: Ke.lineWidth
                        })
                      });
                    }
                    return xr;
                  });
                }
              }, {
                key: "getRect",
                value: function(u, h, v, g) {
                  var b = g.barWidth, C = g.ratio, R = this.theme.rect, I = Rh(u, 4), W = I[1], Z = I[3];
                  return {
                    type: "rect",
                    x: h,
                    y: this.getYPos(Z, C),
                    width: b,
                    height: (Z - W) * C,
                    thickness: R.borderWidth,
                    borderColor: R.borderColor,
                    color: v
                  };
                }
              }, {
                key: "getWhisker",
                value: function(u, h, v, g, b) {
                  var C = g.barWidth, R = g.ratio, I = Rh(u, 5), W = I[0], Z = I[4], ue = this.theme.line.whisker, ke = ue.lineWidth, Ee = ue.color, Le = Cr(h + C / 2, ke);
                  return {
                    upperWhisker: {
                      type: "line",
                      x: Le,
                      y: this.getYPos(Z, R, ke),
                      x2: Le,
                      y2: b.y,
                      strokeStyle: Ee ?? v,
                      lineWidth: ke
                    },
                    lowerWhisker: {
                      type: "line",
                      x: Le,
                      y: this.getYPos(W, R, ke),
                      x2: Le,
                      y2: Cr(b.y + b.height, ke),
                      strokeStyle: Ee ?? v,
                      lineWidth: ke
                    }
                  };
                }
              }, {
                key: "getMedian",
                value: function(u, h, v, g) {
                  var b = g.barWidth, C = g.ratio, R = u[2], I = this.theme.line.median, W = I.lineWidth, Z = I.color;
                  return {
                    type: "line",
                    x: Cr(h, W),
                    y: this.getYPos(R, C, W),
                    x2: Cr(h + b, W),
                    y2: this.getYPos(R, C, W),
                    strokeStyle: Z ?? v,
                    lineWidth: W
                  };
                }
              }, {
                key: "getMinimum",
                value: function(u, h, v, g) {
                  var b = g.barWidth, C = g.ratio, R = g.minMaxBarWidth, I = u[0], W = this.theme.line.minimum, Z = W.lineWidth, ue = W.color;
                  return {
                    type: "line",
                    x: Cr(h + (b - R) / 2, Z),
                    y: this.getYPos(I, C, Z),
                    x2: Cr(h + (b - R) / 2 + R, Z),
                    y2: this.getYPos(I, C, Z),
                    strokeStyle: ue ?? v,
                    lineWidth: Z
                  };
                }
              }, {
                key: "getMaximum",
                value: function(u, h, v, g) {
                  var b = g.barWidth, C = g.ratio, R = g.minMaxBarWidth, I = u[4], W = this.theme.line.maximum, Z = W.lineWidth, ue = W.color;
                  return {
                    type: "line",
                    x: Cr(h + (b - R) / 2, Z),
                    y: this.getYPos(I, C, Z),
                    x2: Cr(h + (b - R) / 2 + R, Z),
                    y2: this.getYPos(I, C, Z),
                    strokeStyle: ue ?? v,
                    lineWidth: Z
                  };
                }
              }, {
                key: "getSeriesColor",
                value: function(u, h) {
                  var v = this.theme, g = v.select, b = v.areaOpacity, C = this.activeSeriesMap[u], R = Object.values(this.activeSeriesMap).some(function(Z) {
                    return !Z;
                  }), I = C ? g.areaOpacity : g.restSeries.areaOpacity, W = R ? I : b;
                  return cr(h, W);
                }
              }]), a;
            }(Lr);
            function ow(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function hu(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? ow(Object(a), !0).forEach(function(o) {
                  IF(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : ow(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function IF(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function _F(t, n) {
              var a = n.rect, o = n.upperWhisker, u = n.lowerWhisker, h = n.median, v = n.minimum, g = n.maximum;
              v && Wr(t, hu({
                type: "line"
              }, v)), u && Wr(t, hu({
                type: "line"
              }, u)), a && cn(t, hu({
                type: "rect"
              }, a)), o && Wr(t, hu({
                type: "line"
              }, o)), g && Wr(t, hu({
                type: "line"
              }, g)), h && Wr(t, hu({
                type: "line"
              }, h));
            }
            function Ph(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Ph = function(a) {
                return typeof a;
              } : Ph = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Ph(t);
            }
            function sw(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function lw(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? sw(Object(a), !0).forEach(function(o) {
                  NF(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : sw(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function NF(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function BF(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function FF(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function zF(t, n, a) {
              return n && FF(t.prototype, n), t;
            }
            function Lh(t, n, a) {
              return typeof Reflect < "u" && Reflect.get ? Lh = Reflect.get : Lh = function(u, h, v) {
                var g = HF(u, h);
                if (g) {
                  var b = Object.getOwnPropertyDescriptor(g, h);
                  return b.get ? b.get.call(v) : b.value;
                }
              }, Lh(t, n, a || t);
            }
            function HF(t, n) {
              for (; !Object.prototype.hasOwnProperty.call(t, n) && (t = pu(t), t !== null); )
                ;
              return t;
            }
            function jF(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && bg(t, n);
            }
            function bg(t, n) {
              return bg = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, bg(t, n);
            }
            function WF(t) {
              var n = VF();
              return function() {
                var o = pu(t), u;
                if (n) {
                  var h = pu(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return $F(this, u);
              };
            }
            function $F(t, n) {
              return n && (Ph(n) === "object" || typeof n == "function") ? n : UF(t);
            }
            function UF(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function VF() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function pu(t) {
              return pu = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, pu(t);
            }
            var GF = /* @__PURE__ */ function(t) {
              jF(a, t);
              var n = WF(a);
              function a(o) {
                var u = o.el, h = o.options, v = o.data, g = v.series, b = v.categories;
                return BF(this, a), n.call(this, {
                  el: u,
                  options: h,
                  series: {
                    boxPlot: g
                  },
                  categories: b,
                  modules: [Vi, Gi, Xa, Za]
                });
              }
              return zF(a, [{
                key: "initialize",
                value: function() {
                  Lh(pu(a.prototype), "initialize", this).call(this), this.componentManager.add(Yn), this.componentManager.add(Un), this.componentManager.add(Qa), this.componentManager.add(Oi), this.componentManager.add(LF), this.componentManager.add(Vr, {
                    name: "yAxis"
                  }), this.componentManager.add(Vr, {
                    name: "xAxis"
                  }), this.componentManager.add(Yr, {
                    name: "xAxis"
                  }), this.componentManager.add(Yr, {
                    name: "yAxis"
                  }), this.componentManager.add(Hn, {
                    chartEl: this.el
                  }), this.componentManager.add(Vn), this.componentManager.add(Gn), this.componentManager.add($n, {
                    chartEl: this.el
                  }), this.componentManager.add(qn), this.painter.addGroups([p, d, z, w, f, O]);
                }
                /**
                 * Add data.
                 * @param {Array<<Array<number>>} data - Array of data to be added.
                 * @param {string} category - Category to be added.
                 * @api
                 * @example
                 * chart.addData(
                    [
                       [3000, 4000, 4714, 6000, 7000],
                       [3000, 5750, 7571, 8250, 9000],
                    ],
                    'newCategory'
                  );
                 */
              }, {
                key: "addData",
                value: function(u, h) {
                  this.animationControlFlag.updating = !0, this.resetSeries(), this.store.dispatch("addData", {
                    data: u,
                    category: h
                  });
                }
                /**
                 * add outlier.
                 * @param {number} seriesIndex - Index of series.
                 * @param {number} outliers - Array of outlier.
                 * @api
                 * @example
                 * chart.addOutlier(1, [[1, 10000], [3, 12000]]);
                 */
              }, {
                key: "addOutlier",
                value: function(u, h) {
                  this.animationControlFlag.updating = !0, this.resetSeries(), this.store.dispatch("addOutlier", {
                    seriesIndex: u,
                    outliers: h
                  });
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<Array<number>>} data.data - Array of data to be added.
                 *   @param {Array<Array<number>>} data.outliers - Series outliers data.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: [
                 *     [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
                 *   ],
                 *   outliers: [
                 *     [0, 14000],
                 *     [2, 10000],
                 *   ]
                 * });
                 */
              }, {
                key: "addSeries",
                value: function(u) {
                  this.resetSeries(), this.store.dispatch("addSeries", {
                    data: u
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set.
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['1', '2', '3'],
                 *   series: [
                 *     {
                 *       name: 'newSeries',
                 *       data: [
                 *         [10, 100, 50, 40, 70, 55, 33, 70, 90, 110],
                 *       ],
                 *       outliers: [
                 *         [0, 14000],
                 *         [2, 10000],
                 *       ]
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function(u) {
                  var h = u.categories, v = u.series;
                  this.resetSeries(), this.store.dispatch("setData", {
                    series: {
                      boxPlot: v
                    },
                    categories: h
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   xAxis: {
                 *     title: 'Month',
                 *     date: { format: 'yy/MM' },
                 *   },
                 *   yAxis: {
                 *     title: 'Energy (kWh)',
                 *   },
                 *   series: {
                 *     selectable: true,
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "setOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("initOptions", u);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     height: 'auto',
                 *     title: 'Energy Usage',
                 *   },
                 *   tooltip: {
                 *     formatter: (value) => `${value}kWh`,
                 *   },
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("updateOptions", u);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.seriesIndex - Index of series.
                 *      @param {number} seriesInfo.index - Index of data within series.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1, seriesIndex: 2});
                 */
              }, {
                key: "showTooltip",
                value: function(u) {
                  this.eventBus.emit("showTooltip", lw(lw({}, u), {}, {
                    state: this.store.state
                  }));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function() {
                  this.eventBus.emit("hideTooltip");
                }
              }]), a;
            }(Wn);
            function Ih(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Ih = function(a) {
                return typeof a;
              } : Ih = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Ih(t);
            }
            function uw(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function Xn(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? uw(Object(a), !0).forEach(function(o) {
                  Ba(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : uw(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function bc(t) {
              return XF(t) || KF(t) || qF(t) || YF();
            }
            function YF() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function qF(t, n) {
              if (t) {
                if (typeof t == "string") return Sg(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return Sg(t, n);
              }
            }
            function KF(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function XF(t) {
              if (Array.isArray(t)) return Sg(t);
            }
            function Sg(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function JF(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function ZF(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function QF(t, n, a) {
              return n && ZF(t.prototype, n), t;
            }
            function ez(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && wg(t, n);
            }
            function wg(t, n) {
              return wg = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, wg(t, n);
            }
            function tz(t) {
              var n = nz();
              return function() {
                var o = _h(t), u;
                if (n) {
                  var h = _h(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return rz(this, u);
              };
            }
            function rz(t, n) {
              return n && (Ih(n) === "object" || typeof n == "function") ? n : Na(t);
            }
            function Na(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function nz() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function _h(t) {
              return _h = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, _h(t);
            }
            function Ba(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var iz = /* @__PURE__ */ function(t) {
              ez(a, t);
              var n = tz(a);
              function a() {
                var o;
                JF(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), Ba(Na(o), "models", {}), Ba(Na(o), "drawModels", void 0), Ba(Na(o), "responders", void 0), Ba(Na(o), "activatedResponders", []), Ba(Na(o), "eventDetectType", "point"), Ba(Na(o), "tooltipSectorMap", void 0), Ba(Na(o), "theme", void 0), Ba(Na(o), "circularAxis", void 0), Ba(Na(o), "onMouseoutComponent", function() {
                  o.eventBus.emit("seriesPointHovered", {
                    models: [],
                    name: o.name
                  }), o.eventBus.emit("renderHoveredSeries", {
                    models: [],
                    name: o.name
                  }), o.eventBus.emit("needDraw");
                }), Ba(Na(o), "selectSeries", function(g) {
                  var b, C = g.index, R = g.seriesIndex, I = Me(C) && (o.eventDetectType === "grouped" || Me(R));
                  if (I) {
                    var W = o.eventDetectType === "grouped" ? [].concat(bc(o.getGroupedSector([o.responders[C]], "select")), bc(o.getRadialBarSectorModelsFromResponders([o.responders[C]]))) : (b = o.getResponderModelsWithTheme([o.tooltipSectorMap[C][R]], "select")) !== null && b !== void 0 ? b : [];
                    if (!W.length)
                      throw new Error(ve.SELECT_SERIES_API_INDEX_ERROR);
                    o.eventBus.emit("renderSelectedSeries", {
                      models: W,
                      name: o.name,
                      eventDetectType: o.eventDetectType
                    }), o.eventBus.emit("needDraw");
                  }
                }), Ba(Na(o), "showTooltip", function(g) {
                  var b = g.index, C = g.seriesIndex;
                  if (xf(g, o.eventDetectType, "radialBar")) {
                    var R = o.eventDetectType === "grouped" ? o.getGroupedSector([o.responders[b]], "hover") : o.getResponderModelsWithTheme([o.tooltipSectorMap[b][C]], "hover");
                    R.length && (o.eventBus.emit("renderHoveredSeries", {
                      models: R,
                      name: o.name,
                      eventDetectType: o.eventDetectType
                    }), o.activatedResponders = o.eventDetectType === "grouped" ? o.tooltipSectorMap[b] : R, o.eventBus.emit("seriesPointHovered", {
                      models: o.activatedResponders,
                      name: o.name
                    }), o.eventBus.emit("needDraw"));
                  }
                }), o;
              }
              return QF(a, [{
                key: "initUpdate",
                value: function(u) {
                  var h = this;
                  if (this.drawModels) {
                    var v = this.circularAxis.angle, g = v.start, b = v.total, C;
                    Object.keys(this.models).forEach(function(R) {
                      var I = h.models[R].findIndex(function(W) {
                        var Z = W.clockwise, ue = W.degree, ke = ue.start, Ee = ue.end;
                        return C = Z ? g + b * u : g - b * u, go(Z, ke, Ee, C);
                      });
                      h.syncEndAngle(I < 0 ? h.models[R].length : I, R), I !== -1 && (h.drawModels[R][I].degree.end = C);
                    });
                  }
                }
              }, {
                key: "syncEndAngle",
                value: function(u, h) {
                  if (!(u < 1))
                    for (var v = 0; v < u; v += 1) {
                      var g = this.models[h][v].degree.end;
                      this.drawModels[h][v].degree.end !== g && (this.drawModels[h][v].degree.end = g);
                    }
                }
              }, {
                key: "initialize",
                value: function() {
                  this.type = "series", this.name = "radialBar", this.eventBus.on("selectSeries", this.selectSeries), this.eventBus.on("showTooltip", this.showTooltip), this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "render",
                value: function(u) {
                  var h, v = this, g = u.layout, b = u.series, C = u.legend, R = u.options, I = u.theme, W = u.stackSeries, Z = u.scale, ue = u.radialAxes, ke = (h = u.categories) !== null && h !== void 0 ? h : [];
                  if (!b.radialBar || !W.radialBar)
                    throw new Error(ve.noDataError(this.name));
                  this.theme = I.series.radialBar, this.rect = g.plot, this.activeSeriesMap = Ea(C), this.selectable = this.getSelectableOption(R), this.setEventDetectType(R);
                  var Ee = ke.reduce(function(Lt, Wt) {
                    return Lt[Wt] || (Lt[Wt] = []), Lt;
                  }, {}), Le = b.radialBar.data;
                  this.circularAxis = ue.circularAxis;
                  var je = ue.verticalAxis, Ke = this.makeRenderOptions(je, Z.circularAxis, R == null ? void 0 : R.series), ut = this.makeSeriesModelData(Le, W.radialBar.stackData, Ke, Ee), bt = ut.categoryMap, mt = ut.seriesModels, Rt = this.makeTooltipData(mt, ke);
                  if (this.models = bt, this.drawModels || this.initDrawModels(bt), Ma(R, this.name).visible) {
                    var Dt = mt.reduce(function(Lt, Wt) {
                      return [].concat(bc(Lt), [Xn(Xn({}, Wt), {}, {
                        type: "sector",
                        theme: v.theme.dataLabels
                      })]);
                    }, []);
                    this.renderDataLabels(Dt);
                  }
                  this.tooltipSectorMap = this.makeTooltipSectorMap(mt, Rt), this.responders = this.makeResponders(je.radius.ranges, mt, Ke, ke, Rt);
                }
              }, {
                key: "initDrawModels",
                value: function(u) {
                  var h = this;
                  this.drawModels = {}, Object.keys(u).forEach(function(v) {
                    h.drawModels[v] = u[v].map(function(g) {
                      return Xn(Xn({}, g), {}, {
                        degree: Xn(Xn({}, g.degree), {}, {
                          end: g.degree.start
                        })
                      });
                    });
                  });
                }
              }, {
                key: "makeResponders",
                value: function(u, h, v, g, b) {
                  return this.eventDetectType === "grouped" ? LE(u, v, g) : h.map(function(C, R) {
                    return Xn(Xn({}, C), {}, {
                      data: Xn({}, b[R])
                    });
                  });
                }
              }, {
                key: "makeTooltipSectorMap",
                value: function(u, h) {
                  return u.reduce(function(v, g, b) {
                    var C = g.index;
                    return v[C] || (v[C] = []), v[C].push(Xn(Xn({}, g), {}, {
                      data: Xn({}, h[b])
                    })), v;
                  }, {});
                }
              }, {
                key: "setEventDetectType",
                value: function(u) {
                  var h;
                  u != null && (h = u.series) !== null && h !== void 0 && h.eventDetectType && (this.eventDetectType = u.series.eventDetectType);
                }
              }, {
                key: "getBarWidth",
                value: function(u, h) {
                  var v = this.theme.barWidth, g = 5;
                  return v ? Math.min(u, be(h, v)) : u - g * 2;
                }
              }, {
                key: "makeRenderOptions",
                value: function(u, h, v) {
                  var g, b = u.axisSize, C = u.centerX, R = u.centerY, I = u.tickDistance, W = u.radius.ranges, Z = u.angle, ue = Z.start, ke = Z.end, Ee = h.limit.max, Le = h.stepSize, je = (g = v == null ? void 0 : v.clockwise) !== null && g !== void 0 ? g : !0, Ke = Pe(je, ue, ke), ut = this.getBarWidth(I, b), bt = (I - ut) / 2, mt = Ee + (Ke < Dr ? gn : Le);
                  return {
                    clockwise: je,
                    centerX: C,
                    centerY: R,
                    radiusRanges: ws(W, bt),
                    angleRange: {
                      start: ue,
                      end: ke
                    },
                    totalAngle: Ke,
                    scaleMaxLimitValue: mt,
                    startAngle: ue
                  };
                }
              }, {
                key: "makeSeriesModelData",
                value: function(u, h, v, g) {
                  var b = this, C = v.clockwise, R = v.centerX, I = v.centerY, W = v.radiusRanges, Z = v.totalAngle, ue = v.scaleMaxLimitValue, ke = v.startAngle, Ee = ke, Le = this.theme, je = Le.lineWidth, Ke = Le.strokeStyle, ut = [], bt = Object.keys(g), mt = wt(g);
                  return h.forEach(function(Rt, Dt) {
                    var Lt = Rt.values, Wt = W[Dt], Qt = Wt.inner, or = Wt.outer;
                    Lt.forEach(function(lr, xr) {
                      if (!Oe(lr)) {
                        var br = Math.max(lr / ue * Z, 1) * (C ? 1 : -1), yr = ut[ut.length - 1], Ar = xr && yr ? yr.degree.end : Ee, qr = C ? Math.min(Ar + br, Dr) : Math.max(Ar + br, gn), nn = u[xr], tn = nn.name, bn = nn.color, Tn = b.getSeriesColor(tn, bn), un = {
                          type: "sector",
                          name: tn,
                          color: Tn,
                          x: R,
                          y: I,
                          degree: {
                            start: Ar,
                            end: qr
                          },
                          radius: {
                            inner: Qt,
                            outer: or
                          },
                          value: lr,
                          style: [{
                            strokeStyle: Ke
                          }],
                          lineWidth: je,
                          clockwise: C,
                          totalAngle: Z,
                          seriesColor: bn,
                          seriesIndex: xr,
                          index: Dt,
                          drawingStartAngle: ti
                        };
                        mt[bt[Dt]].push(un), ut.push(un);
                      }
                    });
                  }), {
                    seriesModels: ut,
                    categoryMap: mt
                  };
                }
              }, {
                key: "getSeriesColor",
                value: function(u, h) {
                  var v = this.theme, g = v.select, b = v.areaOpacity, C = this.activeSeriesMap[u], R = Object.values(this.activeSeriesMap).some(function(I) {
                    return !I;
                  });
                  return R ? cr(h, C ? g.areaOpacity : g.restSeries.areaOpacity) : cr(h, b);
                }
              }, {
                key: "makeTooltipData",
                value: function(u, h) {
                  var v = [];
                  return u.forEach(function(g) {
                    var b = g.seriesColor, C = g.name, R = g.value, I = g.index;
                    Oe(R) || v.push({
                      label: C,
                      color: b,
                      value: R,
                      category: Me(I) ? h[I] : ""
                    });
                  }), v;
                }
              }, {
                key: "makeTooltipResponder",
                value: function(u) {
                  var h = this, v = Object.keys(this.models);
                  return u.map(function(g) {
                    return Xn(Xn({}, g), ka(xa("center", h.models[v[g.index]].find(function(b) {
                      var C = b.name;
                      return C === g.name;
                    }))));
                  });
                }
              }, {
                key: "getRadialBarSectorModelsFromResponders",
                value: function(u) {
                  var h;
                  return u.length ? (h = this.tooltipSectorMap[u[0].index]) !== null && h !== void 0 ? h : [] : [];
                }
              }, {
                key: "getGroupedSector",
                value: function(u, h) {
                  var v = this.getRadialBarSectorModelsFromResponders(u), g = this.theme[h].groupedSector, b = g.color, C = g.opacity;
                  return v.length ? u.map(function(R) {
                    return Xn(Xn({}, R), {}, {
                      color: cr(b, C)
                    });
                  }) : [];
                }
              }, {
                key: "onMousemoveGroupedType",
                value: function(u) {
                  var h = this.getRadialBarSectorModelsFromResponders(u);
                  this.eventBus.emit("renderHoveredSeries", {
                    models: this.getGroupedSector(u, "hover"),
                    name: this.name,
                    eventDetectType: this.eventDetectType
                  }), this.activatedResponders = h;
                }
              }, {
                key: "onMousemove",
                value: function(u) {
                  var h = u.responders;
                  this.eventDetectType === "grouped" ? this.onMousemoveGroupedType(h) : (this.eventBus.emit("renderHoveredSeries", {
                    models: this.getResponderModelsWithTheme(h, "hover"),
                    name: this.name
                  }), this.activatedResponders = this.makeTooltipResponder(h)), this.eventBus.emit("seriesPointHovered", {
                    models: this.activatedResponders,
                    name: this.name,
                    eventDetectType: this.eventDetectType
                  }), this.eventBus.emit("needDraw");
                }
              }, {
                key: "onClick",
                value: function(u) {
                  var h = u.responders;
                  if (this.selectable) {
                    var v;
                    this.eventDetectType === "grouped" ? v = [].concat(bc(this.getGroupedSector(h, "select")), bc(this.getRadialBarSectorModelsFromResponders(h))) : v = this.getResponderModelsWithTheme(h, "select"), this.eventBus.emit("renderSelectedSeries", {
                      models: v,
                      name: this.name,
                      eventDetectType: this.eventDetectType
                    }), this.eventBus.emit("needDraw");
                  }
                }
              }, {
                key: "getResponderModelsWithTheme",
                value: function(u, h) {
                  var v = this.theme[h], g = v.lineWidth, b = this.theme.lineWidth === g, C = b ? 0 : g * 0.5;
                  return u.map(function(R) {
                    var I;
                    return Xn(Xn({}, R), {}, {
                      color: (I = v == null ? void 0 : v.color) !== null && I !== void 0 ? I : R.color,
                      lineWidth: g,
                      style: [Ue(v, "strokeStyle", "shadowBlur", "shadowColor", "shadowOffsetX", "shadowOffsetY")],
                      radius: {
                        inner: Math.max(R.radius.inner - C, 0),
                        outer: R.radius.outer + C
                      }
                    });
                  });
                }
              }]), a;
            }(Lr);
            function Nh(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Nh = function(a) {
                return typeof a;
              } : Nh = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Nh(t);
            }
            function cw(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function fw(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? cw(Object(a), !0).forEach(function(o) {
                  az(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : cw(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function az(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function oz(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function sz(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function lz(t, n, a) {
              return n && sz(t.prototype, n), t;
            }
            function Bh(t, n, a) {
              return typeof Reflect < "u" && Reflect.get ? Bh = Reflect.get : Bh = function(u, h, v) {
                var g = uz(u, h);
                if (g) {
                  var b = Object.getOwnPropertyDescriptor(g, h);
                  return b.get ? b.get.call(v) : b.value;
                }
              }, Bh(t, n, a || t);
            }
            function uz(t, n) {
              for (; !Object.prototype.hasOwnProperty.call(t, n) && (t = vu(t), t !== null); )
                ;
              return t;
            }
            function cz(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && xg(t, n);
            }
            function xg(t, n) {
              return xg = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, xg(t, n);
            }
            function fz(t) {
              var n = pz();
              return function() {
                var o = vu(t), u;
                if (n) {
                  var h = vu(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return dz(this, u);
              };
            }
            function dz(t, n) {
              return n && (Nh(n) === "object" || typeof n == "function") ? n : hz(t);
            }
            function hz(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function pz() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function vu(t) {
              return vu = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, vu(t);
            }
            var vz = /* @__PURE__ */ function(t) {
              cz(a, t);
              var n = fz(a);
              function a(o) {
                var u = o.el, h = o.options, v = o.data;
                return oz(this, a), n.call(this, {
                  el: u,
                  options: h,
                  series: {
                    radialBar: v.series
                  },
                  categories: v.categories,
                  modules: [Hl, Vi, Gi, ia]
                });
              }
              return lz(a, [{
                key: "initialize",
                value: function() {
                  Bh(vu(a.prototype), "initialize", this).call(this), this.componentManager.add(Yn), this.componentManager.add(Un), this.componentManager.add(Oi), this.componentManager.add(ag), this.componentManager.add(iz), this.componentManager.add(Vn), this.componentManager.add(Gn), this.componentManager.add(Yi), this.componentManager.add(lg), this.componentManager.add(Hn, {
                    chartEl: this.el
                  }), this.componentManager.add($n, {
                    chartEl: this.el
                  }), this.componentManager.add(qn), this.painter.addGroups([p, w, f, O, L, m, d]);
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<number>} data.data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: [10, 20, 30, 40],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function(u) {
                  this.resetSeries(), this.store.dispatch("addSeries", {
                    data: u
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set.
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['1', '2', '3'],
                 *   series: [
                 *     {
                 *       name: 'new series',
                 *       data: [1, 2, 3],
                 *     },
                 *     {
                 *       name: 'new series2',
                 *       data: [4, 5, 6],
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function(u) {
                  var h = u.categories, v = u.series;
                  this.resetSeries(), this.store.dispatch("setData", {
                    series: {
                      radialBar: v
                    },
                    categories: h
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !1
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !0
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 500,
                 *     title: 'Olympic Medals',
                 *   },
                 *   series: {
                 *     selectable: true
                 *   }
                 * });
                 */
              }, {
                key: "setOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("initOptions", u);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     title: 'Olympic Medals',
                 *   },
                 *   series: {
                 *     eventDetectType: 'grouped'
                 *   }
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("updateOptions", u);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.index - Index of data within series. If 'series.eventDetectType' is "grouped", only index is needed.
                 *      @param {number} [seriesInfo.seriesIndex] - Index of series
                 * @api
                 * @example
                 * // eventDetectType is 'grouped'
                 * chart.showTooltip({index: 1});
                 *
                 * // eventDetectType is 'point'
                 * chart.showTooltip({index: 1, seriesIndex: 2});
                 */
              }, {
                key: "showTooltip",
                value: function(u) {
                  this.eventBus.emit("showTooltip", fw(fw({}, u), {}, {
                    state: this.store.state
                  }));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function() {
                  this.eventBus.emit("hideTooltip");
                }
              }]), a;
            }(Wn);
            function mz(t) {
              return Sz(t) || bz(t) || yz(t) || gz();
            }
            function gz() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function yz(t, n) {
              if (t) {
                if (typeof t == "string") return kg(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return kg(t, n);
              }
            }
            function bz(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function Sz(t) {
              if (Array.isArray(t)) return kg(t);
            }
            function kg(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function dw(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function Fh(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? dw(Object(a), !0).forEach(function(o) {
                  wz(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : dw(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function wz(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var xz = 15, Og = 10, hw = 10, pw = 30;
            function kz(t, n, a) {
              var o = a ?? !1, u = be(t, n), h = {
                visible: !0,
                radiusRange: {
                  inner: t - u,
                  outer: t
                },
                barWidth: u,
                clockHand: !1
              };
              return o ? ot(o) ? Fh(Fh({}, h), o) : h : Fh(Fh({}, h), {}, {
                visible: !1
              });
            }
            function Oz(t) {
              var n, a, o = t.labels, u = t.intervalData, h = t.circularAxisLabelMargin, v = t.circularAxisLabelFont, g = t.defaultAxisData, b = t.bandWidth, C = t.options, R = t.solidBarWidth, I = Yo(o, h, v), W = I.maxLabelWidth, Z = I.maxLabelHeight, ue = g.totalAngle, ke = g.axisSize, Ee = g.centerX, Le = g.centerY, je = g.startAngle, Ke = g.endAngle, ut = g.drawingStartAngle, bt = g.clockwise, mt = u.tickInterval, Rt = u.labelInterval, Dt = ke - b - Og, Lt = R ?? Dt * 0.1, Wt = kz(Dt - h - Z - (h - 5), Lt, C == null || (n = C.series) === null || n === void 0 ? void 0 : n.solid), Qt = ue / (o.length + (ue < Dr ? -1 : gn)), or = Dt - h - Z - hw + (Wt.visible ? -Wt.barWidth - hw : 0);
              return {
                axisSize: ke,
                centerX: Ee,
                centerY: Le,
                label: {
                  labels: o,
                  interval: Rt,
                  margin: h,
                  maxWidth: W,
                  maxHeight: Z
                },
                radius: {
                  inner: 0,
                  outer: Dt
                },
                angle: {
                  start: je,
                  end: Ke,
                  total: ue,
                  central: Qt,
                  drawingStart: ut
                },
                band: {
                  width: b,
                  margin: Og
                },
                tickInterval: mt,
                clockwise: bt,
                maxClockHandSize: or,
                title: Yp(C == null || (a = C.circularAxis) === null || a === void 0 ? void 0 : a.title),
                solidData: Wt
              };
            }
            function vw(t, n, a) {
              var o, u, h, v = (o = (u = t[a]) === null || u === void 0 || (h = u.label) === null || h === void 0 ? void 0 : h.formatter) !== null && o !== void 0 ? o : function(g) {
                return g;
              };
              return n.map(function(g, b) {
                return v(g, {
                  index: b,
                  labels: n,
                  axisName: a
                });
              });
            }
            function Cz(t, n, a, o) {
              var u = t ? Or.CIRCULAR : Or.VERTICAL, h = o[u], v = h.limit, g = h.stepSize, b = vw(n, yo(v, g), u), C = vw(n, a, t ? Or.VERTICAL : Or.CIRCULAR);
              return t ? b : C;
            }
            function Tz(t) {
              var n, a, o;
              return (n = t == null || (a = t.circularAxis) === null || a === void 0 || (o = a.label) === null || o === void 0 ? void 0 : o.margin) !== null && n !== void 0 ? n : xz;
            }
            function Az(t, n) {
              var a, o, u = t == null || (a = t.label) === null || a === void 0 ? void 0 : a.maxWidth, h = t == null || (o = t.label) === null || o === void 0 ? void 0 : o.maxHeight, v = n.label.maxWidth, g = n.label.maxHeight;
              return h !== g || u !== v;
            }
            var Ez = {
              name: "gaugeAxes",
              state: function() {
                return {
                  radialAxes: {
                    circularAxis: {}
                  }
                };
              },
              action: {
                setCircularAxisData: function(n) {
                  var a, o, u, h, v, g, b, C, R, I, W, Z = n.state, ue = Z.series, ke = Z.layout, Ee = Z.scale, Le = Z.categories, je = ke.plot, Ke = sa({
                    series: ue,
                    categories: Le
                  }), ut = Z.options, bt = Z.theme, mt = an(bt.circularAxis.label), Rt = Tz(ut), Dt = Cz(Ke, ut, Le, Ee), Lt = Yo(Dt, Rt, mt), Wt = Lt.maxLabelWidth, Qt = Lt.maxLabelHeight, or = my(ut, je, Wt, Qt, Ke), lr = Dl(an(bt.series.gauge.dataLabels)), xr = (a = ut == null || (o = ut.series) === null || o === void 0 || (u = o.dataLabels) === null || u === void 0 ? void 0 : u.offsetY) !== null && a !== void 0 ? a : pw;
                  if (or.isSemiCircular) {
                    or.centerY = or.centerY - (xr > 0 ? xr + lr : 0);
                    var br = or.centerY - or.axisSize;
                    or.axisSize += br < 0 ? br : 0;
                  }
                  var yr = ut != null && (h = ut.plot) !== null && h !== void 0 && (v = h.bands) !== null && v !== void 0 && v.length ? or.axisSize / 2 - Og : 0, Ar = (g = (b = bt.plot) === null || b === void 0 || (C = b.bands) === null || C === void 0 ? void 0 : C.barWidth) !== null && g !== void 0 ? g : yr, qr = Oz({
                    labels: Dt,
                    intervalData: hf(!0, {
                      axis: ut.circularAxis,
                      categories: Le,
                      layout: ke
                    }),
                    defaultAxisData: or,
                    circularAxisLabelMargin: Rt,
                    circularAxisLabelFont: mt,
                    bandWidth: Ar,
                    options: ut,
                    solidBarWidth: (R = bt.series.gauge) === null || R === void 0 || (I = R.solid) === null || I === void 0 ? void 0 : I.barWidth
                  });
                  Az((W = Z.radialAxes) === null || W === void 0 ? void 0 : W.circularAxis, qr) && this.notify(Z, "layout"), Z.radialAxes = {
                    circularAxis: qr
                  };
                },
                addGaugePlotBand: function(n, a) {
                  var o, u, h, v = n.state, g = a.data, b = (o = (u = v.options) === null || u === void 0 || (h = u.plot) === null || h === void 0 ? void 0 : h.bands) !== null && o !== void 0 ? o : [];
                  Mv(b, g) || this.dispatch("updateOptions", {
                    options: {
                      plot: {
                        bands: [].concat(mz(b), [g])
                      }
                    }
                  });
                },
                removeGaugePlotBand: function(n, a) {
                  var o, u, h, v = n.state, g = a.id, b = ((o = (u = v.options) === null || u === void 0 || (h = u.plot) === null || h === void 0 ? void 0 : h.bands) !== null && o !== void 0 ? o : []).filter(function(C) {
                    var R = C.id;
                    return R !== g;
                  });
                  this.dispatch("updateOptions", {
                    options: {
                      plot: {
                        bands: b
                      }
                    }
                  });
                }
              },
              observe: {
                updateRadialAxes: function() {
                  this.dispatch("setCircularAxisData");
                }
              }
            }, Mz = Ez;
            function zh(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? zh = function(a) {
                return typeof a;
              } : zh = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, zh(t);
            }
            function Hh(t) {
              return Lz(t) || Pz(t) || Dz(t) || Rz();
            }
            function Rz() {
              throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
            }
            function Dz(t, n) {
              if (t) {
                if (typeof t == "string") return Cg(t, n);
                var a = Object.prototype.toString.call(t).slice(8, -1);
                if (a === "Object" && t.constructor && (a = t.constructor.name), a === "Map" || a === "Set") return Array.from(t);
                if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return Cg(t, n);
              }
            }
            function Pz(t) {
              if (typeof Symbol < "u" && t[Symbol.iterator] != null || t["@@iterator"] != null) return Array.from(t);
            }
            function Lz(t) {
              if (Array.isArray(t)) return Cg(t);
            }
            function Cg(t, n) {
              (n == null || n > t.length) && (n = t.length);
              for (var a = 0, o = new Array(n); a < n; a++)
                o[a] = t[a];
              return o;
            }
            function mw(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function kn(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? mw(Object(a), !0).forEach(function(o) {
                  oo(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : mw(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function Iz(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function _z(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function Nz(t, n, a) {
              return n && _z(t.prototype, n), t;
            }
            function Bz(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Tg(t, n);
            }
            function Tg(t, n) {
              return Tg = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Tg(t, n);
            }
            function Fz(t) {
              var n = Hz();
              return function() {
                var o = jh(t), u;
                if (n) {
                  var h = jh(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return zz(this, u);
              };
            }
            function zz(t, n) {
              return n && (zh(n) === "object" || typeof n == "function") ? n : ao(t);
            }
            function ao(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function Hz() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function jh(t) {
              return jh = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, jh(t);
            }
            function oo(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var jz = 3, Wz = /* @__PURE__ */ function(t) {
              Bz(a, t);
              var n = Fz(a);
              function a() {
                var o;
                Iz(this, a);
                for (var u = arguments.length, h = new Array(u), v = 0; v < u; v++)
                  h[v] = arguments[v];
                return o = n.call.apply(n, [this].concat(h)), oo(ao(o), "models", {
                  clockHand: [],
                  solid: [],
                  backgroundSolid: []
                }), oo(ao(o), "drawModels", void 0), oo(ao(o), "responders", void 0), oo(ao(o), "activatedResponders", []), oo(ao(o), "tooltipMap", void 0), oo(ao(o), "theme", void 0), oo(ao(o), "circularAxis", void 0), oo(ao(o), "onMouseoutComponent", function() {
                  o.eventBus.emit("seriesPointHovered", {
                    models: [],
                    name: o.name
                  }), o.eventBus.emit("renderHoveredSeries", {
                    models: [],
                    name: o.name
                  }), o.eventBus.emit("needDraw");
                }), oo(ao(o), "selectSeries", function(g) {
                  var b, C = g.index;
                  if (Me(C)) {
                    var R = (b = o.tooltipMap.clockHand[C]) !== null && b !== void 0 ? b : o.tooltipMap.solid[C];
                    if (R) {
                      var I = o.getResponderModelsWithTheme(o.getResponderModels([R]), "select");
                      if (!I.length)
                        throw new Error(ve.SELECT_SERIES_API_INDEX_ERROR);
                      o.eventBus.emit("renderSelectedSeries", {
                        models: I,
                        name: o.name
                      }), o.eventBus.emit("needDraw");
                    }
                  }
                }), oo(ao(o), "showTooltip", function(g) {
                  var b = g.index, C = o.getResponderModelsWithTheme([o.tooltipMap.clockHand[b]], "hover");
                  C.length && (o.eventBus.emit("renderHoveredSeries", {
                    models: C,
                    name: o.name
                  }), o.activatedResponders = C, o.eventBus.emit("seriesPointHovered", {
                    models: o.activatedResponders,
                    name: o.name
                  }), o.eventBus.emit("needDraw"));
                }), o;
              }
              return Nz(a, [{
                key: "initialize",
                value: function() {
                  this.type = "series", this.name = "gauge", this.eventBus.on("selectSeries", this.selectSeries), this.eventBus.on("showTooltip", this.showTooltip), this.eventBus.on("hideTooltip", this.onMouseoutComponent);
                }
              }, {
                key: "initUpdate",
                value: function(u) {
                  var h = this;
                  if (this.drawModels) {
                    var v = this.circularAxis, g = v.angle, b = g.start, C = g.total, R = v.clockwise, I = R ? b + C * u : b - C * u;
                    this.models.clockHand.forEach(function(W, Z) {
                      var ue = W.x, ke = W.y, Ee = W.animationDegree, Le = W.handSize;
                      if (R && Ee < I || !R && Ee > I) {
                        h.syncEndAngle(Z);
                        return;
                      }
                      var je = hn(ue, ke, Le, Pr(zn(I))), Ke = je.x, ut = je.y;
                      h.drawModels.clockHand[Z].x2 = Ke, h.drawModels.clockHand[Z].y2 = ut;
                    }), this.models.solid.forEach(function() {
                      var W = h.models.solid.findIndex(function(Z) {
                        var ue = Z.animationDegree, ke = ue, Ee = ke.start, Le = ke.end;
                        return go(R, Ee, Le, I);
                      });
                      h.syncSectorEndAngle(W < 0 ? h.models.solid.length : W), W !== -1 && (h.drawModels.solid[W].degree.end = zn(I));
                    });
                  }
                }
              }, {
                key: "updateModels",
                value: function(u, h, v) {
                  var g = this.circularAxis.angle.total;
                  Object.keys(u).forEach(function(b) {
                    !u || !h || b[0] !== "_" && (Me(u[b]) ? u[b] = u[b] + (h[b] - u[b]) * v : b === "degree" ? g < Dr && u.degree.end < ri ? u[b].end = Dr + u[b].end - (Dr - h[b].end + u[b].end) * v : u[b].end = u[b].end + (h[b].end - u[b].end) * v : u[b] = h[b]);
                  });
                }
              }, {
                key: "update",
                value: function(u) {
                  var h = this;
                  this.models.clockHand.forEach(function(v, g) {
                    h.updateModels(h.drawModels.clockHand[g], v, u);
                  }), this.models.solid.forEach(function(v, g) {
                    h.updateModels(h.drawModels.solid[g], v, u);
                  });
                }
              }, {
                key: "syncEndAngle",
                value: function(u) {
                  var h = this.models.clockHand[u], v = this.drawModels.clockHand[u];
                  (h.x2 !== v.x2 || h.y2 !== v.y2) && (v.x2 = h.x2, v.y2 = h.y2);
                }
              }, {
                key: "syncSectorEndAngle",
                value: function(u) {
                  if (u)
                    for (var h = 0; h < u; h += 1) {
                      var v = this.models.solid[h].degree.end;
                      this.drawModels.solid[h].degree.end !== v && (this.drawModels.solid[h].degree.end = v);
                    }
                }
              }, {
                key: "render",
                value: function(u) {
                  var h, v = u.layout, g = u.series, b = u.legend, C = u.options, R = u.theme, I = u.scale, W = u.radialAxes, Z = (h = u.categories) !== null && h !== void 0 ? h : [];
                  if (!g.gauge)
                    throw new Error(ve.noDataError(this.name));
                  this.theme = R.series.gauge, this.rect = v.plot, this.circularAxis = W.circularAxis, this.activeSeriesMap = Ea(b), this.selectable = this.getSelectableOption(C);
                  var ue = g.gauge.data, ke = !sa({
                    series: g,
                    categories: Z
                  }), Ee = this.makeRenderOptions(ke, Z, I, C == null ? void 0 : C.series), Le = this.renderClockHands(ue, Ee);
                  this.models.clockHand = Ee.useClockHand ? Le : [];
                  var je = this.renderSolidModels(ue, Le, Ee), Ke = this.makeTooltipData(Le);
                  if (this.drawModels || this.initDrawModels(), Ma(C, this.name).visible) {
                    var ut = Le[0], bt = ut.value, mt = ut.name, Rt = ut.x, Dt = ut.y, Lt = ut.seriesData;
                    this.renderDataLabels([{
                      type: "point",
                      theme: this.theme.dataLabels,
                      value: bt,
                      name: mt,
                      x: Rt,
                      y: Dt + pw,
                      data: Lt
                    }]);
                  }
                  this.tooltipMap = this.makeTooltipMap(Ke, Ee), this.responders = this.getResponders(Le, je, Ke, Ee.useClockHand);
                }
              }, {
                key: "renderSolidModels",
                value: function(u, h, v) {
                  var g = [];
                  return this.models.clockHand = v.useClockHand ? h : [], v.solidData.visible && (g = this.renderSectors(u, v), this.models.backgroundSolid = this.renderBackgroundSolid(v), this.models.solid = g), g;
                }
              }, {
                key: "initDrawModels",
                value: function() {
                  var u = this.circularAxis.angle.start;
                  this.drawModels = {
                    clockHand: this.models.clockHand.map(function(h) {
                      var v = hn(h.x, h.y, h.handSize, Pr(u)), g = v.x, b = v.y;
                      return kn(kn({}, h), {}, {
                        x2: g,
                        y2: b,
                        testDegree: 0
                      });
                    }),
                    backgroundSolid: this.models.backgroundSolid,
                    solid: this.models.solid.map(function(h) {
                      return kn(kn({}, h), {}, {
                        degree: kn(kn({}, h.degree), {}, {
                          end: h.degree.start
                        })
                      });
                    })
                  };
                }
              }, {
                key: "getResponders",
                value: function(u, h, v) {
                  var g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0, b = g ? u.map(function(C, R) {
                    return kn(kn({}, C), {}, {
                      detectionSize: C.baseLine + jz,
                      data: kn({}, v[R])
                    });
                  }) : [];
                  return h.length ? [].concat(Hh(h.map(function(C, R) {
                    return kn(kn({}, C), {}, {
                      data: kn({}, v[R])
                    });
                  })), Hh(b)) : b;
                }
              }, {
                key: "getHandSize",
                value: function(u) {
                  var h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, v = this.circularAxis.maxClockHandSize;
                  return u ? Array.isArray(u) ? be(v, u[h]) : be(v, u) : v;
                }
              }, {
                key: "renderClockHands",
                value: function(u, h) {
                  var v = this, g = h.centerX, b = h.centerY, C = h.totalAngle, R = h.clockwise, I = h.scaleMaxLimitValue, W = h.categories, Z = h.drawingStartAngle, ue = [], ke = this.theme.clockHand, Ee = ke.size, Le = ke.baseLine, je = ke.color, Ke = this.theme.pin, ut = Ke.radius, bt = Ke.color, mt = Ke.borderWidth, Rt = Ke.borderColor;
                  return u.forEach(function(Dt, Lt) {
                    var Wt = Dt.name, Qt = Dt.data, or = Dt.color, lr = v.getSeriesColor(Wt, or);
                    Qt.forEach(function(xr, br) {
                      var yr = Ie(xr) ? W.findIndex(function(un) {
                        return un === xr;
                      }) : xr, Ar = Z + yr / I * C * (R ? 1 : -1), qr = zn(Ar), nn = v.getHandSize(Ee, br), tn = hn(g, b, nn, Pr(qr)), bn = tn.x, Tn = tn.y;
                      ue.push({
                        type: "clockHand",
                        color: je ?? lr,
                        name: Wt,
                        value: xr,
                        x: g,
                        y: b,
                        x2: bn,
                        y2: Tn,
                        pin: {
                          radius: ut,
                          color: bt ?? lr,
                          style: [{
                            strokeStyle: Rt ?? cr(lr, 0.1),
                            lineWidth: mt ? mt + ut : 0
                          }]
                        },
                        degree: qr,
                        animationDegree: Ar,
                        baseLine: Le,
                        handSize: nn,
                        seriesData: Qt,
                        index: br,
                        seriesIndex: Lt
                      });
                    });
                  }), ue;
                }
              }, {
                key: "renderBackgroundSolid",
                value: function(u) {
                  var h = u.centerX, v = u.centerY, g = u.startAngle, b = u.totalAngle, C = u.clockwise, R = u.solidData, I = this.theme.solid.backgroundSolid, W = I.color;
                  return [{
                    type: "sector",
                    color: W,
                    x: h,
                    y: v,
                    clockwise: C,
                    degree: {
                      start: g,
                      end: g + b
                    },
                    radius: R.radiusRange
                  }];
                }
              }, {
                key: "renderSectors",
                value: function(u, h) {
                  var v = this, g = [], b = h.centerX, C = h.centerY, R = h.clockwise, I = h.totalAngle, W = h.scaleMaxLimitValue, Z = h.startAngle, ue = h.categories, ke = h.solidData, Ee = ke.radiusRange, Le = this.theme.solid, je = Le.lineWidth, Ke = Le.strokeStyle;
                  return u.forEach(function(ut, bt) {
                    var mt = ut.name, Rt = ut.data, Dt = ut.color, Lt = v.getSeriesColor(mt, Dt), Wt = Rt[0], Qt = Ie(Wt) ? ue.findIndex(function(qr) {
                      return qr === Wt;
                    }) : Wt, or = Qt / W * I * (R ? 1 : -1), lr = zn(or), xr = Z, br = xr + or, yr = Z, Ar = yr + lr;
                    g.push({
                      type: "sector",
                      color: Lt,
                      x: b,
                      y: C,
                      clockwise: R,
                      degree: {
                        start: xr,
                        end: br
                      },
                      radius: Ee,
                      animationDegree: {
                        start: yr,
                        end: Ar
                      },
                      drawingStartAngle: ti,
                      style: [{
                        strokeStyle: Ke
                      }],
                      lineWidth: je,
                      index: bt
                    });
                  }), g;
                }
              }, {
                key: "makeTooltipMap",
                value: function(u, h) {
                  var v = this.models, g = v.clockHand, b = v.solid, C = h.useClockHand;
                  return u.reduce(function(R, I, W) {
                    return C && R.clockHand.push(kn(kn({}, g[W]), {}, {
                      detectionSize: g[W].baseLine + 3,
                      data: I
                    })), b[W] && R.solid.push(kn(kn({}, b[W]), {}, {
                      data: I
                    })), R;
                  }, {
                    solid: [],
                    clockHand: []
                  });
                }
              }, {
                key: "makeRenderOptions",
                value: function(u, h, v, g) {
                  var b, C = this.circularAxis, R = C.centerX, I = C.centerY, W = C.solidData, Z = C.angle, ue = Z.start, ke = Z.end, Ee = Z.drawingStart, Le = C.radius.outer, je = this.circularAxis.solidData, Ke = (b = g == null ? void 0 : g.clockwise) !== null && b !== void 0 ? b : !0, ut = Pe(Ke, ue, ke);
                  return {
                    clockwise: Ke,
                    centerX: R,
                    centerY: I,
                    angleRange: {
                      start: ue,
                      end: ke
                    },
                    totalAngle: ut,
                    scaleMaxLimitValue: u ? h.length : WS(v.circularAxis, ut),
                    startAngle: ue,
                    categories: h,
                    drawingStartAngle: Ee,
                    outerRadius: Le,
                    useClockHand: je.visible ? je.clockHand : !0,
                    solidData: W
                  };
                }
              }, {
                key: "getSeriesColor",
                value: function(u, h) {
                  var v = this.theme, g = v.select, b = v.areaOpacity, C = this.activeSeriesMap[u], R = Object.values(this.activeSeriesMap).some(function(I) {
                    return !I;
                  });
                  return R ? cr(h, C ? g.areaOpacity : g.restSeries.areaOpacity) : cr(h, b);
                }
              }, {
                key: "makeTooltipData",
                value: function(u) {
                  return u.reduce(function(h, v) {
                    var g = v.color, b = v.name, C = v.value, R = v.index, I = v.seriesIndex;
                    return Oe(C) ? h : [].concat(Hh(h), [{
                      label: b,
                      color: g,
                      value: C,
                      index: R,
                      seriesIndex: I
                    }]);
                  }, []);
                }
              }, {
                key: "onMousemove",
                value: function(u) {
                  var h = u.responders;
                  this.eventBus.emit("renderHoveredSeries", {
                    models: this.getResponderModelsWithTheme(this.getResponderModels(h), "hover"),
                    name: this.name
                  }), this.activatedResponders = h.map(function(v) {
                    return kn({}, v);
                  }), this.eventBus.emit("seriesPointHovered", {
                    models: this.activatedResponders,
                    name: this.name
                  }), this.eventBus.emit("needDraw");
                }
              }, {
                key: "getResponderModels",
                value: function(u) {
                  var h = this.tooltipMap, v = h.clockHand, g = h.solid;
                  return u.reduce(function(b, C) {
                    var R = C.index, I = v[R] ? [v[R]] : [], W = g[R] ? [g[R]] : [];
                    return [].concat(Hh(b), I, W);
                  }, []);
                }
              }, {
                key: "onClick",
                value: function(u) {
                  var h = u.responders;
                  if (this.selectable) {
                    var v = this.getResponderModelsWithTheme(this.getResponderModels(h), "select");
                    this.eventBus.emit("renderSelectedSeries", {
                      models: v,
                      name: this.name
                    }), this.eventBus.emit("needDraw");
                  }
                }
              }, {
                key: "getResponderModelsWithSolidTheme",
                value: function(u, h) {
                  var v, g = this.theme[h].solid, b = g.lineWidth, C = this.theme.solid === b, R = C ? 0 : b * 0.5;
                  return kn(kn({}, u), {}, {
                    color: (v = g.color) !== null && v !== void 0 ? v : u.color,
                    lineWidth: b,
                    style: [Ue(g, "strokeStyle", "shadowBlur", "shadowColor", "shadowOffsetX", "shadowOffsetY")],
                    radius: {
                      inner: Math.max(u.radius.inner - R, 0),
                      outer: u.radius.outer + R
                    }
                  });
                }
              }, {
                key: "getResponderWithClockHandTheme",
                value: function(u, h) {
                  var v = this.theme[h], g = v.clockHand, b = v.pin, C = g, R = C.size, I = C.baseLine, W = C.color, Z = b, ue = Z.radius, ke = Z.color, Ee = Z.borderWidth, Le = Z.borderColor, je = ue ?? u.pin.radius, Ke = [{
                    strokeStyle: Le ?? cr(u.pin.style[0].strokeStyle, 0.3),
                    lineWidth: Ee ? Ee + je : 0
                  }];
                  return kn(kn({}, u), {}, {
                    color: W ?? u.color,
                    pin: {
                      radius: je,
                      color: ke ?? u.pin.color,
                      style: Ke
                    },
                    baseLine: I ?? u.baseLine,
                    handSize: R ? this.getHandSize(R, u.index) : u.handSize
                  });
                }
              }, {
                key: "getResponderModelsWithTheme",
                value: function(u, h) {
                  var v = this;
                  return u.map(function(g) {
                    return (g == null ? void 0 : g.type) === "sector" ? v.getResponderModelsWithSolidTheme(g, h) : v.getResponderWithClockHandTheme(g, h);
                  });
                }
              }]), a;
            }(Lr);
            function $z(t) {
              var n = t.x, a = t.y, o = t.x2, u = t.y2, h = t.degree, v = t.baseLine, g = v / 2, b, C;
              return n === o ? (b = {
                x: n - g,
                y: a
              }, C = {
                x: n + g,
                y: a
              }) : a === u ? (b = {
                x: n,
                y: a - g
              }, C = {
                x: n,
                y: a + g
              }) : (b = hn(n, a, g, Pr(zn(h + ri))), C = hn(n, a, g, Pr(zn(h - ri)))), [b, {
                x: o,
                y: u
              }, C];
            }
            function Uz(t, n) {
              var a = n.color, o = n.x, u = n.y, h = n.pin, v = h.color, g = h.radius, b = h.style;
              Rr(t, {
                x: o,
                y: u,
                radius: g,
                color: v,
                style: b
              }), cv(t, {
                color: a,
                lineWidth: 1,
                fillColor: a,
                points: $z(n)
              });
            }
            function Wh(t) {
              "@babel/helpers - typeof";
              return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Wh = function(a) {
                return typeof a;
              } : Wh = function(a) {
                return a && typeof Symbol == "function" && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a;
              }, Wh(t);
            }
            function gw(t, n) {
              var a = Object.keys(t);
              if (Object.getOwnPropertySymbols) {
                var o = Object.getOwnPropertySymbols(t);
                n && (o = o.filter(function(u) {
                  return Object.getOwnPropertyDescriptor(t, u).enumerable;
                })), a.push.apply(a, o);
              }
              return a;
            }
            function yw(t) {
              for (var n = 1; n < arguments.length; n++) {
                var a = arguments[n] != null ? arguments[n] : {};
                n % 2 ? gw(Object(a), !0).forEach(function(o) {
                  Vz(t, o, a[o]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(a)) : gw(Object(a)).forEach(function(o) {
                  Object.defineProperty(t, o, Object.getOwnPropertyDescriptor(a, o));
                });
              }
              return t;
            }
            function Vz(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            function Gz(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function Yz(t, n) {
              for (var a = 0; a < n.length; a++) {
                var o = n[a];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
              }
            }
            function qz(t, n, a) {
              return n && Yz(t.prototype, n), t;
            }
            function $h(t, n, a) {
              return typeof Reflect < "u" && Reflect.get ? $h = Reflect.get : $h = function(u, h, v) {
                var g = Kz(u, h);
                if (g) {
                  var b = Object.getOwnPropertyDescriptor(g, h);
                  return b.get ? b.get.call(v) : b.value;
                }
              }, $h(t, n, a || t);
            }
            function Kz(t, n) {
              for (; !Object.prototype.hasOwnProperty.call(t, n) && (t = mu(t), t !== null); )
                ;
              return t;
            }
            function Xz(t, n) {
              if (typeof n != "function" && n !== null)
                throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(n && n.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), n && Ag(t, n);
            }
            function Ag(t, n) {
              return Ag = Object.setPrototypeOf || function(o, u) {
                return o.__proto__ = u, o;
              }, Ag(t, n);
            }
            function Jz(t) {
              var n = eH();
              return function() {
                var o = mu(t), u;
                if (n) {
                  var h = mu(this).constructor;
                  u = Reflect.construct(o, arguments, h);
                } else
                  u = o.apply(this, arguments);
                return Zz(this, u);
              };
            }
            function Zz(t, n) {
              return n && (Wh(n) === "object" || typeof n == "function") ? n : Qz(t);
            }
            function Qz(t) {
              if (t === void 0)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return t;
            }
            function eH() {
              if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
              if (typeof Proxy == "function") return !0;
              try {
                return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
                })), !0;
              } catch {
                return !1;
              }
            }
            function mu(t) {
              return mu = Object.setPrototypeOf ? Object.getPrototypeOf : function(a) {
                return a.__proto__ || Object.getPrototypeOf(a);
              }, mu(t);
            }
            var tH = /* @__PURE__ */ function(t) {
              Xz(a, t);
              var n = Jz(a);
              function a(o) {
                var u = o.el, h = o.options, v = o.data;
                return Gz(this, a), n.call(this, {
                  el: u,
                  options: h,
                  series: {
                    gauge: v.series
                  },
                  categories: v.categories,
                  modules: [Vi, Gi, Mz]
                });
              }
              return qz(a, [{
                key: "initialize",
                value: function() {
                  $h(mu(a.prototype), "initialize", this).call(this), this.componentManager.add(Yn), this.componentManager.add(Un), this.componentManager.add(ag, {
                    name: "gauge"
                  }), this.componentManager.add(lg, {
                    name: "gauge"
                  }), this.componentManager.add(Yr, {
                    name: "circularAxis"
                  }), this.componentManager.add(Wz), this.componentManager.add(Vn), this.componentManager.add(Gn), this.componentManager.add(Yi), this.componentManager.add(Hn, {
                    chartEl: this.el
                  }), this.componentManager.add($n, {
                    chartEl: this.el
                  }), this.componentManager.add(qn), this.painter.addGroups([p, w, f, O, L, m, d, J]);
                }
                /**
                 * Add series.
                 * @param {Object} data - Data to be added.
                 *   @param {string} data.name - Series name.
                 *   @param {Array<number|Array<number>>} data.data - Array of data to be added.
                 * @api
                 * @example
                 * chart.addSeries({
                 *   name: 'newSeries',
                 *   data: [10, 20],
                 * });
                 */
              }, {
                key: "addSeries",
                value: function(u) {
                  this.resetSeries(), this.store.dispatch("addSeries", {
                    data: u
                  });
                }
                /**
                 * Add data.
                 * @param {Array} data - Array of data to be added.
                 * @param {string} [category] - Category to be added.
                 * @api
                 * @example
                 * // without categories
                 * chart.addData([10], '6');
                 *
                 * // with categories
                 * chart.addData([10], '6');
                 */
              }, {
                key: "addData",
                value: function(u, h) {
                  this.resetSeries(), this.animationControlFlag.updating = !0, this.store.dispatch("addData", {
                    data: u,
                    category: h
                  });
                }
                /**
                 * Convert the chart data to new data.
                 * @param {Object} data - Data to be set.
                 * @api
                 * @example
                 * chart.setData({
                 *   categories: ['1', '2', '3'],
                 *   series: [
                 *     {
                 *       name: 'new series',
                 *       data: [1, 2, 3],
                 *     },
                 *     {
                 *       name: 'new series2',
                 *       data: [4, 5, 6],
                 *     }
                 *   ]
                 * });
                 */
              }, {
                key: "setData",
                value: function(u) {
                  var h = u.categories, v = u.series;
                  this.resetSeries(), this.store.dispatch("setData", {
                    series: {
                      gauge: v
                    },
                    categories: h
                  });
                }
                /**
                 * Hide series data label.
                 * @api
                 * @example
                 * chart.hideSeriesDataLabel();
                 */
              }, {
                key: "hideSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !1
                        }
                      }
                    }
                  });
                }
                /**
                 * Show series data label.
                 * @api
                 * @example
                 * chart.showSeriesDataLabel();
                 */
              }, {
                key: "showSeriesDataLabel",
                value: function() {
                  this.store.dispatch("updateOptions", {
                    options: {
                      series: {
                        dataLabels: {
                          visible: !0
                        }
                      }
                    }
                  });
                }
                /**
                 * Convert the chart options to new options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.setOptions({
                 *   chart: {
                 *     width: 500,
                 *     height: 500,
                 *     title: 'Olympic Medals',
                 *   },
                 *   series: {
                 *     selectable: true
                 *   }
                 * });
                 */
              }, {
                key: "setOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("initOptions", u);
                }
                /**
                 * Update chart options.
                 * @param {Object} options - Chart options.
                 * @api
                 * @example
                 * chart.updateOptions({
                 *   chart: {
                 *     title: 'Olympic Medals',
                 *   }
                 * });
                 */
              }, {
                key: "updateOptions",
                value: function(u) {
                  this.resetSeries(), this.dispatchOptionsEvent("updateOptions", u);
                }
                /**
                 * Show tooltip.
                 * @param {Object} seriesInfo - Information of the series for the tooltip to be displayed.
                 *      @param {number} seriesInfo.index - Index of data within series.
                 * @api
                 * @example
                 * chart.showTooltip({index: 1});
                 */
              }, {
                key: "showTooltip",
                value: function(u) {
                  this.eventBus.emit("showTooltip", yw(yw({}, u), {}, {
                    state: this.store.state
                  }));
                }
                /**
                 * Hide tooltip.
                 * @api
                 * @example
                 * chart.hideTooltip();
                 */
              }, {
                key: "hideTooltip",
                value: function() {
                  this.eventBus.emit("hideTooltip");
                }
                /**
                 * Add plot band.
                 * @param {Object} data - Plot info.
                 *   @param {Array<string|number>} data.range - The range to be drawn.
                 *   @param {string} data.color - Plot band color.
                 *   @param {string} [data.id] - Plot id. The value on which the removePlotBand is based.
                 * @api
                 * @example
                 * chart.addPlotBand({
                 *   range: [10, 20],
                 *   color: '#00ff22',
                 *   id: 'plot-1',
                 * });
                 */
              }, {
                key: "addPlotBand",
                value: function(u) {
                  this.store.dispatch("addGaugePlotBand", {
                    data: u
                  });
                }
                /**
                 * Remove plot band with id.
                 * @param {string} id - id of the plot band to be removed
                 * @api
                 * @example
                 * chart.removePlotBand('plot-1');
                 */
              }, {
                key: "removePlotBand",
                value: function(u) {
                  this.store.dispatch("removeGaugePlotBand", {
                    id: u
                  });
                }
              }]), a;
            }(Wn);
            function rH(t, n) {
              if (!(t instanceof n))
                throw new TypeError("Cannot call a class as a function");
            }
            function Jn(t, n, a) {
              return n in t ? Object.defineProperty(t, n, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : t[n] = a, t;
            }
            var Pn = function t() {
              rH(this, t);
            };
            Jn(Pn, "lineChart", function(t) {
              return new OD(t);
            }), Jn(Pn, "areaChart", function(t) {
              return new ML(t);
            }), Jn(Pn, "barChart", function(t) {
              return new k_(t);
            }), Jn(Pn, "boxPlotChart", function(t) {
              return new GF(t);
            }), Jn(Pn, "columnChart", function(t) {
              return new __(t);
            }), Jn(Pn, "pieChart", function(t) {
              return new YD(t);
            }), Jn(Pn, "heatmapChart", function(t) {
              return new oL(t);
            }), Jn(Pn, "bubbleChart", function(t) {
              return new EN(t);
            }), Jn(Pn, "scatterChart", function(t) {
              return new VN(t);
            }), Jn(Pn, "bulletChart", function(t) {
              return new yB(t);
            }), Jn(Pn, "radarChart", function(t) {
              return new A2(t);
            }), Jn(Pn, "treemapChart", function(t) {
              return new gF(t);
            }), Jn(Pn, "nestedPieChart", function(t) {
              return new PB(t);
            }), Jn(Pn, "lineAreaChart", function(t) {
              return new uI(t);
            }), Jn(Pn, "lineScatterChart", function(t) {
              return new ZL(t);
            }), Jn(Pn, "columnLineChart", function(t) {
              return new Y_(t);
            }), Jn(Pn, "radialBarChart", function(t) {
              return new vz(t);
            }), Jn(Pn, "gaugeChart", function(t) {
              return new tH(t);
            });
          }(), c = c.default, c;
        }()
      );
    });
  }(Oj)), Oj.exports;
}
/*!
 * TOAST UI Editor : Chart Plugin
 * @version 3.0.1 | Wed Jul 07 2021
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
var lV;
function Z9e() {
  return lV || (lV = 1, function(i, e) {
    (function(s, l) {
      i.exports = l(/* @__PURE__ */ J9e());
    })(self, function(r) {
      return (
        /******/
        function() {
          var s = {
            /***/
            72: (
              /***/
              function(p, d) {
                d.byteLength = T, d.toByteArray = j, d.fromByteArray = ie;
                for (var m = [], y = [], S = typeof Uint8Array < "u" ? Uint8Array : Array, x = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", w = 0, k = x.length; w < k; ++w)
                  m[w] = x[w], y[x.charCodeAt(w)] = w;
                y[45] = 62, y[95] = 63;
                function O(K) {
                  var re = K.length;
                  if (re % 4 > 0)
                    throw new Error("Invalid string. Length must be a multiple of 4");
                  var ee = K.indexOf("=");
                  ee === -1 && (ee = re);
                  var de = ee === re ? 0 : 4 - ee % 4;
                  return [ee, de];
                }
                function T(K) {
                  var re = O(K), ee = re[0], de = re[1];
                  return (ee + de) * 3 / 4 - de;
                }
                function L(K, re, ee) {
                  return (re + ee) * 3 / 4 - ee;
                }
                function j(K) {
                  var re, ee = O(K), de = ee[0], Ce = ee[1], he = new S(L(K, de, Ce)), oe = 0, ge = Ce > 0 ? de - 4 : de, we;
                  for (we = 0; we < ge; we += 4)
                    re = y[K.charCodeAt(we)] << 18 | y[K.charCodeAt(we + 1)] << 12 | y[K.charCodeAt(we + 2)] << 6 | y[K.charCodeAt(we + 3)], he[oe++] = re >> 16 & 255, he[oe++] = re >> 8 & 255, he[oe++] = re & 255;
                  return Ce === 2 && (re = y[K.charCodeAt(we)] << 2 | y[K.charCodeAt(we + 1)] >> 4, he[oe++] = re & 255), Ce === 1 && (re = y[K.charCodeAt(we)] << 10 | y[K.charCodeAt(we + 1)] << 4 | y[K.charCodeAt(we + 2)] >> 2, he[oe++] = re >> 8 & 255, he[oe++] = re & 255), he;
                }
                function z(K) {
                  return m[K >> 18 & 63] + m[K >> 12 & 63] + m[K >> 6 & 63] + m[K & 63];
                }
                function J(K, re, ee) {
                  for (var de, Ce = [], he = re; he < ee; he += 3)
                    de = (K[he] << 16 & 16711680) + (K[he + 1] << 8 & 65280) + (K[he + 2] & 255), Ce.push(z(de));
                  return Ce.join("");
                }
                function ie(K) {
                  for (var re, ee = K.length, de = ee % 3, Ce = [], he = 16383, oe = 0, ge = ee - de; oe < ge; oe += he)
                    Ce.push(J(K, oe, oe + he > ge ? ge : oe + he));
                  return de === 1 ? (re = K[ee - 1], Ce.push(m[re >> 2] + m[re << 4 & 63] + "==")) : de === 2 && (re = (K[ee - 2] << 8) + K[ee - 1], Ce.push(m[re >> 10] + m[re >> 4 & 63] + m[re << 2 & 63] + "=")), Ce.join("");
                }
              }
            ),
            /***/
            636: (
              /***/
              function(p, d, m) {
                /*!
                 * The buffer module from node.js, for the browser.
                 *
                 * @author   Feross Aboukhadijeh <https://feross.org>
                 * @license  MIT
                 */
                var y = m(72), S = m(74), x = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
                d.Buffer = T, d.SlowBuffer = he, d.INSPECT_MAX_BYTES = 50;
                var w = 2147483647;
                d.kMaxLength = w, T.TYPED_ARRAY_SUPPORT = k(), !T.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
                function k() {
                  try {
                    var be = new Uint8Array(1), G = { foo: function() {
                      return 42;
                    } };
                    return Object.setPrototypeOf(G, Uint8Array.prototype), Object.setPrototypeOf(be, G), be.foo() === 42;
                  } catch {
                    return !1;
                  }
                }
                Object.defineProperty(T.prototype, "parent", {
                  enumerable: !0,
                  get: function() {
                    if (T.isBuffer(this))
                      return this.buffer;
                  }
                }), Object.defineProperty(T.prototype, "offset", {
                  enumerable: !0,
                  get: function() {
                    if (T.isBuffer(this))
                      return this.byteOffset;
                  }
                });
                function O(be) {
                  if (be > w)
                    throw new RangeError('The value "' + be + '" is invalid for option "size"');
                  var G = new Uint8Array(be);
                  return Object.setPrototypeOf(G, T.prototype), G;
                }
                function T(be, G, V) {
                  if (typeof be == "number") {
                    if (typeof G == "string")
                      throw new TypeError('The "string" argument must be of type string. Received type number');
                    return J(be);
                  }
                  return L(be, G, V);
                }
                T.poolSize = 8192;
                function L(be, G, V) {
                  if (typeof be == "string")
                    return ie(be, G);
                  if (ArrayBuffer.isView(be))
                    return re(be);
                  if (be == null)
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof be);
                  if (te(be, ArrayBuffer) || be && te(be.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (te(be, SharedArrayBuffer) || be && te(be.buffer, SharedArrayBuffer)))
                    return ee(be, G, V);
                  if (typeof be == "number")
                    throw new TypeError('The "value" argument must not be of type number. Received type number');
                  var ve = be.valueOf && be.valueOf();
                  if (ve != null && ve !== be)
                    return T.from(ve, G, V);
                  var Ne = de(be);
                  if (Ne)
                    return Ne;
                  if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof be[Symbol.toPrimitive] == "function")
                    return T.from(be[Symbol.toPrimitive]("string"), G, V);
                  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof be);
                }
                T.from = function(be, G, V) {
                  return L(be, G, V);
                }, Object.setPrototypeOf(T.prototype, Uint8Array.prototype), Object.setPrototypeOf(T, Uint8Array);
                function j(be) {
                  if (typeof be != "number")
                    throw new TypeError('"size" argument must be of type number');
                  if (be < 0)
                    throw new RangeError('The value "' + be + '" is invalid for option "size"');
                }
                function z(be, G, V) {
                  return j(be), be <= 0 ? O(be) : G !== void 0 ? typeof V == "string" ? O(be).fill(G, V) : O(be).fill(G) : O(be);
                }
                T.alloc = function(be, G, V) {
                  return z(be, G, V);
                };
                function J(be) {
                  return j(be), O(be < 0 ? 0 : Ce(be) | 0);
                }
                T.allocUnsafe = function(be) {
                  return J(be);
                }, T.allocUnsafeSlow = function(be) {
                  return J(be);
                };
                function ie(be, G) {
                  if ((typeof G != "string" || G === "") && (G = "utf8"), !T.isEncoding(G))
                    throw new TypeError("Unknown encoding: " + G);
                  var V = oe(be, G) | 0, ve = O(V), Ne = ve.write(be, G);
                  return Ne !== V && (ve = ve.slice(0, Ne)), ve;
                }
                function K(be) {
                  for (var G = be.length < 0 ? 0 : Ce(be.length) | 0, V = O(G), ve = 0; ve < G; ve += 1)
                    V[ve] = be[ve] & 255;
                  return V;
                }
                function re(be) {
                  if (te(be, Uint8Array)) {
                    var G = new Uint8Array(be);
                    return ee(G.buffer, G.byteOffset, G.byteLength);
                  }
                  return K(be);
                }
                function ee(be, G, V) {
                  if (G < 0 || be.byteLength < G)
                    throw new RangeError('"offset" is outside of buffer bounds');
                  if (be.byteLength < G + (V || 0))
                    throw new RangeError('"length" is outside of buffer bounds');
                  var ve;
                  return G === void 0 && V === void 0 ? ve = new Uint8Array(be) : V === void 0 ? ve = new Uint8Array(be, G) : ve = new Uint8Array(be, G, V), Object.setPrototypeOf(ve, T.prototype), ve;
                }
                function de(be) {
                  if (T.isBuffer(be)) {
                    var G = Ce(be.length) | 0, V = O(G);
                    return V.length === 0 || be.copy(V, 0, 0, G), V;
                  }
                  if (be.length !== void 0)
                    return typeof be.length != "number" || De(be.length) ? O(0) : K(be);
                  if (be.type === "Buffer" && Array.isArray(be.data))
                    return K(be.data);
                }
                function Ce(be) {
                  if (be >= w)
                    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + w.toString(16) + " bytes");
                  return be | 0;
                }
                function he(be) {
                  return +be != be && (be = 0), T.alloc(+be);
                }
                T.isBuffer = function(G) {
                  return G != null && G._isBuffer === !0 && G !== T.prototype;
                }, T.compare = function(G, V) {
                  if (te(G, Uint8Array) && (G = T.from(G, G.offset, G.byteLength)), te(V, Uint8Array) && (V = T.from(V, V.offset, V.byteLength)), !T.isBuffer(G) || !T.isBuffer(V))
                    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                  if (G === V)
                    return 0;
                  for (var ve = G.length, Ne = V.length, it = 0, yt = Math.min(ve, Ne); it < yt; ++it)
                    if (G[it] !== V[it]) {
                      ve = G[it], Ne = V[it];
                      break;
                    }
                  return ve < Ne ? -1 : Ne < ve ? 1 : 0;
                }, T.isEncoding = function(G) {
                  switch (String(G).toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return !0;
                    default:
                      return !1;
                  }
                }, T.concat = function(G, V) {
                  if (!Array.isArray(G))
                    throw new TypeError('"list" argument must be an Array of Buffers');
                  if (G.length === 0)
                    return T.alloc(0);
                  var ve;
                  if (V === void 0)
                    for (V = 0, ve = 0; ve < G.length; ++ve)
                      V += G[ve].length;
                  var Ne = T.allocUnsafe(V), it = 0;
                  for (ve = 0; ve < G.length; ++ve) {
                    var yt = G[ve];
                    if (te(yt, Uint8Array))
                      it + yt.length > Ne.length ? T.from(yt).copy(Ne, it) : Uint8Array.prototype.set.call(Ne, yt, it);
                    else if (T.isBuffer(yt))
                      yt.copy(Ne, it);
                    else
                      throw new TypeError('"list" argument must be an Array of Buffers');
                    it += yt.length;
                  }
                  return Ne;
                };
                function oe(be, G) {
                  if (T.isBuffer(be))
                    return be.length;
                  if (ArrayBuffer.isView(be) || te(be, ArrayBuffer))
                    return be.byteLength;
                  if (typeof be != "string")
                    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof be);
                  var V = be.length, ve = arguments.length > 2 && arguments[2] === !0;
                  if (!ve && V === 0)
                    return 0;
                  for (var Ne = !1; ; )
                    switch (G) {
                      case "ascii":
                      case "latin1":
                      case "binary":
                        return V;
                      case "utf8":
                      case "utf-8":
                        return pe(be).length;
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return V * 2;
                      case "hex":
                        return V >>> 1;
                      case "base64":
                        return lt(be).length;
                      default:
                        if (Ne)
                          return ve ? -1 : pe(be).length;
                        G = ("" + G).toLowerCase(), Ne = !0;
                    }
                }
                T.byteLength = oe;
                function ge(be, G, V) {
                  var ve = !1;
                  if ((G === void 0 || G < 0) && (G = 0), G > this.length || ((V === void 0 || V > this.length) && (V = this.length), V <= 0) || (V >>>= 0, G >>>= 0, V <= G))
                    return "";
                  for (be || (be = "utf8"); ; )
                    switch (be) {
                      case "hex":
                        return He(this, G, V);
                      case "utf8":
                      case "utf-8":
                        return At(this, G, V);
                      case "ascii":
                        return Ve(this, G, V);
                      case "latin1":
                      case "binary":
                        return Ue(this, G, V);
                      case "base64":
                        return gt(this, G, V);
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return We(this, G, V);
                      default:
                        if (ve)
                          throw new TypeError("Unknown encoding: " + be);
                        be = (be + "").toLowerCase(), ve = !0;
                    }
                }
                T.prototype._isBuffer = !0;
                function we(be, G, V) {
                  var ve = be[G];
                  be[G] = be[V], be[V] = ve;
                }
                T.prototype.swap16 = function() {
                  var G = this.length;
                  if (G % 2 !== 0)
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                  for (var V = 0; V < G; V += 2)
                    we(this, V, V + 1);
                  return this;
                }, T.prototype.swap32 = function() {
                  var G = this.length;
                  if (G % 4 !== 0)
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                  for (var V = 0; V < G; V += 4)
                    we(this, V, V + 3), we(this, V + 1, V + 2);
                  return this;
                }, T.prototype.swap64 = function() {
                  var G = this.length;
                  if (G % 8 !== 0)
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                  for (var V = 0; V < G; V += 8)
                    we(this, V, V + 7), we(this, V + 1, V + 6), we(this, V + 2, V + 5), we(this, V + 3, V + 4);
                  return this;
                }, T.prototype.toString = function() {
                  var G = this.length;
                  return G === 0 ? "" : arguments.length === 0 ? At(this, 0, G) : ge.apply(this, arguments);
                }, T.prototype.toLocaleString = T.prototype.toString, T.prototype.equals = function(G) {
                  if (!T.isBuffer(G))
                    throw new TypeError("Argument must be a Buffer");
                  return this === G ? !0 : T.compare(this, G) === 0;
                }, T.prototype.inspect = function() {
                  var G = "", V = d.INSPECT_MAX_BYTES;
                  return G = this.toString("hex", 0, V).replace(/(.{2})/g, "$1 ").trim(), this.length > V && (G += " ... "), "<Buffer " + G + ">";
                }, x && (T.prototype[x] = T.prototype.inspect), T.prototype.compare = function(G, V, ve, Ne, it) {
                  if (te(G, Uint8Array) && (G = T.from(G, G.offset, G.byteLength)), !T.isBuffer(G))
                    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof G);
                  if (V === void 0 && (V = 0), ve === void 0 && (ve = G ? G.length : 0), Ne === void 0 && (Ne = 0), it === void 0 && (it = this.length), V < 0 || ve > G.length || Ne < 0 || it > this.length)
                    throw new RangeError("out of range index");
                  if (Ne >= it && V >= ve)
                    return 0;
                  if (Ne >= it)
                    return -1;
                  if (V >= ve)
                    return 1;
                  if (V >>>= 0, ve >>>= 0, Ne >>>= 0, it >>>= 0, this === G)
                    return 0;
                  for (var yt = it - Ne, $t = ve - V, Gt = Math.min(yt, $t), Jt = this.slice(Ne, it), Xt = G.slice(V, ve), Ae = 0; Ae < Gt; ++Ae)
                    if (Jt[Ae] !== Xt[Ae]) {
                      yt = Jt[Ae], $t = Xt[Ae];
                      break;
                    }
                  return yt < $t ? -1 : $t < yt ? 1 : 0;
                };
                function Oe(be, G, V, ve, Ne) {
                  if (be.length === 0)
                    return -1;
                  if (typeof V == "string" ? (ve = V, V = 0) : V > 2147483647 ? V = 2147483647 : V < -2147483648 && (V = -2147483648), V = +V, De(V) && (V = Ne ? 0 : be.length - 1), V < 0 && (V = be.length + V), V >= be.length) {
                    if (Ne)
                      return -1;
                    V = be.length - 1;
                  } else if (V < 0)
                    if (Ne)
                      V = 0;
                    else
                      return -1;
                  if (typeof G == "string" && (G = T.from(G, ve)), T.isBuffer(G))
                    return G.length === 0 ? -1 : Qe(be, G, V, ve, Ne);
                  if (typeof G == "number")
                    return G = G & 255, typeof Uint8Array.prototype.indexOf == "function" ? Ne ? Uint8Array.prototype.indexOf.call(be, G, V) : Uint8Array.prototype.lastIndexOf.call(be, G, V) : Qe(be, [G], V, ve, Ne);
                  throw new TypeError("val must be string, number or Buffer");
                }
                function Qe(be, G, V, ve, Ne) {
                  var it = 1, yt = be.length, $t = G.length;
                  if (ve !== void 0 && (ve = String(ve).toLowerCase(), ve === "ucs2" || ve === "ucs-2" || ve === "utf16le" || ve === "utf-16le")) {
                    if (be.length < 2 || G.length < 2)
                      return -1;
                    it = 2, yt /= 2, $t /= 2, V /= 2;
                  }
                  function Gt(Ot, Vt) {
                    return it === 1 ? Ot[Vt] : Ot.readUInt16BE(Vt * it);
                  }
                  var Jt;
                  if (Ne) {
                    var Xt = -1;
                    for (Jt = V; Jt < yt; Jt++)
                      if (Gt(be, Jt) === Gt(G, Xt === -1 ? 0 : Jt - Xt)) {
                        if (Xt === -1 && (Xt = Jt), Jt - Xt + 1 === $t)
                          return Xt * it;
                      } else
                        Xt !== -1 && (Jt -= Jt - Xt), Xt = -1;
                  } else
                    for (V + $t > yt && (V = yt - $t), Jt = V; Jt >= 0; Jt--) {
                      for (var Ae = !0, vt = 0; vt < $t; vt++)
                        if (Gt(be, Jt + vt) !== Gt(G, vt)) {
                          Ae = !1;
                          break;
                        }
                      if (Ae)
                        return Jt;
                    }
                  return -1;
                }
                T.prototype.includes = function(G, V, ve) {
                  return this.indexOf(G, V, ve) !== -1;
                }, T.prototype.indexOf = function(G, V, ve) {
                  return Oe(this, G, V, ve, !0);
                }, T.prototype.lastIndexOf = function(G, V, ve) {
                  return Oe(this, G, V, ve, !1);
                };
                function Me(be, G, V, ve) {
                  V = Number(V) || 0;
                  var Ne = be.length - V;
                  ve ? (ve = Number(ve), ve > Ne && (ve = Ne)) : ve = Ne;
                  var it = G.length;
                  ve > it / 2 && (ve = it / 2);
                  for (var yt = 0; yt < ve; ++yt) {
                    var $t = parseInt(G.substr(yt * 2, 2), 16);
                    if (De($t))
                      return yt;
                    be[V + yt] = $t;
                  }
                  return yt;
                }
                function Ie(be, G, V, ve) {
                  return Q(pe(G, be.length - V), be, V, ve);
                }
                function rt(be, G, V, ve) {
                  return Q(_e(G), be, V, ve);
                }
                function ot(be, G, V, ve) {
                  return Q(lt(G), be, V, ve);
                }
                function Et(be, G, V, ve) {
                  return Q(Xe(G, be.length - V), be, V, ve);
                }
                T.prototype.write = function(G, V, ve, Ne) {
                  if (V === void 0)
                    Ne = "utf8", ve = this.length, V = 0;
                  else if (ve === void 0 && typeof V == "string")
                    Ne = V, ve = this.length, V = 0;
                  else if (isFinite(V))
                    V = V >>> 0, isFinite(ve) ? (ve = ve >>> 0, Ne === void 0 && (Ne = "utf8")) : (Ne = ve, ve = void 0);
                  else
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                  var it = this.length - V;
                  if ((ve === void 0 || ve > it) && (ve = it), G.length > 0 && (ve < 0 || V < 0) || V > this.length)
                    throw new RangeError("Attempt to write outside buffer bounds");
                  Ne || (Ne = "utf8");
                  for (var yt = !1; ; )
                    switch (Ne) {
                      case "hex":
                        return Me(this, G, V, ve);
                      case "utf8":
                      case "utf-8":
                        return Ie(this, G, V, ve);
                      case "ascii":
                      case "latin1":
                      case "binary":
                        return rt(this, G, V, ve);
                      case "base64":
                        return ot(this, G, V, ve);
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return Et(this, G, V, ve);
                      default:
                        if (yt)
                          throw new TypeError("Unknown encoding: " + Ne);
                        Ne = ("" + Ne).toLowerCase(), yt = !0;
                    }
                }, T.prototype.toJSON = function() {
                  return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                  };
                };
                function gt(be, G, V) {
                  return G === 0 && V === be.length ? y.fromByteArray(be) : y.fromByteArray(be.slice(G, V));
                }
                function At(be, G, V) {
                  V = Math.min(be.length, V);
                  for (var ve = [], Ne = G; Ne < V; ) {
                    var it = be[Ne], yt = null, $t = it > 239 ? 4 : it > 223 ? 3 : it > 191 ? 2 : 1;
                    if (Ne + $t <= V) {
                      var Gt, Jt, Xt, Ae;
                      switch ($t) {
                        case 1:
                          it < 128 && (yt = it);
                          break;
                        case 2:
                          Gt = be[Ne + 1], (Gt & 192) === 128 && (Ae = (it & 31) << 6 | Gt & 63, Ae > 127 && (yt = Ae));
                          break;
                        case 3:
                          Gt = be[Ne + 1], Jt = be[Ne + 2], (Gt & 192) === 128 && (Jt & 192) === 128 && (Ae = (it & 15) << 12 | (Gt & 63) << 6 | Jt & 63, Ae > 2047 && (Ae < 55296 || Ae > 57343) && (yt = Ae));
                          break;
                        case 4:
                          Gt = be[Ne + 1], Jt = be[Ne + 2], Xt = be[Ne + 3], (Gt & 192) === 128 && (Jt & 192) === 128 && (Xt & 192) === 128 && (Ae = (it & 15) << 18 | (Gt & 63) << 12 | (Jt & 63) << 6 | Xt & 63, Ae > 65535 && Ae < 1114112 && (yt = Ae));
                      }
                    }
                    yt === null ? (yt = 65533, $t = 1) : yt > 65535 && (yt -= 65536, ve.push(yt >>> 10 & 1023 | 55296), yt = 56320 | yt & 1023), ve.push(yt), Ne += $t;
                  }
                  return St(ve);
                }
                var Mt = 4096;
                function St(be) {
                  var G = be.length;
                  if (G <= Mt)
                    return String.fromCharCode.apply(String, be);
                  for (var V = "", ve = 0; ve < G; )
                    V += String.fromCharCode.apply(String, be.slice(ve, ve += Mt));
                  return V;
                }
                function Ve(be, G, V) {
                  var ve = "";
                  V = Math.min(be.length, V);
                  for (var Ne = G; Ne < V; ++Ne)
                    ve += String.fromCharCode(be[Ne] & 127);
                  return ve;
                }
                function Ue(be, G, V) {
                  var ve = "";
                  V = Math.min(be.length, V);
                  for (var Ne = G; Ne < V; ++Ne)
                    ve += String.fromCharCode(be[Ne]);
                  return ve;
                }
                function He(be, G, V) {
                  var ve = be.length;
                  (!G || G < 0) && (G = 0), (!V || V < 0 || V > ve) && (V = ve);
                  for (var Ne = "", it = G; it < V; ++it)
                    Ne += nt[be[it]];
                  return Ne;
                }
                function We(be, G, V) {
                  for (var ve = be.slice(G, V), Ne = "", it = 0; it < ve.length - 1; it += 2)
                    Ne += String.fromCharCode(ve[it] + ve[it + 1] * 256);
                  return Ne;
                }
                T.prototype.slice = function(G, V) {
                  var ve = this.length;
                  G = ~~G, V = V === void 0 ? ve : ~~V, G < 0 ? (G += ve, G < 0 && (G = 0)) : G > ve && (G = ve), V < 0 ? (V += ve, V < 0 && (V = 0)) : V > ve && (V = ve), V < G && (V = G);
                  var Ne = this.subarray(G, V);
                  return Object.setPrototypeOf(Ne, T.prototype), Ne;
                };
                function ze(be, G, V) {
                  if (be % 1 !== 0 || be < 0)
                    throw new RangeError("offset is not uint");
                  if (be + G > V)
                    throw new RangeError("Trying to access beyond buffer length");
                }
                T.prototype.readUintLE = T.prototype.readUIntLE = function(G, V, ve) {
                  G = G >>> 0, V = V >>> 0, ve || ze(G, V, this.length);
                  for (var Ne = this[G], it = 1, yt = 0; ++yt < V && (it *= 256); )
                    Ne += this[G + yt] * it;
                  return Ne;
                }, T.prototype.readUintBE = T.prototype.readUIntBE = function(G, V, ve) {
                  G = G >>> 0, V = V >>> 0, ve || ze(G, V, this.length);
                  for (var Ne = this[G + --V], it = 1; V > 0 && (it *= 256); )
                    Ne += this[G + --V] * it;
                  return Ne;
                }, T.prototype.readUint8 = T.prototype.readUInt8 = function(G, V) {
                  return G = G >>> 0, V || ze(G, 1, this.length), this[G];
                }, T.prototype.readUint16LE = T.prototype.readUInt16LE = function(G, V) {
                  return G = G >>> 0, V || ze(G, 2, this.length), this[G] | this[G + 1] << 8;
                }, T.prototype.readUint16BE = T.prototype.readUInt16BE = function(G, V) {
                  return G = G >>> 0, V || ze(G, 2, this.length), this[G] << 8 | this[G + 1];
                }, T.prototype.readUint32LE = T.prototype.readUInt32LE = function(G, V) {
                  return G = G >>> 0, V || ze(G, 4, this.length), (this[G] | this[G + 1] << 8 | this[G + 2] << 16) + this[G + 3] * 16777216;
                }, T.prototype.readUint32BE = T.prototype.readUInt32BE = function(G, V) {
                  return G = G >>> 0, V || ze(G, 4, this.length), this[G] * 16777216 + (this[G + 1] << 16 | this[G + 2] << 8 | this[G + 3]);
                }, T.prototype.readIntLE = function(G, V, ve) {
                  G = G >>> 0, V = V >>> 0, ve || ze(G, V, this.length);
                  for (var Ne = this[G], it = 1, yt = 0; ++yt < V && (it *= 256); )
                    Ne += this[G + yt] * it;
                  return it *= 128, Ne >= it && (Ne -= Math.pow(2, 8 * V)), Ne;
                }, T.prototype.readIntBE = function(G, V, ve) {
                  G = G >>> 0, V = V >>> 0, ve || ze(G, V, this.length);
                  for (var Ne = V, it = 1, yt = this[G + --Ne]; Ne > 0 && (it *= 256); )
                    yt += this[G + --Ne] * it;
                  return it *= 128, yt >= it && (yt -= Math.pow(2, 8 * V)), yt;
                }, T.prototype.readInt8 = function(G, V) {
                  return G = G >>> 0, V || ze(G, 1, this.length), this[G] & 128 ? (255 - this[G] + 1) * -1 : this[G];
                }, T.prototype.readInt16LE = function(G, V) {
                  G = G >>> 0, V || ze(G, 2, this.length);
                  var ve = this[G] | this[G + 1] << 8;
                  return ve & 32768 ? ve | 4294901760 : ve;
                }, T.prototype.readInt16BE = function(G, V) {
                  G = G >>> 0, V || ze(G, 2, this.length);
                  var ve = this[G + 1] | this[G] << 8;
                  return ve & 32768 ? ve | 4294901760 : ve;
                }, T.prototype.readInt32LE = function(G, V) {
                  return G = G >>> 0, V || ze(G, 4, this.length), this[G] | this[G + 1] << 8 | this[G + 2] << 16 | this[G + 3] << 24;
                }, T.prototype.readInt32BE = function(G, V) {
                  return G = G >>> 0, V || ze(G, 4, this.length), this[G] << 24 | this[G + 1] << 16 | this[G + 2] << 8 | this[G + 3];
                }, T.prototype.readFloatLE = function(G, V) {
                  return G = G >>> 0, V || ze(G, 4, this.length), S.read(this, G, !0, 23, 4);
                }, T.prototype.readFloatBE = function(G, V) {
                  return G = G >>> 0, V || ze(G, 4, this.length), S.read(this, G, !1, 23, 4);
                }, T.prototype.readDoubleLE = function(G, V) {
                  return G = G >>> 0, V || ze(G, 8, this.length), S.read(this, G, !0, 52, 8);
                }, T.prototype.readDoubleBE = function(G, V) {
                  return G = G >>> 0, V || ze(G, 8, this.length), S.read(this, G, !1, 52, 8);
                };
                function at(be, G, V, ve, Ne, it) {
                  if (!T.isBuffer(be))
                    throw new TypeError('"buffer" argument must be a Buffer instance');
                  if (G > Ne || G < it)
                    throw new RangeError('"value" argument is out of bounds');
                  if (V + ve > be.length)
                    throw new RangeError("Index out of range");
                }
                T.prototype.writeUintLE = T.prototype.writeUIntLE = function(G, V, ve, Ne) {
                  if (G = +G, V = V >>> 0, ve = ve >>> 0, !Ne) {
                    var it = Math.pow(2, 8 * ve) - 1;
                    at(this, G, V, ve, it, 0);
                  }
                  var yt = 1, $t = 0;
                  for (this[V] = G & 255; ++$t < ve && (yt *= 256); )
                    this[V + $t] = G / yt & 255;
                  return V + ve;
                }, T.prototype.writeUintBE = T.prototype.writeUIntBE = function(G, V, ve, Ne) {
                  if (G = +G, V = V >>> 0, ve = ve >>> 0, !Ne) {
                    var it = Math.pow(2, 8 * ve) - 1;
                    at(this, G, V, ve, it, 0);
                  }
                  var yt = ve - 1, $t = 1;
                  for (this[V + yt] = G & 255; --yt >= 0 && ($t *= 256); )
                    this[V + yt] = G / $t & 255;
                  return V + ve;
                }, T.prototype.writeUint8 = T.prototype.writeUInt8 = function(G, V, ve) {
                  return G = +G, V = V >>> 0, ve || at(this, G, V, 1, 255, 0), this[V] = G & 255, V + 1;
                }, T.prototype.writeUint16LE = T.prototype.writeUInt16LE = function(G, V, ve) {
                  return G = +G, V = V >>> 0, ve || at(this, G, V, 2, 65535, 0), this[V] = G & 255, this[V + 1] = G >>> 8, V + 2;
                }, T.prototype.writeUint16BE = T.prototype.writeUInt16BE = function(G, V, ve) {
                  return G = +G, V = V >>> 0, ve || at(this, G, V, 2, 65535, 0), this[V] = G >>> 8, this[V + 1] = G & 255, V + 2;
                }, T.prototype.writeUint32LE = T.prototype.writeUInt32LE = function(G, V, ve) {
                  return G = +G, V = V >>> 0, ve || at(this, G, V, 4, 4294967295, 0), this[V + 3] = G >>> 24, this[V + 2] = G >>> 16, this[V + 1] = G >>> 8, this[V] = G & 255, V + 4;
                }, T.prototype.writeUint32BE = T.prototype.writeUInt32BE = function(G, V, ve) {
                  return G = +G, V = V >>> 0, ve || at(this, G, V, 4, 4294967295, 0), this[V] = G >>> 24, this[V + 1] = G >>> 16, this[V + 2] = G >>> 8, this[V + 3] = G & 255, V + 4;
                }, T.prototype.writeIntLE = function(G, V, ve, Ne) {
                  if (G = +G, V = V >>> 0, !Ne) {
                    var it = Math.pow(2, 8 * ve - 1);
                    at(this, G, V, ve, it - 1, -it);
                  }
                  var yt = 0, $t = 1, Gt = 0;
                  for (this[V] = G & 255; ++yt < ve && ($t *= 256); )
                    G < 0 && Gt === 0 && this[V + yt - 1] !== 0 && (Gt = 1), this[V + yt] = (G / $t >> 0) - Gt & 255;
                  return V + ve;
                }, T.prototype.writeIntBE = function(G, V, ve, Ne) {
                  if (G = +G, V = V >>> 0, !Ne) {
                    var it = Math.pow(2, 8 * ve - 1);
                    at(this, G, V, ve, it - 1, -it);
                  }
                  var yt = ve - 1, $t = 1, Gt = 0;
                  for (this[V + yt] = G & 255; --yt >= 0 && ($t *= 256); )
                    G < 0 && Gt === 0 && this[V + yt + 1] !== 0 && (Gt = 1), this[V + yt] = (G / $t >> 0) - Gt & 255;
                  return V + ve;
                }, T.prototype.writeInt8 = function(G, V, ve) {
                  return G = +G, V = V >>> 0, ve || at(this, G, V, 1, 127, -128), G < 0 && (G = 255 + G + 1), this[V] = G & 255, V + 1;
                }, T.prototype.writeInt16LE = function(G, V, ve) {
                  return G = +G, V = V >>> 0, ve || at(this, G, V, 2, 32767, -32768), this[V] = G & 255, this[V + 1] = G >>> 8, V + 2;
                }, T.prototype.writeInt16BE = function(G, V, ve) {
                  return G = +G, V = V >>> 0, ve || at(this, G, V, 2, 32767, -32768), this[V] = G >>> 8, this[V + 1] = G & 255, V + 2;
                }, T.prototype.writeInt32LE = function(G, V, ve) {
                  return G = +G, V = V >>> 0, ve || at(this, G, V, 4, 2147483647, -2147483648), this[V] = G & 255, this[V + 1] = G >>> 8, this[V + 2] = G >>> 16, this[V + 3] = G >>> 24, V + 4;
                }, T.prototype.writeInt32BE = function(G, V, ve) {
                  return G = +G, V = V >>> 0, ve || at(this, G, V, 4, 2147483647, -2147483648), G < 0 && (G = 4294967295 + G + 1), this[V] = G >>> 24, this[V + 1] = G >>> 16, this[V + 2] = G >>> 8, this[V + 3] = G & 255, V + 4;
                };
                function Ye(be, G, V, ve, Ne, it) {
                  if (V + ve > be.length)
                    throw new RangeError("Index out of range");
                  if (V < 0)
                    throw new RangeError("Index out of range");
                }
                function tt(be, G, V, ve, Ne) {
                  return G = +G, V = V >>> 0, Ne || Ye(be, G, V, 4), S.write(be, G, V, ve, 23, 4), V + 4;
                }
                T.prototype.writeFloatLE = function(G, V, ve) {
                  return tt(this, G, V, !0, ve);
                }, T.prototype.writeFloatBE = function(G, V, ve) {
                  return tt(this, G, V, !1, ve);
                };
                function wt(be, G, V, ve, Ne) {
                  return G = +G, V = V >>> 0, Ne || Ye(be, G, V, 8), S.write(be, G, V, ve, 52, 8), V + 8;
                }
                T.prototype.writeDoubleLE = function(G, V, ve) {
                  return wt(this, G, V, !0, ve);
                }, T.prototype.writeDoubleBE = function(G, V, ve) {
                  return wt(this, G, V, !1, ve);
                }, T.prototype.copy = function(G, V, ve, Ne) {
                  if (!T.isBuffer(G))
                    throw new TypeError("argument should be a Buffer");
                  if (ve || (ve = 0), !Ne && Ne !== 0 && (Ne = this.length), V >= G.length && (V = G.length), V || (V = 0), Ne > 0 && Ne < ve && (Ne = ve), Ne === ve || G.length === 0 || this.length === 0)
                    return 0;
                  if (V < 0)
                    throw new RangeError("targetStart out of bounds");
                  if (ve < 0 || ve >= this.length)
                    throw new RangeError("Index out of range");
                  if (Ne < 0)
                    throw new RangeError("sourceEnd out of bounds");
                  Ne > this.length && (Ne = this.length), G.length - V < Ne - ve && (Ne = G.length - V + ve);
                  var it = Ne - ve;
                  return this === G && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(V, ve, Ne) : Uint8Array.prototype.set.call(G, this.subarray(ve, Ne), V), it;
                }, T.prototype.fill = function(G, V, ve, Ne) {
                  if (typeof G == "string") {
                    if (typeof V == "string" ? (Ne = V, V = 0, ve = this.length) : typeof ve == "string" && (Ne = ve, ve = this.length), Ne !== void 0 && typeof Ne != "string")
                      throw new TypeError("encoding must be a string");
                    if (typeof Ne == "string" && !T.isEncoding(Ne))
                      throw new TypeError("Unknown encoding: " + Ne);
                    if (G.length === 1) {
                      var it = G.charCodeAt(0);
                      (Ne === "utf8" && it < 128 || Ne === "latin1") && (G = it);
                    }
                  } else typeof G == "number" ? G = G & 255 : typeof G == "boolean" && (G = Number(G));
                  if (V < 0 || this.length < V || this.length < ve)
                    throw new RangeError("Out of range index");
                  if (ve <= V)
                    return this;
                  V = V >>> 0, ve = ve === void 0 ? this.length : ve >>> 0, G || (G = 0);
                  var yt;
                  if (typeof G == "number")
                    for (yt = V; yt < ve; ++yt)
                      this[yt] = G;
                  else {
                    var $t = T.isBuffer(G) ? G : T.from(G, Ne), Gt = $t.length;
                    if (Gt === 0)
                      throw new TypeError('The value "' + G + '" is invalid for argument "value"');
                    for (yt = 0; yt < ve - V; ++yt)
                      this[yt + V] = $t[yt % Gt];
                  }
                  return this;
                };
                var Ft = /[^+/0-9A-Za-z-_]/g;
                function qe(be) {
                  if (be = be.split("=")[0], be = be.trim().replace(Ft, ""), be.length < 2)
                    return "";
                  for (; be.length % 4 !== 0; )
                    be = be + "=";
                  return be;
                }
                function pe(be, G) {
                  G = G || 1 / 0;
                  for (var V, ve = be.length, Ne = null, it = [], yt = 0; yt < ve; ++yt) {
                    if (V = be.charCodeAt(yt), V > 55295 && V < 57344) {
                      if (!Ne) {
                        if (V > 56319) {
                          (G -= 3) > -1 && it.push(239, 191, 189);
                          continue;
                        } else if (yt + 1 === ve) {
                          (G -= 3) > -1 && it.push(239, 191, 189);
                          continue;
                        }
                        Ne = V;
                        continue;
                      }
                      if (V < 56320) {
                        (G -= 3) > -1 && it.push(239, 191, 189), Ne = V;
                        continue;
                      }
                      V = (Ne - 55296 << 10 | V - 56320) + 65536;
                    } else Ne && (G -= 3) > -1 && it.push(239, 191, 189);
                    if (Ne = null, V < 128) {
                      if ((G -= 1) < 0)
                        break;
                      it.push(V);
                    } else if (V < 2048) {
                      if ((G -= 2) < 0)
                        break;
                      it.push(V >> 6 | 192, V & 63 | 128);
                    } else if (V < 65536) {
                      if ((G -= 3) < 0)
                        break;
                      it.push(V >> 12 | 224, V >> 6 & 63 | 128, V & 63 | 128);
                    } else if (V < 1114112) {
                      if ((G -= 4) < 0)
                        break;
                      it.push(V >> 18 | 240, V >> 12 & 63 | 128, V >> 6 & 63 | 128, V & 63 | 128);
                    } else
                      throw new Error("Invalid code point");
                  }
                  return it;
                }
                function _e(be) {
                  for (var G = [], V = 0; V < be.length; ++V)
                    G.push(be.charCodeAt(V) & 255);
                  return G;
                }
                function Xe(be, G) {
                  for (var V, ve, Ne, it = [], yt = 0; yt < be.length && !((G -= 2) < 0); ++yt)
                    V = be.charCodeAt(yt), ve = V >> 8, Ne = V % 256, it.push(Ne), it.push(ve);
                  return it;
                }
                function lt(be) {
                  return y.toByteArray(qe(be));
                }
                function Q(be, G, V, ve) {
                  for (var Ne = 0; Ne < ve && !(Ne + V >= G.length || Ne >= be.length); ++Ne)
                    G[Ne + V] = be[Ne];
                  return Ne;
                }
                function te(be, G) {
                  return be instanceof G || be != null && be.constructor != null && be.constructor.name != null && be.constructor.name === G.name;
                }
                function De(be) {
                  return be !== be;
                }
                var nt = function() {
                  for (var be = "0123456789abcdef", G = new Array(256), V = 0; V < 16; ++V)
                    for (var ve = V * 16, Ne = 0; Ne < 16; ++Ne)
                      G[ve + Ne] = be[V] + be[Ne];
                  return G;
                }();
              }
            ),
            /***/
            722: (
              /***/
              function(p) {
                var d = typeof Reflect == "object" ? Reflect : null, m = d && typeof d.apply == "function" ? d.apply : function(ge, we, Oe) {
                  return Function.prototype.apply.call(ge, we, Oe);
                }, y;
                d && typeof d.ownKeys == "function" ? y = d.ownKeys : Object.getOwnPropertySymbols ? y = function(ge) {
                  return Object.getOwnPropertyNames(ge).concat(Object.getOwnPropertySymbols(ge));
                } : y = function(ge) {
                  return Object.getOwnPropertyNames(ge);
                };
                function S(oe) {
                  console && console.warn && console.warn(oe);
                }
                var x = Number.isNaN || function(ge) {
                  return ge !== ge;
                };
                function w() {
                  w.init.call(this);
                }
                p.exports = w, p.exports.once = de, w.EventEmitter = w, w.prototype._events = void 0, w.prototype._eventsCount = 0, w.prototype._maxListeners = void 0;
                var k = 10;
                function O(oe) {
                  if (typeof oe != "function")
                    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof oe);
                }
                Object.defineProperty(w, "defaultMaxListeners", {
                  enumerable: !0,
                  get: function() {
                    return k;
                  },
                  set: function(oe) {
                    if (typeof oe != "number" || oe < 0 || x(oe))
                      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + oe + ".");
                    k = oe;
                  }
                }), w.init = function() {
                  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
                }, w.prototype.setMaxListeners = function(ge) {
                  if (typeof ge != "number" || ge < 0 || x(ge))
                    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + ge + ".");
                  return this._maxListeners = ge, this;
                };
                function T(oe) {
                  return oe._maxListeners === void 0 ? w.defaultMaxListeners : oe._maxListeners;
                }
                w.prototype.getMaxListeners = function() {
                  return T(this);
                }, w.prototype.emit = function(ge) {
                  for (var we = [], Oe = 1; Oe < arguments.length; Oe++)
                    we.push(arguments[Oe]);
                  var Qe = ge === "error", Me = this._events;
                  if (Me !== void 0)
                    Qe = Qe && Me.error === void 0;
                  else if (!Qe)
                    return !1;
                  if (Qe) {
                    var Ie;
                    if (we.length > 0 && (Ie = we[0]), Ie instanceof Error)
                      throw Ie;
                    var rt = new Error("Unhandled error." + (Ie ? " (" + Ie.message + ")" : ""));
                    throw rt.context = Ie, rt;
                  }
                  var ot = Me[ge];
                  if (ot === void 0)
                    return !1;
                  if (typeof ot == "function")
                    m(ot, this, we);
                  else
                    for (var Et = ot.length, gt = K(ot, Et), Oe = 0; Oe < Et; ++Oe)
                      m(gt[Oe], this, we);
                  return !0;
                };
                function L(oe, ge, we, Oe) {
                  var Qe, Me, Ie;
                  if (O(we), Me = oe._events, Me === void 0 ? (Me = oe._events = /* @__PURE__ */ Object.create(null), oe._eventsCount = 0) : (Me.newListener !== void 0 && (oe.emit("newListener", ge, we.listener ? we.listener : we), Me = oe._events), Ie = Me[ge]), Ie === void 0)
                    Ie = Me[ge] = we, ++oe._eventsCount;
                  else if (typeof Ie == "function" ? Ie = Me[ge] = Oe ? [we, Ie] : [Ie, we] : Oe ? Ie.unshift(we) : Ie.push(we), Qe = T(oe), Qe > 0 && Ie.length > Qe && !Ie.warned) {
                    Ie.warned = !0;
                    var rt = new Error("Possible EventEmitter memory leak detected. " + Ie.length + " " + String(ge) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                    rt.name = "MaxListenersExceededWarning", rt.emitter = oe, rt.type = ge, rt.count = Ie.length, S(rt);
                  }
                  return oe;
                }
                w.prototype.addListener = function(ge, we) {
                  return L(this, ge, we, !1);
                }, w.prototype.on = w.prototype.addListener, w.prototype.prependListener = function(ge, we) {
                  return L(this, ge, we, !0);
                };
                function j() {
                  if (!this.fired)
                    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
                }
                function z(oe, ge, we) {
                  var Oe = { fired: !1, wrapFn: void 0, target: oe, type: ge, listener: we }, Qe = j.bind(Oe);
                  return Qe.listener = we, Oe.wrapFn = Qe, Qe;
                }
                w.prototype.once = function(ge, we) {
                  return O(we), this.on(ge, z(this, ge, we)), this;
                }, w.prototype.prependOnceListener = function(ge, we) {
                  return O(we), this.prependListener(ge, z(this, ge, we)), this;
                }, w.prototype.removeListener = function(ge, we) {
                  var Oe, Qe, Me, Ie, rt;
                  if (O(we), Qe = this._events, Qe === void 0)
                    return this;
                  if (Oe = Qe[ge], Oe === void 0)
                    return this;
                  if (Oe === we || Oe.listener === we)
                    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete Qe[ge], Qe.removeListener && this.emit("removeListener", ge, Oe.listener || we));
                  else if (typeof Oe != "function") {
                    for (Me = -1, Ie = Oe.length - 1; Ie >= 0; Ie--)
                      if (Oe[Ie] === we || Oe[Ie].listener === we) {
                        rt = Oe[Ie].listener, Me = Ie;
                        break;
                      }
                    if (Me < 0)
                      return this;
                    Me === 0 ? Oe.shift() : re(Oe, Me), Oe.length === 1 && (Qe[ge] = Oe[0]), Qe.removeListener !== void 0 && this.emit("removeListener", ge, rt || we);
                  }
                  return this;
                }, w.prototype.off = w.prototype.removeListener, w.prototype.removeAllListeners = function(ge) {
                  var we, Oe, Qe;
                  if (Oe = this._events, Oe === void 0)
                    return this;
                  if (Oe.removeListener === void 0)
                    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : Oe[ge] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete Oe[ge]), this;
                  if (arguments.length === 0) {
                    var Me = Object.keys(Oe), Ie;
                    for (Qe = 0; Qe < Me.length; ++Qe)
                      Ie = Me[Qe], Ie !== "removeListener" && this.removeAllListeners(Ie);
                    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
                  }
                  if (we = Oe[ge], typeof we == "function")
                    this.removeListener(ge, we);
                  else if (we !== void 0)
                    for (Qe = we.length - 1; Qe >= 0; Qe--)
                      this.removeListener(ge, we[Qe]);
                  return this;
                };
                function J(oe, ge, we) {
                  var Oe = oe._events;
                  if (Oe === void 0)
                    return [];
                  var Qe = Oe[ge];
                  return Qe === void 0 ? [] : typeof Qe == "function" ? we ? [Qe.listener || Qe] : [Qe] : we ? ee(Qe) : K(Qe, Qe.length);
                }
                w.prototype.listeners = function(ge) {
                  return J(this, ge, !0);
                }, w.prototype.rawListeners = function(ge) {
                  return J(this, ge, !1);
                }, w.listenerCount = function(oe, ge) {
                  return typeof oe.listenerCount == "function" ? oe.listenerCount(ge) : ie.call(oe, ge);
                }, w.prototype.listenerCount = ie;
                function ie(oe) {
                  var ge = this._events;
                  if (ge !== void 0) {
                    var we = ge[oe];
                    if (typeof we == "function")
                      return 1;
                    if (we !== void 0)
                      return we.length;
                  }
                  return 0;
                }
                w.prototype.eventNames = function() {
                  return this._eventsCount > 0 ? y(this._events) : [];
                };
                function K(oe, ge) {
                  for (var we = new Array(ge), Oe = 0; Oe < ge; ++Oe)
                    we[Oe] = oe[Oe];
                  return we;
                }
                function re(oe, ge) {
                  for (; ge + 1 < oe.length; ge++)
                    oe[ge] = oe[ge + 1];
                  oe.pop();
                }
                function ee(oe) {
                  for (var ge = new Array(oe.length), we = 0; we < ge.length; ++we)
                    ge[we] = oe[we].listener || oe[we];
                  return ge;
                }
                function de(oe, ge) {
                  return new Promise(function(we, Oe) {
                    function Qe(Ie) {
                      oe.removeListener(ge, Me), Oe(Ie);
                    }
                    function Me() {
                      typeof oe.removeListener == "function" && oe.removeListener("error", Qe), we([].slice.call(arguments));
                    }
                    he(oe, ge, Me, { once: !0 }), ge !== "error" && Ce(oe, Qe, { once: !0 });
                  });
                }
                function Ce(oe, ge, we) {
                  typeof oe.on == "function" && he(oe, "error", ge, we);
                }
                function he(oe, ge, we, Oe) {
                  if (typeof oe.on == "function")
                    Oe.once ? oe.once(ge, we) : oe.on(ge, we);
                  else if (typeof oe.addEventListener == "function")
                    oe.addEventListener(ge, function Qe(Me) {
                      Oe.once && oe.removeEventListener(ge, Qe), we(Me);
                    });
                  else
                    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof oe);
                }
              }
            ),
            /***/
            74: (
              /***/
              function(p, d) {
                /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
                d.read = function(m, y, S, x, w) {
                  var k, O, T = w * 8 - x - 1, L = (1 << T) - 1, j = L >> 1, z = -7, J = S ? w - 1 : 0, ie = S ? -1 : 1, K = m[y + J];
                  for (J += ie, k = K & (1 << -z) - 1, K >>= -z, z += T; z > 0; k = k * 256 + m[y + J], J += ie, z -= 8)
                    ;
                  for (O = k & (1 << -z) - 1, k >>= -z, z += x; z > 0; O = O * 256 + m[y + J], J += ie, z -= 8)
                    ;
                  if (k === 0)
                    k = 1 - j;
                  else {
                    if (k === L)
                      return O ? NaN : (K ? -1 : 1) * (1 / 0);
                    O = O + Math.pow(2, x), k = k - j;
                  }
                  return (K ? -1 : 1) * O * Math.pow(2, k - x);
                }, d.write = function(m, y, S, x, w, k) {
                  var O, T, L, j = k * 8 - w - 1, z = (1 << j) - 1, J = z >> 1, ie = w === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, K = x ? 0 : k - 1, re = x ? 1 : -1, ee = y < 0 || y === 0 && 1 / y < 0 ? 1 : 0;
                  for (y = Math.abs(y), isNaN(y) || y === 1 / 0 ? (T = isNaN(y) ? 1 : 0, O = z) : (O = Math.floor(Math.log(y) / Math.LN2), y * (L = Math.pow(2, -O)) < 1 && (O--, L *= 2), O + J >= 1 ? y += ie / L : y += ie * Math.pow(2, 1 - J), y * L >= 2 && (O++, L /= 2), O + J >= z ? (T = 0, O = z) : O + J >= 1 ? (T = (y * L - 1) * Math.pow(2, w), O = O + J) : (T = y * Math.pow(2, J - 1) * Math.pow(2, w), O = 0)); w >= 8; m[S + K] = T & 255, K += re, T /= 256, w -= 8)
                    ;
                  for (O = O << w | T, j += w; j > 0; m[S + K] = O & 255, K += re, O /= 256, j -= 8)
                    ;
                  m[S + K - re] |= ee * 128;
                };
              }
            ),
            /***/
            409: (
              /***/
              function(p) {
                typeof Object.create == "function" ? p.exports = function(m, y) {
                  y && (m.super_ = y, m.prototype = Object.create(y.prototype, {
                    constructor: {
                      value: m,
                      enumerable: !1,
                      writable: !0,
                      configurable: !0
                    }
                  }));
                } : p.exports = function(m, y) {
                  if (y) {
                    m.super_ = y;
                    var S = function() {
                    };
                    S.prototype = y.prototype, m.prototype = new S(), m.prototype.constructor = m;
                  }
                };
              }
            ),
            /***/
            983: (
              /***/
              function(p, d, m) {
                p.exports = m(983);
              }
            ),
            /***/
            50: (
              /***/
              function(p) {
                function d(O, T) {
                  O.prototype = Object.create(T.prototype), O.prototype.constructor = O, O.__proto__ = T;
                }
                var m = {};
                function y(O, T, L) {
                  L || (L = Error);
                  function j(J, ie, K) {
                    return typeof T == "string" ? T : T(J, ie, K);
                  }
                  var z = /* @__PURE__ */ function(J) {
                    d(ie, J);
                    function ie(K, re, ee) {
                      return J.call(this, j(K, re, ee)) || this;
                    }
                    return ie;
                  }(L);
                  z.prototype.name = L.name, z.prototype.code = O, m[O] = z;
                }
                function S(O, T) {
                  if (Array.isArray(O)) {
                    var L = O.length;
                    return O = O.map(function(j) {
                      return String(j);
                    }), L > 2 ? "one of ".concat(T, " ").concat(O.slice(0, L - 1).join(", "), ", or ") + O[L - 1] : L === 2 ? "one of ".concat(T, " ").concat(O[0], " or ").concat(O[1]) : "of ".concat(T, " ").concat(O[0]);
                  } else
                    return "of ".concat(T, " ").concat(String(O));
                }
                function x(O, T, L) {
                  return O.substr(0, T.length) === T;
                }
                function w(O, T, L) {
                  return (L === void 0 || L > O.length) && (L = O.length), O.substring(L - T.length, L) === T;
                }
                function k(O, T, L) {
                  return typeof L != "number" && (L = 0), L + T.length > O.length ? !1 : O.indexOf(T, L) !== -1;
                }
                y("ERR_INVALID_OPT_VALUE", function(O, T) {
                  return 'The value "' + T + '" is invalid for option "' + O + '"';
                }, TypeError), y("ERR_INVALID_ARG_TYPE", function(O, T, L) {
                  var j;
                  typeof T == "string" && x(T, "not ") ? (j = "must not be", T = T.replace(/^not /, "")) : j = "must be";
                  var z;
                  if (w(O, " argument"))
                    z = "The ".concat(O, " ").concat(j, " ").concat(S(T, "type"));
                  else {
                    var J = k(O, ".") ? "property" : "argument";
                    z = 'The "'.concat(O, '" ').concat(J, " ").concat(j, " ").concat(S(T, "type"));
                  }
                  return z += ". Received type ".concat(typeof L), z;
                }, TypeError), y("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), y("ERR_METHOD_NOT_IMPLEMENTED", function(O) {
                  return "The " + O + " method is not implemented";
                }), y("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), y("ERR_STREAM_DESTROYED", function(O) {
                  return "Cannot call " + O + " after a stream was destroyed";
                }), y("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), y("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), y("ERR_STREAM_WRITE_AFTER_END", "write after end"), y("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), y("ERR_UNKNOWN_ENCODING", function(O) {
                  return "Unknown encoding: " + O;
                }, TypeError), y("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), p.exports.q = m;
              }
            ),
            /***/
            298: (
              /***/
              function(p, d, m) {
                var y = Object.keys || function(z) {
                  var J = [];
                  for (var ie in z)
                    J.push(ie);
                  return J;
                };
                p.exports = T;
                var S = m(58), x = m(880);
                m(409)(T, S);
                for (var w = y(x.prototype), k = 0; k < w.length; k++) {
                  var O = w[k];
                  T.prototype[O] || (T.prototype[O] = x.prototype[O]);
                }
                function T(z) {
                  if (!(this instanceof T))
                    return new T(z);
                  S.call(this, z), x.call(this, z), this.allowHalfOpen = !0, z && (z.readable === !1 && (this.readable = !1), z.writable === !1 && (this.writable = !1), z.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", L)));
                }
                Object.defineProperty(T.prototype, "writableHighWaterMark", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: !1,
                  get: function() {
                    return this._writableState.highWaterMark;
                  }
                }), Object.defineProperty(T.prototype, "writableBuffer", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: !1,
                  get: function() {
                    return this._writableState && this._writableState.getBuffer();
                  }
                }), Object.defineProperty(T.prototype, "writableLength", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: !1,
                  get: function() {
                    return this._writableState.length;
                  }
                });
                function L() {
                  this._writableState.ended || process.nextTick(j, this);
                }
                function j(z) {
                  z.end();
                }
                Object.defineProperty(T.prototype, "destroyed", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: !1,
                  get: function() {
                    return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
                  },
                  set: function(J) {
                    this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = J, this._writableState.destroyed = J);
                  }
                });
              }
            ),
            /***/
            4: (
              /***/
              function(p, d, m) {
                p.exports = S;
                var y = m(969);
                m(409)(S, y);
                function S(x) {
                  if (!(this instanceof S))
                    return new S(x);
                  y.call(this, x);
                }
                S.prototype._transform = function(x, w, k) {
                  k(null, x);
                };
              }
            ),
            /***/
            58: (
              /***/
              function(p, d, m) {
                p.exports = rt;
                var y;
                rt.ReadableState = Ie, m(722).EventEmitter;
                var S = function(te, De) {
                  return te.listeners(De).length;
                }, x = m(786), w = m(636).Buffer, k = m.g.Uint8Array || function() {
                };
                function O(Q) {
                  return w.from(Q);
                }
                function T(Q) {
                  return w.isBuffer(Q) || Q instanceof k;
                }
                var L = m(602), j;
                L && L.debuglog ? j = L.debuglog("stream") : j = function() {
                };
                var z = m(346), J = m(974), ie = m(754), K = ie.getHighWaterMark, re = m(50).q, ee = re.ERR_INVALID_ARG_TYPE, de = re.ERR_STREAM_PUSH_AFTER_EOF, Ce = re.ERR_METHOD_NOT_IMPLEMENTED, he = re.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, oe, ge, we;
                m(409)(rt, x);
                var Oe = J.errorOrDestroy, Qe = ["error", "close", "destroy", "pause", "resume"];
                function Me(Q, te, De) {
                  if (typeof Q.prependListener == "function")
                    return Q.prependListener(te, De);
                  !Q._events || !Q._events[te] ? Q.on(te, De) : Array.isArray(Q._events[te]) ? Q._events[te].unshift(De) : Q._events[te] = [De, Q._events[te]];
                }
                function Ie(Q, te, De) {
                  y = y || m(298), Q = Q || {}, typeof De != "boolean" && (De = te instanceof y), this.objectMode = !!Q.objectMode, De && (this.objectMode = this.objectMode || !!Q.readableObjectMode), this.highWaterMark = K(this, Q, "readableHighWaterMark", De), this.buffer = new z(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = Q.emitClose !== !1, this.autoDestroy = !!Q.autoDestroy, this.destroyed = !1, this.defaultEncoding = Q.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Q.encoding && (oe || (oe = m(183).s), this.decoder = new oe(Q.encoding), this.encoding = Q.encoding);
                }
                function rt(Q) {
                  if (y = y || m(298), !(this instanceof rt))
                    return new rt(Q);
                  var te = this instanceof y;
                  this._readableState = new Ie(Q, this, te), this.readable = !0, Q && (typeof Q.read == "function" && (this._read = Q.read), typeof Q.destroy == "function" && (this._destroy = Q.destroy)), x.call(this);
                }
                Object.defineProperty(rt.prototype, "destroyed", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: !1,
                  get: function() {
                    return this._readableState === void 0 ? !1 : this._readableState.destroyed;
                  },
                  set: function(te) {
                    this._readableState && (this._readableState.destroyed = te);
                  }
                }), rt.prototype.destroy = J.destroy, rt.prototype._undestroy = J.undestroy, rt.prototype._destroy = function(Q, te) {
                  te(Q);
                }, rt.prototype.push = function(Q, te) {
                  var De = this._readableState, nt;
                  return De.objectMode ? nt = !0 : typeof Q == "string" && (te = te || De.defaultEncoding, te !== De.encoding && (Q = w.from(Q, te), te = ""), nt = !0), ot(this, Q, te, !1, nt);
                }, rt.prototype.unshift = function(Q) {
                  return ot(this, Q, null, !0, !1);
                };
                function ot(Q, te, De, nt, be) {
                  j("readableAddChunk", te);
                  var G = Q._readableState;
                  if (te === null)
                    G.reading = !1, Ve(Q, G);
                  else {
                    var V;
                    if (be || (V = gt(G, te)), V)
                      Oe(Q, V);
                    else if (G.objectMode || te && te.length > 0)
                      if (typeof te != "string" && !G.objectMode && Object.getPrototypeOf(te) !== w.prototype && (te = O(te)), nt)
                        G.endEmitted ? Oe(Q, new he()) : Et(Q, G, te, !0);
                      else if (G.ended)
                        Oe(Q, new de());
                      else {
                        if (G.destroyed)
                          return !1;
                        G.reading = !1, G.decoder && !De ? (te = G.decoder.write(te), G.objectMode || te.length !== 0 ? Et(Q, G, te, !1) : We(Q, G)) : Et(Q, G, te, !1);
                      }
                    else nt || (G.reading = !1, We(Q, G));
                  }
                  return !G.ended && (G.length < G.highWaterMark || G.length === 0);
                }
                function Et(Q, te, De, nt) {
                  te.flowing && te.length === 0 && !te.sync ? (te.awaitDrain = 0, Q.emit("data", De)) : (te.length += te.objectMode ? 1 : De.length, nt ? te.buffer.unshift(De) : te.buffer.push(De), te.needReadable && Ue(Q)), We(Q, te);
                }
                function gt(Q, te) {
                  var De;
                  return !T(te) && typeof te != "string" && te !== void 0 && !Q.objectMode && (De = new ee("chunk", ["string", "Buffer", "Uint8Array"], te)), De;
                }
                rt.prototype.isPaused = function() {
                  return this._readableState.flowing === !1;
                }, rt.prototype.setEncoding = function(Q) {
                  oe || (oe = m(183).s);
                  var te = new oe(Q);
                  this._readableState.decoder = te, this._readableState.encoding = this._readableState.decoder.encoding;
                  for (var De = this._readableState.buffer.head, nt = ""; De !== null; )
                    nt += te.write(De.data), De = De.next;
                  return this._readableState.buffer.clear(), nt !== "" && this._readableState.buffer.push(nt), this._readableState.length = nt.length, this;
                };
                var At = 1073741824;
                function Mt(Q) {
                  return Q >= At ? Q = At : (Q--, Q |= Q >>> 1, Q |= Q >>> 2, Q |= Q >>> 4, Q |= Q >>> 8, Q |= Q >>> 16, Q++), Q;
                }
                function St(Q, te) {
                  return Q <= 0 || te.length === 0 && te.ended ? 0 : te.objectMode ? 1 : Q !== Q ? te.flowing && te.length ? te.buffer.head.data.length : te.length : (Q > te.highWaterMark && (te.highWaterMark = Mt(Q)), Q <= te.length ? Q : te.ended ? te.length : (te.needReadable = !0, 0));
                }
                rt.prototype.read = function(Q) {
                  j("read", Q), Q = parseInt(Q, 10);
                  var te = this._readableState, De = Q;
                  if (Q !== 0 && (te.emittedReadable = !1), Q === 0 && te.needReadable && ((te.highWaterMark !== 0 ? te.length >= te.highWaterMark : te.length > 0) || te.ended))
                    return j("read: emitReadable", te.length, te.ended), te.length === 0 && te.ended ? _e(this) : Ue(this), null;
                  if (Q = St(Q, te), Q === 0 && te.ended)
                    return te.length === 0 && _e(this), null;
                  var nt = te.needReadable;
                  j("need readable", nt), (te.length === 0 || te.length - Q < te.highWaterMark) && (nt = !0, j("length less than watermark", nt)), te.ended || te.reading ? (nt = !1, j("reading or ended", nt)) : nt && (j("do read"), te.reading = !0, te.sync = !0, te.length === 0 && (te.needReadable = !0), this._read(te.highWaterMark), te.sync = !1, te.reading || (Q = St(De, te)));
                  var be;
                  return Q > 0 ? be = pe(Q, te) : be = null, be === null ? (te.needReadable = te.length <= te.highWaterMark, Q = 0) : (te.length -= Q, te.awaitDrain = 0), te.length === 0 && (te.ended || (te.needReadable = !0), De !== Q && te.ended && _e(this)), be !== null && this.emit("data", be), be;
                };
                function Ve(Q, te) {
                  if (j("onEofChunk"), !te.ended) {
                    if (te.decoder) {
                      var De = te.decoder.end();
                      De && De.length && (te.buffer.push(De), te.length += te.objectMode ? 1 : De.length);
                    }
                    te.ended = !0, te.sync ? Ue(Q) : (te.needReadable = !1, te.emittedReadable || (te.emittedReadable = !0, He(Q)));
                  }
                }
                function Ue(Q) {
                  var te = Q._readableState;
                  j("emitReadable", te.needReadable, te.emittedReadable), te.needReadable = !1, te.emittedReadable || (j("emitReadable", te.flowing), te.emittedReadable = !0, process.nextTick(He, Q));
                }
                function He(Q) {
                  var te = Q._readableState;
                  j("emitReadable_", te.destroyed, te.length, te.ended), !te.destroyed && (te.length || te.ended) && (Q.emit("readable"), te.emittedReadable = !1), te.needReadable = !te.flowing && !te.ended && te.length <= te.highWaterMark, qe(Q);
                }
                function We(Q, te) {
                  te.readingMore || (te.readingMore = !0, process.nextTick(ze, Q, te));
                }
                function ze(Q, te) {
                  for (; !te.reading && !te.ended && (te.length < te.highWaterMark || te.flowing && te.length === 0); ) {
                    var De = te.length;
                    if (j("maybeReadMore read 0"), Q.read(0), De === te.length)
                      break;
                  }
                  te.readingMore = !1;
                }
                rt.prototype._read = function(Q) {
                  Oe(this, new Ce("_read()"));
                }, rt.prototype.pipe = function(Q, te) {
                  var De = this, nt = this._readableState;
                  switch (nt.pipesCount) {
                    case 0:
                      nt.pipes = Q;
                      break;
                    case 1:
                      nt.pipes = [nt.pipes, Q];
                      break;
                    default:
                      nt.pipes.push(Q);
                      break;
                  }
                  nt.pipesCount += 1, j("pipe count=%d opts=%j", nt.pipesCount, te);
                  var be = (!te || te.end !== !1) && Q !== process.stdout && Q !== process.stderr, G = be ? ve : Ae;
                  nt.endEmitted ? process.nextTick(G) : De.once("end", G), Q.on("unpipe", V);
                  function V(vt, Ot) {
                    j("onunpipe"), vt === De && Ot && Ot.hasUnpiped === !1 && (Ot.hasUnpiped = !0, yt());
                  }
                  function ve() {
                    j("onend"), Q.end();
                  }
                  var Ne = at(De);
                  Q.on("drain", Ne);
                  var it = !1;
                  function yt() {
                    j("cleanup"), Q.removeListener("close", Jt), Q.removeListener("finish", Xt), Q.removeListener("drain", Ne), Q.removeListener("error", Gt), Q.removeListener("unpipe", V), De.removeListener("end", ve), De.removeListener("end", Ae), De.removeListener("data", $t), it = !0, nt.awaitDrain && (!Q._writableState || Q._writableState.needDrain) && Ne();
                  }
                  De.on("data", $t);
                  function $t(vt) {
                    j("ondata");
                    var Ot = Q.write(vt);
                    j("dest.write", Ot), Ot === !1 && ((nt.pipesCount === 1 && nt.pipes === Q || nt.pipesCount > 1 && lt(nt.pipes, Q) !== -1) && !it && (j("false write response, pause", nt.awaitDrain), nt.awaitDrain++), De.pause());
                  }
                  function Gt(vt) {
                    j("onerror", vt), Ae(), Q.removeListener("error", Gt), S(Q, "error") === 0 && Oe(Q, vt);
                  }
                  Me(Q, "error", Gt);
                  function Jt() {
                    Q.removeListener("finish", Xt), Ae();
                  }
                  Q.once("close", Jt);
                  function Xt() {
                    j("onfinish"), Q.removeListener("close", Jt), Ae();
                  }
                  Q.once("finish", Xt);
                  function Ae() {
                    j("unpipe"), De.unpipe(Q);
                  }
                  return Q.emit("pipe", De), nt.flowing || (j("pipe resume"), De.resume()), Q;
                };
                function at(Q) {
                  return function() {
                    var De = Q._readableState;
                    j("pipeOnDrain", De.awaitDrain), De.awaitDrain && De.awaitDrain--, De.awaitDrain === 0 && S(Q, "data") && (De.flowing = !0, qe(Q));
                  };
                }
                rt.prototype.unpipe = function(Q) {
                  var te = this._readableState, De = {
                    hasUnpiped: !1
                  };
                  if (te.pipesCount === 0)
                    return this;
                  if (te.pipesCount === 1)
                    return Q && Q !== te.pipes ? this : (Q || (Q = te.pipes), te.pipes = null, te.pipesCount = 0, te.flowing = !1, Q && Q.emit("unpipe", this, De), this);
                  if (!Q) {
                    var nt = te.pipes, be = te.pipesCount;
                    te.pipes = null, te.pipesCount = 0, te.flowing = !1;
                    for (var G = 0; G < be; G++)
                      nt[G].emit("unpipe", this, {
                        hasUnpiped: !1
                      });
                    return this;
                  }
                  var V = lt(te.pipes, Q);
                  return V === -1 ? this : (te.pipes.splice(V, 1), te.pipesCount -= 1, te.pipesCount === 1 && (te.pipes = te.pipes[0]), Q.emit("unpipe", this, De), this);
                }, rt.prototype.on = function(Q, te) {
                  var De = x.prototype.on.call(this, Q, te), nt = this._readableState;
                  return Q === "data" ? (nt.readableListening = this.listenerCount("readable") > 0, nt.flowing !== !1 && this.resume()) : Q === "readable" && !nt.endEmitted && !nt.readableListening && (nt.readableListening = nt.needReadable = !0, nt.flowing = !1, nt.emittedReadable = !1, j("on readable", nt.length, nt.reading), nt.length ? Ue(this) : nt.reading || process.nextTick(tt, this)), De;
                }, rt.prototype.addListener = rt.prototype.on, rt.prototype.removeListener = function(Q, te) {
                  var De = x.prototype.removeListener.call(this, Q, te);
                  return Q === "readable" && process.nextTick(Ye, this), De;
                }, rt.prototype.removeAllListeners = function(Q) {
                  var te = x.prototype.removeAllListeners.apply(this, arguments);
                  return (Q === "readable" || Q === void 0) && process.nextTick(Ye, this), te;
                };
                function Ye(Q) {
                  var te = Q._readableState;
                  te.readableListening = Q.listenerCount("readable") > 0, te.resumeScheduled && !te.paused ? te.flowing = !0 : Q.listenerCount("data") > 0 && Q.resume();
                }
                function tt(Q) {
                  j("readable nexttick read 0"), Q.read(0);
                }
                rt.prototype.resume = function() {
                  var Q = this._readableState;
                  return Q.flowing || (j("resume"), Q.flowing = !Q.readableListening, wt(this, Q)), Q.paused = !1, this;
                };
                function wt(Q, te) {
                  te.resumeScheduled || (te.resumeScheduled = !0, process.nextTick(Ft, Q, te));
                }
                function Ft(Q, te) {
                  j("resume", te.reading), te.reading || Q.read(0), te.resumeScheduled = !1, Q.emit("resume"), qe(Q), te.flowing && !te.reading && Q.read(0);
                }
                rt.prototype.pause = function() {
                  return j("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (j("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
                };
                function qe(Q) {
                  var te = Q._readableState;
                  for (j("flow", te.flowing); te.flowing && Q.read() !== null; )
                    ;
                }
                rt.prototype.wrap = function(Q) {
                  var te = this, De = this._readableState, nt = !1;
                  Q.on("end", function() {
                    if (j("wrapped end"), De.decoder && !De.ended) {
                      var V = De.decoder.end();
                      V && V.length && te.push(V);
                    }
                    te.push(null);
                  }), Q.on("data", function(V) {
                    if (j("wrapped data"), De.decoder && (V = De.decoder.write(V)), !(De.objectMode && V == null) && !(!De.objectMode && (!V || !V.length))) {
                      var ve = te.push(V);
                      ve || (nt = !0, Q.pause());
                    }
                  });
                  for (var be in Q)
                    this[be] === void 0 && typeof Q[be] == "function" && (this[be] = /* @__PURE__ */ function(ve) {
                      return function() {
                        return Q[ve].apply(Q, arguments);
                      };
                    }(be));
                  for (var G = 0; G < Qe.length; G++)
                    Q.on(Qe[G], this.emit.bind(this, Qe[G]));
                  return this._read = function(V) {
                    j("wrapped _read", V), nt && (nt = !1, Q.resume());
                  }, this;
                }, typeof Symbol == "function" && (rt.prototype[Symbol.asyncIterator] = function() {
                  return ge === void 0 && (ge = m(262)), ge(this);
                }), Object.defineProperty(rt.prototype, "readableHighWaterMark", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: !1,
                  get: function() {
                    return this._readableState.highWaterMark;
                  }
                }), Object.defineProperty(rt.prototype, "readableBuffer", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: !1,
                  get: function() {
                    return this._readableState && this._readableState.buffer;
                  }
                }), Object.defineProperty(rt.prototype, "readableFlowing", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: !1,
                  get: function() {
                    return this._readableState.flowing;
                  },
                  set: function(te) {
                    this._readableState && (this._readableState.flowing = te);
                  }
                }), rt._fromList = pe, Object.defineProperty(rt.prototype, "readableLength", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: !1,
                  get: function() {
                    return this._readableState.length;
                  }
                });
                function pe(Q, te) {
                  if (te.length === 0)
                    return null;
                  var De;
                  return te.objectMode ? De = te.buffer.shift() : !Q || Q >= te.length ? (te.decoder ? De = te.buffer.join("") : te.buffer.length === 1 ? De = te.buffer.first() : De = te.buffer.concat(te.length), te.buffer.clear()) : De = te.buffer.consume(Q, te.decoder), De;
                }
                function _e(Q) {
                  var te = Q._readableState;
                  j("endReadable", te.endEmitted), te.endEmitted || (te.ended = !0, process.nextTick(Xe, te, Q));
                }
                function Xe(Q, te) {
                  if (j("endReadableNT", Q.endEmitted, Q.length), !Q.endEmitted && Q.length === 0 && (Q.endEmitted = !0, te.readable = !1, te.emit("end"), Q.autoDestroy)) {
                    var De = te._writableState;
                    (!De || De.autoDestroy && De.finished) && te.destroy();
                  }
                }
                typeof Symbol == "function" && (rt.from = function(Q, te) {
                  return we === void 0 && (we = m(260)), we(rt, Q, te);
                });
                function lt(Q, te) {
                  for (var De = 0, nt = Q.length; De < nt; De++)
                    if (Q[De] === te)
                      return De;
                  return -1;
                }
              }
            ),
            /***/
            969: (
              /***/
              function(p, d, m) {
                p.exports = L;
                var y = m(50).q, S = y.ERR_METHOD_NOT_IMPLEMENTED, x = y.ERR_MULTIPLE_CALLBACK, w = y.ERR_TRANSFORM_ALREADY_TRANSFORMING, k = y.ERR_TRANSFORM_WITH_LENGTH_0, O = m(298);
                m(409)(L, O);
                function T(J, ie) {
                  var K = this._transformState;
                  K.transforming = !1;
                  var re = K.writecb;
                  if (re === null)
                    return this.emit("error", new x());
                  K.writechunk = null, K.writecb = null, ie != null && this.push(ie), re(J);
                  var ee = this._readableState;
                  ee.reading = !1, (ee.needReadable || ee.length < ee.highWaterMark) && this._read(ee.highWaterMark);
                }
                function L(J) {
                  if (!(this instanceof L))
                    return new L(J);
                  O.call(this, J), this._transformState = {
                    afterTransform: T.bind(this),
                    needTransform: !1,
                    transforming: !1,
                    writecb: null,
                    writechunk: null,
                    writeencoding: null
                  }, this._readableState.needReadable = !0, this._readableState.sync = !1, J && (typeof J.transform == "function" && (this._transform = J.transform), typeof J.flush == "function" && (this._flush = J.flush)), this.on("prefinish", j);
                }
                function j() {
                  var J = this;
                  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(ie, K) {
                    z(J, ie, K);
                  }) : z(this, null, null);
                }
                L.prototype.push = function(J, ie) {
                  return this._transformState.needTransform = !1, O.prototype.push.call(this, J, ie);
                }, L.prototype._transform = function(J, ie, K) {
                  K(new S("_transform()"));
                }, L.prototype._write = function(J, ie, K) {
                  var re = this._transformState;
                  if (re.writecb = K, re.writechunk = J, re.writeencoding = ie, !re.transforming) {
                    var ee = this._readableState;
                    (re.needTransform || ee.needReadable || ee.length < ee.highWaterMark) && this._read(ee.highWaterMark);
                  }
                }, L.prototype._read = function(J) {
                  var ie = this._transformState;
                  ie.writechunk !== null && !ie.transforming ? (ie.transforming = !0, this._transform(ie.writechunk, ie.writeencoding, ie.afterTransform)) : ie.needTransform = !0;
                }, L.prototype._destroy = function(J, ie) {
                  O.prototype._destroy.call(this, J, function(K) {
                    ie(K);
                  });
                };
                function z(J, ie, K) {
                  if (ie)
                    return J.emit("error", ie);
                  if (K != null && J.push(K), J._writableState.length)
                    throw new k();
                  if (J._transformState.transforming)
                    throw new w();
                  return J.push(null);
                }
              }
            ),
            /***/
            880: (
              /***/
              function(p, d, m) {
                p.exports = Ie;
                function y(qe) {
                  var pe = this;
                  this.next = null, this.entry = null, this.finish = function() {
                    Ft(pe, qe);
                  };
                }
                var S;
                Ie.WritableState = Qe;
                var x = {
                  deprecate: m(485)
                }, w = m(786), k = m(636).Buffer, O = m.g.Uint8Array || function() {
                };
                function T(qe) {
                  return k.from(qe);
                }
                function L(qe) {
                  return k.isBuffer(qe) || qe instanceof O;
                }
                var j = m(974), z = m(754), J = z.getHighWaterMark, ie = m(50).q, K = ie.ERR_INVALID_ARG_TYPE, re = ie.ERR_METHOD_NOT_IMPLEMENTED, ee = ie.ERR_MULTIPLE_CALLBACK, de = ie.ERR_STREAM_CANNOT_PIPE, Ce = ie.ERR_STREAM_DESTROYED, he = ie.ERR_STREAM_NULL_VALUES, oe = ie.ERR_STREAM_WRITE_AFTER_END, ge = ie.ERR_UNKNOWN_ENCODING, we = j.errorOrDestroy;
                m(409)(Ie, w);
                function Oe() {
                }
                function Qe(qe, pe, _e) {
                  S = S || m(298), qe = qe || {}, typeof _e != "boolean" && (_e = pe instanceof S), this.objectMode = !!qe.objectMode, _e && (this.objectMode = this.objectMode || !!qe.writableObjectMode), this.highWaterMark = J(this, qe, "writableHighWaterMark", _e), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
                  var Xe = qe.decodeStrings === !1;
                  this.decodeStrings = !Xe, this.defaultEncoding = qe.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(lt) {
                    Ve(pe, lt);
                  }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = qe.emitClose !== !1, this.autoDestroy = !!qe.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new y(this);
                }
                Qe.prototype.getBuffer = function() {
                  for (var pe = this.bufferedRequest, _e = []; pe; )
                    _e.push(pe), pe = pe.next;
                  return _e;
                }, function() {
                  try {
                    Object.defineProperty(Qe.prototype, "buffer", {
                      get: x.deprecate(function() {
                        return this.getBuffer();
                      }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                    });
                  } catch {
                  }
                }();
                var Me;
                typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Me = Function.prototype[Symbol.hasInstance], Object.defineProperty(Ie, Symbol.hasInstance, {
                  value: function(pe) {
                    return Me.call(this, pe) ? !0 : this !== Ie ? !1 : pe && pe._writableState instanceof Qe;
                  }
                })) : Me = function(pe) {
                  return pe instanceof this;
                };
                function Ie(qe) {
                  S = S || m(298);
                  var pe = this instanceof S;
                  if (!pe && !Me.call(Ie, this))
                    return new Ie(qe);
                  this._writableState = new Qe(qe, this, pe), this.writable = !0, qe && (typeof qe.write == "function" && (this._write = qe.write), typeof qe.writev == "function" && (this._writev = qe.writev), typeof qe.destroy == "function" && (this._destroy = qe.destroy), typeof qe.final == "function" && (this._final = qe.final)), w.call(this);
                }
                Ie.prototype.pipe = function() {
                  we(this, new de());
                };
                function rt(qe, pe) {
                  var _e = new oe();
                  we(qe, _e), process.nextTick(pe, _e);
                }
                function ot(qe, pe, _e, Xe) {
                  var lt;
                  return _e === null ? lt = new he() : typeof _e != "string" && !pe.objectMode && (lt = new K("chunk", ["string", "Buffer"], _e)), lt ? (we(qe, lt), process.nextTick(Xe, lt), !1) : !0;
                }
                Ie.prototype.write = function(qe, pe, _e) {
                  var Xe = this._writableState, lt = !1, Q = !Xe.objectMode && L(qe);
                  return Q && !k.isBuffer(qe) && (qe = T(qe)), typeof pe == "function" && (_e = pe, pe = null), Q ? pe = "buffer" : pe || (pe = Xe.defaultEncoding), typeof _e != "function" && (_e = Oe), Xe.ending ? rt(this, _e) : (Q || ot(this, Xe, qe, _e)) && (Xe.pendingcb++, lt = gt(this, Xe, Q, qe, pe, _e)), lt;
                }, Ie.prototype.cork = function() {
                  this._writableState.corked++;
                }, Ie.prototype.uncork = function() {
                  var qe = this._writableState;
                  qe.corked && (qe.corked--, !qe.writing && !qe.corked && !qe.bufferProcessing && qe.bufferedRequest && We(this, qe));
                }, Ie.prototype.setDefaultEncoding = function(pe) {
                  if (typeof pe == "string" && (pe = pe.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((pe + "").toLowerCase()) > -1))
                    throw new ge(pe);
                  return this._writableState.defaultEncoding = pe, this;
                }, Object.defineProperty(Ie.prototype, "writableBuffer", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: !1,
                  get: function() {
                    return this._writableState && this._writableState.getBuffer();
                  }
                });
                function Et(qe, pe, _e) {
                  return !qe.objectMode && qe.decodeStrings !== !1 && typeof pe == "string" && (pe = k.from(pe, _e)), pe;
                }
                Object.defineProperty(Ie.prototype, "writableHighWaterMark", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: !1,
                  get: function() {
                    return this._writableState.highWaterMark;
                  }
                });
                function gt(qe, pe, _e, Xe, lt, Q) {
                  if (!_e) {
                    var te = Et(pe, Xe, lt);
                    Xe !== te && (_e = !0, lt = "buffer", Xe = te);
                  }
                  var De = pe.objectMode ? 1 : Xe.length;
                  pe.length += De;
                  var nt = pe.length < pe.highWaterMark;
                  if (nt || (pe.needDrain = !0), pe.writing || pe.corked) {
                    var be = pe.lastBufferedRequest;
                    pe.lastBufferedRequest = {
                      chunk: Xe,
                      encoding: lt,
                      isBuf: _e,
                      callback: Q,
                      next: null
                    }, be ? be.next = pe.lastBufferedRequest : pe.bufferedRequest = pe.lastBufferedRequest, pe.bufferedRequestCount += 1;
                  } else
                    At(qe, pe, !1, De, Xe, lt, Q);
                  return nt;
                }
                function At(qe, pe, _e, Xe, lt, Q, te) {
                  pe.writelen = Xe, pe.writecb = te, pe.writing = !0, pe.sync = !0, pe.destroyed ? pe.onwrite(new Ce("write")) : _e ? qe._writev(lt, pe.onwrite) : qe._write(lt, Q, pe.onwrite), pe.sync = !1;
                }
                function Mt(qe, pe, _e, Xe, lt) {
                  --pe.pendingcb, _e ? (process.nextTick(lt, Xe), process.nextTick(tt, qe, pe), qe._writableState.errorEmitted = !0, we(qe, Xe)) : (lt(Xe), qe._writableState.errorEmitted = !0, we(qe, Xe), tt(qe, pe));
                }
                function St(qe) {
                  qe.writing = !1, qe.writecb = null, qe.length -= qe.writelen, qe.writelen = 0;
                }
                function Ve(qe, pe) {
                  var _e = qe._writableState, Xe = _e.sync, lt = _e.writecb;
                  if (typeof lt != "function")
                    throw new ee();
                  if (St(_e), pe)
                    Mt(qe, _e, Xe, pe, lt);
                  else {
                    var Q = ze(_e) || qe.destroyed;
                    !Q && !_e.corked && !_e.bufferProcessing && _e.bufferedRequest && We(qe, _e), Xe ? process.nextTick(Ue, qe, _e, Q, lt) : Ue(qe, _e, Q, lt);
                  }
                }
                function Ue(qe, pe, _e, Xe) {
                  _e || He(qe, pe), pe.pendingcb--, Xe(), tt(qe, pe);
                }
                function He(qe, pe) {
                  pe.length === 0 && pe.needDrain && (pe.needDrain = !1, qe.emit("drain"));
                }
                function We(qe, pe) {
                  pe.bufferProcessing = !0;
                  var _e = pe.bufferedRequest;
                  if (qe._writev && _e && _e.next) {
                    var Xe = pe.bufferedRequestCount, lt = new Array(Xe), Q = pe.corkedRequestsFree;
                    Q.entry = _e;
                    for (var te = 0, De = !0; _e; )
                      lt[te] = _e, _e.isBuf || (De = !1), _e = _e.next, te += 1;
                    lt.allBuffers = De, At(qe, pe, !0, pe.length, lt, "", Q.finish), pe.pendingcb++, pe.lastBufferedRequest = null, Q.next ? (pe.corkedRequestsFree = Q.next, Q.next = null) : pe.corkedRequestsFree = new y(pe), pe.bufferedRequestCount = 0;
                  } else {
                    for (; _e; ) {
                      var nt = _e.chunk, be = _e.encoding, G = _e.callback, V = pe.objectMode ? 1 : nt.length;
                      if (At(qe, pe, !1, V, nt, be, G), _e = _e.next, pe.bufferedRequestCount--, pe.writing)
                        break;
                    }
                    _e === null && (pe.lastBufferedRequest = null);
                  }
                  pe.bufferedRequest = _e, pe.bufferProcessing = !1;
                }
                Ie.prototype._write = function(qe, pe, _e) {
                  _e(new re("_write()"));
                }, Ie.prototype._writev = null, Ie.prototype.end = function(qe, pe, _e) {
                  var Xe = this._writableState;
                  return typeof qe == "function" ? (_e = qe, qe = null, pe = null) : typeof pe == "function" && (_e = pe, pe = null), qe != null && this.write(qe, pe), Xe.corked && (Xe.corked = 1, this.uncork()), Xe.ending || wt(this, Xe, _e), this;
                }, Object.defineProperty(Ie.prototype, "writableLength", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: !1,
                  get: function() {
                    return this._writableState.length;
                  }
                });
                function ze(qe) {
                  return qe.ending && qe.length === 0 && qe.bufferedRequest === null && !qe.finished && !qe.writing;
                }
                function at(qe, pe) {
                  qe._final(function(_e) {
                    pe.pendingcb--, _e && we(qe, _e), pe.prefinished = !0, qe.emit("prefinish"), tt(qe, pe);
                  });
                }
                function Ye(qe, pe) {
                  !pe.prefinished && !pe.finalCalled && (typeof qe._final == "function" && !pe.destroyed ? (pe.pendingcb++, pe.finalCalled = !0, process.nextTick(at, qe, pe)) : (pe.prefinished = !0, qe.emit("prefinish")));
                }
                function tt(qe, pe) {
                  var _e = ze(pe);
                  if (_e && (Ye(qe, pe), pe.pendingcb === 0 && (pe.finished = !0, qe.emit("finish"), pe.autoDestroy))) {
                    var Xe = qe._readableState;
                    (!Xe || Xe.autoDestroy && Xe.endEmitted) && qe.destroy();
                  }
                  return _e;
                }
                function wt(qe, pe, _e) {
                  pe.ending = !0, tt(qe, pe), _e && (pe.finished ? process.nextTick(_e) : qe.once("finish", _e)), pe.ended = !0, qe.writable = !1;
                }
                function Ft(qe, pe, _e) {
                  var Xe = qe.entry;
                  for (qe.entry = null; Xe; ) {
                    var lt = Xe.callback;
                    pe.pendingcb--, lt(_e), Xe = Xe.next;
                  }
                  pe.corkedRequestsFree.next = qe;
                }
                Object.defineProperty(Ie.prototype, "destroyed", {
                  // making it explicit this property is not enumerable
                  // because otherwise some prototype manipulation in
                  // userland will fail
                  enumerable: !1,
                  get: function() {
                    return this._writableState === void 0 ? !1 : this._writableState.destroyed;
                  },
                  set: function(pe) {
                    this._writableState && (this._writableState.destroyed = pe);
                  }
                }), Ie.prototype.destroy = j.destroy, Ie.prototype._undestroy = j.undestroy, Ie.prototype._destroy = function(qe, pe) {
                  pe(qe);
                };
              }
            ),
            /***/
            262: (
              /***/
              function(p, d, m) {
                var y;
                function S(he, oe, ge) {
                  return oe in he ? Object.defineProperty(he, oe, { value: ge, enumerable: !0, configurable: !0, writable: !0 }) : he[oe] = ge, he;
                }
                var x = m(678), w = Symbol("lastResolve"), k = Symbol("lastReject"), O = Symbol("error"), T = Symbol("ended"), L = Symbol("lastPromise"), j = Symbol("handlePromise"), z = Symbol("stream");
                function J(he, oe) {
                  return {
                    value: he,
                    done: oe
                  };
                }
                function ie(he) {
                  var oe = he[w];
                  if (oe !== null) {
                    var ge = he[z].read();
                    ge !== null && (he[L] = null, he[w] = null, he[k] = null, oe(J(ge, !1)));
                  }
                }
                function K(he) {
                  process.nextTick(ie, he);
                }
                function re(he, oe) {
                  return function(ge, we) {
                    he.then(function() {
                      if (oe[T]) {
                        ge(J(void 0, !0));
                        return;
                      }
                      oe[j](ge, we);
                    }, we);
                  };
                }
                var ee = Object.getPrototypeOf(function() {
                }), de = Object.setPrototypeOf((y = {
                  get stream() {
                    return this[z];
                  },
                  next: function() {
                    var oe = this, ge = this[O];
                    if (ge !== null)
                      return Promise.reject(ge);
                    if (this[T])
                      return Promise.resolve(J(void 0, !0));
                    if (this[z].destroyed)
                      return new Promise(function(Me, Ie) {
                        process.nextTick(function() {
                          oe[O] ? Ie(oe[O]) : Me(J(void 0, !0));
                        });
                      });
                    var we = this[L], Oe;
                    if (we)
                      Oe = new Promise(re(we, this));
                    else {
                      var Qe = this[z].read();
                      if (Qe !== null)
                        return Promise.resolve(J(Qe, !1));
                      Oe = new Promise(this[j]);
                    }
                    return this[L] = Oe, Oe;
                  }
                }, S(y, Symbol.asyncIterator, function() {
                  return this;
                }), S(y, "return", function() {
                  var oe = this;
                  return new Promise(function(ge, we) {
                    oe[z].destroy(null, function(Oe) {
                      if (Oe) {
                        we(Oe);
                        return;
                      }
                      ge(J(void 0, !0));
                    });
                  });
                }), y), ee), Ce = function(oe) {
                  var ge, we = Object.create(de, (ge = {}, S(ge, z, {
                    value: oe,
                    writable: !0
                  }), S(ge, w, {
                    value: null,
                    writable: !0
                  }), S(ge, k, {
                    value: null,
                    writable: !0
                  }), S(ge, O, {
                    value: null,
                    writable: !0
                  }), S(ge, T, {
                    value: oe._readableState.endEmitted,
                    writable: !0
                  }), S(ge, j, {
                    value: function(Qe, Me) {
                      var Ie = we[z].read();
                      Ie ? (we[L] = null, we[w] = null, we[k] = null, Qe(J(Ie, !1))) : (we[w] = Qe, we[k] = Me);
                    },
                    writable: !0
                  }), ge));
                  return we[L] = null, x(oe, function(Oe) {
                    if (Oe && Oe.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                      var Qe = we[k];
                      Qe !== null && (we[L] = null, we[w] = null, we[k] = null, Qe(Oe)), we[O] = Oe;
                      return;
                    }
                    var Me = we[w];
                    Me !== null && (we[L] = null, we[w] = null, we[k] = null, Me(J(void 0, !0))), we[T] = !0;
                  }), oe.on("readable", K.bind(null, we)), we;
                };
                p.exports = Ce;
              }
            ),
            /***/
            346: (
              /***/
              function(p, d, m) {
                function y(K, re) {
                  var ee = Object.keys(K);
                  if (Object.getOwnPropertySymbols) {
                    var de = Object.getOwnPropertySymbols(K);
                    re && (de = de.filter(function(Ce) {
                      return Object.getOwnPropertyDescriptor(K, Ce).enumerable;
                    })), ee.push.apply(ee, de);
                  }
                  return ee;
                }
                function S(K) {
                  for (var re = 1; re < arguments.length; re++) {
                    var ee = arguments[re] != null ? arguments[re] : {};
                    re % 2 ? y(Object(ee), !0).forEach(function(de) {
                      x(K, de, ee[de]);
                    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(K, Object.getOwnPropertyDescriptors(ee)) : y(Object(ee)).forEach(function(de) {
                      Object.defineProperty(K, de, Object.getOwnPropertyDescriptor(ee, de));
                    });
                  }
                  return K;
                }
                function x(K, re, ee) {
                  return re in K ? Object.defineProperty(K, re, { value: ee, enumerable: !0, configurable: !0, writable: !0 }) : K[re] = ee, K;
                }
                function w(K, re) {
                  if (!(K instanceof re))
                    throw new TypeError("Cannot call a class as a function");
                }
                function k(K, re) {
                  for (var ee = 0; ee < re.length; ee++) {
                    var de = re[ee];
                    de.enumerable = de.enumerable || !1, de.configurable = !0, "value" in de && (de.writable = !0), Object.defineProperty(K, de.key, de);
                  }
                }
                function O(K, re, ee) {
                  return re && k(K.prototype, re), K;
                }
                var T = m(636), L = T.Buffer, j = m(854), z = j.inspect, J = z && z.custom || "inspect";
                function ie(K, re, ee) {
                  L.prototype.copy.call(K, re, ee);
                }
                p.exports = /* @__PURE__ */ function() {
                  function K() {
                    w(this, K), this.head = null, this.tail = null, this.length = 0;
                  }
                  return O(K, [{
                    key: "push",
                    value: function(ee) {
                      var de = {
                        data: ee,
                        next: null
                      };
                      this.length > 0 ? this.tail.next = de : this.head = de, this.tail = de, ++this.length;
                    }
                  }, {
                    key: "unshift",
                    value: function(ee) {
                      var de = {
                        data: ee,
                        next: this.head
                      };
                      this.length === 0 && (this.tail = de), this.head = de, ++this.length;
                    }
                  }, {
                    key: "shift",
                    value: function() {
                      if (this.length !== 0) {
                        var ee = this.head.data;
                        return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ee;
                      }
                    }
                  }, {
                    key: "clear",
                    value: function() {
                      this.head = this.tail = null, this.length = 0;
                    }
                  }, {
                    key: "join",
                    value: function(ee) {
                      if (this.length === 0)
                        return "";
                      for (var de = this.head, Ce = "" + de.data; de = de.next; )
                        Ce += ee + de.data;
                      return Ce;
                    }
                  }, {
                    key: "concat",
                    value: function(ee) {
                      if (this.length === 0)
                        return L.alloc(0);
                      for (var de = L.allocUnsafe(ee >>> 0), Ce = this.head, he = 0; Ce; )
                        ie(Ce.data, de, he), he += Ce.data.length, Ce = Ce.next;
                      return de;
                    }
                    // Consumes a specified amount of bytes or characters from the buffered data.
                  }, {
                    key: "consume",
                    value: function(ee, de) {
                      var Ce;
                      return ee < this.head.data.length ? (Ce = this.head.data.slice(0, ee), this.head.data = this.head.data.slice(ee)) : ee === this.head.data.length ? Ce = this.shift() : Ce = de ? this._getString(ee) : this._getBuffer(ee), Ce;
                    }
                  }, {
                    key: "first",
                    value: function() {
                      return this.head.data;
                    }
                    // Consumes a specified amount of characters from the buffered data.
                  }, {
                    key: "_getString",
                    value: function(ee) {
                      var de = this.head, Ce = 1, he = de.data;
                      for (ee -= he.length; de = de.next; ) {
                        var oe = de.data, ge = ee > oe.length ? oe.length : ee;
                        if (ge === oe.length ? he += oe : he += oe.slice(0, ee), ee -= ge, ee === 0) {
                          ge === oe.length ? (++Ce, de.next ? this.head = de.next : this.head = this.tail = null) : (this.head = de, de.data = oe.slice(ge));
                          break;
                        }
                        ++Ce;
                      }
                      return this.length -= Ce, he;
                    }
                    // Consumes a specified amount of bytes from the buffered data.
                  }, {
                    key: "_getBuffer",
                    value: function(ee) {
                      var de = L.allocUnsafe(ee), Ce = this.head, he = 1;
                      for (Ce.data.copy(de), ee -= Ce.data.length; Ce = Ce.next; ) {
                        var oe = Ce.data, ge = ee > oe.length ? oe.length : ee;
                        if (oe.copy(de, de.length - ee, 0, ge), ee -= ge, ee === 0) {
                          ge === oe.length ? (++he, Ce.next ? this.head = Ce.next : this.head = this.tail = null) : (this.head = Ce, Ce.data = oe.slice(ge));
                          break;
                        }
                        ++he;
                      }
                      return this.length -= he, de;
                    }
                    // Make sure the linked list only shows the minimal necessary information.
                  }, {
                    key: J,
                    value: function(ee, de) {
                      return z(this, S({}, de, {
                        // Only inspect one level.
                        depth: 0,
                        // It should not recurse.
                        customInspect: !1
                      }));
                    }
                  }]), K;
                }();
              }
            ),
            /***/
            974: (
              /***/
              function(p) {
                function d(k, O) {
                  var T = this, L = this._readableState && this._readableState.destroyed, j = this._writableState && this._writableState.destroyed;
                  return L || j ? (O ? O(k) : k && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process.nextTick(x, this, k)) : process.nextTick(x, this, k)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(k || null, function(z) {
                    !O && z ? T._writableState ? T._writableState.errorEmitted ? process.nextTick(y, T) : (T._writableState.errorEmitted = !0, process.nextTick(m, T, z)) : process.nextTick(m, T, z) : O ? (process.nextTick(y, T), O(z)) : process.nextTick(y, T);
                  }), this);
                }
                function m(k, O) {
                  x(k, O), y(k);
                }
                function y(k) {
                  k._writableState && !k._writableState.emitClose || k._readableState && !k._readableState.emitClose || k.emit("close");
                }
                function S() {
                  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
                }
                function x(k, O) {
                  k.emit("error", O);
                }
                function w(k, O) {
                  var T = k._readableState, L = k._writableState;
                  T && T.autoDestroy || L && L.autoDestroy ? k.destroy(O) : k.emit("error", O);
                }
                p.exports = {
                  destroy: d,
                  undestroy: S,
                  errorOrDestroy: w
                };
              }
            ),
            /***/
            678: (
              /***/
              function(p, d, m) {
                var y = m(50).q.ERR_STREAM_PREMATURE_CLOSE;
                function S(O) {
                  var T = !1;
                  return function() {
                    if (!T) {
                      T = !0;
                      for (var L = arguments.length, j = new Array(L), z = 0; z < L; z++)
                        j[z] = arguments[z];
                      O.apply(this, j);
                    }
                  };
                }
                function x() {
                }
                function w(O) {
                  return O.setHeader && typeof O.abort == "function";
                }
                function k(O, T, L) {
                  if (typeof T == "function")
                    return k(O, null, T);
                  T || (T = {}), L = S(L || x);
                  var j = T.readable || T.readable !== !1 && O.readable, z = T.writable || T.writable !== !1 && O.writable, J = function() {
                    O.writable || K();
                  }, ie = O._writableState && O._writableState.finished, K = function() {
                    z = !1, ie = !0, j || L.call(O);
                  }, re = O._readableState && O._readableState.endEmitted, ee = function() {
                    j = !1, re = !0, z || L.call(O);
                  }, de = function(ge) {
                    L.call(O, ge);
                  }, Ce = function() {
                    var ge;
                    if (j && !re)
                      return (!O._readableState || !O._readableState.ended) && (ge = new y()), L.call(O, ge);
                    if (z && !ie)
                      return (!O._writableState || !O._writableState.ended) && (ge = new y()), L.call(O, ge);
                  }, he = function() {
                    O.req.on("finish", K);
                  };
                  return w(O) ? (O.on("complete", K), O.on("abort", Ce), O.req ? he() : O.on("request", he)) : z && !O._writableState && (O.on("end", J), O.on("close", J)), O.on("end", ee), O.on("finish", K), T.error !== !1 && O.on("error", de), O.on("close", Ce), function() {
                    O.removeListener("complete", K), O.removeListener("abort", Ce), O.removeListener("request", he), O.req && O.req.removeListener("finish", K), O.removeListener("end", J), O.removeListener("close", J), O.removeListener("finish", K), O.removeListener("end", ee), O.removeListener("error", de), O.removeListener("close", Ce);
                  };
                }
                p.exports = k;
              }
            ),
            /***/
            260: (
              /***/
              function(p) {
                p.exports = function() {
                  throw new Error("Readable.from is not available in the browser");
                };
              }
            ),
            /***/
            732: (
              /***/
              function(p, d, m) {
                var y;
                function S(K) {
                  var re = !1;
                  return function() {
                    re || (re = !0, K.apply(void 0, arguments));
                  };
                }
                var x = m(50).q, w = x.ERR_MISSING_ARGS, k = x.ERR_STREAM_DESTROYED;
                function O(K) {
                  if (K)
                    throw K;
                }
                function T(K) {
                  return K.setHeader && typeof K.abort == "function";
                }
                function L(K, re, ee, de) {
                  de = S(de);
                  var Ce = !1;
                  K.on("close", function() {
                    Ce = !0;
                  }), y === void 0 && (y = m(678)), y(K, {
                    readable: re,
                    writable: ee
                  }, function(oe) {
                    if (oe)
                      return de(oe);
                    Ce = !0, de();
                  });
                  var he = !1;
                  return function(oe) {
                    if (!Ce && !he) {
                      if (he = !0, T(K))
                        return K.abort();
                      if (typeof K.destroy == "function")
                        return K.destroy();
                      de(oe || new k("pipe"));
                    }
                  };
                }
                function j(K) {
                  K();
                }
                function z(K, re) {
                  return K.pipe(re);
                }
                function J(K) {
                  return !K.length || typeof K[K.length - 1] != "function" ? O : K.pop();
                }
                function ie() {
                  for (var K = arguments.length, re = new Array(K), ee = 0; ee < K; ee++)
                    re[ee] = arguments[ee];
                  var de = J(re);
                  if (Array.isArray(re[0]) && (re = re[0]), re.length < 2)
                    throw new w("streams");
                  var Ce, he = re.map(function(oe, ge) {
                    var we = ge < re.length - 1, Oe = ge > 0;
                    return L(oe, we, Oe, function(Qe) {
                      Ce || (Ce = Qe), Qe && he.forEach(j), !we && (he.forEach(j), de(Ce));
                    });
                  });
                  return re.reduce(z);
                }
                p.exports = ie;
              }
            ),
            /***/
            754: (
              /***/
              function(p, d, m) {
                var y = m(50).q.ERR_INVALID_OPT_VALUE;
                function S(w, k, O) {
                  return w.highWaterMark != null ? w.highWaterMark : k ? w[O] : null;
                }
                function x(w, k, O, T) {
                  var L = S(k, T, O);
                  if (L != null) {
                    if (!(isFinite(L) && Math.floor(L) === L) || L < 0) {
                      var j = T ? O : "highWaterMark";
                      throw new y(j, L);
                    }
                    return Math.floor(L);
                  }
                  return w.objectMode ? 16 : 16384;
                }
                p.exports = {
                  getHighWaterMark: x
                };
              }
            ),
            /***/
            786: (
              /***/
              function(p, d, m) {
                p.exports = m(722).EventEmitter;
              }
            ),
            /***/
            769: (
              /***/
              function(p, d, m) {
                p.exports = x;
                var y = m(722).EventEmitter, S = m(409);
                S(x, y), x.Readable = m(58), x.Writable = m(880), x.Duplex = m(298), x.Transform = m(969), x.PassThrough = m(4), x.finished = m(678), x.pipeline = m(732), x.Stream = x;
                function x() {
                  y.call(this);
                }
                x.prototype.pipe = function(w, k) {
                  var O = this;
                  function T(re) {
                    w.writable && w.write(re) === !1 && O.pause && O.pause();
                  }
                  O.on("data", T);
                  function L() {
                    O.readable && O.resume && O.resume();
                  }
                  w.on("drain", L), !w._isStdio && (!k || k.end !== !1) && (O.on("end", z), O.on("close", J));
                  var j = !1;
                  function z() {
                    j || (j = !0, w.end());
                  }
                  function J() {
                    j || (j = !0, typeof w.destroy == "function" && w.destroy());
                  }
                  function ie(re) {
                    if (K(), y.listenerCount(this, "error") === 0)
                      throw re;
                  }
                  O.on("error", ie), w.on("error", ie);
                  function K() {
                    O.removeListener("data", T), w.removeListener("drain", L), O.removeListener("end", z), O.removeListener("close", J), O.removeListener("error", ie), w.removeListener("error", ie), O.removeListener("end", K), O.removeListener("close", K), w.removeListener("close", K);
                  }
                  return O.on("end", K), O.on("close", K), w.on("close", K), w.emit("pipe", O), w;
                };
              }
            ),
            /***/
            183: (
              /***/
              function(p, d, m) {
                var y = m(805).Buffer, S = y.isEncoding || function(he) {
                  switch (he = "" + he, he && he.toLowerCase()) {
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                    case "raw":
                      return !0;
                    default:
                      return !1;
                  }
                };
                function x(he) {
                  if (!he)
                    return "utf8";
                  for (var oe; ; )
                    switch (he) {
                      case "utf8":
                      case "utf-8":
                        return "utf8";
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return "utf16le";
                      case "latin1":
                      case "binary":
                        return "latin1";
                      case "base64":
                      case "ascii":
                      case "hex":
                        return he;
                      default:
                        if (oe)
                          return;
                        he = ("" + he).toLowerCase(), oe = !0;
                    }
                }
                function w(he) {
                  var oe = x(he);
                  if (typeof oe != "string" && (y.isEncoding === S || !S(he)))
                    throw new Error("Unknown encoding: " + he);
                  return oe || he;
                }
                d.s = k;
                function k(he) {
                  this.encoding = w(he);
                  var oe;
                  switch (this.encoding) {
                    case "utf16le":
                      this.text = ie, this.end = K, oe = 4;
                      break;
                    case "utf8":
                      this.fillLast = j, oe = 4;
                      break;
                    case "base64":
                      this.text = re, this.end = ee, oe = 3;
                      break;
                    default:
                      this.write = de, this.end = Ce;
                      return;
                  }
                  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = y.allocUnsafe(oe);
                }
                k.prototype.write = function(he) {
                  if (he.length === 0)
                    return "";
                  var oe, ge;
                  if (this.lastNeed) {
                    if (oe = this.fillLast(he), oe === void 0)
                      return "";
                    ge = this.lastNeed, this.lastNeed = 0;
                  } else
                    ge = 0;
                  return ge < he.length ? oe ? oe + this.text(he, ge) : this.text(he, ge) : oe || "";
                }, k.prototype.end = J, k.prototype.text = z, k.prototype.fillLast = function(he) {
                  if (this.lastNeed <= he.length)
                    return he.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
                  he.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, he.length), this.lastNeed -= he.length;
                };
                function O(he) {
                  return he <= 127 ? 0 : he >> 5 === 6 ? 2 : he >> 4 === 14 ? 3 : he >> 3 === 30 ? 4 : he >> 6 === 2 ? -1 : -2;
                }
                function T(he, oe, ge) {
                  var we = oe.length - 1;
                  if (we < ge)
                    return 0;
                  var Oe = O(oe[we]);
                  return Oe >= 0 ? (Oe > 0 && (he.lastNeed = Oe - 1), Oe) : --we < ge || Oe === -2 ? 0 : (Oe = O(oe[we]), Oe >= 0 ? (Oe > 0 && (he.lastNeed = Oe - 2), Oe) : --we < ge || Oe === -2 ? 0 : (Oe = O(oe[we]), Oe >= 0 ? (Oe > 0 && (Oe === 2 ? Oe = 0 : he.lastNeed = Oe - 3), Oe) : 0));
                }
                function L(he, oe, ge) {
                  if ((oe[0] & 192) !== 128)
                    return he.lastNeed = 0, "�";
                  if (he.lastNeed > 1 && oe.length > 1) {
                    if ((oe[1] & 192) !== 128)
                      return he.lastNeed = 1, "�";
                    if (he.lastNeed > 2 && oe.length > 2 && (oe[2] & 192) !== 128)
                      return he.lastNeed = 2, "�";
                  }
                }
                function j(he) {
                  var oe = this.lastTotal - this.lastNeed, ge = L(this, he);
                  if (ge !== void 0)
                    return ge;
                  if (this.lastNeed <= he.length)
                    return he.copy(this.lastChar, oe, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
                  he.copy(this.lastChar, oe, 0, he.length), this.lastNeed -= he.length;
                }
                function z(he, oe) {
                  var ge = T(this, he, oe);
                  if (!this.lastNeed)
                    return he.toString("utf8", oe);
                  this.lastTotal = ge;
                  var we = he.length - (ge - this.lastNeed);
                  return he.copy(this.lastChar, 0, we), he.toString("utf8", oe, we);
                }
                function J(he) {
                  var oe = he && he.length ? this.write(he) : "";
                  return this.lastNeed ? oe + "�" : oe;
                }
                function ie(he, oe) {
                  if ((he.length - oe) % 2 === 0) {
                    var ge = he.toString("utf16le", oe);
                    if (ge) {
                      var we = ge.charCodeAt(ge.length - 1);
                      if (we >= 55296 && we <= 56319)
                        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = he[he.length - 2], this.lastChar[1] = he[he.length - 1], ge.slice(0, -1);
                    }
                    return ge;
                  }
                  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = he[he.length - 1], he.toString("utf16le", oe, he.length - 1);
                }
                function K(he) {
                  var oe = he && he.length ? this.write(he) : "";
                  if (this.lastNeed) {
                    var ge = this.lastTotal - this.lastNeed;
                    return oe + this.lastChar.toString("utf16le", 0, ge);
                  }
                  return oe;
                }
                function re(he, oe) {
                  var ge = (he.length - oe) % 3;
                  return ge === 0 ? he.toString("base64", oe) : (this.lastNeed = 3 - ge, this.lastTotal = 3, ge === 1 ? this.lastChar[0] = he[he.length - 1] : (this.lastChar[0] = he[he.length - 2], this.lastChar[1] = he[he.length - 1]), he.toString("base64", oe, he.length - ge));
                }
                function ee(he) {
                  var oe = he && he.length ? this.write(he) : "";
                  return this.lastNeed ? oe + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : oe;
                }
                function de(he) {
                  return he.toString(this.encoding);
                }
                function Ce(he) {
                  return he && he.length ? this.write(he) : "";
                }
              }
            ),
            /***/
            805: (
              /***/
              function(p, d, m) {
                /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
                var y = m(636), S = y.Buffer;
                function x(k, O) {
                  for (var T in k)
                    O[T] = k[T];
                }
                S.from && S.alloc && S.allocUnsafe && S.allocUnsafeSlow ? p.exports = y : (x(y, d), d.Buffer = w);
                function w(k, O, T) {
                  return S(k, O, T);
                }
                w.prototype = Object.create(S.prototype), x(S, w), w.from = function(k, O, T) {
                  if (typeof k == "number")
                    throw new TypeError("Argument must not be a number");
                  return S(k, O, T);
                }, w.alloc = function(k, O, T) {
                  if (typeof k != "number")
                    throw new TypeError("Argument must be a number");
                  var L = S(k);
                  return O !== void 0 ? typeof T == "string" ? L.fill(O, T) : L.fill(O) : L.fill(0), L;
                }, w.allocUnsafe = function(k) {
                  if (typeof k != "number")
                    throw new TypeError("Argument must be a number");
                  return S(k);
                }, w.allocUnsafeSlow = function(k) {
                  if (typeof k != "number")
                    throw new TypeError("Argument must be a number");
                  return y.SlowBuffer(k);
                };
              }
            ),
            /***/
            863: (
              /***/
              function(p, d, m) {
                d.__esModule = !0, d.default = void 0;
                var y = z(m(695)), S = z(m(175)), x = z(m(867)), w = z(m(383)), k = z(m(440)), O = z(m(494)), T = z(m(948)), L = z(m(873)), j = z(m(895));
                function z(St) {
                  return St && St.__esModule ? St : {
                    default: St
                  };
                }
                function J(St, Ve) {
                  return encodeURIComponent(St) + "=" + encodeURIComponent((0, T.default)(Ve) || (0, j.default)(Ve) ? "" : Ve);
                }
                function ie(St, Ve, Ue) {
                  (0, w.default)(Ve) ? (0, y.default)(Ve, function(He, We) {
                    ie(St + "[" + ((0, L.default)(He) ? We : "") + "]", He, Ue);
                  }) : (0, L.default)(Ve) ? (0, S.default)(Ve, function(He, We) {
                    ie(St + "[" + We + "]", He, Ue);
                  }) : Ue.push(J(St, Ve));
                }
                function K(St) {
                  if (!St || (0, k.default)(St))
                    return "";
                  var Ve = [];
                  return (0, S.default)(St, function(Ue, He) {
                    ie(He, Ue, Ve);
                  }), Ve.join("&");
                }
                var re = function() {
                  return {
                    baseURL: "",
                    headers: {
                      common: {},
                      get: {},
                      post: {},
                      put: {},
                      delete: {},
                      patch: {},
                      options: {},
                      head: {}
                    },
                    serializer: K
                  };
                }, ee = /^(http|https):\/\//i;
                function de(St, Ve) {
                  return ee.test(Ve) ? Ve : (St.slice(-1) === "/" && Ve.slice(0, 1) === "/" && (Ve = Ve.slice(1)), St + Ve);
                }
                function Ce(St, Ve) {
                  var Ue = St.baseURL, He = St.headers, We = St.serializer, ze = St.beforeRequest, at = St.success, Ye = St.error, tt = St.complete, wt = Ve.url, Ft = Ve.contentType, qe = Ve.method, pe = Ve.params, _e = Ve.headers, Xe = Ve.serializer, lt = Ve.beforeRequest, Q = Ve.success, te = Ve.error, De = Ve.complete, nt = Ve.withCredentials, be = Ve.mimeType, G = {
                    url: de(Ue, wt),
                    method: qe,
                    params: pe,
                    headers: (0, x.default)(He.common, He[qe.toLowerCase()], _e),
                    serializer: Xe || We || K,
                    beforeRequest: [ze, lt],
                    success: [at, Q],
                    error: [Ye, te],
                    complete: [tt, De],
                    withCredentials: nt,
                    mimeType: be
                  };
                  return G.contentType = Ft || G.headers["Content-Type"], delete G.headers["Content-Type"], G;
                }
                function he(St) {
                  return St >= 200 && St < 300;
                }
                function oe(St) {
                  return /^(?:POST|PUT|PATCH)$/.test(St.toUpperCase());
                }
                function ge(St, Ve) {
                  (0, w.default)(St) ? (0, y.default)(St, function(Ue) {
                    return ge(Ue, Ve);
                  }) : (0, O.default)(St) && St(Ve);
                }
                function we(St) {
                  var Ve = {};
                  return (0, y.default)(St.split(`\r
`), function(Ue) {
                    var He = Ue.split(": "), We = He[0], ze = He[1];
                    We !== "" && !(0, j.default)(ze) && (Ve[We] = ze);
                  }), Ve;
                }
                function Oe(St) {
                  var Ve = "";
                  try {
                    Ve = JSON.parse(St);
                  } catch {
                    Ve = St;
                  }
                  return Ve;
                }
                var Qe = 4;
                function Me(St, Ve) {
                  var Ue = St.readyState;
                  if (Ue == Qe) {
                    var He = St.status, We = St.statusText, ze = St.responseText, at = Ve.success, Ye = Ve.resolve, tt = Ve.error, wt = Ve.reject, Ft = Ve.complete;
                    if (he(He)) {
                      var qe = St.getResponseHeader("Content-Type"), pe = ze;
                      qe && qe.indexOf("application/json") > -1 && (pe = Oe(pe)), ge([at, Ye], {
                        status: He,
                        statusText: We,
                        data: pe,
                        headers: we(St.getAllResponseHeaders())
                      });
                    } else
                      ge([tt, wt], {
                        status: He,
                        statusText: We
                      });
                    ge(Ft, {
                      status: He,
                      statusText: We
                    });
                  }
                }
                var Ie = /\?/;
                function rt(St, Ve) {
                  var Ue = Ve.url, He = Ve.method, We = Ve.serializer, ze = Ve.params, at = Ue;
                  if (!oe(He) && ze) {
                    var Ye = (Ie.test(Ue) ? "&" : "?") + We(ze);
                    at = "" + Ue + Ye;
                  }
                  St.open(He, at);
                }
                function ot(St, Ve) {
                  var Ue = Ve.method, He = Ve.contentType, We = Ve.mimeType, ze = Ve.headers, at = Ve.withCredentials, Ye = at === void 0 ? !1 : at;
                  Ye && (St.withCredentials = Ye), We && St.overrideMimeType(We), (0, S.default)(ze, function(tt, wt) {
                    (0, L.default)(tt) || St.setRequestHeader(wt, tt);
                  }), oe(Ue) && St.setRequestHeader("Content-Type", He + "; charset=UTF-8"), St.setRequestHeader("x-requested-with", "XMLHttpRequest");
                }
                var Et = /%20/g;
                function gt(St, Ve) {
                  var Ue = Ve.method, He = Ve.serializer, We = Ve.beforeRequest, ze = Ve.params, at = ze === void 0 ? {} : ze, Ye = Ve.contentType, tt = Ye === void 0 ? "application/x-www-form-urlencoded" : Ye, wt = null;
                  oe(Ue) && (wt = tt.indexOf("application/x-www-form-urlencoded") > -1 ? He(at).replace(Et, "+") : JSON.stringify(at)), St.onreadystatechange = function() {
                    return Me(St, Ve);
                  }, ge(We, St), St.send(wt);
                }
                function At(St) {
                  var Ve = new XMLHttpRequest(), Ue = function(We) {
                    return (0, y.default)([rt, ot, gt], function(ze) {
                      return ze(Ve, We);
                    });
                  };
                  return St = Ce(At.defaults, St), typeof Promise < "u" ? new Promise(function(He, We) {
                    Ue((0, x.default)(St, {
                      resolve: He,
                      reject: We
                    }));
                  }) : (Ue(St), null);
                }
                At.defaults = re(), At._reset = function() {
                  At.defaults = re();
                }, At._request = function(St, Ve, Ue) {
                  return Ue === void 0 && (Ue = {}), At((0, x.default)(Ue, {
                    url: St,
                    method: Ve
                  }));
                }, (0, y.default)(["get", "post", "put", "delete", "patch", "options", "head"], function(St) {
                  At[St] = function(Ve, Ue) {
                    return At._request(Ve, St.toUpperCase(), Ue);
                  };
                });
                var Mt = At;
                d.default = Mt, p.exports = d.default;
              }
            ),
            /***/
            187: (
              /***/
              function(p, d, m) {
                var y = m(383);
                function S(x, w, k) {
                  var O, T;
                  if (k = k || 0, !y(w))
                    return -1;
                  if (Array.prototype.indexOf)
                    return Array.prototype.indexOf.call(w, x, k);
                  for (T = w.length, O = k; k >= 0 && O < T; O += 1)
                    if (w[O] === x)
                      return O;
                  return -1;
                }
                p.exports = S;
              }
            ),
            /***/
            695: (
              /***/
              function(p) {
                function d(m, y, S) {
                  var x = 0, w = m.length;
                  for (S = S || null; x < w && y.call(S, m[x], x, m) !== !1; x += 1)
                    ;
                }
                p.exports = d;
              }
            ),
            /***/
            175: (
              /***/
              function(p) {
                function d(m, y, S) {
                  var x;
                  S = S || null;
                  for (x in m)
                    if (m.hasOwnProperty(x) && y.call(S, m[x], x, m) === !1)
                      break;
                }
                p.exports = d;
              }
            ),
            /***/
            867: (
              /***/
              function(p) {
                function d(m, y) {
                  var S = Object.prototype.hasOwnProperty, x, w, k, O;
                  for (k = 1, O = arguments.length; k < O; k += 1) {
                    x = arguments[k];
                    for (w in x)
                      S.call(x, w) && (m[w] = x[w]);
                  }
                  return m;
                }
                p.exports = d;
              }
            ),
            /***/
            947: (
              /***/
              function(p, d, m) {
                var y = m(325);
                function S(x) {
                  var w = y(x) && (Object.prototype.toString.call(x) === "[object Arguments]" || !!x.callee);
                  return w;
                }
                p.exports = S;
              }
            ),
            /***/
            383: (
              /***/
              function(p) {
                function d(m) {
                  return m instanceof Array;
                }
                p.exports = d;
              }
            ),
            /***/
            440: (
              /***/
              function(p, d, m) {
                var y = m(994), S = m(325), x = m(383), w = m(947), k = m(873), O = m(494);
                function T(z) {
                  return y(z) && z === "";
                }
                function L(z) {
                  var J;
                  for (J in z)
                    if (z.hasOwnProperty(J))
                      return !0;
                  return !1;
                }
                function j(z) {
                  return !S(z) || T(z) ? !0 : x(z) || w(z) ? z.length === 0 : k(z) && !O(z) ? !L(z) : !0;
                }
                p.exports = j;
              }
            ),
            /***/
            325: (
              /***/
              function(p, d, m) {
                var y = m(895), S = m(948);
                function x(w) {
                  return !y(w) && !S(w);
                }
                p.exports = x;
              }
            ),
            /***/
            494: (
              /***/
              function(p) {
                function d(m) {
                  return m instanceof Function;
                }
                p.exports = d;
              }
            ),
            /***/
            948: (
              /***/
              function(p) {
                function d(m) {
                  return m === null;
                }
                p.exports = d;
              }
            ),
            /***/
            873: (
              /***/
              function(p) {
                function d(m) {
                  return m === Object(m);
                }
                p.exports = d;
              }
            ),
            /***/
            994: (
              /***/
              function(p) {
                function d(m) {
                  return typeof m == "string" || m instanceof String;
                }
                p.exports = d;
              }
            ),
            /***/
            895: (
              /***/
              function(p) {
                function d(m) {
                  return m === void 0;
                }
                p.exports = d;
              }
            ),
            /***/
            485: (
              /***/
              function(p, d, m) {
                p.exports = y;
                function y(x, w) {
                  if (S("noDeprecation"))
                    return x;
                  var k = !1;
                  function O() {
                    if (!k) {
                      if (S("throwDeprecation"))
                        throw new Error(w);
                      S("traceDeprecation") ? console.trace(w) : console.warn(w), k = !0;
                    }
                    return x.apply(this, arguments);
                  }
                  return O;
                }
                function S(x) {
                  try {
                    if (!m.g.localStorage)
                      return !1;
                  } catch {
                    return !1;
                  }
                  var w = m.g.localStorage[x];
                  return w == null ? !1 : String(w).toLowerCase() === "true";
                }
              }
            ),
            /***/
            203: (
              /***/
              function(p) {
                p.exports = r;
              }
            ),
            /***/
            854: (
              /***/
              function() {
              }
            ),
            /***/
            602: (
              /***/
              function() {
              }
            )
            /******/
          }, l = {};
          function c(p) {
            var d = l[p];
            if (d !== void 0)
              return d.exports;
            var m = l[p] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            return s[p](m, m.exports, c), m.exports;
          }
          (function() {
            c.n = function(p) {
              var d = p && p.__esModule ? (
                /******/
                function() {
                  return p.default;
                }
              ) : (
                /******/
                function() {
                  return p;
                }
              );
              return c.d(d, { a: d }), d;
            };
          })(), function() {
            c.d = function(p, d) {
              for (var m in d)
                c.o(d, m) && !c.o(p, m) && Object.defineProperty(p, m, { enumerable: !0, get: d[m] });
            };
          }(), function() {
            c.g = function() {
              if (typeof globalThis == "object") return globalThis;
              try {
                return this || new Function("return this")();
              } catch {
                if (typeof window == "object") return window;
              }
            }();
          }(), function() {
            c.o = function(p, d) {
              return Object.prototype.hasOwnProperty.call(p, d);
            };
          }();
          var f = {};
          return function() {
            c.d(f, {
              default: function() {
                return (
                  /* binding */
                  lt
                );
              }
            });
            var p = c(203), d = /* @__PURE__ */ c.n(p), m = c(994), y = /* @__PURE__ */ c.n(m), S = c(895), x = /* @__PURE__ */ c.n(S), w = c(187), k = /* @__PURE__ */ c.n(w), O = c(867), T = /* @__PURE__ */ c.n(O), L = c(863), j = /* @__PURE__ */ c.n(L), z = {};
            z.RELAXED = !1, z.IGNORE_RECORD_LENGTH = !1, z.IGNORE_QUOTES = !1, z.LINE_FEED_OK = !0, z.CARRIAGE_RETURN_OK = !0, z.DETECT_TYPES = !0, z.IGNORE_QUOTE_WHITESPACE = !0, z.DEBUG = !1, z.COLUMN_SEPARATOR = ",", z.ERROR_EOF = "UNEXPECTED_END_OF_FILE", z.ERROR_CHAR = "UNEXPECTED_CHARACTER", z.ERROR_EOL = "UNEXPECTED_END_OF_RECORD", z.WARN_SPACE = "UNEXPECTED_WHITESPACE";
            var J = '"', ie = "\r", K = `
`, re = " ", ee = "	", de = 0, Ce = 1, he = 2, oe = 4;
            z.parse = function(Q) {
              var te = z.result = [];
              z.COLUMN_SEPARATOR = z.COLUMN_SEPARATOR instanceof RegExp ? new RegExp("^" + z.COLUMN_SEPARATOR.source) : z.COLUMN_SEPARATOR, z.offset = 0, z.str = Q, z.record_begin(), z.debug("parse()", Q);
              for (var De; ; ) {
                if (De = Q[z.offset++], z.debug("c", De), De == null) {
                  z.escaped && z.error(z.ERROR_EOF), z.record && (z.token_end(), z.record_end()), z.debug("...bail", De, z.state, z.record), z.reset();
                  break;
                }
                if (z.record == null) {
                  if (z.RELAXED && (De == K || De == ie && Q[z.offset + 1] == K))
                    continue;
                  z.record_begin();
                }
                if (z.state == de) {
                  if ((De === re || De === ee) && z.next_nonspace() == J) {
                    if (z.RELAXED || z.IGNORE_QUOTE_WHITESPACE)
                      continue;
                    z.warn(z.WARN_SPACE);
                  }
                  if (De == J && !z.IGNORE_QUOTES) {
                    z.debug("...escaped start", De), z.escaped = !0, z.state = Ce;
                    continue;
                  }
                  z.state = Ce;
                }
                if (z.state == Ce && z.escaped) {
                  De == J ? Q[z.offset] == J ? (z.debug("...escaped quote", De), z.token += J, z.offset++) : (z.debug("...escaped end", De), z.escaped = !1, z.state = he) : (z.token += De, z.debug("...escaped add", De, z.token));
                  continue;
                }
                De == ie ? (Q[z.offset] == K ? z.offset++ : z.CARRIAGE_RETURN_OK || z.error(z.ERROR_CHAR), z.token_end(), z.record_end()) : De == K ? (z.LINE_FEED_OK || z.RELAXED || z.error(z.ERROR_CHAR), z.token_end(), z.record_end()) : z.test_regex_separator(Q) || z.COLUMN_SEPARATOR == De ? z.token_end() : z.state == Ce ? (z.token += De, z.debug("...add", De, z.token)) : De === re || De === ee ? z.IGNORE_QUOTE_WHITESPACE || z.error(z.WARN_SPACE) : z.RELAXED || z.error(z.ERROR_CHAR);
              }
              return te;
            }, z.stream = function() {
              var Q = c(769), te = new Q.Transform({ objectMode: !0 });
              return te.EOL = `
`, te.prior = "", te.emitter = /* @__PURE__ */ function(De) {
                return function(nt) {
                  De.push(z.parse(nt + De.EOL));
                };
              }(te), te._transform = function(De, nt, be) {
                var G = this.prior == "" ? De.toString().split(this.EOL) : (this.prior + De.toString()).split(this.EOL);
                this.prior = G.pop(), G.forEach(this.emitter), be();
              }, te._flush = function(De) {
                this.prior != "" && (this.emitter(this.prior), this.prior = ""), De();
              }, te;
            }, z.test_regex_separator = function(Q) {
              if (!(z.COLUMN_SEPARATOR instanceof RegExp))
                return !1;
              var te;
              return Q = Q.slice(z.offset - 1), te = z.COLUMN_SEPARATOR.exec(Q), te && (z.offset += te[0].length - 1), te !== null;
            }, z.stream.json = function() {
              var Q = c(983);
              c(769);
              var te = new streamTransform({ objectMode: !0 });
              return te._transform = function(De, nt, be) {
                te.push(JSON.stringify(De.toString()) + Q.EOL), be();
              }, te;
            }, z.reset = function() {
              z.state = null, z.token = null, z.escaped = null, z.record = null, z.offset = null, z.result = null, z.str = null;
            }, z.next_nonspace = function() {
              for (var Q = z.offset, te; Q < z.str.length; )
                if (te = z.str[Q++], !(te == re || te === ee))
                  return te;
              return null;
            }, z.record_begin = function() {
              z.escaped = !1, z.record = [], z.token_begin(), z.debug("record_begin");
            }, z.record_end = function() {
              z.state = oe, !(z.IGNORE_RECORD_LENGTH || z.RELAXED) && z.result.length > 0 && z.record.length != z.result[0].length && z.error(z.ERROR_EOL), z.result.push(z.record), z.debug("record end", z.record), z.record = null;
            }, z.resolve_type = function(Q) {
              return Q.match(/^[-+]?[0-9]+(\.[0-9]+)?([eE][-+]?[0-9]+)?$/) ? Q = parseFloat(Q) : Q.match(/^(true|false)$/i) ? Q = !!Q.match(/true/i) : Q === "undefined" ? Q = void 0 : Q === "null" && (Q = null), Q;
            }, z.token_begin = function() {
              z.state = de, z.token = "";
            }, z.token_end = function() {
              z.DETECT_TYPES && (z.token = z.resolve_type(z.token)), z.record.push(z.token), z.debug("token end", z.token), z.token_begin();
            }, z.debug = function() {
              z.DEBUG && console.log(arguments);
            }, z.dump = function(Q) {
              return [
                Q,
                "at char",
                z.offset,
                ":",
                z.str.substr(z.offset - 50, 50).replace(/\r/gm, "\\r").replace(/\n/gm, "\\n").replace(/\t/gm, "\\t")
              ].join(" ");
            }, z.error = function(Q) {
              var te = z.dump(Q);
              throw z.reset(), te;
            }, z.warn = function(Q) {
              if (z.DEBUG) {
                var te = z.dump(Q);
                try {
                  console.warn(te);
                  return;
                } catch {
                }
                try {
                  console.log(te);
                } catch {
                }
              }
            };
            var ge = z;
            function we(Q) {
              return Q.replace(/(^(\s*[\n\r])+)|([\n\r]+\s*$)/g, "");
            }
            function Oe(Q) {
              var te = Number(Q);
              return !isNaN(te) && isFinite(te);
            }
            function Qe(Q, te, De) {
              var nt;
              return te > De && (nt = [te, De], De = nt[0], te = nt[1]), Math.max(te, Math.min(Q, De));
            }
            var Me = function() {
              return Me = Object.assign || function(Q) {
                for (var te, De = 1, nt = arguments.length; De < nt; De++) {
                  te = arguments[De];
                  for (var be in te) Object.prototype.hasOwnProperty.call(te, be) && (Q[be] = te[be]);
                }
                return Q;
              }, Me.apply(this, arguments);
            };
            ge.IGNORE_QUOTE_WHITESPACE = !1, ge.IGNORE_RECORD_LENGTH = !0, ge.DETECT_TYPES = !1;
            var Ie = /[\n\r]/, rt = /([^:]+)?:?(.*)/, ot = /\s+/, Et = [",", "	"], gt = 2, At = ["bar", "column", "line", "area", "pie"], Mt = ["line", "area"], St = {
              minWidth: 0,
              maxWidth: 1 / 0,
              minHeight: 0,
              maxHeight: 1 / 0,
              height: "auto",
              width: "auto"
            }, Ve = ["type", "url"], Ue = {
              bar: d().barChart,
              column: d().columnChart,
              area: d().areaChart,
              line: d().lineChart,
              pie: d().pieChart
            }, He = {};
            function We(Q, te) {
              var De;
              Q = we(Q);
              var nt = Q.split(/\n{2,}/), be = nt[0], G = nt[1], V = tt(be), ve = (De = V == null ? void 0 : V.editorChart) === null || De === void 0 ? void 0 : De.url;
              if (y()(ve)) {
                var Ne = function(Gt) {
                  var Jt = Gt.data;
                  te({ data: at(Jt), options: tt(be) });
                }, it = function() {
                  return te();
                };
                j().get(ve, { success: Ne, error: it });
              } else {
                var yt = at(be), $t = tt(G);
                te({ data: yt, options: $t });
              }
            }
            function ze(Q) {
              var te = ot, De = 0;
              return Q = we(Q), Et.forEach(function(nt) {
                var be = Q.match(new RegExp(nt, "g"));
                (be == null ? void 0 : be.length) > Math.max(gt, De) && (te = nt, De = be.length);
              }), te;
            }
            function at(Q, te) {
              Q = we(Q), ge.COLUMN_SEPARATOR = ze(Q);
              var De = ge.parse(Q);
              De = De.map(function(it) {
                return it.map(function(yt) {
                  return yt.trim();
                });
              });
              var nt = De[0].filter(function(it, yt) {
                return yt > 0;
              }).reduce(function(it, yt) {
                return it || !Oe(yt);
              }, !1), be = nt ? De.shift() : [], G = De.slice(1).reduce(function(it, yt) {
                return it || !Oe(yt[0]);
              }, !1), V = G ? De.map(function(it) {
                return it.shift();
              }) : [];
              G && be.shift();
              var ve = De[0].map(function(it, yt) {
                return De.map(function($t) {
                  return parseFloat($t[yt]);
                });
              }), Ne = ve.map(function(it, yt) {
                return nt ? {
                  name: be[yt],
                  data: it
                } : {
                  data: it
                };
              });
              return { categories: V, series: Ne };
            }
            function Ye(Q) {
              var te = Q.trim().split("."), De = te[0];
              return k()(De, Ve) >= 0 ? te.unshift("editorChart") : te.length === 1 ? te.unshift("chart") : (De === "x" || De === "y") && (te[0] = De + "Axis"), te;
            }
            function tt(Q) {
              var te = {};
              if (!x()(Q)) {
                var De = Q.split(Ie);
                De.forEach(function(nt) {
                  var be = nt.match(rt);
                  if (be) {
                    var G = be[1], V = be[2];
                    if (V) {
                      try {
                        V = JSON.parse(V.trim());
                      } catch {
                        V = V.trim();
                      }
                      var ve = Ye(G), Ne = te;
                      ve.forEach(function(it, yt) {
                        Ne[it] = Ne[it] || (ve.length - 1 === yt ? V : {}), Ne = Ne[it];
                      });
                    }
                  }
                });
              }
              return te;
            }
            function wt(Q, te) {
              return Q === "auto" ? te : Q;
            }
            function Ft(Q, te, De) {
              var nt = T()(Me({}, St), te), be = nt.maxWidth, G = nt.minWidth, V = nt.maxHeight, ve = nt.minHeight, Ne = De.getBoundingClientRect().width, it = Q.chart, yt = it.width, $t = yt === void 0 ? nt.width : yt, Gt = it.height, Jt = Gt === void 0 ? nt.height : Gt;
              return $t = wt($t, Ne), Jt = wt(Jt, Ne), {
                width: Qe($t, G, be),
                height: Qe(Jt, ve, V)
              };
            }
            function qe(Q, te, De) {
              Q = T()({
                editorChart: {},
                chart: {},
                exportMenu: {}
              }, Q);
              var nt = Ft(Q, te, De), be = nt.width, G = nt.height;
              return Q.chart.width = be, Q.chart.height = G, Q.editorChart.type = Q.editorChart.type || "column", Q.exportMenu.visible = !!Q.exportMenu.visible, Q;
            }
            function pe() {
              Object.keys(He).forEach(function(Q) {
                var te = document.querySelector("[data-chart-id=" + Q + "]");
                te || (He[Q].destroy(), delete He[Q]);
              });
            }
            function _e(Q, te, De, nt) {
              var be = document.querySelector("[data-chart-id=" + Q + "]");
              if (pe(), be)
                try {
                  We(te, function(G) {
                    var V = G || {}, ve = V.data, Ne = V.options, it = qe(Ne, nt, be), yt = it.editorChart.type;
                    if (!ve || Mt.indexOf(yt) > -1 && ve.categories.length !== ve.series[0].data.length)
                      be.innerHTML = "invalid chart data";
                    else if (At.indexOf(yt) < 0)
                      be.innerHTML = "invalid chart type. type: bar, column, line, area, pie";
                    else {
                      var $t = Ue[yt];
                      it.usageStatistics = De, He[Q] = $t({ el: be, data: ve, options: it });
                    }
                  });
                } catch {
                  be.innerHTML = "invalid chart data";
                }
            }
            function Xe() {
              return "chart-" + Math.random().toString(36).substr(2, 10);
            }
            function lt(Q, te) {
              var De = Q.usageStatistics, nt = De === void 0 ? !0 : De;
              return {
                toHTMLRenderers: {
                  chart: function(be) {
                    var G = Xe();
                    return setTimeout(function() {
                      _e(G, be.literal, nt, te);
                    }), [
                      {
                        type: "openTag",
                        tagName: "div",
                        outerNewLine: !0,
                        attributes: { "data-chart-id": G }
                      },
                      { type: "closeTag", tagName: "div", outerNewLine: !0 }
                    ];
                  }
                }
              };
            }
          }(), f = f.default, f;
        }()
      );
    });
  }(kj)), kj.exports;
}
var Q9e = Z9e();
const eGe = /* @__PURE__ */ Cp(Q9e);
var Cj = { exports: {} };
/*!
 * TOAST UI Editor : Code Syntax Highlight Plugin
 * @version 3.1.0 | Fri Aug 05 2022
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
var uV;
function tGe() {
  return uV || (uV = 1, function() {
    var i = {
      /***/
      928: (
        /***/
        function(l, c, f) {
          var p = f(322);
          function d(m, y, S) {
            var x, w;
            if (S = S || 0, !p(y))
              return -1;
            if (Array.prototype.indexOf)
              return Array.prototype.indexOf.call(y, m, S);
            for (w = y.length, x = S; S >= 0 && x < w; x += 1)
              if (y[x] === m)
                return x;
            return -1;
          }
          l.exports = d;
        }
      ),
      /***/
      690: (
        /***/
        function(l, c, f) {
          var p = f(322), d = f(893), m = f(956);
          function y(S, x, w) {
            p(S) ? d(S, x, w) : m(S, x, w);
          }
          l.exports = y;
        }
      ),
      /***/
      893: (
        /***/
        function(l) {
          function c(f, p, d) {
            var m = 0, y = f.length;
            for (d = d || null; m < y && p.call(d, f[m], m, f) !== !1; m += 1)
              ;
          }
          l.exports = c;
        }
      ),
      /***/
      956: (
        /***/
        function(l) {
          function c(f, p, d) {
            var m;
            d = d || null;
            for (m in f)
              if (f.hasOwnProperty(m) && p.call(d, f[m], m, f) === !1)
                break;
          }
          l.exports = c;
        }
      ),
      /***/
      990: (
        /***/
        function(l, c, f) {
          var p = f(893);
          function d(m) {
            var y;
            try {
              y = Array.prototype.slice.call(m);
            } catch {
              y = [], p(m, function(x) {
                y.push(x);
              });
            }
            return y;
          }
          l.exports = d;
        }
      ),
      /***/
      24: (
        /***/
        function(l, c, f) {
          var p = f(322), d = f(929);
          function m(y, S) {
            if (S = p(S) ? S.join(" ") : S, S = S.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), d(y.className.baseVal)) {
              y.className = S;
              return;
            }
            y.className.baseVal = S;
          }
          l.exports = m;
        }
      ),
      /***/
      204: (
        /***/
        function(l, c, f) {
          var p = f(690), d = f(928), m = f(902), y = f(24);
          function S(x) {
            var w = Array.prototype.slice.call(arguments, 1), k = x.classList, O = [], T;
            if (k) {
              p(w, function(L) {
                x.classList.add(L);
              });
              return;
            }
            T = m(x), T && (w = [].concat(T.split(/\s+/), w)), p(w, function(L) {
              d(L, O) < 0 && O.push(L);
            }), y(x, O);
          }
          l.exports = S;
        }
      ),
      /***/
      522: (
        /***/
        function(l, c, f) {
          var p = f(758), d = f(690);
          function m(y, S, x) {
            var w = y.style;
            if (p(S)) {
              w[S] = x;
              return;
            }
            d(S, function(k, O) {
              w[O] = k;
            });
          }
          l.exports = m;
        }
      ),
      /***/
      902: (
        /***/
        function(l, c, f) {
          var p = f(929);
          function d(m) {
            return !m || !m.className ? "" : p(m.className.baseVal) ? m.className : m.className.baseVal;
          }
          l.exports = d;
        }
      ),
      /***/
      714: (
        /***/
        function(l, c, f) {
          var p = f(928), d = f(902);
          function m(y, S) {
            var x;
            return y.classList ? y.classList.contains(S) : (x = d(y).split(/\s+/), p(S, x) > -1);
          }
          l.exports = m;
        }
      ),
      /***/
      462: (
        /***/
        function(l, c, f) {
          var p = f(893), d = f(928), m = f(902), y = f(24);
          function S(x) {
            var w = Array.prototype.slice.call(arguments, 1), k = x.classList, O, T;
            if (k) {
              p(w, function(L) {
                k.remove(L);
              });
              return;
            }
            O = m(x).split(/\s+/), T = [], p(O, function(L) {
              d(L, w) < 0 && T.push(L);
            }), y(x, T);
          }
          l.exports = S;
        }
      ),
      /***/
      322: (
        /***/
        function(l) {
          function c(f) {
            return f instanceof Array;
          }
          l.exports = c;
        }
      ),
      /***/
      294: (
        /***/
        function(l) {
          function c(f) {
            return f instanceof Function;
          }
          l.exports = c;
        }
      ),
      /***/
      758: (
        /***/
        function(l) {
          function c(f) {
            return typeof f == "string" || f instanceof String;
          }
          l.exports = c;
        }
      ),
      /***/
      929: (
        /***/
        function(l) {
          function c(f) {
            return f === void 0;
          }
          l.exports = c;
        }
      )
      /******/
    }, e = {};
    function r(l) {
      var c = e[l];
      if (c !== void 0)
        return c.exports;
      var f = e[l] = {
        /******/
        // no module.id needed
        /******/
        // no module.loaded needed
        /******/
        exports: {}
        /******/
      };
      return i[l](f, f.exports, r), f.exports;
    }
    (function() {
      r.n = function(l) {
        var c = l && l.__esModule ? (
          /******/
          function() {
            return l.default;
          }
        ) : (
          /******/
          function() {
            return l;
          }
        );
        return r.d(c, { a: c }), c;
      };
    })(), function() {
      r.d = function(l, c) {
        for (var f in c)
          r.o(c, f) && !r.o(l, f) && Object.defineProperty(l, f, { enumerable: !0, get: c[f] });
      };
    }(), function() {
      r.o = function(l, c) {
        return Object.prototype.hasOwnProperty.call(l, c);
      };
    }();
    var s = {};
    (function() {
      r.d(s, {
        default: function() {
          return (
            /* binding */
            at
          );
        }
      });
      var l = r(294), c = /* @__PURE__ */ r.n(l), f = 3;
      function p(Ye) {
        return {
          codeBlock: function(tt) {
            var wt = tt, Ft = wt.fenceLength, qe = wt.info, pe = qe ? qe.split(/\s+/) : [], _e = [], Xe = {};
            Ft > f && (Xe["data-backticks"] = Ft);
            var lt = tt.literal;
            if (pe.length && pe[0].length) {
              var Q = pe[0];
              _e.push("lang-" + Q), Xe["data-language"] = Q;
              var te = Ye.languages[Q];
              te && (lt = Ye.highlight(tt.literal, te, Q));
            }
            return [
              { type: "openTag", tagName: "pre", classNames: _e },
              { type: "openTag", tagName: "code", attributes: Xe },
              { type: "html", content: lt },
              { type: "closeTag", tagName: "code" },
              { type: "closeTag", tagName: "pre" }
            ];
          }
        };
      }
      var d = r(758), m = /* @__PURE__ */ r.n(d);
      function y(Ye) {
        return Ye.reduce(function(tt, wt) {
          return tt.concat(Array.isArray(wt) ? y(wt) : wt);
        }, []);
      }
      var S = function(Ye, tt) {
        for (var wt = 0, Ft = tt.length, qe = Ye.length; wt < Ft; wt++, qe++)
          Ye[qe] = tt[wt];
        return Ye;
      }, x = "codeBlock";
      function w(Ye) {
        var tt = [];
        return Ye.descendants(function(wt, Ft) {
          wt.isBlock && wt.type.name === x && tt.push({ node: wt, pos: Ft });
        }), tt;
      }
      function k(Ye, tt) {
        return tt === void 0 && (tt = []), m()(Ye) ? [{ text: Ye, classes: tt }] : Ye.map(function(wt) {
          var Ft = wt, qe = Ft.type, pe = Ft.alias, _e = [], Xe = [];
          qe && (_e = ["token", qe]), pe && (Xe = m()(pe) ? [pe] : pe);
          var lt = S(S(S([], tt), _e), Xe);
          return m()(wt) ? {
            text: wt,
            classes: lt
          } : k(wt.content, lt);
        });
      }
      function O(Ye, tt, wt) {
        var Ft = tt.pmView, qe = [], pe = w(Ye);
        return pe.forEach(function(_e) {
          var Xe = _e.pos, lt = _e.node, Q = lt.attrs.language, te = wt.languages[Q], De = te ? wt.tokenize(lt.textContent, te) : [], nt = y(k(De)), be = Xe + 1;
          nt.forEach(function(G) {
            var V = G.text, ve = G.classes, Ne = be, it = Ne + V.length;
            be = it;
            var yt = ve.join(" "), $t = Ft.Decoration.inline(Ne, it, {
              class: yt
            });
            yt.length && qe.push($t);
          });
        }), Ft.DecorationSet.create(Ye, qe);
      }
      function T(Ye, tt) {
        return new Ye.pmState.Plugin({
          state: {
            init: function(wt, Ft) {
              var qe = Ft.doc;
              return O(qe, Ye, tt);
            },
            apply: function(wt, Ft) {
              return wt.docChanged ? O(wt.doc, Ye, tt) : Ft.map(wt.mapping, wt.doc);
            }
          },
          props: {
            decorations: function(wt) {
              return this.getState(wt);
            }
          }
        });
      }
      var L = r(204), j = /* @__PURE__ */ r.n(L);
      function z(Ye) {
        return parseInt(Ye, 10);
      }
      function J(Ye, tt, wt) {
        var Ft = z(Ye.left), qe = z(Ye.top), pe = z(Ye.width) + z(Ye.paddingLeft) + z(Ye.paddingRight), _e = z(Ye.height) + z(Ye.paddingTop) + z(Ye.paddingBottom);
        return tt >= Ft && tt <= Ft + pe && wt >= qe && wt <= qe + _e;
      }
      function ie(Ye) {
        Ye.parentNode && Ye.parentNode.removeChild(Ye);
      }
      var K = "toastui-editor-";
      function re() {
        for (var Ye = [], tt = 0; tt < arguments.length; tt++)
          Ye[tt] = arguments[tt];
        return Ye.map(function(wt) {
          return "" + K + wt;
        }).join(" ");
      }
      var ee = r(522), de = /* @__PURE__ */ r.n(ee), Ce = r(462), he = /* @__PURE__ */ r.n(Ce), oe = r(714), ge = /* @__PURE__ */ r.n(oe), we = r(990), Oe = /* @__PURE__ */ r.n(we), Qe = r(928), Me = /* @__PURE__ */ r.n(Qe), Ie = "code-block-language", rt = "code-block-language-input", ot = "code-block-language-list", Et = "data-language", gt = 10;
      function At(Ye) {
        return Ye.map(function(tt) {
          return '<button type="button" data-language="' + tt + '">' + tt + "</button>";
        }).join("");
      }
      var Mt = (
        /** @class */
        function() {
          function Ye(tt, wt, Ft) {
            var qe = this;
            this.buttons = [], this.prevStoredLanguage = "", this.onSelectToggleButton = function(pe) {
              var _e = pe.target, Xe = getComputedStyle(_e, ":after"), lt = pe.offsetX, Q = pe.offsetY;
              J(Xe, lt, Q) && (pe.preventDefault(), qe.toggleFocus());
            }, this.onSelectLanguageButtons = function(pe) {
              var _e = pe.target, Xe = _e.getAttribute(Et);
              Xe && qe.selectLanguage(Xe);
            }, this.handleKeydown = function(pe) {
              var _e = pe.key;
              _e === "ArrowUp" ? (qe.selectPrevLanguage(), pe.preventDefault()) : _e === "ArrowDown" ? (qe.selectNextLanguage(), pe.preventDefault()) : _e === "Enter" || _e === "Tab" ? (qe.storeInputLanguage(), pe.preventDefault()) : qe.hideList();
            }, this.showLangugaeSelectBox = function(pe, _e) {
              var Xe = pe.top, lt = pe.right;
              _e && qe.setLanguage(_e), qe.show();
              var Q = qe.input.parentElement.getBoundingClientRect().width;
              de()(qe.wrapper, {
                top: Xe + gt + "px",
                left: lt - Q - gt + "px"
              }), qe.toggleFocus();
            }, this.rootEl = tt, this.eventEmitter = wt, this.languages = Ft, this.createElement(), this.bindDOMEvent(), this.bindEvent();
          }
          return Ye.prototype.createElement = function() {
            this.wrapper = document.createElement("div"), j()(this.wrapper, re(Ie)), this.createInputElement(), this.createLanguageListElement(), this.rootEl.appendChild(this.wrapper), this.hide();
          }, Ye.prototype.createInputElement = function() {
            var tt = document.createElement("span");
            j()(tt, re(rt));
            var wt = document.createElement("input");
            wt.type = "text", wt.setAttribute("maxlength", "20"), this.input = wt, tt.appendChild(this.input), this.wrapper.appendChild(tt);
          }, Ye.prototype.createLanguageListElement = function() {
            this.list = document.createElement("div"), j()(this.list, re(ot));
            var tt = document.createElement("div");
            j()(tt, "buttons"), tt.innerHTML = At(this.languages), this.buttons = Oe()(tt.children), this.list.appendChild(tt), this.wrapper.appendChild(this.list), this.activateButtonByIndex(0), this.hideList();
          }, Ye.prototype.bindDOMEvent = function() {
            var tt = this;
            this.wrapper.addEventListener("mousedown", this.onSelectToggleButton), this.input.addEventListener("keydown", this.handleKeydown), this.input.addEventListener("focus", function() {
              return tt.activateSelectBox();
            }), this.input.addEventListener("blur", function() {
              return tt.inactivateSelectBox();
            }), this.list.addEventListener("mousedown", this.onSelectLanguageButtons);
          }, Ye.prototype.bindEvent = function() {
            this.eventEmitter.listen("showCodeBlockLanguages", this.showLangugaeSelectBox);
          }, Ye.prototype.activateSelectBox = function() {
            j()(this.wrapper, "active"), de()(this.list, { display: "block" });
          }, Ye.prototype.inactivateSelectBox = function() {
            this.input.value = this.prevStoredLanguage, he()(this.wrapper, "active"), this.hideList();
          }, Ye.prototype.toggleFocus = function() {
            ge()(this.wrapper, "active") ? this.input.blur() : this.input.focus();
          }, Ye.prototype.storeInputLanguage = function() {
            var tt = this.input.value;
            this.setLanguage(tt), this.hideList(), this.eventEmitter.emit("selectLanguage", tt);
          }, Ye.prototype.activateButtonByIndex = function(tt) {
            this.currentButton && he()(this.currentButton, "active"), this.buttons.length && (this.currentButton = this.buttons[tt], this.input.value = this.currentButton.getAttribute(Et), j()(this.currentButton, "active"), this.currentButton.scrollIntoView());
          }, Ye.prototype.selectLanguage = function(tt) {
            this.input.value = tt, this.storeInputLanguage();
          }, Ye.prototype.selectPrevLanguage = function() {
            var tt = Me()(this.currentButton, this.buttons) - 1;
            tt < 0 && (tt = this.buttons.length - 1), this.activateButtonByIndex(tt);
          }, Ye.prototype.selectNextLanguage = function() {
            var tt = Me()(this.currentButton, this.buttons) + 1;
            tt >= this.buttons.length && (tt = 0), this.activateButtonByIndex(tt);
          }, Ye.prototype.hideList = function() {
            de()(this.list, { display: "none" });
          }, Ye.prototype.show = function() {
            de()(this.wrapper, { display: "inline-block" });
          }, Ye.prototype.hide = function() {
            de()(this.wrapper, { display: "none" });
          }, Ye.prototype.setLanguage = function(tt) {
            this.prevStoredLanguage = tt, this.input.value = tt;
            var wt = this.buttons.filter(function(qe) {
              return qe.getAttribute(Et) === tt;
            });
            if (wt.length) {
              var Ft = Me()(wt[0], this.buttons);
              this.activateButtonByIndex(Ft);
            }
          }, Ye.prototype.destroy = function() {
            ie(this.wrapper), this.eventEmitter.removeEventHandler("showCodeBlockLanguages", this.showLangugaeSelectBox);
          }, Ye;
        }()
      ), St = function() {
        return St = Object.assign || function(Ye) {
          for (var tt, wt = 1, Ft = arguments.length; wt < Ft; wt++) {
            tt = arguments[wt];
            for (var qe in tt) Object.prototype.hasOwnProperty.call(tt, qe) && (Ye[qe] = tt[qe]);
          }
          return Ye;
        }, St.apply(this, arguments);
      }, Ve = "ww-code-block-highlighting";
      function Ue(Ye) {
        var tt = Ye.htmlAttrs, wt = Ye.classNames;
        return St(St({}, tt), { class: wt ? wt.join(" ") : null });
      }
      var He = (
        /** @class */
        function() {
          function Ye(tt, wt, Ft, qe, pe) {
            var _e = this;
            this.node = tt, this.view = wt, this.getPos = Ft, this.eventEmitter = qe, this.languages = pe, this.contentDOM = null, this.languageSelectBox = null, this.onSelectLanguage = function(Xe) {
              _e.languageEditing && _e.changeLanguage(Xe);
            }, this.onClickEditingButton = function(Xe) {
              var lt = Xe.target, Q = getComputedStyle(lt, ":after");
              if (Q.backgroundImage !== "none" && c()(_e.getPos)) {
                var te = _e.view.coordsAtPos(_e.getPos());
                _e.openLanguageSelectBox(te);
              }
            }, this.finishLanguageEditing = function() {
              _e.languageEditing && _e.reset();
            }, this.node = tt, this.view = wt, this.getPos = Ft, this.eventEmitter = qe, this.languageEditing = !1, this.languages = pe, this.createElement(), this.bindDOMEvent(), this.bindEvent();
          }
          return Ye.prototype.createElement = function() {
            var tt = this.node.attrs.language, wt = document.createElement("div");
            wt.setAttribute("data-language", tt || "text"), j()(wt, re(Ve));
            var Ft = this.createCodeBlockElement(), qe = Ft.firstChild;
            tt && (j()(Ft, "language-" + tt), j()(qe, "language-" + tt)), wt.appendChild(Ft), this.dom = wt, this.contentDOM = qe;
          }, Ye.prototype.createCodeBlockElement = function() {
            var tt = document.createElement("pre"), wt = document.createElement("code"), Ft = this.node.attrs.language, qe = Ue(this.node.attrs);
            return Ft && wt.setAttribute("data-language", Ft), Object.keys(qe).forEach(function(pe) {
              qe[pe] && tt.setAttribute(pe, qe[pe]);
            }), tt.appendChild(wt), tt;
          }, Ye.prototype.bindDOMEvent = function() {
            this.dom && (this.dom.addEventListener("click", this.onClickEditingButton), this.view.dom.addEventListener("mousedown", this.finishLanguageEditing), window.addEventListener("resize", this.finishLanguageEditing));
          }, Ye.prototype.bindEvent = function() {
            this.eventEmitter.listen("selectLanguage", this.onSelectLanguage), this.eventEmitter.listen("scroll", this.finishLanguageEditing), this.eventEmitter.listen("finishLanguageEditing", this.finishLanguageEditing);
          }, Ye.prototype.openLanguageSelectBox = function(tt) {
            this.languageSelectBox = new Mt(this.view.dom.parentElement, this.eventEmitter, this.languages), this.eventEmitter.emit("showCodeBlockLanguages", tt, this.node.attrs.language), this.languageEditing = !0;
          }, Ye.prototype.changeLanguage = function(tt) {
            if (c()(this.getPos)) {
              this.reset();
              var wt = this.getPos(), Ft = this.view.state.tr;
              Ft.setNodeMarkup(wt, null, { language: tt }), this.view.dispatch(Ft);
            }
          }, Ye.prototype.reset = function() {
            this.languageSelectBox && (this.languageSelectBox.destroy(), this.languageSelectBox = null), this.languageEditing = !1;
          }, Ye.prototype.stopEvent = function() {
            return !0;
          }, Ye.prototype.update = function(tt) {
            return tt.sameMarkup(this.node) ? (this.node = tt, !0) : !1;
          }, Ye.prototype.destroy = function() {
            this.reset(), this.dom && (this.dom.removeEventListener("click", this.onClickEditingButton), this.view.dom.removeEventListener("mousedown", this.finishLanguageEditing), window.removeEventListener("resize", this.finishLanguageEditing)), this.eventEmitter.removeEventHandler("selectLanguage", this.onSelectLanguage), this.eventEmitter.removeEventHandler("scroll", this.finishLanguageEditing), this.eventEmitter.removeEventHandler("finishLanguageEditing", this.finishLanguageEditing);
          }, Ye;
        }()
      );
      function We(Ye) {
        return function(tt, wt, Ft, qe) {
          return new He(tt, wt, Ft, qe, Ye);
        };
      }
      function ze(Ye, tt) {
        if (tt) {
          var wt = Ye.eventEmitter, Ft = tt.highlighter;
          wt.addEventType("showCodeBlockLanguages"), wt.addEventType("selectLanguage"), wt.addEventType("finishLanguageEditing");
          var qe = Ft.languages, pe = Object.keys(qe).filter(function(_e) {
            return !c()(qe[_e]);
          });
          return {
            toHTMLRenderers: p(Ft),
            wysiwygPlugins: [function() {
              return T(Ye, Ft);
            }],
            wysiwygNodeViews: {
              codeBlock: We(pe)
            }
          };
        }
        return {};
      }
      typeof window !== void 0 && (window.Prism = window.Prism || {}, window.Prism.manual = !0);
      var at = ze;
    })(), Cj.exports = s.default;
  }()), Cj.exports;
}
var rGe = tGe();
const nGe = /* @__PURE__ */ Cp(rGe);
var Tj = { exports: {} }, Aj = { exports: {} };
/*!
 * TOAST UI Color Picker
 * @version 2.2.8
 * @author NHN Cloud FE Development Team <dl_javascript@nhn.com>
 * @license MIT
 */
var cV;
function iGe() {
  return cV || (cV = 1, function(i, e) {
    (function(s, l) {
      i.exports = l();
    })(window, function() {
      return (
        /******/
        function(r) {
          var s = {};
          function l(c) {
            if (s[c])
              return s[c].exports;
            var f = s[c] = {
              /******/
              i: c,
              /******/
              l: !1,
              /******/
              exports: {}
              /******/
            };
            return r[c].call(f.exports, f, f.exports, l), f.l = !0, f.exports;
          }
          return l.m = r, l.c = s, l.d = function(c, f, p) {
            l.o(c, f) || Object.defineProperty(c, f, { enumerable: !0, get: p });
          }, l.r = function(c) {
            typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(c, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(c, "__esModule", { value: !0 });
          }, l.t = function(c, f) {
            if (f & 1 && (c = l(c)), f & 8 || f & 4 && typeof c == "object" && c && c.__esModule) return c;
            var p = /* @__PURE__ */ Object.create(null);
            if (l.r(p), Object.defineProperty(p, "default", { enumerable: !0, value: c }), f & 2 && typeof c != "string") for (var d in c) l.d(p, d, (function(m) {
              return c[m];
            }).bind(null, d));
            return p;
          }, l.n = function(c) {
            var f = c && c.__esModule ? (
              /******/
              function() {
                return c.default;
              }
            ) : (
              /******/
              function() {
                return c;
              }
            );
            return l.d(f, "a", f), f;
          }, l.o = function(c, f) {
            return Object.prototype.hasOwnProperty.call(c, f);
          }, l.p = "dist", l(l.s = 33);
        }([
          /* 0 */
          /***/
          function(r, s, l) {
            function c(f, p) {
              var d = Object.prototype.hasOwnProperty, m, y, S, x;
              for (S = 1, x = arguments.length; S < x; S += 1) {
                m = arguments[S];
                for (y in m)
                  d.call(m, y) && (f[y] = m[y]);
              }
              return f;
            }
            r.exports = c;
          },
          /* 1 */
          /***/
          function(r, s, l) {
            function c(f) {
              return f instanceof Array;
            }
            r.exports = c;
          },
          /* 2 */
          /***/
          function(r, s, l) {
            var c = l(1), f = l(6), p = l(7);
            function d(m, y, S) {
              c(m) ? f(m, y, S) : p(m, y, S);
            }
            r.exports = d;
          },
          /* 3 */
          /***/
          function(r, s, l) {
            function c(f) {
              return f === void 0;
            }
            r.exports = c;
          },
          /* 4 */
          /***/
          function(r, s, l) {
            var c = l(22), f = l(2), p = l(6), d = l(7), m = l(37), y = 0, S = {
              /**
               * Get the number of properties in the object.
               * @param {Object} obj - object
               * @returns {number}
               */
              getLength: function(x) {
                var w = 0;
                return d(x, function() {
                  w += 1;
                }), w;
              },
              /**
               * Constructs a new array by executing the provided callback function.
               * @param {Object|Array} obj - object or array to be traversed
               * @param {function} iteratee - callback function
               * @param {Object} context - context of callback function
               * @returns {Array}
               */
              map: function(x, w, k) {
                var O = [];
                return f(x, function() {
                  O.push(w.apply(k || null, arguments));
                }), O;
              },
              /**
               * Construct a new array with elements that pass the test by the provided callback function.
               * @param {Array|NodeList|Arguments} arr - array to be traversed
               * @param {function} iteratee - callback function
               * @param {Object} context - context of callback function
               * @returns {Array}
               */
              filter: function(x, w, k) {
                var O = [];
                return p(x, function(T) {
                  w.apply(k || null, arguments) && O.push(T);
                }), O;
              },
              /**
               * Create an unique id for a color-picker instance.
               * @returns {number}
               */
              generateId: function() {
                return y += 1, y;
              },
              /**
               * True when browser is below IE8.
               */
              isOldBrowser: function() {
                return c.msie && c.version < 9;
              }(),
              /**
               * send host name
               * @ignore
               */
              sendHostName: function() {
                m("color-picker", "UA-129987462-1");
              }
            };
            r.exports = S;
          },
          /* 5 */
          /***/
          function(r, s, l) {
            var c = l(1);
            function f(p, d, m) {
              var y, S;
              if (m = m || 0, !c(d))
                return -1;
              if (Array.prototype.indexOf)
                return Array.prototype.indexOf.call(d, p, m);
              for (S = d.length, y = m; m >= 0 && y < S; y += 1)
                if (d[y] === p)
                  return y;
              return -1;
            }
            r.exports = f;
          },
          /* 6 */
          /***/
          function(r, s, l) {
            function c(f, p, d) {
              var m = 0, y = f.length;
              for (d = d || null; m < y && p.call(d, f[m], m, f) !== !1; m += 1)
                ;
            }
            r.exports = c;
          },
          /* 7 */
          /***/
          function(r, s, l) {
            function c(f, p, d) {
              var m;
              d = d || null;
              for (m in f)
                if (f.hasOwnProperty(m) && p.call(d, f[m], m, f) === !1)
                  break;
            }
            r.exports = c;
          },
          /* 8 */
          /***/
          function(r, s, l) {
            var c = l(39), f = l(13), p = l(41), d = l(3), m = l(9), y = l(19), S = l(4);
            function x(w, k) {
              var O = S.generateId();
              d(k) && (k = m.appendHTMLElement("div")), c(k, "tui-view-" + O), this.id = O, this.container = k, this.childs = new y(function(T) {
                return T.id;
              }), this.parent = null;
            }
            x.prototype.addChild = function(w, k) {
              k && k.call(w, this), w.parent = this, this.childs.add(w);
            }, x.prototype.removeChild = function(w, k) {
              var O = p(w) ? this.childs.items[w] : w;
              k && k.call(O, this), this.childs.remove(O.id);
            }, x.prototype.render = function() {
              this.childs.each(function(w) {
                w.render();
              });
            }, x.prototype.recursive = function(w, k) {
              f(w) && (k || w(this), this.childs.each(function(O) {
                O.recursive(w);
              }));
            }, x.prototype.resize = function() {
              for (var w = Array.prototype.slice.call(arguments), k = this.parent; k; )
                f(k._onResize) && k._onResize.apply(k, w), k = k.parent;
            }, x.prototype._beforeDestroy = function() {
            }, x.prototype._destroy = function() {
              this._beforeDestroy(), this.container.innerHTML = "", this.id = this.parent = this.childs = this.container = null;
            }, x.prototype.destroy = function(w) {
              this.childs && (this.childs.each(function(k) {
                k.destroy(!0), k._destroy();
              }), this.childs.clear()), !w && this._destroy();
            }, x.prototype.getViewBound = function() {
              var w = this.container.getBoundingClientRect();
              return {
                x: w.left,
                y: w.top,
                width: w.right - w.left,
                height: w.bottom - w.top
              };
            }, r.exports = x;
          },
          /* 9 */
          /***/
          function(r, s, l) {
            var c = {
              /**
               * Create DOM element and return it.
               * @param {string} tagName Tag name to append.
               * @param {HTMLElement} [container] HTML element will be parent to created element.
               * if not supplied, will use **document.body**
               * @param {string} [className] Design class names to appling created element.
               * @returns {HTMLElement} HTML element created.
               */
              appendHTMLElement: function(f, p, d) {
                var m = document.createElement(f);
                return m.className = d || "", p ? p.appendChild(m) : document.body.appendChild(m), m;
              }
            };
            r.exports = c;
          },
          /* 10 */
          /***/
          function(r, s, l) {
            var c = l(0), f = l(20), p = l(11), d = l(21), m = l(1), y = l(13), S = l(2), x = /\s+/g;
            function w() {
              this.events = null, this.contexts = null;
            }
            w.mixin = function(k) {
              c(k.prototype, w.prototype);
            }, w.prototype._getHandlerItem = function(k, O) {
              var T = { handler: k };
              return O && (T.context = O), T;
            }, w.prototype._safeEvent = function(k) {
              var O = this.events, T;
              return O || (O = this.events = {}), k && (T = O[k], T || (T = [], O[k] = T), O = T), O;
            }, w.prototype._safeContext = function() {
              var k = this.contexts;
              return k || (k = this.contexts = []), k;
            }, w.prototype._indexOfContext = function(k) {
              for (var O = this._safeContext(), T = 0; O[T]; ) {
                if (k === O[T][0])
                  return T;
                T += 1;
              }
              return -1;
            }, w.prototype._memorizeContext = function(k) {
              var O, T;
              f(k) && (O = this._safeContext(), T = this._indexOfContext(k), T > -1 ? O[T][1] += 1 : O.push([k, 1]));
            }, w.prototype._forgetContext = function(k) {
              var O, T;
              f(k) && (O = this._safeContext(), T = this._indexOfContext(k), T > -1 && (O[T][1] -= 1, O[T][1] <= 0 && O.splice(T, 1)));
            }, w.prototype._bindEvent = function(k, O, T) {
              var L = this._safeEvent(k);
              this._memorizeContext(T), L.push(this._getHandlerItem(O, T));
            }, w.prototype.on = function(k, O, T) {
              var L = this;
              p(k) ? (k = k.split(x), S(k, function(j) {
                L._bindEvent(j, O, T);
              })) : d(k) && (T = O, S(k, function(j, z) {
                L.on(z, j, T);
              }));
            }, w.prototype.once = function(k, O, T) {
              var L = this;
              if (d(k)) {
                T = O, S(k, function(z, J) {
                  L.once(J, z, T);
                });
                return;
              }
              function j() {
                O.apply(T, arguments), L.off(k, j, T);
              }
              this.on(k, j, T);
            }, w.prototype._spliceMatches = function(k, O) {
              var T = 0, L;
              if (m(k))
                for (L = k.length; T < L; T += 1)
                  O(k[T]) === !0 && (k.splice(T, 1), L -= 1, T -= 1);
            }, w.prototype._matchHandler = function(k) {
              var O = this;
              return function(T) {
                var L = k === T.handler;
                return L && O._forgetContext(T.context), L;
              };
            }, w.prototype._matchContext = function(k) {
              var O = this;
              return function(T) {
                var L = k === T.context;
                return L && O._forgetContext(T.context), L;
              };
            }, w.prototype._matchHandlerAndContext = function(k, O) {
              var T = this;
              return function(L) {
                var j = k === L.handler, z = O === L.context, J = j && z;
                return J && T._forgetContext(L.context), J;
              };
            }, w.prototype._offByEventName = function(k, O) {
              var T = this, L = y(O), j = T._matchHandler(O);
              k = k.split(x), S(k, function(z) {
                var J = T._safeEvent(z);
                L ? T._spliceMatches(J, j) : (S(J, function(ie) {
                  T._forgetContext(ie.context);
                }), T.events[z] = []);
              });
            }, w.prototype._offByHandler = function(k) {
              var O = this, T = this._matchHandler(k);
              S(this._safeEvent(), function(L) {
                O._spliceMatches(L, T);
              });
            }, w.prototype._offByObject = function(k, O) {
              var T = this, L;
              this._indexOfContext(k) < 0 ? S(k, function(j, z) {
                T.off(z, j);
              }) : p(O) ? (L = this._matchContext(k), T._spliceMatches(this._safeEvent(O), L)) : y(O) ? (L = this._matchHandlerAndContext(O, k), S(this._safeEvent(), function(j) {
                T._spliceMatches(j, L);
              })) : (L = this._matchContext(k), S(this._safeEvent(), function(j) {
                T._spliceMatches(j, L);
              }));
            }, w.prototype.off = function(k, O) {
              p(k) ? this._offByEventName(k, O) : arguments.length ? y(k) ? this._offByHandler(k) : d(k) && this._offByObject(k, O) : (this.events = {}, this.contexts = []);
            }, w.prototype.fire = function(k) {
              this.invoke.apply(this, arguments);
            }, w.prototype.invoke = function(k) {
              var O, T, L, j;
              if (!this.hasListener(k))
                return !0;
              for (O = this._safeEvent(k), T = Array.prototype.slice.call(arguments, 1), L = 0; O[L]; ) {
                if (j = O[L], j.handler.apply(j.context, T) === !1)
                  return !1;
                L += 1;
              }
              return !0;
            }, w.prototype.hasListener = function(k) {
              return this.getListenerLength(k) > 0;
            }, w.prototype.getListenerLength = function(k) {
              var O = this._safeEvent(k);
              return O.length;
            }, r.exports = w;
          },
          /* 11 */
          /***/
          function(r, s, l) {
            function c(f) {
              return typeof f == "string" || f instanceof String;
            }
            r.exports = c;
          },
          /* 12 */
          /***/
          function(r, s, l) {
            var c = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i, f = {
              /**
               * pad left zero characters.
               * @param {number} number number value to pad zero.
               * @param {number} length pad length to want.
               * @returns {string} padded string.
               */
              leadingZero: function(p, d) {
                var m = "", y = 0;
                if ((p + "").length > d)
                  return p + "";
                for (; y < d - 1; y += 1)
                  m += "0";
                return (m + p).slice(d * -1);
              },
              /**
               * Check validate of hex string value is RGB
               * @param {string} str - rgb hex string
               * @returns {boolean} return true when supplied str is valid RGB hex string
               */
              isValidRGB: function(p) {
                return c.test(p);
              },
              // @license RGB <-> HSV conversion utilities based off of http://www.cs.rit.edu/~ncs/color/t_convert.html
              /**
               * Convert color hex string to rgb number array
               * @param {string} hexStr - hex string
               * @returns {number[]} rgb numbers
               */
              hexToRGB: function(p) {
                var d, m, y;
                return f.isValidRGB(p) ? (p = p.substring(1), d = parseInt(p.substr(0, 2), 16), m = parseInt(p.substr(2, 2), 16), y = parseInt(p.substr(4, 2), 16), [d, m, y]) : !1;
              },
              /**
               * Convert rgb number to hex string
               * @param {number} r - red
               * @param {number} g - green
               * @param {number} b - blue
               * @returns {string|boolean} return false when supplied rgb number is not valid. otherwise, converted hex string
               */
              rgbToHEX: function(p, d, m) {
                var y = "#" + f.leadingZero(p.toString(16), 2) + f.leadingZero(d.toString(16), 2) + f.leadingZero(m.toString(16), 2);
                return f.isValidRGB(y) ? y : !1;
              },
              /**
               * Convert rgb number to HSV value
               * @param {number} r - red
               * @param {number} g - green
               * @param {number} b - blue
               * @returns {number[]} hsv value
               */
              rgbToHSV: function(p, d, m) {
                var y, S, x, w, k, O;
                if (p /= 255, d /= 255, m /= 255, y = Math.max(p, d, m), S = Math.min(p, d, m), k = y, O = y - S, w = y === 0 ? 0 : O / y, y === S)
                  x = 0;
                else {
                  switch (y) {
                    case p:
                      x = (d - m) / O + (d < m ? 6 : 0);
                      break;
                    case d:
                      x = (m - p) / O + 2;
                      break;
                    case m:
                      x = (p - d) / O + 4;
                      break;
                  }
                  x /= 6;
                }
                return [Math.round(x * 360), Math.round(w * 100), Math.round(k * 100)];
              },
              /**
               * Convert HSV number to RGB
               * @param {number} h - hue
               * @param {number} s - saturation
               * @param {number} v - value
               * @returns {number[]} rgb value
               */
              hsvToRGB: function(p, d, m) {
                var y, S, x, w, k, O, T, L;
                if (p = Math.max(0, Math.min(360, p)), d = Math.max(0, Math.min(100, d)), m = Math.max(0, Math.min(100, m)), d /= 100, m /= 100, d === 0)
                  return y = S = x = m, [Math.round(y * 255), Math.round(S * 255), Math.round(x * 255)];
                switch (p /= 60, w = Math.floor(p), k = p - w, O = m * (1 - d), T = m * (1 - d * k), L = m * (1 - d * (1 - k)), w) {
                  case 0:
                    y = m, S = L, x = O;
                    break;
                  case 1:
                    y = T, S = m, x = O;
                    break;
                  case 2:
                    y = O, S = m, x = L;
                    break;
                  case 3:
                    y = O, S = T, x = m;
                    break;
                  case 4:
                    y = L, S = O, x = m;
                    break;
                  default:
                    y = m, S = O, x = T;
                    break;
                }
                return [Math.round(y * 255), Math.round(S * 255), Math.round(x * 255)];
              }
            };
            r.exports = f;
          },
          /* 13 */
          /***/
          function(r, s, l) {
            function c(f) {
              return f instanceof Function;
            }
            r.exports = c;
          },
          /* 14 */
          /***/
          function(r, s, l) {
            var c = l(11), f = l(2), p = l(26);
            function d(S, x, w, k) {
              if (c(x)) {
                f(x.split(/\s+/g), function(O) {
                  m(S, O, w, k);
                });
                return;
              }
              f(x, function(O, T) {
                m(S, T, O, w);
              });
            }
            function m(S, x, w, k) {
              function O(T) {
                w.call(k || S, T || window.event);
              }
              "addEventListener" in S ? S.addEventListener(x, O) : "attachEvent" in S && S.attachEvent("on" + x, O), y(S, x, w, O);
            }
            function y(S, x, w, k) {
              var O = p(S, x), T = !1;
              f(O, function(L) {
                return L.handler === w ? (T = !0, !1) : !0;
              }), T || O.push({
                handler: w,
                wrappedHandler: k
              });
            }
            r.exports = d;
          },
          /* 15 */
          /***/
          function(r, s, l) {
            function c(f) {
              if (f.preventDefault) {
                f.preventDefault();
                return;
              }
              f.returnValue = !1;
            }
            r.exports = c;
          },
          /* 16 */
          /***/
          function(r, s, l) {
            function c(f) {
              return f.replace(/([A-Z])/g, function(p) {
                return "-" + p.toLowerCase();
              });
            }
            r.exports = c;
          },
          /* 17 */
          /***/
          function(r, s, l) {
            var c = l(11), f = l(2), p = l(26);
            function d(S, x, w) {
              if (c(x)) {
                f(x.split(/\s+/g), function(k) {
                  m(S, k, w);
                });
                return;
              }
              f(x, function(k, O) {
                m(S, O, k);
              });
            }
            function m(S, x, w) {
              var k = p(S, x), O;
              w ? (f(k, function(T, L) {
                return w === T.handler ? (y(S, x, T.wrappedHandler), O = L, !1) : !0;
              }), k.splice(O, 1)) : (f(k, function(T) {
                y(S, x, T.wrappedHandler);
              }), k.splice(0, k.length));
            }
            function y(S, x, w) {
              "removeEventListener" in S ? S.removeEventListener(x, w) : "detachEvent" in S && S.detachEvent("on" + x, w);
            }
            r.exports = d;
          },
          /* 18 */
          /***/
          function(r, s, l) {
            var c = l(50);
            function f(p, d) {
              var m = c(d.prototype);
              m.constructor = p, p.prototype = m;
            }
            r.exports = f;
          },
          /* 19 */
          /***/
          function(r, s, l) {
            var c = l(6), f = l(7), p = l(0), d = l(1), m = l(20), y = l(13), S = l(21), x = l(4), w = Array.prototype.slice;
            function k(O) {
              this.items = {}, this.length = 0, y(O) && (this.getItemID = O);
            }
            k.and = function(O) {
              var T;
              return O = w.call(arguments), T = O.length, function(L) {
                for (var j = 0; j < T; j += 1)
                  if (!O[j].call(null, L))
                    return !1;
                return !0;
              };
            }, k.or = function(O) {
              var T;
              return O = w.call(arguments), T = O.length, function(L) {
                for (var j = 1, z = O[0].call(null, L); j < T; j += 1)
                  z = z || O[j].call(null, L);
                return z;
              };
            }, k.merge = function(O) {
              var T = {}, L = new k(O.getItemID);
              return c(arguments, function(j) {
                p(T, j.items);
              }), L.items = T, L.length = x.getLength(L.items), L;
            }, k.prototype.getItemID = function(O) {
              return O._id + "";
            }, k.prototype.add = function(O) {
              var T, L;
              if (arguments.length > 1) {
                c(w.call(arguments), function(j) {
                  this.add(j);
                }, this);
                return;
              }
              T = this.getItemID(O), L = this.items, L[T] || (this.length += 1), L[T] = O;
            }, k.prototype.remove = function(O) {
              var T = [], L, j;
              return this.length ? arguments.length > 1 ? (T = x.map(w.call(arguments), function(z) {
                return this.remove(z);
              }, this), T) : (L = this.items, S(O) && (O = this.getItemID(O)), L[O] ? (this.length -= 1, j = L[O], delete L[O], j) : T) : T;
            }, k.prototype.clear = function() {
              this.items = {}, this.length = 0;
            }, k.prototype.has = function(O) {
              var T, L;
              return this.length ? (T = y(O), L = !1, T ? this.each(function(j) {
                return O(j) === !0 ? (L = !0, !1) : !0;
              }) : (O = S(O) ? this.getItemID(O) : O, L = m(this.items[O])), L) : !1;
            }, k.prototype.doWhenHas = function(O, T, L) {
              var j = this.items[O];
              m(j) && T.call(L || this, j);
            }, k.prototype.find = function(O) {
              var T = new k();
              return this.hasOwnProperty("getItemID") && (T.getItemID = this.getItemID), this.each(function(L) {
                O(L) === !0 && T.add(L);
              }), T;
            }, k.prototype.groupBy = function(O, T) {
              var L = {}, j = y(O), z = this.getItemID, J, ie;
              if (d(O)) {
                if (c(O, function(K) {
                  L[K + ""] = new k(z);
                }), !T)
                  return L;
                O = T, j = !0;
              }
              return this.each(function(K) {
                j ? ie = O(K) : (ie = K[O], y(ie) && (ie = ie.apply(K))), J = L[ie], J || (J = L[ie] = new k(z)), J.add(K);
              }), L;
            }, k.prototype.single = function() {
              var O;
              return this.each(function(T) {
                return O = T, !1;
              }, this), O;
            }, k.prototype.sort = function(O) {
              var T = [];
              return this.each(function(L) {
                T.push(L);
              }), y(O) && (T = T.sort(O)), T;
            }, k.prototype.each = function(O, T) {
              f(this.items, O, T || this);
            }, k.prototype.toArray = function() {
              return this.length ? x.map(this.items, function(O) {
                return O;
              }) : [];
            }, r.exports = k;
          },
          /* 20 */
          /***/
          function(r, s, l) {
            var c = l(3), f = l(36);
            function p(d) {
              return !c(d) && !f(d);
            }
            r.exports = p;
          },
          /* 21 */
          /***/
          function(r, s, l) {
            function c(f) {
              return f === Object(f);
            }
            r.exports = c;
          },
          /* 22 */
          /***/
          function(r, s, l) {
            var c = {
              chrome: !1,
              firefox: !1,
              safari: !1,
              msie: !1,
              edge: !1,
              others: !1,
              version: 0
            };
            typeof window < "u" && window.navigator && f();
            function f() {
              var p = window.navigator, d = p.appName.replace(/\s/g, "_"), m = p.userAgent, y = /MSIE\s([0-9]+[.0-9]*)/, S = /Trident.*rv:11\./, x = /Edge\/(\d+)\./, w = {
                firefox: /Firefox\/(\d+)\./,
                chrome: /Chrome\/(\d+)\./,
                safari: /Version\/([\d.]+).*Safari\/(\d+)/
              }, k, O, T = {
                Microsoft_Internet_Explorer: function() {
                  var j = m.match(y);
                  j ? (c.msie = !0, c.version = parseFloat(j[1])) : c.others = !0;
                },
                Netscape: function() {
                  var j = !1;
                  if (S.exec(m))
                    c.msie = !0, c.version = 11, j = !0;
                  else if (x.exec(m))
                    c.edge = !0, c.version = m.match(x)[1], j = !0;
                  else
                    for (k in w)
                      if (w.hasOwnProperty(k) && (O = m.match(w[k]), O && O.length > 1)) {
                        c[k] = j = !0, c.version = parseFloat(O[1] || 0);
                        break;
                      }
                  j || (c.others = !0);
                }
              }, L = T[d];
              L && T[d]();
            }
            r.exports = c;
          },
          /* 23 */
          /***/
          function(r, s, l) {
            var c = l(3);
            function f(p) {
              return !p || !p.className ? "" : c(p.className.baseVal) ? p.className : p.className.baseVal;
            }
            r.exports = f;
          },
          /* 24 */
          /***/
          function(r, s, l) {
            (function(c) {
              var f = l(10), p = l(42), d = l(44), m = l(47), y = l(28), S = l(17), x = l(14), w = l(15), k = l(0);
              function O(T, L) {
                x(L, "mousedown", this._onMouseDown, this), this.options = k({
                  distance: 10
                }, T), this.container = L, this._isMoved = !1, this._distance = 0, this._dragStartFired = !1, this._dragStartEventData = null;
              }
              O.prototype.destroy = function() {
                S(this.container, "mousedown", this._onMouseDown), this.options = this.container = this._isMoved = this._distance = this._dragStartFired = this._dragStartEventData = null;
              }, O.prototype._toggleDragEvent = function(T) {
                var L = this.container;
                T ? (p(L), x(window, "dragstart", w), x(c.document, {
                  mousemove: this._onMouseMove,
                  mouseup: this._onMouseUp
                }, this)) : (d(L), S(window, "dragstart", w), S(c.document, {
                  mousemove: this._onMouseMove,
                  mouseup: this._onMouseUp
                }));
              }, O.prototype._getEventData = function(T) {
                return {
                  target: y(T),
                  originEvent: T
                };
              }, O.prototype._onMouseDown = function(T) {
                m(T) === 0 && (this._distance = 0, this._dragStartFired = !1, this._dragStartEventData = this._getEventData(T), this._toggleDragEvent(!0));
              }, O.prototype._onMouseMove = function(T) {
                var L = this.options.distance;
                if (w(T), this._isMoved = !0, this._distance < L) {
                  this._distance += 1;
                  return;
                }
                if (!this._dragStartFired && (this._dragStartFired = !0, !this.invoke("dragStart", this._dragStartEventData))) {
                  this._toggleDragEvent(!1);
                  return;
                }
                this.fire("drag", this._getEventData(T));
              }, O.prototype._onMouseUp = function(T) {
                if (this._toggleDragEvent(!1), this._isMoved) {
                  this._isMoved = !1, this.fire("dragEnd", this._getEventData(T));
                  return;
                }
                this.fire("click", this._getEventData(T));
              }, f.mixin(O), r.exports = O;
            }).call(this, l(25));
          },
          /* 25 */
          /***/
          function(r, s) {
            var l;
            l = /* @__PURE__ */ function() {
              return this;
            }();
            try {
              l = l || new Function("return this")();
            } catch {
              typeof window == "object" && (l = window);
            }
            r.exports = l;
          },
          /* 26 */
          /***/
          function(r, s, l) {
            var c = "_feEventKey";
            function f(p, d) {
              var m = p[c], y;
              return m || (m = p[c] = {}), y = m[d], y || (y = m[d] = []), y;
            }
            r.exports = f;
          },
          /* 27 */
          /***/
          function(r, s, l) {
            function c(f) {
              var p = document.documentElement.style, d, m;
              for (d = 0, m = f.length; d < m; d += 1)
                if (f[d] in p)
                  return f[d];
              return !1;
            }
            r.exports = c;
          },
          /* 28 */
          /***/
          function(r, s, l) {
            function c(f) {
              return f.target || f.srcElement;
            }
            r.exports = c;
          },
          /* 29 */
          /***/
          function(r, s, l) {
            var c = l(10), f = l(28), p = l(17), d = l(14), m = l(30), y = l(0), S = l(18), x = l(9), w = l(12), k = l(8), O = l(51);
            function T(L, j) {
              this.options = y({
                cssPrefix: "tui-colorpicker-",
                preset: ["#181818", "#282828", "#383838", "#585858", "#B8B8B8", "#D8D8D8", "#E8E8E8", "#F8F8F8", "#AB4642", "#DC9656", "#F7CA88", "#A1B56C", "#86C1B9", "#7CAFC2", "#BA8BAF", "#A16946"],
                detailTxt: "Detail"
              }, L), j = x.appendHTMLElement("div", j, this.options.cssPrefix + "palette-container"), k.call(this, L, j);
            }
            S(T, k), T.prototype._onClick = function(L) {
              var j = this.options, z = f(L), J = {};
              if (m(z, j.cssPrefix + "palette-button")) {
                J.color = z.value, this.fire("_selectColor", J);
                return;
              }
              m(z, j.cssPrefix + "palette-toggle-slider") && this.fire("_toggleSlider");
            }, T.prototype._onChange = function(L) {
              var j = this.options, z = f(L), J = {};
              m(z, j.cssPrefix + "palette-hex") && (J.color = z.value, this.fire("_selectColor", J));
            }, T.prototype._beforeDestroy = function() {
              this._toggleEvent(!1);
            }, T.prototype._toggleEvent = function(L) {
              var j = this.options, z = this.container, J = L ? d : p, ie;
              J(z, "click", this._onClick, this), ie = z.querySelector("." + j.cssPrefix + "palette-hex", z), ie && J(ie, "change", this._onChange, this);
            }, T.prototype.render = function(L) {
              var j = this.options, z = "";
              this._toggleEvent(!1), z = O({
                cssPrefix: j.cssPrefix,
                preset: j.preset,
                detailTxt: j.detailTxt,
                color: L,
                isValidRGB: w.isValidRGB,
                getItemClass: function(J) {
                  return J ? "" : " " + j.cssPrefix + "color-transparent";
                },
                isSelected: function(J) {
                  return J === L ? " " + j.cssPrefix + "selected" : "";
                }
              }), this.container.innerHTML = z, this._toggleEvent(!0);
            }, c.mixin(T), r.exports = T;
          },
          /* 30 */
          /***/
          function(r, s, l) {
            var c = l(5), f = l(23);
            function p(d, m) {
              var y;
              return d.classList ? d.classList.contains(m) : (y = f(d).split(/\s+/), c(m, y) > -1);
            }
            r.exports = p;
          },
          /* 31 */
          /***/
          function(r, s, l) {
            var c = l(10), f = l(53), p = l(54), d = l(30), m = l(0), y = l(18), S = l(9), x = l(32), w = l(12), k = l(8), O = l(24), T = l(57), L = -7, j = 112, z = -3, J = 115, ie = 359.99;
            function K(re, ee) {
              ee = S.appendHTMLElement("div", ee, re.cssPrefix + "slider-container"), ee.style.display = "none", k.call(this, re, ee), this.options = m({
                color: "#f8f8f8",
                cssPrefix: "tui-colorpicker-"
              }, re), this._dragDataCache = {}, this.sliderHandleElement = null, this.huebarHandleElement = null, this.baseColorElement = null, this.drag = new O({
                distance: 0
              }, ee), this.colorSliderPosLimitRange = [L, j], this.huebarPosLimitRange = [z, J], this.drag.on({
                dragStart: this._onDragStart,
                drag: this._onDrag,
                dragEnd: this._onDragEnd,
                click: this._onClick
              }, this);
            }
            y(K, k), K.prototype._beforeDestroy = function() {
              this.drag.off(), this.drag = this.options = this._dragDataCache = this.sliderHandleElement = this.huebarHandleElement = this.baseColorElement = null;
            }, K.prototype.toggle = function(re) {
              this.container.style.display = re ? "block" : "none";
            }, K.prototype.isVisible = function() {
              return this.container.style.display === "block";
            }, K.prototype.render = function(re) {
              var ee = this.container, de = this.options, Ce = T.layout, he, oe;
              w.isValidRGB(re) && (Ce = Ce.replace(/{{slider}}/, T.slider), Ce = Ce.replace(/{{huebar}}/, T.huebar), Ce = Ce.replace(/{{cssPrefix}}/g, de.cssPrefix), Ce = Ce.replace(/{{id}}/g, de.id), this.container.innerHTML = Ce, this.sliderSvgElement = ee.querySelector("." + de.cssPrefix + "svg-slider"), this.huebarSvgElement = ee.querySelector("." + de.cssPrefix + "svg-huebar"), this.sliderHandleElement = ee.querySelector("." + de.cssPrefix + "slider-handle"), this.huebarHandleElement = ee.querySelector("." + de.cssPrefix + "huebar-handle"), this.baseColorElement = ee.querySelector("." + de.cssPrefix + "slider-basecolor"), he = w.hexToRGB(re), oe = w.rgbToHSV.apply(null, he), this.moveHue(oe[0], !0), this.moveSaturationAndValue(oe[1], oe[2], !0));
            }, K.prototype._setColorSliderPosMax = function() {
              var re = this.sliderSvgElement.getClientRects()[0];
              re && (this.colorSliderPosLimitRange[1] = re.height - 10);
            }, K.prototype._moveColorSliderHandle = function(re, ee, de) {
              var Ce = this.sliderHandleElement, he;
              ee = Math.max(this.colorSliderPosLimitRange[0], ee), ee = Math.min(this.colorSliderPosLimitRange[1], ee), re = Math.max(this.colorSliderPosLimitRange[0], re), re = Math.min(this.colorSliderPosLimitRange[1], re), x.setTranslateXY(Ce, re, ee), he = ee > 50 ? "white" : "black", x.setStrokeColor(Ce, he), de || this.fire("_selectColor", {
                color: w.rgbToHEX.apply(null, this.getRGB())
              });
            }, K.prototype.moveSaturationAndValue = function(re, ee, de) {
              var Ce, he, oe, ge;
              re = re || 0, ee = ee || 0, Ce = Math.abs(this.colorSliderPosLimitRange[0]), he = this.colorSliderPosLimitRange[1], oe = re * he / 100 - Ce, ge = he - ee * he / 100 - Ce, this._moveColorSliderHandle(oe, ge, de);
            }, K.prototype._moveColorSliderByPosition = function(re, ee) {
              var de = this.colorSliderPosLimitRange[0];
              this._moveColorSliderHandle(re + de, ee + de);
            }, K.prototype.getSaturationAndValue = function() {
              var re = Math.abs(this.colorSliderPosLimitRange[0]), ee = re + this.colorSliderPosLimitRange[1], de = x.getTranslateXY(this.sliderHandleElement), Ce, he;
              return Ce = (de[1] + re) / ee * 100, he = 100 - (de[0] + re) / ee * 100, [Ce, he];
            }, K.prototype._setHueBarPosMax = function() {
              var re = this.huebarSvgElement.getClientRects()[0];
              re && (this.huebarPosLimitRange[1] = re.height - 7);
            }, K.prototype._moveHueHandle = function(re, ee) {
              var de = this.huebarHandleElement, Ce = this.baseColorElement, he, oe;
              re = Math.max(this.huebarPosLimitRange[0], re), re = Math.min(this.huebarPosLimitRange[1], re), x.setTranslateY(de, re), he = w.hsvToRGB(this.getHue(), 100, 100), oe = w.rgbToHEX.apply(null, he), x.setGradientColorStop(Ce, oe), ee || this.fire("_selectColor", {
                color: w.rgbToHEX.apply(null, this.getRGB())
              });
            }, K.prototype.moveHue = function(re, ee) {
              var de = 0, Ce, he;
              Ce = Math.abs(this.huebarPosLimitRange[0]), he = Ce + this.huebarPosLimitRange[1], re = re || 0, de = he * re / ie - Ce, this._moveHueHandle(de, ee);
            }, K.prototype._moveHueByPosition = function(re) {
              var ee = this.huebarPosLimitRange[0];
              this._moveHueHandle(re + ee);
            }, K.prototype.getHue = function() {
              var re = this.huebarHandleElement, ee = x.getTranslateXY(re), de, Ce;
              return de = Math.abs(this.huebarPosLimitRange[0]), Ce = de + this.huebarPosLimitRange[1], (ee[0] + de) * ie / Ce;
            }, K.prototype.getHSV = function() {
              var re = this.getSaturationAndValue(), ee = this.getHue();
              return [ee].concat(re);
            }, K.prototype.getRGB = function() {
              return w.hsvToRGB.apply(null, this.getHSV());
            }, K.prototype._prepareColorSliderForMouseEvent = function(re) {
              var ee = this.options, de = p(re.target, "." + ee.cssPrefix + "slider-part"), Ce;
              return Ce = this._dragDataCache = {
                isColorSlider: d(de, ee.cssPrefix + "slider-left"),
                parentElement: de
              }, Ce;
            }, K.prototype._onClick = function(re) {
              var ee = this._prepareColorSliderForMouseEvent(re), de = f(re.originEvent, ee.parentElement);
              ee.isColorSlider ? this._moveColorSliderByPosition(de[0], de[1]) : this._moveHueByPosition(de[1]), this._dragDataCache = null;
            }, K.prototype._onDragStart = function(re) {
              this._setColorSliderPosMax(), this._setHueBarPosMax(), this._prepareColorSliderForMouseEvent(re);
            }, K.prototype._onDrag = function(re) {
              var ee = this._dragDataCache, de = f(re.originEvent, ee.parentElement);
              ee.isColorSlider ? this._moveColorSliderByPosition(de[0], de[1]) : this._moveHueByPosition(de[1]);
            }, K.prototype._onDragEnd = function() {
              this._dragDataCache = null;
            }, c.mixin(K), r.exports = K;
          },
          /* 32 */
          /***/
          function(r, s, l) {
            var c = l(4).isOldBrowser, f = /[\.\-0-9]+/g, p = -6, d = {
              /**
               * Get translate transform value
               * @param {SVG|VML} obj - svg or vml object that want to know translate x, y
               * @returns {number[]} translated coordinates [x, y]
               */
              getTranslateXY: function(m) {
                var y;
                return c ? (y = m.style, [parseFloat(y.top), parseFloat(y.left)]) : (y = m.getAttribute("transform"), y ? (y = y.match(f), [parseFloat(y[1]), parseFloat(y[0])]) : [0, 0]);
              },
              /**
               * Set translate transform value
               * @param {SVG|VML} obj - SVG or VML object to setting translate transform.
               * @param {number} x - translate X value
               * @param {number} y - translate Y value
               */
              setTranslateXY: function(m, y, S) {
                c ? (m.style.left = y + "px", m.style.top = S + "px") : m.setAttribute("transform", "translate(" + y + "," + S + ")");
              },
              /**
               * Set translate only Y value
               * @param {SVG|VML} obj - SVG or VML object to setting translate transform.
               * @param {number} y - translate Y value
               */
              setTranslateY: function(m, y) {
                c ? m.style.top = y + "px" : m.setAttribute("transform", "translate(" + p + "," + y + ")");
              },
              /**
               * Set stroke color to SVG or VML object
               * @param {SVG|VML} obj - SVG or VML object to setting stroke color
               * @param {string} colorStr - color string
               */
              setStrokeColor: function(m, y) {
                c ? m.strokecolor = y : m.setAttribute("stroke", y);
              },
              /**
               * Set gradient stop color to SVG, VML object.
               * @param {SVG|VML} obj - SVG, VML object to applying gradient stop color
               * @param {string} colorStr - color string
               */
              setGradientColorStop: function(m, y) {
                c ? m.color = y : m.setAttribute("stop-color", y);
              }
            };
            r.exports = d;
          },
          /* 33 */
          /***/
          function(r, s, l) {
            l(34), r.exports = l(35);
          },
          /* 34 */
          /***/
          function(r, s, l) {
          },
          /* 35 */
          /***/
          function(r, s, l) {
            var c = l(19), f = l(8), p = l(24), d = l(48), m = l(29), y = l(31), S = l(12), x = l(32), w = {
              Collection: c,
              View: f,
              Drag: p,
              create: d,
              Palette: m,
              Slider: y,
              colorutil: S,
              svgvml: x
            };
            r.exports = w;
          },
          /* 36 */
          /***/
          function(r, s, l) {
            function c(f) {
              return f === null;
            }
            r.exports = c;
          },
          /* 37 */
          /***/
          function(r, s, l) {
            var c = l(3), f = l(38), p = 7 * 24 * 60 * 60 * 1e3;
            function d(y) {
              var S = (/* @__PURE__ */ new Date()).getTime();
              return S - y > p;
            }
            function m(y, S) {
              var x = "https://www.google-analytics.com/collect", w = location.hostname, k = "event", O = "use", T = "TOAST UI " + y + " for " + w + ": Statistics", L = window.localStorage.getItem(T);
              !c(window.tui) && window.tui.usageStatistics === !1 || L && !d(L) || (window.localStorage.setItem(T, (/* @__PURE__ */ new Date()).getTime()), setTimeout(function() {
                (document.readyState === "interactive" || document.readyState === "complete") && f(x, {
                  v: 1,
                  t: k,
                  tid: S,
                  cid: w,
                  dp: w,
                  dh: y,
                  el: y,
                  ec: O
                });
              }, 1e3));
            }
            r.exports = m;
          },
          /* 38 */
          /***/
          function(r, s, l) {
            var c = l(7);
            function f(p, d) {
              var m = document.createElement("img"), y = "";
              return c(d, function(S, x) {
                y += "&" + x + "=" + S;
              }), y = y.substring(1), m.src = p + "?" + y, m.style.display = "none", document.body.appendChild(m), document.body.removeChild(m), m;
            }
            r.exports = f;
          },
          /* 39 */
          /***/
          function(r, s, l) {
            var c = l(2), f = l(5), p = l(23), d = l(40);
            function m(y) {
              var S = Array.prototype.slice.call(arguments, 1), x = y.classList, w = [], k;
              if (x) {
                c(S, function(O) {
                  y.classList.add(O);
                });
                return;
              }
              k = p(y), k && (S = [].concat(k.split(/\s+/), S)), c(S, function(O) {
                f(O, w) < 0 && w.push(O);
              }), d(y, w);
            }
            r.exports = m;
          },
          /* 40 */
          /***/
          function(r, s, l) {
            var c = l(1), f = l(3);
            function p(d, m) {
              if (m = c(m) ? m.join(" ") : m, m = m.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), f(d.className.baseVal)) {
                d.className = m;
                return;
              }
              d.className.baseVal = m;
            }
            r.exports = p;
          },
          /* 41 */
          /***/
          function(r, s, l) {
            function c(f) {
              return typeof f == "number" || f instanceof Number;
            }
            r.exports = c;
          },
          /* 42 */
          /***/
          function(r, s, l) {
            var c = l(14), f = l(15), p = l(43), d = l(27), m = "onselectstart" in document, y = "prevUserSelect", S = d([
              "userSelect",
              "WebkitUserSelect",
              "OUserSelect",
              "MozUserSelect",
              "msUserSelect"
            ]);
            function x(w) {
              w || (w = document), m ? c(w, "selectstart", f) : (w = w === document ? document.documentElement : w, p(w, y, w.style[S]), w.style[S] = "none");
            }
            r.exports = x;
          },
          /* 43 */
          /***/
          function(r, s, l) {
            var c = l(16);
            function f(p, d, m) {
              if (p.dataset) {
                p.dataset[d] = m;
                return;
              }
              p.setAttribute("data-" + c(d), m);
            }
            r.exports = f;
          },
          /* 44 */
          /***/
          function(r, s, l) {
            var c = l(17), f = l(15), p = l(45), d = l(46), m = l(27), y = "onselectstart" in document, S = "prevUserSelect", x = m([
              "userSelect",
              "WebkitUserSelect",
              "OUserSelect",
              "MozUserSelect",
              "msUserSelect"
            ]);
            function w(k) {
              k || (k = document), y ? c(k, "selectstart", f) : (k = k === document ? document.documentElement : k, k.style[x] = p(k, S) || "auto", d(k, S));
            }
            r.exports = w;
          },
          /* 45 */
          /***/
          function(r, s, l) {
            var c = l(16);
            function f(p, d) {
              return p.dataset ? p.dataset[d] : p.getAttribute("data-" + c(d));
            }
            r.exports = f;
          },
          /* 46 */
          /***/
          function(r, s, l) {
            var c = l(16);
            function f(p, d) {
              if (p.dataset) {
                delete p.dataset[d];
                return;
              }
              p.removeAttribute("data-" + c(d));
            }
            r.exports = f;
          },
          /* 47 */
          /***/
          function(r, s, l) {
            var c = l(22), f = l(5), p = ["0", "1", "3", "5", "7"], d = ["2", "6"], m = ["4"];
            function y(x) {
              return c.msie && c.version <= 8 ? S(x) : x.button;
            }
            function S(x) {
              var w = String(x.button);
              return f(w, p) > -1 ? 0 : f(w, d) > -1 ? 2 : f(w, m) > -1 ? 1 : null;
            }
            r.exports = y;
          },
          /* 48 */
          /***/
          function(r, s, l) {
            var c = l(10), f = l(0), p = l(4), d = l(12), m = l(49), y = l(29), S = l(31), x = 0;
            function w() {
              return x += 1, x;
            }
            function k(O) {
              var T;
              if (!(this instanceof k))
                return new k(O);
              if (O = this.options = f({
                container: null,
                color: "#f8f8f8",
                preset: ["#181818", "#282828", "#383838", "#585858", "#b8b8b8", "#d8d8d8", "#e8e8e8", "#f8f8f8", "#ab4642", "#dc9656", "#f7ca88", "#a1b56c", "#86c1b9", "#7cafc2", "#ba8baf", "#a16946"],
                cssPrefix: "tui-colorpicker-",
                detailTxt: "Detail",
                id: w(),
                usageStatistics: !0
              }, O), !O.container)
                throw new Error("ColorPicker(): need container option.");
              T = this.layout = new m(O, O.container), this.palette = new y(O, T.container), this.palette.on({
                _selectColor: this._onSelectColorInPalette,
                _toggleSlider: this._onToggleSlider
              }, this), this.slider = new S(O, T.container), this.slider.on("_selectColor", this._onSelectColorInSlider, this), T.addChild(this.palette), T.addChild(this.slider), this.render(O.color), O.usageStatistics && p.sendHostName();
            }
            k.prototype._onSelectColorInPalette = function(O) {
              var T = O.color, L = this.options;
              if (!d.isValidRGB(T) && T !== "") {
                this.render();
                return;
              }
              this.fire("selectColor", {
                color: T,
                origin: "palette"
              }), L.color !== T && (L.color = T, this.render(T));
            }, k.prototype._onToggleSlider = function() {
              this.slider.toggle(!this.slider.isVisible());
            }, k.prototype._onSelectColorInSlider = function(O) {
              var T = O.color, L = this.options;
              this.fire("selectColor", {
                color: T,
                origin: "slider"
              }), L.color !== T && (L.color = T, this.palette.render(T));
            }, k.prototype.setColor = function(O) {
              if (!d.isValidRGB(O))
                throw new Error("ColorPicker#setColor(): need valid hex string color value");
              this.options.color = O, this.render(O);
            }, k.prototype.getColor = function() {
              return this.options.color;
            }, k.prototype.toggle = function(O) {
              this.layout.container.style.display = O ? "block" : "none";
            }, k.prototype.render = function(O) {
              this.layout.render(O || this.options.color);
            }, k.prototype.destroy = function() {
              this.layout.destroy(), this.options.container.innerHTML = "", this.layout = this.slider = this.palette = this.options = null;
            }, c.mixin(k), r.exports = k;
          },
          /* 49 */
          /***/
          function(r, s, l) {
            var c = l(0), f = l(18), p = l(9), d = l(8);
            function m(y, S) {
              this.options = c({
                cssPrefix: "tui-colorpicker-"
              }, y), S = p.appendHTMLElement("div", S, this.options.cssPrefix + "container"), d.call(this, y, S), this.render();
            }
            f(m, d), m.prototype.render = function(y) {
              this.recursive(function(S) {
                S.render(y);
              }, !0);
            }, r.exports = m;
          },
          /* 50 */
          /***/
          function(r, s, l) {
            function c(f) {
              function p() {
              }
              return p.prototype = f, new p();
            }
            r.exports = c;
          },
          /* 51 */
          /***/
          function(r, s, l) {
            var c = l(52);
            r.exports = function(f) {
              var p = ['<li><input class="{{cssPrefix}}palette-button{{isSelected @this}}{{getItemClass @this}}" type="button"', "{{if isValidRGB @this}}", ' style="background-color:{{@this}};color:{{@this}}"', "{{/if}}", ' title="{{@this}}" value="{{@this}}" /></li>'].join(""), d = ['<ul class="{{cssPrefix}}clearfix">', "{{each preset}}", p, "{{/each}}", "</ul>", '<div class="{{cssPrefix}}clearfix" style="overflow:hidden">', '<input type="button" class="{{cssPrefix}}palette-toggle-slider" value="{{detailTxt}}" />', '<input type="text" class="{{cssPrefix}}palette-hex" value="{{color}}" maxlength="7" />', '<span class="{{cssPrefix}}palette-preview" style="background-color:{{color}};color:{{color}}">{{color}}</span>', "</div>"].join(`
`);
              return c(d, f);
            };
          },
          /* 52 */
          /***/
          function(r, s, l) {
            var c = l(5), f = l(2), p = l(1), d = l(11), m = l(0), y = /{{\s?|\s?}}/g, S = /^[a-zA-Z0-9_@]+\[[a-zA-Z0-9_@"']+\]$/, x = /\[\s?|\s?\]/, w = /^[a-zA-Z_]+\.[a-zA-Z_]+$/, k = /\./, O = /^["']\w+["']$/, T = /"|'/g, L = /^-?\d+\.?\d*$/, j = 2, z = {
              if: ee,
              each: de,
              with: Ce
            }, J = "a".split(/a/).length === 3, ie = /* @__PURE__ */ function() {
              return J ? function(Me, Ie) {
                return Me.split(Ie);
              } : function(Me, Ie) {
                var rt = [], ot = 0, Et, gt;
                for (Ie.global || (Ie = new RegExp(Ie, "g")), Et = Ie.exec(Me); Et !== null; )
                  gt = Et.index, rt.push(Me.slice(ot, gt)), ot = gt + Et[0].length, Et = Ie.exec(Me);
                return rt.push(Me.slice(ot)), rt;
              };
            }();
            function K(Me, Ie) {
              var rt, ot = Ie[Me];
              return Me === "true" ? ot = !0 : Me === "false" ? ot = !1 : O.test(Me) ? ot = Me.replace(T, "") : S.test(Me) ? (rt = Me.split(x), ot = K(rt[0], Ie)[K(rt[1], Ie)]) : w.test(Me) ? (rt = Me.split(k), ot = K(rt[0], Ie)[rt[1]]) : L.test(Me) && (ot = parseFloat(Me)), ot;
            }
            function re(Me, Ie) {
              var rt = [Me], ot = [], Et = 0, gt = 0;
              return f(Ie, function(At, Mt) {
                At.indexOf("if") === 0 ? Et += 1 : At === "/if" ? Et -= 1 : !Et && (At.indexOf("elseif") === 0 || At === "else") && (rt.push(At === "else" ? ["true"] : At.split(" ").slice(1)), ot.push(Ie.slice(gt, Mt)), gt = Mt + 1);
              }), ot.push(Ie.slice(gt)), {
                exps: rt,
                sourcesInsideIf: ot
              };
            }
            function ee(Me, Ie, rt) {
              var ot = re(Me, Ie), Et = !1, gt = "";
              return f(ot.exps, function(At, Mt) {
                return Et = ge(At, rt), Et && (gt = Oe(ot.sourcesInsideIf[Mt], rt)), !Et;
              }), gt;
            }
            function de(Me, Ie, rt) {
              var ot = ge(Me, rt), Et = p(ot) ? "@index" : "@key", gt = {}, At = "";
              return f(ot, function(Mt, St) {
                gt[Et] = St, gt["@this"] = Mt, m(rt, gt), At += Oe(Ie.slice(), rt);
              }), At;
            }
            function Ce(Me, Ie, rt) {
              var ot = c("as", Me), Et = Me[ot + 1], gt = ge(Me.slice(0, ot), rt), At = {};
              return At[Et] = gt, Oe(Ie, m(rt, At)) || "";
            }
            function he(Me, Ie, rt) {
              var ot = Me.splice(Ie + 1, rt - Ie);
              return ot.pop(), ot;
            }
            function oe(Me, Ie, rt) {
              for (var ot = z[Me], Et = 1, gt = 0, At, Mt = gt + j, St = Ie[Mt]; Et && d(St); )
                St.indexOf(Me) === 0 ? Et += 1 : St.indexOf("/" + Me) === 0 && (Et -= 1, At = Mt), Mt += j, St = Ie[Mt];
              if (Et)
                throw Error(Me + " needs {{/" + Me + "}} expression.");
              return Ie[gt] = ot(
                Ie[gt].split(" ").slice(1),
                he(Ie, gt, At),
                rt
              ), Ie;
            }
            function ge(Me, Ie) {
              var rt = K(Me[0], Ie);
              return rt instanceof Function ? we(rt, Me.slice(1), Ie) : rt;
            }
            function we(Me, Ie, rt) {
              var ot = [];
              return f(Ie, function(Et) {
                ot.push(K(Et, rt));
              }), Me.apply(null, ot);
            }
            function Oe(Me, Ie) {
              for (var rt = 1, ot = Me[rt], Et, gt, At; d(ot); )
                Et = ot.split(" "), gt = Et[0], z[gt] ? (At = oe(gt, Me.splice(rt, Me.length - rt), Ie), Me = Me.concat(At)) : Me[rt] = ge(Et, Ie), rt += j, ot = Me[rt];
              return Me.join("");
            }
            function Qe(Me, Ie) {
              return Oe(ie(Me, y), Ie);
            }
            r.exports = Qe;
          },
          /* 53 */
          /***/
          function(r, s, l) {
            var c = l(1);
            function f(p, d) {
              var m = c(p), y = m ? p[0] : p.clientX, S = m ? p[1] : p.clientY, x;
              return d ? (x = d.getBoundingClientRect(), [
                y - x.left - d.clientLeft,
                S - x.top - d.clientTop
              ]) : [y, S];
            }
            r.exports = f;
          },
          /* 54 */
          /***/
          function(r, s, l) {
            var c = l(55);
            function f(p, d) {
              var m = p.parentNode;
              if (c(p, d))
                return p;
              for (; m && m !== document; ) {
                if (c(m, d))
                  return m;
                m = m.parentNode;
              }
              return null;
            }
            r.exports = f;
          },
          /* 55 */
          /***/
          function(r, s, l) {
            var c = l(5), f = l(56), p = Element.prototype, d = p.matches || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || function(y) {
              var S = this.document || this.ownerDocument;
              return c(this, f(S.querySelectorAll(y))) > -1;
            };
            function m(y, S) {
              return d.call(y, S);
            }
            r.exports = m;
          },
          /* 56 */
          /***/
          function(r, s, l) {
            var c = l(6);
            function f(p) {
              var d;
              try {
                d = Array.prototype.slice.call(p);
              } catch {
                d = [], c(p, function(y) {
                  d.push(y);
                });
              }
              return d;
            }
            r.exports = f;
          },
          /* 57 */
          /***/
          function(r, s, l) {
            (function(c) {
              var f = l(4).isOldBrowser, p = ['<div class="{{cssPrefix}}slider-left {{cssPrefix}}slider-part">{{slider}}</div>', '<div class="{{cssPrefix}}slider-right {{cssPrefix}}slider-part">{{huebar}}</div>'].join(`
`), d = ['<svg class="{{cssPrefix}}svg {{cssPrefix}}svg-slider">', "<defs>", '<linearGradient id="{{cssPrefix}}svg-fill-color-{{id}}" x1="0%" y1="0%" x2="100%" y2="0%">', '<stop offset="0%" stop-color="rgb(255,255,255)" />', '<stop class="{{cssPrefix}}slider-basecolor" offset="100%" stop-color="rgb(255,0,0)" />', "</linearGradient>", '<linearGradient id="{{cssPrefix}}svn-fill-black-{{id}}" x1="0%" y1="0%" x2="0%" y2="100%">', '<stop offset="0%" style="stop-color:rgb(0,0,0);stop-opacity:0" />', '<stop offset="100%" style="stop-color:rgb(0,0,0);stop-opacity:1" />', "</linearGradient>", "</defs>", '<rect width="100%" height="100%" fill="url(#{{cssPrefix}}svg-fill-color-{{id}})"></rect>', '<rect width="100%" height="100%" fill="url(#{{cssPrefix}}svn-fill-black-{{id}})"></rect>', '<path transform="translate(0,0)" class="{{cssPrefix}}slider-handle" d="M0 7.5 L15 7.5 M7.5 15 L7.5 0 M2 7 a5.5 5.5 0 1 1 0 1 Z" stroke="black" stroke-width="0.75" fill="none" />', "</svg>"].join(`
`), m = ['<div class="{{cssPrefix}}vml-slider">', '<v:rect strokecolor="none" class="{{cssPrefix}}vml {{cssPrefix}}vml-slider-bg">', '<v:fill class="{{cssPrefix}}vml {{cssPrefix}}slider-basecolor" type="gradient" method="none" color="#ff0000" color2="#fff" angle="90" />', "</v:rect>", '<v:rect strokecolor="#ccc" class="{{cssPrefix}}vml {{cssPrefix}}vml-slider-bg">', '<v:fill type="gradient" method="none" color="black" color2="white" o:opacity2="0%" class="{{cssPrefix}}vml" />', "</v:rect>", '<v:shape class="{{cssPrefix}}vml {{cssPrefix}}slider-handle" coordsize="1 1" style="width:1px;height:1px;"path="m 0,7 l 14,7 m 7,14 l 7,0 ar 12,12 2,2 z" filled="false" stroked="true" />', "</div>"].join(`
`), y = ['<svg class="{{cssPrefix}}svg {{cssPrefix}}svg-huebar">', "<defs>", '<linearGradient id="g-{{id}}" x1="0%" y1="0%" x2="0%" y2="100%">', '<stop offset="0%" stop-color="rgb(255,0,0)" />', '<stop offset="16.666%" stop-color="rgb(255,255,0)" />', '<stop offset="33.333%" stop-color="rgb(0,255,0)" />', '<stop offset="50%" stop-color="rgb(0,255,255)" />', '<stop offset="66.666%" stop-color="rgb(0,0,255)" />', '<stop offset="83.333%" stop-color="rgb(255,0,255)" />', '<stop offset="100%" stop-color="rgb(255,0,0)" />', "</linearGradient>", "</defs>", '<rect width="18px" height="100%" fill="url(#g-{{id}})"></rect>', '<path transform="translate(-6,-3)" class="{{cssPrefix}}huebar-handle" d="M0 0 L4 4 L0 8 L0 0 Z" fill="black" stroke="none" />', "</svg>"].join(`
`), S = ['<div class="{{cssPrefix}}vml-huebar">', '<v:rect strokecolor="#ccc" class="{{cssPrefix}}vml {{cssPrefix}}vml-huebar-bg">', '<v:fill type="gradient" method="none" colors="0% rgb(255,0,0), 16.666% rgb(255,255,0), 33.333% rgb(0,255,0), 50% rgb(0,255,255), 66.666% rgb(0,0,255), 83.333% rgb(255,0,255), 100% rgb(255,0,0)" angle="180" class="{{cssPrefix}}vml" />', "</v:rect>", '<v:shape class="{{cssPrefix}}vml {{cssPrefix}}huebar-handle" coordsize="1 1" style="width:1px;height:1px;position:absolute;z-index:1;right:22px;top:-3px;"path="m 0,0 l 4,4 l 0,8 l 0,0 z" filled="true" fillcolor="black" stroked="false" />', "</div>"].join(`
`);
              f && c.document.namespaces.add("v", "urn:schemas-microsoft-com:vml"), r.exports = {
                layout: p,
                slider: f ? m : d,
                huebar: f ? S : y
              };
            }).call(this, l(25));
          }
          /******/
        ])
      );
    });
  }(Aj)), Aj.exports;
}
/*!
 * TOAST UI Editor : Color Syntax Plugin
 * @version 3.1.0 | Fri Aug 05 2022
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
var fV;
function aGe() {
  return fV || (fV = 1, function(i, e) {
    (function(s, l) {
      i.exports = l(iGe());
    })(self, function(r) {
      return (
        /******/
        function() {
          var s = {
            /***/
            858: (
              /***/
              function(p) {
                p.exports = r;
              }
            )
            /******/
          }, l = {};
          function c(p) {
            var d = l[p];
            if (d !== void 0)
              return d.exports;
            var m = l[p] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            return s[p](m, m.exports, c), m.exports;
          }
          (function() {
            c.n = function(p) {
              var d = p && p.__esModule ? (
                /******/
                function() {
                  return p.default;
                }
              ) : (
                /******/
                function() {
                  return p;
                }
              );
              return c.d(d, { a: d }), d;
            };
          })(), function() {
            c.d = function(p, d) {
              for (var m in d)
                c.o(d, m) && !c.o(p, m) && Object.defineProperty(p, m, { enumerable: !0, get: d[m] });
            };
          }(), function() {
            c.o = function(p, d) {
              return Object.prototype.hasOwnProperty.call(p, d);
            };
          }();
          var f = {};
          return function() {
            c.d(f, {
              default: function() {
                return (
                  /* binding */
                  z
                );
              }
            });
            var p = c(858), d = /* @__PURE__ */ c.n(p);
            function m(J) {
              J.setLanguage("ar", {
                "Text color": "لون النص"
              }), J.setLanguage(["cs", "cs-CZ"], {
                "Text color": "Barva textu"
              }), J.setLanguage(["de", "de-DE"], {
                "Text color": "Textfarbe"
              }), J.setLanguage(["en", "en-US"], {
                "Text color": "Text color"
              }), J.setLanguage(["es", "es-ES"], {
                "Text color": "Color del texto"
              }), J.setLanguage(["fi", "fi-FI"], {
                "Text color": "Tekstin väri"
              }), J.setLanguage(["fr", "fr-FR"], {
                "Text color": "Couleur du texte"
              }), J.setLanguage(["gl", "gl-ES"], {
                "Text color": "Cor do texto"
              }), J.setLanguage(["hr", "hr-HR"], {
                "Text color": "Boja teksta"
              }), J.setLanguage(["it", "it-IT"], {
                "Text color": "Colore del testo"
              }), J.setLanguage(["ja", "ja-JP"], {
                "Text color": "文字色相"
              }), J.setLanguage(["ko", "ko-KR"], {
                "Text color": "글자 색상"
              }), J.setLanguage(["nb", "nb-NO"], {
                "Text color": "Tekstfarge"
              }), J.setLanguage(["nl", "nl-NL"], {
                "Text color": "Tekstkleur"
              }), J.setLanguage(["pl", "pl-PL"], {
                "Text color": "Kolor tekstu"
              }), J.setLanguage(["pt", "pt-BR"], {
                "Text color": "Cor do texto"
              }), J.setLanguage(["ru", "ru-RU"], {
                "Text color": "Цвет текста"
              }), J.setLanguage(["sv", "sv-SE"], {
                "Text color": "Textfärg"
              }), J.setLanguage(["tr", "tr-TR"], {
                "Text color": "Metin rengi"
              }), J.setLanguage(["uk", "uk-UA"], {
                "Text color": "Колір тексту"
              }), J.setLanguage("zh-CN", {
                "Text color": "文字颜色"
              }), J.setLanguage("zh-TW", {
                "Text color": "文字顏色"
              });
            }
            function y(J, ie) {
              return J.classList.contains(ie);
            }
            function S(J, ie) {
              for (var K = J; K && !y(K, ie); )
                K = K.parentElement;
              return K;
            }
            var x = "toastui-editor-";
            function w(J) {
              var ie = document.createElement("button");
              return ie.setAttribute("type", "button"), ie.textContent = J, ie;
            }
            function k(J, ie) {
              return {
                name: "color",
                tooltip: ie.get("Text color"),
                className: x + "toolbar-icons color",
                popup: {
                  className: x + "popup-color",
                  body: J,
                  style: { width: "auto" }
                }
              };
            }
            function O(J, ie, K, re, ee) {
              var de = J.mapping, Ce = J.doc, he = ie.from, oe = ie.to, ge = ie.empty, we = de.map(he) + re.length, Oe = de.map(oe) - ee.length;
              return ge ? K.create(Ce, Oe, Oe) : K.create(Ce, we, Oe);
            }
            function T(J, ie) {
              var K = S(J, x + "defaultUI");
              return K.querySelector("." + ie + " .ProseMirror");
            }
            var L, j;
            function z(J, ie) {
              ie === void 0 && (ie = {});
              var K = J.eventEmitter, re = J.i18n, ee = J.usageStatistics, de = ee === void 0 ? !0 : ee, Ce = J.pmState, he = ie.preset, oe = document.createElement("div"), ge = { container: oe, usageStatistics: de };
              m(re), he && (ge.preset = he);
              var we = d().create(ge), Oe = w(re.get("OK"));
              K.listen("focus", function(Me) {
                L = "" + x + (Me === "markdown" ? "md" : "ww") + "-container";
              }), oe.addEventListener("click", function(Me) {
                if (Me.target.getAttribute("type") === "button") {
                  var Ie = we.getColor();
                  j = T(oe, L), K.emit("command", "color", { selectedColor: Ie }), K.emit("closePopup"), j.focus();
                }
              }), we.slider.toggle(!0), oe.appendChild(Oe);
              var Qe = k(oe, re);
              return {
                markdownCommands: {
                  color: function(Me, Ie, rt) {
                    var ot = Me.selectedColor, Et = Ie.tr, gt = Ie.selection, At = Ie.schema;
                    if (ot) {
                      var Mt = gt.content(), St = Mt.content.textBetween(0, Mt.content.size, `
`), Ve = '<span style="color: ' + ot + '">', Ue = "</span>", He = "" + Ve + St + Ue;
                      return Et.replaceSelectionWith(At.text(He)).setSelection(O(Et, gt, Ce.TextSelection, Ve, Ue)), rt(Et), !0;
                    }
                    return !1;
                  }
                },
                wysiwygCommands: {
                  color: function(Me, Ie, rt) {
                    var ot = Me.selectedColor, Et = Ie.tr, gt = Ie.selection, At = Ie.schema;
                    if (ot) {
                      var Mt = gt.from, St = gt.to, Ve = { htmlAttrs: { style: "color: " + ot } }, Ue = At.marks.span.create(Ve);
                      return Et.addMark(Mt, St, Ue), rt(Et), !0;
                    }
                    return !1;
                  }
                },
                toolbarItems: [
                  {
                    groupIndex: 0,
                    itemIndex: 3,
                    item: Qe
                  }
                ],
                toHTMLRenderers: {
                  htmlInline: {
                    span: function(Me, Ie) {
                      var rt = Ie.entering;
                      return rt ? { type: "openTag", tagName: "span", attributes: Me.attrs } : { type: "closeTag", tagName: "span" };
                    }
                  }
                }
              };
            }
          }(), f = f.default, f;
        }()
      );
    });
  }(Tj)), Tj.exports;
}
var oGe = aGe();
const sGe = /* @__PURE__ */ Cp(oGe);
var Ej = { exports: {} };
/*!
 * TOAST UI Editor : Table Merged Cell Plugin
 * @version 3.1.0 | Fri Aug 05 2022
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
var dV;
function lGe() {
  return dV || (dV = 1, function() {
    var i = {
      /***/
      893: (
        /***/
        function(l) {
          function c(f, p, d) {
            var m = 0, y = f.length;
            for (d = d || null; m < y && p.call(d, f[m], m, f) !== !1; m += 1)
              ;
          }
          l.exports = c;
        }
      ),
      /***/
      990: (
        /***/
        function(l, c, f) {
          var p = f(893);
          function d(m) {
            var y;
            try {
              y = Array.prototype.slice.call(m);
            } catch {
              y = [], p(m, function(x) {
                y.push(x);
              });
            }
            return y;
          }
          l.exports = d;
        }
      )
      /******/
    }, e = {};
    function r(l) {
      var c = e[l];
      if (c !== void 0)
        return c.exports;
      var f = e[l] = {
        /******/
        // no module.id needed
        /******/
        // no module.loaded needed
        /******/
        exports: {}
        /******/
      };
      return i[l](f, f.exports, r), f.exports;
    }
    (function() {
      r.n = function(l) {
        var c = l && l.__esModule ? (
          /******/
          function() {
            return l.default;
          }
        ) : (
          /******/
          function() {
            return l;
          }
        );
        return r.d(c, { a: c }), c;
      };
    })(), function() {
      r.d = function(l, c) {
        for (var f in c)
          r.o(c, f) && !r.o(l, f) && Object.defineProperty(l, f, { enumerable: !0, get: c[f] });
      };
    }(), function() {
      r.o = function(l, c) {
        return Object.prototype.hasOwnProperty.call(l, c);
      };
    }();
    var s = {};
    (function() {
      r.d(s, {
        default: function() {
          return (
            /* binding */
            qe
          );
        }
      });
      function l(pe, _e, Xe) {
        var lt = new RegExp("^((?:" + Xe + "=[0-9]+:)?)" + _e + "=([0-9]+):(.*)"), Q = lt.exec(pe), te = 1;
        return Q && (te = parseInt(Q[2], 10), pe = Q[1] + Q[3]), [te, pe];
      }
      function c(pe, _e, Xe) {
        var lt = _e.prev;
        if (lt)
          for (var Q = _e.parent.parent.columns.length, te = pe.startIdx; te < Q; te += 1) {
            var De = lt.rowspanMap[te];
            De && De > 1 && (_e.rowspanMap[te] = De - 1, te <= pe.endIdx && (pe.startIdx += 1, pe.endIdx += 1));
          }
        if (Xe > 1)
          for (var nt = pe.startIdx, be = pe.endIdx, te = nt; te <= be; te += 1)
            _e.rowspanMap[te] = Xe;
      }
      var f = {
        // @ts-expect-error
        tableRow: function(pe, _e) {
          var Xe = _e.entering;
          if (Xe && (pe.rowspanMap = {}, pe.prev && !pe.firstChild)) {
            var lt = pe.prev.rowspanMap;
            Object.keys(lt).forEach(function(Q) {
              lt[Q] > 1 && (pe.rowspanMap[Q] = lt[Q] - 1);
            });
          }
        },
        // @ts-expect-error
        tableCell: function(pe, _e) {
          var Xe, lt, Q = _e.entering, te = pe.parent, De = pe.prev, nt = pe.stringContent;
          if (Q) {
            var be = {}, G = nt, V = [1, 1], ve = V[0], Ne = V[1];
            Xe = l(G, "@cols", "@rows"), ve = Xe[0], G = Xe[1], lt = l(G, "@rows", "@cols"), Ne = lt[0], G = lt[1], pe.stringContent = G, De && (pe.startIdx = De.endIdx + 1, pe.endIdx = pe.startIdx), ve > 1 && (be.colspan = ve, pe.endIdx += ve - 1), Ne > 1 && (be.rowspan = Ne), pe.attrs = be, c(pe, te, Ne);
            var it = te.parent;
            it.type === "tableBody" && pe.endIdx >= it.parent.columns.length && (pe.ignored = !0);
          }
        }
      }, p = function() {
        return p = Object.assign || function(pe) {
          for (var _e, Xe = 1, lt = arguments.length; Xe < lt; Xe++) {
            _e = arguments[Xe];
            for (var Q in _e) Object.prototype.hasOwnProperty.call(_e, Q) && (pe[Q] = _e[Q]);
          }
          return pe;
        }, p.apply(this, arguments);
      }, d = {
        // @ts-ignore
        tableRow: function(pe, _e) {
          var Xe = _e.entering, lt = _e.origin;
          if (Xe)
            return lt();
          var Q = [];
          if (pe.lastChild)
            for (var te = pe.parent.parent.columns.length, De = pe.lastChild.endIdx, nt = De + 1; nt < te; nt += 1)
              (!pe.prev || !pe.prev.rowspanMap[nt] || pe.prev.rowspanMap[nt] <= 1) && Q.push({
                type: "openTag",
                tagName: "td",
                outerNewLine: !0
              }, {
                type: "closeTag",
                tagName: "td",
                outerNewLine: !0
              });
          return Q.push({
            type: "closeTag",
            tagName: "tr",
            outerNewLine: !0
          }), Q;
        },
        // @ts-ignore
        tableCell: function(pe, _e) {
          var Xe = _e.entering, lt = _e.origin, Q = lt();
          if (pe.ignored)
            return Q;
          if (Xe) {
            var te = p({}, pe.attrs);
            Q.attributes = p(p({}, Q.attributes), te);
          }
          return Q;
        }
      }, m = 3;
      function y(pe, _e) {
        for (var Xe = "", lt = 0; lt < _e; lt += 1)
          Xe += pe;
        return Xe;
      }
      function S(pe, _e) {
        var Xe = pe.length, lt = "", Q = "";
        return _e === "left" ? (lt = ":", Xe -= 1) : _e === "right" ? (Q = ":", Xe -= 1) : _e === "center" && (lt = ":", Q = ":", Xe -= 2), "" + lt + y("-", Math.max(Xe, m)) + Q;
      }
      function x(pe) {
        var _e = pe.attrs, Xe = _e.rowspan, lt = _e.colspan, Q = "";
        return Xe && (Q = "@rows=" + Xe + ":"), lt && (Q = "@cols=" + lt + ":" + Q), { delim: "| " + Q };
      }
      var w = {
        tableHead: function(pe) {
          var _e = pe.node.firstChild, Xe = "";
          return _e && _e.forEach(function(lt) {
            var Q = lt.textContent, te = lt.attrs, De = S(Q, te.align);
            if (Xe += "| " + De + " ", te.colspan)
              for (var nt = 0; nt < te.colspan - 1; nt += 1)
                Xe += "| " + De + " ";
          }), { delim: Xe };
        },
        tableHeadCell: function(pe) {
          return x(pe.node);
        },
        tableBodyCell: function(pe) {
          return x(pe.node);
        }
      };
      function k(pe) {
        pe.setLanguage(["ko", "ko-KR"], {
          "Merge cells": "셀 병합",
          "Split cells": "셀 병합해제",
          "Cannot change part of merged cell": "병합된 셀의 일부를 변경할 수 없습니다.",
          "Cannot paste row merged cells into the table header": "테이블 헤더에는 행 병합된 셀을 붙여넣을 수 없습니다."
        }), pe.setLanguage(["en", "en-US"], {
          "Merge cells": "Merge cells",
          "Split cells": "Split cells",
          "Cannot change part of merged cell": "Cannot change part of merged cell.",
          "Cannot paste row merged cells into the table header": "Cannot paste row merged cells into the table header."
        }), pe.setLanguage(["es", "es-ES"], {
          "Merge cells": "Combinar celdas",
          "Split cells": "Separar celdas",
          "Cannot change part of merged cell": "No se puede cambiar parte de una celda combinada.",
          "Cannot paste row merged cells into the table header": "No se pueden pegar celdas combinadas en el encabezado de tabla."
        }), pe.setLanguage(["ja", "ja-JP"], {
          "Merge cells": "セルの結合",
          "Split cells": "セルの結合を解除",
          "Cannot change part of merged cell": "結合されたセルの一部を変更することはできません。",
          "Cannot paste row merged cells into the table header": "行にマージされたセルをヘッダーに貼り付けることはできません。"
        }), pe.setLanguage(["nl", "nl-NL"], {
          "Merge cells": "Cellen samenvoegen",
          "Split cells": "Samengevoegde cellen ongedaan maken",
          "Cannot change part of merged cell": "Kan geen deel uit van een samengevoegde cel veranderen.",
          "Cannot paste row merged cells into the table header": "Kan geen rij met samengevoegde cellen in de koptekst plakken."
        }), pe.setLanguage("zh-CN", {
          "Merge cells": "合并单元格",
          "Split cells": "取消合并单元格",
          "Cannot change part of merged cell": "无法更改合并单元格的一部分。",
          "Cannot paste row merged cells into the table header": "无法将行合并单元格粘贴到标题中。"
        }), pe.setLanguage(["de", "de-DE"], {
          "Merge cells": "Zellen zusammenführen",
          "Split cells": "Zusammenführen rückgängig machen",
          "Cannot change part of merged cell": "Der Teil der verbundenen Zelle kann nicht geändert werden.",
          "Cannot paste row merged cells into the table header": "Die Zeile der verbundenen Zellen kann nicht in die Kopfzeile eingefügt werden."
        }), pe.setLanguage(["ru", "ru-RU"], {
          "Merge cells": "Объединить ячейки",
          "Split cells": "Разъединить ячейки",
          "Cannot change part of merged cell": "Вы не можете изменять часть комбинированной ячейки.",
          "Cannot paste row merged cells into the table header": "Вы не можете вставлять объединенные ячейки в заголовок таблицы."
        }), pe.setLanguage(["fr", "fr-FR"], {
          "Merge cells": "Fusionner les cellules",
          "Split cells": "Séparer les cellules",
          "Cannot change part of merged cell": "Impossible de modifier une partie de la cellule fusionnée.",
          "Cannot paste row merged cells into the table header": "Impossible de coller les cellules fusionnées dans l'en-tête du tableau."
        }), pe.setLanguage(["uk", "uk-UA"], {
          "Merge cells": "Об'єднати комірки",
          "Split cells": "Роз'єднати комірки",
          "Cannot change part of merged cell": "Ви не можете змінювати частину комбінованої комірки.",
          "Cannot paste row merged cells into the table header": "Ви не можете вставляти об'єднані комірки в заголовок таблиці."
        }), pe.setLanguage(["tr", "tr-TR"], {
          "Merge cells": "Hücreleri birleştir",
          "Split cells": "Hücreleri ayır",
          "Cannot change part of merged cell": "Birleştirilmiş hücrelerin bir kısmı değiştirelemez.",
          "Cannot paste row merged cells into the table header": "Satırda birleştirilmiş hücreler sütun başlığına yapıştırılamaz"
        }), pe.setLanguage(["fi", "fi-FI"], {
          "Merge cells": "Yhdistä solut",
          "Split cells": "Jaa solut",
          "Cannot change part of merged cell": "Yhdistettyjen solujen osaa ei voi muuttaa",
          "Cannot paste row merged cells into the table header": "Soluja ei voi yhdistää taulukon otsikkoriviin"
        }), pe.setLanguage(["cs", "cs-CZ"], {
          "Merge cells": "Spojit buňky",
          "Split cells": "Rozpojit buňky",
          "Cannot change part of merged cell": "Nelze měnit část spojené buňky",
          "Cannot paste row merged cells into the table header": "Nelze vkládat spojené buňky do záhlaví tabulky"
        }), pe.setLanguage("ar", {
          "Merge cells": "دمج الوحدات",
          "Split cells": "إلغاء دمج الوحدات",
          "Cannot change part of merged cell": "لا يمكن تغيير جزء من الخلية المدموجة",
          "Cannot paste row merged cells into the table header": "لا يمكن لصق الخلايا المدموجة من صف واحد في رأس الجدول"
        }), pe.setLanguage(["pl", "pl-PL"], {
          "Merge cells": "Scal komórki",
          "Split cells": "Rozłącz komórki",
          "Cannot change part of merged cell": "Nie można zmienić części scalonej komórki.",
          "Cannot paste row merged cells into the table header": "Nie można wkleić komórek o scalonym rzędzie w nagłówek tabeli."
        }), pe.setLanguage("zh-TW", {
          "Merge cells": "合併儲存格",
          "Split cells": "取消合併儲存格",
          "Cannot change part of merged cell": "無法變更儲存格的一部分。",
          "Cannot paste row merged cells into the table header": "無法將合併的儲存格貼上至表格標題中。"
        }), pe.setLanguage(["gl", "gl-ES"], {
          "Merge cells": "Combinar celas",
          "Split cells": "Separar celas",
          "Cannot change part of merged cell": "Non se pode cambiar parte dunha cela combinada",
          "Cannot paste row merged cells into the table header": "Non se poden pegar celas no encabezado da táboa"
        }), pe.setLanguage(["sv", "sv-SE"], {
          "Merge cells": "Sammanfoga celler",
          "Split cells": "Dela celler",
          "Cannot change part of merged cell": "Ej möjligt att ändra en del av en sammanfogad cell",
          "Cannot paste row merged cells into the table header": "Ej möjligt att klistra in rad-sammanfogade celler i tabellens huvud"
        }), pe.setLanguage(["it", "it-IT"], {
          "Merge cells": "Unisci celle",
          "Split cells": "Separa celle",
          "Cannot change part of merged cell": "Non è possibile modificare parte di una cella unita",
          "Cannot paste row merged cells into the table header": "Non è possibile incollare celle unite per riga nell'intestazione della tabella"
        }), pe.setLanguage(["nb", "nb-NO"], {
          "Merge cells": "Slå sammen celler",
          "Split cells": "Separer celler",
          "Cannot change part of merged cell": "Kan ikke endre deler av sammenslåtte celler",
          "Cannot paste row merged cells into the table header": "Kan ikke lime inn rad med sammenslåtte celler"
        }), pe.setLanguage(["hr", "hr-HR"], {
          "Merge cells": "Spoji ćelije",
          "Split cells": "Odspoji ćelije",
          "Cannot change part of merged cell": "Ne mogu mijenjati dio spojene ćelije.",
          "Cannot paste row merged cells into the table header": "Ne mogu zaljepiti redak spojenih ćelija u zaglavlje tablice"
        });
      }
      var O = function() {
        return O = Object.assign || function(pe) {
          for (var _e, Xe = 1, lt = arguments.length; Xe < lt; Xe++) {
            _e = arguments[Xe];
            for (var Q in _e) Object.prototype.hasOwnProperty.call(_e, Q) && (pe[Q] = _e[Q]);
          }
          return pe;
        }, O.apply(this, arguments);
      }, T = {
        extendedRowspan: function(pe, _e) {
          var Xe = this.rowInfo[pe].rowspanMap[_e];
          return !!Xe && Xe.startSpanIdx !== pe;
        },
        extendedColspan: function(pe, _e) {
          var Xe = this.rowInfo[pe].colspanMap[_e];
          return !!Xe && Xe.startSpanIdx !== _e;
        },
        getRowspanCount: function(pe, _e) {
          var Xe = this.rowInfo[pe].rowspanMap[_e];
          return Xe ? Xe.count : 0;
        },
        getColspanCount: function(pe, _e) {
          var Xe = this.rowInfo[pe].colspanMap[_e];
          return Xe ? Xe.count : 0;
        },
        decreaseColspanCount: function(pe, _e) {
          var Xe = this.rowInfo[pe].colspanMap[_e], lt = this.rowInfo[pe].colspanMap[Xe.startSpanIdx];
          return lt.count -= 1, lt.count;
        },
        decreaseRowspanCount: function(pe, _e) {
          var Xe = this.rowInfo[pe].rowspanMap[_e], lt = this.rowInfo[Xe.startSpanIdx].rowspanMap[_e];
          return lt.count -= 1, lt.count;
        },
        getColspanStartInfo: function(pe, _e) {
          var Xe = this.rowInfo[pe].colspanMap, lt = Xe[_e];
          if (lt) {
            var Q = lt.startSpanIdx, te = this.rowInfo[pe][Q];
            return {
              node: this.table.nodeAt(te.offset - this.tableStartOffset),
              pos: te.offset,
              startSpanIdx: Q,
              count: Xe[Q].count
            };
          }
          return null;
        },
        getRowspanStartInfo: function(pe, _e) {
          var Xe = this.rowInfo[pe].rowspanMap, lt = Xe[_e];
          if (lt) {
            var Q = lt.startSpanIdx, te = this.rowInfo[Q][_e];
            return {
              node: this.table.nodeAt(te.offset - this.tableStartOffset),
              pos: te.offset,
              startSpanIdx: Q,
              count: this.rowInfo[Q].rowspanMap[_e].count
            };
          }
          return null;
        },
        getSpannedOffsets: function(pe) {
          for (var _e = pe.startRowIdx, Xe = pe.startColIdx, lt = pe.endRowIdx, Q = pe.endColIdx, te = lt; te >= _e; te -= 1)
            if (this.rowInfo[te])
              for (var De = this.rowInfo[te], nt = De.rowspanMap, be = De.colspanMap, G = Q; G >= Xe; G -= 1) {
                var V = nt[G], ve = be[G];
                V && (_e = Math.min(_e, V.startSpanIdx)), ve && (Xe = Math.min(Xe, ve.startSpanIdx));
              }
          for (var te = _e; te <= lt; te += 1)
            if (this.rowInfo[te])
              for (var Ne = this.rowInfo[te], nt = Ne.rowspanMap, be = Ne.colspanMap, G = Xe; G <= Q; G += 1) {
                var V = nt[G], ve = be[G];
                V && (lt = Math.max(lt, te + V.count - 1)), ve && (Q = Math.max(Q, G + ve.count - 1));
              }
          return { startRowIdx: _e, startColIdx: Xe, endRowIdx: lt, endColIdx: Q };
        }
      };
      function L(pe, _e) {
        var Xe = _e.rowspanMap, lt = _e.colspanMap, Q = pe.rowspanMap, te = pe.colspanMap;
        Object.keys(Q).forEach(function(De) {
          var nt = Number(De), be = Q[nt];
          if ((be == null ? void 0 : be.count) > 1) {
            var G = te[nt], V = be.count, ve = be.startSpanIdx;
            Xe[nt] = { count: V - 1, startSpanIdx: ve }, lt[nt] = G, _e[nt] = O(O({}, pe[nt]), { extended: !0 }), _e.length += 1;
          }
        });
      }
      function j(pe, _e, Xe, lt, Q) {
        for (var te = Q.rowspanMap, De = Q.colspanMap, nt = 1; nt < _e; nt += 1)
          De[lt + nt] = { count: _e - nt, startSpanIdx: lt }, pe > 1 && (te[lt + nt] = { count: pe, startSpanIdx: Xe }), Q[lt + nt] = O({}, Q[lt]), Q.length += 1;
      }
      var z = function(pe, _e, Xe) {
        Xe === void 0 && (Xe = !1);
        var lt = [], Q = pe.type.name === "tableBody";
        return pe.forEach(function(te, De, nt) {
          var be = Q && !Xe ? nt + 1 : nt, G = lt[nt - 1], V = { rowspanMap: {}, colspanMap: {}, length: 0 };
          G && L(G, V), te.forEach(function(ve, Ne) {
            for (var it, yt, $t = ve.nodeSize, Gt = ve.attrs, Jt = (it = Gt.colspan) !== null && it !== void 0 ? it : 1, Xt = (yt = Gt.rowspan) !== null && yt !== void 0 ? yt : 1, Ae = 0; V[Ae]; )
              Ae += 1;
            V[Ae] = {
              // 2 is the sum of the front and back positions of the tag
              offset: _e + De + Ne + 2,
              nodeSize: $t
            }, V.length += 1, Xt > 1 && (V.rowspanMap[Ae] = { count: Xt, startSpanIdx: be }), Jt > 1 && (V.colspanMap[Ae] = { count: Jt, startSpanIdx: Ae }, j(Xt, Jt, be, Ae, V));
          }), lt.push(V);
        }), lt;
      }, J = r(990), ie = /* @__PURE__ */ r.n(J), K = ".toastui-editor-cell-selected";
      function re(pe) {
        return Number(pe.getAttribute("colspan")) > 1 || Number(pe.getAttribute("rowspan")) > 1;
      }
      function ee(pe) {
        return ie()(pe.querySelectorAll(K)).some(re);
      }
      function de(pe) {
        return !!pe.querySelectorAll(K).length;
      }
      function Ce(pe, _e) {
        var Xe = pe.i18n, lt = pe.eventEmitter, Q = _e.parentElement.parentElement, te = [];
        return de(Q) && te.push({
          label: Xe.get("Merge cells"),
          onClick: function() {
            return lt.emit("command", "mergeCells");
          },
          className: "merge-cells"
        }), (re(_e) || ee(Q)) && te.push({
          label: Xe.get("Split cells"),
          onClick: function() {
            return lt.emit("command", "splitCells");
          },
          className: "split-cells"
        }), te;
      }
      function he(pe) {
        pe.eventEmitter.listen("contextmenu", function() {
          for (var _e = [], Xe = 0; Xe < arguments.length; Xe++)
            _e[Xe] = arguments[Xe];
          var lt = _e[0], Q = lt.menuGroups, te = lt.tableCell, De = Ce(pe, te);
          De.length && Q.splice(2, 0, De);
        });
      }
      var oe = function() {
        return oe = Object.assign || function(pe) {
          for (var _e, Xe = 1, lt = arguments.length; Xe < lt; Xe++) {
            _e = arguments[Xe];
            for (var Q in _e) Object.prototype.hasOwnProperty.call(_e, Q) && (pe[Q] = _e[Q]);
          }
          return pe;
        }, oe.apply(this, arguments);
      };
      function ge(pe, _e) {
        for (var Xe = pe.depth; Xe >= 0; ) {
          var lt = pe.node(Xe);
          if (_e(lt, Xe))
            return {
              node: lt,
              depth: Xe,
              offset: Xe > 0 ? pe.before(Xe) : 0
            };
          Xe -= 1;
        }
        return null;
      }
      function we(pe) {
        return ge(pe, function(_e) {
          var Xe = _e.type;
          return Xe.name === "tableHeadCell" || Xe.name === "tableBodyCell";
        });
      }
      function Oe(pe, _e) {
        if (pe instanceof _e.pmState.TextSelection) {
          var Xe = pe.$anchor, lt = we(Xe);
          if (lt) {
            var Q = Xe.node(0).resolve(Xe.before(lt.depth));
            return { anchor: Q, head: Q };
          }
        }
        var te = pe, De = te.startCell, nt = te.endCell;
        return { anchor: De, head: nt };
      }
      function Qe(pe) {
        var _e = pe.startRowIdx, Xe = pe.startColIdx, lt = pe.endRowIdx, Q = pe.endColIdx;
        return { rowCount: lt - _e + 1, columnCount: Q - Xe + 1 };
      }
      function Me(pe, _e) {
        return oe(oe({}, pe.attrs), _e);
      }
      function Ie(pe) {
        var _e = Object.getPrototypeOf(pe);
        return _e.constructor;
      }
      function rt(pe, _e, Xe, lt) {
        lt === void 0 && (lt = null);
        for (var Q = Xe.nodes, te = Q.tableHeadCell, De = Q.tableBodyCell, nt = Q.paragraph, be = _e === 0 ? te : De, G = [], V = 0; V < pe; V += 1)
          G.push(be.create(lt, nt.create()));
        return G;
      }
      function ot(pe, _e) {
        var Xe = pe.pmModel.Fragment, lt = function(Q, te, De) {
          var nt = te.selection, be = te.tr, G = Oe(nt, pe), V = G.anchor, ve = G.head;
          if (!V || !ve || !nt.isCellSelection)
            return !1;
          var Ne = _e.create(V), it = Ie(nt), yt = Ne.totalRowCount, $t = Ne.totalColumnCount, Gt = Ne.getRectOffsets(V, ve), Jt = Qe(Gt), Xt = Jt.rowCount, Ae = Jt.columnCount, vt = Gt.startRowIdx, Ot = Gt.startColIdx, Vt = Gt.endRowIdx, et = Gt.endColIdx, ft = Xt >= yt - 1 && Ae === $t, $ = vt === 0 && Vt > vt;
          if (ft || $)
            return !1;
          for (var Se = Xe.empty, se = vt; se <= Vt; se += 1)
            for (var M = Ot; M <= et; M += 1)
              if (se === vt && M === Ot)
                Se = gt(se, M, Se, Ne);
              else if (!Ne.extendedRowspan(se, M) && !Ne.extendedColspan(se, M)) {
                var ne = Ne.getCellInfo(se, M), ce = ne.offset, X = ne.nodeSize, Re = be.mapping.map(ce), Ge = Re + X;
                Se = gt(se, M, Se, Ne), be.delete(Re, Ge);
              }
          var pt = Ne.getNodeAndPos(vt, Ot), xt = pt.node, Pt = pt.pos;
          return Et(be, Se, {
            startNode: xt,
            startPos: Pt,
            rowCount: Xt,
            columnCount: Ae
          }), be.setSelection(new it(be.doc.resolve(Pt))), De(be), !0;
        };
        return lt;
      }
      function Et(pe, _e, Xe) {
        var lt = Xe.startNode, Q = Xe.startPos, te = Xe.rowCount, De = Xe.columnCount;
        pe.setNodeMarkup(Q, null, Me(lt, { colspan: De, rowspan: te })), _e.size && pe.replaceWith(Q + 1, Q + lt.content.size, _e);
      }
      function gt(pe, _e, Xe, lt) {
        var Q = lt.getNodeAndPos(pe, _e).node.content;
        return Q.size > 2 ? Xe.append(Q) : Xe;
      }
      function At(pe, _e, Xe) {
        var lt = _e;
        if (!Xe.extendedRowspan(pe, _e) && Xe.extendedColspan(pe, _e)) {
          var Q = Xe.getColspanStartInfo(pe, _e), te = Q.startSpanIdx, De = Q.count;
          lt = te + De;
        }
        return lt;
      }
      function Mt(pe, _e, Xe, lt) {
        var Q = pe.totalColumnCount;
        return pe.extendedRowspan(Xe, lt) && pe.extendedRowspan(Xe, Q - 1) && _e === pe.posAt(Xe, Q - 1);
      }
      function St(pe, _e) {
        var Xe = function(lt, Q, te, De) {
          var nt = Q.selection, be = Q.tr, G = Oe(nt, pe), V = G.anchor, ve = G.head;
          if (!V || !ve)
            return !1;
          for (var Ne = _e.create(V), it = Ne.getRectOffsets(V, ve), yt = it.startRowIdx, $t = it.startColIdx, Gt = it.endRowIdx, Jt = it.endColIdx, Xt = -1, Ae = yt; Ae <= Gt; Ae += 1)
            for (var vt = $t; vt <= Jt; vt += 1)
              if (Ne.extendedRowspan(Ae, vt) || Ne.extendedColspan(Ae, vt)) {
                var Ot = Ne.getNodeAndPos(Ae, vt).node, Vt = At(Ae, vt, Ne), et = Ne.posAt(Ae, Vt), ft = be.mapping.map(et);
                Mt(Ne, et, Ae, Vt) && (ft += 2), Xt = Math.max(ft, Xt), be.insert(ft, Ot.type.createAndFill(Me(Ot, { colspan: null, rowspan: null })));
              } else {
                var $ = Ne.getNodeAndPos(Ae, vt), Ot = $.node, ft = $.pos;
                Xt = Math.max(be.mapping.map(ft), Xt), be.setNodeMarkup(be.mapping.map(ft), null, Me(Ot, { colspan: null, rowspan: null }));
              }
          return te(be), Ve(De, nt, _e, Ne.tableStartOffset, it), !0;
        };
        return Xe;
      }
      function Ve(pe, _e, Xe, lt, Q) {
        if (_e.isCellSelection) {
          var te = pe.state.tr, De = Ie(_e), nt = Q.startRowIdx, be = Q.startColIdx, G = Q.endRowIdx, V = Q.endColIdx, ve = Xe.create(te.doc.resolve(lt)), Ne = ve.getCellInfo(nt, be).offset, it = ve.getCellInfo(G, V).offset;
          te.setSelection(new De(te.doc.resolve(Ne), te.doc.resolve(it))), pe.dispatch(te);
        }
      }
      function Ue(pe, _e) {
        var Xe = function(lt, Q, te) {
          var De = Q.selection, nt = Q.tr, be = Oe(De, pe), G = be.anchor, V = be.head;
          if (!G || !V)
            return !1;
          var ve = _e.create(G), Ne = ve.getRectOffsets(G, V), it = ve.totalColumnCount, yt = ve.totalRowCount, $t = Qe(Ne).columnCount, Gt = $t === it;
          if (Gt)
            return !1;
          for (var Jt = Ne.startColIdx, Xt = Ne.endColIdx, Ae = nt.mapping.maps.length, vt = 0; vt < yt; vt += 1)
            for (var Ot = Xt; Ot >= Jt; Ot -= 1) {
              var Vt = ve.getCellInfo(vt, Ot), et = Vt.offset, ft = Vt.nodeSize, $ = ve.getColspanStartInfo(vt, Ot);
              if (!ve.extendedRowspan(vt, Ot))
                if (($ == null ? void 0 : $.count) > 1) {
                  var Se = ve.getColspanStartInfo(vt, Ot), se = Se.node, M = Se.pos, ne = ve.decreaseColspanCount(vt, Ot), ce = Me(se, { colspan: ne > 1 ? ne : null });
                  nt.setNodeMarkup(nt.mapping.slice(Ae).map(M), null, ce);
                } else {
                  var X = nt.mapping.slice(Ae).map(et), Re = X + ft;
                  nt.delete(X, Re);
                }
            }
          return te(nt), !0;
        };
        return Xe;
      }
      function He(pe, _e) {
        for (var Xe = pe.totalColumnCount, lt = Number.MAX_VALUE, Q = 0, te = 0; te < Xe; te += 1)
          if (!pe.extendedRowspan(_e, te)) {
            var De = pe.getCellInfo(_e, te), nt = De.offset, be = De.nodeSize;
            lt = Math.min(lt, nt), Q = Math.max(Q, nt + be);
          }
        return { from: lt, to: Q };
      }
      function We(pe, _e) {
        var Xe = function(lt, Q, te) {
          var De = Q.selection, nt = Q.tr, be = Oe(De, pe), G = be.anchor, V = be.head;
          if (G && V) {
            var ve = _e.create(G), Ne = ve.totalRowCount, it = ve.totalColumnCount, yt = ve.getRectOffsets(G, V), $t = Qe(yt).rowCount, Gt = yt.startRowIdx, Jt = yt.endRowIdx, Xt = Gt === 0, Ae = $t === Ne - 1;
            if (Ae || Xt)
              return !1;
            for (var vt = Jt; vt >= Gt; vt -= 1) {
              var Ot = nt.mapping.maps.length, Vt = He(ve, vt), et = Vt.from, ft = Vt.to;
              nt.delete(et - 1, ft + 1);
              for (var $ = 0; $ < it; $ += 1) {
                var Se = ve.getRowspanStartInfo(vt, $);
                if ((Se == null ? void 0 : Se.count) > 1 && !ve.extendedColspan(vt, $)) {
                  if (ve.extendedRowspan(vt, $)) {
                    var se = ve.getRowspanStartInfo(vt, $), M = se.node, ne = se.pos, ce = ve.decreaseRowspanCount(vt, $), X = Me(M, { rowspan: ce > 1 ? ce : null });
                    nt.setNodeMarkup(nt.mapping.slice(Ot).map(ne), null, X);
                  } else if (!ve.extendedRowspan(vt, $)) {
                    var Re = ve.getRowspanStartInfo(vt, $), M = Re.node, Ge = Re.count, X = Me(M, { rowspan: Ge > 2 ? Ge - 1 : null }), pt = M.type.create(X, M.content);
                    nt.insert(nt.mapping.slice(Ot).map(ve.posAt(vt + 1, $)), pt);
                  }
                }
              }
              ve = _e.create(nt.doc.resolve(ve.tableStartOffset));
            }
            return te(nt), !0;
          }
          return !1;
        };
        return Xe;
      }
      var ze;
      (function(pe) {
        pe.LEFT = "left", pe.RIGHT = "right", pe.UP = "up", pe.DOWN = "down";
      })(ze || (ze = {}));
      function at(pe, _e, Xe) {
        var lt, Q, te, De;
        return pe === ze.UP ? (lt = Xe.startRowIdx, Q = function(nt) {
          return _e.extendedRowspan(lt, nt);
        }, te = 0, De = -1) : (lt = Xe.endRowIdx, Q = function(nt) {
          return _e.getRowspanCount(lt, nt) > 1;
        }, te = _e.totalColumnCount - 1, De = _e.extendedRowspan(lt, te) ? 2 : _e.getCellInfo(lt, te).nodeSize + 1), { targetRowIdx: lt, judgeToExtendRowspan: Q, insertColIdx: te, nodeSize: De };
      }
      function Ye(pe, _e, Xe) {
        var lt = function(Q, te, De) {
          var nt = te.selection, be = te.schema, G = te.tr, V = Oe(nt, pe), ve = V.anchor, Ne = V.head;
          if (!ve || !Ne)
            return !1;
          var it = _e.create(ve), yt = it.totalColumnCount, $t = it.getRectOffsets(ve, Ne), Gt = Qe($t).rowCount, Jt = at(Xe, it, $t), Xt = Jt.targetRowIdx, Ae = Jt.judgeToExtendRowspan, vt = Jt.insertColIdx, Ot = Jt.nodeSize, Vt = Xt === 0;
          if (Vt)
            return !1;
          for (var et = [], ft = G.mapping.map(it.posAt(Xt, vt)) + Ot, $ = [], Se = 0; Se < yt; Se += 1)
            if (Ae(Se)) {
              var se = it.getRowspanStartInfo(Xt, Se), M = se.node, ne = se.pos, ce = Me(M, { rowspan: M.attrs.rowspan + Gt });
              G.setNodeMarkup(G.mapping.map(ne), null, ce);
            } else
              $ = $.concat(rt(1, Xt, be));
          for (var X = 0; X < Gt; X += 1)
            et.push(be.nodes.tableRow.create(null, $));
          return De(G.insert(ft, et)), !0;
        };
        return lt;
      }
      function tt(pe, _e, Xe) {
        var lt, Q, te;
        return pe === ze.LEFT ? (lt = Xe.startColIdx, Q = function(De) {
          return _e.extendedColspan(De, lt);
        }, te = lt) : (lt = Xe.endColIdx, Q = function(De) {
          return _e.getColspanCount(De, lt) > 1;
        }, te = lt + 1), { targetColIdx: lt, judgeToExtendColspan: Q, insertColIdx: te };
      }
      function wt(pe, _e, Xe) {
        var lt = function(Q, te, De) {
          var nt = te.selection, be = te.tr, G = te.schema, V = Oe(nt, pe), ve = V.anchor, Ne = V.head;
          if (!ve || !Ne)
            return !1;
          for (var it = _e.create(ve), yt = it.getRectOffsets(ve, Ne), $t = tt(Xe, it, yt), Gt = $t.targetColIdx, Jt = $t.judgeToExtendColspan, Xt = $t.insertColIdx, Ae = Qe(yt).columnCount, vt = it.totalRowCount, Ot = 0; Ot < vt; Ot += 1)
            if (Jt(Ot)) {
              var Vt = it.getColspanStartInfo(Ot, Gt), et = Vt.node, ft = Vt.pos, $ = Me(et, { colspan: et.attrs.colspan + Ae });
              be.setNodeMarkup(be.mapping.map(ft), null, $);
            } else {
              var Se = rt(Ae, Ot, G);
              be.insert(be.mapping.map(it.posAt(Ot, Xt)), Se);
            }
          return De(be), !0;
        };
        return lt;
      }
      function Ft(pe, _e) {
        return {
          mergeCells: ot(pe, _e),
          splitCells: St(pe, _e),
          addRowToUp: Ye(pe, _e, ze.UP),
          addRowToDown: Ye(pe, _e, ze.DOWN),
          removeRow: We(pe, _e),
          addColumnToLeft: wt(pe, _e, ze.LEFT),
          addColumnToRight: wt(pe, _e, ze.RIGHT),
          removeColumn: Ue(pe, _e)
        };
      }
      function qe(pe) {
        var _e = pe.i18n, Xe = pe.eventEmitter, lt = Xe.emitReduce("mixinTableOffsetMapPrototype", T, z);
        return k(_e), he(pe), {
          toHTMLRenderers: d,
          markdownParsers: f,
          toMarkdownRenderers: w,
          wysiwygCommands: Ft(pe, lt)
        };
      }
    })(), Ej.exports = s.default;
  }()), Ej.exports;
}
var uGe = lGe();
const cGe = /* @__PURE__ */ Cp(uGe);
var Mj = { exports: {} };
function Tu(i) {
  throw new Error('Could not dynamically require "' + i + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var Rj = { exports: {} }, hV;
function fGe() {
  return hV || (hV = 1, function(i, e) {
    (function(r) {
      i.exports = r();
    })(function() {
      return (/* @__PURE__ */ function() {
        function r(s, l, c) {
          function f(m, y) {
            if (!l[m]) {
              if (!s[m]) {
                var S = typeof Tu == "function" && Tu;
                if (!y && S) return S(m, !0);
                if (p) return p(m, !0);
                var x = new Error("Cannot find module '" + m + "'");
                throw x.code = "MODULE_NOT_FOUND", x;
              }
              var w = l[m] = { exports: {} };
              s[m][0].call(w.exports, function(k) {
                var O = s[m][1][k];
                return f(O || k);
              }, w, w.exports, r, s, l, c);
            }
            return l[m].exports;
          }
          for (var p = typeof Tu == "function" && Tu, d = 0; d < c.length; d++) f(c[d]);
          return f;
        }
        return r;
      }())({ 1: [function(r, s, l) {
        var c = r("pako/lib/deflate.js");
        s.exports = function(f) {
          return c.deflateRaw(f, { level: 9, to: "string" });
        };
      }, { "pako/lib/deflate.js": 4 }], 2: [function(r, s, l) {
        function c(p) {
          return p < 10 ? String.fromCharCode(48 + p) : (p -= 10, p < 26 ? String.fromCharCode(65 + p) : (p -= 26, p < 26 ? String.fromCharCode(97 + p) : (p -= 26, p === 0 ? "-" : p === 1 ? "_" : "?")));
        }
        function f(p, d, m) {
          var y = p >> 2, S = (p & 3) << 4 | d >> 4, x = (d & 15) << 2 | m >> 6, w = m & 63, k = "";
          return k += c(y & 63), k += c(S & 63), k += c(x & 63), k += c(w & 63), k;
        }
        s.exports = function(p) {
          for (var d = "", m = 0; m < p.length; m += 3)
            m + 2 === p.length ? d += f(p.charCodeAt(m), p.charCodeAt(m + 1), 0) : m + 1 === p.length ? d += f(p.charCodeAt(m), 0, 0) : d += f(
              p.charCodeAt(m),
              p.charCodeAt(m + 1),
              p.charCodeAt(m + 2)
            );
          return d;
        };
      }, {}], 3: [function(r, s, l) {
        var c = r("./deflate"), f = r("./encode64");
        s.exports.encode = function(p) {
          var d = c(p);
          return f(d);
        };
      }, { "./deflate": 1, "./encode64": 2 }], 4: [function(r, s, l) {
        var c = r("./zlib/deflate"), f = r("./utils/common"), p = r("./utils/strings"), d = r("./zlib/messages"), m = r("./zlib/zstream"), y = Object.prototype.toString, S = 0, x = 4, w = 0, k = 1, O = 2, T = -1, L = 0, j = 8;
        function z(re) {
          if (!(this instanceof z)) return new z(re);
          this.options = f.assign({
            level: T,
            method: j,
            chunkSize: 16384,
            windowBits: 15,
            memLevel: 8,
            strategy: L,
            to: ""
          }, re || {});
          var ee = this.options;
          ee.raw && ee.windowBits > 0 ? ee.windowBits = -ee.windowBits : ee.gzip && ee.windowBits > 0 && ee.windowBits < 16 && (ee.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new m(), this.strm.avail_out = 0;
          var de = c.deflateInit2(
            this.strm,
            ee.level,
            ee.method,
            ee.windowBits,
            ee.memLevel,
            ee.strategy
          );
          if (de !== w)
            throw new Error(d[de]);
          if (ee.header && c.deflateSetHeader(this.strm, ee.header), ee.dictionary) {
            var Ce;
            if (typeof ee.dictionary == "string" ? Ce = p.string2buf(ee.dictionary) : y.call(ee.dictionary) === "[object ArrayBuffer]" ? Ce = new Uint8Array(ee.dictionary) : Ce = ee.dictionary, de = c.deflateSetDictionary(this.strm, Ce), de !== w)
              throw new Error(d[de]);
            this._dict_set = !0;
          }
        }
        z.prototype.push = function(re, ee) {
          var de = this.strm, Ce = this.options.chunkSize, he, oe;
          if (this.ended)
            return !1;
          oe = ee === ~~ee ? ee : ee === !0 ? x : S, typeof re == "string" ? de.input = p.string2buf(re) : y.call(re) === "[object ArrayBuffer]" ? de.input = new Uint8Array(re) : de.input = re, de.next_in = 0, de.avail_in = de.input.length;
          do {
            if (de.avail_out === 0 && (de.output = new f.Buf8(Ce), de.next_out = 0, de.avail_out = Ce), he = c.deflate(de, oe), he !== k && he !== w)
              return this.onEnd(he), this.ended = !0, !1;
            (de.avail_out === 0 || de.avail_in === 0 && (oe === x || oe === O)) && (this.options.to === "string" ? this.onData(p.buf2binstring(f.shrinkBuf(de.output, de.next_out))) : this.onData(f.shrinkBuf(de.output, de.next_out)));
          } while ((de.avail_in > 0 || de.avail_out === 0) && he !== k);
          return oe === x ? (he = c.deflateEnd(this.strm), this.onEnd(he), this.ended = !0, he === w) : (oe === O && (this.onEnd(w), de.avail_out = 0), !0);
        }, z.prototype.onData = function(re) {
          this.chunks.push(re);
        }, z.prototype.onEnd = function(re) {
          re === w && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = f.flattenChunks(this.chunks)), this.chunks = [], this.err = re, this.msg = this.strm.msg;
        };
        function J(re, ee) {
          var de = new z(ee);
          if (de.push(re, !0), de.err)
            throw de.msg || d[de.err];
          return de.result;
        }
        function ie(re, ee) {
          return ee = ee || {}, ee.raw = !0, J(re, ee);
        }
        function K(re, ee) {
          return ee = ee || {}, ee.gzip = !0, J(re, ee);
        }
        l.Deflate = z, l.deflate = J, l.deflateRaw = ie, l.gzip = K;
      }, { "./utils/common": 5, "./utils/strings": 6, "./zlib/deflate": 9, "./zlib/messages": 10, "./zlib/zstream": 12 }], 5: [function(r, s, l) {
        var c = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
        function f(m, y) {
          return Object.prototype.hasOwnProperty.call(m, y);
        }
        l.assign = function(m) {
          for (var y = Array.prototype.slice.call(arguments, 1); y.length; ) {
            var S = y.shift();
            if (S) {
              if (typeof S != "object")
                throw new TypeError(S + "must be non-object");
              for (var x in S)
                f(S, x) && (m[x] = S[x]);
            }
          }
          return m;
        }, l.shrinkBuf = function(m, y) {
          return m.length === y ? m : m.subarray ? m.subarray(0, y) : (m.length = y, m);
        };
        var p = {
          arraySet: function(m, y, S, x, w) {
            if (y.subarray && m.subarray) {
              m.set(y.subarray(S, S + x), w);
              return;
            }
            for (var k = 0; k < x; k++)
              m[w + k] = y[S + k];
          },
          // Join array of chunks to single array.
          flattenChunks: function(m) {
            var y, S, x, w, k, O;
            for (x = 0, y = 0, S = m.length; y < S; y++)
              x += m[y].length;
            for (O = new Uint8Array(x), w = 0, y = 0, S = m.length; y < S; y++)
              k = m[y], O.set(k, w), w += k.length;
            return O;
          }
        }, d = {
          arraySet: function(m, y, S, x, w) {
            for (var k = 0; k < x; k++)
              m[w + k] = y[S + k];
          },
          // Join array of chunks to single array.
          flattenChunks: function(m) {
            return [].concat.apply([], m);
          }
        };
        l.setTyped = function(m) {
          m ? (l.Buf8 = Uint8Array, l.Buf16 = Uint16Array, l.Buf32 = Int32Array, l.assign(l, p)) : (l.Buf8 = Array, l.Buf16 = Array, l.Buf32 = Array, l.assign(l, d));
        }, l.setTyped(c);
      }, {}], 6: [function(r, s, l) {
        var c = r("./common"), f = !0, p = !0;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch {
          f = !1;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch {
          p = !1;
        }
        for (var d = new c.Buf8(256), m = 0; m < 256; m++)
          d[m] = m >= 252 ? 6 : m >= 248 ? 5 : m >= 240 ? 4 : m >= 224 ? 3 : m >= 192 ? 2 : 1;
        d[254] = d[254] = 1, l.string2buf = function(S) {
          var x, w, k, O, T, L = S.length, j = 0;
          for (O = 0; O < L; O++)
            w = S.charCodeAt(O), (w & 64512) === 55296 && O + 1 < L && (k = S.charCodeAt(O + 1), (k & 64512) === 56320 && (w = 65536 + (w - 55296 << 10) + (k - 56320), O++)), j += w < 128 ? 1 : w < 2048 ? 2 : w < 65536 ? 3 : 4;
          for (x = new c.Buf8(j), T = 0, O = 0; T < j; O++)
            w = S.charCodeAt(O), (w & 64512) === 55296 && O + 1 < L && (k = S.charCodeAt(O + 1), (k & 64512) === 56320 && (w = 65536 + (w - 55296 << 10) + (k - 56320), O++)), w < 128 ? x[T++] = w : w < 2048 ? (x[T++] = 192 | w >>> 6, x[T++] = 128 | w & 63) : w < 65536 ? (x[T++] = 224 | w >>> 12, x[T++] = 128 | w >>> 6 & 63, x[T++] = 128 | w & 63) : (x[T++] = 240 | w >>> 18, x[T++] = 128 | w >>> 12 & 63, x[T++] = 128 | w >>> 6 & 63, x[T++] = 128 | w & 63);
          return x;
        };
        function y(S, x) {
          if (x < 65534 && (S.subarray && p || !S.subarray && f))
            return String.fromCharCode.apply(null, c.shrinkBuf(S, x));
          for (var w = "", k = 0; k < x; k++)
            w += String.fromCharCode(S[k]);
          return w;
        }
        l.buf2binstring = function(S) {
          return y(S, S.length);
        }, l.binstring2buf = function(S) {
          for (var x = new c.Buf8(S.length), w = 0, k = x.length; w < k; w++)
            x[w] = S.charCodeAt(w);
          return x;
        }, l.buf2string = function(S, x) {
          var w, k, O, T, L = x || S.length, j = new Array(L * 2);
          for (k = 0, w = 0; w < L; ) {
            if (O = S[w++], O < 128) {
              j[k++] = O;
              continue;
            }
            if (T = d[O], T > 4) {
              j[k++] = 65533, w += T - 1;
              continue;
            }
            for (O &= T === 2 ? 31 : T === 3 ? 15 : 7; T > 1 && w < L; )
              O = O << 6 | S[w++] & 63, T--;
            if (T > 1) {
              j[k++] = 65533;
              continue;
            }
            O < 65536 ? j[k++] = O : (O -= 65536, j[k++] = 55296 | O >> 10 & 1023, j[k++] = 56320 | O & 1023);
          }
          return y(j, k);
        }, l.utf8border = function(S, x) {
          var w;
          for (x = x || S.length, x > S.length && (x = S.length), w = x - 1; w >= 0 && (S[w] & 192) === 128; )
            w--;
          return w < 0 || w === 0 ? x : w + d[S[w]] > x ? w : x;
        };
      }, { "./common": 5 }], 7: [function(r, s, l) {
        function c(f, p, d, m) {
          for (var y = f & 65535 | 0, S = f >>> 16 & 65535 | 0, x = 0; d !== 0; ) {
            x = d > 2e3 ? 2e3 : d, d -= x;
            do
              y = y + p[m++] | 0, S = S + y | 0;
            while (--x);
            y %= 65521, S %= 65521;
          }
          return y | S << 16 | 0;
        }
        s.exports = c;
      }, {}], 8: [function(r, s, l) {
        function c() {
          for (var d, m = [], y = 0; y < 256; y++) {
            d = y;
            for (var S = 0; S < 8; S++)
              d = d & 1 ? 3988292384 ^ d >>> 1 : d >>> 1;
            m[y] = d;
          }
          return m;
        }
        var f = c();
        function p(d, m, y, S) {
          var x = f, w = S + y;
          d ^= -1;
          for (var k = S; k < w; k++)
            d = d >>> 8 ^ x[(d ^ m[k]) & 255];
          return d ^ -1;
        }
        s.exports = p;
      }, {}], 9: [function(r, s, l) {
        var c = r("../utils/common"), f = r("./trees"), p = r("./adler32"), d = r("./crc32"), m = r("./messages"), y = 0, S = 1, x = 3, w = 4, k = 5, O = 0, T = 1, L = -2, j = -3, z = -5, J = -1, ie = 1, K = 2, re = 3, ee = 4, de = 0, Ce = 2, he = 8, oe = 9, ge = 15, we = 8, Oe = 29, Qe = 256, Me = Qe + 1 + Oe, Ie = 30, rt = 19, ot = 2 * Me + 1, Et = 15, gt = 3, At = 258, Mt = At + gt + 1, St = 32, Ve = 42, Ue = 69, He = 73, We = 91, ze = 103, at = 113, Ye = 666, tt = 1, wt = 2, Ft = 3, qe = 4, pe = 3;
        function _e(M, ne) {
          return M.msg = m[ne], ne;
        }
        function Xe(M) {
          return (M << 1) - (M > 4 ? 9 : 0);
        }
        function lt(M) {
          for (var ne = M.length; --ne >= 0; )
            M[ne] = 0;
        }
        function Q(M) {
          var ne = M.state, ce = ne.pending;
          ce > M.avail_out && (ce = M.avail_out), ce !== 0 && (c.arraySet(M.output, ne.pending_buf, ne.pending_out, ce, M.next_out), M.next_out += ce, ne.pending_out += ce, M.total_out += ce, M.avail_out -= ce, ne.pending -= ce, ne.pending === 0 && (ne.pending_out = 0));
        }
        function te(M, ne) {
          f._tr_flush_block(M, M.block_start >= 0 ? M.block_start : -1, M.strstart - M.block_start, ne), M.block_start = M.strstart, Q(M.strm);
        }
        function De(M, ne) {
          M.pending_buf[M.pending++] = ne;
        }
        function nt(M, ne) {
          M.pending_buf[M.pending++] = ne >>> 8 & 255, M.pending_buf[M.pending++] = ne & 255;
        }
        function be(M, ne, ce, X) {
          var Re = M.avail_in;
          return Re > X && (Re = X), Re === 0 ? 0 : (M.avail_in -= Re, c.arraySet(ne, M.input, M.next_in, Re, ce), M.state.wrap === 1 ? M.adler = p(M.adler, ne, Re, ce) : M.state.wrap === 2 && (M.adler = d(M.adler, ne, Re, ce)), M.next_in += Re, M.total_in += Re, Re);
        }
        function G(M, ne) {
          var ce = M.max_chain_length, X = M.strstart, Re, Ge, pt = M.prev_length, xt = M.nice_match, Pt = M.strstart > M.w_size - Mt ? M.strstart - (M.w_size - Mt) : 0, Yt = M.window, gr = M.w_mask, dr = M.prev, It = M.strstart + At, ct = Yt[X + pt - 1], zt = Yt[X + pt];
          M.prev_length >= M.good_match && (ce >>= 2), xt > M.lookahead && (xt = M.lookahead);
          do
            if (Re = ne, !(Yt[Re + pt] !== zt || Yt[Re + pt - 1] !== ct || Yt[Re] !== Yt[X] || Yt[++Re] !== Yt[X + 1])) {
              X += 2, Re++;
              do
                ;
              while (Yt[++X] === Yt[++Re] && Yt[++X] === Yt[++Re] && Yt[++X] === Yt[++Re] && Yt[++X] === Yt[++Re] && Yt[++X] === Yt[++Re] && Yt[++X] === Yt[++Re] && Yt[++X] === Yt[++Re] && Yt[++X] === Yt[++Re] && X < It);
              if (Ge = At - (It - X), X = It - At, Ge > pt) {
                if (M.match_start = ne, pt = Ge, Ge >= xt)
                  break;
                ct = Yt[X + pt - 1], zt = Yt[X + pt];
              }
            }
          while ((ne = dr[ne & gr]) > Pt && --ce !== 0);
          return pt <= M.lookahead ? pt : M.lookahead;
        }
        function V(M) {
          var ne = M.w_size, ce, X, Re, Ge, pt;
          do {
            if (Ge = M.window_size - M.lookahead - M.strstart, M.strstart >= ne + (ne - Mt)) {
              c.arraySet(M.window, M.window, ne, ne, 0), M.match_start -= ne, M.strstart -= ne, M.block_start -= ne, X = M.hash_size, ce = X;
              do
                Re = M.head[--ce], M.head[ce] = Re >= ne ? Re - ne : 0;
              while (--X);
              X = ne, ce = X;
              do
                Re = M.prev[--ce], M.prev[ce] = Re >= ne ? Re - ne : 0;
              while (--X);
              Ge += ne;
            }
            if (M.strm.avail_in === 0)
              break;
            if (X = be(M.strm, M.window, M.strstart + M.lookahead, Ge), M.lookahead += X, M.lookahead + M.insert >= gt)
              for (pt = M.strstart - M.insert, M.ins_h = M.window[pt], M.ins_h = (M.ins_h << M.hash_shift ^ M.window[pt + 1]) & M.hash_mask; M.insert && (M.ins_h = (M.ins_h << M.hash_shift ^ M.window[pt + gt - 1]) & M.hash_mask, M.prev[pt & M.w_mask] = M.head[M.ins_h], M.head[M.ins_h] = pt, pt++, M.insert--, !(M.lookahead + M.insert < gt)); )
                ;
          } while (M.lookahead < Mt && M.strm.avail_in !== 0);
        }
        function ve(M, ne) {
          var ce = 65535;
          for (ce > M.pending_buf_size - 5 && (ce = M.pending_buf_size - 5); ; ) {
            if (M.lookahead <= 1) {
              if (V(M), M.lookahead === 0 && ne === y)
                return tt;
              if (M.lookahead === 0)
                break;
            }
            M.strstart += M.lookahead, M.lookahead = 0;
            var X = M.block_start + ce;
            if ((M.strstart === 0 || M.strstart >= X) && (M.lookahead = M.strstart - X, M.strstart = X, te(M, !1), M.strm.avail_out === 0) || M.strstart - M.block_start >= M.w_size - Mt && (te(M, !1), M.strm.avail_out === 0))
              return tt;
          }
          return M.insert = 0, ne === w ? (te(M, !0), M.strm.avail_out === 0 ? Ft : qe) : (M.strstart > M.block_start && (te(M, !1), M.strm.avail_out === 0), tt);
        }
        function Ne(M, ne) {
          for (var ce, X; ; ) {
            if (M.lookahead < Mt) {
              if (V(M), M.lookahead < Mt && ne === y)
                return tt;
              if (M.lookahead === 0)
                break;
            }
            if (ce = 0, M.lookahead >= gt && (M.ins_h = (M.ins_h << M.hash_shift ^ M.window[M.strstart + gt - 1]) & M.hash_mask, ce = M.prev[M.strstart & M.w_mask] = M.head[M.ins_h], M.head[M.ins_h] = M.strstart), ce !== 0 && M.strstart - ce <= M.w_size - Mt && (M.match_length = G(M, ce)), M.match_length >= gt)
              if (X = f._tr_tally(M, M.strstart - M.match_start, M.match_length - gt), M.lookahead -= M.match_length, M.match_length <= M.max_lazy_match && M.lookahead >= gt) {
                M.match_length--;
                do
                  M.strstart++, M.ins_h = (M.ins_h << M.hash_shift ^ M.window[M.strstart + gt - 1]) & M.hash_mask, ce = M.prev[M.strstart & M.w_mask] = M.head[M.ins_h], M.head[M.ins_h] = M.strstart;
                while (--M.match_length !== 0);
                M.strstart++;
              } else
                M.strstart += M.match_length, M.match_length = 0, M.ins_h = M.window[M.strstart], M.ins_h = (M.ins_h << M.hash_shift ^ M.window[M.strstart + 1]) & M.hash_mask;
            else
              X = f._tr_tally(M, 0, M.window[M.strstart]), M.lookahead--, M.strstart++;
            if (X && (te(M, !1), M.strm.avail_out === 0))
              return tt;
          }
          return M.insert = M.strstart < gt - 1 ? M.strstart : gt - 1, ne === w ? (te(M, !0), M.strm.avail_out === 0 ? Ft : qe) : M.last_lit && (te(M, !1), M.strm.avail_out === 0) ? tt : wt;
        }
        function it(M, ne) {
          for (var ce, X, Re; ; ) {
            if (M.lookahead < Mt) {
              if (V(M), M.lookahead < Mt && ne === y)
                return tt;
              if (M.lookahead === 0)
                break;
            }
            if (ce = 0, M.lookahead >= gt && (M.ins_h = (M.ins_h << M.hash_shift ^ M.window[M.strstart + gt - 1]) & M.hash_mask, ce = M.prev[M.strstart & M.w_mask] = M.head[M.ins_h], M.head[M.ins_h] = M.strstart), M.prev_length = M.match_length, M.prev_match = M.match_start, M.match_length = gt - 1, ce !== 0 && M.prev_length < M.max_lazy_match && M.strstart - ce <= M.w_size - Mt && (M.match_length = G(M, ce), M.match_length <= 5 && (M.strategy === ie || M.match_length === gt && M.strstart - M.match_start > 4096) && (M.match_length = gt - 1)), M.prev_length >= gt && M.match_length <= M.prev_length) {
              Re = M.strstart + M.lookahead - gt, X = f._tr_tally(M, M.strstart - 1 - M.prev_match, M.prev_length - gt), M.lookahead -= M.prev_length - 1, M.prev_length -= 2;
              do
                ++M.strstart <= Re && (M.ins_h = (M.ins_h << M.hash_shift ^ M.window[M.strstart + gt - 1]) & M.hash_mask, ce = M.prev[M.strstart & M.w_mask] = M.head[M.ins_h], M.head[M.ins_h] = M.strstart);
              while (--M.prev_length !== 0);
              if (M.match_available = 0, M.match_length = gt - 1, M.strstart++, X && (te(M, !1), M.strm.avail_out === 0))
                return tt;
            } else if (M.match_available) {
              if (X = f._tr_tally(M, 0, M.window[M.strstart - 1]), X && te(M, !1), M.strstart++, M.lookahead--, M.strm.avail_out === 0)
                return tt;
            } else
              M.match_available = 1, M.strstart++, M.lookahead--;
          }
          return M.match_available && (X = f._tr_tally(M, 0, M.window[M.strstart - 1]), M.match_available = 0), M.insert = M.strstart < gt - 1 ? M.strstart : gt - 1, ne === w ? (te(M, !0), M.strm.avail_out === 0 ? Ft : qe) : M.last_lit && (te(M, !1), M.strm.avail_out === 0) ? tt : wt;
        }
        function yt(M, ne) {
          for (var ce, X, Re, Ge, pt = M.window; ; ) {
            if (M.lookahead <= At) {
              if (V(M), M.lookahead <= At && ne === y)
                return tt;
              if (M.lookahead === 0)
                break;
            }
            if (M.match_length = 0, M.lookahead >= gt && M.strstart > 0 && (Re = M.strstart - 1, X = pt[Re], X === pt[++Re] && X === pt[++Re] && X === pt[++Re])) {
              Ge = M.strstart + At;
              do
                ;
              while (X === pt[++Re] && X === pt[++Re] && X === pt[++Re] && X === pt[++Re] && X === pt[++Re] && X === pt[++Re] && X === pt[++Re] && X === pt[++Re] && Re < Ge);
              M.match_length = At - (Ge - Re), M.match_length > M.lookahead && (M.match_length = M.lookahead);
            }
            if (M.match_length >= gt ? (ce = f._tr_tally(M, 1, M.match_length - gt), M.lookahead -= M.match_length, M.strstart += M.match_length, M.match_length = 0) : (ce = f._tr_tally(M, 0, M.window[M.strstart]), M.lookahead--, M.strstart++), ce && (te(M, !1), M.strm.avail_out === 0))
              return tt;
          }
          return M.insert = 0, ne === w ? (te(M, !0), M.strm.avail_out === 0 ? Ft : qe) : M.last_lit && (te(M, !1), M.strm.avail_out === 0) ? tt : wt;
        }
        function $t(M, ne) {
          for (var ce; ; ) {
            if (M.lookahead === 0 && (V(M), M.lookahead === 0)) {
              if (ne === y)
                return tt;
              break;
            }
            if (M.match_length = 0, ce = f._tr_tally(M, 0, M.window[M.strstart]), M.lookahead--, M.strstart++, ce && (te(M, !1), M.strm.avail_out === 0))
              return tt;
          }
          return M.insert = 0, ne === w ? (te(M, !0), M.strm.avail_out === 0 ? Ft : qe) : M.last_lit && (te(M, !1), M.strm.avail_out === 0) ? tt : wt;
        }
        function Gt(M, ne, ce, X, Re) {
          this.good_length = M, this.max_lazy = ne, this.nice_length = ce, this.max_chain = X, this.func = Re;
        }
        var Jt;
        Jt = [
          /*      good lazy nice chain */
          new Gt(0, 0, 0, 0, ve),
          /* 0 store only */
          new Gt(4, 4, 8, 4, Ne),
          /* 1 max speed, no lazy matches */
          new Gt(4, 5, 16, 8, Ne),
          /* 2 */
          new Gt(4, 6, 32, 32, Ne),
          /* 3 */
          new Gt(4, 4, 16, 16, it),
          /* 4 lazy matches */
          new Gt(8, 16, 32, 32, it),
          /* 5 */
          new Gt(8, 16, 128, 128, it),
          /* 6 */
          new Gt(8, 32, 128, 256, it),
          /* 7 */
          new Gt(32, 128, 258, 1024, it),
          /* 8 */
          new Gt(32, 258, 258, 4096, it)
          /* 9 max compression */
        ];
        function Xt(M) {
          M.window_size = 2 * M.w_size, lt(M.head), M.max_lazy_match = Jt[M.level].max_lazy, M.good_match = Jt[M.level].good_length, M.nice_match = Jt[M.level].nice_length, M.max_chain_length = Jt[M.level].max_chain, M.strstart = 0, M.block_start = 0, M.lookahead = 0, M.insert = 0, M.match_length = M.prev_length = gt - 1, M.match_available = 0, M.ins_h = 0;
        }
        function Ae() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = he, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(ot * 2), this.dyn_dtree = new c.Buf16((2 * Ie + 1) * 2), this.bl_tree = new c.Buf16((2 * rt + 1) * 2), lt(this.dyn_ltree), lt(this.dyn_dtree), lt(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(Et + 1), this.heap = new c.Buf16(2 * Me + 1), lt(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * Me + 1), lt(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function vt(M) {
          var ne;
          return !M || !M.state ? _e(M, L) : (M.total_in = M.total_out = 0, M.data_type = Ce, ne = M.state, ne.pending = 0, ne.pending_out = 0, ne.wrap < 0 && (ne.wrap = -ne.wrap), ne.status = ne.wrap ? Ve : at, M.adler = ne.wrap === 2 ? 0 : 1, ne.last_flush = y, f._tr_init(ne), O);
        }
        function Ot(M) {
          var ne = vt(M);
          return ne === O && Xt(M.state), ne;
        }
        function Vt(M, ne) {
          return !M || !M.state || M.state.wrap !== 2 ? L : (M.state.gzhead = ne, O);
        }
        function et(M, ne, ce, X, Re, Ge) {
          if (!M)
            return L;
          var pt = 1;
          if (ne === J && (ne = 6), X < 0 ? (pt = 0, X = -X) : X > 15 && (pt = 2, X -= 16), Re < 1 || Re > oe || ce !== he || X < 8 || X > 15 || ne < 0 || ne > 9 || Ge < 0 || Ge > ee)
            return _e(M, L);
          X === 8 && (X = 9);
          var xt = new Ae();
          return M.state = xt, xt.strm = M, xt.wrap = pt, xt.gzhead = null, xt.w_bits = X, xt.w_size = 1 << xt.w_bits, xt.w_mask = xt.w_size - 1, xt.hash_bits = Re + 7, xt.hash_size = 1 << xt.hash_bits, xt.hash_mask = xt.hash_size - 1, xt.hash_shift = ~~((xt.hash_bits + gt - 1) / gt), xt.window = new c.Buf8(xt.w_size * 2), xt.head = new c.Buf16(xt.hash_size), xt.prev = new c.Buf16(xt.w_size), xt.lit_bufsize = 1 << Re + 6, xt.pending_buf_size = xt.lit_bufsize * 4, xt.pending_buf = new c.Buf8(xt.pending_buf_size), xt.d_buf = 1 * xt.lit_bufsize, xt.l_buf = 3 * xt.lit_bufsize, xt.level = ne, xt.strategy = Ge, xt.method = ce, Ot(M);
        }
        function ft(M, ne) {
          return et(M, ne, he, ge, we, de);
        }
        function $(M, ne) {
          var ce, X, Re, Ge;
          if (!M || !M.state || ne > k || ne < 0)
            return M ? _e(M, L) : L;
          if (X = M.state, !M.output || !M.input && M.avail_in !== 0 || X.status === Ye && ne !== w)
            return _e(M, M.avail_out === 0 ? z : L);
          if (X.strm = M, ce = X.last_flush, X.last_flush = ne, X.status === Ve)
            if (X.wrap === 2)
              M.adler = 0, De(X, 31), De(X, 139), De(X, 8), X.gzhead ? (De(
                X,
                (X.gzhead.text ? 1 : 0) + (X.gzhead.hcrc ? 2 : 0) + (X.gzhead.extra ? 4 : 0) + (X.gzhead.name ? 8 : 0) + (X.gzhead.comment ? 16 : 0)
              ), De(X, X.gzhead.time & 255), De(X, X.gzhead.time >> 8 & 255), De(X, X.gzhead.time >> 16 & 255), De(X, X.gzhead.time >> 24 & 255), De(X, X.level === 9 ? 2 : X.strategy >= K || X.level < 2 ? 4 : 0), De(X, X.gzhead.os & 255), X.gzhead.extra && X.gzhead.extra.length && (De(X, X.gzhead.extra.length & 255), De(X, X.gzhead.extra.length >> 8 & 255)), X.gzhead.hcrc && (M.adler = d(M.adler, X.pending_buf, X.pending, 0)), X.gzindex = 0, X.status = Ue) : (De(X, 0), De(X, 0), De(X, 0), De(X, 0), De(X, 0), De(X, X.level === 9 ? 2 : X.strategy >= K || X.level < 2 ? 4 : 0), De(X, pe), X.status = at);
            else {
              var pt = he + (X.w_bits - 8 << 4) << 8, xt = -1;
              X.strategy >= K || X.level < 2 ? xt = 0 : X.level < 6 ? xt = 1 : X.level === 6 ? xt = 2 : xt = 3, pt |= xt << 6, X.strstart !== 0 && (pt |= St), pt += 31 - pt % 31, X.status = at, nt(X, pt), X.strstart !== 0 && (nt(X, M.adler >>> 16), nt(X, M.adler & 65535)), M.adler = 1;
            }
          if (X.status === Ue)
            if (X.gzhead.extra) {
              for (Re = X.pending; X.gzindex < (X.gzhead.extra.length & 65535) && !(X.pending === X.pending_buf_size && (X.gzhead.hcrc && X.pending > Re && (M.adler = d(M.adler, X.pending_buf, X.pending - Re, Re)), Q(M), Re = X.pending, X.pending === X.pending_buf_size)); )
                De(X, X.gzhead.extra[X.gzindex] & 255), X.gzindex++;
              X.gzhead.hcrc && X.pending > Re && (M.adler = d(M.adler, X.pending_buf, X.pending - Re, Re)), X.gzindex === X.gzhead.extra.length && (X.gzindex = 0, X.status = He);
            } else
              X.status = He;
          if (X.status === He)
            if (X.gzhead.name) {
              Re = X.pending;
              do {
                if (X.pending === X.pending_buf_size && (X.gzhead.hcrc && X.pending > Re && (M.adler = d(M.adler, X.pending_buf, X.pending - Re, Re)), Q(M), Re = X.pending, X.pending === X.pending_buf_size)) {
                  Ge = 1;
                  break;
                }
                X.gzindex < X.gzhead.name.length ? Ge = X.gzhead.name.charCodeAt(X.gzindex++) & 255 : Ge = 0, De(X, Ge);
              } while (Ge !== 0);
              X.gzhead.hcrc && X.pending > Re && (M.adler = d(M.adler, X.pending_buf, X.pending - Re, Re)), Ge === 0 && (X.gzindex = 0, X.status = We);
            } else
              X.status = We;
          if (X.status === We)
            if (X.gzhead.comment) {
              Re = X.pending;
              do {
                if (X.pending === X.pending_buf_size && (X.gzhead.hcrc && X.pending > Re && (M.adler = d(M.adler, X.pending_buf, X.pending - Re, Re)), Q(M), Re = X.pending, X.pending === X.pending_buf_size)) {
                  Ge = 1;
                  break;
                }
                X.gzindex < X.gzhead.comment.length ? Ge = X.gzhead.comment.charCodeAt(X.gzindex++) & 255 : Ge = 0, De(X, Ge);
              } while (Ge !== 0);
              X.gzhead.hcrc && X.pending > Re && (M.adler = d(M.adler, X.pending_buf, X.pending - Re, Re)), Ge === 0 && (X.status = ze);
            } else
              X.status = ze;
          if (X.status === ze && (X.gzhead.hcrc ? (X.pending + 2 > X.pending_buf_size && Q(M), X.pending + 2 <= X.pending_buf_size && (De(X, M.adler & 255), De(X, M.adler >> 8 & 255), M.adler = 0, X.status = at)) : X.status = at), X.pending !== 0) {
            if (Q(M), M.avail_out === 0)
              return X.last_flush = -1, O;
          } else if (M.avail_in === 0 && Xe(ne) <= Xe(ce) && ne !== w)
            return _e(M, z);
          if (X.status === Ye && M.avail_in !== 0)
            return _e(M, z);
          if (M.avail_in !== 0 || X.lookahead !== 0 || ne !== y && X.status !== Ye) {
            var Pt = X.strategy === K ? $t(X, ne) : X.strategy === re ? yt(X, ne) : Jt[X.level].func(X, ne);
            if ((Pt === Ft || Pt === qe) && (X.status = Ye), Pt === tt || Pt === Ft)
              return M.avail_out === 0 && (X.last_flush = -1), O;
            if (Pt === wt && (ne === S ? f._tr_align(X) : ne !== k && (f._tr_stored_block(X, 0, 0, !1), ne === x && (lt(X.head), X.lookahead === 0 && (X.strstart = 0, X.block_start = 0, X.insert = 0))), Q(M), M.avail_out === 0))
              return X.last_flush = -1, O;
          }
          return ne !== w ? O : X.wrap <= 0 ? T : (X.wrap === 2 ? (De(X, M.adler & 255), De(X, M.adler >> 8 & 255), De(X, M.adler >> 16 & 255), De(X, M.adler >> 24 & 255), De(X, M.total_in & 255), De(X, M.total_in >> 8 & 255), De(X, M.total_in >> 16 & 255), De(X, M.total_in >> 24 & 255)) : (nt(X, M.adler >>> 16), nt(X, M.adler & 65535)), Q(M), X.wrap > 0 && (X.wrap = -X.wrap), X.pending !== 0 ? O : T);
        }
        function Se(M) {
          var ne;
          return !M || !M.state ? L : (ne = M.state.status, ne !== Ve && ne !== Ue && ne !== He && ne !== We && ne !== ze && ne !== at && ne !== Ye ? _e(M, L) : (M.state = null, ne === at ? _e(M, j) : O));
        }
        function se(M, ne) {
          var ce = ne.length, X, Re, Ge, pt, xt, Pt, Yt, gr;
          if (!M || !M.state || (X = M.state, pt = X.wrap, pt === 2 || pt === 1 && X.status !== Ve || X.lookahead))
            return L;
          for (pt === 1 && (M.adler = p(M.adler, ne, ce, 0)), X.wrap = 0, ce >= X.w_size && (pt === 0 && (lt(X.head), X.strstart = 0, X.block_start = 0, X.insert = 0), gr = new c.Buf8(X.w_size), c.arraySet(gr, ne, ce - X.w_size, X.w_size, 0), ne = gr, ce = X.w_size), xt = M.avail_in, Pt = M.next_in, Yt = M.input, M.avail_in = ce, M.next_in = 0, M.input = ne, V(X); X.lookahead >= gt; ) {
            Re = X.strstart, Ge = X.lookahead - (gt - 1);
            do
              X.ins_h = (X.ins_h << X.hash_shift ^ X.window[Re + gt - 1]) & X.hash_mask, X.prev[Re & X.w_mask] = X.head[X.ins_h], X.head[X.ins_h] = Re, Re++;
            while (--Ge);
            X.strstart = Re, X.lookahead = gt - 1, V(X);
          }
          return X.strstart += X.lookahead, X.block_start = X.strstart, X.insert = X.lookahead, X.lookahead = 0, X.match_length = X.prev_length = gt - 1, X.match_available = 0, M.next_in = Pt, M.input = Yt, M.avail_in = xt, X.wrap = pt, O;
        }
        l.deflateInit = ft, l.deflateInit2 = et, l.deflateReset = Ot, l.deflateResetKeep = vt, l.deflateSetHeader = Vt, l.deflate = $, l.deflateEnd = Se, l.deflateSetDictionary = se, l.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 5, "./adler32": 7, "./crc32": 8, "./messages": 10, "./trees": 11 }], 10: [function(r, s, l) {
        s.exports = {
          2: "need dictionary",
          /* Z_NEED_DICT       2  */
          1: "stream end",
          /* Z_STREAM_END      1  */
          0: "",
          /* Z_OK              0  */
          "-1": "file error",
          /* Z_ERRNO         (-1) */
          "-2": "stream error",
          /* Z_STREAM_ERROR  (-2) */
          "-3": "data error",
          /* Z_DATA_ERROR    (-3) */
          "-4": "insufficient memory",
          /* Z_MEM_ERROR     (-4) */
          "-5": "buffer error",
          /* Z_BUF_ERROR     (-5) */
          "-6": "incompatible version"
          /* Z_VERSION_ERROR (-6) */
        };
      }, {}], 11: [function(r, s, l) {
        var c = r("../utils/common"), f = 4, p = 0, d = 1, m = 2;
        function y(Ae) {
          for (var vt = Ae.length; --vt >= 0; )
            Ae[vt] = 0;
        }
        var S = 0, x = 1, w = 2, k = 3, O = 258, T = 29, L = 256, j = L + 1 + T, z = 30, J = 19, ie = 2 * j + 1, K = 15, re = 16, ee = 7, de = 256, Ce = 16, he = 17, oe = 18, ge = (
          /* extra bits for each length code */
          [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
        ), we = (
          /* extra bits for each distance code */
          [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
        ), Oe = (
          /* extra bits for each bit length code */
          [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
        ), Qe = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], Me = 512, Ie = new Array((j + 2) * 2);
        y(Ie);
        var rt = new Array(z * 2);
        y(rt);
        var ot = new Array(Me);
        y(ot);
        var Et = new Array(O - k + 1);
        y(Et);
        var gt = new Array(T);
        y(gt);
        var At = new Array(z);
        y(At);
        function Mt(Ae, vt, Ot, Vt, et) {
          this.static_tree = Ae, this.extra_bits = vt, this.extra_base = Ot, this.elems = Vt, this.max_length = et, this.has_stree = Ae && Ae.length;
        }
        var St, Ve, Ue;
        function He(Ae, vt) {
          this.dyn_tree = Ae, this.max_code = 0, this.stat_desc = vt;
        }
        function We(Ae) {
          return Ae < 256 ? ot[Ae] : ot[256 + (Ae >>> 7)];
        }
        function ze(Ae, vt) {
          Ae.pending_buf[Ae.pending++] = vt & 255, Ae.pending_buf[Ae.pending++] = vt >>> 8 & 255;
        }
        function at(Ae, vt, Ot) {
          Ae.bi_valid > re - Ot ? (Ae.bi_buf |= vt << Ae.bi_valid & 65535, ze(Ae, Ae.bi_buf), Ae.bi_buf = vt >> re - Ae.bi_valid, Ae.bi_valid += Ot - re) : (Ae.bi_buf |= vt << Ae.bi_valid & 65535, Ae.bi_valid += Ot);
        }
        function Ye(Ae, vt, Ot) {
          at(
            Ae,
            Ot[vt * 2],
            Ot[vt * 2 + 1]
            /*.Len*/
          );
        }
        function tt(Ae, vt) {
          var Ot = 0;
          do
            Ot |= Ae & 1, Ae >>>= 1, Ot <<= 1;
          while (--vt > 0);
          return Ot >>> 1;
        }
        function wt(Ae) {
          Ae.bi_valid === 16 ? (ze(Ae, Ae.bi_buf), Ae.bi_buf = 0, Ae.bi_valid = 0) : Ae.bi_valid >= 8 && (Ae.pending_buf[Ae.pending++] = Ae.bi_buf & 255, Ae.bi_buf >>= 8, Ae.bi_valid -= 8);
        }
        function Ft(Ae, vt) {
          var Ot = vt.dyn_tree, Vt = vt.max_code, et = vt.stat_desc.static_tree, ft = vt.stat_desc.has_stree, $ = vt.stat_desc.extra_bits, Se = vt.stat_desc.extra_base, se = vt.stat_desc.max_length, M, ne, ce, X, Re, Ge, pt = 0;
          for (X = 0; X <= K; X++)
            Ae.bl_count[X] = 0;
          for (Ot[Ae.heap[Ae.heap_max] * 2 + 1] = 0, M = Ae.heap_max + 1; M < ie; M++)
            ne = Ae.heap[M], X = Ot[Ot[ne * 2 + 1] * 2 + 1] + 1, X > se && (X = se, pt++), Ot[ne * 2 + 1] = X, !(ne > Vt) && (Ae.bl_count[X]++, Re = 0, ne >= Se && (Re = $[ne - Se]), Ge = Ot[ne * 2], Ae.opt_len += Ge * (X + Re), ft && (Ae.static_len += Ge * (et[ne * 2 + 1] + Re)));
          if (pt !== 0) {
            do {
              for (X = se - 1; Ae.bl_count[X] === 0; )
                X--;
              Ae.bl_count[X]--, Ae.bl_count[X + 1] += 2, Ae.bl_count[se]--, pt -= 2;
            } while (pt > 0);
            for (X = se; X !== 0; X--)
              for (ne = Ae.bl_count[X]; ne !== 0; )
                ce = Ae.heap[--M], !(ce > Vt) && (Ot[ce * 2 + 1] !== X && (Ae.opt_len += (X - Ot[ce * 2 + 1]) * Ot[ce * 2], Ot[ce * 2 + 1] = X), ne--);
          }
        }
        function qe(Ae, vt, Ot) {
          var Vt = new Array(K + 1), et = 0, ft, $;
          for (ft = 1; ft <= K; ft++)
            Vt[ft] = et = et + Ot[ft - 1] << 1;
          for ($ = 0; $ <= vt; $++) {
            var Se = Ae[$ * 2 + 1];
            Se !== 0 && (Ae[$ * 2] = tt(Vt[Se]++, Se));
          }
        }
        function pe() {
          var Ae, vt, Ot, Vt, et, ft = new Array(K + 1);
          for (Ot = 0, Vt = 0; Vt < T - 1; Vt++)
            for (gt[Vt] = Ot, Ae = 0; Ae < 1 << ge[Vt]; Ae++)
              Et[Ot++] = Vt;
          for (Et[Ot - 1] = Vt, et = 0, Vt = 0; Vt < 16; Vt++)
            for (At[Vt] = et, Ae = 0; Ae < 1 << we[Vt]; Ae++)
              ot[et++] = Vt;
          for (et >>= 7; Vt < z; Vt++)
            for (At[Vt] = et << 7, Ae = 0; Ae < 1 << we[Vt] - 7; Ae++)
              ot[256 + et++] = Vt;
          for (vt = 0; vt <= K; vt++)
            ft[vt] = 0;
          for (Ae = 0; Ae <= 143; )
            Ie[Ae * 2 + 1] = 8, Ae++, ft[8]++;
          for (; Ae <= 255; )
            Ie[Ae * 2 + 1] = 9, Ae++, ft[9]++;
          for (; Ae <= 279; )
            Ie[Ae * 2 + 1] = 7, Ae++, ft[7]++;
          for (; Ae <= 287; )
            Ie[Ae * 2 + 1] = 8, Ae++, ft[8]++;
          for (qe(Ie, j + 1, ft), Ae = 0; Ae < z; Ae++)
            rt[Ae * 2 + 1] = 5, rt[Ae * 2] = tt(Ae, 5);
          St = new Mt(Ie, ge, L + 1, j, K), Ve = new Mt(rt, we, 0, z, K), Ue = new Mt(new Array(0), Oe, 0, J, ee);
        }
        function _e(Ae) {
          var vt;
          for (vt = 0; vt < j; vt++)
            Ae.dyn_ltree[vt * 2] = 0;
          for (vt = 0; vt < z; vt++)
            Ae.dyn_dtree[vt * 2] = 0;
          for (vt = 0; vt < J; vt++)
            Ae.bl_tree[vt * 2] = 0;
          Ae.dyn_ltree[de * 2] = 1, Ae.opt_len = Ae.static_len = 0, Ae.last_lit = Ae.matches = 0;
        }
        function Xe(Ae) {
          Ae.bi_valid > 8 ? ze(Ae, Ae.bi_buf) : Ae.bi_valid > 0 && (Ae.pending_buf[Ae.pending++] = Ae.bi_buf), Ae.bi_buf = 0, Ae.bi_valid = 0;
        }
        function lt(Ae, vt, Ot, Vt) {
          Xe(Ae), ze(Ae, Ot), ze(Ae, ~Ot), c.arraySet(Ae.pending_buf, Ae.window, vt, Ot, Ae.pending), Ae.pending += Ot;
        }
        function Q(Ae, vt, Ot, Vt) {
          var et = vt * 2, ft = Ot * 2;
          return Ae[et] < Ae[ft] || Ae[et] === Ae[ft] && Vt[vt] <= Vt[Ot];
        }
        function te(Ae, vt, Ot) {
          for (var Vt = Ae.heap[Ot], et = Ot << 1; et <= Ae.heap_len && (et < Ae.heap_len && Q(vt, Ae.heap[et + 1], Ae.heap[et], Ae.depth) && et++, !Q(vt, Vt, Ae.heap[et], Ae.depth)); )
            Ae.heap[Ot] = Ae.heap[et], Ot = et, et <<= 1;
          Ae.heap[Ot] = Vt;
        }
        function De(Ae, vt, Ot) {
          var Vt, et, ft = 0, $, Se;
          if (Ae.last_lit !== 0)
            do
              Vt = Ae.pending_buf[Ae.d_buf + ft * 2] << 8 | Ae.pending_buf[Ae.d_buf + ft * 2 + 1], et = Ae.pending_buf[Ae.l_buf + ft], ft++, Vt === 0 ? Ye(Ae, et, vt) : ($ = Et[et], Ye(Ae, $ + L + 1, vt), Se = ge[$], Se !== 0 && (et -= gt[$], at(Ae, et, Se)), Vt--, $ = We(Vt), Ye(Ae, $, Ot), Se = we[$], Se !== 0 && (Vt -= At[$], at(Ae, Vt, Se)));
            while (ft < Ae.last_lit);
          Ye(Ae, de, vt);
        }
        function nt(Ae, vt) {
          var Ot = vt.dyn_tree, Vt = vt.stat_desc.static_tree, et = vt.stat_desc.has_stree, ft = vt.stat_desc.elems, $, Se, se = -1, M;
          for (Ae.heap_len = 0, Ae.heap_max = ie, $ = 0; $ < ft; $++)
            Ot[$ * 2] !== 0 ? (Ae.heap[++Ae.heap_len] = se = $, Ae.depth[$] = 0) : Ot[$ * 2 + 1] = 0;
          for (; Ae.heap_len < 2; )
            M = Ae.heap[++Ae.heap_len] = se < 2 ? ++se : 0, Ot[M * 2] = 1, Ae.depth[M] = 0, Ae.opt_len--, et && (Ae.static_len -= Vt[M * 2 + 1]);
          for (vt.max_code = se, $ = Ae.heap_len >> 1; $ >= 1; $--)
            te(Ae, Ot, $);
          M = ft;
          do
            $ = Ae.heap[
              1
              /*SMALLEST*/
            ], Ae.heap[
              1
              /*SMALLEST*/
            ] = Ae.heap[Ae.heap_len--], te(
              Ae,
              Ot,
              1
              /*SMALLEST*/
            ), Se = Ae.heap[
              1
              /*SMALLEST*/
            ], Ae.heap[--Ae.heap_max] = $, Ae.heap[--Ae.heap_max] = Se, Ot[M * 2] = Ot[$ * 2] + Ot[Se * 2], Ae.depth[M] = (Ae.depth[$] >= Ae.depth[Se] ? Ae.depth[$] : Ae.depth[Se]) + 1, Ot[$ * 2 + 1] = Ot[Se * 2 + 1] = M, Ae.heap[
              1
              /*SMALLEST*/
            ] = M++, te(
              Ae,
              Ot,
              1
              /*SMALLEST*/
            );
          while (Ae.heap_len >= 2);
          Ae.heap[--Ae.heap_max] = Ae.heap[
            1
            /*SMALLEST*/
          ], Ft(Ae, vt), qe(Ot, se, Ae.bl_count);
        }
        function be(Ae, vt, Ot) {
          var Vt, et = -1, ft, $ = vt[0 * 2 + 1], Se = 0, se = 7, M = 4;
          for ($ === 0 && (se = 138, M = 3), vt[(Ot + 1) * 2 + 1] = 65535, Vt = 0; Vt <= Ot; Vt++)
            ft = $, $ = vt[(Vt + 1) * 2 + 1], !(++Se < se && ft === $) && (Se < M ? Ae.bl_tree[ft * 2] += Se : ft !== 0 ? (ft !== et && Ae.bl_tree[ft * 2]++, Ae.bl_tree[Ce * 2]++) : Se <= 10 ? Ae.bl_tree[he * 2]++ : Ae.bl_tree[oe * 2]++, Se = 0, et = ft, $ === 0 ? (se = 138, M = 3) : ft === $ ? (se = 6, M = 3) : (se = 7, M = 4));
        }
        function G(Ae, vt, Ot) {
          var Vt, et = -1, ft, $ = vt[0 * 2 + 1], Se = 0, se = 7, M = 4;
          for ($ === 0 && (se = 138, M = 3), Vt = 0; Vt <= Ot; Vt++)
            if (ft = $, $ = vt[(Vt + 1) * 2 + 1], !(++Se < se && ft === $)) {
              if (Se < M)
                do
                  Ye(Ae, ft, Ae.bl_tree);
                while (--Se !== 0);
              else ft !== 0 ? (ft !== et && (Ye(Ae, ft, Ae.bl_tree), Se--), Ye(Ae, Ce, Ae.bl_tree), at(Ae, Se - 3, 2)) : Se <= 10 ? (Ye(Ae, he, Ae.bl_tree), at(Ae, Se - 3, 3)) : (Ye(Ae, oe, Ae.bl_tree), at(Ae, Se - 11, 7));
              Se = 0, et = ft, $ === 0 ? (se = 138, M = 3) : ft === $ ? (se = 6, M = 3) : (se = 7, M = 4);
            }
        }
        function V(Ae) {
          var vt;
          for (be(Ae, Ae.dyn_ltree, Ae.l_desc.max_code), be(Ae, Ae.dyn_dtree, Ae.d_desc.max_code), nt(Ae, Ae.bl_desc), vt = J - 1; vt >= 3 && Ae.bl_tree[Qe[vt] * 2 + 1] === 0; vt--)
            ;
          return Ae.opt_len += 3 * (vt + 1) + 5 + 5 + 4, vt;
        }
        function ve(Ae, vt, Ot, Vt) {
          var et;
          for (at(Ae, vt - 257, 5), at(Ae, Ot - 1, 5), at(Ae, Vt - 4, 4), et = 0; et < Vt; et++)
            at(Ae, Ae.bl_tree[Qe[et] * 2 + 1], 3);
          G(Ae, Ae.dyn_ltree, vt - 1), G(Ae, Ae.dyn_dtree, Ot - 1);
        }
        function Ne(Ae) {
          var vt = 4093624447, Ot;
          for (Ot = 0; Ot <= 31; Ot++, vt >>>= 1)
            if (vt & 1 && Ae.dyn_ltree[Ot * 2] !== 0)
              return p;
          if (Ae.dyn_ltree[9 * 2] !== 0 || Ae.dyn_ltree[10 * 2] !== 0 || Ae.dyn_ltree[13 * 2] !== 0)
            return d;
          for (Ot = 32; Ot < L; Ot++)
            if (Ae.dyn_ltree[Ot * 2] !== 0)
              return d;
          return p;
        }
        var it = !1;
        function yt(Ae) {
          it || (pe(), it = !0), Ae.l_desc = new He(Ae.dyn_ltree, St), Ae.d_desc = new He(Ae.dyn_dtree, Ve), Ae.bl_desc = new He(Ae.bl_tree, Ue), Ae.bi_buf = 0, Ae.bi_valid = 0, _e(Ae);
        }
        function $t(Ae, vt, Ot, Vt) {
          at(Ae, (S << 1) + (Vt ? 1 : 0), 3), lt(Ae, vt, Ot);
        }
        function Gt(Ae) {
          at(Ae, x << 1, 3), Ye(Ae, de, Ie), wt(Ae);
        }
        function Jt(Ae, vt, Ot, Vt) {
          var et, ft, $ = 0;
          Ae.level > 0 ? (Ae.strm.data_type === m && (Ae.strm.data_type = Ne(Ae)), nt(Ae, Ae.l_desc), nt(Ae, Ae.d_desc), $ = V(Ae), et = Ae.opt_len + 3 + 7 >>> 3, ft = Ae.static_len + 3 + 7 >>> 3, ft <= et && (et = ft)) : et = ft = Ot + 5, Ot + 4 <= et && vt !== -1 ? $t(Ae, vt, Ot, Vt) : Ae.strategy === f || ft === et ? (at(Ae, (x << 1) + (Vt ? 1 : 0), 3), De(Ae, Ie, rt)) : (at(Ae, (w << 1) + (Vt ? 1 : 0), 3), ve(Ae, Ae.l_desc.max_code + 1, Ae.d_desc.max_code + 1, $ + 1), De(Ae, Ae.dyn_ltree, Ae.dyn_dtree)), _e(Ae), Vt && Xe(Ae);
        }
        function Xt(Ae, vt, Ot) {
          return Ae.pending_buf[Ae.d_buf + Ae.last_lit * 2] = vt >>> 8 & 255, Ae.pending_buf[Ae.d_buf + Ae.last_lit * 2 + 1] = vt & 255, Ae.pending_buf[Ae.l_buf + Ae.last_lit] = Ot & 255, Ae.last_lit++, vt === 0 ? Ae.dyn_ltree[Ot * 2]++ : (Ae.matches++, vt--, Ae.dyn_ltree[(Et[Ot] + L + 1) * 2]++, Ae.dyn_dtree[We(vt) * 2]++), Ae.last_lit === Ae.lit_bufsize - 1;
        }
        l._tr_init = yt, l._tr_stored_block = $t, l._tr_flush_block = Jt, l._tr_tally = Xt, l._tr_align = Gt;
      }, { "../utils/common": 5 }], 12: [function(r, s, l) {
        function c() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        }
        s.exports = c;
      }, {}] }, {}, [3])(3);
    });
  }(Rj)), Rj.exports;
}
var Dj = { exports: {} }, pV;
function dGe() {
  return pV || (pV = 1, function(i, e) {
    (function(r) {
      i.exports = r();
    })(function() {
      return (/* @__PURE__ */ function() {
        function r(s, l, c) {
          function f(m, y) {
            if (!l[m]) {
              if (!s[m]) {
                var S = typeof Tu == "function" && Tu;
                if (!y && S) return S(m, !0);
                if (p) return p(m, !0);
                var x = new Error("Cannot find module '" + m + "'");
                throw x.code = "MODULE_NOT_FOUND", x;
              }
              var w = l[m] = { exports: {} };
              s[m][0].call(w.exports, function(k) {
                var O = s[m][1][k];
                return f(O || k);
              }, w, w.exports, r, s, l, c);
            }
            return l[m].exports;
          }
          for (var p = typeof Tu == "function" && Tu, d = 0; d < c.length; d++) f(c[d]);
          return f;
        }
        return r;
      }())({ 1: [function(r, s, l) {
        var c = r("pako/lib/inflate.js");
        s.exports = function(f) {
          return c.inflateRaw(f, { to: "string" });
        };
      }, { "pako/lib/inflate.js": 4 }], 2: [function(r, s, l) {
        function c(p) {
          var d = p.charCodeAt(0);
          return p === "_" ? 63 : p === "-" ? 62 : d >= 97 ? d - 61 : d >= 65 ? d - 55 : d >= 48 ? d - 48 : "?";
        }
        function f(p) {
          var d = c(p[0]), m = c(p[1]), y = c(p[2]), S = c(p[3]), x = d << 2 | m >> 4 & 63, w = m << 4 & 240 | y >> 2 & 15, k = y << 6 & 192 | S & 63;
          return [x, w, k];
        }
        s.exports = function(p) {
          var d = "", m = 0;
          for (m = 0; m < p.length; m += 4) {
            var y = f(p.substring(m, m + 4));
            d = d + String.fromCharCode(y[0]), d = d + String.fromCharCode(y[1]), d = d + String.fromCharCode(y[2]);
          }
          return d;
        };
      }, {}], 3: [function(r, s, l) {
        var c = r("./inflate"), f = r("./decode64");
        s.exports.decode = function(p) {
          var d = f(p);
          return c(d);
        };
      }, { "./decode64": 2, "./inflate": 1 }], 4: [function(r, s, l) {
        var c = r("./zlib/inflate"), f = r("./utils/common"), p = r("./utils/strings"), d = r("./zlib/constants"), m = r("./zlib/messages"), y = r("./zlib/zstream"), S = r("./zlib/gzheader"), x = Object.prototype.toString;
        function w(T) {
          if (!(this instanceof w)) return new w(T);
          this.options = f.assign({
            chunkSize: 16384,
            windowBits: 0,
            to: ""
          }, T || {});
          var L = this.options;
          L.raw && L.windowBits >= 0 && L.windowBits < 16 && (L.windowBits = -L.windowBits, L.windowBits === 0 && (L.windowBits = -15)), L.windowBits >= 0 && L.windowBits < 16 && !(T && T.windowBits) && (L.windowBits += 32), L.windowBits > 15 && L.windowBits < 48 && (L.windowBits & 15) === 0 && (L.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new y(), this.strm.avail_out = 0;
          var j = c.inflateInit2(
            this.strm,
            L.windowBits
          );
          if (j !== d.Z_OK)
            throw new Error(m[j]);
          if (this.header = new S(), c.inflateGetHeader(this.strm, this.header), L.dictionary && (typeof L.dictionary == "string" ? L.dictionary = p.string2buf(L.dictionary) : x.call(L.dictionary) === "[object ArrayBuffer]" && (L.dictionary = new Uint8Array(L.dictionary)), L.raw && (j = c.inflateSetDictionary(this.strm, L.dictionary), j !== d.Z_OK)))
            throw new Error(m[j]);
        }
        w.prototype.push = function(T, L) {
          var j = this.strm, z = this.options.chunkSize, J = this.options.dictionary, ie, K, re, ee, de, Ce = !1;
          if (this.ended)
            return !1;
          K = L === ~~L ? L : L === !0 ? d.Z_FINISH : d.Z_NO_FLUSH, typeof T == "string" ? j.input = p.binstring2buf(T) : x.call(T) === "[object ArrayBuffer]" ? j.input = new Uint8Array(T) : j.input = T, j.next_in = 0, j.avail_in = j.input.length;
          do {
            if (j.avail_out === 0 && (j.output = new f.Buf8(z), j.next_out = 0, j.avail_out = z), ie = c.inflate(j, d.Z_NO_FLUSH), ie === d.Z_NEED_DICT && J && (ie = c.inflateSetDictionary(this.strm, J)), ie === d.Z_BUF_ERROR && Ce === !0 && (ie = d.Z_OK, Ce = !1), ie !== d.Z_STREAM_END && ie !== d.Z_OK)
              return this.onEnd(ie), this.ended = !0, !1;
            j.next_out && (j.avail_out === 0 || ie === d.Z_STREAM_END || j.avail_in === 0 && (K === d.Z_FINISH || K === d.Z_SYNC_FLUSH)) && (this.options.to === "string" ? (re = p.utf8border(j.output, j.next_out), ee = j.next_out - re, de = p.buf2string(j.output, re), j.next_out = ee, j.avail_out = z - ee, ee && f.arraySet(j.output, j.output, re, ee, 0), this.onData(de)) : this.onData(f.shrinkBuf(j.output, j.next_out))), j.avail_in === 0 && j.avail_out === 0 && (Ce = !0);
          } while ((j.avail_in > 0 || j.avail_out === 0) && ie !== d.Z_STREAM_END);
          return ie === d.Z_STREAM_END && (K = d.Z_FINISH), K === d.Z_FINISH ? (ie = c.inflateEnd(this.strm), this.onEnd(ie), this.ended = !0, ie === d.Z_OK) : (K === d.Z_SYNC_FLUSH && (this.onEnd(d.Z_OK), j.avail_out = 0), !0);
        }, w.prototype.onData = function(T) {
          this.chunks.push(T);
        }, w.prototype.onEnd = function(T) {
          T === d.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = f.flattenChunks(this.chunks)), this.chunks = [], this.err = T, this.msg = this.strm.msg;
        };
        function k(T, L) {
          var j = new w(L);
          if (j.push(T, !0), j.err)
            throw j.msg || m[j.err];
          return j.result;
        }
        function O(T, L) {
          return L = L || {}, L.raw = !0, k(T, L);
        }
        l.Inflate = w, l.inflate = k, l.inflateRaw = O, l.ungzip = k;
      }, { "./utils/common": 5, "./utils/strings": 6, "./zlib/constants": 8, "./zlib/gzheader": 10, "./zlib/inflate": 12, "./zlib/messages": 14, "./zlib/zstream": 15 }], 5: [function(r, s, l) {
        var c = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
        function f(m, y) {
          return Object.prototype.hasOwnProperty.call(m, y);
        }
        l.assign = function(m) {
          for (var y = Array.prototype.slice.call(arguments, 1); y.length; ) {
            var S = y.shift();
            if (S) {
              if (typeof S != "object")
                throw new TypeError(S + "must be non-object");
              for (var x in S)
                f(S, x) && (m[x] = S[x]);
            }
          }
          return m;
        }, l.shrinkBuf = function(m, y) {
          return m.length === y ? m : m.subarray ? m.subarray(0, y) : (m.length = y, m);
        };
        var p = {
          arraySet: function(m, y, S, x, w) {
            if (y.subarray && m.subarray) {
              m.set(y.subarray(S, S + x), w);
              return;
            }
            for (var k = 0; k < x; k++)
              m[w + k] = y[S + k];
          },
          // Join array of chunks to single array.
          flattenChunks: function(m) {
            var y, S, x, w, k, O;
            for (x = 0, y = 0, S = m.length; y < S; y++)
              x += m[y].length;
            for (O = new Uint8Array(x), w = 0, y = 0, S = m.length; y < S; y++)
              k = m[y], O.set(k, w), w += k.length;
            return O;
          }
        }, d = {
          arraySet: function(m, y, S, x, w) {
            for (var k = 0; k < x; k++)
              m[w + k] = y[S + k];
          },
          // Join array of chunks to single array.
          flattenChunks: function(m) {
            return [].concat.apply([], m);
          }
        };
        l.setTyped = function(m) {
          m ? (l.Buf8 = Uint8Array, l.Buf16 = Uint16Array, l.Buf32 = Int32Array, l.assign(l, p)) : (l.Buf8 = Array, l.Buf16 = Array, l.Buf32 = Array, l.assign(l, d));
        }, l.setTyped(c);
      }, {}], 6: [function(r, s, l) {
        var c = r("./common"), f = !0, p = !0;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch {
          f = !1;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch {
          p = !1;
        }
        for (var d = new c.Buf8(256), m = 0; m < 256; m++)
          d[m] = m >= 252 ? 6 : m >= 248 ? 5 : m >= 240 ? 4 : m >= 224 ? 3 : m >= 192 ? 2 : 1;
        d[254] = d[254] = 1, l.string2buf = function(S) {
          var x, w, k, O, T, L = S.length, j = 0;
          for (O = 0; O < L; O++)
            w = S.charCodeAt(O), (w & 64512) === 55296 && O + 1 < L && (k = S.charCodeAt(O + 1), (k & 64512) === 56320 && (w = 65536 + (w - 55296 << 10) + (k - 56320), O++)), j += w < 128 ? 1 : w < 2048 ? 2 : w < 65536 ? 3 : 4;
          for (x = new c.Buf8(j), T = 0, O = 0; T < j; O++)
            w = S.charCodeAt(O), (w & 64512) === 55296 && O + 1 < L && (k = S.charCodeAt(O + 1), (k & 64512) === 56320 && (w = 65536 + (w - 55296 << 10) + (k - 56320), O++)), w < 128 ? x[T++] = w : w < 2048 ? (x[T++] = 192 | w >>> 6, x[T++] = 128 | w & 63) : w < 65536 ? (x[T++] = 224 | w >>> 12, x[T++] = 128 | w >>> 6 & 63, x[T++] = 128 | w & 63) : (x[T++] = 240 | w >>> 18, x[T++] = 128 | w >>> 12 & 63, x[T++] = 128 | w >>> 6 & 63, x[T++] = 128 | w & 63);
          return x;
        };
        function y(S, x) {
          if (x < 65534 && (S.subarray && p || !S.subarray && f))
            return String.fromCharCode.apply(null, c.shrinkBuf(S, x));
          for (var w = "", k = 0; k < x; k++)
            w += String.fromCharCode(S[k]);
          return w;
        }
        l.buf2binstring = function(S) {
          return y(S, S.length);
        }, l.binstring2buf = function(S) {
          for (var x = new c.Buf8(S.length), w = 0, k = x.length; w < k; w++)
            x[w] = S.charCodeAt(w);
          return x;
        }, l.buf2string = function(S, x) {
          var w, k, O, T, L = x || S.length, j = new Array(L * 2);
          for (k = 0, w = 0; w < L; ) {
            if (O = S[w++], O < 128) {
              j[k++] = O;
              continue;
            }
            if (T = d[O], T > 4) {
              j[k++] = 65533, w += T - 1;
              continue;
            }
            for (O &= T === 2 ? 31 : T === 3 ? 15 : 7; T > 1 && w < L; )
              O = O << 6 | S[w++] & 63, T--;
            if (T > 1) {
              j[k++] = 65533;
              continue;
            }
            O < 65536 ? j[k++] = O : (O -= 65536, j[k++] = 55296 | O >> 10 & 1023, j[k++] = 56320 | O & 1023);
          }
          return y(j, k);
        }, l.utf8border = function(S, x) {
          var w;
          for (x = x || S.length, x > S.length && (x = S.length), w = x - 1; w >= 0 && (S[w] & 192) === 128; )
            w--;
          return w < 0 || w === 0 ? x : w + d[S[w]] > x ? w : x;
        };
      }, { "./common": 5 }], 7: [function(r, s, l) {
        function c(f, p, d, m) {
          for (var y = f & 65535 | 0, S = f >>> 16 & 65535 | 0, x = 0; d !== 0; ) {
            x = d > 2e3 ? 2e3 : d, d -= x;
            do
              y = y + p[m++] | 0, S = S + y | 0;
            while (--x);
            y %= 65521, S %= 65521;
          }
          return y | S << 16 | 0;
        }
        s.exports = c;
      }, {}], 8: [function(r, s, l) {
        s.exports = {
          /* Allowed flush values; see deflate() and inflate() below for details */
          Z_NO_FLUSH: 0,
          Z_PARTIAL_FLUSH: 1,
          Z_SYNC_FLUSH: 2,
          Z_FULL_FLUSH: 3,
          Z_FINISH: 4,
          Z_BLOCK: 5,
          Z_TREES: 6,
          /* Return codes for the compression/decompression functions. Negative values
          * are errors, positive values are used for special but normal events.
          */
          Z_OK: 0,
          Z_STREAM_END: 1,
          Z_NEED_DICT: 2,
          Z_ERRNO: -1,
          Z_STREAM_ERROR: -2,
          Z_DATA_ERROR: -3,
          //Z_MEM_ERROR:     -4,
          Z_BUF_ERROR: -5,
          //Z_VERSION_ERROR: -6,
          /* compression levels */
          Z_NO_COMPRESSION: 0,
          Z_BEST_SPEED: 1,
          Z_BEST_COMPRESSION: 9,
          Z_DEFAULT_COMPRESSION: -1,
          Z_FILTERED: 1,
          Z_HUFFMAN_ONLY: 2,
          Z_RLE: 3,
          Z_FIXED: 4,
          Z_DEFAULT_STRATEGY: 0,
          /* Possible values of the data_type field (though see inflate()) */
          Z_BINARY: 0,
          Z_TEXT: 1,
          //Z_ASCII:                1, // = Z_TEXT (deprecated)
          Z_UNKNOWN: 2,
          /* The deflate compression method */
          Z_DEFLATED: 8
          //Z_NULL:                 null // Use -1 or null inline, depending on var type
        };
      }, {}], 9: [function(r, s, l) {
        function c() {
          for (var d, m = [], y = 0; y < 256; y++) {
            d = y;
            for (var S = 0; S < 8; S++)
              d = d & 1 ? 3988292384 ^ d >>> 1 : d >>> 1;
            m[y] = d;
          }
          return m;
        }
        var f = c();
        function p(d, m, y, S) {
          var x = f, w = S + y;
          d ^= -1;
          for (var k = S; k < w; k++)
            d = d >>> 8 ^ x[(d ^ m[k]) & 255];
          return d ^ -1;
        }
        s.exports = p;
      }, {}], 10: [function(r, s, l) {
        function c() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
        }
        s.exports = c;
      }, {}], 11: [function(r, s, l) {
        var c = 30, f = 12;
        s.exports = function(d, m) {
          var y, S, x, w, k, O, T, L, j, z, J, ie, K, re, ee, de, Ce, he, oe, ge, we, Oe, Qe, Me, Ie;
          y = d.state, S = d.next_in, Me = d.input, x = S + (d.avail_in - 5), w = d.next_out, Ie = d.output, k = w - (m - d.avail_out), O = w + (d.avail_out - 257), T = y.dmax, L = y.wsize, j = y.whave, z = y.wnext, J = y.window, ie = y.hold, K = y.bits, re = y.lencode, ee = y.distcode, de = (1 << y.lenbits) - 1, Ce = (1 << y.distbits) - 1;
          e:
            do {
              K < 15 && (ie += Me[S++] << K, K += 8, ie += Me[S++] << K, K += 8), he = re[ie & de];
              t:
                for (; ; ) {
                  if (oe = he >>> 24, ie >>>= oe, K -= oe, oe = he >>> 16 & 255, oe === 0)
                    Ie[w++] = he & 65535;
                  else if (oe & 16) {
                    ge = he & 65535, oe &= 15, oe && (K < oe && (ie += Me[S++] << K, K += 8), ge += ie & (1 << oe) - 1, ie >>>= oe, K -= oe), K < 15 && (ie += Me[S++] << K, K += 8, ie += Me[S++] << K, K += 8), he = ee[ie & Ce];
                    r:
                      for (; ; ) {
                        if (oe = he >>> 24, ie >>>= oe, K -= oe, oe = he >>> 16 & 255, oe & 16) {
                          if (we = he & 65535, oe &= 15, K < oe && (ie += Me[S++] << K, K += 8, K < oe && (ie += Me[S++] << K, K += 8)), we += ie & (1 << oe) - 1, we > T) {
                            d.msg = "invalid distance too far back", y.mode = c;
                            break e;
                          }
                          if (ie >>>= oe, K -= oe, oe = w - k, we > oe) {
                            if (oe = we - oe, oe > j && y.sane) {
                              d.msg = "invalid distance too far back", y.mode = c;
                              break e;
                            }
                            if (Oe = 0, Qe = J, z === 0) {
                              if (Oe += L - oe, oe < ge) {
                                ge -= oe;
                                do
                                  Ie[w++] = J[Oe++];
                                while (--oe);
                                Oe = w - we, Qe = Ie;
                              }
                            } else if (z < oe) {
                              if (Oe += L + z - oe, oe -= z, oe < ge) {
                                ge -= oe;
                                do
                                  Ie[w++] = J[Oe++];
                                while (--oe);
                                if (Oe = 0, z < ge) {
                                  oe = z, ge -= oe;
                                  do
                                    Ie[w++] = J[Oe++];
                                  while (--oe);
                                  Oe = w - we, Qe = Ie;
                                }
                              }
                            } else if (Oe += z - oe, oe < ge) {
                              ge -= oe;
                              do
                                Ie[w++] = J[Oe++];
                              while (--oe);
                              Oe = w - we, Qe = Ie;
                            }
                            for (; ge > 2; )
                              Ie[w++] = Qe[Oe++], Ie[w++] = Qe[Oe++], Ie[w++] = Qe[Oe++], ge -= 3;
                            ge && (Ie[w++] = Qe[Oe++], ge > 1 && (Ie[w++] = Qe[Oe++]));
                          } else {
                            Oe = w - we;
                            do
                              Ie[w++] = Ie[Oe++], Ie[w++] = Ie[Oe++], Ie[w++] = Ie[Oe++], ge -= 3;
                            while (ge > 2);
                            ge && (Ie[w++] = Ie[Oe++], ge > 1 && (Ie[w++] = Ie[Oe++]));
                          }
                        } else if ((oe & 64) === 0) {
                          he = ee[(he & 65535) + (ie & (1 << oe) - 1)];
                          continue r;
                        } else {
                          d.msg = "invalid distance code", y.mode = c;
                          break e;
                        }
                        break;
                      }
                  } else if ((oe & 64) === 0) {
                    he = re[(he & 65535) + (ie & (1 << oe) - 1)];
                    continue t;
                  } else if (oe & 32) {
                    y.mode = f;
                    break e;
                  } else {
                    d.msg = "invalid literal/length code", y.mode = c;
                    break e;
                  }
                  break;
                }
            } while (S < x && w < O);
          ge = K >> 3, S -= ge, K -= ge << 3, ie &= (1 << K) - 1, d.next_in = S, d.next_out = w, d.avail_in = S < x ? 5 + (x - S) : 5 - (S - x), d.avail_out = w < O ? 257 + (O - w) : 257 - (w - O), y.hold = ie, y.bits = K;
        };
      }, {}], 12: [function(r, s, l) {
        var c = r("../utils/common"), f = r("./adler32"), p = r("./crc32"), d = r("./inffast"), m = r("./inftrees"), y = 0, S = 1, x = 2, w = 4, k = 5, O = 6, T = 0, L = 1, j = 2, z = -2, J = -3, ie = -4, K = -5, re = 8, ee = 1, de = 2, Ce = 3, he = 4, oe = 5, ge = 6, we = 7, Oe = 8, Qe = 9, Me = 10, Ie = 11, rt = 12, ot = 13, Et = 14, gt = 15, At = 16, Mt = 17, St = 18, Ve = 19, Ue = 20, He = 21, We = 22, ze = 23, at = 24, Ye = 25, tt = 26, wt = 27, Ft = 28, qe = 29, pe = 30, _e = 31, Xe = 32, lt = 852, Q = 592, te = 15, De = te;
        function nt(et) {
          return (et >>> 24 & 255) + (et >>> 8 & 65280) + ((et & 65280) << 8) + ((et & 255) << 24);
        }
        function be() {
          this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new c.Buf16(320), this.work = new c.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function G(et) {
          var ft;
          return !et || !et.state ? z : (ft = et.state, et.total_in = et.total_out = ft.total = 0, et.msg = "", ft.wrap && (et.adler = ft.wrap & 1), ft.mode = ee, ft.last = 0, ft.havedict = 0, ft.dmax = 32768, ft.head = null, ft.hold = 0, ft.bits = 0, ft.lencode = ft.lendyn = new c.Buf32(lt), ft.distcode = ft.distdyn = new c.Buf32(Q), ft.sane = 1, ft.back = -1, T);
        }
        function V(et) {
          var ft;
          return !et || !et.state ? z : (ft = et.state, ft.wsize = 0, ft.whave = 0, ft.wnext = 0, G(et));
        }
        function ve(et, ft) {
          var $, Se;
          return !et || !et.state || (Se = et.state, ft < 0 ? ($ = 0, ft = -ft) : ($ = (ft >> 4) + 1, ft < 48 && (ft &= 15)), ft && (ft < 8 || ft > 15)) ? z : (Se.window !== null && Se.wbits !== ft && (Se.window = null), Se.wrap = $, Se.wbits = ft, V(et));
        }
        function Ne(et, ft) {
          var $, Se;
          return et ? (Se = new be(), et.state = Se, Se.window = null, $ = ve(et, ft), $ !== T && (et.state = null), $) : z;
        }
        function it(et) {
          return Ne(et, De);
        }
        var yt = !0, $t, Gt;
        function Jt(et) {
          if (yt) {
            var ft;
            for ($t = new c.Buf32(512), Gt = new c.Buf32(32), ft = 0; ft < 144; )
              et.lens[ft++] = 8;
            for (; ft < 256; )
              et.lens[ft++] = 9;
            for (; ft < 280; )
              et.lens[ft++] = 7;
            for (; ft < 288; )
              et.lens[ft++] = 8;
            for (m(S, et.lens, 0, 288, $t, 0, et.work, { bits: 9 }), ft = 0; ft < 32; )
              et.lens[ft++] = 5;
            m(x, et.lens, 0, 32, Gt, 0, et.work, { bits: 5 }), yt = !1;
          }
          et.lencode = $t, et.lenbits = 9, et.distcode = Gt, et.distbits = 5;
        }
        function Xt(et, ft, $, Se) {
          var se, M = et.state;
          return M.window === null && (M.wsize = 1 << M.wbits, M.wnext = 0, M.whave = 0, M.window = new c.Buf8(M.wsize)), Se >= M.wsize ? (c.arraySet(M.window, ft, $ - M.wsize, M.wsize, 0), M.wnext = 0, M.whave = M.wsize) : (se = M.wsize - M.wnext, se > Se && (se = Se), c.arraySet(M.window, ft, $ - Se, se, M.wnext), Se -= se, Se ? (c.arraySet(M.window, ft, $ - Se, Se, 0), M.wnext = Se, M.whave = M.wsize) : (M.wnext += se, M.wnext === M.wsize && (M.wnext = 0), M.whave < M.wsize && (M.whave += se))), 0;
        }
        function Ae(et, ft) {
          var $, Se, se, M, ne, ce, X, Re, Ge, pt, xt, Pt, Yt, gr, dr = 0, It, ct, zt, xe, ae, _, U, fe, Te = new c.Buf8(4), Be, Je, Ct = (
            /* permutation of code lengths */
            [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
          );
          if (!et || !et.state || !et.output || !et.input && et.avail_in !== 0)
            return z;
          $ = et.state, $.mode === rt && ($.mode = ot), ne = et.next_out, se = et.output, X = et.avail_out, M = et.next_in, Se = et.input, ce = et.avail_in, Re = $.hold, Ge = $.bits, pt = ce, xt = X, fe = T;
          e:
            for (; ; )
              switch ($.mode) {
                case ee:
                  if ($.wrap === 0) {
                    $.mode = ot;
                    break;
                  }
                  for (; Ge < 16; ) {
                    if (ce === 0)
                      break e;
                    ce--, Re += Se[M++] << Ge, Ge += 8;
                  }
                  if ($.wrap & 2 && Re === 35615) {
                    $.check = 0, Te[0] = Re & 255, Te[1] = Re >>> 8 & 255, $.check = p($.check, Te, 2, 0), Re = 0, Ge = 0, $.mode = de;
                    break;
                  }
                  if ($.flags = 0, $.head && ($.head.done = !1), !($.wrap & 1) || /* check if zlib header allowed */
                  (((Re & 255) << 8) + (Re >> 8)) % 31) {
                    et.msg = "incorrect header check", $.mode = pe;
                    break;
                  }
                  if ((Re & 15) !== re) {
                    et.msg = "unknown compression method", $.mode = pe;
                    break;
                  }
                  if (Re >>>= 4, Ge -= 4, U = (Re & 15) + 8, $.wbits === 0)
                    $.wbits = U;
                  else if (U > $.wbits) {
                    et.msg = "invalid window size", $.mode = pe;
                    break;
                  }
                  $.dmax = 1 << U, et.adler = $.check = 1, $.mode = Re & 512 ? Me : rt, Re = 0, Ge = 0;
                  break;
                case de:
                  for (; Ge < 16; ) {
                    if (ce === 0)
                      break e;
                    ce--, Re += Se[M++] << Ge, Ge += 8;
                  }
                  if ($.flags = Re, ($.flags & 255) !== re) {
                    et.msg = "unknown compression method", $.mode = pe;
                    break;
                  }
                  if ($.flags & 57344) {
                    et.msg = "unknown header flags set", $.mode = pe;
                    break;
                  }
                  $.head && ($.head.text = Re >> 8 & 1), $.flags & 512 && (Te[0] = Re & 255, Te[1] = Re >>> 8 & 255, $.check = p($.check, Te, 2, 0)), Re = 0, Ge = 0, $.mode = Ce;
                /* falls through */
                case Ce:
                  for (; Ge < 32; ) {
                    if (ce === 0)
                      break e;
                    ce--, Re += Se[M++] << Ge, Ge += 8;
                  }
                  $.head && ($.head.time = Re), $.flags & 512 && (Te[0] = Re & 255, Te[1] = Re >>> 8 & 255, Te[2] = Re >>> 16 & 255, Te[3] = Re >>> 24 & 255, $.check = p($.check, Te, 4, 0)), Re = 0, Ge = 0, $.mode = he;
                /* falls through */
                case he:
                  for (; Ge < 16; ) {
                    if (ce === 0)
                      break e;
                    ce--, Re += Se[M++] << Ge, Ge += 8;
                  }
                  $.head && ($.head.xflags = Re & 255, $.head.os = Re >> 8), $.flags & 512 && (Te[0] = Re & 255, Te[1] = Re >>> 8 & 255, $.check = p($.check, Te, 2, 0)), Re = 0, Ge = 0, $.mode = oe;
                /* falls through */
                case oe:
                  if ($.flags & 1024) {
                    for (; Ge < 16; ) {
                      if (ce === 0)
                        break e;
                      ce--, Re += Se[M++] << Ge, Ge += 8;
                    }
                    $.length = Re, $.head && ($.head.extra_len = Re), $.flags & 512 && (Te[0] = Re & 255, Te[1] = Re >>> 8 & 255, $.check = p($.check, Te, 2, 0)), Re = 0, Ge = 0;
                  } else $.head && ($.head.extra = null);
                  $.mode = ge;
                /* falls through */
                case ge:
                  if ($.flags & 1024 && (Pt = $.length, Pt > ce && (Pt = ce), Pt && ($.head && (U = $.head.extra_len - $.length, $.head.extra || ($.head.extra = new Array($.head.extra_len)), c.arraySet(
                    $.head.extra,
                    Se,
                    M,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    Pt,
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    U
                  )), $.flags & 512 && ($.check = p($.check, Se, Pt, M)), ce -= Pt, M += Pt, $.length -= Pt), $.length))
                    break e;
                  $.length = 0, $.mode = we;
                /* falls through */
                case we:
                  if ($.flags & 2048) {
                    if (ce === 0)
                      break e;
                    Pt = 0;
                    do
                      U = Se[M + Pt++], $.head && U && $.length < 65536 && ($.head.name += String.fromCharCode(U));
                    while (U && Pt < ce);
                    if ($.flags & 512 && ($.check = p($.check, Se, Pt, M)), ce -= Pt, M += Pt, U)
                      break e;
                  } else $.head && ($.head.name = null);
                  $.length = 0, $.mode = Oe;
                /* falls through */
                case Oe:
                  if ($.flags & 4096) {
                    if (ce === 0)
                      break e;
                    Pt = 0;
                    do
                      U = Se[M + Pt++], $.head && U && $.length < 65536 && ($.head.comment += String.fromCharCode(U));
                    while (U && Pt < ce);
                    if ($.flags & 512 && ($.check = p($.check, Se, Pt, M)), ce -= Pt, M += Pt, U)
                      break e;
                  } else $.head && ($.head.comment = null);
                  $.mode = Qe;
                /* falls through */
                case Qe:
                  if ($.flags & 512) {
                    for (; Ge < 16; ) {
                      if (ce === 0)
                        break e;
                      ce--, Re += Se[M++] << Ge, Ge += 8;
                    }
                    if (Re !== ($.check & 65535)) {
                      et.msg = "header crc mismatch", $.mode = pe;
                      break;
                    }
                    Re = 0, Ge = 0;
                  }
                  $.head && ($.head.hcrc = $.flags >> 9 & 1, $.head.done = !0), et.adler = $.check = 0, $.mode = rt;
                  break;
                case Me:
                  for (; Ge < 32; ) {
                    if (ce === 0)
                      break e;
                    ce--, Re += Se[M++] << Ge, Ge += 8;
                  }
                  et.adler = $.check = nt(Re), Re = 0, Ge = 0, $.mode = Ie;
                /* falls through */
                case Ie:
                  if ($.havedict === 0)
                    return et.next_out = ne, et.avail_out = X, et.next_in = M, et.avail_in = ce, $.hold = Re, $.bits = Ge, j;
                  et.adler = $.check = 1, $.mode = rt;
                /* falls through */
                case rt:
                  if (ft === k || ft === O)
                    break e;
                /* falls through */
                case ot:
                  if ($.last) {
                    Re >>>= Ge & 7, Ge -= Ge & 7, $.mode = wt;
                    break;
                  }
                  for (; Ge < 3; ) {
                    if (ce === 0)
                      break e;
                    ce--, Re += Se[M++] << Ge, Ge += 8;
                  }
                  switch ($.last = Re & 1, Re >>>= 1, Ge -= 1, Re & 3) {
                    case 0:
                      $.mode = Et;
                      break;
                    case 1:
                      if (Jt($), $.mode = Ue, ft === O) {
                        Re >>>= 2, Ge -= 2;
                        break e;
                      }
                      break;
                    case 2:
                      $.mode = Mt;
                      break;
                    case 3:
                      et.msg = "invalid block type", $.mode = pe;
                  }
                  Re >>>= 2, Ge -= 2;
                  break;
                case Et:
                  for (Re >>>= Ge & 7, Ge -= Ge & 7; Ge < 32; ) {
                    if (ce === 0)
                      break e;
                    ce--, Re += Se[M++] << Ge, Ge += 8;
                  }
                  if ((Re & 65535) !== (Re >>> 16 ^ 65535)) {
                    et.msg = "invalid stored block lengths", $.mode = pe;
                    break;
                  }
                  if ($.length = Re & 65535, Re = 0, Ge = 0, $.mode = gt, ft === O)
                    break e;
                /* falls through */
                case gt:
                  $.mode = At;
                /* falls through */
                case At:
                  if (Pt = $.length, Pt) {
                    if (Pt > ce && (Pt = ce), Pt > X && (Pt = X), Pt === 0)
                      break e;
                    c.arraySet(se, Se, M, Pt, ne), ce -= Pt, M += Pt, X -= Pt, ne += Pt, $.length -= Pt;
                    break;
                  }
                  $.mode = rt;
                  break;
                case Mt:
                  for (; Ge < 14; ) {
                    if (ce === 0)
                      break e;
                    ce--, Re += Se[M++] << Ge, Ge += 8;
                  }
                  if ($.nlen = (Re & 31) + 257, Re >>>= 5, Ge -= 5, $.ndist = (Re & 31) + 1, Re >>>= 5, Ge -= 5, $.ncode = (Re & 15) + 4, Re >>>= 4, Ge -= 4, $.nlen > 286 || $.ndist > 30) {
                    et.msg = "too many length or distance symbols", $.mode = pe;
                    break;
                  }
                  $.have = 0, $.mode = St;
                /* falls through */
                case St:
                  for (; $.have < $.ncode; ) {
                    for (; Ge < 3; ) {
                      if (ce === 0)
                        break e;
                      ce--, Re += Se[M++] << Ge, Ge += 8;
                    }
                    $.lens[Ct[$.have++]] = Re & 7, Re >>>= 3, Ge -= 3;
                  }
                  for (; $.have < 19; )
                    $.lens[Ct[$.have++]] = 0;
                  if ($.lencode = $.lendyn, $.lenbits = 7, Be = { bits: $.lenbits }, fe = m(y, $.lens, 0, 19, $.lencode, 0, $.work, Be), $.lenbits = Be.bits, fe) {
                    et.msg = "invalid code lengths set", $.mode = pe;
                    break;
                  }
                  $.have = 0, $.mode = Ve;
                /* falls through */
                case Ve:
                  for (; $.have < $.nlen + $.ndist; ) {
                    for (; dr = $.lencode[Re & (1 << $.lenbits) - 1], It = dr >>> 24, ct = dr >>> 16 & 255, zt = dr & 65535, !(It <= Ge); ) {
                      if (ce === 0)
                        break e;
                      ce--, Re += Se[M++] << Ge, Ge += 8;
                    }
                    if (zt < 16)
                      Re >>>= It, Ge -= It, $.lens[$.have++] = zt;
                    else {
                      if (zt === 16) {
                        for (Je = It + 2; Ge < Je; ) {
                          if (ce === 0)
                            break e;
                          ce--, Re += Se[M++] << Ge, Ge += 8;
                        }
                        if (Re >>>= It, Ge -= It, $.have === 0) {
                          et.msg = "invalid bit length repeat", $.mode = pe;
                          break;
                        }
                        U = $.lens[$.have - 1], Pt = 3 + (Re & 3), Re >>>= 2, Ge -= 2;
                      } else if (zt === 17) {
                        for (Je = It + 3; Ge < Je; ) {
                          if (ce === 0)
                            break e;
                          ce--, Re += Se[M++] << Ge, Ge += 8;
                        }
                        Re >>>= It, Ge -= It, U = 0, Pt = 3 + (Re & 7), Re >>>= 3, Ge -= 3;
                      } else {
                        for (Je = It + 7; Ge < Je; ) {
                          if (ce === 0)
                            break e;
                          ce--, Re += Se[M++] << Ge, Ge += 8;
                        }
                        Re >>>= It, Ge -= It, U = 0, Pt = 11 + (Re & 127), Re >>>= 7, Ge -= 7;
                      }
                      if ($.have + Pt > $.nlen + $.ndist) {
                        et.msg = "invalid bit length repeat", $.mode = pe;
                        break;
                      }
                      for (; Pt--; )
                        $.lens[$.have++] = U;
                    }
                  }
                  if ($.mode === pe)
                    break;
                  if ($.lens[256] === 0) {
                    et.msg = "invalid code -- missing end-of-block", $.mode = pe;
                    break;
                  }
                  if ($.lenbits = 9, Be = { bits: $.lenbits }, fe = m(S, $.lens, 0, $.nlen, $.lencode, 0, $.work, Be), $.lenbits = Be.bits, fe) {
                    et.msg = "invalid literal/lengths set", $.mode = pe;
                    break;
                  }
                  if ($.distbits = 6, $.distcode = $.distdyn, Be = { bits: $.distbits }, fe = m(x, $.lens, $.nlen, $.ndist, $.distcode, 0, $.work, Be), $.distbits = Be.bits, fe) {
                    et.msg = "invalid distances set", $.mode = pe;
                    break;
                  }
                  if ($.mode = Ue, ft === O)
                    break e;
                /* falls through */
                case Ue:
                  $.mode = He;
                /* falls through */
                case He:
                  if (ce >= 6 && X >= 258) {
                    et.next_out = ne, et.avail_out = X, et.next_in = M, et.avail_in = ce, $.hold = Re, $.bits = Ge, d(et, xt), ne = et.next_out, se = et.output, X = et.avail_out, M = et.next_in, Se = et.input, ce = et.avail_in, Re = $.hold, Ge = $.bits, $.mode === rt && ($.back = -1);
                    break;
                  }
                  for ($.back = 0; dr = $.lencode[Re & (1 << $.lenbits) - 1], It = dr >>> 24, ct = dr >>> 16 & 255, zt = dr & 65535, !(It <= Ge); ) {
                    if (ce === 0)
                      break e;
                    ce--, Re += Se[M++] << Ge, Ge += 8;
                  }
                  if (ct && (ct & 240) === 0) {
                    for (xe = It, ae = ct, _ = zt; dr = $.lencode[_ + ((Re & (1 << xe + ae) - 1) >> xe)], It = dr >>> 24, ct = dr >>> 16 & 255, zt = dr & 65535, !(xe + It <= Ge); ) {
                      if (ce === 0)
                        break e;
                      ce--, Re += Se[M++] << Ge, Ge += 8;
                    }
                    Re >>>= xe, Ge -= xe, $.back += xe;
                  }
                  if (Re >>>= It, Ge -= It, $.back += It, $.length = zt, ct === 0) {
                    $.mode = tt;
                    break;
                  }
                  if (ct & 32) {
                    $.back = -1, $.mode = rt;
                    break;
                  }
                  if (ct & 64) {
                    et.msg = "invalid literal/length code", $.mode = pe;
                    break;
                  }
                  $.extra = ct & 15, $.mode = We;
                /* falls through */
                case We:
                  if ($.extra) {
                    for (Je = $.extra; Ge < Je; ) {
                      if (ce === 0)
                        break e;
                      ce--, Re += Se[M++] << Ge, Ge += 8;
                    }
                    $.length += Re & (1 << $.extra) - 1, Re >>>= $.extra, Ge -= $.extra, $.back += $.extra;
                  }
                  $.was = $.length, $.mode = ze;
                /* falls through */
                case ze:
                  for (; dr = $.distcode[Re & (1 << $.distbits) - 1], It = dr >>> 24, ct = dr >>> 16 & 255, zt = dr & 65535, !(It <= Ge); ) {
                    if (ce === 0)
                      break e;
                    ce--, Re += Se[M++] << Ge, Ge += 8;
                  }
                  if ((ct & 240) === 0) {
                    for (xe = It, ae = ct, _ = zt; dr = $.distcode[_ + ((Re & (1 << xe + ae) - 1) >> xe)], It = dr >>> 24, ct = dr >>> 16 & 255, zt = dr & 65535, !(xe + It <= Ge); ) {
                      if (ce === 0)
                        break e;
                      ce--, Re += Se[M++] << Ge, Ge += 8;
                    }
                    Re >>>= xe, Ge -= xe, $.back += xe;
                  }
                  if (Re >>>= It, Ge -= It, $.back += It, ct & 64) {
                    et.msg = "invalid distance code", $.mode = pe;
                    break;
                  }
                  $.offset = zt, $.extra = ct & 15, $.mode = at;
                /* falls through */
                case at:
                  if ($.extra) {
                    for (Je = $.extra; Ge < Je; ) {
                      if (ce === 0)
                        break e;
                      ce--, Re += Se[M++] << Ge, Ge += 8;
                    }
                    $.offset += Re & (1 << $.extra) - 1, Re >>>= $.extra, Ge -= $.extra, $.back += $.extra;
                  }
                  if ($.offset > $.dmax) {
                    et.msg = "invalid distance too far back", $.mode = pe;
                    break;
                  }
                  $.mode = Ye;
                /* falls through */
                case Ye:
                  if (X === 0)
                    break e;
                  if (Pt = xt - X, $.offset > Pt) {
                    if (Pt = $.offset - Pt, Pt > $.whave && $.sane) {
                      et.msg = "invalid distance too far back", $.mode = pe;
                      break;
                    }
                    Pt > $.wnext ? (Pt -= $.wnext, Yt = $.wsize - Pt) : Yt = $.wnext - Pt, Pt > $.length && (Pt = $.length), gr = $.window;
                  } else
                    gr = se, Yt = ne - $.offset, Pt = $.length;
                  Pt > X && (Pt = X), X -= Pt, $.length -= Pt;
                  do
                    se[ne++] = gr[Yt++];
                  while (--Pt);
                  $.length === 0 && ($.mode = He);
                  break;
                case tt:
                  if (X === 0)
                    break e;
                  se[ne++] = $.length, X--, $.mode = He;
                  break;
                case wt:
                  if ($.wrap) {
                    for (; Ge < 32; ) {
                      if (ce === 0)
                        break e;
                      ce--, Re |= Se[M++] << Ge, Ge += 8;
                    }
                    if (xt -= X, et.total_out += xt, $.total += xt, xt && (et.adler = $.check = /*UPDATE(state.check, put - _out, _out);*/
                    $.flags ? p($.check, se, xt, ne - xt) : f($.check, se, xt, ne - xt)), xt = X, ($.flags ? Re : nt(Re)) !== $.check) {
                      et.msg = "incorrect data check", $.mode = pe;
                      break;
                    }
                    Re = 0, Ge = 0;
                  }
                  $.mode = Ft;
                /* falls through */
                case Ft:
                  if ($.wrap && $.flags) {
                    for (; Ge < 32; ) {
                      if (ce === 0)
                        break e;
                      ce--, Re += Se[M++] << Ge, Ge += 8;
                    }
                    if (Re !== ($.total & 4294967295)) {
                      et.msg = "incorrect length check", $.mode = pe;
                      break;
                    }
                    Re = 0, Ge = 0;
                  }
                  $.mode = qe;
                /* falls through */
                case qe:
                  fe = L;
                  break e;
                case pe:
                  fe = J;
                  break e;
                case _e:
                  return ie;
                case Xe:
                /* falls through */
                default:
                  return z;
              }
          return et.next_out = ne, et.avail_out = X, et.next_in = M, et.avail_in = ce, $.hold = Re, $.bits = Ge, ($.wsize || xt !== et.avail_out && $.mode < pe && ($.mode < wt || ft !== w)) && Xt(et, et.output, et.next_out, xt - et.avail_out), pt -= et.avail_in, xt -= et.avail_out, et.total_in += pt, et.total_out += xt, $.total += xt, $.wrap && xt && (et.adler = $.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
          $.flags ? p($.check, se, xt, et.next_out - xt) : f($.check, se, xt, et.next_out - xt)), et.data_type = $.bits + ($.last ? 64 : 0) + ($.mode === rt ? 128 : 0) + ($.mode === Ue || $.mode === gt ? 256 : 0), (pt === 0 && xt === 0 || ft === w) && fe === T && (fe = K), fe;
        }
        function vt(et) {
          if (!et || !et.state)
            return z;
          var ft = et.state;
          return ft.window && (ft.window = null), et.state = null, T;
        }
        function Ot(et, ft) {
          var $;
          return !et || !et.state || ($ = et.state, ($.wrap & 2) === 0) ? z : ($.head = ft, ft.done = !1, T);
        }
        function Vt(et, ft) {
          var $ = ft.length, Se, se, M;
          return !et || !et.state || (Se = et.state, Se.wrap !== 0 && Se.mode !== Ie) ? z : Se.mode === Ie && (se = 1, se = f(se, ft, $, 0), se !== Se.check) ? J : (M = Xt(et, ft, $, $), M ? (Se.mode = _e, ie) : (Se.havedict = 1, T));
        }
        l.inflateReset = V, l.inflateReset2 = ve, l.inflateResetKeep = G, l.inflateInit = it, l.inflateInit2 = Ne, l.inflate = Ae, l.inflateEnd = vt, l.inflateGetHeader = Ot, l.inflateSetDictionary = Vt, l.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 5, "./adler32": 7, "./crc32": 9, "./inffast": 11, "./inftrees": 13 }], 13: [function(r, s, l) {
        var c = r("../utils/common"), f = 15, p = 852, d = 592, m = 0, y = 1, S = 2, x = [
          /* Length codes 257..285 base */
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          13,
          15,
          17,
          19,
          23,
          27,
          31,
          35,
          43,
          51,
          59,
          67,
          83,
          99,
          115,
          131,
          163,
          195,
          227,
          258,
          0,
          0
        ], w = [
          /* Length codes 257..285 extra */
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          16,
          17,
          17,
          17,
          17,
          18,
          18,
          18,
          18,
          19,
          19,
          19,
          19,
          20,
          20,
          20,
          20,
          21,
          21,
          21,
          21,
          16,
          72,
          78
        ], k = [
          /* Distance codes 0..29 base */
          1,
          2,
          3,
          4,
          5,
          7,
          9,
          13,
          17,
          25,
          33,
          49,
          65,
          97,
          129,
          193,
          257,
          385,
          513,
          769,
          1025,
          1537,
          2049,
          3073,
          4097,
          6145,
          8193,
          12289,
          16385,
          24577,
          0,
          0
        ], O = [
          /* Distance codes 0..29 extra */
          16,
          16,
          16,
          16,
          17,
          17,
          18,
          18,
          19,
          19,
          20,
          20,
          21,
          21,
          22,
          22,
          23,
          23,
          24,
          24,
          25,
          25,
          26,
          26,
          27,
          27,
          28,
          28,
          29,
          29,
          64,
          64
        ];
        s.exports = function(L, j, z, J, ie, K, re, ee) {
          var de = ee.bits, Ce = 0, he = 0, oe = 0, ge = 0, we = 0, Oe = 0, Qe = 0, Me = 0, Ie = 0, rt = 0, ot, Et, gt, At, Mt, St = null, Ve = 0, Ue, He = new c.Buf16(f + 1), We = new c.Buf16(f + 1), ze = null, at = 0, Ye, tt, wt;
          for (Ce = 0; Ce <= f; Ce++)
            He[Ce] = 0;
          for (he = 0; he < J; he++)
            He[j[z + he]]++;
          for (we = de, ge = f; ge >= 1 && He[ge] === 0; ge--)
            ;
          if (we > ge && (we = ge), ge === 0)
            return ie[K++] = 1 << 24 | 64 << 16 | 0, ie[K++] = 1 << 24 | 64 << 16 | 0, ee.bits = 1, 0;
          for (oe = 1; oe < ge && He[oe] === 0; oe++)
            ;
          for (we < oe && (we = oe), Me = 1, Ce = 1; Ce <= f; Ce++)
            if (Me <<= 1, Me -= He[Ce], Me < 0)
              return -1;
          if (Me > 0 && (L === m || ge !== 1))
            return -1;
          for (We[1] = 0, Ce = 1; Ce < f; Ce++)
            We[Ce + 1] = We[Ce] + He[Ce];
          for (he = 0; he < J; he++)
            j[z + he] !== 0 && (re[We[j[z + he]]++] = he);
          if (L === m ? (St = ze = re, Ue = 19) : L === y ? (St = x, Ve -= 257, ze = w, at -= 257, Ue = 256) : (St = k, ze = O, Ue = -1), rt = 0, he = 0, Ce = oe, Mt = K, Oe = we, Qe = 0, gt = -1, Ie = 1 << we, At = Ie - 1, L === y && Ie > p || L === S && Ie > d)
            return 1;
          for (; ; ) {
            Ye = Ce - Qe, re[he] < Ue ? (tt = 0, wt = re[he]) : re[he] > Ue ? (tt = ze[at + re[he]], wt = St[Ve + re[he]]) : (tt = 96, wt = 0), ot = 1 << Ce - Qe, Et = 1 << Oe, oe = Et;
            do
              Et -= ot, ie[Mt + (rt >> Qe) + Et] = Ye << 24 | tt << 16 | wt | 0;
            while (Et !== 0);
            for (ot = 1 << Ce - 1; rt & ot; )
              ot >>= 1;
            if (ot !== 0 ? (rt &= ot - 1, rt += ot) : rt = 0, he++, --He[Ce] === 0) {
              if (Ce === ge)
                break;
              Ce = j[z + re[he]];
            }
            if (Ce > we && (rt & At) !== gt) {
              for (Qe === 0 && (Qe = we), Mt += oe, Oe = Ce - Qe, Me = 1 << Oe; Oe + Qe < ge && (Me -= He[Oe + Qe], !(Me <= 0)); )
                Oe++, Me <<= 1;
              if (Ie += 1 << Oe, L === y && Ie > p || L === S && Ie > d)
                return 1;
              gt = rt & At, ie[gt] = we << 24 | Oe << 16 | Mt - K | 0;
            }
          }
          return rt !== 0 && (ie[Mt + rt] = Ce - Qe << 24 | 64 << 16 | 0), ee.bits = we, 0;
        };
      }, { "../utils/common": 5 }], 14: [function(r, s, l) {
        s.exports = {
          2: "need dictionary",
          /* Z_NEED_DICT       2  */
          1: "stream end",
          /* Z_STREAM_END      1  */
          0: "",
          /* Z_OK              0  */
          "-1": "file error",
          /* Z_ERRNO         (-1) */
          "-2": "stream error",
          /* Z_STREAM_ERROR  (-2) */
          "-3": "data error",
          /* Z_DATA_ERROR    (-3) */
          "-4": "insufficient memory",
          /* Z_MEM_ERROR     (-4) */
          "-5": "buffer error",
          /* Z_BUF_ERROR     (-5) */
          "-6": "incompatible version"
          /* Z_VERSION_ERROR (-6) */
        };
      }, {}], 15: [function(r, s, l) {
        function c() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        }
        s.exports = c;
      }, {}] }, {}, [3])(3);
    });
  }(Dj)), Dj.exports;
}
var Pj, vV;
function hGe() {
  return vV || (vV = 1, Pj = {
    encode: fGe().encode,
    decode: dGe().decode
  }), Pj;
}
/*!
 * TOAST UI Editor : UML Plugin
 * @version 3.0.1 | Wed Jul 07 2021
 * @author NHN FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
var mV;
function pGe() {
  return mV || (mV = 1, function(i, e) {
    (function(s, l) {
      i.exports = l(hGe());
    })(self, function(r) {
      return (
        /******/
        function() {
          var s = {
            /***/
            94: (
              /***/
              function(p) {
                p.exports = r;
              }
            )
            /******/
          }, l = {};
          function c(p) {
            var d = l[p];
            if (d !== void 0)
              return d.exports;
            var m = l[p] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            return s[p](m, m.exports, c), m.exports;
          }
          (function() {
            c.n = function(p) {
              var d = p && p.__esModule ? (
                /******/
                function() {
                  return p.default;
                }
              ) : (
                /******/
                function() {
                  return p;
                }
              );
              return c.d(d, { a: d }), d;
            };
          })(), function() {
            c.d = function(p, d) {
              for (var m in d)
                c.o(d, m) && !c.o(p, m) && Object.defineProperty(p, m, { enumerable: !0, get: d[m] });
            };
          }(), function() {
            c.o = function(p, d) {
              return Object.prototype.hasOwnProperty.call(p, d);
            };
          }();
          var f = {};
          return function() {
            c.d(f, {
              /* harmony export */
              default: function() {
                return (
                  /* binding */
                  S
                );
              }
              /* harmony export */
            });
            var p = c(94), d = /* @__PURE__ */ c.n(p), m = "//www.plantuml.com/plantuml/png/";
            function y(x, w) {
              var k;
              try {
                if (!d())
                  throw new Error("plantuml-encoder dependency required");
                k = '<img src="' + w + d().encode(x) + '" />';
              } catch (O) {
                k = "Error occurred on encoding uml: " + O.message;
              }
              return [
                { type: "openTag", tagName: "div", outerNewLine: !0 },
                { type: "html", content: k },
                { type: "closeTag", tagName: "div", outerNewLine: !0 }
              ];
            }
            function S(x, w) {
              w === void 0 && (w = {});
              var k = w.rendererURL, O = k === void 0 ? m : k;
              return {
                toHTMLRenderers: {
                  uml: function(T) {
                    return y(T.literal, O);
                  },
                  plantUml: function(T) {
                    return y(T.literal, O);
                  }
                }
              };
            }
          }(), f = f.default, f;
        }()
      );
    });
  }(Mj)), Mj.exports;
}
var vGe = pGe();
const mGe = /* @__PURE__ */ Cp(vGe), q9 = (i) => {
  const e = {
    chart: eGe,
    codeSyntaxHighlight: nGe,
    colorSyntax: sGe,
    tableMergedCell: cGe,
    uml: mGe
  };
  return i.map((r) => e[r]);
}, gGe = (i, e) => {
  if (!i.value)
    throw new Error("Reference to the element is set");
  const r = new Qn({
    el: i.value,
    height: e.height,
    hideModeSwitch: e.hideModeSwitch,
    initialEditType: e.initialEditType,
    initialValue: e.initialValue,
    language: e.language,
    plugins: e.plugins !== void 0 ? q9(e.plugins) : void 0,
    previewStyle: e.previewStyle,
    toolbarItems: e.toolbarItems,
    usageStatistics: e.usageStatistics,
    useCommandShortcut: e.useCommandShortcut,
    events: {
      change: e.onChange ? () => e.onChange && e.onChange(r) : () => {
      }
    },
    hooks: {
      addImageBlobHook: e.addImageBlobHook
    }
  });
  return r;
}, yGe = {
  key: 0,
  class: "fullscreen-button-container"
}, bGe = /* @__PURE__ */ (0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({
  __name: "Editor",
  props: /* @__PURE__ */ (0,vue__WEBPACK_IMPORTED_MODULE_0__.mergeModels)({
    allowFullScreen: { type: Boolean, default: !0 },
    darkMode: { type: Boolean, default: !1 },
    editorClasses: {},
    enhanced: { type: Boolean, default: !0 },
    height: { default: "500px" },
    hideModeSwitch: { type: Boolean },
    initialEditType: { default: "markdown" },
    language: {},
    plugins: { default: () => [] },
    previewStyle: { default: "tab" },
    toolbarItems: { default: () => [
      ["heading", "bold", "italic"],
      ["quote", "ul", "ol"],
      ["table", "link"]
    ] },
    usageStatistics: { type: Boolean },
    useCommandShortcut: { type: Boolean }
  }, {
    modelValue: { default: "" },
    modelModifiers: {},
    fullScreen: { type: Boolean, default: !1 },
    fullScreenModifiers: {}
  }),
  emits: /* @__PURE__ */ (0,vue__WEBPACK_IMPORTED_MODULE_0__.mergeModels)(["addImage"], ["update:modelValue", "update:fullScreen"]),
  setup(i, { expose: e, emit: r }) {
    const s = i, l = (0,vue__WEBPACK_IMPORTED_MODULE_0__.useModel)(i, "modelValue"), c = (0,vue__WEBPACK_IMPORTED_MODULE_0__.useModel)(i, "fullScreen"), f = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null), p = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null), d = r;
    return e({ editor: f }), (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(c, (m) => {
      document.body.style.overflow = m ? "hidden" : "";
    }), (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => (0,vue__WEBPACK_IMPORTED_MODULE_0__.nextTick)(() => {
      f.value = gGe(p, {
        height: "100cqh",
        hideModeSwitch: s.hideModeSwitch,
        initialEditType: s.initialEditType,
        initialValue: l.value,
        language: s.language,
        plugins: s.plugins,
        previewStyle: s.previewStyle,
        toolbarItems: s.toolbarItems,
        usageStatistics: s.usageStatistics,
        useCommandShortcut: s.useCommandShortcut,
        addImageBlobHook: (m, y) => d("addImage", { blob: m, callback: y }),
        onChange: (m) => {
          l.value = m.getMarkdown();
        }
      });
    })), (m, y) => ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
      class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(["tui-editor-vue3-wrapper", {
        "tui-editor-vue3-enhanced": m.enhanced,
        "toastui-full-screen": c.value,
        "toastui-editor-dark": m.darkMode
      }]),
      style: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeStyle)({ height: c.value ? void 0 : m.height }),
      onKeydown: y[1] || (y[1] = (0,vue__WEBPACK_IMPORTED_MODULE_0__.withKeys)((S) => c.value = !1, ["escape"]))
    }, [
      (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("div", {
        ref_key: "editorEl",
        ref: p,
        class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)(m.editorClasses)
      }, null, 2),
      s.allowFullScreen ? ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", yGe, [
        (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("a", {
          href: "#",
          class: "fullscreen-button",
          onClick: y[0] || (y[0] = (0,vue__WEBPACK_IMPORTED_MODULE_0__.withModifiers)((S) => c.value = !c.value, ["prevent"]))
        }, y[2] || (y[2] = [
          (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            fill: "none",
            viewBox: "0 0 24 24",
            stroke: "currentColor",
            "stroke-width": "2"
          }, [
            (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementVNode)("path", {
              "stroke-linecap": "round",
              "stroke-linejoin": "round",
              d: "M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"
            })
          ], -1)
        ]))
      ])) : (0,vue__WEBPACK_IMPORTED_MODULE_0__.createCommentVNode)("", !0)
    ], 38));
  }
});
var Lj = { exports: {} }, pa = {}, Po = {}, Ki = {}, Ij, gV;
function SGe() {
  if (gV) return Ij;
  gV = 1;
  function i(e) {
    this.content = e;
  }
  return i.prototype = {
    constructor: i,
    find: function(e) {
      for (var r = 0; r < this.content.length; r += 2)
        if (this.content[r] === e) return r;
      return -1;
    },
    // :: (string) → ?any
    // Retrieve the value stored under `key`, or return undefined when
    // no such key exists.
    get: function(e) {
      var r = this.find(e);
      return r == -1 ? void 0 : this.content[r + 1];
    },
    // :: (string, any, ?string) → OrderedMap
    // Create a new map by replacing the value of `key` with a new
    // value, or adding a binding to the end of the map. If `newKey` is
    // given, the key of the binding will be replaced with that key.
    update: function(e, r, s) {
      var l = s && s != e ? this.remove(s) : this, c = l.find(e), f = l.content.slice();
      return c == -1 ? f.push(s || e, r) : (f[c + 1] = r, s && (f[c] = s)), new i(f);
    },
    // :: (string) → OrderedMap
    // Return a map with the given key removed, if it existed.
    remove: function(e) {
      var r = this.find(e);
      if (r == -1) return this;
      var s = this.content.slice();
      return s.splice(r, 2), new i(s);
    },
    // :: (string, any) → OrderedMap
    // Add a new key to the start of the map.
    addToStart: function(e, r) {
      return new i([e, r].concat(this.remove(e).content));
    },
    // :: (string, any) → OrderedMap
    // Add a new key to the end of the map.
    addToEnd: function(e, r) {
      var s = this.remove(e).content.slice();
      return s.push(e, r), new i(s);
    },
    // :: (string, string, any) → OrderedMap
    // Add a key after the given key. If `place` is not found, the new
    // key is added to the end.
    addBefore: function(e, r, s) {
      var l = this.remove(r), c = l.content.slice(), f = l.find(e);
      return c.splice(f == -1 ? c.length : f, 0, r, s), new i(c);
    },
    // :: ((key: string, value: any))
    // Call the given function for each key/value pair in the map, in
    // order.
    forEach: function(e) {
      for (var r = 0; r < this.content.length; r += 2)
        e(this.content[r], this.content[r + 1]);
    },
    // :: (union<Object, OrderedMap>) → OrderedMap
    // Create a new map by prepending the keys in this map that don't
    // appear in `map` before the keys in `map`.
    prepend: function(e) {
      return e = i.from(e), e.size ? new i(e.content.concat(this.subtract(e).content)) : this;
    },
    // :: (union<Object, OrderedMap>) → OrderedMap
    // Create a new map by appending the keys in this map that don't
    // appear in `map` after the keys in `map`.
    append: function(e) {
      return e = i.from(e), e.size ? new i(this.subtract(e).content.concat(e.content)) : this;
    },
    // :: (union<Object, OrderedMap>) → OrderedMap
    // Create a map containing all the keys in this map that don't
    // appear in `map`.
    subtract: function(e) {
      var r = this;
      e = i.from(e);
      for (var s = 0; s < e.content.length; s += 2)
        r = r.remove(e.content[s]);
      return r;
    },
    // :: () → Object
    // Turn ordered map into a plain object.
    toObject: function() {
      var e = {};
      return this.forEach(function(r, s) {
        e[r] = s;
      }), e;
    },
    // :: number
    // The amount of keys in this map.
    get size() {
      return this.content.length >> 1;
    }
  }, i.from = function(e) {
    if (e instanceof i) return e;
    var r = [];
    if (e) for (var s in e) r.push(s, e[s]);
    return new i(r);
  }, Ij = i, Ij;
}
var yV;
function ek() {
  if (yV) return Ki;
  yV = 1;
  function i(xe, ae) {
    return c(xe) || l(xe, ae) || r(xe, ae) || e();
  }
  function e() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function r(xe, ae) {
    if (xe) {
      if (typeof xe == "string") return s(xe, ae);
      var _ = Object.prototype.toString.call(xe).slice(8, -1);
      if (_ === "Object" && xe.constructor && (_ = xe.constructor.name), _ === "Map" || _ === "Set") return Array.from(xe);
      if (_ === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(_)) return s(xe, ae);
    }
  }
  function s(xe, ae) {
    (ae == null || ae > xe.length) && (ae = xe.length);
    for (var _ = 0, U = new Array(ae); _ < ae; _++)
      U[_] = xe[_];
    return U;
  }
  function l(xe, ae) {
    var _ = xe == null ? null : typeof Symbol < "u" && xe[Symbol.iterator] || xe["@@iterator"];
    if (_ != null) {
      var U = [], fe = !0, Te = !1, Be, Je;
      try {
        for (_ = _.call(xe); !(fe = (Be = _.next()).done) && (U.push(Be.value), !(ae && U.length === ae)); fe = !0)
          ;
      } catch (Ct) {
        Te = !0, Je = Ct;
      } finally {
        try {
          !fe && _.return != null && _.return();
        } finally {
          if (Te) throw Je;
        }
      }
      return U;
    }
  }
  function c(xe) {
    if (Array.isArray(xe)) return xe;
  }
  function f() {
    return typeof Reflect < "u" && Reflect.get ? f = Reflect.get : f = function(ae, _, U) {
      var fe = p(ae, _);
      if (fe) {
        var Te = Object.getOwnPropertyDescriptor(fe, _);
        return Te.get ? Te.get.call(arguments.length < 3 ? ae : U) : Te.value;
      }
    }, f.apply(this, arguments);
  }
  function p(xe, ae) {
    for (; !Object.prototype.hasOwnProperty.call(xe, ae) && (xe = L(xe), xe !== null); )
      ;
    return xe;
  }
  function d(xe, ae) {
    if (typeof ae != "function" && ae !== null)
      throw new TypeError("Super expression must either be null or a function");
    xe.prototype = Object.create(ae && ae.prototype, { constructor: { value: xe, writable: !0, configurable: !0 } }), Object.defineProperty(xe, "prototype", { writable: !1 }), ae && T(xe, ae);
  }
  function m(xe) {
    var ae = k();
    return function() {
      var U = L(xe), fe;
      if (ae) {
        var Te = L(this).constructor;
        fe = Reflect.construct(U, arguments, Te);
      } else
        fe = U.apply(this, arguments);
      return y(this, fe);
    };
  }
  function y(xe, ae) {
    if (ae && (ie(ae) === "object" || typeof ae == "function"))
      return ae;
    if (ae !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return S(xe);
  }
  function S(xe) {
    if (xe === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return xe;
  }
  function x(xe) {
    var ae = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return x = function(U) {
      if (U === null || !O(U)) return U;
      if (typeof U != "function")
        throw new TypeError("Super expression must either be null or a function");
      if (typeof ae < "u") {
        if (ae.has(U)) return ae.get(U);
        ae.set(U, fe);
      }
      function fe() {
        return w(U, arguments, L(this).constructor);
      }
      return fe.prototype = Object.create(U.prototype, { constructor: { value: fe, enumerable: !1, writable: !0, configurable: !0 } }), T(fe, U);
    }, x(xe);
  }
  function w(xe, ae, _) {
    return k() ? w = Reflect.construct : w = function(fe, Te, Be) {
      var Je = [null];
      Je.push.apply(Je, Te);
      var Ct = Function.bind.apply(fe, Je), jt = new Ct();
      return Be && T(jt, Be.prototype), jt;
    }, w.apply(null, arguments);
  }
  function k() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function O(xe) {
    return Function.toString.call(xe).indexOf("[native code]") !== -1;
  }
  function T(xe, ae) {
    return T = Object.setPrototypeOf || function(U, fe) {
      return U.__proto__ = fe, U;
    }, T(xe, ae);
  }
  function L(xe) {
    return L = Object.setPrototypeOf ? Object.getPrototypeOf : function(_) {
      return _.__proto__ || Object.getPrototypeOf(_);
    }, L(xe);
  }
  function j(xe, ae) {
    if (!(xe instanceof ae))
      throw new TypeError("Cannot call a class as a function");
  }
  function z(xe, ae) {
    for (var _ = 0; _ < ae.length; _++) {
      var U = ae[_];
      U.enumerable = U.enumerable || !1, U.configurable = !0, "value" in U && (U.writable = !0), Object.defineProperty(xe, U.key, U);
    }
  }
  function J(xe, ae, _) {
    return ae && z(xe.prototype, ae), _ && z(xe, _), Object.defineProperty(xe, "prototype", { writable: !1 }), xe;
  }
  function ie(xe) {
    "@babel/helpers - typeof";
    return ie = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ae) {
      return typeof ae;
    } : function(ae) {
      return ae && typeof Symbol == "function" && ae.constructor === Symbol && ae !== Symbol.prototype ? "symbol" : typeof ae;
    }, ie(xe);
  }
  Object.defineProperty(Ki, "__esModule", {
    value: !0
  });
  var K = /* @__PURE__ */ SGe();
  function re(xe) {
    return xe && ie(xe) === "object" && "default" in xe ? xe : {
      default: xe
    };
  }
  var ee = re(K);
  function de(xe, ae, _) {
    for (var U = 0; ; U++) {
      if (U == xe.childCount || U == ae.childCount) return xe.childCount == ae.childCount ? null : _;
      var fe = xe.child(U), Te = ae.child(U);
      if (fe == Te) {
        _ += fe.nodeSize;
        continue;
      }
      if (!fe.sameMarkup(Te)) return _;
      if (fe.isText && fe.text != Te.text) {
        for (var Be = 0; fe.text[Be] == Te.text[Be]; Be++)
          _++;
        return _;
      }
      if (fe.content.size || Te.content.size) {
        var Je = de(fe.content, Te.content, _ + 1);
        if (Je != null) return Je;
      }
      _ += fe.nodeSize;
    }
  }
  function Ce(xe, ae, _, U) {
    for (var fe = xe.childCount, Te = ae.childCount; ; ) {
      if (fe == 0 || Te == 0) return fe == Te ? null : {
        a: _,
        b: U
      };
      var Be = xe.child(--fe), Je = ae.child(--Te), Ct = Be.nodeSize;
      if (Be == Je) {
        _ -= Ct, U -= Ct;
        continue;
      }
      if (!Be.sameMarkup(Je)) return {
        a: _,
        b: U
      };
      if (Be.isText && Be.text != Je.text) {
        for (var jt = 0, tr = Math.min(Be.text.length, Je.text.length); jt < tr && Be.text[Be.text.length - jt - 1] == Je.text[Je.text.length - jt - 1]; )
          jt++, _--, U--;
        return {
          a: _,
          b: U
        };
      }
      if (Be.content.size || Je.content.size) {
        var Kt = Ce(Be.content, Je.content, _ - 1, U - 1);
        if (Kt) return Kt;
      }
      _ -= Ct, U -= Ct;
    }
  }
  var he = function() {
    function xe(ae, _) {
      if (j(this, xe), this.content = ae, this.size = _ || 0, _ == null) for (var U = 0; U < ae.length; U++)
        this.size += ae[U].nodeSize;
    }
    return J(xe, [{
      key: "nodesBetween",
      value: function(_, U, fe) {
        for (var Te = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, Be = arguments.length > 4 ? arguments[4] : void 0, Je = 0, Ct = 0; Ct < U; Je++) {
          var jt = this.content[Je], tr = Ct + jt.nodeSize;
          if (tr > _ && fe(jt, Te + Ct, Be || null, Je) !== !1 && jt.content.size) {
            var Kt = Ct + 1;
            jt.nodesBetween(Math.max(0, _ - Kt), Math.min(jt.content.size, U - Kt), fe, Te + Kt);
          }
          Ct = tr;
        }
      }
    }, {
      key: "descendants",
      value: function(_) {
        this.nodesBetween(0, this.size, _);
      }
    }, {
      key: "textBetween",
      value: function(_, U, fe, Te) {
        var Be = "", Je = !0;
        return this.nodesBetween(_, U, function(Ct, jt) {
          Ct.isText ? (Be += Ct.text.slice(Math.max(_, jt) - jt, U - jt), Je = !fe) : Ct.isLeaf ? (Te ? Be += typeof Te == "function" ? Te(Ct) : Te : Ct.type.spec.leafText && (Be += Ct.type.spec.leafText(Ct)), Je = !fe) : !Je && Ct.isBlock && (Be += fe, Je = !0);
        }, 0), Be;
      }
    }, {
      key: "append",
      value: function(_) {
        if (!_.size) return this;
        if (!this.size) return _;
        var U = this.lastChild, fe = _.firstChild, Te = this.content.slice(), Be = 0;
        for (U.isText && U.sameMarkup(fe) && (Te[Te.length - 1] = U.withText(U.text + fe.text), Be = 1); Be < _.content.length; Be++)
          Te.push(_.content[Be]);
        return new xe(Te, this.size + _.size);
      }
    }, {
      key: "cut",
      value: function(_) {
        var U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.size;
        if (_ == 0 && U == this.size) return this;
        var fe = [], Te = 0;
        if (U > _) for (var Be = 0, Je = 0; Je < U; Be++) {
          var Ct = this.content[Be], jt = Je + Ct.nodeSize;
          jt > _ && ((Je < _ || jt > U) && (Ct.isText ? Ct = Ct.cut(Math.max(0, _ - Je), Math.min(Ct.text.length, U - Je)) : Ct = Ct.cut(Math.max(0, _ - Je - 1), Math.min(Ct.content.size, U - Je - 1))), fe.push(Ct), Te += Ct.nodeSize), Je = jt;
        }
        return new xe(fe, Te);
      }
    }, {
      key: "cutByIndex",
      value: function(_, U) {
        return _ == U ? xe.empty : _ == 0 && U == this.content.length ? this : new xe(this.content.slice(_, U));
      }
    }, {
      key: "replaceChild",
      value: function(_, U) {
        var fe = this.content[_];
        if (fe == U) return this;
        var Te = this.content.slice(), Be = this.size + U.nodeSize - fe.nodeSize;
        return Te[_] = U, new xe(Te, Be);
      }
    }, {
      key: "addToStart",
      value: function(_) {
        return new xe([_].concat(this.content), this.size + _.nodeSize);
      }
    }, {
      key: "addToEnd",
      value: function(_) {
        return new xe(this.content.concat(_), this.size + _.nodeSize);
      }
    }, {
      key: "eq",
      value: function(_) {
        if (this.content.length != _.content.length) return !1;
        for (var U = 0; U < this.content.length; U++)
          if (!this.content[U].eq(_.content[U])) return !1;
        return !0;
      }
    }, {
      key: "firstChild",
      get: function() {
        return this.content.length ? this.content[0] : null;
      }
    }, {
      key: "lastChild",
      get: function() {
        return this.content.length ? this.content[this.content.length - 1] : null;
      }
    }, {
      key: "childCount",
      get: function() {
        return this.content.length;
      }
    }, {
      key: "child",
      value: function(_) {
        var U = this.content[_];
        if (!U) throw new RangeError("Index " + _ + " out of range for " + this);
        return U;
      }
    }, {
      key: "maybeChild",
      value: function(_) {
        return this.content[_] || null;
      }
    }, {
      key: "forEach",
      value: function(_) {
        for (var U = 0, fe = 0; U < this.content.length; U++) {
          var Te = this.content[U];
          _(Te, fe, U), fe += Te.nodeSize;
        }
      }
    }, {
      key: "findDiffStart",
      value: function(_) {
        var U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return de(this, _, U);
      }
    }, {
      key: "findDiffEnd",
      value: function(_) {
        var U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.size, fe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _.size;
        return Ce(this, _, U, fe);
      }
    }, {
      key: "findIndex",
      value: function(_) {
        var U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
        if (_ == 0) return ge(0, _);
        if (_ == this.size) return ge(this.content.length, _);
        if (_ > this.size || _ < 0) throw new RangeError("Position ".concat(_, " outside of fragment (").concat(this, ")"));
        for (var fe = 0, Te = 0; ; fe++) {
          var Be = this.child(fe), Je = Te + Be.nodeSize;
          if (Je >= _)
            return Je == _ || U > 0 ? ge(fe + 1, Je) : ge(fe, Te);
          Te = Je;
        }
      }
    }, {
      key: "toString",
      value: function() {
        return "<" + this.toStringInner() + ">";
      }
    }, {
      key: "toStringInner",
      value: function() {
        return this.content.join(", ");
      }
    }, {
      key: "toJSON",
      value: function() {
        return this.content.length ? this.content.map(function(_) {
          return _.toJSON();
        }) : null;
      }
    }], [{
      key: "fromJSON",
      value: function(_, U) {
        if (!U) return xe.empty;
        if (!Array.isArray(U)) throw new RangeError("Invalid input for Fragment.fromJSON");
        return new xe(U.map(_.nodeFromJSON));
      }
    }, {
      key: "fromArray",
      value: function(_) {
        if (!_.length) return xe.empty;
        for (var U, fe = 0, Te = 0; Te < _.length; Te++) {
          var Be = _[Te];
          fe += Be.nodeSize, Te && Be.isText && _[Te - 1].sameMarkup(Be) ? (U || (U = _.slice(0, Te)), U[U.length - 1] = Be.withText(U[U.length - 1].text + Be.text)) : U && U.push(Be);
        }
        return new xe(U || _, fe);
      }
    }, {
      key: "from",
      value: function(_) {
        if (!_) return xe.empty;
        if (_ instanceof xe) return _;
        if (Array.isArray(_)) return this.fromArray(_);
        if (_.attrs) return new xe([_], _.nodeSize);
        throw new RangeError("Can not convert " + _ + " to a Fragment" + (_.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
      }
    }]), xe;
  }();
  he.empty = new he([], 0);
  var oe = {
    index: 0,
    offset: 0
  };
  function ge(xe, ae) {
    return oe.index = xe, oe.offset = ae, oe;
  }
  function we(xe, ae) {
    if (xe === ae) return !0;
    if (!(xe && ie(xe) == "object") || !(ae && ie(ae) == "object")) return !1;
    var _ = Array.isArray(xe);
    if (Array.isArray(ae) != _) return !1;
    if (_) {
      if (xe.length != ae.length) return !1;
      for (var U = 0; U < xe.length; U++)
        if (!we(xe[U], ae[U])) return !1;
    } else {
      for (var fe in xe)
        if (!(fe in ae) || !we(xe[fe], ae[fe])) return !1;
      for (var Te in ae)
        if (!(Te in xe)) return !1;
    }
    return !0;
  }
  var Oe = function() {
    function xe(ae, _) {
      j(this, xe), this.type = ae, this.attrs = _;
    }
    return J(xe, [{
      key: "addToSet",
      value: function(_) {
        for (var U, fe = !1, Te = 0; Te < _.length; Te++) {
          var Be = _[Te];
          if (this.eq(Be)) return _;
          if (this.type.excludes(Be.type))
            U || (U = _.slice(0, Te));
          else {
            if (Be.type.excludes(this.type))
              return _;
            !fe && Be.type.rank > this.type.rank && (U || (U = _.slice(0, Te)), U.push(this), fe = !0), U && U.push(Be);
          }
        }
        return U || (U = _.slice()), fe || U.push(this), U;
      }
    }, {
      key: "removeFromSet",
      value: function(_) {
        for (var U = 0; U < _.length; U++)
          if (this.eq(_[U])) return _.slice(0, U).concat(_.slice(U + 1));
        return _;
      }
    }, {
      key: "isInSet",
      value: function(_) {
        for (var U = 0; U < _.length; U++)
          if (this.eq(_[U])) return !0;
        return !1;
      }
    }, {
      key: "eq",
      value: function(_) {
        return this == _ || this.type == _.type && we(this.attrs, _.attrs);
      }
    }, {
      key: "toJSON",
      value: function() {
        var _ = {
          type: this.type.name
        };
        for (var U in this.attrs) {
          _.attrs = this.attrs;
          break;
        }
        return _;
      }
    }], [{
      key: "fromJSON",
      value: function(_, U) {
        if (!U) throw new RangeError("Invalid input for Mark.fromJSON");
        var fe = _.marks[U.type];
        if (!fe) throw new RangeError("There is no mark type ".concat(U.type, " in this schema"));
        return fe.create(U.attrs);
      }
    }, {
      key: "sameSet",
      value: function(_, U) {
        if (_ == U) return !0;
        if (_.length != U.length) return !1;
        for (var fe = 0; fe < _.length; fe++)
          if (!_[fe].eq(U[fe])) return !1;
        return !0;
      }
    }, {
      key: "setFrom",
      value: function(_) {
        if (!_ || Array.isArray(_) && _.length == 0) return xe.none;
        if (_ instanceof xe) return [_];
        var U = _.slice();
        return U.sort(function(fe, Te) {
          return fe.type.rank - Te.type.rank;
        }), U;
      }
    }]), xe;
  }();
  Oe.none = [];
  var Qe = function(xe) {
    d(_, xe);
    var ae = m(_);
    function _() {
      return j(this, _), ae.apply(this, arguments);
    }
    return J(_);
  }(x(Error)), Me = function() {
    function xe(ae, _, U) {
      j(this, xe), this.content = ae, this.openStart = _, this.openEnd = U;
    }
    return J(xe, [{
      key: "size",
      get: function() {
        return this.content.size - this.openStart - this.openEnd;
      }
    }, {
      key: "insertAt",
      value: function(_, U) {
        var fe = rt(this.content, _ + this.openStart, U);
        return fe && new xe(fe, this.openStart, this.openEnd);
      }
    }, {
      key: "removeBetween",
      value: function(_, U) {
        return new xe(Ie(this.content, _ + this.openStart, U + this.openStart), this.openStart, this.openEnd);
      }
    }, {
      key: "eq",
      value: function(_) {
        return this.content.eq(_.content) && this.openStart == _.openStart && this.openEnd == _.openEnd;
      }
    }, {
      key: "toString",
      value: function() {
        return this.content + "(" + this.openStart + "," + this.openEnd + ")";
      }
    }, {
      key: "toJSON",
      value: function() {
        if (!this.content.size) return null;
        var _ = {
          content: this.content.toJSON()
        };
        return this.openStart > 0 && (_.openStart = this.openStart), this.openEnd > 0 && (_.openEnd = this.openEnd), _;
      }
    }], [{
      key: "fromJSON",
      value: function(_, U) {
        if (!U) return xe.empty;
        var fe = U.openStart || 0, Te = U.openEnd || 0;
        if (typeof fe != "number" || typeof Te != "number") throw new RangeError("Invalid input for Slice.fromJSON");
        return new xe(he.fromJSON(_, U.content), fe, Te);
      }
    }, {
      key: "maxOpen",
      value: function(_) {
        for (var U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, fe = 0, Te = 0, Be = _.firstChild; Be && !Be.isLeaf && (U || !Be.type.spec.isolating); Be = Be.firstChild)
          fe++;
        for (var Je = _.lastChild; Je && !Je.isLeaf && (U || !Je.type.spec.isolating); Je = Je.lastChild)
          Te++;
        return new xe(_, fe, Te);
      }
    }]), xe;
  }();
  Me.empty = new Me(he.empty, 0, 0);
  function Ie(xe, ae, _) {
    var U = xe.findIndex(ae), fe = U.index, Te = U.offset, Be = xe.maybeChild(fe), Je = xe.findIndex(_), Ct = Je.index, jt = Je.offset;
    if (Te == ae || Be.isText) {
      if (jt != _ && !xe.child(Ct).isText) throw new RangeError("Removing non-flat range");
      return xe.cut(0, ae).append(xe.cut(_));
    }
    if (fe != Ct) throw new RangeError("Removing non-flat range");
    return xe.replaceChild(fe, Be.copy(Ie(Be.content, ae - Te - 1, _ - Te - 1)));
  }
  function rt(xe, ae, _, U) {
    var fe = xe.findIndex(ae), Te = fe.index, Be = fe.offset, Je = xe.maybeChild(Te);
    if (Be == ae || Je.isText)
      return xe.cut(0, ae).append(_).append(xe.cut(ae));
    var Ct = rt(Je.content, ae - Be - 1, _);
    return Ct && xe.replaceChild(Te, Je.copy(Ct));
  }
  function ot(xe, ae, _) {
    if (_.openStart > xe.depth) throw new Qe("Inserted content deeper than insertion position");
    if (xe.depth - _.openStart != ae.depth - _.openEnd) throw new Qe("Inconsistent open depths");
    return Et(xe, ae, _, 0);
  }
  function Et(xe, ae, _, U) {
    var fe = xe.index(U), Te = xe.node(U);
    if (fe == ae.index(U) && U < xe.depth - _.openStart) {
      var Be = Et(xe, ae, _, U + 1);
      return Te.copy(Te.content.replaceChild(fe, Be));
    } else if (_.content.size)
      if (!_.openStart && !_.openEnd && xe.depth == U && ae.depth == U) {
        var Je = xe.parent, Ct = Je.content;
        return Ve(Je, Ct.cut(0, xe.parentOffset).append(_.content).append(Ct.cut(ae.parentOffset)));
      } else {
        var jt = We(_, xe), tr = jt.start, Kt = jt.end;
        return Ve(Te, Ue(xe, tr, Kt, ae, U));
      }
    else return Ve(Te, He(xe, ae, U));
  }
  function gt(xe, ae) {
    if (!ae.type.compatibleContent(xe.type)) throw new Qe("Cannot join " + ae.type.name + " onto " + xe.type.name);
  }
  function At(xe, ae, _) {
    var U = xe.node(_);
    return gt(U, ae.node(_)), U;
  }
  function Mt(xe, ae) {
    var _ = ae.length - 1;
    _ >= 0 && xe.isText && xe.sameMarkup(ae[_]) ? ae[_] = xe.withText(ae[_].text + xe.text) : ae.push(xe);
  }
  function St(xe, ae, _, U) {
    var fe = (ae || xe).node(_), Te = 0, Be = ae ? ae.index(_) : fe.childCount;
    xe && (Te = xe.index(_), xe.depth > _ ? Te++ : xe.textOffset && (Mt(xe.nodeAfter, U), Te++));
    for (var Je = Te; Je < Be; Je++)
      Mt(fe.child(Je), U);
    ae && ae.depth == _ && ae.textOffset && Mt(ae.nodeBefore, U);
  }
  function Ve(xe, ae) {
    return xe.type.checkContent(ae), xe.copy(ae);
  }
  function Ue(xe, ae, _, U, fe) {
    var Te = xe.depth > fe && At(xe, ae, fe + 1), Be = U.depth > fe && At(_, U, fe + 1), Je = [];
    return St(null, xe, fe, Je), Te && Be && ae.index(fe) == _.index(fe) ? (gt(Te, Be), Mt(Ve(Te, Ue(xe, ae, _, U, fe + 1)), Je)) : (Te && Mt(Ve(Te, He(xe, ae, fe + 1)), Je), St(ae, _, fe, Je), Be && Mt(Ve(Be, He(_, U, fe + 1)), Je)), St(U, null, fe, Je), new he(Je);
  }
  function He(xe, ae, _) {
    var U = [];
    if (St(null, xe, _, U), xe.depth > _) {
      var fe = At(xe, ae, _ + 1);
      Mt(Ve(fe, He(xe, ae, _ + 1)), U);
    }
    return St(ae, null, _, U), new he(U);
  }
  function We(xe, ae) {
    for (var _ = ae.depth - xe.openStart, U = ae.node(_), fe = U.copy(xe.content), Te = _ - 1; Te >= 0; Te--)
      fe = ae.node(Te).copy(he.from(fe));
    return {
      start: fe.resolveNoCache(xe.openStart + _),
      end: fe.resolveNoCache(fe.content.size - xe.openEnd - _)
    };
  }
  var ze = function() {
    function xe(ae, _, U) {
      j(this, xe), this.pos = ae, this.path = _, this.parentOffset = U, this.depth = _.length / 3 - 1;
    }
    return J(xe, [{
      key: "resolveDepth",
      value: function(_) {
        return _ == null ? this.depth : _ < 0 ? this.depth + _ : _;
      }
    }, {
      key: "parent",
      get: function() {
        return this.node(this.depth);
      }
    }, {
      key: "doc",
      get: function() {
        return this.node(0);
      }
    }, {
      key: "node",
      value: function(_) {
        return this.path[this.resolveDepth(_) * 3];
      }
    }, {
      key: "index",
      value: function(_) {
        return this.path[this.resolveDepth(_) * 3 + 1];
      }
    }, {
      key: "indexAfter",
      value: function(_) {
        return _ = this.resolveDepth(_), this.index(_) + (_ == this.depth && !this.textOffset ? 0 : 1);
      }
    }, {
      key: "start",
      value: function(_) {
        return _ = this.resolveDepth(_), _ == 0 ? 0 : this.path[_ * 3 - 1] + 1;
      }
    }, {
      key: "end",
      value: function(_) {
        return _ = this.resolveDepth(_), this.start(_) + this.node(_).content.size;
      }
    }, {
      key: "before",
      value: function(_) {
        if (_ = this.resolveDepth(_), !_) throw new RangeError("There is no position before the top-level node");
        return _ == this.depth + 1 ? this.pos : this.path[_ * 3 - 1];
      }
    }, {
      key: "after",
      value: function(_) {
        if (_ = this.resolveDepth(_), !_) throw new RangeError("There is no position after the top-level node");
        return _ == this.depth + 1 ? this.pos : this.path[_ * 3 - 1] + this.path[_ * 3].nodeSize;
      }
    }, {
      key: "textOffset",
      get: function() {
        return this.pos - this.path[this.path.length - 1];
      }
    }, {
      key: "nodeAfter",
      get: function() {
        var _ = this.parent, U = this.index(this.depth);
        if (U == _.childCount) return null;
        var fe = this.pos - this.path[this.path.length - 1], Te = _.child(U);
        return fe ? _.child(U).cut(fe) : Te;
      }
    }, {
      key: "nodeBefore",
      get: function() {
        var _ = this.index(this.depth), U = this.pos - this.path[this.path.length - 1];
        return U ? this.parent.child(_).cut(0, U) : _ == 0 ? null : this.parent.child(_ - 1);
      }
    }, {
      key: "posAtIndex",
      value: function(_, U) {
        U = this.resolveDepth(U);
        for (var fe = this.path[U * 3], Te = U == 0 ? 0 : this.path[U * 3 - 1] + 1, Be = 0; Be < _; Be++)
          Te += fe.child(Be).nodeSize;
        return Te;
      }
    }, {
      key: "marks",
      value: function() {
        var _ = this.parent, U = this.index();
        if (_.content.size == 0) return Oe.none;
        if (this.textOffset) return _.child(U).marks;
        var fe = _.maybeChild(U - 1), Te = _.maybeChild(U);
        if (!fe) {
          var Be = fe;
          fe = Te, Te = Be;
        }
        for (var Je = fe.marks, Ct = 0; Ct < Je.length; Ct++)
          Je[Ct].type.spec.inclusive === !1 && (!Te || !Je[Ct].isInSet(Te.marks)) && (Je = Je[Ct--].removeFromSet(Je));
        return Je;
      }
    }, {
      key: "marksAcross",
      value: function(_) {
        var U = this.parent.maybeChild(this.index());
        if (!U || !U.isInline) return null;
        for (var fe = U.marks, Te = _.parent.maybeChild(_.index()), Be = 0; Be < fe.length; Be++)
          fe[Be].type.spec.inclusive === !1 && (!Te || !fe[Be].isInSet(Te.marks)) && (fe = fe[Be--].removeFromSet(fe));
        return fe;
      }
    }, {
      key: "sharedDepth",
      value: function(_) {
        for (var U = this.depth; U > 0; U--)
          if (this.start(U) <= _ && this.end(U) >= _) return U;
        return 0;
      }
    }, {
      key: "blockRange",
      value: function() {
        var _ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this, U = arguments.length > 1 ? arguments[1] : void 0;
        if (_.pos < this.pos) return _.blockRange(this);
        for (var fe = this.depth - (this.parent.inlineContent || this.pos == _.pos ? 1 : 0); fe >= 0; fe--)
          if (_.pos <= this.end(fe) && (!U || U(this.node(fe)))) return new wt(this, _, fe);
        return null;
      }
    }, {
      key: "sameParent",
      value: function(_) {
        return this.pos - this.parentOffset == _.pos - _.parentOffset;
      }
    }, {
      key: "max",
      value: function(_) {
        return _.pos > this.pos ? _ : this;
      }
    }, {
      key: "min",
      value: function(_) {
        return _.pos < this.pos ? _ : this;
      }
    }, {
      key: "toString",
      value: function() {
        for (var _ = "", U = 1; U <= this.depth; U++)
          _ += (_ ? "/" : "") + this.node(U).type.name + "_" + this.index(U - 1);
        return _ + ":" + this.parentOffset;
      }
    }], [{
      key: "resolve",
      value: function(_, U) {
        if (!(U >= 0 && U <= _.content.size)) throw new RangeError("Position " + U + " out of range");
        for (var fe = [], Te = 0, Be = U, Je = _; ; ) {
          var Ct = Je.content.findIndex(Be), jt = Ct.index, tr = Ct.offset, Kt = Be - tr;
          if (fe.push(Je, jt, Te + tr), !Kt || (Je = Je.child(jt), Je.isText)) break;
          Be = Kt - 1, Te += tr + 1;
        }
        return new xe(U, fe, Be);
      }
    }, {
      key: "resolveCached",
      value: function(_, U) {
        for (var fe = 0; fe < at.length; fe++) {
          var Te = at[fe];
          if (Te.pos == U && Te.doc == _) return Te;
        }
        var Be = at[Ye] = xe.resolve(_, U);
        return Ye = (Ye + 1) % tt, Be;
      }
    }]), xe;
  }(), at = [], Ye = 0, tt = 12, wt = function() {
    function xe(ae, _, U) {
      j(this, xe), this.$from = ae, this.$to = _, this.depth = U;
    }
    return J(xe, [{
      key: "start",
      get: function() {
        return this.$from.before(this.depth + 1);
      }
    }, {
      key: "end",
      get: function() {
        return this.$to.after(this.depth + 1);
      }
    }, {
      key: "parent",
      get: function() {
        return this.$from.node(this.depth);
      }
    }, {
      key: "startIndex",
      get: function() {
        return this.$from.index(this.depth);
      }
    }, {
      key: "endIndex",
      get: function() {
        return this.$to.indexAfter(this.depth);
      }
    }]), xe;
  }(), Ft = /* @__PURE__ */ Object.create(null), qe = function() {
    function xe(ae, _, U) {
      var fe = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Oe.none;
      j(this, xe), this.type = ae, this.attrs = _, this.marks = fe, this.content = U || he.empty;
    }
    return J(xe, [{
      key: "nodeSize",
      get: function() {
        return this.isLeaf ? 1 : 2 + this.content.size;
      }
    }, {
      key: "childCount",
      get: function() {
        return this.content.childCount;
      }
    }, {
      key: "child",
      value: function(_) {
        return this.content.child(_);
      }
    }, {
      key: "maybeChild",
      value: function(_) {
        return this.content.maybeChild(_);
      }
    }, {
      key: "forEach",
      value: function(_) {
        this.content.forEach(_);
      }
    }, {
      key: "nodesBetween",
      value: function(_, U, fe) {
        var Te = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        this.content.nodesBetween(_, U, fe, Te, this);
      }
    }, {
      key: "descendants",
      value: function(_) {
        this.nodesBetween(0, this.content.size, _);
      }
    }, {
      key: "textContent",
      get: function() {
        return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
      }
    }, {
      key: "textBetween",
      value: function(_, U, fe, Te) {
        return this.content.textBetween(_, U, fe, Te);
      }
    }, {
      key: "firstChild",
      get: function() {
        return this.content.firstChild;
      }
    }, {
      key: "lastChild",
      get: function() {
        return this.content.lastChild;
      }
    }, {
      key: "eq",
      value: function(_) {
        return this == _ || this.sameMarkup(_) && this.content.eq(_.content);
      }
    }, {
      key: "sameMarkup",
      value: function(_) {
        return this.hasMarkup(_.type, _.attrs, _.marks);
      }
    }, {
      key: "hasMarkup",
      value: function(_, U, fe) {
        return this.type == _ && we(this.attrs, U || _.defaultAttrs || Ft) && Oe.sameSet(this.marks, fe || Oe.none);
      }
    }, {
      key: "copy",
      value: function() {
        var _ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        return _ == this.content ? this : new xe(this.type, this.attrs, _, this.marks);
      }
    }, {
      key: "mark",
      value: function(_) {
        return _ == this.marks ? this : new xe(this.type, this.attrs, this.content, _);
      }
    }, {
      key: "cut",
      value: function(_) {
        var U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.content.size;
        return _ == 0 && U == this.content.size ? this : this.copy(this.content.cut(_, U));
      }
    }, {
      key: "slice",
      value: function(_) {
        var U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.content.size, fe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
        if (_ == U) return Me.empty;
        var Te = this.resolve(_), Be = this.resolve(U), Je = fe ? 0 : Te.sharedDepth(U), Ct = Te.start(Je), jt = Te.node(Je), tr = jt.content.cut(Te.pos - Ct, Be.pos - Ct);
        return new Me(tr, Te.depth - Je, Be.depth - Je);
      }
    }, {
      key: "replace",
      value: function(_, U, fe) {
        return ot(this.resolve(_), this.resolve(U), fe);
      }
    }, {
      key: "nodeAt",
      value: function(_) {
        for (var U = this; ; ) {
          var fe = U.content.findIndex(_), Te = fe.index, Be = fe.offset;
          if (U = U.maybeChild(Te), !U) return null;
          if (Be == _ || U.isText) return U;
          _ -= Be + 1;
        }
      }
    }, {
      key: "childAfter",
      value: function(_) {
        var U = this.content.findIndex(_), fe = U.index, Te = U.offset;
        return {
          node: this.content.maybeChild(fe),
          index: fe,
          offset: Te
        };
      }
    }, {
      key: "childBefore",
      value: function(_) {
        if (_ == 0) return {
          node: null,
          index: 0,
          offset: 0
        };
        var U = this.content.findIndex(_), fe = U.index, Te = U.offset;
        if (Te < _) return {
          node: this.content.child(fe),
          index: fe,
          offset: Te
        };
        var Be = this.content.child(fe - 1);
        return {
          node: Be,
          index: fe - 1,
          offset: Te - Be.nodeSize
        };
      }
    }, {
      key: "resolve",
      value: function(_) {
        return ze.resolveCached(this, _);
      }
    }, {
      key: "resolveNoCache",
      value: function(_) {
        return ze.resolve(this, _);
      }
    }, {
      key: "rangeHasMark",
      value: function(_, U, fe) {
        var Te = !1;
        return U > _ && this.nodesBetween(_, U, function(Be) {
          return fe.isInSet(Be.marks) && (Te = !0), !Te;
        }), Te;
      }
    }, {
      key: "isBlock",
      get: function() {
        return this.type.isBlock;
      }
    }, {
      key: "isTextblock",
      get: function() {
        return this.type.isTextblock;
      }
    }, {
      key: "inlineContent",
      get: function() {
        return this.type.inlineContent;
      }
    }, {
      key: "isInline",
      get: function() {
        return this.type.isInline;
      }
    }, {
      key: "isText",
      get: function() {
        return this.type.isText;
      }
    }, {
      key: "isLeaf",
      get: function() {
        return this.type.isLeaf;
      }
    }, {
      key: "isAtom",
      get: function() {
        return this.type.isAtom;
      }
    }, {
      key: "toString",
      value: function() {
        if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);
        var _ = this.type.name;
        return this.content.size && (_ += "(" + this.content.toStringInner() + ")"), _e(this.marks, _);
      }
    }, {
      key: "contentMatchAt",
      value: function(_) {
        var U = this.type.contentMatch.matchFragment(this.content, 0, _);
        if (!U) throw new Error("Called contentMatchAt on a node with invalid content");
        return U;
      }
    }, {
      key: "canReplace",
      value: function(_, U) {
        var fe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : he.empty, Te = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, Be = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : fe.childCount, Je = this.contentMatchAt(_).matchFragment(fe, Te, Be), Ct = Je && Je.matchFragment(this.content, U);
        if (!Ct || !Ct.validEnd) return !1;
        for (var jt = Te; jt < Be; jt++)
          if (!this.type.allowsMarks(fe.child(jt).marks)) return !1;
        return !0;
      }
    }, {
      key: "canReplaceWith",
      value: function(_, U, fe, Te) {
        if (Te && !this.type.allowsMarks(Te)) return !1;
        var Be = this.contentMatchAt(_).matchType(fe), Je = Be && Be.matchFragment(this.content, U);
        return Je ? Je.validEnd : !1;
      }
    }, {
      key: "canAppend",
      value: function(_) {
        return _.content.size ? this.canReplace(this.childCount, this.childCount, _.content) : this.type.compatibleContent(_.type);
      }
    }, {
      key: "check",
      value: function() {
        this.type.checkContent(this.content);
        for (var _ = Oe.none, U = 0; U < this.marks.length; U++)
          _ = this.marks[U].addToSet(_);
        if (!Oe.sameSet(_, this.marks)) throw new RangeError("Invalid collection of marks for node ".concat(this.type.name, ": ").concat(this.marks.map(function(fe) {
          return fe.type.name;
        })));
        this.content.forEach(function(fe) {
          return fe.check();
        });
      }
    }, {
      key: "toJSON",
      value: function() {
        var _ = {
          type: this.type.name
        };
        for (var U in this.attrs) {
          _.attrs = this.attrs;
          break;
        }
        return this.content.size && (_.content = this.content.toJSON()), this.marks.length && (_.marks = this.marks.map(function(fe) {
          return fe.toJSON();
        })), _;
      }
    }], [{
      key: "fromJSON",
      value: function(_, U) {
        if (!U) throw new RangeError("Invalid input for Node.fromJSON");
        var fe = null;
        if (U.marks) {
          if (!Array.isArray(U.marks)) throw new RangeError("Invalid mark data for Node.fromJSON");
          fe = U.marks.map(_.markFromJSON);
        }
        if (U.type == "text") {
          if (typeof U.text != "string") throw new RangeError("Invalid text node in JSON");
          return _.text(U.text, fe);
        }
        var Te = he.fromJSON(_, U.content);
        return _.nodeType(U.type).create(U.attrs, Te, fe);
      }
    }]), xe;
  }();
  qe.prototype.text = void 0;
  var pe = function(xe) {
    d(_, xe);
    var ae = m(_);
    function _(U, fe, Te, Be) {
      var Je;
      if (j(this, _), Je = ae.call(this, U, fe, null, Be), !Te) throw new RangeError("Empty text nodes are not allowed");
      return Je.text = Te, Je;
    }
    return J(_, [{
      key: "toString",
      value: function() {
        return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : _e(this.marks, JSON.stringify(this.text));
      }
    }, {
      key: "textContent",
      get: function() {
        return this.text;
      }
    }, {
      key: "textBetween",
      value: function(fe, Te) {
        return this.text.slice(fe, Te);
      }
    }, {
      key: "nodeSize",
      get: function() {
        return this.text.length;
      }
    }, {
      key: "mark",
      value: function(fe) {
        return fe == this.marks ? this : new _(this.type, this.attrs, this.text, fe);
      }
    }, {
      key: "withText",
      value: function(fe) {
        return fe == this.text ? this : new _(this.type, this.attrs, fe, this.marks);
      }
    }, {
      key: "cut",
      value: function() {
        var fe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, Te = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.text.length;
        return fe == 0 && Te == this.text.length ? this : this.withText(this.text.slice(fe, Te));
      }
    }, {
      key: "eq",
      value: function(fe) {
        return this.sameMarkup(fe) && this.text == fe.text;
      }
    }, {
      key: "toJSON",
      value: function() {
        var fe = f(L(_.prototype), "toJSON", this).call(this);
        return fe.text = this.text, fe;
      }
    }]), _;
  }(qe);
  function _e(xe, ae) {
    for (var _ = xe.length - 1; _ >= 0; _--)
      ae = xe[_].type.name + "(" + ae + ")";
    return ae;
  }
  var Xe = function() {
    function xe(ae) {
      j(this, xe), this.validEnd = ae, this.next = [], this.wrapCache = [];
    }
    return J(xe, [{
      key: "matchType",
      value: function(_) {
        for (var U = 0; U < this.next.length; U++)
          if (this.next[U].type == _) return this.next[U].next;
        return null;
      }
    }, {
      key: "matchFragment",
      value: function(_) {
        for (var U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, fe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _.childCount, Te = this, Be = U; Te && Be < fe; Be++)
          Te = Te.matchType(_.child(Be).type);
        return Te;
      }
    }, {
      key: "inlineContent",
      get: function() {
        return this.next.length != 0 && this.next[0].type.isInline;
      }
    }, {
      key: "defaultType",
      get: function() {
        for (var _ = 0; _ < this.next.length; _++) {
          var U = this.next[_].type;
          if (!(U.isText || U.hasRequiredAttrs())) return U;
        }
        return null;
      }
    }, {
      key: "compatible",
      value: function(_) {
        for (var U = 0; U < this.next.length; U++)
          for (var fe = 0; fe < _.next.length; fe++)
            if (this.next[U].type == _.next[fe].type) return !0;
        return !1;
      }
    }, {
      key: "fillBefore",
      value: function(_) {
        var U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, fe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, Te = [this];
        function Be(Je, Ct) {
          var jt = Je.matchFragment(_, fe);
          if (jt && (!U || jt.validEnd)) return he.from(Ct.map(function(cr) {
            return cr.createAndFill();
          }));
          for (var tr = 0; tr < Je.next.length; tr++) {
            var Kt = Je.next[tr], rr = Kt.type, kr = Kt.next;
            if (!(rr.isText || rr.hasRequiredAttrs()) && Te.indexOf(kr) == -1) {
              Te.push(kr);
              var on = Be(kr, Ct.concat(rr));
              if (on) return on;
            }
          }
          return null;
        }
        return Be(this, []);
      }
    }, {
      key: "findWrapping",
      value: function(_) {
        for (var U = 0; U < this.wrapCache.length; U += 2)
          if (this.wrapCache[U] == _) return this.wrapCache[U + 1];
        var fe = this.computeWrapping(_);
        return this.wrapCache.push(_, fe), fe;
      }
    }, {
      key: "computeWrapping",
      value: function(_) {
        for (var U = /* @__PURE__ */ Object.create(null), fe = [{
          match: this,
          type: null,
          via: null
        }]; fe.length; ) {
          var Te = fe.shift(), Be = Te.match;
          if (Be.matchType(_)) {
            for (var Je = [], Ct = Te; Ct.type; Ct = Ct.via)
              Je.push(Ct.type);
            return Je.reverse();
          }
          for (var jt = 0; jt < Be.next.length; jt++) {
            var tr = Be.next[jt], Kt = tr.type, rr = tr.next;
            !Kt.isLeaf && !Kt.hasRequiredAttrs() && !(Kt.name in U) && (!Te.type || rr.validEnd) && (fe.push({
              match: Kt.contentMatch,
              type: Kt,
              via: Te
            }), U[Kt.name] = !0);
          }
        }
        return null;
      }
    }, {
      key: "edgeCount",
      get: function() {
        return this.next.length;
      }
    }, {
      key: "edge",
      value: function(_) {
        if (_ >= this.next.length) throw new RangeError("There's no ".concat(_, "th edge in this content match"));
        return this.next[_];
      }
    }, {
      key: "toString",
      value: function() {
        var _ = [];
        function U(fe) {
          _.push(fe);
          for (var Te = 0; Te < fe.next.length; Te++)
            _.indexOf(fe.next[Te].next) == -1 && U(fe.next[Te].next);
        }
        return U(this), _.map(function(fe, Te) {
          for (var Be = Te + (fe.validEnd ? "*" : " ") + " ", Je = 0; Je < fe.next.length; Je++)
            Be += (Je ? ", " : "") + fe.next[Je].type.name + "->" + _.indexOf(fe.next[Je].next);
          return Be;
        }).join(`
`);
      }
    }], [{
      key: "parse",
      value: function(_, U) {
        var fe = new lt(_, U);
        if (fe.next == null) return xe.empty;
        var Te = Q(fe);
        fe.next && fe.err("Unexpected trailing text");
        var Be = yt(ve(Te));
        return $t(Be, fe), Be;
      }
    }]), xe;
  }();
  Xe.empty = new Xe(!0);
  var lt = function() {
    function xe(ae, _) {
      j(this, xe), this.string = ae, this.nodeTypes = _, this.inline = null, this.pos = 0, this.tokens = ae.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
    }
    return J(xe, [{
      key: "next",
      get: function() {
        return this.tokens[this.pos];
      }
    }, {
      key: "eat",
      value: function(_) {
        return this.next == _ && (this.pos++ || !0);
      }
    }, {
      key: "err",
      value: function(_) {
        throw new SyntaxError(_ + " (in content expression '" + this.string + "')");
      }
    }]), xe;
  }();
  function Q(xe) {
    var ae = [];
    do
      ae.push(te(xe));
    while (xe.eat("|"));
    return ae.length == 1 ? ae[0] : {
      type: "choice",
      exprs: ae
    };
  }
  function te(xe) {
    var ae = [];
    do
      ae.push(De(xe));
    while (xe.next && xe.next != ")" && xe.next != "|");
    return ae.length == 1 ? ae[0] : {
      type: "seq",
      exprs: ae
    };
  }
  function De(xe) {
    for (var ae = V(xe); ; )
      if (xe.eat("+")) ae = {
        type: "plus",
        expr: ae
      };
      else if (xe.eat("*")) ae = {
        type: "star",
        expr: ae
      };
      else if (xe.eat("?")) ae = {
        type: "opt",
        expr: ae
      };
      else if (xe.eat("{")) ae = be(xe, ae);
      else break;
    return ae;
  }
  function nt(xe) {
    /\D/.test(xe.next) && xe.err("Expected number, got '" + xe.next + "'");
    var ae = Number(xe.next);
    return xe.pos++, ae;
  }
  function be(xe, ae) {
    var _ = nt(xe), U = _;
    return xe.eat(",") && (xe.next != "}" ? U = nt(xe) : U = -1), xe.eat("}") || xe.err("Unclosed braced range"), {
      type: "range",
      min: _,
      max: U,
      expr: ae
    };
  }
  function G(xe, ae) {
    var _ = xe.nodeTypes, U = _[ae];
    if (U) return [U];
    var fe = [];
    for (var Te in _) {
      var Be = _[Te];
      Be.groups.indexOf(ae) > -1 && fe.push(Be);
    }
    return fe.length == 0 && xe.err("No node type or group '" + ae + "' found"), fe;
  }
  function V(xe) {
    if (xe.eat("(")) {
      var ae = Q(xe);
      return xe.eat(")") || xe.err("Missing closing paren"), ae;
    } else if (/\W/.test(xe.next))
      xe.err("Unexpected token '" + xe.next + "'");
    else {
      var _ = G(xe, xe.next).map(function(U) {
        return xe.inline == null ? xe.inline = U.isInline : xe.inline != U.isInline && xe.err("Mixing inline and block content"), {
          type: "name",
          value: U
        };
      });
      return xe.pos++, _.length == 1 ? _[0] : {
        type: "choice",
        exprs: _
      };
    }
  }
  function ve(xe) {
    var ae = [[]];
    return fe(Te(xe, 0), _()), ae;
    function _() {
      return ae.push([]) - 1;
    }
    function U(Be, Je, Ct) {
      var jt = {
        term: Ct,
        to: Je
      };
      return ae[Be].push(jt), jt;
    }
    function fe(Be, Je) {
      Be.forEach(function(Ct) {
        return Ct.to = Je;
      });
    }
    function Te(Be, Je) {
      if (Be.type == "choice")
        return Be.exprs.reduce(function(ei, bi) {
          return ei.concat(Te(bi, Je));
        }, []);
      if (Be.type == "seq")
        for (var Ct = 0; ; Ct++) {
          var jt = Te(Be.exprs[Ct], Je);
          if (Ct == Be.exprs.length - 1) return jt;
          fe(jt, Je = _());
        }
      else if (Be.type == "star") {
        var tr = _();
        return U(Je, tr), fe(Te(Be.expr, tr), tr), [U(tr)];
      } else if (Be.type == "plus") {
        var Kt = _();
        return fe(Te(Be.expr, Je), Kt), fe(Te(Be.expr, Kt), Kt), [U(Kt)];
      } else {
        if (Be.type == "opt")
          return [U(Je)].concat(Te(Be.expr, Je));
        if (Be.type == "range") {
          for (var rr = Je, kr = 0; kr < Be.min; kr++) {
            var on = _();
            fe(Te(Be.expr, rr), on), rr = on;
          }
          if (Be.max == -1)
            fe(Te(Be.expr, rr), rr);
          else
            for (var cr = Be.min; cr < Be.max; cr++) {
              var An = _();
              U(rr, An), fe(Te(Be.expr, rr), An), rr = An;
            }
          return [U(rr)];
        } else {
          if (Be.type == "name")
            return [U(Je, void 0, Be.value)];
          throw new Error("Unknown expr type");
        }
      }
    }
  }
  function Ne(xe, ae) {
    return ae - xe;
  }
  function it(xe, ae) {
    var _ = [];
    return U(ae), _.sort(Ne);
    function U(fe) {
      var Te = xe[fe];
      if (Te.length == 1 && !Te[0].term) return U(Te[0].to);
      _.push(fe);
      for (var Be = 0; Be < Te.length; Be++) {
        var Je = Te[Be], Ct = Je.term, jt = Je.to;
        !Ct && _.indexOf(jt) == -1 && U(jt);
      }
    }
  }
  function yt(xe) {
    var ae = /* @__PURE__ */ Object.create(null);
    return _(it(xe, 0));
    function _(U) {
      var fe = [];
      U.forEach(function(Ct) {
        xe[Ct].forEach(function(jt) {
          var tr = jt.term, Kt = jt.to;
          if (tr) {
            for (var rr, kr = 0; kr < fe.length; kr++)
              fe[kr][0] == tr && (rr = fe[kr][1]);
            it(xe, Kt).forEach(function(on) {
              rr || fe.push([tr, rr = []]), rr.indexOf(on) == -1 && rr.push(on);
            });
          }
        });
      });
      for (var Te = ae[U.join(",")] = new Xe(U.indexOf(xe.length - 1) > -1), Be = 0; Be < fe.length; Be++) {
        var Je = fe[Be][1].sort(Ne);
        Te.next.push({
          type: fe[Be][0],
          next: ae[Je.join(",")] || _(Je)
        });
      }
      return Te;
    }
  }
  function $t(xe, ae) {
    for (var _ = 0, U = [xe]; _ < U.length; _++) {
      for (var fe = U[_], Te = !fe.validEnd, Be = [], Je = 0; Je < fe.next.length; Je++) {
        var Ct = fe.next[Je], jt = Ct.type, tr = Ct.next;
        Be.push(jt.name), Te && !(jt.isText || jt.hasRequiredAttrs()) && (Te = !1), U.indexOf(tr) == -1 && U.push(tr);
      }
      Te && ae.err("Only non-generatable nodes (" + Be.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
    }
  }
  function Gt(xe) {
    var ae = /* @__PURE__ */ Object.create(null);
    for (var _ in xe) {
      var U = xe[_];
      if (!U.hasDefault) return null;
      ae[_] = U.default;
    }
    return ae;
  }
  function Jt(xe, ae) {
    var _ = /* @__PURE__ */ Object.create(null);
    for (var U in xe) {
      var fe = ae && ae[U];
      if (fe === void 0) {
        var Te = xe[U];
        if (Te.hasDefault) fe = Te.default;
        else throw new RangeError("No value supplied for attribute " + U);
      }
      _[U] = fe;
    }
    return _;
  }
  function Xt(xe) {
    var ae = /* @__PURE__ */ Object.create(null);
    if (xe) for (var _ in xe)
      ae[_] = new vt(xe[_]);
    return ae;
  }
  var Ae = function() {
    function xe(ae, _, U) {
      j(this, xe), this.name = ae, this.schema = _, this.spec = U, this.markSet = null, this.groups = U.group ? U.group.split(" ") : [], this.attrs = Xt(U.attrs), this.defaultAttrs = Gt(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(U.inline || ae == "text"), this.isText = ae == "text";
    }
    return J(xe, [{
      key: "isInline",
      get: function() {
        return !this.isBlock;
      }
    }, {
      key: "isTextblock",
      get: function() {
        return this.isBlock && this.inlineContent;
      }
    }, {
      key: "isLeaf",
      get: function() {
        return this.contentMatch == Xe.empty;
      }
    }, {
      key: "isAtom",
      get: function() {
        return this.isLeaf || !!this.spec.atom;
      }
    }, {
      key: "whitespace",
      get: function() {
        return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
      }
    }, {
      key: "hasRequiredAttrs",
      value: function() {
        for (var _ in this.attrs)
          if (this.attrs[_].isRequired) return !0;
        return !1;
      }
    }, {
      key: "compatibleContent",
      value: function(_) {
        return this == _ || this.contentMatch.compatible(_.contentMatch);
      }
    }, {
      key: "computeAttrs",
      value: function(_) {
        return !_ && this.defaultAttrs ? this.defaultAttrs : Jt(this.attrs, _);
      }
    }, {
      key: "create",
      value: function() {
        var _ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, U = arguments.length > 1 ? arguments[1] : void 0, fe = arguments.length > 2 ? arguments[2] : void 0;
        if (this.isText) throw new Error("NodeType.create can't construct text nodes");
        return new qe(this, this.computeAttrs(_), he.from(U), Oe.setFrom(fe));
      }
    }, {
      key: "createChecked",
      value: function() {
        var _ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, U = arguments.length > 1 ? arguments[1] : void 0, fe = arguments.length > 2 ? arguments[2] : void 0;
        return U = he.from(U), this.checkContent(U), new qe(this, this.computeAttrs(_), U, Oe.setFrom(fe));
      }
    }, {
      key: "createAndFill",
      value: function() {
        var _ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, U = arguments.length > 1 ? arguments[1] : void 0, fe = arguments.length > 2 ? arguments[2] : void 0;
        if (_ = this.computeAttrs(_), U = he.from(U), U.size) {
          var Te = this.contentMatch.fillBefore(U);
          if (!Te) return null;
          U = Te.append(U);
        }
        var Be = this.contentMatch.matchFragment(U), Je = Be && Be.fillBefore(he.empty, !0);
        return Je ? new qe(this, _, U.append(Je), Oe.setFrom(fe)) : null;
      }
    }, {
      key: "validContent",
      value: function(_) {
        var U = this.contentMatch.matchFragment(_);
        if (!U || !U.validEnd) return !1;
        for (var fe = 0; fe < _.childCount; fe++)
          if (!this.allowsMarks(_.child(fe).marks)) return !1;
        return !0;
      }
    }, {
      key: "checkContent",
      value: function(_) {
        if (!this.validContent(_)) throw new RangeError("Invalid content for node ".concat(this.name, ": ").concat(_.toString().slice(0, 50)));
      }
    }, {
      key: "allowsMarkType",
      value: function(_) {
        return this.markSet == null || this.markSet.indexOf(_) > -1;
      }
    }, {
      key: "allowsMarks",
      value: function(_) {
        if (this.markSet == null) return !0;
        for (var U = 0; U < _.length; U++)
          if (!this.allowsMarkType(_[U].type)) return !1;
        return !0;
      }
    }, {
      key: "allowedMarks",
      value: function(_) {
        if (this.markSet == null) return _;
        for (var U, fe = 0; fe < _.length; fe++)
          this.allowsMarkType(_[fe].type) ? U && U.push(_[fe]) : U || (U = _.slice(0, fe));
        return U ? U.length ? U : Oe.none : _;
      }
    }], [{
      key: "compile",
      value: function(_, U) {
        var fe = /* @__PURE__ */ Object.create(null);
        _.forEach(function(Je, Ct) {
          return fe[Je] = new xe(Je, U, Ct);
        });
        var Te = U.spec.topNode || "doc";
        if (!fe[Te]) throw new RangeError("Schema is missing its top node type ('" + Te + "')");
        if (!fe.text) throw new RangeError("Every schema needs a 'text' type");
        for (var Be in fe.text.attrs)
          throw new RangeError("The text node type should not have attributes");
        return fe;
      }
    }]), xe;
  }(), vt = function() {
    function xe(ae) {
      j(this, xe), this.hasDefault = Object.prototype.hasOwnProperty.call(ae, "default"), this.default = ae.default;
    }
    return J(xe, [{
      key: "isRequired",
      get: function() {
        return !this.hasDefault;
      }
    }]), xe;
  }(), Ot = function() {
    function xe(ae, _, U, fe) {
      j(this, xe), this.name = ae, this.rank = _, this.schema = U, this.spec = fe, this.attrs = Xt(fe.attrs), this.excluded = null;
      var Te = Gt(this.attrs);
      this.instance = Te ? new Oe(this, Te) : null;
    }
    return J(xe, [{
      key: "create",
      value: function() {
        var _ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
        return !_ && this.instance ? this.instance : new Oe(this, Jt(this.attrs, _));
      }
    }, {
      key: "removeFromSet",
      value: function(_) {
        for (var U = 0; U < _.length; U++)
          _[U].type == this && (_ = _.slice(0, U).concat(_.slice(U + 1)), U--);
        return _;
      }
    }, {
      key: "isInSet",
      value: function(_) {
        for (var U = 0; U < _.length; U++)
          if (_[U].type == this) return _[U];
      }
    }, {
      key: "excludes",
      value: function(_) {
        return this.excluded.indexOf(_) > -1;
      }
    }], [{
      key: "compile",
      value: function(_, U) {
        var fe = /* @__PURE__ */ Object.create(null), Te = 0;
        return _.forEach(function(Be, Je) {
          return fe[Be] = new xe(Be, Te++, U, Je);
        }), fe;
      }
    }]), xe;
  }(), Vt = function() {
    function xe(ae) {
      j(this, xe), this.cached = /* @__PURE__ */ Object.create(null);
      var _ = this.spec = {};
      for (var U in ae)
        _[U] = ae[U];
      _.nodes = ee.default.from(ae.nodes), _.marks = ee.default.from(ae.marks || {}), this.nodes = Ae.compile(this.spec.nodes, this), this.marks = Ot.compile(this.spec.marks, this);
      var fe = /* @__PURE__ */ Object.create(null);
      for (var Te in this.nodes) {
        if (Te in this.marks) throw new RangeError(Te + " can not be both a node and a mark");
        var Be = this.nodes[Te], Je = Be.spec.content || "", Ct = Be.spec.marks;
        Be.contentMatch = fe[Je] || (fe[Je] = Xe.parse(Je, this.nodes)), Be.inlineContent = Be.contentMatch.inlineContent, Be.markSet = Ct == "_" ? null : Ct ? et(this, Ct.split(" ")) : Ct == "" || !Be.inlineContent ? [] : null;
      }
      for (var jt in this.marks) {
        var tr = this.marks[jt], Kt = tr.spec.excludes;
        tr.excluded = Kt == null ? [tr] : Kt == "" ? [] : et(this, Kt.split(" "));
      }
      this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
    }
    return J(xe, [{
      key: "node",
      value: function(_) {
        var U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, fe = arguments.length > 2 ? arguments[2] : void 0, Te = arguments.length > 3 ? arguments[3] : void 0;
        if (typeof _ == "string") _ = this.nodeType(_);
        else if (_ instanceof Ae) {
          if (_.schema != this) throw new RangeError("Node type from different schema used (" + _.name + ")");
        } else throw new RangeError("Invalid node type: " + _);
        return _.createChecked(U, fe, Te);
      }
    }, {
      key: "text",
      value: function(_, U) {
        var fe = this.nodes.text;
        return new pe(fe, fe.defaultAttrs, _, Oe.setFrom(U));
      }
    }, {
      key: "mark",
      value: function(_, U) {
        return typeof _ == "string" && (_ = this.marks[_]), _.create(U);
      }
    }, {
      key: "nodeFromJSON",
      value: function(_) {
        return qe.fromJSON(this, _);
      }
    }, {
      key: "markFromJSON",
      value: function(_) {
        return Oe.fromJSON(this, _);
      }
    }, {
      key: "nodeType",
      value: function(_) {
        var U = this.nodes[_];
        if (!U) throw new RangeError("Unknown node type: " + _);
        return U;
      }
    }]), xe;
  }();
  function et(xe, ae) {
    for (var _ = [], U = 0; U < ae.length; U++) {
      var fe = ae[U], Te = xe.marks[fe], Be = Te;
      if (Te)
        _.push(Te);
      else
        for (var Je in xe.marks) {
          var Ct = xe.marks[Je];
          (fe == "_" || Ct.spec.group && Ct.spec.group.split(" ").indexOf(fe) > -1) && _.push(Be = Ct);
        }
      if (!Be) throw new SyntaxError("Unknown mark type: '" + ae[U] + "'");
    }
    return _;
  }
  var ft = function() {
    function xe(ae, _) {
      var U = this;
      j(this, xe), this.schema = ae, this.rules = _, this.tags = [], this.styles = [], _.forEach(function(fe) {
        fe.tag ? U.tags.push(fe) : fe.style && U.styles.push(fe);
      }), this.normalizeLists = !this.tags.some(function(fe) {
        if (!/^(ul|ol)\b/.test(fe.tag) || !fe.node) return !1;
        var Te = ae.nodes[fe.node];
        return Te.contentMatch.matchType(Te);
      });
    }
    return J(xe, [{
      key: "parse",
      value: function(_) {
        var U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, fe = new Ge(this, U, !1);
        return fe.addAll(_, U.from, U.to), fe.finish();
      }
    }, {
      key: "parseSlice",
      value: function(_) {
        var U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, fe = new Ge(this, U, !0);
        return fe.addAll(_, U.from, U.to), Me.maxOpen(fe.finish());
      }
    }, {
      key: "matchTag",
      value: function(_, U, fe) {
        for (var Te = fe ? this.tags.indexOf(fe) + 1 : 0; Te < this.tags.length; Te++) {
          var Be = this.tags[Te];
          if (xt(_, Be.tag) && (Be.namespace === void 0 || _.namespaceURI == Be.namespace) && (!Be.context || U.matchesContext(Be.context))) {
            if (Be.getAttrs) {
              var Je = Be.getAttrs(_);
              if (Je === !1) continue;
              Be.attrs = Je || void 0;
            }
            return Be;
          }
        }
      }
    }, {
      key: "matchStyle",
      value: function(_, U, fe, Te) {
        for (var Be = Te ? this.styles.indexOf(Te) + 1 : 0; Be < this.styles.length; Be++) {
          var Je = this.styles[Be], Ct = Je.style;
          if (!(Ct.indexOf(_) != 0 || Je.context && !fe.matchesContext(Je.context) || Ct.length > _.length && (Ct.charCodeAt(_.length) != 61 || Ct.slice(_.length + 1) != U))) {
            if (Je.getAttrs) {
              var jt = Je.getAttrs(U);
              if (jt === !1) continue;
              Je.attrs = jt || void 0;
            }
            return Je;
          }
        }
      }
    }], [{
      key: "schemaRules",
      value: function(_) {
        var U = [];
        function fe(jt) {
          for (var tr = jt.priority == null ? 50 : jt.priority, Kt = 0; Kt < U.length; Kt++) {
            var rr = U[Kt], kr = rr.priority == null ? 50 : rr.priority;
            if (kr < tr) break;
          }
          U.splice(Kt, 0, jt);
        }
        var Te = function(tr) {
          var Kt = _.marks[tr].spec.parseDOM;
          Kt && Kt.forEach(function(rr) {
            fe(rr = Yt(rr)), rr.mark || rr.ignore || rr.clearMark || (rr.mark = tr);
          });
        };
        for (var Be in _.marks)
          Te(Be);
        var Je = function(tr) {
          var Kt = _.nodes[tr].spec.parseDOM;
          Kt && Kt.forEach(function(rr) {
            fe(rr = Yt(rr)), rr.node || rr.ignore || rr.mark || (rr.node = tr);
          });
        };
        for (var Ct in _.nodes)
          Je(Ct);
        return U;
      }
    }, {
      key: "fromSchema",
      value: function(_) {
        return _.cached.domParser || (_.cached.domParser = new xe(_, xe.schemaRules(_)));
      }
    }]), xe;
  }(), $ = {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    canvas: !0,
    dd: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    figcaption: !0,
    figure: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    li: !0,
    noscript: !0,
    ol: !0,
    output: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    tfoot: !0,
    ul: !0
  }, Se = {
    head: !0,
    noscript: !0,
    object: !0,
    script: !0,
    style: !0,
    title: !0
  }, se = {
    ol: !0,
    ul: !0
  }, M = 1, ne = 2, ce = 4;
  function X(xe, ae, _) {
    return ae != null ? (ae ? M : 0) | (ae === "full" ? ne : 0) : xe && xe.whitespace == "pre" ? M | ne : _ & -5;
  }
  var Re = function() {
    function xe(ae, _, U, fe, Te, Be, Je) {
      j(this, xe), this.type = ae, this.attrs = _, this.marks = U, this.pendingMarks = fe, this.solid = Te, this.options = Je, this.content = [], this.activeMarks = Oe.none, this.stashMarks = [], this.match = Be || (Je & ce ? null : ae.contentMatch);
    }
    return J(xe, [{
      key: "findWrapping",
      value: function(_) {
        if (!this.match) {
          if (!this.type) return [];
          var U = this.type.contentMatch.fillBefore(he.from(_));
          if (U)
            this.match = this.type.contentMatch.matchFragment(U);
          else {
            var fe = this.type.contentMatch, Te;
            return (Te = fe.findWrapping(_.type)) ? (this.match = fe, Te) : null;
          }
        }
        return this.match.findWrapping(_.type);
      }
    }, {
      key: "finish",
      value: function(_) {
        if (!(this.options & M)) {
          var U = this.content[this.content.length - 1], fe;
          if (U && U.isText && (fe = /[ \t\r\n\u000c]+$/.exec(U.text))) {
            var Te = U;
            U.text.length == fe[0].length ? this.content.pop() : this.content[this.content.length - 1] = Te.withText(Te.text.slice(0, Te.text.length - fe[0].length));
          }
        }
        var Be = he.from(this.content);
        return !_ && this.match && (Be = Be.append(this.match.fillBefore(he.empty, !0))), this.type ? this.type.create(this.attrs, Be, this.marks) : Be;
      }
    }, {
      key: "popFromStashMark",
      value: function(_) {
        for (var U = this.stashMarks.length - 1; U >= 0; U--)
          if (_.eq(this.stashMarks[U])) return this.stashMarks.splice(U, 1)[0];
      }
    }, {
      key: "applyPending",
      value: function(_) {
        for (var U = 0, fe = this.pendingMarks; U < fe.length; U++) {
          var Te = fe[U];
          (this.type ? this.type.allowsMarkType(Te.type) : gr(Te.type, _)) && !Te.isInSet(this.activeMarks) && (this.activeMarks = Te.addToSet(this.activeMarks), this.pendingMarks = Te.removeFromSet(this.pendingMarks));
        }
      }
    }, {
      key: "inlineContext",
      value: function(_) {
        return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : _.parentNode && !$.hasOwnProperty(_.parentNode.nodeName.toLowerCase());
      }
    }]), xe;
  }(), Ge = function() {
    function xe(ae, _, U) {
      j(this, xe), this.parser = ae, this.options = _, this.isOpen = U, this.open = 0;
      var fe = _.topNode, Te, Be = X(null, _.preserveWhitespace, 0) | (U ? ce : 0);
      fe ? Te = new Re(fe.type, fe.attrs, Oe.none, Oe.none, !0, _.topMatch || fe.type.contentMatch, Be) : U ? Te = new Re(null, null, Oe.none, Oe.none, !0, null, Be) : Te = new Re(ae.schema.topNodeType, null, Oe.none, Oe.none, !0, null, Be), this.nodes = [Te], this.find = _.findPositions, this.needsBlock = !1;
    }
    return J(xe, [{
      key: "top",
      get: function() {
        return this.nodes[this.open];
      }
    }, {
      key: "addDOM",
      value: function(_) {
        _.nodeType == 3 ? this.addTextNode(_) : _.nodeType == 1 && this.addElement(_);
      }
    }, {
      key: "withStyleRules",
      value: function(_, U) {
        var fe = _.getAttribute("style");
        if (!fe) return U();
        var Te = this.readStyles(Pt(fe));
        if (Te) {
          for (var Be = i(Te, 2), Je = Be[0], Ct = Be[1], jt = this.top, tr = 0; tr < Ct.length; tr++)
            this.removePendingMark(Ct[tr], jt);
          for (var Kt = 0; Kt < Je.length; Kt++)
            this.addPendingMark(Je[Kt]);
          U();
          for (var rr = 0; rr < Je.length; rr++)
            this.removePendingMark(Je[rr], jt);
          for (var kr = 0; kr < Ct.length; kr++)
            this.addPendingMark(Ct[kr]);
        }
      }
    }, {
      key: "addTextNode",
      value: function(_) {
        var U = _.nodeValue, fe = this.top;
        if (fe.options & ne || fe.inlineContext(_) || /[^ \t\r\n\u000c]/.test(U)) {
          if (fe.options & M)
            fe.options & ne ? U = U.replace(/\r\n?/g, `
`) : U = U.replace(/\r?\n|\r/g, " ");
          else if (U = U.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(U) && this.open == this.nodes.length - 1) {
            var Te = fe.content[fe.content.length - 1], Be = _.previousSibling;
            (!Te || Be && Be.nodeName == "BR" || Te.isText && /[ \t\r\n\u000c]$/.test(Te.text)) && (U = U.slice(1));
          }
          U && this.insertNode(this.parser.schema.text(U)), this.findInText(_);
        } else
          this.findInside(_);
      }
    }, {
      key: "addElement",
      value: function(_, U) {
        var fe = this, Te = _.nodeName.toLowerCase(), Be;
        se.hasOwnProperty(Te) && this.parser.normalizeLists && pt(_);
        var Je = this.options.ruleFromNode && this.options.ruleFromNode(_) || (Be = this.parser.matchTag(_, this, U));
        if (Je ? Je.ignore : Se.hasOwnProperty(Te))
          this.findInside(_), this.ignoreFallback(_);
        else if (!Je || Je.skip || Je.closeParent) {
          Je && Je.closeParent ? this.open = Math.max(0, this.open - 1) : Je && Je.skip.nodeType && (_ = Je.skip);
          var Ct, jt = this.top, tr = this.needsBlock;
          if ($.hasOwnProperty(Te))
            jt.content.length && jt.content[0].isInline && this.open && (this.open--, jt = this.top), Ct = !0, jt.type || (this.needsBlock = !0);
          else if (!_.firstChild) {
            this.leafFallback(_);
            return;
          }
          Je && Je.skip ? this.addAll(_) : this.withStyleRules(_, function() {
            return fe.addAll(_);
          }), Ct && this.sync(jt), this.needsBlock = tr;
        } else
          this.withStyleRules(_, function() {
            fe.addElementByRule(_, Je, Je.consuming === !1 ? Be : void 0);
          });
      }
    }, {
      key: "leafFallback",
      value: function(_) {
        _.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(_.ownerDocument.createTextNode(`
`));
      }
    }, {
      key: "ignoreFallback",
      value: function(_) {
        _.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"));
      }
    }, {
      key: "readStyles",
      value: function(_) {
        for (var U = this, fe = Oe.none, Te = Oe.none, Be = 0; Be < _.length; Be += 2)
          for (var Je = function(Kt) {
            var rr = U.parser.matchStyle(_[Be], _[Be + 1], U, Kt);
            if (!rr)
              return Ct = Kt, "break";
            if (rr.ignore)
              return Ct = Kt, {
                v: null
              };
            if (rr.clearMark ? U.top.pendingMarks.concat(U.top.activeMarks).forEach(function(kr) {
              rr.clearMark(kr) && (Te = kr.addToSet(Te));
            }) : fe = U.parser.schema.marks[rr.mark].create(rr.attrs).addToSet(fe), rr.consuming === !1) Kt = rr;
            else
              return Ct = Kt, "break";
            Ct = Kt;
          }, Ct = void 0; ; ) {
            var jt = Je(Ct);
            if (jt === "break") break;
            if (ie(jt) === "object") return jt.v;
          }
        return [fe, Te];
      }
    }, {
      key: "addElementByRule",
      value: function(_, U, fe) {
        var Te = this, Be, Je, Ct;
        if (U.node)
          Je = this.parser.schema.nodes[U.node], Je.isLeaf ? this.insertNode(Je.create(U.attrs)) || this.leafFallback(_) : Be = this.enter(Je, U.attrs || null, U.preserveWhitespace);
        else {
          var jt = this.parser.schema.marks[U.mark];
          Ct = jt.create(U.attrs), this.addPendingMark(Ct);
        }
        var tr = this.top;
        if (Je && Je.isLeaf)
          this.findInside(_);
        else if (fe)
          this.addElement(_, fe);
        else if (U.getContent)
          this.findInside(_), U.getContent(_, this.parser.schema).forEach(function(rr) {
            return Te.insertNode(rr);
          });
        else {
          var Kt = _;
          typeof U.contentElement == "string" ? Kt = _.querySelector(U.contentElement) : typeof U.contentElement == "function" ? Kt = U.contentElement(_) : U.contentElement && (Kt = U.contentElement), this.findAround(_, Kt, !0), this.addAll(Kt);
        }
        Be && this.sync(tr) && this.open--, Ct && this.removePendingMark(Ct, tr);
      }
    }, {
      key: "addAll",
      value: function(_, U, fe) {
        for (var Te = U || 0, Be = U ? _.childNodes[U] : _.firstChild, Je = fe == null ? null : _.childNodes[fe]; Be != Je; Be = Be.nextSibling, ++Te)
          this.findAtPoint(_, Te), this.addDOM(Be);
        this.findAtPoint(_, Te);
      }
    }, {
      key: "findPlace",
      value: function(_) {
        for (var U, fe, Te = this.open; Te >= 0; Te--) {
          var Be = this.nodes[Te], Je = Be.findWrapping(_);
          if (Je && (!U || U.length > Je.length) && (U = Je, fe = Be, !Je.length) || Be.solid) break;
        }
        if (!U) return !1;
        this.sync(fe);
        for (var Ct = 0; Ct < U.length; Ct++)
          this.enterInner(U[Ct], null, !1);
        return !0;
      }
    }, {
      key: "insertNode",
      value: function(_) {
        if (_.isInline && this.needsBlock && !this.top.type) {
          var U = this.textblockFromContext();
          U && this.enterInner(U);
        }
        if (this.findPlace(_)) {
          this.closeExtra();
          var fe = this.top;
          fe.applyPending(_.type), fe.match && (fe.match = fe.match.matchType(_.type));
          for (var Te = fe.activeMarks, Be = 0; Be < _.marks.length; Be++)
            (!fe.type || fe.type.allowsMarkType(_.marks[Be].type)) && (Te = _.marks[Be].addToSet(Te));
          return fe.content.push(_.mark(Te)), !0;
        }
        return !1;
      }
    }, {
      key: "enter",
      value: function(_, U, fe) {
        var Te = this.findPlace(_.create(U));
        return Te && this.enterInner(_, U, !0, fe), Te;
      }
    }, {
      key: "enterInner",
      value: function(_) {
        var U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, fe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, Te = arguments.length > 3 ? arguments[3] : void 0;
        this.closeExtra();
        var Be = this.top;
        Be.applyPending(_), Be.match = Be.match && Be.match.matchType(_);
        var Je = X(_, Te, Be.options);
        Be.options & ce && Be.content.length == 0 && (Je |= ce), this.nodes.push(new Re(_, U, Be.activeMarks, Be.pendingMarks, fe, null, Je)), this.open++;
      }
    }, {
      key: "closeExtra",
      value: function() {
        var _ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, U = this.nodes.length - 1;
        if (U > this.open) {
          for (; U > this.open; U--)
            this.nodes[U - 1].content.push(this.nodes[U].finish(_));
          this.nodes.length = this.open + 1;
        }
      }
    }, {
      key: "finish",
      value: function() {
        return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(this.isOpen || this.options.topOpen);
      }
    }, {
      key: "sync",
      value: function(_) {
        for (var U = this.open; U >= 0; U--)
          if (this.nodes[U] == _)
            return this.open = U, !0;
        return !1;
      }
    }, {
      key: "currentPos",
      get: function() {
        this.closeExtra();
        for (var _ = 0, U = this.open; U >= 0; U--) {
          for (var fe = this.nodes[U].content, Te = fe.length - 1; Te >= 0; Te--)
            _ += fe[Te].nodeSize;
          U && _++;
        }
        return _;
      }
    }, {
      key: "findAtPoint",
      value: function(_, U) {
        if (this.find) for (var fe = 0; fe < this.find.length; fe++)
          this.find[fe].node == _ && this.find[fe].offset == U && (this.find[fe].pos = this.currentPos);
      }
    }, {
      key: "findInside",
      value: function(_) {
        if (this.find) for (var U = 0; U < this.find.length; U++)
          this.find[U].pos == null && _.nodeType == 1 && _.contains(this.find[U].node) && (this.find[U].pos = this.currentPos);
      }
    }, {
      key: "findAround",
      value: function(_, U, fe) {
        if (_ != U && this.find) {
          for (var Te = 0; Te < this.find.length; Te++)
            if (this.find[Te].pos == null && _.nodeType == 1 && _.contains(this.find[Te].node)) {
              var Be = U.compareDocumentPosition(this.find[Te].node);
              Be & (fe ? 2 : 4) && (this.find[Te].pos = this.currentPos);
            }
        }
      }
    }, {
      key: "findInText",
      value: function(_) {
        if (this.find) for (var U = 0; U < this.find.length; U++)
          this.find[U].node == _ && (this.find[U].pos = this.currentPos - (_.nodeValue.length - this.find[U].offset));
      }
    }, {
      key: "matchesContext",
      value: function(_) {
        var U = this;
        if (_.indexOf("|") > -1) return _.split(/\s*\|\s*/).some(this.matchesContext, this);
        var fe = _.split("/"), Te = this.options.context, Be = !this.isOpen && (!Te || Te.parent.type == this.nodes[0].type), Je = -(Te ? Te.depth + 1 : 0) + (Be ? 0 : 1), Ct = function jt(tr, Kt) {
          for (; tr >= 0; tr--) {
            var rr = fe[tr];
            if (rr == "") {
              if (tr == fe.length - 1 || tr == 0) continue;
              for (; Kt >= Je; Kt--)
                if (jt(tr - 1, Kt)) return !0;
              return !1;
            } else {
              var kr = Kt > 0 || Kt == 0 && Be ? U.nodes[Kt].type : Te && Kt >= Je ? Te.node(Kt - Je).type : null;
              if (!kr || kr.name != rr && kr.groups.indexOf(rr) == -1) return !1;
              Kt--;
            }
          }
          return !0;
        };
        return Ct(fe.length - 1, this.open);
      }
    }, {
      key: "textblockFromContext",
      value: function() {
        var _ = this.options.context;
        if (_) for (var U = _.depth; U >= 0; U--) {
          var fe = _.node(U).contentMatchAt(_.indexAfter(U)).defaultType;
          if (fe && fe.isTextblock && fe.defaultAttrs) return fe;
        }
        for (var Te in this.parser.schema.nodes) {
          var Be = this.parser.schema.nodes[Te];
          if (Be.isTextblock && Be.defaultAttrs) return Be;
        }
      }
    }, {
      key: "addPendingMark",
      value: function(_) {
        var U = dr(_, this.top.pendingMarks);
        U && this.top.stashMarks.push(U), this.top.pendingMarks = _.addToSet(this.top.pendingMarks);
      }
    }, {
      key: "removePendingMark",
      value: function(_, U) {
        for (var fe = this.open; fe >= 0; fe--) {
          var Te = this.nodes[fe], Be = Te.pendingMarks.lastIndexOf(_);
          if (Be > -1)
            Te.pendingMarks = _.removeFromSet(Te.pendingMarks);
          else {
            Te.activeMarks = _.removeFromSet(Te.activeMarks);
            var Je = Te.popFromStashMark(_);
            Je && Te.type && Te.type.allowsMarkType(Je.type) && (Te.activeMarks = Je.addToSet(Te.activeMarks));
          }
          if (Te == U) break;
        }
      }
    }]), xe;
  }();
  function pt(xe) {
    for (var ae = xe.firstChild, _ = null; ae; ae = ae.nextSibling) {
      var U = ae.nodeType == 1 ? ae.nodeName.toLowerCase() : null;
      U && se.hasOwnProperty(U) && _ ? (_.appendChild(ae), ae = _) : U == "li" ? _ = ae : U && (_ = null);
    }
  }
  function xt(xe, ae) {
    return (xe.matches || xe.msMatchesSelector || xe.webkitMatchesSelector || xe.mozMatchesSelector).call(xe, ae);
  }
  function Pt(xe) {
    for (var ae = /\s*([\w-]+)\s*:\s*([^;]+)/g, _, U = []; _ = ae.exec(xe); )
      U.push(_[1], _[2].trim());
    return U;
  }
  function Yt(xe) {
    var ae = {};
    for (var _ in xe)
      ae[_] = xe[_];
    return ae;
  }
  function gr(xe, ae) {
    var _ = ae.schema.nodes, U = function(Je) {
      var Ct = _[Je];
      if (!Ct.allowsMarkType(xe)) return "continue";
      var jt = [], tr = function Kt(rr) {
        jt.push(rr);
        for (var kr = 0; kr < rr.edgeCount; kr++) {
          var on = rr.edge(kr), cr = on.type, An = on.next;
          if (cr == ae || jt.indexOf(An) < 0 && Kt(An)) return !0;
        }
      };
      if (tr(Ct.contentMatch)) return {
        v: !0
      };
    };
    for (var fe in _) {
      var Te = U(fe);
      if (Te !== "continue" && ie(Te) === "object")
        return Te.v;
    }
  }
  function dr(xe, ae) {
    for (var _ = 0; _ < ae.length; _++)
      if (xe.eq(ae[_])) return ae[_];
  }
  var It = function() {
    function xe(ae, _) {
      j(this, xe), this.nodes = ae, this.marks = _;
    }
    return J(xe, [{
      key: "serializeFragment",
      value: function(_) {
        var U = this, fe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, Te = arguments.length > 2 ? arguments[2] : void 0;
        Te || (Te = zt(fe).createDocumentFragment());
        var Be = Te, Je = [];
        return _.forEach(function(Ct) {
          if (Je.length || Ct.marks.length) {
            for (var jt = 0, tr = 0; jt < Je.length && tr < Ct.marks.length; ) {
              var Kt = Ct.marks[tr];
              if (!U.marks[Kt.type.name]) {
                tr++;
                continue;
              }
              if (!Kt.eq(Je[jt][0]) || Kt.type.spec.spanning === !1) break;
              jt++, tr++;
            }
            for (; jt < Je.length; )
              Be = Je.pop()[1];
            for (; tr < Ct.marks.length; ) {
              var rr = Ct.marks[tr++], kr = U.serializeMark(rr, Ct.isInline, fe);
              kr && (Je.push([rr, Be]), Be.appendChild(kr.dom), Be = kr.contentDOM || kr.dom);
            }
          }
          Be.appendChild(U.serializeNodeInner(Ct, fe));
        }), Te;
      }
    }, {
      key: "serializeNodeInner",
      value: function(_, U) {
        var fe = xe.renderSpec(zt(U), this.nodes[_.type.name](_)), Te = fe.dom, Be = fe.contentDOM;
        if (Be) {
          if (_.isLeaf) throw new RangeError("Content hole not allowed in a leaf node spec");
          this.serializeFragment(_.content, U, Be);
        }
        return Te;
      }
    }, {
      key: "serializeNode",
      value: function(_) {
        for (var U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, fe = this.serializeNodeInner(_, U), Te = _.marks.length - 1; Te >= 0; Te--) {
          var Be = this.serializeMark(_.marks[Te], _.isInline, U);
          Be && ((Be.contentDOM || Be.dom).appendChild(fe), fe = Be.dom);
        }
        return fe;
      }
    }, {
      key: "serializeMark",
      value: function(_, U) {
        var fe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, Te = this.marks[_.type.name];
        return Te && xe.renderSpec(zt(fe), Te(_, U));
      }
    }], [{
      key: "renderSpec",
      value: function(_, U) {
        var fe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        if (typeof U == "string") return {
          dom: _.createTextNode(U)
        };
        if (U.nodeType != null) return {
          dom: U
        };
        if (U.dom && U.dom.nodeType != null) return U;
        var Te = U[0], Be = Te.indexOf(" ");
        Be > 0 && (fe = Te.slice(0, Be), Te = Te.slice(Be + 1));
        var Je, Ct = fe ? _.createElementNS(fe, Te) : _.createElement(Te), jt = U[1], tr = 1;
        if (jt && ie(jt) == "object" && jt.nodeType == null && !Array.isArray(jt)) {
          tr = 2;
          for (var Kt in jt)
            if (jt[Kt] != null) {
              var rr = Kt.indexOf(" ");
              rr > 0 ? Ct.setAttributeNS(Kt.slice(0, rr), Kt.slice(rr + 1), jt[Kt]) : Ct.setAttribute(Kt, jt[Kt]);
            }
        }
        for (var kr = tr; kr < U.length; kr++) {
          var on = U[kr];
          if (on === 0) {
            if (kr < U.length - 1 || kr > tr) throw new RangeError("Content hole must be the only child of its parent node");
            return {
              dom: Ct,
              contentDOM: Ct
            };
          } else {
            var cr = xe.renderSpec(_, on, fe), An = cr.dom, ei = cr.contentDOM;
            if (Ct.appendChild(An), ei) {
              if (Je) throw new RangeError("Multiple content holes");
              Je = ei;
            }
          }
        }
        return {
          dom: Ct,
          contentDOM: Je
        };
      }
    }, {
      key: "fromSchema",
      value: function(_) {
        return _.cached.domSerializer || (_.cached.domSerializer = new xe(this.nodesFromSchema(_), this.marksFromSchema(_)));
      }
    }, {
      key: "nodesFromSchema",
      value: function(_) {
        var U = ct(_.nodes);
        return U.text || (U.text = function(fe) {
          return fe.text;
        }), U;
      }
    }, {
      key: "marksFromSchema",
      value: function(_) {
        return ct(_.marks);
      }
    }]), xe;
  }();
  function ct(xe) {
    var ae = {};
    for (var _ in xe) {
      var U = xe[_].spec.toDOM;
      U && (ae[_] = U);
    }
    return ae;
  }
  function zt(xe) {
    return xe.document || window.document;
  }
  return Ki.ContentMatch = Xe, Ki.DOMParser = ft, Ki.DOMSerializer = It, Ki.Fragment = he, Ki.Mark = Oe, Ki.MarkType = Ot, Ki.Node = qe, Ki.NodeRange = wt, Ki.NodeType = Ae, Ki.ReplaceError = Qe, Ki.ResolvedPos = ze, Ki.Schema = Vt, Ki.Slice = Me, Ki;
}
var _j = {}, bV;
function kW() {
  return bV || (bV = 1, function(i) {
    function e($) {
      "@babel/helpers - typeof";
      return e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Se) {
        return typeof Se;
      } : function(Se) {
        return Se && typeof Symbol == "function" && Se.constructor === Symbol && Se !== Symbol.prototype ? "symbol" : typeof Se;
      }, e($);
    }
    function r($) {
      var Se = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
      return r = function(M) {
        if (M === null || !l(M)) return M;
        if (typeof M != "function")
          throw new TypeError("Super expression must either be null or a function");
        if (typeof Se < "u") {
          if (Se.has(M)) return Se.get(M);
          Se.set(M, ne);
        }
        function ne() {
          return s(M, arguments, S(this).constructor);
        }
        return ne.prototype = Object.create(M.prototype, { constructor: { value: ne, enumerable: !1, writable: !0, configurable: !0 } }), f(ne, M);
      }, r($);
    }
    function s($, Se, se) {
      return y() ? s = Reflect.construct : s = function(ne, ce, X) {
        var Re = [null];
        Re.push.apply(Re, ce);
        var Ge = Function.bind.apply(ne, Re), pt = new Ge();
        return X && f(pt, X.prototype), pt;
      }, s.apply(null, arguments);
    }
    function l($) {
      return Function.toString.call($).indexOf("[native code]") !== -1;
    }
    function c($, Se) {
      if (typeof Se != "function" && Se !== null)
        throw new TypeError("Super expression must either be null or a function");
      $.prototype = Object.create(Se && Se.prototype, { constructor: { value: $, writable: !0, configurable: !0 } }), Object.defineProperty($, "prototype", { writable: !1 }), Se && f($, Se);
    }
    function f($, Se) {
      return f = Object.setPrototypeOf || function(M, ne) {
        return M.__proto__ = ne, M;
      }, f($, Se);
    }
    function p($) {
      var Se = y();
      return function() {
        var M = S($), ne;
        if (Se) {
          var ce = S(this).constructor;
          ne = Reflect.construct(M, arguments, ce);
        } else
          ne = M.apply(this, arguments);
        return d(this, ne);
      };
    }
    function d($, Se) {
      if (Se && (e(Se) === "object" || typeof Se == "function"))
        return Se;
      if (Se !== void 0)
        throw new TypeError("Derived constructors may only return object or undefined");
      return m($);
    }
    function m($) {
      if ($ === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return $;
    }
    function y() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
      if (typeof Proxy == "function") return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    function S($) {
      return S = Object.setPrototypeOf ? Object.getPrototypeOf : function(se) {
        return se.__proto__ || Object.getPrototypeOf(se);
      }, S($);
    }
    function x($, Se) {
      if (!($ instanceof Se))
        throw new TypeError("Cannot call a class as a function");
    }
    function w($, Se) {
      for (var se = 0; se < Se.length; se++) {
        var M = Se[se];
        M.enumerable = M.enumerable || !1, M.configurable = !0, "value" in M && (M.writable = !0), Object.defineProperty($, M.key, M);
      }
    }
    function k($, Se, se) {
      return Se && w($.prototype, Se), se && w($, se), Object.defineProperty($, "prototype", { writable: !1 }), $;
    }
    var O = /* @__PURE__ */ ek(), T = 65535, L = Math.pow(2, 16);
    function j($, Se) {
      return $ + Se * L;
    }
    function z($) {
      return $ & T;
    }
    function J($) {
      return ($ - ($ & T)) / L;
    }
    var ie = 1, K = 2, re = 4, ee = 8, de = function() {
      function $(Se, se, M) {
        x(this, $), this.pos = Se, this.delInfo = se, this.recover = M;
      }
      return k($, [{
        key: "deleted",
        get: function() {
          return (this.delInfo & ee) > 0;
        }
      }, {
        key: "deletedBefore",
        get: function() {
          return (this.delInfo & (ie | re)) > 0;
        }
      }, {
        key: "deletedAfter",
        get: function() {
          return (this.delInfo & (K | re)) > 0;
        }
      }, {
        key: "deletedAcross",
        get: function() {
          return (this.delInfo & re) > 0;
        }
      }]), $;
    }(), Ce = function() {
      function $(Se) {
        var se = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
        if (x(this, $), this.ranges = Se, this.inverted = se, !Se.length && $.empty) return $.empty;
      }
      return k($, [{
        key: "recover",
        value: function(se) {
          var M = 0, ne = z(se);
          if (!this.inverted) for (var ce = 0; ce < ne; ce++)
            M += this.ranges[ce * 3 + 2] - this.ranges[ce * 3 + 1];
          return this.ranges[ne * 3] + M + J(se);
        }
      }, {
        key: "mapResult",
        value: function(se) {
          var M = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return this._map(se, M, !1);
        }
      }, {
        key: "map",
        value: function(se) {
          var M = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return this._map(se, M, !0);
        }
      }, {
        key: "_map",
        value: function(se, M, ne) {
          for (var ce = 0, X = this.inverted ? 2 : 1, Re = this.inverted ? 1 : 2, Ge = 0; Ge < this.ranges.length; Ge += 3) {
            var pt = this.ranges[Ge] - (this.inverted ? ce : 0);
            if (pt > se) break;
            var xt = this.ranges[Ge + X], Pt = this.ranges[Ge + Re], Yt = pt + xt;
            if (se <= Yt) {
              var gr = xt ? se == pt ? -1 : se == Yt ? 1 : M : M, dr = pt + ce + (gr < 0 ? 0 : Pt);
              if (ne) return dr;
              var It = se == (M < 0 ? pt : Yt) ? null : j(Ge / 3, se - pt), ct = se == pt ? K : se == Yt ? ie : re;
              return (M < 0 ? se != pt : se != Yt) && (ct |= ee), new de(dr, ct, It);
            }
            ce += Pt - xt;
          }
          return ne ? se + ce : new de(se + ce, 0, null);
        }
      }, {
        key: "touches",
        value: function(se, M) {
          for (var ne = 0, ce = z(M), X = this.inverted ? 2 : 1, Re = this.inverted ? 1 : 2, Ge = 0; Ge < this.ranges.length; Ge += 3) {
            var pt = this.ranges[Ge] - (this.inverted ? ne : 0);
            if (pt > se) break;
            var xt = this.ranges[Ge + X], Pt = pt + xt;
            if (se <= Pt && Ge == ce * 3) return !0;
            ne += this.ranges[Ge + Re] - xt;
          }
          return !1;
        }
      }, {
        key: "forEach",
        value: function(se) {
          for (var M = this.inverted ? 2 : 1, ne = this.inverted ? 1 : 2, ce = 0, X = 0; ce < this.ranges.length; ce += 3) {
            var Re = this.ranges[ce], Ge = Re - (this.inverted ? X : 0), pt = Re + (this.inverted ? 0 : X), xt = this.ranges[ce + M], Pt = this.ranges[ce + ne];
            se(Ge, Ge + xt, pt, pt + Pt), X += Pt - xt;
          }
        }
      }, {
        key: "invert",
        value: function() {
          return new $(this.ranges, !this.inverted);
        }
      }, {
        key: "toString",
        value: function() {
          return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
        }
      }], [{
        key: "offset",
        value: function(se) {
          return se == 0 ? $.empty : new $(se < 0 ? [0, -se, 0] : [0, 0, se]);
        }
      }]), $;
    }();
    Ce.empty = new Ce([]);
    var he = function() {
      function $() {
        var Se = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], se = arguments.length > 1 ? arguments[1] : void 0, M = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, ne = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Se.length;
        x(this, $), this.maps = Se, this.mirror = se, this.from = M, this.to = ne;
      }
      return k($, [{
        key: "slice",
        value: function() {
          var se = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, M = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.maps.length;
          return new $(this.maps, this.mirror, se, M);
        }
      }, {
        key: "copy",
        value: function() {
          return new $(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
        }
      }, {
        key: "appendMap",
        value: function(se, M) {
          this.to = this.maps.push(se), M != null && this.setMirror(this.maps.length - 1, M);
        }
      }, {
        key: "appendMapping",
        value: function(se) {
          for (var M = 0, ne = this.maps.length; M < se.maps.length; M++) {
            var ce = se.getMirror(M);
            this.appendMap(se.maps[M], ce != null && ce < M ? ne + ce : void 0);
          }
        }
      }, {
        key: "getMirror",
        value: function(se) {
          if (this.mirror) {
            for (var M = 0; M < this.mirror.length; M++)
              if (this.mirror[M] == se) return this.mirror[M + (M % 2 ? -1 : 1)];
          }
        }
      }, {
        key: "setMirror",
        value: function(se, M) {
          this.mirror || (this.mirror = []), this.mirror.push(se, M);
        }
      }, {
        key: "appendMappingInverted",
        value: function(se) {
          for (var M = se.maps.length - 1, ne = this.maps.length + se.maps.length; M >= 0; M--) {
            var ce = se.getMirror(M);
            this.appendMap(se.maps[M].invert(), ce != null && ce > M ? ne - ce - 1 : void 0);
          }
        }
      }, {
        key: "invert",
        value: function() {
          var se = new $();
          return se.appendMappingInverted(this), se;
        }
      }, {
        key: "map",
        value: function(se) {
          var M = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          if (this.mirror) return this._map(se, M, !0);
          for (var ne = this.from; ne < this.to; ne++)
            se = this.maps[ne].map(se, M);
          return se;
        }
      }, {
        key: "mapResult",
        value: function(se) {
          var M = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return this._map(se, M, !1);
        }
      }, {
        key: "_map",
        value: function(se, M, ne) {
          for (var ce = 0, X = this.from; X < this.to; X++) {
            var Re = this.maps[X], Ge = Re.mapResult(se, M);
            if (Ge.recover != null) {
              var pt = this.getMirror(X);
              if (pt != null && pt > X && pt < this.to) {
                X = pt, se = this.maps[pt].recover(Ge.recover);
                continue;
              }
            }
            ce |= Ge.delInfo, se = Ge.pos;
          }
          return ne ? se : new de(se, ce, null);
        }
      }]), $;
    }(), oe = /* @__PURE__ */ Object.create(null), ge = function() {
      function $() {
        x(this, $);
      }
      return k($, [{
        key: "getMap",
        value: function() {
          return Ce.empty;
        }
      }, {
        key: "merge",
        value: function(se) {
          return null;
        }
      }], [{
        key: "fromJSON",
        value: function(se, M) {
          if (!M || !M.stepType) throw new RangeError("Invalid input for Step.fromJSON");
          var ne = oe[M.stepType];
          if (!ne) throw new RangeError("No step type ".concat(M.stepType, " defined"));
          return ne.fromJSON(se, M);
        }
      }, {
        key: "jsonID",
        value: function(se, M) {
          if (se in oe) throw new RangeError("Duplicate use of step JSON ID " + se);
          return oe[se] = M, M.prototype.jsonID = se, M;
        }
      }]), $;
    }(), we = function() {
      function $(Se, se) {
        x(this, $), this.doc = Se, this.failed = se;
      }
      return k($, null, [{
        key: "ok",
        value: function(se) {
          return new $(se, null);
        }
      }, {
        key: "fail",
        value: function(se) {
          return new $(null, se);
        }
      }, {
        key: "fromReplace",
        value: function(se, M, ne, ce) {
          try {
            return $.ok(se.replace(M, ne, ce));
          } catch (X) {
            if (X instanceof O.ReplaceError) return $.fail(X.message);
            throw X;
          }
        }
      }]), $;
    }();
    function Oe($, Se, se) {
      for (var M = [], ne = 0; ne < $.childCount; ne++) {
        var ce = $.child(ne);
        ce.content.size && (ce = ce.copy(Oe(ce.content, Se, ce))), ce.isInline && (ce = Se(ce, se, ne)), M.push(ce);
      }
      return O.Fragment.fromArray(M);
    }
    var Qe = function($) {
      c(se, $);
      var Se = p(se);
      function se(M, ne, ce) {
        var X;
        return x(this, se), X = Se.call(this), X.from = M, X.to = ne, X.mark = ce, X;
      }
      return k(se, [{
        key: "apply",
        value: function(ne) {
          var ce = this, X = ne.slice(this.from, this.to), Re = ne.resolve(this.from), Ge = Re.node(Re.sharedDepth(this.to)), pt = new O.Slice(Oe(X.content, function(xt, Pt) {
            return !xt.isAtom || !Pt.type.allowsMarkType(ce.mark.type) ? xt : xt.mark(ce.mark.addToSet(xt.marks));
          }, Ge), X.openStart, X.openEnd);
          return we.fromReplace(ne, this.from, this.to, pt);
        }
      }, {
        key: "invert",
        value: function() {
          return new Me(this.from, this.to, this.mark);
        }
      }, {
        key: "map",
        value: function(ne) {
          var ce = ne.mapResult(this.from, 1), X = ne.mapResult(this.to, -1);
          return ce.deleted && X.deleted || ce.pos >= X.pos ? null : new se(ce.pos, X.pos, this.mark);
        }
      }, {
        key: "merge",
        value: function(ne) {
          return ne instanceof se && ne.mark.eq(this.mark) && this.from <= ne.to && this.to >= ne.from ? new se(Math.min(this.from, ne.from), Math.max(this.to, ne.to), this.mark) : null;
        }
      }, {
        key: "toJSON",
        value: function() {
          return {
            stepType: "addMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to
          };
        }
      }], [{
        key: "fromJSON",
        value: function(ne, ce) {
          if (typeof ce.from != "number" || typeof ce.to != "number") throw new RangeError("Invalid input for AddMarkStep.fromJSON");
          return new se(ce.from, ce.to, ne.markFromJSON(ce.mark));
        }
      }]), se;
    }(ge);
    ge.jsonID("addMark", Qe);
    var Me = function($) {
      c(se, $);
      var Se = p(se);
      function se(M, ne, ce) {
        var X;
        return x(this, se), X = Se.call(this), X.from = M, X.to = ne, X.mark = ce, X;
      }
      return k(se, [{
        key: "apply",
        value: function(ne) {
          var ce = this, X = ne.slice(this.from, this.to), Re = new O.Slice(Oe(X.content, function(Ge) {
            return Ge.mark(ce.mark.removeFromSet(Ge.marks));
          }, ne), X.openStart, X.openEnd);
          return we.fromReplace(ne, this.from, this.to, Re);
        }
      }, {
        key: "invert",
        value: function() {
          return new Qe(this.from, this.to, this.mark);
        }
      }, {
        key: "map",
        value: function(ne) {
          var ce = ne.mapResult(this.from, 1), X = ne.mapResult(this.to, -1);
          return ce.deleted && X.deleted || ce.pos >= X.pos ? null : new se(ce.pos, X.pos, this.mark);
        }
      }, {
        key: "merge",
        value: function(ne) {
          return ne instanceof se && ne.mark.eq(this.mark) && this.from <= ne.to && this.to >= ne.from ? new se(Math.min(this.from, ne.from), Math.max(this.to, ne.to), this.mark) : null;
        }
      }, {
        key: "toJSON",
        value: function() {
          return {
            stepType: "removeMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to
          };
        }
      }], [{
        key: "fromJSON",
        value: function(ne, ce) {
          if (typeof ce.from != "number" || typeof ce.to != "number") throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
          return new se(ce.from, ce.to, ne.markFromJSON(ce.mark));
        }
      }]), se;
    }(ge);
    ge.jsonID("removeMark", Me);
    var Ie = function($) {
      c(se, $);
      var Se = p(se);
      function se(M, ne) {
        var ce;
        return x(this, se), ce = Se.call(this), ce.pos = M, ce.mark = ne, ce;
      }
      return k(se, [{
        key: "apply",
        value: function(ne) {
          var ce = ne.nodeAt(this.pos);
          if (!ce) return we.fail("No node at mark step's position");
          var X = ce.type.create(ce.attrs, null, this.mark.addToSet(ce.marks));
          return we.fromReplace(ne, this.pos, this.pos + 1, new O.Slice(O.Fragment.from(X), 0, ce.isLeaf ? 0 : 1));
        }
      }, {
        key: "invert",
        value: function(ne) {
          var ce = ne.nodeAt(this.pos);
          if (ce) {
            var X = this.mark.addToSet(ce.marks);
            if (X.length == ce.marks.length) {
              for (var Re = 0; Re < ce.marks.length; Re++)
                if (!ce.marks[Re].isInSet(X)) return new se(this.pos, ce.marks[Re]);
              return new se(this.pos, this.mark);
            }
          }
          return new rt(this.pos, this.mark);
        }
      }, {
        key: "map",
        value: function(ne) {
          var ce = ne.mapResult(this.pos, 1);
          return ce.deletedAfter ? null : new se(ce.pos, this.mark);
        }
      }, {
        key: "toJSON",
        value: function() {
          return {
            stepType: "addNodeMark",
            pos: this.pos,
            mark: this.mark.toJSON()
          };
        }
      }], [{
        key: "fromJSON",
        value: function(ne, ce) {
          if (typeof ce.pos != "number") throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
          return new se(ce.pos, ne.markFromJSON(ce.mark));
        }
      }]), se;
    }(ge);
    ge.jsonID("addNodeMark", Ie);
    var rt = function($) {
      c(se, $);
      var Se = p(se);
      function se(M, ne) {
        var ce;
        return x(this, se), ce = Se.call(this), ce.pos = M, ce.mark = ne, ce;
      }
      return k(se, [{
        key: "apply",
        value: function(ne) {
          var ce = ne.nodeAt(this.pos);
          if (!ce) return we.fail("No node at mark step's position");
          var X = ce.type.create(ce.attrs, null, this.mark.removeFromSet(ce.marks));
          return we.fromReplace(ne, this.pos, this.pos + 1, new O.Slice(O.Fragment.from(X), 0, ce.isLeaf ? 0 : 1));
        }
      }, {
        key: "invert",
        value: function(ne) {
          var ce = ne.nodeAt(this.pos);
          return !ce || !this.mark.isInSet(ce.marks) ? this : new Ie(this.pos, this.mark);
        }
      }, {
        key: "map",
        value: function(ne) {
          var ce = ne.mapResult(this.pos, 1);
          return ce.deletedAfter ? null : new se(ce.pos, this.mark);
        }
      }, {
        key: "toJSON",
        value: function() {
          return {
            stepType: "removeNodeMark",
            pos: this.pos,
            mark: this.mark.toJSON()
          };
        }
      }], [{
        key: "fromJSON",
        value: function(ne, ce) {
          if (typeof ce.pos != "number") throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
          return new se(ce.pos, ne.markFromJSON(ce.mark));
        }
      }]), se;
    }(ge);
    ge.jsonID("removeNodeMark", rt);
    var ot = function($) {
      c(se, $);
      var Se = p(se);
      function se(M, ne, ce) {
        var X, Re = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
        return x(this, se), X = Se.call(this), X.from = M, X.to = ne, X.slice = ce, X.structure = Re, X;
      }
      return k(se, [{
        key: "apply",
        value: function(ne) {
          return this.structure && gt(ne, this.from, this.to) ? we.fail("Structure replace would overwrite content") : we.fromReplace(ne, this.from, this.to, this.slice);
        }
      }, {
        key: "getMap",
        value: function() {
          return new Ce([this.from, this.to - this.from, this.slice.size]);
        }
      }, {
        key: "invert",
        value: function(ne) {
          return new se(this.from, this.from + this.slice.size, ne.slice(this.from, this.to));
        }
      }, {
        key: "map",
        value: function(ne) {
          var ce = ne.mapResult(this.from, 1), X = ne.mapResult(this.to, -1);
          return ce.deletedAcross && X.deletedAcross ? null : new se(ce.pos, Math.max(ce.pos, X.pos), this.slice);
        }
      }, {
        key: "merge",
        value: function(ne) {
          if (!(ne instanceof se) || ne.structure || this.structure) return null;
          if (this.from + this.slice.size == ne.from && !this.slice.openEnd && !ne.slice.openStart) {
            var ce = this.slice.size + ne.slice.size == 0 ? O.Slice.empty : new O.Slice(this.slice.content.append(ne.slice.content), this.slice.openStart, ne.slice.openEnd);
            return new se(this.from, this.to + (ne.to - ne.from), ce, this.structure);
          } else if (ne.to == this.from && !this.slice.openStart && !ne.slice.openEnd) {
            var X = this.slice.size + ne.slice.size == 0 ? O.Slice.empty : new O.Slice(ne.slice.content.append(this.slice.content), ne.slice.openStart, this.slice.openEnd);
            return new se(ne.from, this.to, X, this.structure);
          } else
            return null;
        }
      }, {
        key: "toJSON",
        value: function() {
          var ne = {
            stepType: "replace",
            from: this.from,
            to: this.to
          };
          return this.slice.size && (ne.slice = this.slice.toJSON()), this.structure && (ne.structure = !0), ne;
        }
      }], [{
        key: "fromJSON",
        value: function(ne, ce) {
          if (typeof ce.from != "number" || typeof ce.to != "number") throw new RangeError("Invalid input for ReplaceStep.fromJSON");
          return new se(ce.from, ce.to, O.Slice.fromJSON(ne, ce.slice), !!ce.structure);
        }
      }]), se;
    }(ge);
    ge.jsonID("replace", ot);
    var Et = function($) {
      c(se, $);
      var Se = p(se);
      function se(M, ne, ce, X, Re, Ge) {
        var pt, xt = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : !1;
        return x(this, se), pt = Se.call(this), pt.from = M, pt.to = ne, pt.gapFrom = ce, pt.gapTo = X, pt.slice = Re, pt.insert = Ge, pt.structure = xt, pt;
      }
      return k(se, [{
        key: "apply",
        value: function(ne) {
          if (this.structure && (gt(ne, this.from, this.gapFrom) || gt(ne, this.gapTo, this.to))) return we.fail("Structure gap-replace would overwrite content");
          var ce = ne.slice(this.gapFrom, this.gapTo);
          if (ce.openStart || ce.openEnd) return we.fail("Gap is not a flat range");
          var X = this.slice.insertAt(this.insert, ce.content);
          return X ? we.fromReplace(ne, this.from, this.to, X) : we.fail("Content does not fit in gap");
        }
      }, {
        key: "getMap",
        value: function() {
          return new Ce([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);
        }
      }, {
        key: "invert",
        value: function(ne) {
          var ce = this.gapTo - this.gapFrom;
          return new se(this.from, this.from + this.slice.size + ce, this.from + this.insert, this.from + this.insert + ce, ne.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
        }
      }, {
        key: "map",
        value: function(ne) {
          var ce = ne.mapResult(this.from, 1), X = ne.mapResult(this.to, -1), Re = ne.map(this.gapFrom, -1), Ge = ne.map(this.gapTo, 1);
          return ce.deletedAcross && X.deletedAcross || Re < ce.pos || Ge > X.pos ? null : new se(ce.pos, X.pos, Re, Ge, this.slice, this.insert, this.structure);
        }
      }, {
        key: "toJSON",
        value: function() {
          var ne = {
            stepType: "replaceAround",
            from: this.from,
            to: this.to,
            gapFrom: this.gapFrom,
            gapTo: this.gapTo,
            insert: this.insert
          };
          return this.slice.size && (ne.slice = this.slice.toJSON()), this.structure && (ne.structure = !0), ne;
        }
      }], [{
        key: "fromJSON",
        value: function(ne, ce) {
          if (typeof ce.from != "number" || typeof ce.to != "number" || typeof ce.gapFrom != "number" || typeof ce.gapTo != "number" || typeof ce.insert != "number") throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
          return new se(ce.from, ce.to, ce.gapFrom, ce.gapTo, O.Slice.fromJSON(ne, ce.slice), ce.insert, !!ce.structure);
        }
      }]), se;
    }(ge);
    ge.jsonID("replaceAround", Et);
    function gt($, Se, se) {
      for (var M = $.resolve(Se), ne = se - Se, ce = M.depth; ne > 0 && ce > 0 && M.indexAfter(ce) == M.node(ce).childCount; )
        ce--, ne--;
      if (ne > 0)
        for (var X = M.node(ce).maybeChild(M.indexAfter(ce)); ne > 0; ) {
          if (!X || X.isLeaf) return !0;
          X = X.firstChild, ne--;
        }
      return !1;
    }
    function At($, Se, se, M) {
      var ne = [], ce = [], X, Re;
      $.doc.nodesBetween(Se, se, function(Ge, pt, xt) {
        if (Ge.isInline) {
          var Pt = Ge.marks;
          if (!M.isInSet(Pt) && xt.type.allowsMarkType(M.type)) {
            for (var Yt = Math.max(pt, Se), gr = Math.min(pt + Ge.nodeSize, se), dr = M.addToSet(Pt), It = 0; It < Pt.length; It++)
              Pt[It].isInSet(dr) || (X && X.to == Yt && X.mark.eq(Pt[It]) ? X.to = gr : ne.push(X = new Me(Yt, gr, Pt[It])));
            Re && Re.to == Yt ? Re.to = gr : ce.push(Re = new Qe(Yt, gr, M));
          }
        }
      }), ne.forEach(function(Ge) {
        return $.step(Ge);
      }), ce.forEach(function(Ge) {
        return $.step(Ge);
      });
    }
    function Mt($, Se, se, M) {
      var ne = [], ce = 0;
      $.doc.nodesBetween(Se, se, function(X, Re) {
        if (X.isInline) {
          ce++;
          var Ge = null;
          if (M instanceof O.MarkType)
            for (var pt = X.marks, xt; xt = M.isInSet(pt); )
              (Ge || (Ge = [])).push(xt), pt = xt.removeFromSet(pt);
          else M ? M.isInSet(X.marks) && (Ge = [M]) : Ge = X.marks;
          if (Ge && Ge.length)
            for (var Pt = Math.min(Re + X.nodeSize, se), Yt = 0; Yt < Ge.length; Yt++) {
              for (var gr = Ge[Yt], dr = void 0, It = 0; It < ne.length; It++) {
                var ct = ne[It];
                ct.step == ce - 1 && gr.eq(ne[It].style) && (dr = ct);
              }
              dr ? (dr.to = Pt, dr.step = ce) : ne.push({
                style: gr,
                from: Math.max(Re, Se),
                to: Pt,
                step: ce
              });
            }
        }
      }), ne.forEach(function(X) {
        return $.step(new Me(X.from, X.to, X.style));
      });
    }
    function St($, Se, se) {
      for (var M = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : se.contentMatch, ne = $.doc.nodeAt(Se), ce = [], X = Se + 1, Re = 0; Re < ne.childCount; Re++) {
        var Ge = ne.child(Re), pt = X + Ge.nodeSize, xt = M.matchType(Ge.type);
        if (!xt)
          ce.push(new ot(X, pt, O.Slice.empty));
        else {
          M = xt;
          for (var Pt = 0; Pt < Ge.marks.length; Pt++)
            se.allowsMarkType(Ge.marks[Pt].type) || $.step(new Me(X, pt, Ge.marks[Pt]));
          if (Ge.isText && !se.spec.code)
            for (var Yt = void 0, gr = /\r?\n|\r/g, dr = void 0; Yt = gr.exec(Ge.text); )
              dr || (dr = new O.Slice(O.Fragment.from(se.schema.text(" ", se.allowedMarks(Ge.marks))), 0, 0)), ce.push(new ot(X + Yt.index, X + Yt.index + Yt[0].length, dr));
        }
        X = pt;
      }
      if (!M.validEnd) {
        var It = M.fillBefore(O.Fragment.empty, !0);
        $.replace(X, X, new O.Slice(It, 0, 0));
      }
      for (var ct = ce.length - 1; ct >= 0; ct--)
        $.step(ce[ct]);
    }
    function Ve($, Se, se) {
      return (Se == 0 || $.canReplace(Se, $.childCount)) && (se == $.childCount || $.canReplace(0, se));
    }
    function Ue($) {
      for (var Se = $.parent, se = Se.content.cutByIndex($.startIndex, $.endIndex), M = $.depth; ; --M) {
        var ne = $.$from.node(M), ce = $.$from.index(M), X = $.$to.indexAfter(M);
        if (M < $.depth && ne.canReplace(ce, X, se)) return M;
        if (M == 0 || ne.type.spec.isolating || !Ve(ne, ce, X)) break;
      }
      return null;
    }
    function He($, Se, se) {
      for (var M = Se.$from, ne = Se.$to, ce = Se.depth, X = M.before(ce + 1), Re = ne.after(ce + 1), Ge = X, pt = Re, xt = O.Fragment.empty, Pt = 0, Yt = ce, gr = !1; Yt > se; Yt--)
        gr || M.index(Yt) > 0 ? (gr = !0, xt = O.Fragment.from(M.node(Yt).copy(xt)), Pt++) : Ge--;
      for (var dr = O.Fragment.empty, It = 0, ct = ce, zt = !1; ct > se; ct--)
        zt || ne.after(ct + 1) < ne.end(ct) ? (zt = !0, dr = O.Fragment.from(ne.node(ct).copy(dr)), It++) : pt++;
      $.step(new Et(Ge, pt, X, Re, new O.Slice(xt.append(dr), Pt, It), xt.size - Pt, !0));
    }
    function We($, Se) {
      var se = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, M = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : $, ne = at($, Se), ce = ne && Ye(M, Se);
      return ce ? ne.map(ze).concat({
        type: Se,
        attrs: se
      }).concat(ce.map(ze)) : null;
    }
    function ze($) {
      return {
        type: $,
        attrs: null
      };
    }
    function at($, Se) {
      var se = $.parent, M = $.startIndex, ne = $.endIndex, ce = se.contentMatchAt(M).findWrapping(Se);
      if (!ce) return null;
      var X = ce.length ? ce[0] : Se;
      return se.canReplaceWith(M, ne, X) ? ce : null;
    }
    function Ye($, Se) {
      var se = $.parent, M = $.startIndex, ne = $.endIndex, ce = se.child(M), X = Se.contentMatch.findWrapping(ce.type);
      if (!X) return null;
      for (var Re = X.length ? X[X.length - 1] : Se, Ge = Re.contentMatch, pt = M; Ge && pt < ne; pt++)
        Ge = Ge.matchType(se.child(pt).type);
      return !Ge || !Ge.validEnd ? null : X;
    }
    function tt($, Se, se) {
      for (var M = O.Fragment.empty, ne = se.length - 1; ne >= 0; ne--) {
        if (M.size) {
          var ce = se[ne].type.contentMatch.matchFragment(M);
          if (!ce || !ce.validEnd) throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
        }
        M = O.Fragment.from(se[ne].type.create(se[ne].attrs, M));
      }
      var X = Se.start, Re = Se.end;
      $.step(new Et(X, Re, X, Re, new O.Slice(M, 0, 0), se.length, !0));
    }
    function wt($, Se, se, M, ne) {
      if (!M.isTextblock) throw new RangeError("Type given to setBlockType should be a textblock");
      var ce = $.steps.length;
      $.doc.nodesBetween(Se, se, function(X, Re) {
        if (X.isTextblock && !X.hasMarkup(M, ne) && Ft($.doc, $.mapping.slice(ce).map(Re), M)) {
          $.clearIncompatible($.mapping.slice(ce).map(Re, 1), M);
          var Ge = $.mapping.slice(ce), pt = Ge.map(Re, 1), xt = Ge.map(Re + X.nodeSize, 1);
          return $.step(new Et(pt, xt, pt + 1, xt - 1, new O.Slice(O.Fragment.from(M.create(ne, null, X.marks)), 0, 0), 1, !0)), !1;
        }
      });
    }
    function Ft($, Se, se) {
      var M = $.resolve(Se), ne = M.index();
      return M.parent.canReplaceWith(ne, ne + 1, se);
    }
    function qe($, Se, se, M, ne) {
      var ce = $.doc.nodeAt(Se);
      if (!ce) throw new RangeError("No node at given position");
      se || (se = ce.type);
      var X = se.create(M, null, ne || ce.marks);
      if (ce.isLeaf) return $.replaceWith(Se, Se + ce.nodeSize, X);
      if (!se.validContent(ce.content)) throw new RangeError("Invalid content for node type " + se.name);
      $.step(new Et(Se, Se + ce.nodeSize, Se + 1, Se + ce.nodeSize - 1, new O.Slice(O.Fragment.from(X), 0, 0), 1, !0));
    }
    function pe($, Se) {
      var se = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, M = arguments.length > 3 ? arguments[3] : void 0, ne = $.resolve(Se), ce = ne.depth - se, X = M && M[M.length - 1] || ne.parent;
      if (ce < 0 || ne.parent.type.spec.isolating || !ne.parent.canReplace(ne.index(), ne.parent.childCount) || !X.type.validContent(ne.parent.content.cutByIndex(ne.index(), ne.parent.childCount))) return !1;
      for (var Re = ne.depth - 1, Ge = se - 2; Re > ce; Re--, Ge--) {
        var pt = ne.node(Re), xt = ne.index(Re);
        if (pt.type.spec.isolating) return !1;
        var Pt = pt.content.cutByIndex(xt, pt.childCount), Yt = M && M[Ge + 1];
        Yt && (Pt = Pt.replaceChild(0, Yt.type.create(Yt.attrs)));
        var gr = M && M[Ge] || pt;
        if (!pt.canReplace(xt + 1, pt.childCount) || !gr.type.validContent(Pt)) return !1;
      }
      var dr = ne.indexAfter(ce), It = M && M[0];
      return ne.node(ce).canReplaceWith(dr, dr, It ? It.type : ne.node(ce + 1).type);
    }
    function _e($, Se) {
      for (var se = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, M = arguments.length > 3 ? arguments[3] : void 0, ne = $.doc.resolve(Se), ce = O.Fragment.empty, X = O.Fragment.empty, Re = ne.depth, Ge = ne.depth - se, pt = se - 1; Re > Ge; Re--, pt--) {
        ce = O.Fragment.from(ne.node(Re).copy(ce));
        var xt = M && M[pt];
        X = O.Fragment.from(xt ? xt.type.create(xt.attrs, X) : ne.node(Re).copy(X));
      }
      $.step(new ot(Se, Se, new O.Slice(ce.append(X), se, se), !0));
    }
    function Xe($, Se) {
      var se = $.resolve(Se), M = se.index();
      return lt(se.nodeBefore, se.nodeAfter) && se.parent.canReplace(M, M + 1);
    }
    function lt($, Se) {
      return !!($ && Se && !$.isLeaf && $.canAppend(Se));
    }
    function Q($, Se) {
      for (var se = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1, M = $.resolve(Se), ne = M.depth; ; ne--) {
        var ce = void 0, X = void 0, Re = M.index(ne);
        if (ne == M.depth ? (ce = M.nodeBefore, X = M.nodeAfter) : se > 0 ? (ce = M.node(ne + 1), Re++, X = M.node(ne).maybeChild(Re)) : (ce = M.node(ne).maybeChild(Re - 1), X = M.node(ne + 1)), ce && !ce.isTextblock && lt(ce, X) && M.node(ne).canReplace(Re, Re + 1)) return Se;
        if (ne == 0) break;
        Se = se < 0 ? M.before(ne) : M.after(ne);
      }
    }
    function te($, Se, se) {
      var M = new ot(Se - se, Se + se, O.Slice.empty, !0);
      $.step(M);
    }
    function De($, Se, se) {
      var M = $.resolve(Se);
      if (M.parent.canReplaceWith(M.index(), M.index(), se)) return Se;
      if (M.parentOffset == 0) for (var ne = M.depth - 1; ne >= 0; ne--) {
        var ce = M.index(ne);
        if (M.node(ne).canReplaceWith(ce, ce, se)) return M.before(ne + 1);
        if (ce > 0) return null;
      }
      if (M.parentOffset == M.parent.content.size) for (var X = M.depth - 1; X >= 0; X--) {
        var Re = M.indexAfter(X);
        if (M.node(X).canReplaceWith(Re, Re, se)) return M.after(X + 1);
        if (Re < M.node(X).childCount) return null;
      }
      return null;
    }
    function nt($, Se, se) {
      var M = $.resolve(Se);
      if (!se.content.size) return Se;
      for (var ne = se.content, ce = 0; ce < se.openStart; ce++)
        ne = ne.firstChild.content;
      for (var X = 1; X <= (se.openStart == 0 && se.size ? 2 : 1); X++)
        for (var Re = M.depth; Re >= 0; Re--) {
          var Ge = Re == M.depth ? 0 : M.pos <= (M.start(Re + 1) + M.end(Re + 1)) / 2 ? -1 : 1, pt = M.index(Re) + (Ge > 0 ? 1 : 0), xt = M.node(Re), Pt = !1;
          if (X == 1)
            Pt = xt.canReplace(pt, pt, ne);
          else {
            var Yt = xt.contentMatchAt(pt).findWrapping(ne.firstChild.type);
            Pt = Yt && xt.canReplaceWith(pt, pt, Yt[0]);
          }
          if (Pt) return Ge == 0 ? M.pos : Ge < 0 ? M.before(Re + 1) : M.after(Re + 1);
        }
      return null;
    }
    function be($, Se) {
      var se = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Se, M = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : O.Slice.empty;
      if (Se == se && !M.size) return null;
      var ne = $.resolve(Se), ce = $.resolve(se);
      return G(ne, ce, M) ? new ot(Se, se, M) : new V(ne, ce, M).fit();
    }
    function G($, Se, se) {
      return !se.openStart && !se.openEnd && $.start() == Se.start() && $.parent.canReplace($.index(), Se.index(), se.content);
    }
    var V = function() {
      function $(Se, se, M) {
        x(this, $), this.$from = Se, this.$to = se, this.unplaced = M, this.frontier = [], this.placed = O.Fragment.empty;
        for (var ne = 0; ne <= Se.depth; ne++) {
          var ce = Se.node(ne);
          this.frontier.push({
            type: ce.type,
            match: ce.contentMatchAt(Se.indexAfter(ne))
          });
        }
        for (var X = Se.depth; X > 0; X--)
          this.placed = O.Fragment.from(Se.node(X).copy(this.placed));
      }
      return k($, [{
        key: "depth",
        get: function() {
          return this.frontier.length - 1;
        }
      }, {
        key: "fit",
        value: function() {
          for (; this.unplaced.size; ) {
            var se = this.findFittable();
            se ? this.placeNodes(se) : this.openMore() || this.dropNode();
          }
          var M = this.mustMoveInline(), ne = this.placed.size - this.depth - this.$from.depth, ce = this.$from, X = this.close(M < 0 ? this.$to : ce.doc.resolve(M));
          if (!X) return null;
          for (var Re = this.placed, Ge = ce.depth, pt = X.depth; Ge && pt && Re.childCount == 1; )
            Re = Re.firstChild.content, Ge--, pt--;
          var xt = new O.Slice(Re, Ge, pt);
          return M > -1 ? new Et(ce.pos, M, this.$to.pos, this.$to.end(), xt, ne) : xt.size || ce.pos != this.$to.pos ? new ot(ce.pos, X.pos, xt) : null;
        }
      }, {
        key: "findFittable",
        value: function() {
          for (var se = this.unplaced.openStart, M = this.unplaced.content, ne = 0, ce = this.unplaced.openEnd; ne < se; ne++) {
            var X = M.firstChild;
            if (M.childCount > 1 && (ce = 0), X.type.spec.isolating && ce <= ne) {
              se = ne;
              break;
            }
            M = X.content;
          }
          for (var Re = 1; Re <= 2; Re++)
            for (var Ge = Re == 1 ? se : this.unplaced.openStart; Ge >= 0; Ge--) {
              var pt = void 0, xt = null;
              Ge ? (xt = it(this.unplaced.content, Ge - 1).firstChild, pt = xt.content) : pt = this.unplaced.content;
              for (var Pt = pt.firstChild, Yt = this.depth; Yt >= 0; Yt--) {
                var gr = this.frontier[Yt], dr = gr.type, It = gr.match, ct = void 0, zt = null;
                if (Re == 1 && (Pt ? It.matchType(Pt.type) || (zt = It.fillBefore(O.Fragment.from(Pt), !1)) : xt && dr.compatibleContent(xt.type))) return {
                  sliceDepth: Ge,
                  frontierDepth: Yt,
                  parent: xt,
                  inject: zt
                };
                if (Re == 2 && Pt && (ct = It.findWrapping(Pt.type))) return {
                  sliceDepth: Ge,
                  frontierDepth: Yt,
                  parent: xt,
                  wrap: ct
                };
                if (xt && It.matchType(xt.type)) break;
              }
            }
        }
      }, {
        key: "openMore",
        value: function() {
          var se = this.unplaced, M = se.content, ne = se.openStart, ce = se.openEnd, X = it(M, ne);
          return !X.childCount || X.firstChild.isLeaf ? !1 : (this.unplaced = new O.Slice(M, ne + 1, Math.max(ce, X.size + ne >= M.size - ce ? ne + 1 : 0)), !0);
        }
      }, {
        key: "dropNode",
        value: function() {
          var se = this.unplaced, M = se.content, ne = se.openStart, ce = se.openEnd, X = it(M, ne);
          if (X.childCount <= 1 && ne > 0) {
            var Re = M.size - ne <= ne + X.size;
            this.unplaced = new O.Slice(ve(M, ne - 1, 1), ne - 1, Re ? ne - 1 : ce);
          } else
            this.unplaced = new O.Slice(ve(M, ne, 1), ne, ce);
        }
      }, {
        key: "placeNodes",
        value: function(se) {
          for (var M = se.sliceDepth, ne = se.frontierDepth, ce = se.parent, X = se.inject, Re = se.wrap; this.depth > ne; )
            this.closeFrontierNode();
          if (Re) for (var Ge = 0; Ge < Re.length; Ge++)
            this.openFrontierNode(Re[Ge]);
          var pt = this.unplaced, xt = ce ? ce.content : pt.content, Pt = pt.openStart - M, Yt = 0, gr = [], dr = this.frontier[ne], It = dr.match, ct = dr.type;
          if (X) {
            for (var Ge = 0; Ge < X.childCount; Ge++)
              gr.push(X.child(Ge));
            It = It.matchFragment(X);
          }
          for (var zt = xt.size + M - (pt.content.size - pt.openEnd); Yt < xt.childCount; ) {
            var xe = xt.child(Yt), ae = It.matchType(xe.type);
            if (!ae) break;
            Yt++, (Yt > 1 || Pt == 0 || xe.content.size) && (It = ae, gr.push(yt(xe.mark(ct.allowedMarks(xe.marks)), Yt == 1 ? Pt : 0, Yt == xt.childCount ? zt : -1)));
          }
          var _ = Yt == xt.childCount;
          _ || (zt = -1), this.placed = Ne(this.placed, ne, O.Fragment.from(gr)), this.frontier[ne].match = It, _ && zt < 0 && ce && ce.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
          for (var U = 0, fe = xt; U < zt; U++) {
            var Te = fe.lastChild;
            this.frontier.push({
              type: Te.type,
              match: Te.contentMatchAt(Te.childCount)
            }), fe = Te.content;
          }
          this.unplaced = _ ? M == 0 ? O.Slice.empty : new O.Slice(ve(pt.content, M - 1, 1), M - 1, zt < 0 ? pt.openEnd : M - 1) : new O.Slice(ve(pt.content, M, Yt), pt.openStart, pt.openEnd);
        }
      }, {
        key: "mustMoveInline",
        value: function() {
          if (!this.$to.parent.isTextblock) return -1;
          var se = this.frontier[this.depth], M;
          if (!se.type.isTextblock || !$t(this.$to, this.$to.depth, se.type, se.match, !1) || this.$to.depth == this.depth && (M = this.findCloseLevel(this.$to)) && M.depth == this.depth) return -1;
          for (var ne = this.$to.depth, ce = this.$to.after(ne); ne > 1 && ce == this.$to.end(--ne); )
            ++ce;
          return ce;
        }
      }, {
        key: "findCloseLevel",
        value: function(se) {
          e: for (var M = Math.min(this.depth, se.depth); M >= 0; M--) {
            var ne = this.frontier[M], ce = ne.match, X = ne.type, Re = M < se.depth && se.end(M + 1) == se.pos + (se.depth - (M + 1)), Ge = $t(se, M, X, ce, Re);
            if (Ge) {
              for (var pt = M - 1; pt >= 0; pt--) {
                var xt = this.frontier[pt], Pt = xt.match, Yt = xt.type, gr = $t(se, pt, Yt, Pt, !0);
                if (!gr || gr.childCount) continue e;
              }
              return {
                depth: M,
                fit: Ge,
                move: Re ? se.doc.resolve(se.after(M + 1)) : se
              };
            }
          }
        }
      }, {
        key: "close",
        value: function(se) {
          var M = this.findCloseLevel(se);
          if (!M) return null;
          for (; this.depth > M.depth; )
            this.closeFrontierNode();
          M.fit.childCount && (this.placed = Ne(this.placed, M.depth, M.fit)), se = M.move;
          for (var ne = M.depth + 1; ne <= se.depth; ne++) {
            var ce = se.node(ne), X = ce.type.contentMatch.fillBefore(ce.content, !0, se.index(ne));
            this.openFrontierNode(ce.type, ce.attrs, X);
          }
          return se;
        }
      }, {
        key: "openFrontierNode",
        value: function(se) {
          var M = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, ne = arguments.length > 2 ? arguments[2] : void 0, ce = this.frontier[this.depth];
          ce.match = ce.match.matchType(se), this.placed = Ne(this.placed, this.depth, O.Fragment.from(se.create(M, ne))), this.frontier.push({
            type: se,
            match: se.contentMatch
          });
        }
      }, {
        key: "closeFrontierNode",
        value: function() {
          var se = this.frontier.pop(), M = se.match.fillBefore(O.Fragment.empty, !0);
          M.childCount && (this.placed = Ne(this.placed, this.frontier.length, M));
        }
      }]), $;
    }();
    function ve($, Se, se) {
      return Se == 0 ? $.cutByIndex(se, $.childCount) : $.replaceChild(0, $.firstChild.copy(ve($.firstChild.content, Se - 1, se)));
    }
    function Ne($, Se, se) {
      return Se == 0 ? $.append(se) : $.replaceChild($.childCount - 1, $.lastChild.copy(Ne($.lastChild.content, Se - 1, se)));
    }
    function it($, Se) {
      for (var se = 0; se < Se; se++)
        $ = $.firstChild.content;
      return $;
    }
    function yt($, Se, se) {
      if (Se <= 0) return $;
      var M = $.content;
      return Se > 1 && (M = M.replaceChild(0, yt(M.firstChild, Se - 1, M.childCount == 1 ? se - 1 : 0))), Se > 0 && (M = $.type.contentMatch.fillBefore(M).append(M), se <= 0 && (M = M.append($.type.contentMatch.matchFragment(M).fillBefore(O.Fragment.empty, !0)))), $.copy(M);
    }
    function $t($, Se, se, M, ne) {
      var ce = $.node(Se), X = ne ? $.indexAfter(Se) : $.index(Se);
      if (X == ce.childCount && !se.compatibleContent(ce.type)) return null;
      var Re = M.fillBefore(ce.content, !0, X);
      return Re && !Gt(se, ce.content, X) ? Re : null;
    }
    function Gt($, Se, se) {
      for (var M = se; M < Se.childCount; M++)
        if (!$.allowsMarks(Se.child(M).marks)) return !0;
      return !1;
    }
    function Jt($) {
      return $.spec.defining || $.spec.definingForContent;
    }
    function Xt($, Se, se, M) {
      if (!M.size) return $.deleteRange(Se, se);
      var ne = $.doc.resolve(Se), ce = $.doc.resolve(se);
      if (G(ne, ce, M)) return $.step(new ot(Se, se, M));
      var X = Vt(ne, $.doc.resolve(se));
      X[X.length - 1] == 0 && X.pop();
      var Re = -(ne.depth + 1);
      X.unshift(Re);
      for (var Ge = ne.depth, pt = ne.pos - 1; Ge > 0; Ge--, pt--) {
        var xt = ne.node(Ge).type.spec;
        if (xt.defining || xt.definingAsContext || xt.isolating) break;
        X.indexOf(Ge) > -1 ? Re = Ge : ne.before(Ge) == pt && X.splice(1, 0, -Ge);
      }
      for (var Pt = X.indexOf(Re), Yt = [], gr = M.openStart, dr = M.content, It = 0; ; It++) {
        var ct = dr.firstChild;
        if (Yt.push(ct), It == M.openStart) break;
        dr = ct.content;
      }
      for (var zt = gr - 1; zt >= 0; zt--) {
        var xe = Yt[zt], ae = Jt(xe.type);
        if (ae && !xe.sameMarkup(ne.node(Math.abs(Re) - 1))) gr = zt;
        else if (ae || !xe.type.isTextblock) break;
      }
      for (var _ = M.openStart; _ >= 0; _--) {
        var U = (_ + gr + 1) % (M.openStart + 1), fe = Yt[U];
        if (fe)
          for (var Te = 0; Te < X.length; Te++) {
            var Be = X[(Te + Pt) % X.length], Je = !0;
            Be < 0 && (Je = !1, Be = -Be);
            var Ct = ne.node(Be - 1), jt = ne.index(Be - 1);
            if (Ct.canReplaceWith(jt, jt, fe.type, fe.marks)) return $.replace(ne.before(Be), Je ? ce.after(Be) : se, new O.Slice(Ae(M.content, 0, M.openStart, U), U, M.openEnd));
          }
      }
      for (var tr = $.steps.length, Kt = X.length - 1; Kt >= 0 && ($.replace(Se, se, M), !($.steps.length > tr)); Kt--) {
        var rr = X[Kt];
        rr < 0 || (Se = ne.before(rr), se = ce.after(rr));
      }
    }
    function Ae($, Se, se, M, ne) {
      if (Se < se) {
        var ce = $.firstChild;
        $ = $.replaceChild(0, ce.copy(Ae(ce.content, Se + 1, se, M, ce)));
      }
      if (Se > M) {
        var X = ne.contentMatchAt(0), Re = X.fillBefore($).append($);
        $ = Re.append(X.matchFragment(Re).fillBefore(O.Fragment.empty, !0));
      }
      return $;
    }
    function vt($, Se, se, M) {
      if (!M.isInline && Se == se && $.doc.resolve(Se).parent.content.size) {
        var ne = De($.doc, Se, M.type);
        ne != null && (Se = se = ne);
      }
      $.replaceRange(Se, se, new O.Slice(O.Fragment.from(M), 0, 0));
    }
    function Ot($, Se, se) {
      for (var M = $.doc.resolve(Se), ne = $.doc.resolve(se), ce = Vt(M, ne), X = 0; X < ce.length; X++) {
        var Re = ce[X], Ge = X == ce.length - 1;
        if (Ge && Re == 0 || M.node(Re).type.contentMatch.validEnd) return $.delete(M.start(Re), ne.end(Re));
        if (Re > 0 && (Ge || M.node(Re - 1).canReplace(M.index(Re - 1), ne.indexAfter(Re - 1)))) return $.delete(M.before(Re), ne.after(Re));
      }
      for (var pt = 1; pt <= M.depth && pt <= ne.depth; pt++)
        if (Se - M.start(pt) == M.depth - pt && se > M.end(pt) && ne.end(pt) - se != ne.depth - pt) return $.delete(M.before(pt), se);
      $.delete(Se, se);
    }
    function Vt($, Se) {
      for (var se = [], M = Math.min($.depth, Se.depth), ne = M; ne >= 0; ne--) {
        var ce = $.start(ne);
        if (ce < $.pos - ($.depth - ne) || Se.end(ne) > Se.pos + (Se.depth - ne) || $.node(ne).type.spec.isolating || Se.node(ne).type.spec.isolating) break;
        (ce == Se.start(ne) || ne == $.depth && ne == Se.depth && $.parent.inlineContent && Se.parent.inlineContent && ne && Se.start(ne - 1) == ce - 1) && se.push(ne);
      }
      return se;
    }
    var et = function($) {
      c(se, $);
      var Se = p(se);
      function se(M, ne, ce) {
        var X;
        return x(this, se), X = Se.call(this), X.pos = M, X.attr = ne, X.value = ce, X;
      }
      return k(se, [{
        key: "apply",
        value: function(ne) {
          var ce = ne.nodeAt(this.pos);
          if (!ce) return we.fail("No node at attribute step's position");
          var X = /* @__PURE__ */ Object.create(null);
          for (var Re in ce.attrs)
            X[Re] = ce.attrs[Re];
          X[this.attr] = this.value;
          var Ge = ce.type.create(X, null, ce.marks);
          return we.fromReplace(ne, this.pos, this.pos + 1, new O.Slice(O.Fragment.from(Ge), 0, ce.isLeaf ? 0 : 1));
        }
      }, {
        key: "getMap",
        value: function() {
          return Ce.empty;
        }
      }, {
        key: "invert",
        value: function(ne) {
          return new se(this.pos, this.attr, ne.nodeAt(this.pos).attrs[this.attr]);
        }
      }, {
        key: "map",
        value: function(ne) {
          var ce = ne.mapResult(this.pos, 1);
          return ce.deletedAfter ? null : new se(ce.pos, this.attr, this.value);
        }
      }, {
        key: "toJSON",
        value: function() {
          return {
            stepType: "attr",
            pos: this.pos,
            attr: this.attr,
            value: this.value
          };
        }
      }], [{
        key: "fromJSON",
        value: function(ne, ce) {
          if (typeof ce.pos != "number" || typeof ce.attr != "string") throw new RangeError("Invalid input for AttrStep.fromJSON");
          return new se(ce.pos, ce.attr, ce.value);
        }
      }]), se;
    }(ge);
    ge.jsonID("attr", et), i.TransformError = function($) {
      c(se, $);
      var Se = p(se);
      function se() {
        return x(this, se), Se.apply(this, arguments);
      }
      return k(se);
    }(r(Error)), i.TransformError = function $(Se) {
      var se = Error.call(this, Se);
      return se.__proto__ = $.prototype, se;
    }, i.TransformError.prototype = Object.create(Error.prototype), i.TransformError.prototype.constructor = i.TransformError, i.TransformError.prototype.name = "TransformError";
    var ft = function() {
      function $(Se) {
        x(this, $), this.doc = Se, this.steps = [], this.docs = [], this.mapping = new he();
      }
      return k($, [{
        key: "before",
        get: function() {
          return this.docs.length ? this.docs[0] : this.doc;
        }
      }, {
        key: "step",
        value: function(se) {
          var M = this.maybeStep(se);
          if (M.failed) throw new i.TransformError(M.failed);
          return this;
        }
      }, {
        key: "maybeStep",
        value: function(se) {
          var M = se.apply(this.doc);
          return M.failed || this.addStep(se, M.doc), M;
        }
      }, {
        key: "docChanged",
        get: function() {
          return this.steps.length > 0;
        }
      }, {
        key: "addStep",
        value: function(se, M) {
          this.docs.push(this.doc), this.steps.push(se), this.mapping.appendMap(se.getMap()), this.doc = M;
        }
      }, {
        key: "replace",
        value: function(se) {
          var M = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : se, ne = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : O.Slice.empty, ce = be(this.doc, se, M, ne);
          return ce && this.step(ce), this;
        }
      }, {
        key: "replaceWith",
        value: function(se, M, ne) {
          return this.replace(se, M, new O.Slice(O.Fragment.from(ne), 0, 0));
        }
      }, {
        key: "delete",
        value: function(se, M) {
          return this.replace(se, M, O.Slice.empty);
        }
      }, {
        key: "insert",
        value: function(se, M) {
          return this.replaceWith(se, se, M);
        }
      }, {
        key: "replaceRange",
        value: function(se, M, ne) {
          return Xt(this, se, M, ne), this;
        }
      }, {
        key: "replaceRangeWith",
        value: function(se, M, ne) {
          return vt(this, se, M, ne), this;
        }
      }, {
        key: "deleteRange",
        value: function(se, M) {
          return Ot(this, se, M), this;
        }
      }, {
        key: "lift",
        value: function(se, M) {
          return He(this, se, M), this;
        }
      }, {
        key: "join",
        value: function(se) {
          var M = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return te(this, se, M), this;
        }
      }, {
        key: "wrap",
        value: function(se, M) {
          return tt(this, se, M), this;
        }
      }, {
        key: "setBlockType",
        value: function(se) {
          var M = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : se, ne = arguments.length > 2 ? arguments[2] : void 0, ce = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
          return wt(this, se, M, ne, ce), this;
        }
      }, {
        key: "setNodeMarkup",
        value: function(se, M) {
          var ne = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, ce = arguments.length > 3 ? arguments[3] : void 0;
          return qe(this, se, M, ne, ce), this;
        }
      }, {
        key: "setNodeAttribute",
        value: function(se, M, ne) {
          return this.step(new et(se, M, ne)), this;
        }
      }, {
        key: "addNodeMark",
        value: function(se, M) {
          return this.step(new Ie(se, M)), this;
        }
      }, {
        key: "removeNodeMark",
        value: function(se, M) {
          if (!(M instanceof O.Mark)) {
            var ne = this.doc.nodeAt(se);
            if (!ne) throw new RangeError("No node at position " + se);
            if (M = M.isInSet(ne.marks), !M) return this;
          }
          return this.step(new rt(se, M)), this;
        }
      }, {
        key: "split",
        value: function(se) {
          var M = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, ne = arguments.length > 2 ? arguments[2] : void 0;
          return _e(this, se, M, ne), this;
        }
      }, {
        key: "addMark",
        value: function(se, M, ne) {
          return At(this, se, M, ne), this;
        }
      }, {
        key: "removeMark",
        value: function(se, M, ne) {
          return Mt(this, se, M, ne), this;
        }
      }, {
        key: "clearIncompatible",
        value: function(se, M, ne) {
          return St(this, se, M, ne), this;
        }
      }]), $;
    }();
    i.AddMarkStep = Qe, i.AddNodeMarkStep = Ie, i.AttrStep = et, i.MapResult = de, i.Mapping = he, i.RemoveMarkStep = Me, i.RemoveNodeMarkStep = rt, i.ReplaceAroundStep = Et, i.ReplaceStep = ot, i.Step = ge, i.StepMap = Ce, i.StepResult = we, i.Transform = ft, i.canJoin = Xe, i.canSplit = pe, i.dropPoint = nt, i.findWrapping = We, i.insertPoint = De, i.joinPoint = Q, i.liftTarget = Ue, i.replaceStep = be;
  }(_j)), _j;
}
var SV;
function tk() {
  if (SV) return Po;
  SV = 1;
  function i(Ve) {
    "@babel/helpers - typeof";
    return i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(Ue) {
      return typeof Ue;
    } : function(Ue) {
      return Ue && typeof Symbol == "function" && Ue.constructor === Symbol && Ue !== Symbol.prototype ? "symbol" : typeof Ue;
    }, i(Ve);
  }
  function e() {
    return typeof Reflect < "u" && Reflect.get ? e = Reflect.get : e = function(Ue, He, We) {
      var ze = r(Ue, He);
      if (ze) {
        var at = Object.getOwnPropertyDescriptor(ze, He);
        return at.get ? at.get.call(arguments.length < 3 ? Ue : We) : at.value;
      }
    }, e.apply(this, arguments);
  }
  function r(Ve, Ue) {
    for (; !Object.prototype.hasOwnProperty.call(Ve, Ue) && (Ve = m(Ve), Ve !== null); )
      ;
    return Ve;
  }
  function s(Ve, Ue) {
    if (typeof Ue != "function" && Ue !== null)
      throw new TypeError("Super expression must either be null or a function");
    Ve.prototype = Object.create(Ue && Ue.prototype, { constructor: { value: Ve, writable: !0, configurable: !0 } }), Object.defineProperty(Ve, "prototype", { writable: !1 }), Ue && l(Ve, Ue);
  }
  function l(Ve, Ue) {
    return l = Object.setPrototypeOf || function(We, ze) {
      return We.__proto__ = ze, We;
    }, l(Ve, Ue);
  }
  function c(Ve) {
    var Ue = d();
    return function() {
      var We = m(Ve), ze;
      if (Ue) {
        var at = m(this).constructor;
        ze = Reflect.construct(We, arguments, at);
      } else
        ze = We.apply(this, arguments);
      return f(this, ze);
    };
  }
  function f(Ve, Ue) {
    if (Ue && (i(Ue) === "object" || typeof Ue == "function"))
      return Ue;
    if (Ue !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return p(Ve);
  }
  function p(Ve) {
    if (Ve === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return Ve;
  }
  function d() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function m(Ve) {
    return m = Object.setPrototypeOf ? Object.getPrototypeOf : function(He) {
      return He.__proto__ || Object.getPrototypeOf(He);
    }, m(Ve);
  }
  function y(Ve, Ue) {
    if (!(Ve instanceof Ue))
      throw new TypeError("Cannot call a class as a function");
  }
  function S(Ve, Ue) {
    for (var He = 0; He < Ue.length; He++) {
      var We = Ue[He];
      We.enumerable = We.enumerable || !1, We.configurable = !0, "value" in We && (We.writable = !0), Object.defineProperty(Ve, We.key, We);
    }
  }
  function x(Ve, Ue, He) {
    return Ue && S(Ve.prototype, Ue), He && S(Ve, He), Object.defineProperty(Ve, "prototype", { writable: !1 }), Ve;
  }
  Object.defineProperty(Po, "__esModule", {
    value: !0
  });
  var w = /* @__PURE__ */ ek(), k = /* @__PURE__ */ kW(), O = /* @__PURE__ */ Object.create(null), T = function() {
    function Ve(Ue, He, We) {
      y(this, Ve), this.$anchor = Ue, this.$head = He, this.ranges = We || [new L(Ue.min(He), Ue.max(He))];
    }
    return x(Ve, [{
      key: "anchor",
      get: function() {
        return this.$anchor.pos;
      }
    }, {
      key: "head",
      get: function() {
        return this.$head.pos;
      }
    }, {
      key: "from",
      get: function() {
        return this.$from.pos;
      }
    }, {
      key: "to",
      get: function() {
        return this.$to.pos;
      }
    }, {
      key: "$from",
      get: function() {
        return this.ranges[0].$from;
      }
    }, {
      key: "$to",
      get: function() {
        return this.ranges[0].$to;
      }
    }, {
      key: "empty",
      get: function() {
        for (var He = this.ranges, We = 0; We < He.length; We++)
          if (He[We].$from.pos != He[We].$to.pos) return !1;
        return !0;
      }
    }, {
      key: "content",
      value: function() {
        return this.$from.doc.slice(this.from, this.to, !0);
      }
    }, {
      key: "replace",
      value: function(He) {
        for (var We = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : w.Slice.empty, ze = We.content.lastChild, at = null, Ye = 0; Ye < We.openEnd; Ye++)
          at = ze, ze = ze.lastChild;
        for (var tt = He.steps.length, wt = this.ranges, Ft = 0; Ft < wt.length; Ft++) {
          var qe = wt[Ft], pe = qe.$from, _e = qe.$to, Xe = He.mapping.slice(tt);
          He.replaceRange(Xe.map(pe.pos), Xe.map(_e.pos), Ft ? w.Slice.empty : We), Ft == 0 && he(He, tt, (ze ? ze.isInline : at && at.isTextblock) ? -1 : 1);
        }
      }
    }, {
      key: "replaceWith",
      value: function(He, We) {
        for (var ze = He.steps.length, at = this.ranges, Ye = 0; Ye < at.length; Ye++) {
          var tt = at[Ye], wt = tt.$from, Ft = tt.$to, qe = He.mapping.slice(ze), pe = qe.map(wt.pos), _e = qe.map(Ft.pos);
          Ye ? He.deleteRange(pe, _e) : (He.replaceRangeWith(pe, _e, We), he(He, ze, We.isInline ? -1 : 1));
        }
      }
    }, {
      key: "getBookmark",
      value: function() {
        return J.between(this.$anchor, this.$head).getBookmark();
      }
    }], [{
      key: "findFrom",
      value: function(He, We) {
        var ze = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, at = He.parent.inlineContent ? new J(He) : Ce(He.node(0), He.parent, He.pos, He.index(), We, ze);
        if (at) return at;
        for (var Ye = He.depth - 1; Ye >= 0; Ye--) {
          var tt = We < 0 ? Ce(He.node(0), He.node(Ye), He.before(Ye + 1), He.index(Ye), We, ze) : Ce(He.node(0), He.node(Ye), He.after(Ye + 1), He.index(Ye) + 1, We, ze);
          if (tt) return tt;
        }
        return null;
      }
    }, {
      key: "near",
      value: function(He) {
        var We = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        return this.findFrom(He, We) || this.findFrom(He, -We) || new ee(He.node(0));
      }
    }, {
      key: "atStart",
      value: function(He) {
        return Ce(He, He, 0, 0, 1) || new ee(He);
      }
    }, {
      key: "atEnd",
      value: function(He) {
        return Ce(He, He, He.content.size, He.childCount, -1) || new ee(He);
      }
    }, {
      key: "fromJSON",
      value: function(He, We) {
        if (!We || !We.type) throw new RangeError("Invalid input for Selection.fromJSON");
        var ze = O[We.type];
        if (!ze) throw new RangeError("No selection type ".concat(We.type, " defined"));
        return ze.fromJSON(He, We);
      }
    }, {
      key: "jsonID",
      value: function(He, We) {
        if (He in O) throw new RangeError("Duplicate use of selection JSON ID " + He);
        return O[He] = We, We.prototype.jsonID = He, We;
      }
    }]), Ve;
  }();
  T.prototype.visible = !0;
  var L = x(function Ve(Ue, He) {
    y(this, Ve), this.$from = Ue, this.$to = He;
  }), j = !1;
  function z(Ve) {
    !j && !Ve.parent.inlineContent && (j = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + Ve.parent.type.name + ")"));
  }
  var J = function(Ve) {
    s(He, Ve);
    var Ue = c(He);
    function He(We) {
      var ze = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : We;
      return y(this, He), z(We), z(ze), Ue.call(this, We, ze);
    }
    return x(He, [{
      key: "$cursor",
      get: function() {
        return this.$anchor.pos == this.$head.pos ? this.$head : null;
      }
    }, {
      key: "map",
      value: function(ze, at) {
        var Ye = ze.resolve(at.map(this.head));
        if (!Ye.parent.inlineContent) return T.near(Ye);
        var tt = ze.resolve(at.map(this.anchor));
        return new He(tt.parent.inlineContent ? tt : Ye, Ye);
      }
    }, {
      key: "replace",
      value: function(ze) {
        var at = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : w.Slice.empty;
        if (e(m(He.prototype), "replace", this).call(this, ze, at), at == w.Slice.empty) {
          var Ye = this.$from.marksAcross(this.$to);
          Ye && ze.ensureMarks(Ye);
        }
      }
    }, {
      key: "eq",
      value: function(ze) {
        return ze instanceof He && ze.anchor == this.anchor && ze.head == this.head;
      }
    }, {
      key: "getBookmark",
      value: function() {
        return new ie(this.anchor, this.head);
      }
    }, {
      key: "toJSON",
      value: function() {
        return {
          type: "text",
          anchor: this.anchor,
          head: this.head
        };
      }
    }], [{
      key: "fromJSON",
      value: function(ze, at) {
        if (typeof at.anchor != "number" || typeof at.head != "number") throw new RangeError("Invalid input for TextSelection.fromJSON");
        return new He(ze.resolve(at.anchor), ze.resolve(at.head));
      }
    }, {
      key: "create",
      value: function(ze, at) {
        var Ye = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : at, tt = ze.resolve(at);
        return new this(tt, Ye == at ? tt : ze.resolve(Ye));
      }
    }, {
      key: "between",
      value: function(ze, at, Ye) {
        var tt = ze.pos - at.pos;
        if ((!Ye || tt) && (Ye = tt >= 0 ? 1 : -1), !at.parent.inlineContent) {
          var wt = T.findFrom(at, Ye, !0) || T.findFrom(at, -Ye, !0);
          if (wt) at = wt.$head;
          else return T.near(at, Ye);
        }
        return ze.parent.inlineContent || (tt == 0 ? ze = at : (ze = (T.findFrom(ze, -Ye, !0) || T.findFrom(ze, Ye, !0)).$anchor, ze.pos < at.pos != tt < 0 && (ze = at))), new He(ze, at);
      }
    }]), He;
  }(T);
  T.jsonID("text", J);
  var ie = function() {
    function Ve(Ue, He) {
      y(this, Ve), this.anchor = Ue, this.head = He;
    }
    return x(Ve, [{
      key: "map",
      value: function(He) {
        return new Ve(He.map(this.anchor), He.map(this.head));
      }
    }, {
      key: "resolve",
      value: function(He) {
        return J.between(He.resolve(this.anchor), He.resolve(this.head));
      }
    }]), Ve;
  }(), K = function(Ve) {
    s(He, Ve);
    var Ue = c(He);
    function He(We) {
      var ze;
      y(this, He);
      var at = We.nodeAfter, Ye = We.node(0).resolve(We.pos + at.nodeSize);
      return ze = Ue.call(this, We, Ye), ze.node = at, ze;
    }
    return x(He, [{
      key: "map",
      value: function(ze, at) {
        var Ye = at.mapResult(this.anchor), tt = Ye.deleted, wt = Ye.pos, Ft = ze.resolve(wt);
        return tt ? T.near(Ft) : new He(Ft);
      }
    }, {
      key: "content",
      value: function() {
        return new w.Slice(w.Fragment.from(this.node), 0, 0);
      }
    }, {
      key: "eq",
      value: function(ze) {
        return ze instanceof He && ze.anchor == this.anchor;
      }
    }, {
      key: "toJSON",
      value: function() {
        return {
          type: "node",
          anchor: this.anchor
        };
      }
    }, {
      key: "getBookmark",
      value: function() {
        return new re(this.anchor);
      }
    }], [{
      key: "fromJSON",
      value: function(ze, at) {
        if (typeof at.anchor != "number") throw new RangeError("Invalid input for NodeSelection.fromJSON");
        return new He(ze.resolve(at.anchor));
      }
    }, {
      key: "create",
      value: function(ze, at) {
        return new He(ze.resolve(at));
      }
    }, {
      key: "isSelectable",
      value: function(ze) {
        return !ze.isText && ze.type.spec.selectable !== !1;
      }
    }]), He;
  }(T);
  K.prototype.visible = !1, T.jsonID("node", K);
  var re = function() {
    function Ve(Ue) {
      y(this, Ve), this.anchor = Ue;
    }
    return x(Ve, [{
      key: "map",
      value: function(He) {
        var We = He.mapResult(this.anchor), ze = We.deleted, at = We.pos;
        return ze ? new ie(at, at) : new Ve(at);
      }
    }, {
      key: "resolve",
      value: function(He) {
        var We = He.resolve(this.anchor), ze = We.nodeAfter;
        return ze && K.isSelectable(ze) ? new K(We) : T.near(We);
      }
    }]), Ve;
  }(), ee = function(Ve) {
    s(He, Ve);
    var Ue = c(He);
    function He(We) {
      return y(this, He), Ue.call(this, We.resolve(0), We.resolve(We.content.size));
    }
    return x(He, [{
      key: "replace",
      value: function(ze) {
        var at = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : w.Slice.empty;
        if (at == w.Slice.empty) {
          ze.delete(0, ze.doc.content.size);
          var Ye = T.atStart(ze.doc);
          Ye.eq(ze.selection) || ze.setSelection(Ye);
        } else
          e(m(He.prototype), "replace", this).call(this, ze, at);
      }
    }, {
      key: "toJSON",
      value: function() {
        return {
          type: "all"
        };
      }
    }, {
      key: "map",
      value: function(ze) {
        return new He(ze);
      }
    }, {
      key: "eq",
      value: function(ze) {
        return ze instanceof He;
      }
    }, {
      key: "getBookmark",
      value: function() {
        return de;
      }
    }], [{
      key: "fromJSON",
      value: function(ze) {
        return new He(ze);
      }
    }]), He;
  }(T);
  T.jsonID("all", ee);
  var de = {
    map: function() {
      return this;
    },
    resolve: function(Ue) {
      return new ee(Ue);
    }
  };
  function Ce(Ve, Ue, He, We, ze) {
    var at = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1;
    if (Ue.inlineContent) return J.create(Ve, He);
    for (var Ye = We - (ze > 0 ? 0 : 1); ze > 0 ? Ye < Ue.childCount : Ye >= 0; Ye += ze) {
      var tt = Ue.child(Ye);
      if (tt.isAtom) {
        if (!at && K.isSelectable(tt))
          return K.create(Ve, He - (ze < 0 ? tt.nodeSize : 0));
      } else {
        var wt = Ce(Ve, tt, He + ze, ze < 0 ? tt.childCount : 0, ze, at);
        if (wt) return wt;
      }
      He += tt.nodeSize * ze;
    }
    return null;
  }
  function he(Ve, Ue, He) {
    var We = Ve.steps.length - 1;
    if (!(We < Ue)) {
      var ze = Ve.steps[We];
      if (ze instanceof k.ReplaceStep || ze instanceof k.ReplaceAroundStep) {
        var at = Ve.mapping.maps[We], Ye;
        at.forEach(function(tt, wt, Ft, qe) {
          Ye == null && (Ye = qe);
        }), Ve.setSelection(T.near(Ve.doc.resolve(Ye), He));
      }
    }
  }
  var oe = 1, ge = 2, we = 4, Oe = function(Ve) {
    s(He, Ve);
    var Ue = c(He);
    function He(We) {
      var ze;
      return y(this, He), ze = Ue.call(this, We.doc), ze.curSelectionFor = 0, ze.updated = 0, ze.meta = /* @__PURE__ */ Object.create(null), ze.time = Date.now(), ze.curSelection = We.selection, ze.storedMarks = We.storedMarks, ze;
    }
    return x(He, [{
      key: "selection",
      get: function() {
        return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
      }
    }, {
      key: "setSelection",
      value: function(ze) {
        if (ze.$from.doc != this.doc) throw new RangeError("Selection passed to setSelection must point at the current document");
        return this.curSelection = ze, this.curSelectionFor = this.steps.length, this.updated = (this.updated | oe) & -3, this.storedMarks = null, this;
      }
    }, {
      key: "selectionSet",
      get: function() {
        return (this.updated & oe) > 0;
      }
    }, {
      key: "setStoredMarks",
      value: function(ze) {
        return this.storedMarks = ze, this.updated |= ge, this;
      }
    }, {
      key: "ensureMarks",
      value: function(ze) {
        return w.Mark.sameSet(this.storedMarks || this.selection.$from.marks(), ze) || this.setStoredMarks(ze), this;
      }
    }, {
      key: "addStoredMark",
      value: function(ze) {
        return this.ensureMarks(ze.addToSet(this.storedMarks || this.selection.$head.marks()));
      }
    }, {
      key: "removeStoredMark",
      value: function(ze) {
        return this.ensureMarks(ze.removeFromSet(this.storedMarks || this.selection.$head.marks()));
      }
    }, {
      key: "storedMarksSet",
      get: function() {
        return (this.updated & ge) > 0;
      }
    }, {
      key: "addStep",
      value: function(ze, at) {
        e(m(He.prototype), "addStep", this).call(this, ze, at), this.updated = this.updated & -3, this.storedMarks = null;
      }
    }, {
      key: "setTime",
      value: function(ze) {
        return this.time = ze, this;
      }
    }, {
      key: "replaceSelection",
      value: function(ze) {
        return this.selection.replace(this, ze), this;
      }
    }, {
      key: "replaceSelectionWith",
      value: function(ze) {
        var at = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, Ye = this.selection;
        return at && (ze = ze.mark(this.storedMarks || (Ye.empty ? Ye.$from.marks() : Ye.$from.marksAcross(Ye.$to) || w.Mark.none))), Ye.replaceWith(this, ze), this;
      }
    }, {
      key: "deleteSelection",
      value: function() {
        return this.selection.replace(this), this;
      }
    }, {
      key: "insertText",
      value: function(ze, at, Ye) {
        var tt = this.doc.type.schema;
        if (at == null)
          return ze ? this.replaceSelectionWith(tt.text(ze), !0) : this.deleteSelection();
        if (Ye == null && (Ye = at), Ye = Ye ?? at, !ze) return this.deleteRange(at, Ye);
        var wt = this.storedMarks;
        if (!wt) {
          var Ft = this.doc.resolve(at);
          wt = Ye == at ? Ft.marks() : Ft.marksAcross(this.doc.resolve(Ye));
        }
        return this.replaceRangeWith(at, Ye, tt.text(ze, wt)), this.selection.empty || this.setSelection(T.near(this.selection.$to)), this;
      }
    }, {
      key: "setMeta",
      value: function(ze, at) {
        return this.meta[typeof ze == "string" ? ze : ze.key] = at, this;
      }
    }, {
      key: "getMeta",
      value: function(ze) {
        return this.meta[typeof ze == "string" ? ze : ze.key];
      }
    }, {
      key: "isGeneric",
      get: function() {
        for (var ze in this.meta)
          return !1;
        return !0;
      }
    }, {
      key: "scrollIntoView",
      value: function() {
        return this.updated |= we, this;
      }
    }, {
      key: "scrolledIntoView",
      get: function() {
        return (this.updated & we) > 0;
      }
    }]), He;
  }(k.Transform);
  function Qe(Ve, Ue) {
    return !Ue || !Ve ? Ve : Ve.bind(Ue);
  }
  var Me = x(function Ve(Ue, He, We) {
    y(this, Ve), this.name = Ue, this.init = Qe(He.init, We), this.apply = Qe(He.apply, We);
  }), Ie = [new Me("doc", {
    init: function(Ue) {
      return Ue.doc || Ue.schema.topNodeType.createAndFill();
    },
    apply: function(Ue) {
      return Ue.doc;
    }
  }), new Me("selection", {
    init: function(Ue, He) {
      return Ue.selection || T.atStart(He.doc);
    },
    apply: function(Ue) {
      return Ue.selection;
    }
  }), new Me("storedMarks", {
    init: function(Ue) {
      return Ue.storedMarks || null;
    },
    apply: function(Ue, He, We, ze) {
      return ze.selection.$cursor ? Ue.storedMarks : null;
    }
  }), new Me("scrollToSelection", {
    init: function() {
      return 0;
    },
    apply: function(Ue, He) {
      return Ue.scrolledIntoView ? He + 1 : He;
    }
  })], rt = x(function Ve(Ue, He) {
    var We = this;
    y(this, Ve), this.schema = Ue, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = Ie.slice(), He && He.forEach(function(ze) {
      if (We.pluginsByKey[ze.key]) throw new RangeError("Adding different instances of a keyed plugin (" + ze.key + ")");
      We.plugins.push(ze), We.pluginsByKey[ze.key] = ze, ze.spec.state && We.fields.push(new Me(ze.key, ze.spec.state, ze));
    });
  }), ot = function() {
    function Ve(Ue) {
      y(this, Ve), this.config = Ue;
    }
    return x(Ve, [{
      key: "schema",
      get: function() {
        return this.config.schema;
      }
    }, {
      key: "plugins",
      get: function() {
        return this.config.plugins;
      }
    }, {
      key: "apply",
      value: function(He) {
        return this.applyTransaction(He).state;
      }
    }, {
      key: "filterTransaction",
      value: function(He) {
        for (var We = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1, ze = 0; ze < this.config.plugins.length; ze++)
          if (ze != We) {
            var at = this.config.plugins[ze];
            if (at.spec.filterTransaction && !at.spec.filterTransaction.call(at, He, this)) return !1;
          }
        return !0;
      }
    }, {
      key: "applyTransaction",
      value: function(He) {
        if (!this.filterTransaction(He)) return {
          state: this,
          transactions: []
        };
        for (var We = [He], ze = this.applyInner(He), at = null; ; ) {
          for (var Ye = !1, tt = 0; tt < this.config.plugins.length; tt++) {
            var wt = this.config.plugins[tt];
            if (wt.spec.appendTransaction) {
              var Ft = at ? at[tt].n : 0, qe = at ? at[tt].state : this, pe = Ft < We.length && wt.spec.appendTransaction.call(wt, Ft ? We.slice(Ft) : We, qe, ze);
              if (pe && ze.filterTransaction(pe, tt)) {
                if (pe.setMeta("appendedTransaction", He), !at) {
                  at = [];
                  for (var _e = 0; _e < this.config.plugins.length; _e++)
                    at.push(_e < tt ? {
                      state: ze,
                      n: We.length
                    } : {
                      state: this,
                      n: 0
                    });
                }
                We.push(pe), ze = ze.applyInner(pe), Ye = !0;
              }
              at && (at[tt] = {
                state: ze,
                n: We.length
              });
            }
          }
          if (!Ye) return {
            state: ze,
            transactions: We
          };
        }
      }
    }, {
      key: "applyInner",
      value: function(He) {
        if (!He.before.eq(this.doc)) throw new RangeError("Applying a mismatched transaction");
        for (var We = new Ve(this.config), ze = this.config.fields, at = 0; at < ze.length; at++) {
          var Ye = ze[at];
          We[Ye.name] = Ye.apply(He, this[Ye.name], this, We);
        }
        return We;
      }
    }, {
      key: "tr",
      get: function() {
        return new Oe(this);
      }
    }, {
      key: "reconfigure",
      value: function(He) {
        for (var We = new rt(this.schema, He.plugins), ze = We.fields, at = new Ve(We), Ye = 0; Ye < ze.length; Ye++) {
          var tt = ze[Ye].name;
          at[tt] = this.hasOwnProperty(tt) ? this[tt] : ze[Ye].init(He, at);
        }
        return at;
      }
    }, {
      key: "toJSON",
      value: function(He) {
        var We = {
          doc: this.doc.toJSON(),
          selection: this.selection.toJSON()
        };
        if (this.storedMarks && (We.storedMarks = this.storedMarks.map(function(tt) {
          return tt.toJSON();
        })), He && i(He) == "object") for (var ze in He) {
          if (ze == "doc" || ze == "selection") throw new RangeError("The JSON fields `doc` and `selection` are reserved");
          var at = He[ze], Ye = at.spec.state;
          Ye && Ye.toJSON && (We[ze] = Ye.toJSON.call(at, this[at.key]));
        }
        return We;
      }
    }], [{
      key: "create",
      value: function(He) {
        for (var We = new rt(He.doc ? He.doc.type.schema : He.schema, He.plugins), ze = new Ve(We), at = 0; at < We.fields.length; at++)
          ze[We.fields[at].name] = We.fields[at].init(He, ze);
        return ze;
      }
    }, {
      key: "fromJSON",
      value: function(He, We, ze) {
        if (!We) throw new RangeError("Invalid input for EditorState.fromJSON");
        if (!He.schema) throw new RangeError("Required config field 'schema' missing");
        var at = new rt(He.schema, He.plugins), Ye = new Ve(at);
        return at.fields.forEach(function(tt) {
          if (tt.name == "doc")
            Ye.doc = w.Node.fromJSON(He.schema, We.doc);
          else if (tt.name == "selection")
            Ye.selection = T.fromJSON(Ye.doc, We.selection);
          else if (tt.name == "storedMarks")
            We.storedMarks && (Ye.storedMarks = We.storedMarks.map(He.schema.markFromJSON));
          else {
            if (ze) for (var wt in ze) {
              var Ft = ze[wt], qe = Ft.spec.state;
              if (Ft.key == tt.name && qe && qe.fromJSON && Object.prototype.hasOwnProperty.call(We, wt)) {
                Ye[tt.name] = qe.fromJSON.call(Ft, He, We[wt], Ye);
                return;
              }
            }
            Ye[tt.name] = tt.init(He, Ye);
          }
        }), Ye;
      }
    }]), Ve;
  }();
  function Et(Ve, Ue, He) {
    for (var We in Ve) {
      var ze = Ve[We];
      ze instanceof Function ? ze = ze.bind(Ue) : We == "handleDOMEvents" && (ze = Et(ze, Ue, {})), He[We] = ze;
    }
    return He;
  }
  var gt = function() {
    function Ve(Ue) {
      y(this, Ve), this.spec = Ue, this.props = {}, Ue.props && Et(Ue.props, this, this.props), this.key = Ue.key ? Ue.key.key : Mt("plugin");
    }
    return x(Ve, [{
      key: "getState",
      value: function(He) {
        return He[this.key];
      }
    }]), Ve;
  }(), At = /* @__PURE__ */ Object.create(null);
  function Mt(Ve) {
    return Ve in At ? Ve + "$" + ++At[Ve] : (At[Ve] = 0, Ve + "$");
  }
  var St = function() {
    function Ve() {
      var Ue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "key";
      y(this, Ve), this.key = Mt(Ue);
    }
    return x(Ve, [{
      key: "get",
      value: function(He) {
        return He.config.pluginsByKey[this.key];
      }
    }, {
      key: "getState",
      value: function(He) {
        return He[this.key];
      }
    }]), Ve;
  }();
  return Po.AllSelection = ee, Po.EditorState = ot, Po.NodeSelection = K, Po.Plugin = gt, Po.PluginKey = St, Po.Selection = T, Po.SelectionRange = L, Po.TextSelection = J, Po.Transaction = Oe, Po;
}
var wV;
function wGe() {
  if (wV) return pa;
  wV = 1;
  function i(z, J, ie) {
    return Object.defineProperty(z, "prototype", { writable: !1 }), z;
  }
  function e(z, J) {
    if (!(z instanceof J))
      throw new TypeError("Cannot call a class as a function");
  }
  Object.defineProperty(pa, "__esModule", {
    value: !0
  });
  var r = /* @__PURE__ */ tk(), s = /* @__PURE__ */ kW(), l = i(function z(J, ie) {
    e(this, z), this.match = J, this.match = J, this.handler = typeof ie == "string" ? c(ie) : ie;
  });
  function c(z) {
    return function(J, ie, K, re) {
      var ee = z;
      if (ie[1]) {
        var de = ie[0].lastIndexOf(ie[1]);
        ee += ie[0].slice(de + ie[1].length), K += de;
        var Ce = K - re;
        Ce > 0 && (ee = ie[0].slice(de - Ce, de) + ee, K = re);
      }
      return J.tr.insertText(ee, K, re);
    };
  }
  var f = 500;
  function p(z) {
    var J = z.rules, ie = new r.Plugin({
      state: {
        init: function() {
          return null;
        },
        apply: function(re, ee) {
          var de = re.getMeta(this);
          return de || (re.selectionSet || re.docChanged ? null : ee);
        }
      },
      props: {
        handleTextInput: function(re, ee, de, Ce) {
          return d(re, ee, de, Ce, J, ie);
        },
        handleDOMEvents: {
          compositionend: function(re) {
            setTimeout(function() {
              var ee = re.state.selection.$cursor;
              ee && d(re, ee.pos, ee.pos, "", J, ie);
            });
          }
        }
      },
      isInputRules: !0
    });
    return ie;
  }
  function d(z, J, ie, K, re, ee) {
    if (z.composing) return !1;
    var de = z.state, Ce = de.doc.resolve(J);
    if (Ce.parent.type.spec.code) return !1;
    for (var he = Ce.parent.textBetween(Math.max(0, Ce.parentOffset - f), Ce.parentOffset, null, "￼") + K, oe = 0; oe < re.length; oe++) {
      var ge = re[oe].match.exec(he), we = ge && re[oe].handler(de, ge, J - (ge[0].length - K.length), ie);
      if (we)
        return z.dispatch(we.setMeta(ee, {
          transform: we,
          from: J,
          to: ie,
          text: K
        })), !0;
    }
    return !1;
  }
  var m = function(J, ie) {
    for (var K = J.plugins, re = 0; re < K.length; re++) {
      var ee = K[re], de = void 0;
      if (ee.spec.isInputRules && (de = ee.getState(J))) {
        if (ie) {
          for (var Ce = J.tr, he = de.transform, oe = he.steps.length - 1; oe >= 0; oe--)
            Ce.step(he.steps[oe].invert(he.docs[oe]));
          if (de.text) {
            var ge = Ce.doc.resolve(de.from).marks();
            Ce.replaceWith(de.from, de.to, J.schema.text(de.text, ge));
          } else
            Ce.delete(de.from, de.to);
          ie(Ce);
        }
        return !0;
      }
    }
    return !1;
  }, y = new l(/--$/, "—"), S = new l(/\.\.\.$/, "…"), x = new l(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "“"), w = new l(/"$/, "”"), k = new l(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "‘"), O = new l(/'$/, "’"), T = [x, w, k, O];
  function L(z, J) {
    var ie = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, K = arguments.length > 3 ? arguments[3] : void 0;
    return new l(z, function(re, ee, de, Ce) {
      var he = ie instanceof Function ? ie(ee) : ie, oe = re.tr.delete(de, Ce), ge = oe.doc.resolve(de), we = ge.blockRange(), Oe = we && s.findWrapping(we, J, he);
      if (!Oe) return null;
      oe.wrap(we, Oe);
      var Qe = oe.doc.resolve(de - 1).nodeBefore;
      return Qe && Qe.type == J && s.canJoin(oe.doc, de - 1) && (!K || K(ee, Qe)) && oe.join(de - 1), oe;
    });
  }
  function j(z, J) {
    var ie = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    return new l(z, function(K, re, ee, de) {
      var Ce = K.doc.resolve(ee), he = ie instanceof Function ? ie(re) : ie;
      return Ce.node(-1).canReplaceWith(Ce.index(-1), Ce.indexAfter(-1), J) ? K.tr.delete(ee, de).setBlockType(ee, ee, J, he) : null;
    });
  }
  return pa.InputRule = l, pa.closeDoubleQuote = w, pa.closeSingleQuote = O, pa.ellipsis = S, pa.emDash = y, pa.inputRules = p, pa.openDoubleQuote = x, pa.openSingleQuote = k, pa.smartQuotes = T, pa.textblockTypeInputRule = j, pa.undoInputRule = m, pa.wrappingInputRule = L, pa;
}
var Bg = {}, Qh = {}, xV;
function xGe() {
  if (xV) return Qh;
  xV = 1, Object.defineProperty(Qh, "__esModule", { value: !0 });
  for (var i = {
    8: "Backspace",
    9: "Tab",
    10: "Enter",
    12: "NumLock",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    44: "PrintScreen",
    45: "Insert",
    46: "Delete",
    59: ";",
    61: "=",
    91: "Meta",
    92: "Meta",
    106: "*",
    107: "+",
    108: ",",
    109: "-",
    110: ".",
    111: "/",
    144: "NumLock",
    145: "ScrollLock",
    160: "Shift",
    161: "Shift",
    162: "Control",
    163: "Control",
    164: "Alt",
    165: "Alt",
    173: "-",
    186: ";",
    187: "=",
    188: ",",
    189: "-",
    190: ".",
    191: "/",
    192: "`",
    219: "[",
    220: "\\",
    221: "]",
    222: "'"
  }, e = {
    48: ")",
    49: "!",
    50: "@",
    51: "#",
    52: "$",
    53: "%",
    54: "^",
    55: "&",
    56: "*",
    57: "(",
    59: ":",
    61: "+",
    173: "_",
    186: ":",
    187: "+",
    188: "<",
    189: "_",
    190: ">",
    191: "?",
    192: "~",
    219: "{",
    220: "|",
    221: "}",
    222: '"'
  }, r = typeof navigator < "u" && /Mac/.test(navigator.platform), s = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent), l = 0; l < 10; l++) i[48 + l] = i[96 + l] = String(l);
  for (var l = 1; l <= 24; l++) i[l + 111] = "F" + l;
  for (var l = 65; l <= 90; l++)
    i[l] = String.fromCharCode(l + 32), e[l] = String.fromCharCode(l);
  for (var c in i) e.hasOwnProperty(c) || (e[c] = i[c]);
  function f(p) {
    var d = r && p.metaKey && p.shiftKey && !p.ctrlKey && !p.altKey || s && p.shiftKey && p.key && p.key.length == 1 || p.key == "Unidentified", m = !d && p.key || (p.shiftKey ? e : i)[p.keyCode] || p.key || "Unidentified";
    return m == "Esc" && (m = "Escape"), m == "Del" && (m = "Delete"), m == "Left" && (m = "ArrowLeft"), m == "Up" && (m = "ArrowUp"), m == "Right" && (m = "ArrowRight"), m == "Down" && (m = "ArrowDown"), m;
  }
  return Qh.base = i, Qh.keyName = f, Qh.shift = e, Qh;
}
var kV;
function kGe() {
  if (kV) return Bg;
  kV = 1, Object.defineProperty(Bg, "__esModule", {
    value: !0
  });
  var i = xGe(), e = /* @__PURE__ */ tk(), r = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
  function s(d) {
    var m = d.split(/-(?!$)/), y = m[m.length - 1];
    y == "Space" && (y = " ");
    for (var S, x, w, k, O = 0; O < m.length - 1; O++) {
      var T = m[O];
      if (/^(cmd|meta|m)$/i.test(T)) k = !0;
      else if (/^a(lt)?$/i.test(T)) S = !0;
      else if (/^(c|ctrl|control)$/i.test(T)) x = !0;
      else if (/^s(hift)?$/i.test(T)) w = !0;
      else if (/^mod$/i.test(T))
        r ? k = !0 : x = !0;
      else throw new Error("Unrecognized modifier name: " + T);
    }
    return S && (y = "Alt-" + y), x && (y = "Ctrl-" + y), k && (y = "Meta-" + y), w && (y = "Shift-" + y), y;
  }
  function l(d) {
    var m = /* @__PURE__ */ Object.create(null);
    for (var y in d)
      m[s(y)] = d[y];
    return m;
  }
  function c(d, m) {
    var y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
    return m.altKey && (d = "Alt-" + d), m.ctrlKey && (d = "Ctrl-" + d), m.metaKey && (d = "Meta-" + d), y && m.shiftKey && (d = "Shift-" + d), d;
  }
  function f(d) {
    return new e.Plugin({
      props: {
        handleKeyDown: p(d)
      }
    });
  }
  function p(d) {
    var m = l(d);
    return function(y, S) {
      var x = i.keyName(S), w, k = m[c(x, S)];
      if (k && k(y.state, y.dispatch, y)) return !0;
      if (x.length == 1 && x != " ") {
        if (S.shiftKey) {
          var O = m[c(x, S, !1)];
          if (O && O(y.state, y.dispatch, y)) return !0;
        }
        if ((S.shiftKey || S.altKey || S.metaKey || x.charCodeAt(0) > 127) && (w = i.base[S.keyCode]) && w != x) {
          var T = m[c(w, S)];
          if (T && T(y.state, y.dispatch, y)) return !0;
        }
      }
      return !1;
    };
  }
  return Bg.keydownHandler = p, Bg.keymap = f, Bg;
}
var vl = {}, OV;
function OGe() {
  if (OV) return vl;
  OV = 1;
  function i(A) {
    "@babel/helpers - typeof";
    return i = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(B) {
      return typeof B;
    } : function(B) {
      return B && typeof Symbol == "function" && B.constructor === Symbol && B !== Symbol.prototype ? "symbol" : typeof B;
    }, i(A);
  }
  function e(A, B) {
    var E = typeof Symbol < "u" && A[Symbol.iterator] || A["@@iterator"];
    if (!E) {
      if (Array.isArray(A) || (E = r(A)) || B) {
        E && (A = E);
        var N = 0, H = function() {
        };
        return { s: H, n: function() {
          return N >= A.length ? { done: !0 } : { done: !1, value: A[N++] };
        }, e: function($e) {
          throw $e;
        }, f: H };
      }
      throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
    }
    var Y = !0, le = !1, me;
    return { s: function() {
      E = E.call(A);
    }, n: function() {
      var $e = E.next();
      return Y = $e.done, $e;
    }, e: function($e) {
      le = !0, me = $e;
    }, f: function() {
      try {
        !Y && E.return != null && E.return();
      } finally {
        if (le) throw me;
      }
    } };
  }
  function r(A, B) {
    if (A) {
      if (typeof A == "string") return s(A, B);
      var E = Object.prototype.toString.call(A).slice(8, -1);
      if (E === "Object" && A.constructor && (E = A.constructor.name), E === "Map" || E === "Set") return Array.from(A);
      if (E === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(E)) return s(A, B);
    }
  }
  function s(A, B) {
    (B == null || B > A.length) && (B = A.length);
    for (var E = 0, N = new Array(B); E < B; E++)
      N[E] = A[E];
    return N;
  }
  function l() {
    return typeof Reflect < "u" && Reflect.get ? l = Reflect.get : l = function(B, E, N) {
      var H = c(B, E);
      if (H) {
        var Y = Object.getOwnPropertyDescriptor(H, E);
        return Y.get ? Y.get.call(arguments.length < 3 ? B : N) : Y.value;
      }
    }, l.apply(this, arguments);
  }
  function c(A, B) {
    for (; !Object.prototype.hasOwnProperty.call(A, B) && (A = x(A), A !== null); )
      ;
    return A;
  }
  function f(A, B) {
    if (typeof B != "function" && B !== null)
      throw new TypeError("Super expression must either be null or a function");
    A.prototype = Object.create(B && B.prototype, { constructor: { value: A, writable: !0, configurable: !0 } }), Object.defineProperty(A, "prototype", { writable: !1 }), B && p(A, B);
  }
  function p(A, B) {
    return p = Object.setPrototypeOf || function(N, H) {
      return N.__proto__ = H, N;
    }, p(A, B);
  }
  function d(A) {
    var B = S();
    return function() {
      var N = x(A), H;
      if (B) {
        var Y = x(this).constructor;
        H = Reflect.construct(N, arguments, Y);
      } else
        H = N.apply(this, arguments);
      return m(this, H);
    };
  }
  function m(A, B) {
    if (B && (i(B) === "object" || typeof B == "function"))
      return B;
    if (B !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return y(A);
  }
  function y(A) {
    if (A === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return A;
  }
  function S() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function x(A) {
    return x = Object.setPrototypeOf ? Object.getPrototypeOf : function(E) {
      return E.__proto__ || Object.getPrototypeOf(E);
    }, x(A);
  }
  function w(A, B) {
    if (!(A instanceof B))
      throw new TypeError("Cannot call a class as a function");
  }
  function k(A, B) {
    for (var E = 0; E < B.length; E++) {
      var N = B[E];
      N.enumerable = N.enumerable || !1, N.configurable = !0, "value" in N && (N.writable = !0), Object.defineProperty(A, N.key, N);
    }
  }
  function O(A, B, E) {
    return B && k(A.prototype, B), E && k(A, E), Object.defineProperty(A, "prototype", { writable: !1 }), A;
  }
  Object.defineProperty(vl, "__esModule", {
    value: !0
  });
  var T = /* @__PURE__ */ tk(), L = /* @__PURE__ */ ek(), j = /* @__PURE__ */ kW(), z = function(B) {
    for (var E = 0; ; E++)
      if (B = B.previousSibling, !B) return E;
  }, J = function(B) {
    var E = B.assignedSlot || B.parentNode;
    return E && E.nodeType == 11 ? E.host : E;
  }, ie = null, K = function(B, E, N) {
    var H = ie || (ie = document.createRange());
    return H.setEnd(B, N ?? B.nodeValue.length), H.setStart(B, E || 0), H;
  }, re = function(B, E, N, H) {
    return N && (de(B, E, N, H, -1) || de(B, E, N, H, 1));
  }, ee = /^(img|br|input|textarea|hr)$/i;
  function de(A, B, E, N, H) {
    for (; ; ) {
      if (A == E && B == N) return !0;
      if (B == (H < 0 ? 0 : Ce(A))) {
        var Y = A.parentNode;
        if (!Y || Y.nodeType != 1 || oe(A) || ee.test(A.nodeName) || A.contentEditable == "false") return !1;
        B = z(A) + (H < 0 ? 0 : 1), A = Y;
      } else if (A.nodeType == 1) {
        if (A = A.childNodes[B + (H < 0 ? -1 : 0)], A.contentEditable == "false") return !1;
        B = H < 0 ? Ce(A) : 0;
      } else
        return !1;
    }
  }
  function Ce(A) {
    return A.nodeType == 3 ? A.nodeValue.length : A.childNodes.length;
  }
  function he(A, B, E) {
    for (var N = B == 0, H = B == Ce(A); N || H; ) {
      if (A == E) return !0;
      var Y = z(A);
      if (A = A.parentNode, !A) return !1;
      N = N && Y == 0, H = H && Y == Ce(A);
    }
  }
  function oe(A) {
    for (var B, E = A; E && !(B = E.pmViewDesc); E = E.parentNode)
      ;
    return B && B.node && B.node.isBlock && (B.dom == A || B.contentDOM == A);
  }
  var ge = function(B) {
    return B.focusNode && re(B.focusNode, B.focusOffset, B.anchorNode, B.anchorOffset);
  };
  function we(A, B) {
    var E = document.createEvent("Event");
    return E.initEvent("keydown", !0, !0), E.keyCode = A, E.key = E.code = B, E;
  }
  function Oe(A) {
    for (var B = A.activeElement; B && B.shadowRoot; )
      B = B.shadowRoot.activeElement;
    return B;
  }
  function Qe(A, B, E) {
    if (A.caretPositionFromPoint)
      try {
        var N = A.caretPositionFromPoint(B, E);
        if (N) return {
          node: N.offsetNode,
          offset: N.offset
        };
      } catch {
      }
    if (A.caretRangeFromPoint) {
      var H = A.caretRangeFromPoint(B, E);
      if (H) return {
        node: H.startContainer,
        offset: H.startOffset
      };
    }
  }
  var Me = typeof navigator < "u" ? navigator : null, Ie = typeof document < "u" ? document : null, rt = Me && Me.userAgent || "", ot = /Edge\/(\d+)/.exec(rt), Et = /MSIE \d/.exec(rt), gt = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(rt), At = !!(Et || gt || ot), Mt = Et ? document.documentMode : gt ? +gt[1] : ot ? +ot[1] : 0, St = !At && /gecko\/(\d+)/i.test(rt);
  St && +(/Firefox\/(\d+)/.exec(rt) || [0, 0])[1];
  var Ve = !At && /Chrome\/(\d+)/.exec(rt), Ue = !!Ve, He = Ve ? +Ve[1] : 0, We = !At && !!Me && /Apple Computer/.test(Me.vendor), ze = We && (/Mobile\/\w+/.test(rt) || !!Me && Me.maxTouchPoints > 2), at = ze || (Me ? /Mac/.test(Me.platform) : !1), Ye = Me ? /Win/.test(Me.platform) : !1, tt = /Android \d/.test(rt), wt = !!Ie && "webkitFontSmoothing" in Ie.documentElement.style, Ft = wt ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
  function qe(A) {
    return {
      left: 0,
      right: A.documentElement.clientWidth,
      top: 0,
      bottom: A.documentElement.clientHeight
    };
  }
  function pe(A, B) {
    return typeof A == "number" ? A : A[B];
  }
  function _e(A) {
    var B = A.getBoundingClientRect(), E = B.width / A.offsetWidth || 1, N = B.height / A.offsetHeight || 1;
    return {
      left: B.left,
      right: B.left + A.clientWidth * E,
      top: B.top,
      bottom: B.top + A.clientHeight * N
    };
  }
  function Xe(A, B, E) {
    for (var N = A.someProp("scrollThreshold") || 0, H = A.someProp("scrollMargin") || 5, Y = A.dom.ownerDocument, le = E || A.dom; le; le = J(le))
      if (le.nodeType == 1) {
        var me = le, Pe = me == Y.body, $e = Pe ? qe(Y) : _e(me), st = 0, Tt = 0;
        if (B.top < $e.top + pe(N, "top") ? Tt = -($e.top - B.top + pe(H, "top")) : B.bottom > $e.bottom - pe(N, "bottom") && (Tt = B.bottom - B.top > $e.bottom - $e.top ? B.top + pe(H, "top") - $e.top : B.bottom - $e.bottom + pe(H, "bottom")), B.left < $e.left + pe(N, "left") ? st = -($e.left - B.left + pe(H, "left")) : B.right > $e.right - pe(N, "right") && (st = B.right - $e.right + pe(H, "right")), st || Tt)
          if (Pe)
            Y.defaultView.scrollBy(st, Tt);
          else {
            var ht = me.scrollLeft, _t = me.scrollTop;
            Tt && (me.scrollTop += Tt), st && (me.scrollLeft += st);
            var Ht = me.scrollLeft - ht, nr = me.scrollTop - _t;
            B = {
              left: B.left - Ht,
              top: B.top - nr,
              right: B.right - Ht,
              bottom: B.bottom - nr
            };
          }
        if (Pe || /^(fixed|sticky)$/.test(getComputedStyle(le).position)) break;
      }
  }
  function lt(A) {
    for (var B = A.dom.getBoundingClientRect(), E = Math.max(0, B.top), N, H, Y = (B.left + B.right) / 2, le = E + 1; le < Math.min(innerHeight, B.bottom); le += 5) {
      var me = A.root.elementFromPoint(Y, le);
      if (!(!me || me == A.dom || !A.dom.contains(me))) {
        var Pe = me.getBoundingClientRect();
        if (Pe.top >= E - 20) {
          N = me, H = Pe.top;
          break;
        }
      }
    }
    return {
      refDOM: N,
      refTop: H,
      stack: Q(A.dom)
    };
  }
  function Q(A) {
    for (var B = [], E = A.ownerDocument, N = A; N && (B.push({
      dom: N,
      top: N.scrollTop,
      left: N.scrollLeft
    }), A != E); N = J(N))
      ;
    return B;
  }
  function te(A) {
    var B = A.refDOM, E = A.refTop, N = A.stack, H = B ? B.getBoundingClientRect().top : 0;
    De(N, H == 0 ? 0 : H - E);
  }
  function De(A, B) {
    for (var E = 0; E < A.length; E++) {
      var N = A[E], H = N.dom, Y = N.top, le = N.left;
      H.scrollTop != Y + B && (H.scrollTop = Y + B), H.scrollLeft != le && (H.scrollLeft = le);
    }
  }
  var nt = null;
  function be(A) {
    if (A.setActive) return A.setActive();
    if (nt) return A.focus(nt);
    var B = Q(A);
    A.focus(nt == null ? {
      get preventScroll() {
        return nt = {
          preventScroll: !0
        }, !0;
      }
    } : void 0), nt || (nt = !1, De(B, 0));
  }
  function G(A, B) {
    for (var E, N = 2e8, H, Y = 0, le = B.top, me = B.top, Pe, $e, st = A.firstChild, Tt = 0; st; st = st.nextSibling, Tt++) {
      var ht = void 0;
      if (st.nodeType == 1) ht = st.getClientRects();
      else if (st.nodeType == 3) ht = K(st).getClientRects();
      else continue;
      for (var _t = 0; _t < ht.length; _t++) {
        var Ht = ht[_t];
        if (Ht.top <= le && Ht.bottom >= me) {
          le = Math.max(Ht.bottom, le), me = Math.min(Ht.top, me);
          var nr = Ht.left > B.left ? Ht.left - B.left : Ht.right < B.left ? B.left - Ht.right : 0;
          if (nr < N) {
            E = st, N = nr, H = nr && E.nodeType == 3 ? {
              left: Ht.right < B.left ? Ht.right : Ht.left,
              top: B.top
            } : B, st.nodeType == 1 && nr && (Y = Tt + (B.left >= (Ht.left + Ht.right) / 2 ? 1 : 0));
            continue;
          }
        } else Ht.top > B.top && !Pe && Ht.left <= B.left && Ht.right >= B.left && (Pe = st, $e = {
          left: Math.max(Ht.left, Math.min(Ht.right, B.left)),
          top: Ht.top
        });
        !E && (B.left >= Ht.right && B.top >= Ht.top || B.left >= Ht.left && B.top >= Ht.bottom) && (Y = Tt + 1);
      }
    }
    return !E && Pe && (E = Pe, H = $e, N = 0), E && E.nodeType == 3 ? V(E, H) : !E || N && E.nodeType == 1 ? {
      node: A,
      offset: Y
    } : G(E, H);
  }
  function V(A, B) {
    for (var E = A.nodeValue.length, N = document.createRange(), H = 0; H < E; H++) {
      N.setEnd(A, H + 1), N.setStart(A, H);
      var Y = Xt(N, 1);
      if (Y.top != Y.bottom && ve(B, Y))
        return {
          node: A,
          offset: H + (B.left >= (Y.left + Y.right) / 2 ? 1 : 0)
        };
    }
    return {
      node: A,
      offset: 0
    };
  }
  function ve(A, B) {
    return A.left >= B.left - 1 && A.left <= B.right + 1 && A.top >= B.top - 1 && A.top <= B.bottom + 1;
  }
  function Ne(A, B) {
    var E = A.parentNode;
    return E && /^li$/i.test(E.nodeName) && B.left < A.getBoundingClientRect().left ? E : A;
  }
  function it(A, B, E) {
    var N = G(B, E), H = N.node, Y = N.offset, le = -1;
    if (H.nodeType == 1 && !H.firstChild) {
      var me = H.getBoundingClientRect();
      le = me.left != me.right && E.left > (me.left + me.right) / 2 ? 1 : -1;
    }
    return A.docView.posFromDOM(H, Y, le);
  }
  function yt(A, B, E, N) {
    for (var H = -1, Y = B, le = !1; Y != A.dom; ) {
      var me = A.docView.nearestDesc(Y, !0);
      if (!me) return null;
      if (me.dom.nodeType == 1 && (me.node.isBlock && me.parent && !le || !me.contentDOM)) {
        var Pe = me.dom.getBoundingClientRect();
        if (me.node.isBlock && me.parent && !le && (le = !0, Pe.left > N.left || Pe.top > N.top ? H = me.posBefore : (Pe.right < N.left || Pe.bottom < N.top) && (H = me.posAfter)), !me.contentDOM && H < 0 && !me.node.isText) {
          var $e = me.node.isBlock ? N.top < (Pe.top + Pe.bottom) / 2 : N.left < (Pe.left + Pe.right) / 2;
          return $e ? me.posBefore : me.posAfter;
        }
      }
      Y = me.dom.parentNode;
    }
    return H > -1 ? H : A.docView.posFromDOM(B, E, -1);
  }
  function $t(A, B, E) {
    var N = A.childNodes.length;
    if (N && E.top < E.bottom)
      for (var H = Math.max(0, Math.min(N - 1, Math.floor(N * (B.top - E.top) / (E.bottom - E.top)) - 2)), Y = H; ; ) {
        var le = A.childNodes[Y];
        if (le.nodeType == 1)
          for (var me = le.getClientRects(), Pe = 0; Pe < me.length; Pe++) {
            var $e = me[Pe];
            if (ve(B, $e)) return $t(le, B, $e);
          }
        if ((Y = (Y + 1) % N) == H) break;
      }
    return A;
  }
  function Gt(A, B) {
    var E = A.dom.ownerDocument, N, H = 0, Y = Qe(E, B.left, B.top);
    Y && (N = Y.node, H = Y.offset);
    var le = (A.root.elementFromPoint ? A.root : E).elementFromPoint(B.left, B.top), me;
    if (!le || !A.dom.contains(le.nodeType != 1 ? le.parentNode : le)) {
      var Pe = A.dom.getBoundingClientRect();
      if (!ve(B, Pe) || (le = $t(A.dom, B, Pe), !le)) return null;
    }
    if (We)
      for (var $e = le; N && $e; $e = J($e))
        $e.draggable && (N = void 0);
    if (le = Ne(le, B), N) {
      if (St && N.nodeType == 1 && (H = Math.min(H, N.childNodes.length), H < N.childNodes.length)) {
        var st = N.childNodes[H], Tt;
        st.nodeName == "IMG" && (Tt = st.getBoundingClientRect()).right <= B.left && Tt.bottom > B.top && H++;
      }
      N == A.dom && H == N.childNodes.length - 1 && N.lastChild.nodeType == 1 && B.top > N.lastChild.getBoundingClientRect().bottom ? me = A.state.doc.content.size : (H == 0 || N.nodeType != 1 || N.childNodes[H - 1].nodeName != "BR") && (me = yt(A, N, H, B));
    }
    me == null && (me = it(A, le, B));
    var ht = A.docView.nearestDesc(le, !0);
    return {
      pos: me,
      inside: ht ? ht.posAtStart - ht.border : -1
    };
  }
  function Jt(A) {
    return A.top < A.bottom || A.left < A.right;
  }
  function Xt(A, B) {
    var E = A.getClientRects();
    if (E.length) {
      var N = E[B < 0 ? 0 : E.length - 1];
      if (Jt(N)) return N;
    }
    return Array.prototype.find.call(E, Jt) || A.getBoundingClientRect();
  }
  var Ae = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
  function vt(A, B, E) {
    var N = A.docView.domFromPos(B, E < 0 ? -1 : 1), H = N.node, Y = N.offset, le = N.atom, me = wt || St;
    if (H.nodeType == 3)
      if (me && (Ae.test(H.nodeValue) || (E < 0 ? !Y : Y == H.nodeValue.length))) {
        var Pe = Xt(K(H, Y, Y), E);
        if (St && Y && /\s/.test(H.nodeValue[Y - 1]) && Y < H.nodeValue.length) {
          var $e = Xt(K(H, Y - 1, Y - 1), -1);
          if ($e.top == Pe.top) {
            var st = Xt(K(H, Y, Y + 1), -1);
            if (st.top != Pe.top) return Ot(st, st.left < $e.left);
          }
        }
        return Pe;
      } else {
        var Tt = Y, ht = Y, _t = E < 0 ? 1 : -1;
        return E < 0 && !Y ? (ht++, _t = -1) : E >= 0 && Y == H.nodeValue.length ? (Tt--, _t = 1) : E < 0 ? Tt-- : ht++, Ot(Xt(K(H, Tt, ht), _t), _t < 0);
      }
    var Ht = A.state.doc.resolve(B - (le || 0));
    if (!Ht.parent.inlineContent) {
      if (le == null && Y && (E < 0 || Y == Ce(H))) {
        var nr = H.childNodes[Y - 1];
        if (nr.nodeType == 1) return Vt(nr.getBoundingClientRect(), !1);
      }
      if (le == null && Y < Ce(H)) {
        var Tr = H.childNodes[Y];
        if (Tr.nodeType == 1) return Vt(Tr.getBoundingClientRect(), !0);
      }
      return Vt(H.getBoundingClientRect(), E >= 0);
    }
    if (le == null && Y && (E < 0 || Y == Ce(H))) {
      var Zt = H.childNodes[Y - 1], Gr = Zt.nodeType == 3 ? K(Zt, Ce(Zt) - (me ? 0 : 1)) : Zt.nodeType == 1 && (Zt.nodeName != "BR" || !Zt.nextSibling) ? Zt : null;
      if (Gr) return Ot(Xt(Gr, 1), !1);
    }
    if (le == null && Y < Ce(H)) {
      for (var Or = H.childNodes[Y]; Or.pmViewDesc && Or.pmViewDesc.ignoreForCoords; )
        Or = Or.nextSibling;
      var en = Or ? Or.nodeType == 3 ? K(Or, 0, me ? 0 : 1) : Or.nodeType == 1 ? Or : null : null;
      if (en) return Ot(Xt(en, -1), !0);
    }
    return Ot(Xt(H.nodeType == 3 ? K(H) : H, -E), E >= 0);
  }
  function Ot(A, B) {
    if (A.width == 0) return A;
    var E = B ? A.left : A.right;
    return {
      top: A.top,
      bottom: A.bottom,
      left: E,
      right: E
    };
  }
  function Vt(A, B) {
    if (A.height == 0) return A;
    var E = B ? A.top : A.bottom;
    return {
      top: E,
      bottom: E,
      left: A.left,
      right: A.right
    };
  }
  function et(A, B, E) {
    var N = A.state, H = A.root.activeElement;
    N != B && A.updateState(B), H != A.dom && A.focus();
    try {
      return E();
    } finally {
      N != B && A.updateState(N), H != A.dom && H && H.focus();
    }
  }
  function ft(A, B, E) {
    var N = B.selection, H = E == "up" ? N.$from : N.$to;
    return et(A, B, function() {
      for (var Y = A.docView.domFromPos(H.pos, E == "up" ? -1 : 1), le = Y.node; ; ) {
        var me = A.docView.nearestDesc(le, !0);
        if (!me) break;
        if (me.node.isBlock) {
          le = me.contentDOM || me.dom;
          break;
        }
        le = me.dom.parentNode;
      }
      for (var Pe = vt(A, H.pos, 1), $e = le.firstChild; $e; $e = $e.nextSibling) {
        var st = void 0;
        if ($e.nodeType == 1) st = $e.getClientRects();
        else if ($e.nodeType == 3) st = K($e, 0, $e.nodeValue.length).getClientRects();
        else continue;
        for (var Tt = 0; Tt < st.length; Tt++) {
          var ht = st[Tt];
          if (ht.bottom > ht.top + 1 && (E == "up" ? Pe.top - ht.top > (ht.bottom - Pe.top) * 2 : ht.bottom - Pe.bottom > (Pe.bottom - ht.top) * 2)) return !1;
        }
      }
      return !0;
    });
  }
  var $ = /[\u0590-\u08ac]/;
  function Se(A, B, E) {
    var N = B.selection.$head;
    if (!N.parent.isTextblock) return !1;
    var H = N.parentOffset, Y = !H, le = H == N.parent.content.size, me = A.domSelection();
    return !$.test(N.parent.textContent) || !me.modify ? E == "left" || E == "backward" ? Y : le : et(A, B, function() {
      var Pe = A.domSelectionRange(), $e = Pe.focusNode, st = Pe.focusOffset, Tt = Pe.anchorNode, ht = Pe.anchorOffset, _t = me.caretBidiLevel;
      me.modify("move", E, "character");
      var Ht = N.depth ? A.docView.domAfterPos(N.before()) : A.dom, nr = A.domSelectionRange(), Tr = nr.focusNode, Zt = nr.focusOffset, Gr = Tr && !Ht.contains(Tr.nodeType == 1 ? Tr : Tr.parentNode) || $e == Tr && st == Zt;
      try {
        me.collapse(Tt, ht), $e && ($e != Tt || st != ht) && me.extend && me.extend($e, st);
      } catch {
      }
      return _t != null && (me.caretBidiLevel = _t), Gr;
    });
  }
  var se = null, M = null, ne = !1;
  function ce(A, B, E) {
    return se == B && M == E ? ne : (se = B, M = E, ne = E == "up" || E == "down" ? ft(A, B, E) : Se(A, B, E));
  }
  var X = 0, Re = 1, Ge = 2, pt = 3, xt = function() {
    function A(B, E, N, H) {
      w(this, A), this.parent = B, this.children = E, this.dom = N, this.contentDOM = H, this.dirty = X, N.pmViewDesc = this;
    }
    return O(A, [{
      key: "matchesWidget",
      value: function(E) {
        return !1;
      }
    }, {
      key: "matchesMark",
      value: function(E) {
        return !1;
      }
    }, {
      key: "matchesNode",
      value: function(E, N, H) {
        return !1;
      }
    }, {
      key: "matchesHack",
      value: function(E) {
        return !1;
      }
    }, {
      key: "parseRule",
      value: function() {
        return null;
      }
    }, {
      key: "stopEvent",
      value: function(E) {
        return !1;
      }
    }, {
      key: "size",
      get: function() {
        for (var E = 0, N = 0; N < this.children.length; N++)
          E += this.children[N].size;
        return E;
      }
    }, {
      key: "border",
      get: function() {
        return 0;
      }
    }, {
      key: "destroy",
      value: function() {
        this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
        for (var E = 0; E < this.children.length; E++)
          this.children[E].destroy();
      }
    }, {
      key: "posBeforeChild",
      value: function(E) {
        for (var N = 0, H = this.posAtStart; ; N++) {
          var Y = this.children[N];
          if (Y == E) return H;
          H += Y.size;
        }
      }
    }, {
      key: "posBefore",
      get: function() {
        return this.parent.posBeforeChild(this);
      }
    }, {
      key: "posAtStart",
      get: function() {
        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
      }
    }, {
      key: "posAfter",
      get: function() {
        return this.posBefore + this.size;
      }
    }, {
      key: "posAtEnd",
      get: function() {
        return this.posAtStart + this.size - 2 * this.border;
      }
    }, {
      key: "localPosFromDOM",
      value: function(E, N, H) {
        if (this.contentDOM && this.contentDOM.contains(E.nodeType == 1 ? E : E.parentNode))
          if (H < 0) {
            var Y, le;
            if (E == this.contentDOM)
              Y = E.childNodes[N - 1];
            else {
              for (; E.parentNode != this.contentDOM; )
                E = E.parentNode;
              Y = E.previousSibling;
            }
            for (; Y && !((le = Y.pmViewDesc) && le.parent == this); )
              Y = Y.previousSibling;
            return Y ? this.posBeforeChild(le) + le.size : this.posAtStart;
          } else {
            var me, Pe;
            if (E == this.contentDOM)
              me = E.childNodes[N];
            else {
              for (; E.parentNode != this.contentDOM; )
                E = E.parentNode;
              me = E.nextSibling;
            }
            for (; me && !((Pe = me.pmViewDesc) && Pe.parent == this); )
              me = me.nextSibling;
            return me ? this.posBeforeChild(Pe) : this.posAtEnd;
          }
        var $e;
        if (E == this.dom && this.contentDOM)
          $e = N > z(this.contentDOM);
        else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
          $e = E.compareDocumentPosition(this.contentDOM) & 2;
        else if (this.dom.firstChild) {
          if (N == 0) for (var st = E; ; st = st.parentNode) {
            if (st == this.dom) {
              $e = !1;
              break;
            }
            if (st.previousSibling) break;
          }
          if ($e == null && N == E.childNodes.length) for (var Tt = E; ; Tt = Tt.parentNode) {
            if (Tt == this.dom) {
              $e = !0;
              break;
            }
            if (Tt.nextSibling) break;
          }
        }
        return $e ?? H > 0 ? this.posAtEnd : this.posAtStart;
      }
    }, {
      key: "nearestDesc",
      value: function(E) {
        for (var N = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, H = !0, Y = E; Y; Y = Y.parentNode) {
          var le = this.getDesc(Y), me = void 0;
          if (le && (!N || le.node))
            if (H && (me = le.nodeDOM) && !(me.nodeType == 1 ? me.contains(E.nodeType == 1 ? E : E.parentNode) : me == E)) H = !1;
            else return le;
        }
      }
    }, {
      key: "getDesc",
      value: function(E) {
        for (var N = E.pmViewDesc, H = N; H; H = H.parent)
          if (H == this) return N;
      }
    }, {
      key: "posFromDOM",
      value: function(E, N, H) {
        for (var Y = E; Y; Y = Y.parentNode) {
          var le = this.getDesc(Y);
          if (le) return le.localPosFromDOM(E, N, H);
        }
        return -1;
      }
    }, {
      key: "descAt",
      value: function(E) {
        for (var N = 0, H = 0; N < this.children.length; N++) {
          var Y = this.children[N], le = H + Y.size;
          if (H == E && le != H) {
            for (; !Y.border && Y.children.length; )
              Y = Y.children[0];
            return Y;
          }
          if (E < le) return Y.descAt(E - H - Y.border);
          H = le;
        }
      }
    }, {
      key: "domFromPos",
      value: function(E, N) {
        if (!this.contentDOM) return {
          node: this.dom,
          offset: 0,
          atom: E + 1
        };
        for (var H = 0, Y = 0, le = 0; H < this.children.length; H++) {
          var me = this.children[H], Pe = le + me.size;
          if (Pe > E || me instanceof zt) {
            Y = E - le;
            break;
          }
          le = Pe;
        }
        if (Y) return this.children[H].domFromPos(Y - this.children[H].border, N);
        for (var $e; H && !($e = this.children[H - 1]).size && $e instanceof Pt && $e.side >= 0; H--)
          ;
        if (N <= 0) {
          for (var st, Tt = !0; st = H ? this.children[H - 1] : null, !(!st || st.dom.parentNode == this.contentDOM); H--, Tt = !1)
            ;
          return st && N && Tt && !st.border && !st.domAtom ? st.domFromPos(st.size, N) : {
            node: this.contentDOM,
            offset: st ? z(st.dom) + 1 : 0
          };
        } else {
          for (var ht, _t = !0; ht = H < this.children.length ? this.children[H] : null, !(!ht || ht.dom.parentNode == this.contentDOM); H++, _t = !1)
            ;
          return ht && _t && !ht.border && !ht.domAtom ? ht.domFromPos(0, N) : {
            node: this.contentDOM,
            offset: ht ? z(ht.dom) : this.contentDOM.childNodes.length
          };
        }
      }
    }, {
      key: "parseRange",
      value: function(E, N) {
        var H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        if (this.children.length == 0) return {
          node: this.contentDOM,
          from: E,
          to: N,
          fromOffset: 0,
          toOffset: this.contentDOM.childNodes.length
        };
        for (var Y = -1, le = -1, me = H, Pe = 0; ; Pe++) {
          var $e = this.children[Pe], st = me + $e.size;
          if (Y == -1 && E <= st) {
            var Tt = me + $e.border;
            if (E >= Tt && N <= st - $e.border && $e.node && $e.contentDOM && this.contentDOM.contains($e.contentDOM)) return $e.parseRange(E, N, Tt);
            E = me;
            for (var ht = Pe; ht > 0; ht--) {
              var _t = this.children[ht - 1];
              if (_t.size && _t.dom.parentNode == this.contentDOM && !_t.emptyChildAt(1)) {
                Y = z(_t.dom) + 1;
                break;
              }
              E -= _t.size;
            }
            Y == -1 && (Y = 0);
          }
          if (Y > -1 && (st > N || Pe == this.children.length - 1)) {
            N = st;
            for (var Ht = Pe + 1; Ht < this.children.length; Ht++) {
              var nr = this.children[Ht];
              if (nr.size && nr.dom.parentNode == this.contentDOM && !nr.emptyChildAt(-1)) {
                le = z(nr.dom);
                break;
              }
              N += nr.size;
            }
            le == -1 && (le = this.contentDOM.childNodes.length);
            break;
          }
          me = st;
        }
        return {
          node: this.contentDOM,
          from: E,
          to: N,
          fromOffset: Y,
          toOffset: le
        };
      }
    }, {
      key: "emptyChildAt",
      value: function(E) {
        if (this.border || !this.contentDOM || !this.children.length) return !1;
        var N = this.children[E < 0 ? 0 : this.children.length - 1];
        return N.size == 0 || N.emptyChildAt(E);
      }
    }, {
      key: "domAfterPos",
      value: function(E) {
        var N = this.domFromPos(E, 0), H = N.node, Y = N.offset;
        if (H.nodeType != 1 || Y == H.childNodes.length) throw new RangeError("No node after pos " + E);
        return H.childNodes[Y];
      }
    }, {
      key: "setSelection",
      value: function(E, N, H) {
        for (var Y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, le = Math.min(E, N), me = Math.max(E, N), Pe = 0, $e = 0; Pe < this.children.length; Pe++) {
          var st = this.children[Pe], Tt = $e + st.size;
          if (le > $e && me < Tt) return st.setSelection(E - $e - st.border, N - $e - st.border, H, Y);
          $e = Tt;
        }
        var ht = this.domFromPos(E, E ? -1 : 1), _t = N == E ? ht : this.domFromPos(N, N ? -1 : 1), Ht = H.getSelection(), nr = !1;
        if ((St || We) && E == N) {
          var Tr = ht, Zt = Tr.node, Gr = Tr.offset;
          if (Zt.nodeType == 3) {
            if (nr = !!(Gr && Zt.nodeValue[Gr - 1] == `
`), nr && Gr == Zt.nodeValue.length)
              for (var Or = Zt, en; Or; Or = Or.parentNode) {
                if (en = Or.nextSibling) {
                  en.nodeName == "BR" && (ht = _t = {
                    node: en.parentNode,
                    offset: z(en) + 1
                  });
                  break;
                }
                var Nr = Or.pmViewDesc;
                if (Nr && Nr.node && Nr.node.isBlock) break;
              }
          } else {
            var zr = Zt.childNodes[Gr - 1];
            nr = zr && (zr.nodeName == "BR" || zr.contentEditable == "false");
          }
        }
        if (St && Ht.focusNode && Ht.focusNode != _t.node && Ht.focusNode.nodeType == 1) {
          var fn = Ht.focusNode.childNodes[Ht.focusOffset];
          fn && fn.contentEditable == "false" && (Y = !0);
        }
        if (!(!(Y || nr && We) && re(ht.node, ht.offset, Ht.anchorNode, Ht.anchorOffset) && re(_t.node, _t.offset, Ht.focusNode, Ht.focusOffset))) {
          var ki = !1;
          if ((Ht.extend || E == N) && !nr) {
            Ht.collapse(ht.node, ht.offset);
            try {
              E != N && Ht.extend(_t.node, _t.offset), ki = !0;
            } catch {
            }
          }
          if (!ki) {
            if (E > N) {
              var na = ht;
              ht = _t, _t = na;
            }
            var Rn = document.createRange();
            Rn.setEnd(_t.node, _t.offset), Rn.setStart(ht.node, ht.offset), Ht.removeAllRanges(), Ht.addRange(Rn);
          }
        }
      }
    }, {
      key: "ignoreMutation",
      value: function(E) {
        return !this.contentDOM && E.type != "selection";
      }
    }, {
      key: "contentLost",
      get: function() {
        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
      }
    }, {
      key: "markDirty",
      value: function(E, N) {
        for (var H = 0, Y = 0; Y < this.children.length; Y++) {
          var le = this.children[Y], me = H + le.size;
          if (H == me ? E <= me && N >= H : E < me && N > H) {
            var Pe = H + le.border, $e = me - le.border;
            if (E >= Pe && N <= $e) {
              this.dirty = E == H || N == me ? Ge : Re, E == Pe && N == $e && (le.contentLost || le.dom.parentNode != this.contentDOM) ? le.dirty = pt : le.markDirty(E - Pe, N - Pe);
              return;
            } else
              le.dirty = le.dom == le.contentDOM && le.dom.parentNode == this.contentDOM && !le.children.length ? Ge : pt;
          }
          H = me;
        }
        this.dirty = Ge;
      }
    }, {
      key: "markParentsDirty",
      value: function() {
        for (var E = 1, N = this.parent; N; N = N.parent, E++) {
          var H = E == 1 ? Ge : Re;
          N.dirty < H && (N.dirty = H);
        }
      }
    }, {
      key: "domAtom",
      get: function() {
        return !1;
      }
    }, {
      key: "ignoreForCoords",
      get: function() {
        return !1;
      }
    }]), A;
  }(), Pt = function(A) {
    f(E, A);
    var B = d(E);
    function E(N, H, Y, le) {
      var me;
      w(this, E);
      var Pe, $e = H.type.toDOM;
      if (typeof $e == "function" && ($e = $e(Y, function() {
        if (!Pe) return le;
        if (Pe.parent) return Pe.parent.posBeforeChild(Pe);
      })), !H.type.spec.raw) {
        if ($e.nodeType != 1) {
          var st = document.createElement("span");
          st.appendChild($e), $e = st;
        }
        $e.contentEditable = "false", $e.classList.add("ProseMirror-widget");
      }
      return me = B.call(this, N, [], $e, null), me.widget = H, me.widget = H, Pe = y(me), me;
    }
    return O(E, [{
      key: "matchesWidget",
      value: function(H) {
        return this.dirty == X && H.type.eq(this.widget.type);
      }
    }, {
      key: "parseRule",
      value: function() {
        return {
          ignore: !0
        };
      }
    }, {
      key: "stopEvent",
      value: function(H) {
        var Y = this.widget.spec.stopEvent;
        return Y ? Y(H) : !1;
      }
    }, {
      key: "ignoreMutation",
      value: function(H) {
        return H.type != "selection" || this.widget.spec.ignoreSelection;
      }
    }, {
      key: "destroy",
      value: function() {
        this.widget.type.destroy(this.dom), l(x(E.prototype), "destroy", this).call(this);
      }
    }, {
      key: "domAtom",
      get: function() {
        return !0;
      }
    }, {
      key: "side",
      get: function() {
        return this.widget.type.side;
      }
    }]), E;
  }(xt), Yt = function(A) {
    f(E, A);
    var B = d(E);
    function E(N, H, Y, le) {
      var me;
      return w(this, E), me = B.call(this, N, [], H, null), me.textDOM = Y, me.text = le, me;
    }
    return O(E, [{
      key: "size",
      get: function() {
        return this.text.length;
      }
    }, {
      key: "localPosFromDOM",
      value: function(H, Y) {
        return H != this.textDOM ? this.posAtStart + (Y ? this.size : 0) : this.posAtStart + Y;
      }
    }, {
      key: "domFromPos",
      value: function(H) {
        return {
          node: this.textDOM,
          offset: H
        };
      }
    }, {
      key: "ignoreMutation",
      value: function(H) {
        return H.type === "characterData" && H.target.nodeValue == H.oldValue;
      }
    }]), E;
  }(xt), gr = function(A) {
    f(E, A);
    var B = d(E);
    function E(N, H, Y, le) {
      var me;
      return w(this, E), me = B.call(this, N, [], Y, le), me.mark = H, me;
    }
    return O(E, [{
      key: "parseRule",
      value: function() {
        return this.dirty & pt || this.mark.type.spec.reparseInView ? null : {
          mark: this.mark.type.name,
          attrs: this.mark.attrs,
          contentElement: this.contentDOM
        };
      }
    }, {
      key: "matchesMark",
      value: function(H) {
        return this.dirty != pt && this.mark.eq(H);
      }
    }, {
      key: "markDirty",
      value: function(H, Y) {
        if (l(x(E.prototype), "markDirty", this).call(this, H, Y), this.dirty != X) {
          for (var le = this.parent; !le.node; )
            le = le.parent;
          le.dirty < this.dirty && (le.dirty = this.dirty), this.dirty = X;
        }
      }
    }, {
      key: "slice",
      value: function(H, Y, le) {
        var me = E.create(this.parent, this.mark, !0, le), Pe = this.children, $e = this.size;
        Y < $e && (Pe = ei(Pe, Y, $e, le)), H > 0 && (Pe = ei(Pe, 0, H, le));
        for (var st = 0; st < Pe.length; st++)
          Pe[st].parent = me;
        return me.children = Pe, me;
      }
    }], [{
      key: "create",
      value: function(H, Y, le, me) {
        var Pe = me.nodeViews[Y.type.name], $e = Pe && Pe(Y, me, le);
        return (!$e || !$e.dom) && ($e = L.DOMSerializer.renderSpec(document, Y.type.spec.toDOM(Y, le))), new E(H, Y, $e.dom, $e.contentDOM || $e.dom);
      }
    }]), E;
  }(xt), dr = function(A) {
    f(E, A);
    var B = d(E);
    function E(N, H, Y, le, me, Pe, $e, st, Tt) {
      var ht;
      return w(this, E), ht = B.call(this, N, [], me, Pe), ht.node = H, ht.outerDeco = Y, ht.innerDeco = le, ht.nodeDOM = $e, ht;
    }
    return O(E, [{
      key: "parseRule",
      value: function() {
        var H = this;
        if (this.node.type.spec.reparseInView) return null;
        var Y = {
          node: this.node.type.name,
          attrs: this.node.attrs
        };
        if (this.node.type.whitespace == "pre" && (Y.preserveWhitespace = "full"), !this.contentDOM)
          Y.getContent = function() {
            return H.node.content;
          };
        else if (!this.contentLost)
          Y.contentElement = this.contentDOM;
        else {
          for (var le = this.children.length - 1; le >= 0; le--) {
            var me = this.children[le];
            if (this.dom.contains(me.dom.parentNode)) {
              Y.contentElement = me.dom.parentNode;
              break;
            }
          }
          Y.contentElement || (Y.getContent = function() {
            return L.Fragment.empty;
          });
        }
        return Y;
      }
    }, {
      key: "matchesNode",
      value: function(H, Y, le) {
        return this.dirty == X && H.eq(this.node) && Ct(Y, this.outerDeco) && le.eq(this.innerDeco);
      }
    }, {
      key: "size",
      get: function() {
        return this.node.nodeSize;
      }
    }, {
      key: "border",
      get: function() {
        return this.node.isLeaf ? 0 : 1;
      }
    }, {
      key: "updateChildren",
      value: function(H, Y) {
        var le = this, me = this.node.inlineContent, Pe = Y, $e = H.composing ? this.localCompositionInfo(H, Y) : null, st = $e && $e.pos > -1 ? $e : null, Tt = $e && $e.pos < 0, ht = new tr(this, st && st.node, H);
        kr(this.node, this.innerDeco, function(_t, Ht, nr) {
          _t.spec.marks ? ht.syncToMarks(_t.spec.marks, me, H) : _t.type.side >= 0 && !nr && ht.syncToMarks(Ht == le.node.childCount ? L.Mark.none : le.node.child(Ht).marks, me, H), ht.placeWidget(_t, H, Pe);
        }, function(_t, Ht, nr, Tr) {
          ht.syncToMarks(_t.marks, me, H);
          var Zt;
          ht.findNodeMatch(_t, Ht, nr, Tr) || Tt && H.state.selection.from > Pe && H.state.selection.to < Pe + _t.nodeSize && (Zt = ht.findIndexWithChild($e.node)) > -1 && ht.updateNodeAt(_t, Ht, nr, Zt, H) || ht.updateNextNode(_t, Ht, nr, H, Tr, Pe) || ht.addNode(_t, Ht, nr, H, Pe), Pe += _t.nodeSize;
        }), ht.syncToMarks([], me, H), this.node.isTextblock && ht.addTextblockHacks(), ht.destroyRest(), (ht.changed || this.dirty == Ge) && (st && this.protectLocalComposition(H, st), ae(this.contentDOM, this.children, H), ze && on(this.dom));
      }
    }, {
      key: "localCompositionInfo",
      value: function(H, Y) {
        var le = H.state.selection, me = le.from, Pe = le.to;
        if (!(H.state.selection instanceof T.TextSelection) || me < Y || Pe > Y + this.node.content.size) return null;
        var $e = H.domSelectionRange(), st = cr($e.focusNode, $e.focusOffset);
        if (!st || !this.dom.contains(st.parentNode)) return null;
        if (this.node.inlineContent) {
          var Tt = st.nodeValue, ht = An(this.node.content, Tt, me - Y, Pe - Y);
          return ht < 0 ? null : {
            node: st,
            pos: ht,
            text: Tt
          };
        } else
          return {
            node: st,
            pos: -1,
            text: ""
          };
      }
    }, {
      key: "protectLocalComposition",
      value: function(H, Y) {
        var le = Y.node, me = Y.pos, Pe = Y.text;
        if (!this.getDesc(le)) {
          for (var $e = le; $e.parentNode != this.contentDOM; $e = $e.parentNode) {
            for (; $e.previousSibling; )
              $e.parentNode.removeChild($e.previousSibling);
            for (; $e.nextSibling; )
              $e.parentNode.removeChild($e.nextSibling);
            $e.pmViewDesc && ($e.pmViewDesc = void 0);
          }
          var st = new Yt(this, $e, le, Pe);
          H.input.compositionNodes.push(st), this.children = ei(this.children, me, me + Pe.length, H, st);
        }
      }
    }, {
      key: "update",
      value: function(H, Y, le, me) {
        return this.dirty == pt || !H.sameMarkup(this.node) ? !1 : (this.updateInner(H, Y, le, me), !0);
      }
    }, {
      key: "updateInner",
      value: function(H, Y, le, me) {
        this.updateOuterDeco(Y), this.node = H, this.innerDeco = le, this.contentDOM && this.updateChildren(me, this.posAtStart), this.dirty = X;
      }
    }, {
      key: "updateOuterDeco",
      value: function(H) {
        if (!Ct(H, this.outerDeco)) {
          var Y = this.nodeDOM.nodeType != 1, le = this.dom;
          this.dom = Te(this.dom, this.nodeDOM, fe(this.outerDeco, this.node, Y), fe(H, this.node, Y)), this.dom != le && (le.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = H;
        }
      }
    }, {
      key: "selectNode",
      value: function() {
        this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
      }
    }, {
      key: "deselectNode",
      value: function() {
        this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable");
      }
    }, {
      key: "domAtom",
      get: function() {
        return this.node.isAtom;
      }
    }], [{
      key: "create",
      value: function(H, Y, le, me, Pe, $e) {
        var st = Pe.nodeViews[Y.type.name], Tt, ht = st && st(Y, Pe, function() {
          if (!Tt) return $e;
          if (Tt.parent) return Tt.parent.posBeforeChild(Tt);
        }, le, me), _t = ht && ht.dom, Ht = ht && ht.contentDOM;
        if (Y.isText) {
          if (!_t) _t = document.createTextNode(Y.text);
          else if (_t.nodeType != 3) throw new RangeError("Text must be rendered as a DOM text node");
        } else if (!_t) {
          var nr = L.DOMSerializer.renderSpec(document, Y.type.spec.toDOM(Y));
          _t = nr.dom, Ht = nr.contentDOM;
        }
        !Ht && !Y.isText && _t.nodeName != "BR" && (_t.hasAttribute("contenteditable") || (_t.contentEditable = "false"), Y.type.spec.draggable && (_t.draggable = !0));
        var Tr = _t;
        return _t = Je(_t, le, Y), ht ? Tt = new xe(H, Y, le, me, _t, Ht || null, Tr, ht, Pe, $e + 1) : Y.isText ? new ct(H, Y, le, me, _t, Tr, Pe) : new E(H, Y, le, me, _t, Ht || null, Tr);
      }
    }]), E;
  }(xt);
  function It(A, B, E, N, H) {
    Je(N, B, A);
    var Y = new dr(void 0, A, B, E, N, N, N, H, 0);
    return Y.contentDOM && Y.updateChildren(H, 0), Y;
  }
  var ct = function(A) {
    f(E, A);
    var B = d(E);
    function E(N, H, Y, le, me, Pe, $e) {
      return w(this, E), B.call(this, N, H, Y, le, me, null, Pe, $e, 0);
    }
    return O(E, [{
      key: "parseRule",
      value: function() {
        for (var H = this.nodeDOM.parentNode; H && H != this.dom && !H.pmIsDeco; )
          H = H.parentNode;
        return {
          skip: H || !0
        };
      }
    }, {
      key: "update",
      value: function(H, Y, le, me) {
        return this.dirty == pt || this.dirty != X && !this.inParent() || !H.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(Y), (this.dirty != X || H.text != this.node.text) && H.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = H.text, me.trackWrites == this.nodeDOM && (me.trackWrites = null)), this.node = H, this.dirty = X, !0);
      }
    }, {
      key: "inParent",
      value: function() {
        for (var H = this.parent.contentDOM, Y = this.nodeDOM; Y; Y = Y.parentNode)
          if (Y == H) return !0;
        return !1;
      }
    }, {
      key: "domFromPos",
      value: function(H) {
        return {
          node: this.nodeDOM,
          offset: H
        };
      }
    }, {
      key: "localPosFromDOM",
      value: function(H, Y, le) {
        return H == this.nodeDOM ? this.posAtStart + Math.min(Y, this.node.text.length) : l(x(E.prototype), "localPosFromDOM", this).call(this, H, Y, le);
      }
    }, {
      key: "ignoreMutation",
      value: function(H) {
        return H.type != "characterData" && H.type != "selection";
      }
    }, {
      key: "slice",
      value: function(H, Y, le) {
        var me = this.node.cut(H, Y), Pe = document.createTextNode(me.text);
        return new E(this.parent, me, this.outerDeco, this.innerDeco, Pe, Pe, le);
      }
    }, {
      key: "markDirty",
      value: function(H, Y) {
        l(x(E.prototype), "markDirty", this).call(this, H, Y), this.dom != this.nodeDOM && (H == 0 || Y == this.nodeDOM.nodeValue.length) && (this.dirty = pt);
      }
    }, {
      key: "domAtom",
      get: function() {
        return !1;
      }
    }]), E;
  }(dr), zt = function(A) {
    f(E, A);
    var B = d(E);
    function E() {
      return w(this, E), B.apply(this, arguments);
    }
    return O(E, [{
      key: "parseRule",
      value: function() {
        return {
          ignore: !0
        };
      }
    }, {
      key: "matchesHack",
      value: function(H) {
        return this.dirty == X && this.dom.nodeName == H;
      }
    }, {
      key: "domAtom",
      get: function() {
        return !0;
      }
    }, {
      key: "ignoreForCoords",
      get: function() {
        return this.dom.nodeName == "IMG";
      }
    }]), E;
  }(xt), xe = function(A) {
    f(E, A);
    var B = d(E);
    function E(N, H, Y, le, me, Pe, $e, st, Tt, ht) {
      var _t;
      return w(this, E), _t = B.call(this, N, H, Y, le, me, Pe, $e, Tt, ht), _t.spec = st, _t;
    }
    return O(E, [{
      key: "update",
      value: function(H, Y, le, me) {
        if (this.dirty == pt) return !1;
        if (this.spec.update) {
          var Pe = this.spec.update(H, Y, le);
          return Pe && this.updateInner(H, Y, le, me), Pe;
        } else return !this.contentDOM && !H.isLeaf ? !1 : l(x(E.prototype), "update", this).call(this, H, Y, le, me);
      }
    }, {
      key: "selectNode",
      value: function() {
        this.spec.selectNode ? this.spec.selectNode() : l(x(E.prototype), "selectNode", this).call(this);
      }
    }, {
      key: "deselectNode",
      value: function() {
        this.spec.deselectNode ? this.spec.deselectNode() : l(x(E.prototype), "deselectNode", this).call(this);
      }
    }, {
      key: "setSelection",
      value: function(H, Y, le, me) {
        this.spec.setSelection ? this.spec.setSelection(H, Y, le) : l(x(E.prototype), "setSelection", this).call(this, H, Y, le, me);
      }
    }, {
      key: "destroy",
      value: function() {
        this.spec.destroy && this.spec.destroy(), l(x(E.prototype), "destroy", this).call(this);
      }
    }, {
      key: "stopEvent",
      value: function(H) {
        return this.spec.stopEvent ? this.spec.stopEvent(H) : !1;
      }
    }, {
      key: "ignoreMutation",
      value: function(H) {
        return this.spec.ignoreMutation ? this.spec.ignoreMutation(H) : l(x(E.prototype), "ignoreMutation", this).call(this, H);
      }
    }]), E;
  }(dr);
  function ae(A, B, E) {
    for (var N = A.firstChild, H = !1, Y = 0; Y < B.length; Y++) {
      var le = B[Y], me = le.dom;
      if (me.parentNode == A) {
        for (; me != N; )
          N = jt(N), H = !0;
        N = N.nextSibling;
      } else
        H = !0, A.insertBefore(me, N);
      if (le instanceof gr) {
        var Pe = N ? N.previousSibling : A.lastChild;
        ae(le.contentDOM, le.children, E), N = Pe ? Pe.nextSibling : A.firstChild;
      }
    }
    for (; N; )
      N = jt(N), H = !0;
    H && E.trackWrites == A && (E.trackWrites = null);
  }
  var _ = function(B) {
    B && (this.nodeName = B);
  };
  _.prototype = /* @__PURE__ */ Object.create(null);
  var U = [new _()];
  function fe(A, B, E) {
    if (A.length == 0) return U;
    for (var N = E ? U[0] : new _(), H = [N], Y = 0; Y < A.length; Y++) {
      var le = A[Y].type.attrs;
      if (le) {
        le.nodeName && H.push(N = new _(le.nodeName));
        for (var me in le) {
          var Pe = le[me];
          Pe != null && (E && H.length == 1 && H.push(N = new _(B.isInline ? "span" : "div")), me == "class" ? N.class = (N.class ? N.class + " " : "") + Pe : me == "style" ? N.style = (N.style ? N.style + ";" : "") + Pe : me != "nodeName" && (N[me] = Pe));
        }
      }
    }
    return H;
  }
  function Te(A, B, E, N) {
    if (E == U && N == U) return B;
    for (var H = B, Y = 0; Y < N.length; Y++) {
      var le = N[Y], me = E[Y];
      if (Y) {
        var Pe = void 0;
        me && me.nodeName == le.nodeName && H != A && (Pe = H.parentNode) && Pe.nodeName.toLowerCase() == le.nodeName || (Pe = document.createElement(le.nodeName), Pe.pmIsDeco = !0, Pe.appendChild(H), me = U[0]), H = Pe;
      }
      Be(H, me || U[0], le);
    }
    return H;
  }
  function Be(A, B, E) {
    for (var N in B)
      N != "class" && N != "style" && N != "nodeName" && !(N in E) && A.removeAttribute(N);
    for (var H in E)
      H != "class" && H != "style" && H != "nodeName" && E[H] != B[H] && A.setAttribute(H, E[H]);
    if (B.class != E.class) {
      for (var Y = B.class ? B.class.split(" ").filter(Boolean) : [], le = E.class ? E.class.split(" ").filter(Boolean) : [], me = 0; me < Y.length; me++)
        le.indexOf(Y[me]) == -1 && A.classList.remove(Y[me]);
      for (var Pe = 0; Pe < le.length; Pe++)
        Y.indexOf(le[Pe]) == -1 && A.classList.add(le[Pe]);
      A.classList.length == 0 && A.removeAttribute("class");
    }
    if (B.style != E.style) {
      if (B.style)
        for (var $e = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, st; st = $e.exec(B.style); )
          A.style.removeProperty(st[1]);
      E.style && (A.style.cssText += E.style);
    }
  }
  function Je(A, B, E) {
    return Te(A, A, U, fe(B, E, A.nodeType != 1));
  }
  function Ct(A, B) {
    if (A.length != B.length) return !1;
    for (var E = 0; E < A.length; E++)
      if (!A[E].type.eq(B[E].type)) return !1;
    return !0;
  }
  function jt(A) {
    var B = A.nextSibling;
    return A.parentNode.removeChild(A), B;
  }
  var tr = function() {
    function A(B, E, N) {
      w(this, A), this.lock = E, this.view = N, this.index = 0, this.stack = [], this.changed = !1, this.top = B, this.preMatch = Kt(B.node.content, B);
    }
    return O(A, [{
      key: "destroyBetween",
      value: function(E, N) {
        if (E != N) {
          for (var H = E; H < N; H++)
            this.top.children[H].destroy();
          this.top.children.splice(E, N - E), this.changed = !0;
        }
      }
    }, {
      key: "destroyRest",
      value: function() {
        this.destroyBetween(this.index, this.top.children.length);
      }
    }, {
      key: "syncToMarks",
      value: function(E, N, H) {
        for (var Y = 0, le = this.stack.length >> 1, me = Math.min(le, E.length); Y < me && (Y == le - 1 ? this.top : this.stack[Y + 1 << 1]).matchesMark(E[Y]) && E[Y].type.spec.spanning !== !1; )
          Y++;
        for (; Y < le; )
          this.destroyRest(), this.top.dirty = X, this.index = this.stack.pop(), this.top = this.stack.pop(), le--;
        for (; le < E.length; ) {
          this.stack.push(this.top, this.index + 1);
          for (var Pe = -1, $e = this.index; $e < Math.min(this.index + 3, this.top.children.length); $e++) {
            var st = this.top.children[$e];
            if (st.matchesMark(E[le]) && !this.isLocked(st.dom)) {
              Pe = $e;
              break;
            }
          }
          if (Pe > -1)
            Pe > this.index && (this.changed = !0, this.destroyBetween(this.index, Pe)), this.top = this.top.children[this.index];
          else {
            var Tt = gr.create(this.top, E[le], N, H);
            this.top.children.splice(this.index, 0, Tt), this.top = Tt, this.changed = !0;
          }
          this.index = 0, le++;
        }
      }
    }, {
      key: "findNodeMatch",
      value: function(E, N, H, Y) {
        var le = -1, me;
        if (Y >= this.preMatch.index && (me = this.preMatch.matches[Y - this.preMatch.index]).parent == this.top && me.matchesNode(E, N, H))
          le = this.top.children.indexOf(me, this.index);
        else
          for (var Pe = this.index, $e = Math.min(this.top.children.length, Pe + 5); Pe < $e; Pe++) {
            var st = this.top.children[Pe];
            if (st.matchesNode(E, N, H) && !this.preMatch.matched.has(st)) {
              le = Pe;
              break;
            }
          }
        return le < 0 ? !1 : (this.destroyBetween(this.index, le), this.index++, !0);
      }
    }, {
      key: "updateNodeAt",
      value: function(E, N, H, Y, le) {
        var me = this.top.children[Y];
        return me.dirty == pt && me.dom == me.contentDOM && (me.dirty = Ge), me.update(E, N, H, le) ? (this.destroyBetween(this.index, Y), this.index++, !0) : !1;
      }
    }, {
      key: "findIndexWithChild",
      value: function(E) {
        for (; ; ) {
          var N = E.parentNode;
          if (!N) return -1;
          if (N == this.top.contentDOM) {
            var H = E.pmViewDesc;
            if (H) {
              for (var Y = this.index; Y < this.top.children.length; Y++)
                if (this.top.children[Y] == H) return Y;
            }
            return -1;
          }
          E = N;
        }
      }
    }, {
      key: "updateNextNode",
      value: function(E, N, H, Y, le, me) {
        for (var Pe = this.index; Pe < this.top.children.length; Pe++) {
          var $e = this.top.children[Pe];
          if ($e instanceof dr) {
            var st = this.preMatch.matched.get($e);
            if (st != null && st != le) return !1;
            var Tt = $e.dom, ht = void 0, _t = this.isLocked(Tt) && !(E.isText && $e.node && $e.node.isText && $e.nodeDOM.nodeValue == E.text && $e.dirty != pt && Ct(N, $e.outerDeco));
            if (!_t && $e.update(E, N, H, Y))
              return this.destroyBetween(this.index, Pe), $e.dom != Tt && (this.changed = !0), this.index++, !0;
            if (!_t && (ht = this.recreateWrapper($e, E, N, H, Y, me)))
              return this.top.children[this.index] = ht, ht.dirty = Ge, ht.updateChildren(Y, me + 1), ht.dirty = X, this.changed = !0, this.index++, !0;
            break;
          }
        }
        return !1;
      }
    }, {
      key: "recreateWrapper",
      value: function(E, N, H, Y, le, me) {
        if (E.dirty || N.isAtom || !E.children.length || !E.node.content.eq(N.content)) return null;
        var Pe = dr.create(this.top, N, H, Y, le, me);
        if (!Pe.contentDOM) return null;
        Pe.children = E.children, E.children = [], E.destroy();
        var $e = e(Pe.children), st;
        try {
          for ($e.s(); !(st = $e.n()).done; ) {
            var Tt = st.value;
            Tt.parent = Pe;
          }
        } catch (ht) {
          $e.e(ht);
        } finally {
          $e.f();
        }
        return Pe;
      }
    }, {
      key: "addNode",
      value: function(E, N, H, Y, le) {
        var me = dr.create(this.top, E, N, H, Y, le);
        me.contentDOM && me.updateChildren(Y, le + 1), this.top.children.splice(this.index++, 0, me), this.changed = !0;
      }
    }, {
      key: "placeWidget",
      value: function(E, N, H) {
        var Y = this.index < this.top.children.length ? this.top.children[this.index] : null;
        if (Y && Y.matchesWidget(E) && (E == Y.widget || !Y.widget.type.toDOM.parentNode))
          this.index++;
        else {
          var le = new Pt(this.top, E, N, H);
          this.top.children.splice(this.index++, 0, le), this.changed = !0;
        }
      }
    }, {
      key: "addTextblockHacks",
      value: function() {
        for (var E = this.top.children[this.index - 1], N = this.top; E instanceof gr; )
          N = E, E = N.children[N.children.length - 1];
        (!E || !(E instanceof ct) || /\n$/.test(E.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(E.node.text)) && ((We || Ue) && E && E.dom.contentEditable == "false" && this.addHackNode("IMG", N), this.addHackNode("BR", this.top));
      }
    }, {
      key: "addHackNode",
      value: function(E, N) {
        if (N == this.top && this.index < N.children.length && N.children[this.index].matchesHack(E))
          this.index++;
        else {
          var H = document.createElement(E);
          E == "IMG" && (H.className = "ProseMirror-separator", H.alt = ""), E == "BR" && (H.className = "ProseMirror-trailingBreak");
          var Y = new zt(this.top, [], H, null);
          N != this.top ? N.children.push(Y) : N.children.splice(this.index++, 0, Y), this.changed = !0;
        }
      }
    }, {
      key: "isLocked",
      value: function(E) {
        return this.lock && (E == this.lock || E.nodeType == 1 && E.contains(this.lock.parentNode));
      }
    }]), A;
  }();
  function Kt(A, B) {
    var E = B, N = E.children.length, H = A.childCount, Y = /* @__PURE__ */ new Map(), le = [];
    e: for (; H > 0; ) {
      for (var me = void 0; ; )
        if (N) {
          var Pe = E.children[N - 1];
          if (Pe instanceof gr)
            E = Pe, N = Pe.children.length;
          else {
            me = Pe, N--;
            break;
          }
        } else {
          if (E == B)
            break e;
          N = E.parent.children.indexOf(E), E = E.parent;
        }
      var $e = me.node;
      if ($e) {
        if ($e != A.child(H - 1)) break;
        --H, Y.set(me, H), le.push(me);
      }
    }
    return {
      index: H,
      matched: Y,
      matches: le.reverse()
    };
  }
  function rr(A, B) {
    return A.type.side - B.type.side;
  }
  function kr(A, B, E, N) {
    var H = B.locals(A), Y = 0;
    if (H.length == 0) {
      for (var le = 0; le < A.childCount; le++) {
        var me = A.child(le);
        N(me, H, B.forChild(Y, me), le), Y += me.nodeSize;
      }
      return;
    }
    for (var Pe = 0, $e = [], st = null, Tt = 0; ; ) {
      if (Pe < H.length && H[Pe].to == Y) {
        for (var ht = H[Pe++], _t = void 0; Pe < H.length && H[Pe].to == Y; )
          (_t || (_t = [ht])).push(H[Pe++]);
        if (_t) {
          _t.sort(rr);
          for (var Ht = 0; Ht < _t.length; Ht++)
            E(_t[Ht], Tt, !!st);
        } else
          E(ht, Tt, !!st);
      }
      var nr = void 0, Tr = void 0;
      if (st)
        Tr = -1, nr = st, st = null;
      else if (Tt < A.childCount)
        Tr = Tt, nr = A.child(Tt++);
      else
        break;
      for (var Zt = 0; Zt < $e.length; Zt++)
        $e[Zt].to <= Y && $e.splice(Zt--, 1);
      for (; Pe < H.length && H[Pe].from <= Y && H[Pe].to > Y; )
        $e.push(H[Pe++]);
      var Gr = Y + nr.nodeSize;
      if (nr.isText) {
        var Or = Gr;
        Pe < H.length && H[Pe].from < Or && (Or = H[Pe].from);
        for (var en = 0; en < $e.length; en++)
          $e[en].to < Or && (Or = $e[en].to);
        Or < Gr && (st = nr.cut(Or - Y), nr = nr.cut(0, Or - Y), Gr = Or, Tr = -1);
      }
      var Nr = nr.isInline && !nr.isLeaf ? $e.filter(function(zr) {
        return !zr.inline;
      }) : $e.slice();
      N(nr, Nr, B.forChild(Y, nr), Tr), Y = Gr;
    }
  }
  function on(A) {
    if (A.nodeName == "UL" || A.nodeName == "OL") {
      var B = A.style.cssText;
      A.style.cssText = B + "; list-style: square !important", window.getComputedStyle(A).listStyle, A.style.cssText = B;
    }
  }
  function cr(A, B) {
    for (; ; ) {
      if (A.nodeType == 3) return A;
      if (A.nodeType == 1 && B > 0) {
        if (A.childNodes.length > B && A.childNodes[B].nodeType == 3) return A.childNodes[B];
        A = A.childNodes[B - 1], B = Ce(A);
      } else if (A.nodeType == 1 && B < A.childNodes.length)
        A = A.childNodes[B], B = 0;
      else
        return null;
    }
  }
  function An(A, B, E, N) {
    for (var H = 0, Y = 0; H < A.childCount && Y <= N; ) {
      var le = A.child(H++), me = Y;
      if (Y += le.nodeSize, !!le.isText) {
        for (var Pe = le.text; H < A.childCount; ) {
          var $e = A.child(H++);
          if (Y += $e.nodeSize, !$e.isText) break;
          Pe += $e.text;
        }
        if (Y >= E) {
          var st = me < N ? Pe.lastIndexOf(B, N - me - 1) : -1;
          if (st >= 0 && st + B.length + me >= E) return me + st;
          if (E == N && Pe.length >= N + B.length - me && Pe.slice(N - me, N - me + B.length) == B) return N;
        }
      }
    }
    return -1;
  }
  function ei(A, B, E, N, H) {
    for (var Y = [], le = 0, me = 0; le < A.length; le++) {
      var Pe = A[le], $e = me, st = me += Pe.size;
      $e >= E || st <= B ? Y.push(Pe) : ($e < B && Y.push(Pe.slice(0, B - $e, N)), H && (Y.push(H), H = void 0), st > E && Y.push(Pe.slice(E - $e, Pe.size, N)));
    }
    return Y;
  }
  function bi(A) {
    var B = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, E = A.domSelectionRange(), N = A.state.doc;
    if (!E.focusNode) return null;
    var H = A.docView.nearestDesc(E.focusNode), Y = H && H.size == 0, le = A.docView.posFromDOM(E.focusNode, E.focusOffset, 1);
    if (le < 0) return null;
    var me = N.resolve(le), Pe, $e;
    if (ge(E)) {
      for (Pe = me; H && !H.node; )
        H = H.parent;
      var st = H.node;
      if (H && st.isAtom && T.NodeSelection.isSelectable(st) && H.parent && !(st.isInline && he(E.focusNode, E.focusOffset, H.dom))) {
        var Tt = H.posBefore;
        $e = new T.NodeSelection(le == Tt ? me : N.resolve(Tt));
      }
    } else {
      var ht = A.docView.posFromDOM(E.anchorNode, E.anchorOffset, 1);
      if (ht < 0) return null;
      Pe = N.resolve(ht);
    }
    if (!$e) {
      var _t = B == "pointer" || A.state.selection.head < me.pos && !Y ? 1 : -1;
      $e = Ii(A, Pe, me, _t);
    }
    return $e;
  }
  function wa(A) {
    return A.editable ? A.hasFocus() : gs(A) && document.activeElement && document.activeElement.contains(A.dom);
  }
  function Di(A) {
    var B = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, E = A.state.selection;
    if (Fo(A, E), !!wa(A)) {
      if (!B && A.input.mouseDown && A.input.mouseDown.allowDefault && Ue) {
        var N = A.domSelectionRange(), H = A.domObserver.currentSelection;
        if (N.anchorNode && H.anchorNode && re(N.anchorNode, N.anchorOffset, H.anchorNode, H.anchorOffset)) {
          A.input.mouseDown.delayedSelectionSync = !0, A.domObserver.setCurSelection();
          return;
        }
      }
      if (A.domObserver.disconnectSelection(), A.cursorWrapper)
        ta(A);
      else {
        var Y = E.anchor, le = E.head, me, Pe;
        Pi && !(E instanceof T.TextSelection) && (E.$from.parent.inlineContent || (me = Bo(A, E.from)), !E.empty && !E.$from.parent.inlineContent && (Pe = Bo(A, E.to))), A.docView.setSelection(Y, le, A.root, B), Pi && (me && En(me), Pe && En(Pe)), E.visible ? A.dom.classList.remove("ProseMirror-hideselection") : (A.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && Si(A));
      }
      A.domObserver.setCurSelection(), A.domObserver.connectSelection();
    }
  }
  var Pi = We || Ue && He < 63;
  function Bo(A, B) {
    var E = A.docView.domFromPos(B, 0), N = E.node, H = E.offset, Y = H < N.childNodes.length ? N.childNodes[H] : null, le = H ? N.childNodes[H - 1] : null;
    if (We && Y && Y.contentEditable == "false") return an(Y);
    if ((!Y || Y.contentEditable == "false") && (!le || le.contentEditable == "false")) {
      if (Y) return an(Y);
      if (le) return an(le);
    }
  }
  function an(A) {
    return A.contentEditable = "true", We && A.draggable && (A.draggable = !1, A.wasDraggable = !0), A;
  }
  function En(A) {
    A.contentEditable = "false", A.wasDraggable && (A.draggable = !0, A.wasDraggable = null);
  }
  function Si(A) {
    var B = A.dom.ownerDocument;
    B.removeEventListener("selectionchange", A.input.hideSelectionGuard);
    var E = A.domSelectionRange(), N = E.anchorNode, H = E.anchorOffset;
    B.addEventListener("selectionchange", A.input.hideSelectionGuard = function() {
      (E.anchorNode != N || E.anchorOffset != H) && (B.removeEventListener("selectionchange", A.input.hideSelectionGuard), setTimeout(function() {
        (!wa(A) || A.state.selection.visible) && A.dom.classList.remove("ProseMirror-hideselection");
      }, 20));
    });
  }
  function ta(A) {
    var B = A.domSelection(), E = document.createRange(), N = A.cursorWrapper.dom, H = N.nodeName == "IMG";
    H ? E.setEnd(N.parentNode, z(N) + 1) : E.setEnd(N, 0), E.collapse(!1), B.removeAllRanges(), B.addRange(E), !H && !A.state.selection.visible && At && Mt <= 11 && (N.disabled = !0, N.disabled = !1);
  }
  function Fo(A, B) {
    if (B instanceof T.NodeSelection) {
      var E = A.docView.descAt(B.from);
      E != A.lastSelectedViewDesc && (Li(A), E && E.selectNode(), A.lastSelectedViewDesc = E);
    } else
      Li(A);
  }
  function Li(A) {
    A.lastSelectedViewDesc && (A.lastSelectedViewDesc.parent && A.lastSelectedViewDesc.deselectNode(), A.lastSelectedViewDesc = void 0);
  }
  function Ii(A, B, E, N) {
    return A.someProp("createSelectionBetween", function(H) {
      return H(A, B, E);
    }) || T.TextSelection.between(B, E, N);
  }
  function _i(A) {
    return A.editable && !A.hasFocus() ? !1 : gs(A);
  }
  function gs(A) {
    var B = A.domSelectionRange();
    if (!B.anchorNode) return !1;
    try {
      return A.dom.contains(B.anchorNode.nodeType == 3 ? B.anchorNode.parentNode : B.anchorNode) && (A.editable || A.dom.contains(B.focusNode.nodeType == 3 ? B.focusNode.parentNode : B.focusNode));
    } catch {
      return !1;
    }
  }
  function ys(A) {
    var B = A.docView.domFromPos(A.state.selection.anchor, 0), E = A.domSelectionRange();
    return re(B.node, B.offset, E.anchorNode, E.anchorOffset);
  }
  function Ni(A, B) {
    var E = A.selection, N = E.$anchor, H = E.$head, Y = B > 0 ? N.max(H) : N.min(H), le = Y.parent.inlineContent ? Y.depth ? A.doc.resolve(B > 0 ? Y.after() : Y.before()) : null : Y;
    return le && T.Selection.findFrom(le, B);
  }
  function Fn(A, B) {
    return A.dispatch(A.state.tr.setSelection(B).scrollIntoView()), !0;
  }
  function $a(A, B, E) {
    var N = A.state.selection;
    if (N instanceof T.TextSelection) {
      if (!N.empty || E.indexOf("s") > -1)
        return !1;
      if (A.endOfTextblock(B > 0 ? "forward" : "backward")) {
        var H = Ni(A.state, B);
        return H && H instanceof T.NodeSelection ? Fn(A, H) : !1;
      } else if (!(at && E.indexOf("m") > -1)) {
        var Y = N.$head, le = Y.textOffset ? null : B < 0 ? Y.nodeBefore : Y.nodeAfter, me;
        if (!le || le.isText) return !1;
        var Pe = B < 0 ? Y.pos - le.nodeSize : Y.pos;
        return le.isAtom || (me = A.docView.descAt(Pe)) && !me.contentDOM ? T.NodeSelection.isSelectable(le) ? Fn(A, new T.NodeSelection(B < 0 ? A.state.doc.resolve(Y.pos - le.nodeSize) : Y)) : wt ? Fn(A, new T.TextSelection(A.state.doc.resolve(B < 0 ? Pe : Pe + le.nodeSize))) : !1 : !1;
      }
    } else {
      if (N instanceof T.NodeSelection && N.node.isInline)
        return Fn(A, new T.TextSelection(B > 0 ? N.$to : N.$from));
      var $e = Ni(A.state, B);
      return $e ? Fn(A, $e) : !1;
    }
  }
  function ra(A) {
    return A.nodeType == 3 ? A.nodeValue.length : A.childNodes.length;
  }
  function Bi(A) {
    if (A.contentEditable == "false") return !0;
    var B = A.pmViewDesc;
    return B && B.size == 0 && (A.nextSibling || A.nodeName != "BR");
  }
  function mo(A, B) {
    return B < 0 ? Nu(A) : Ua(A);
  }
  function Nu(A) {
    var B = A.domSelectionRange(), E = B.focusNode, N = B.focusOffset;
    if (E) {
      var H, Y, le = !1;
      for (St && E.nodeType == 1 && N < ra(E) && Bi(E.childNodes[N]) && (le = !0); ; )
        if (N > 0) {
          if (E.nodeType != 1)
            break;
          var me = E.childNodes[N - 1];
          if (Bi(me))
            H = E, Y = --N;
          else if (me.nodeType == 3)
            E = me, N = E.nodeValue.length;
          else break;
        } else {
          if (wi(E))
            break;
          for (var Pe = E.previousSibling; Pe && Bi(Pe); )
            H = E.parentNode, Y = z(Pe), Pe = Pe.previousSibling;
          if (Pe)
            E = Pe, N = ra(E);
          else {
            if (E = E.parentNode, E == A.dom) break;
            N = 0;
          }
        }
      le ? gn(A, E, N) : H && gn(A, H, Y);
    }
  }
  function Ua(A) {
    var B = A.domSelectionRange(), E = B.focusNode, N = B.focusOffset;
    if (E) {
      for (var H = ra(E), Y, le; ; )
        if (N < H) {
          if (E.nodeType != 1) break;
          var me = E.childNodes[N];
          if (Bi(me))
            Y = E, le = ++N;
          else break;
        } else {
          if (wi(E))
            break;
          for (var Pe = E.nextSibling; Pe && Bi(Pe); )
            Y = Pe.parentNode, le = z(Pe) + 1, Pe = Pe.nextSibling;
          if (Pe)
            E = Pe, N = 0, H = ra(E);
          else {
            if (E = E.parentNode, E == A.dom) break;
            N = H = 0;
          }
        }
      Y && gn(A, Y, le);
    }
  }
  function wi(A) {
    var B = A.pmViewDesc;
    return B && B.node && B.node.isBlock;
  }
  function Bu(A, B) {
    for (; A && B == A.childNodes.length && !oe(A); )
      B = z(A) + 1, A = A.parentNode;
    for (; A && B < A.childNodes.length; ) {
      if (A = A.childNodes[B], A.nodeType == 3) return A;
      B = 0;
    }
  }
  function Dr(A, B) {
    for (; A && !B && !oe(A); )
      B = z(A), A = A.parentNode;
    for (; A && B; ) {
      if (A = A.childNodes[B - 1], A.nodeType == 3) return A;
      B = A.childNodes.length;
    }
  }
  function gn(A, B, E) {
    if (B.nodeType != 3) {
      var N, H;
      (H = Bu(B, E)) ? (B = H, E = 0) : (N = Dr(B, E)) && (B = N, E = N.nodeValue.length);
    }
    var Y = A.domSelection();
    if (ge(Y)) {
      var le = document.createRange();
      le.setEnd(B, E), le.setStart(B, E), Y.removeAllRanges(), Y.addRange(le);
    } else Y.extend && Y.extend(B, E);
    A.domObserver.setCurSelection();
    var me = A.state;
    setTimeout(function() {
      A.state == me && Di(A);
    }, 50);
  }
  function ti(A, B) {
    var E = A.state.doc.resolve(B);
    if (!(Ue || Ye) && E.parent.inlineContent) {
      var N = A.coordsAtPos(B);
      if (B > E.start()) {
        var H = A.coordsAtPos(B - 1), Y = (H.top + H.bottom) / 2;
        if (Y > N.top && Y < N.bottom && Math.abs(H.left - N.left) > 1) return H.left < N.left ? "ltr" : "rtl";
      }
      if (B < E.end()) {
        var le = A.coordsAtPos(B + 1), me = (le.top + le.bottom) / 2;
        if (me > N.top && me < N.bottom && Math.abs(le.left - N.left) > 1) return le.left > N.left ? "ltr" : "rtl";
      }
    }
    var Pe = getComputedStyle(A.dom).direction;
    return Pe == "rtl" ? "rtl" : "ltr";
  }
  function ri(A, B, E) {
    var N = A.state.selection;
    if (N instanceof T.TextSelection && !N.empty || E.indexOf("s") > -1 || at && E.indexOf("m") > -1) return !1;
    var H = N.$from, Y = N.$to;
    if (!H.parent.inlineContent || A.endOfTextblock(B < 0 ? "up" : "down")) {
      var le = Ni(A.state, B);
      if (le && le instanceof T.NodeSelection) return Fn(A, le);
    }
    if (!H.parent.inlineContent) {
      var me = B < 0 ? H : Y, Pe = N instanceof T.AllSelection ? T.Selection.near(me, B) : T.Selection.findFrom(me, B);
      return Pe ? Fn(A, Pe) : !1;
    }
    return !1;
  }
  function bs(A, B) {
    if (!(A.state.selection instanceof T.TextSelection)) return !0;
    var E = A.state.selection, N = E.$head, H = E.$anchor, Y = E.empty;
    if (!N.sameParent(H)) return !0;
    if (!Y) return !1;
    if (A.endOfTextblock(B > 0 ? "forward" : "backward")) return !0;
    var le = !N.textOffset && (B < 0 ? N.nodeBefore : N.nodeAfter);
    if (le && !le.isText) {
      var me = A.state.tr;
      return B < 0 ? me.delete(N.pos - le.nodeSize, N.pos) : me.delete(N.pos, N.pos + le.nodeSize), A.dispatch(me), !0;
    }
    return !1;
  }
  function xa(A, B, E) {
    A.domObserver.stop(), B.contentEditable = E, A.domObserver.start();
  }
  function Pr(A) {
    if (!We || A.state.selection.$head.parentOffset > 0) return !1;
    var B = A.domSelectionRange(), E = B.focusNode, N = B.focusOffset;
    if (E && E.nodeType == 1 && N == 0 && E.firstChild && E.firstChild.contentEditable == "false") {
      var H = E.firstChild;
      xa(A, H, "true"), setTimeout(function() {
        return xa(A, H, "false");
      }, 20);
    }
    return !1;
  }
  function El(A) {
    var B = "";
    return A.ctrlKey && (B += "c"), A.metaKey && (B += "m"), A.altKey && (B += "a"), A.shiftKey && (B += "s"), B;
  }
  function ka(A, B) {
    var E = B.keyCode, N = El(B);
    if (E == 8 || at && E == 72 && N == "c")
      return bs(A, -1) || mo(A, -1);
    if (E == 46 && !B.shiftKey || at && E == 68 && N == "c")
      return bs(A, 1) || mo(A, 1);
    if (E == 13 || E == 27)
      return !0;
    if (E == 37 || at && E == 66 && N == "c") {
      var H = E == 37 ? ti(A, A.state.selection.from) == "ltr" ? -1 : 1 : -1;
      return $a(A, H, N) || mo(A, H);
    } else if (E == 39 || at && E == 70 && N == "c") {
      var Y = E == 39 ? ti(A, A.state.selection.from) == "ltr" ? 1 : -1 : 1;
      return $a(A, Y, N) || mo(A, Y);
    } else {
      if (E == 38 || at && E == 80 && N == "c")
        return ri(A, -1, N) || mo(A, -1);
      if (E == 40 || at && E == 78 && N == "c")
        return Pr(A) || ri(A, 1, N) || Ua(A);
      if (N == (at ? "m" : "c") && (E == 66 || E == 73 || E == 89 || E == 90))
        return !0;
    }
    return !1;
  }
  function hn(A, B) {
    A.someProp("transformCopied", function(Zt) {
      B = Zt(B, A);
    });
    for (var E = [], N = B, H = N.content, Y = N.openStart, le = N.openEnd; Y > 1 && le > 1 && H.childCount == 1 && H.firstChild.childCount == 1; ) {
      Y--, le--;
      var me = H.firstChild;
      E.push(me.type.name, me.attrs != me.type.defaultAttrs ? me.attrs : null), H = me.content;
    }
    var Pe = A.someProp("clipboardSerializer") || L.DOMSerializer.fromSchema(A.state.schema), $e = hr(), st = $e.createElement("div");
    st.appendChild(Pe.serializeFragment(H, {
      document: $e
    }));
    for (var Tt = st.firstChild, ht, _t = 0; Tt && Tt.nodeType == 1 && (ht = kt[Tt.nodeName.toLowerCase()]); ) {
      for (var Ht = ht.length - 1; Ht >= 0; Ht--) {
        for (var nr = $e.createElement(ht[Ht]); st.firstChild; )
          nr.appendChild(st.firstChild);
        st.appendChild(nr), _t++;
      }
      Tt = st.firstChild;
    }
    Tt && Tt.nodeType == 1 && Tt.setAttribute("data-pm-slice", "".concat(Y, " ").concat(le).concat(_t ? " -".concat(_t) : "", " ").concat(JSON.stringify(E)));
    var Tr = A.someProp("clipboardTextSerializer", function(Zt) {
      return Zt(B, A);
    }) || B.content.textBetween(0, B.content.size, `

`);
    return {
      dom: st,
      text: Tr
    };
  }
  function go(A, B, E, N, H) {
    var Y = H.parent.type.spec.code, le, me;
    if (!E && !B) return null;
    var Pe = B && (N || Y || !E);
    if (Pe) {
      if (A.someProp("transformPastedText", function(zr) {
        B = zr(B, Y || N, A);
      }), Y) return B ? new L.Slice(L.Fragment.from(A.state.schema.text(B.replace(/\r\n?/g, `
`))), 0, 0) : L.Slice.empty;
      var $e = A.someProp("clipboardTextParser", function(zr) {
        return zr(B, H, N, A);
      });
      if ($e)
        me = $e;
      else {
        var st = H.marks(), Tt = A.state.schema, ht = L.DOMSerializer.fromSchema(Tt);
        le = document.createElement("div"), B.split(/(?:\r\n?|\n)+/).forEach(function(zr) {
          var fn = le.appendChild(document.createElement("p"));
          zr && fn.appendChild(ht.serializeNode(Tt.text(zr, st)));
        });
      }
    } else
      A.someProp("transformPastedHTML", function(zr) {
        E = zr(E, A);
      }), le = Rr(E), wt && Wr(le);
    var _t = le && le.querySelector("[data-pm-slice]"), Ht = _t && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(_t.getAttribute("data-pm-slice") || "");
    if (Ht && Ht[3]) for (var nr = +Ht[3]; nr > 0; nr--) {
      for (var Tr = le.firstChild; Tr && Tr.nodeType != 1; )
        Tr = Tr.nextSibling;
      if (!Tr) break;
      le = Tr;
    }
    if (!me) {
      var Zt = A.someProp("clipboardParser") || A.someProp("domParser") || L.DOMParser.fromSchema(A.state.schema);
      me = Zt.parseSlice(le, {
        preserveWhitespace: !!(Pe || Ht),
        context: H,
        ruleFromNode: function(fn) {
          return fn.nodeName == "BR" && !fn.nextSibling && fn.parentNode && !zo.test(fn.parentNode.nodeName) ? {
            ignore: !0
          } : null;
        }
      });
    }
    if (Ht)
      me = cn(mr(me, +Ht[1], +Ht[2]), Ht[4]);
    else if (me = L.Slice.maxOpen(xi(me.content, H), !0), me.openStart || me.openEnd) {
      for (var Gr = 0, Or = 0, en = me.content.firstChild; Gr < me.openStart && !en.type.spec.isolating; Gr++, en = en.firstChild)
        ;
      for (var Nr = me.content.lastChild; Or < me.openEnd && !Nr.type.spec.isolating; Or++, Nr = Nr.lastChild)
        ;
      me = mr(me, Gr, Or);
    }
    return A.someProp("transformPasted", function(zr) {
      me = zr(me, A);
    }), me;
  }
  var zo = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
  function xi(A, B) {
    if (A.childCount < 2) return A;
    for (var E = function(le) {
      var me = B.node(le), Pe = me.contentMatchAt(B.index(le)), $e = void 0, st = [];
      if (A.forEach(function(Tt) {
        if (st) {
          var ht = Pe.findWrapping(Tt.type), _t;
          if (!ht) return st = null;
          if (_t = st.length && $e.length && Ss(ht, $e, Tt, st[st.length - 1], 0))
            st[st.length - 1] = _t;
          else {
            st.length && (st[st.length - 1] = ws(st[st.length - 1], $e.length));
            var Ht = $s(Tt, ht);
            st.push(Ht), Pe = Pe.matchType(Ht.type), $e = ht;
          }
        }
      }), st) return {
        v: L.Fragment.from(st)
      };
    }, N = B.depth; N >= 0; N--) {
      var H = E(N);
      if (i(H) === "object") return H.v;
    }
    return A;
  }
  function $s(A, B) {
    for (var E = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, N = B.length - 1; N >= E; N--)
      A = B[N].create(null, L.Fragment.from(A));
    return A;
  }
  function Ss(A, B, E, N, H) {
    if (H < A.length && H < B.length && A[H] == B[H]) {
      var Y = Ss(A, B, E, N.lastChild, H + 1);
      if (Y) return N.copy(N.content.replaceChild(N.childCount - 1, Y));
      var le = N.contentMatchAt(N.childCount);
      if (le.matchType(H == A.length - 1 ? E.type : A[H + 1])) return N.copy(N.content.append(L.Fragment.from($s(E, A, H + 1))));
    }
  }
  function ws(A, B) {
    if (B == 0) return A;
    var E = A.content.replaceChild(A.childCount - 1, ws(A.lastChild, B - 1)), N = A.contentMatchAt(A.childCount).fillBefore(L.Fragment.empty, !0);
    return A.copy(E.append(N));
  }
  function zn(A, B, E, N, H, Y) {
    var le = B < 0 ? A.firstChild : A.lastChild, me = le.content;
    return A.childCount > 1 && (Y = 0), H < N - 1 && (me = zn(me, B, E, N, H + 1, Y)), H >= E && (me = B < 0 ? le.contentMatchAt(0).fillBefore(me, Y <= H).append(me) : me.append(le.contentMatchAt(le.childCount).fillBefore(L.Fragment.empty, !0))), A.replaceChild(B < 0 ? 0 : A.childCount - 1, le.copy(me));
  }
  function mr(A, B, E) {
    return B < A.openStart && (A = new L.Slice(zn(A.content, -1, B, A.openStart, 0, A.openEnd), B, A.openEnd)), E < A.openEnd && (A = new L.Slice(zn(A.content, 1, E, A.openEnd, 0, 0), A.openStart, E)), A;
  }
  var kt = {
    thead: ["table"],
    tbody: ["table"],
    tfoot: ["table"],
    caption: ["table"],
    colgroup: ["table"],
    col: ["table", "colgroup"],
    tr: ["table", "tbody"],
    td: ["table", "tbody", "tr"],
    th: ["table", "tbody", "tr"]
  }, er = null;
  function hr() {
    return er || (er = document.implementation.createHTMLDocument("title"));
  }
  function Rr(A) {
    var B = /^(\s*<meta [^>]*>)*/.exec(A);
    B && (A = A.slice(B[0].length));
    var E = hr().createElement("div"), N = /<([a-z][^>\s]+)/i.exec(A), H;
    if ((H = N && kt[N[1].toLowerCase()]) && (A = H.map(function(le) {
      return "<" + le + ">";
    }).join("") + A + H.map(function(le) {
      return "</" + le + ">";
    }).reverse().join("")), E.innerHTML = A, H) for (var Y = 0; Y < H.length; Y++)
      E = E.querySelector(H[Y]) || E;
    return E;
  }
  function Wr(A) {
    for (var B = A.querySelectorAll(Ue ? "span:not([class]):not([style])" : "span.Apple-converted-space"), E = 0; E < B.length; E++) {
      var N = B[E];
      N.childNodes.length == 1 && N.textContent == " " && N.parentNode && N.parentNode.replaceChild(A.ownerDocument.createTextNode(" "), N);
    }
  }
  function cn(A, B) {
    if (!A.size) return A;
    var E = A.content.firstChild.type.schema, N;
    try {
      N = JSON.parse(B);
    } catch {
      return A;
    }
    for (var H = A.content, Y = A.openStart, le = A.openEnd, me = N.length - 2; me >= 0; me -= 2) {
      var Pe = E.nodes[N[me]];
      if (!Pe || Pe.hasRequiredAttrs()) break;
      H = L.Fragment.from(Pe.create(N[me + 1], H)), Y++, le++;
    }
    return new L.Slice(H, Y, le);
  }
  var Hr = {}, Ur = {}, Ho = {
    touchstart: !0,
    touchmove: !0
  }, Ml = O(function A() {
    w(this, A), this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = {
      time: 0,
      x: 0,
      y: 0,
      type: ""
    }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastAndroidDelete = 0, this.composing = !1, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  });
  function Fu(A) {
    var B = function(H) {
      var Y = Hr[H];
      A.dom.addEventListener(H, A.input.eventHandlers[H] = function(le) {
        Ap(A, le) && !Us(A, le) && (A.editable || !(le.type in Ur)) && Y(A, le);
      }, Ho[H] ? {
        passive: !0
      } : void 0);
    };
    for (var E in Hr)
      B(E);
    We && A.dom.addEventListener("input", function() {
      return null;
    }), zu(A);
  }
  function Va(A, B) {
    A.input.lastSelectionOrigin = B, A.input.lastSelectionTime = Date.now();
  }
  function Tp(A) {
    A.domObserver.stop();
    for (var B in A.input.eventHandlers)
      A.dom.removeEventListener(B, A.input.eventHandlers[B]);
    clearTimeout(A.input.composingTimeout), clearTimeout(A.input.lastIOSEnterFallbackTimeout);
  }
  function zu(A) {
    A.someProp("handleDOMEvents", function(B) {
      for (var E in B)
        A.input.eventHandlers[E] || A.dom.addEventListener(E, A.input.eventHandlers[E] = function(N) {
          return Us(A, N);
        });
    });
  }
  function Us(A, B) {
    return A.someProp("handleDOMEvents", function(E) {
      var N = E[B.type];
      return N ? N(A, B) || B.defaultPrevented : !1;
    });
  }
  function Ap(A, B) {
    if (!B.bubbles) return !0;
    if (B.defaultPrevented) return !1;
    for (var E = B.target; E != A.dom; E = E.parentNode)
      if (!E || E.nodeType == 11 || E.pmViewDesc && E.pmViewDesc.stopEvent(B)) return !1;
    return !0;
  }
  function Rl(A, B) {
    !Us(A, B) && Hr[B.type] && (A.editable || !(B.type in Ur)) && Hr[B.type](A, B);
  }
  Ur.keydown = function(A, B) {
    var E = B;
    if (A.input.shiftKey = E.keyCode == 16 || E.shiftKey, !Cr(A, E) && (A.input.lastKeyCode = E.keyCode, A.input.lastKeyCodeTime = Date.now(), !(tt && Ue && E.keyCode == 13)))
      if (E.keyCode != 229 && A.domObserver.forceFlush(), ze && E.keyCode == 13 && !E.ctrlKey && !E.altKey && !E.metaKey) {
        var N = Date.now();
        A.input.lastIOSEnter = N, A.input.lastIOSEnterFallbackTimeout = setTimeout(function() {
          A.input.lastIOSEnter == N && (A.someProp("handleKeyDown", function(H) {
            return H(A, we(13, "Enter"));
          }), A.input.lastIOSEnter = 0);
        }, 200);
      } else A.someProp("handleKeyDown", function(H) {
        return H(A, E);
      }) || ka(A, E) ? E.preventDefault() : Va(A, "key");
  }, Ur.keyup = function(A, B) {
    B.keyCode == 16 && (A.input.shiftKey = !1);
  }, Ur.keypress = function(A, B) {
    var E = B;
    if (!(Cr(A, E) || !E.charCode || E.ctrlKey && !E.altKey || at && E.metaKey)) {
      if (A.someProp("handleKeyPress", function(Y) {
        return Y(A, E);
      })) {
        E.preventDefault();
        return;
      }
      var N = A.state.selection;
      if (!(N instanceof T.TextSelection) || !N.$from.sameParent(N.$to)) {
        var H = String.fromCharCode(E.charCode);
        !/[\r\n]/.test(H) && !A.someProp("handleTextInput", function(Y) {
          return Y(A, N.$from.pos, N.$to.pos, H);
        }) && A.dispatch(A.state.tr.insertText(H).scrollIntoView()), E.preventDefault();
      }
    }
  };
  function ni(A) {
    return {
      left: A.clientX,
      top: A.clientY
    };
  }
  function Vs(A, B) {
    var E = B.x - A.clientX, N = B.y - A.clientY;
    return E * E + N * N < 100;
  }
  function Dl(A, B, E, N, H) {
    if (N == -1) return !1;
    for (var Y = A.state.doc.resolve(N), le = function(st) {
      if (A.someProp(B, function(Tt) {
        return st > Y.depth ? Tt(A, E, Y.nodeAfter, Y.before(st), H, !0) : Tt(A, E, Y.node(st), Y.before(st), H, !1);
      })) return {
        v: !0
      };
    }, me = Y.depth + 1; me > 0; me--) {
      var Pe = le(me);
      if (i(Pe) === "object") return Pe.v;
    }
    return !1;
  }
  function jo(A, B, E) {
    A.focused || A.focus();
    var N = A.state.tr.setSelection(B);
    N.setMeta("pointer", !0), A.dispatch(N);
  }
  function Ep(A, B) {
    if (B == -1) return !1;
    var E = A.state.doc.resolve(B), N = E.nodeAfter;
    return N && N.isAtom && T.NodeSelection.isSelectable(N) ? (jo(A, new T.NodeSelection(E)), !0) : !1;
  }
  function Pl(A, B) {
    if (B == -1) return !1;
    var E = A.state.selection, N, H;
    E instanceof T.NodeSelection && (N = E.node);
    for (var Y = A.state.doc.resolve(B), le = Y.depth + 1; le > 0; le--) {
      var me = le > Y.depth ? Y.nodeAfter : Y.node(le);
      if (T.NodeSelection.isSelectable(me)) {
        N && E.$from.depth > 0 && le >= E.$from.depth && Y.before(E.$from.depth + 1) == E.$from.pos ? H = Y.before(E.$from.depth) : H = Y.before(le);
        break;
      }
    }
    return H != null ? (jo(A, T.NodeSelection.create(A.state.doc, H)), !0) : !1;
  }
  function Hu(A, B, E, N, H) {
    return Dl(A, "handleClickOn", B, E, N) || A.someProp("handleClick", function(Y) {
      return Y(A, B, N);
    }) || (H ? Pl(A, E) : Ep(A, E));
  }
  function ju(A, B, E, N) {
    return Dl(A, "handleDoubleClickOn", B, E, N) || A.someProp("handleDoubleClick", function(H) {
      return H(A, B, N);
    });
  }
  function qc(A, B, E, N) {
    return Dl(A, "handleTripleClickOn", B, E, N) || A.someProp("handleTripleClick", function(H) {
      return H(A, B, N);
    }) || Wu(A, E, N);
  }
  function Wu(A, B, E) {
    if (E.button != 0) return !1;
    var N = A.state.doc;
    if (B == -1)
      return N.inlineContent ? (jo(A, T.TextSelection.create(N, 0, N.content.size)), !0) : !1;
    for (var H = N.resolve(B), Y = H.depth + 1; Y > 0; Y--) {
      var le = Y > H.depth ? H.nodeAfter : H.node(Y), me = H.before(Y);
      if (le.inlineContent) jo(A, T.TextSelection.create(N, me + 1, me + 1 + le.content.size));
      else if (T.NodeSelection.isSelectable(le)) jo(A, T.NodeSelection.create(N, me));
      else continue;
      return !0;
    }
  }
  function $u(A) {
    return Oa(A);
  }
  var yo = at ? "metaKey" : "ctrlKey";
  Hr.mousedown = function(A, B) {
    var E = B;
    A.input.shiftKey = E.shiftKey;
    var N = $u(A), H = Date.now(), Y = "singleClick";
    H - A.input.lastClick.time < 500 && Vs(E, A.input.lastClick) && !E[yo] && (A.input.lastClick.type == "singleClick" ? Y = "doubleClick" : A.input.lastClick.type == "doubleClick" && (Y = "tripleClick")), A.input.lastClick = {
      time: H,
      x: E.clientX,
      y: E.clientY,
      type: Y
    };
    var le = A.posAtCoords(ni(E));
    le && (Y == "singleClick" ? (A.input.mouseDown && A.input.mouseDown.done(), A.input.mouseDown = new Fi(A, le, E, !!N)) : (Y == "doubleClick" ? ju : qc)(A, le.pos, le.inside, E) ? E.preventDefault() : Va(A, "pointer"));
  };
  var Fi = function() {
    function A(B, E, N, H) {
      var Y = this;
      w(this, A), this.view = B, this.pos = E, this.event = N, this.flushed = H, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = B.state.doc, this.selectNode = !!N[yo], this.allowDefault = N.shiftKey;
      var le, me;
      if (E.inside > -1)
        le = B.state.doc.nodeAt(E.inside), me = E.inside;
      else {
        var Pe = B.state.doc.resolve(E.pos);
        le = Pe.parent, me = Pe.depth ? Pe.before() : 0;
      }
      var $e = H ? null : N.target, st = $e ? B.docView.nearestDesc($e, !0) : null;
      this.target = st ? st.dom : null;
      var Tt = B.state.selection;
      (N.button == 0 && le.type.spec.draggable && le.type.spec.selectable !== !1 || Tt instanceof T.NodeSelection && Tt.from <= me && Tt.to > me) && (this.mightDrag = {
        node: le,
        pos: me,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && St && !this.target.hasAttribute("contentEditable"))
      }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(function() {
        Y.view.input.mouseDown == Y && Y.target.setAttribute("contentEditable", "false");
      }, 20), this.view.domObserver.start()), B.root.addEventListener("mouseup", this.up = this.up.bind(this)), B.root.addEventListener("mousemove", this.move = this.move.bind(this)), Va(B, "pointer");
    }
    return O(A, [{
      key: "done",
      value: function() {
        var E = this;
        this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(function() {
          return Di(E.view);
        }), this.view.input.mouseDown = null;
      }
    }, {
      key: "up",
      value: function(E) {
        if (this.done(), !!this.view.dom.contains(E.target)) {
          var N = this.pos;
          this.view.state.doc != this.startDoc && (N = this.view.posAtCoords(ni(E))), this.updateAllowDefault(E), this.allowDefault || !N ? Va(this.view, "pointer") : Hu(this.view, N.pos, N.inside, E, this.selectNode) ? E.preventDefault() : E.button == 0 && (this.flushed || We && this.mightDrag && !this.mightDrag.node.isAtom || Ue && !this.view.state.selection.visible && Math.min(Math.abs(N.pos - this.view.state.selection.from), Math.abs(N.pos - this.view.state.selection.to)) <= 2) ? (jo(this.view, T.Selection.near(this.view.state.doc.resolve(N.pos))), E.preventDefault()) : Va(this.view, "pointer");
        }
      }
    }, {
      key: "move",
      value: function(E) {
        this.updateAllowDefault(E), Va(this.view, "pointer"), E.buttons == 0 && this.done();
      }
    }, {
      key: "updateAllowDefault",
      value: function(E) {
        !this.allowDefault && (Math.abs(this.event.x - E.clientX) > 4 || Math.abs(this.event.y - E.clientY) > 4) && (this.allowDefault = !0);
      }
    }]), A;
  }();
  Hr.touchstart = function(A) {
    A.input.lastTouch = Date.now(), $u(A), Va(A, "pointer");
  }, Hr.touchmove = function(A) {
    A.input.lastTouch = Date.now(), Va(A, "pointer");
  }, Hr.contextmenu = function(A) {
    return $u(A);
  };
  function Cr(A, B) {
    return A.composing ? !0 : We && Math.abs(B.timeStamp - A.input.compositionEndedAt) < 500 ? (A.input.compositionEndedAt = -2e8, !0) : !1;
  }
  var Mp = tt ? 5e3 : -1;
  Ur.compositionstart = Ur.compositionupdate = function(A) {
    if (!A.composing) {
      A.domObserver.flush();
      var B = A.state, E = B.selection.$from;
      if (B.selection.empty && (B.storedMarks || !E.textOffset && E.parentOffset && E.nodeBefore.marks.some(function(me) {
        return me.type.spec.inclusive === !1;
      })))
        A.markCursor = A.state.storedMarks || E.marks(), Oa(A, !0), A.markCursor = null;
      else if (Oa(A), St && B.selection.empty && E.parentOffset && !E.textOffset && E.nodeBefore.marks.length)
        for (var N = A.domSelectionRange(), H = N.focusNode, Y = N.focusOffset; H && H.nodeType == 1 && Y != 0; ) {
          var le = Y < 0 ? H.lastChild : H.childNodes[Y - 1];
          if (!le) break;
          if (le.nodeType == 3) {
            A.domSelection().collapse(le, le.nodeValue.length);
            break;
          } else
            H = le, Y = -1;
        }
      A.input.composing = !0;
    }
    Gs(A, Mp);
  }, Ur.compositionend = function(A, B) {
    A.composing && (A.input.composing = !1, A.input.compositionEndedAt = B.timeStamp, A.input.compositionPendingChanges = A.domObserver.pendingRecords().length ? A.input.compositionID : 0, A.input.compositionPendingChanges && Promise.resolve().then(function() {
      return A.domObserver.flush();
    }), A.input.compositionID++, Gs(A, 20));
  };
  function Gs(A, B) {
    clearTimeout(A.input.composingTimeout), B > -1 && (A.input.composingTimeout = setTimeout(function() {
      return Oa(A);
    }, B));
  }
  function bo(A) {
    for (A.composing && (A.input.composing = !1, A.input.compositionEndedAt = Uu()); A.input.compositionNodes.length > 0; )
      A.input.compositionNodes.pop().markParentsDirty();
  }
  function Uu() {
    var A = document.createEvent("Event");
    return A.initEvent("event", !0, !0), A.timeStamp;
  }
  function Oa(A) {
    var B = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (!(tt && A.domObserver.flushingSoon >= 0)) {
      if (A.domObserver.forceFlush(), bo(A), B || A.docView && A.docView.dirty) {
        var E = bi(A);
        return E && !E.eq(A.state.selection) ? A.dispatch(A.state.tr.setSelection(E)) : A.updateState(A.state), !0;
      }
      return !1;
    }
  }
  function Vu(A, B) {
    if (A.dom.parentNode) {
      var E = A.dom.parentNode.appendChild(document.createElement("div"));
      E.appendChild(B), E.style.cssText = "position: fixed; left: -10000px; top: 10px";
      var N = getSelection(), H = document.createRange();
      H.selectNodeContents(B), A.dom.blur(), N.removeAllRanges(), N.addRange(H), setTimeout(function() {
        E.parentNode && E.parentNode.removeChild(E), A.focus();
      }, 50);
    }
  }
  var xs = At && Mt < 15 || ze && Ft < 604;
  Hr.copy = Ur.cut = function(A, B) {
    var E = B, N = A.state.selection, H = E.type == "cut";
    if (!N.empty) {
      var Y = xs ? null : E.clipboardData, le = N.content(), me = hn(A, le), Pe = me.dom, $e = me.text;
      Y ? (E.preventDefault(), Y.clearData(), Y.setData("text/html", Pe.innerHTML), Y.setData("text/plain", $e)) : Vu(A, Pe), H && A.dispatch(A.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
    }
  };
  function Rp(A) {
    return A.openStart == 0 && A.openEnd == 0 && A.content.childCount == 1 ? A.content.firstChild : null;
  }
  function Dp(A, B) {
    if (A.dom.parentNode) {
      var E = A.input.shiftKey || A.state.selection.$from.parent.type.spec.code, N = A.dom.parentNode.appendChild(document.createElement(E ? "textarea" : "div"));
      E || (N.contentEditable = "true"), N.style.cssText = "position: fixed; left: -10000px; top: 10px", N.focus();
      var H = A.input.shiftKey && A.input.lastKeyCode != 45;
      setTimeout(function() {
        A.focus(), N.parentNode && N.parentNode.removeChild(N), E ? Ys(A, N.value, null, H, B) : Ys(A, N.textContent, N.innerHTML, H, B);
      }, 50);
    }
  }
  function Ys(A, B, E, N, H) {
    var Y = go(A, B, E, N, A.state.selection.$from);
    if (A.someProp("handlePaste", function(Pe) {
      return Pe(A, H, Y || L.Slice.empty);
    })) return !0;
    if (!Y) return !1;
    var le = Rp(Y), me = le ? A.state.tr.replaceSelectionWith(le, N) : A.state.tr.replaceSelection(Y);
    return A.dispatch(me.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
  }
  Ur.paste = function(A, B) {
    var E = B;
    if (!(A.composing && !tt)) {
      var N = xs ? null : E.clipboardData, H = A.input.shiftKey && A.input.lastKeyCode != 45;
      N && Ys(A, N.getData("text/plain"), N.getData("text/html"), H, E) ? E.preventDefault() : Dp(A, E);
    }
  };
  var Pp = O(function A(B, E) {
    w(this, A), this.slice = B, this.move = E;
  }), Ll = at ? "altKey" : "ctrlKey";
  Hr.dragstart = function(A, B) {
    var E = B, N = A.input.mouseDown;
    if (N && N.done(), !!E.dataTransfer) {
      var H = A.state.selection, Y = H.empty ? null : A.posAtCoords(ni(E));
      if (!(Y && Y.pos >= H.from && Y.pos <= (H instanceof T.NodeSelection ? H.to - 1 : H.to))) {
        if (N && N.mightDrag)
          A.dispatch(A.state.tr.setSelection(T.NodeSelection.create(A.state.doc, N.mightDrag.pos)));
        else if (E.target && E.target.nodeType == 1) {
          var le = A.docView.nearestDesc(E.target, !0);
          le && le.node.type.spec.draggable && le != A.docView && A.dispatch(A.state.tr.setSelection(T.NodeSelection.create(A.state.doc, le.posBefore)));
        }
      }
      var me = A.state.selection.content(), Pe = hn(A, me), $e = Pe.dom, st = Pe.text;
      E.dataTransfer.clearData(), E.dataTransfer.setData(xs ? "Text" : "text/html", $e.innerHTML), E.dataTransfer.effectAllowed = "copyMove", xs || E.dataTransfer.setData("text/plain", st), A.dragging = new Pp(me, !E[Ll]);
    }
  }, Hr.dragend = function(A) {
    var B = A.dragging;
    window.setTimeout(function() {
      A.dragging == B && (A.dragging = null);
    }, 50);
  }, Ur.dragover = Ur.dragenter = function(A, B) {
    return B.preventDefault();
  }, Ur.drop = function(A, B) {
    var E = B, N = A.dragging;
    if (A.dragging = null, !!E.dataTransfer) {
      var H = A.posAtCoords(ni(E));
      if (H) {
        var Y = A.state.doc.resolve(H.pos), le = N && N.slice;
        le ? A.someProp("transformPasted", function(nr) {
          le = nr(le, A);
        }) : le = go(A, E.dataTransfer.getData(xs ? "Text" : "text/plain"), xs ? null : E.dataTransfer.getData("text/html"), !1, Y);
        var me = !!(N && !E[Ll]);
        if (A.someProp("handleDrop", function(nr) {
          return nr(A, E, le || L.Slice.empty, me);
        })) {
          E.preventDefault();
          return;
        }
        if (le) {
          E.preventDefault();
          var Pe = le ? j.dropPoint(A.state.doc, Y.pos, le) : Y.pos;
          Pe == null && (Pe = Y.pos);
          var $e = A.state.tr;
          me && $e.deleteSelection();
          var st = $e.mapping.map(Pe), Tt = le.openStart == 0 && le.openEnd == 0 && le.content.childCount == 1, ht = $e.doc;
          if (Tt ? $e.replaceRangeWith(st, st, le.content.firstChild) : $e.replaceRange(st, st, le), !$e.doc.eq(ht)) {
            var _t = $e.doc.resolve(st);
            if (Tt && T.NodeSelection.isSelectable(le.content.firstChild) && _t.nodeAfter && _t.nodeAfter.sameMarkup(le.content.firstChild))
              $e.setSelection(new T.NodeSelection(_t));
            else {
              var Ht = $e.mapping.map(Pe);
              $e.mapping.maps[$e.mapping.maps.length - 1].forEach(function(nr, Tr, Zt, Gr) {
                return Ht = Gr;
              }), $e.setSelection(Ii(A, _t, $e.doc.resolve(Ht)));
            }
            A.focus(), A.dispatch($e.setMeta("uiEvent", "drop"));
          }
        }
      }
    }
  }, Hr.focus = function(A) {
    A.input.lastFocus = Date.now(), A.focused || (A.domObserver.stop(), A.dom.classList.add("ProseMirror-focused"), A.domObserver.start(), A.focused = !0, setTimeout(function() {
      A.docView && A.hasFocus() && !A.domObserver.currentSelection.eq(A.domSelectionRange()) && Di(A);
    }, 20));
  }, Hr.blur = function(A, B) {
    var E = B;
    A.focused && (A.domObserver.stop(), A.dom.classList.remove("ProseMirror-focused"), A.domObserver.start(), E.relatedTarget && A.dom.contains(E.relatedTarget) && A.domObserver.currentSelection.clear(), A.focused = !1);
  }, Hr.beforeinput = function(A, B) {
    var E = B;
    if (Ue && tt && E.inputType == "deleteContentBackward") {
      A.domObserver.flushSoon();
      var N = A.input.domChangeCount;
      setTimeout(function() {
        if (A.input.domChangeCount == N && (A.dom.blur(), A.focus(), !A.someProp("handleKeyDown", function(Y) {
          return Y(A, we(8, "Backspace"));
        }))) {
          var H = A.state.selection.$cursor;
          H && H.pos > 0 && A.dispatch(A.state.tr.delete(H.pos - 1, H.pos).scrollIntoView());
        }
      }, 50);
    }
  };
  for (var Kc in Ur)
    Hr[Kc] = Ur[Kc];
  function Wo(A, B) {
    if (A == B) return !0;
    for (var E in A)
      if (A[E] !== B[E]) return !1;
    for (var N in B)
      if (!(N in A)) return !1;
    return !0;
  }
  var So = function() {
    function A(B, E) {
      w(this, A), this.toDOM = B, this.spec = E || Ga, this.side = this.spec.side || 0;
    }
    return O(A, [{
      key: "map",
      value: function(E, N, H, Y) {
        var le = E.mapResult(N.from + Y, this.side < 0 ? -1 : 1), me = le.pos, Pe = le.deleted;
        return Pe ? null : new $o(me - H, me - H, this);
      }
    }, {
      key: "valid",
      value: function() {
        return !0;
      }
    }, {
      key: "eq",
      value: function(E) {
        return this == E || E instanceof A && (this.spec.key && this.spec.key == E.spec.key || this.toDOM == E.toDOM && Wo(this.spec, E.spec));
      }
    }, {
      key: "destroy",
      value: function(E) {
        this.spec.destroy && this.spec.destroy(E);
      }
    }]), A;
  }(), qs = function() {
    function A(B, E) {
      w(this, A), this.attrs = B, this.spec = E || Ga;
    }
    return O(A, [{
      key: "map",
      value: function(E, N, H, Y) {
        var le = E.map(N.from + Y, this.spec.inclusiveStart ? -1 : 1) - H, me = E.map(N.to + Y, this.spec.inclusiveEnd ? 1 : -1) - H;
        return le >= me ? null : new $o(le, me, this);
      }
    }, {
      key: "valid",
      value: function(E, N) {
        return N.from < N.to;
      }
    }, {
      key: "eq",
      value: function(E) {
        return this == E || E instanceof A && Wo(this.attrs, E.attrs) && Wo(this.spec, E.spec);
      }
    }, {
      key: "destroy",
      value: function() {
      }
    }], [{
      key: "is",
      value: function(E) {
        return E.type instanceof A;
      }
    }]), A;
  }(), Lp = function() {
    function A(B, E) {
      w(this, A), this.attrs = B, this.spec = E || Ga;
    }
    return O(A, [{
      key: "map",
      value: function(E, N, H, Y) {
        var le = E.mapResult(N.from + Y, 1);
        if (le.deleted) return null;
        var me = E.mapResult(N.to + Y, -1);
        return me.deleted || me.pos <= le.pos ? null : new $o(le.pos - H, me.pos - H, this);
      }
    }, {
      key: "valid",
      value: function(E, N) {
        var H = E.content.findIndex(N.from), Y = H.index, le = H.offset, me;
        return le == N.from && !(me = E.child(Y)).isText && le + me.nodeSize == N.to;
      }
    }, {
      key: "eq",
      value: function(E) {
        return this == E || E instanceof A && Wo(this.attrs, E.attrs) && Wo(this.spec, E.spec);
      }
    }, {
      key: "destroy",
      value: function() {
      }
    }]), A;
  }(), $o = function() {
    function A(B, E, N) {
      w(this, A), this.from = B, this.to = E, this.type = N;
    }
    return O(A, [{
      key: "copy",
      value: function(E, N) {
        return new A(E, N, this.type);
      }
    }, {
      key: "eq",
      value: function(E) {
        var N = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return this.type.eq(E.type) && this.from + N == E.from && this.to + N == E.to;
      }
    }, {
      key: "map",
      value: function(E, N, H) {
        return this.type.map(E, this, N, H);
      }
    }, {
      key: "spec",
      get: function() {
        return this.type.spec;
      }
    }, {
      key: "inline",
      get: function() {
        return this.type instanceof qs;
      }
    }], [{
      key: "widget",
      value: function(E, N, H) {
        return new A(E, E, new So(N, H));
      }
    }, {
      key: "inline",
      value: function(E, N, H, Y) {
        return new A(E, N, new qs(H, Y));
      }
    }, {
      key: "node",
      value: function(E, N, H, Y) {
        return new A(E, N, new Lp(H, Y));
      }
    }]), A;
  }(), ks = [], Ga = {}, zi = function() {
    function A(B, E) {
      w(this, A), this.local = B.length ? B : ks, this.children = E.length ? E : ks;
    }
    return O(A, [{
      key: "find",
      value: function(E, N, H) {
        var Y = [];
        return this.findInner(E ?? 0, N ?? 1e9, Y, 0, H), Y;
      }
    }, {
      key: "findInner",
      value: function(E, N, H, Y, le) {
        for (var me = 0; me < this.local.length; me++) {
          var Pe = this.local[me];
          Pe.from <= N && Pe.to >= E && (!le || le(Pe.spec)) && H.push(Pe.copy(Pe.from + Y, Pe.to + Y));
        }
        for (var $e = 0; $e < this.children.length; $e += 3)
          if (this.children[$e] < N && this.children[$e + 1] > E) {
            var st = this.children[$e] + 1;
            this.children[$e + 2].findInner(E - st, N - st, H, Y + st, le);
          }
      }
    }, {
      key: "map",
      value: function(E, N, H) {
        return this == Mn || E.maps.length == 0 ? this : this.mapInner(E, N, 0, 0, H || Ga);
      }
    }, {
      key: "mapInner",
      value: function(E, N, H, Y, le) {
        for (var me, Pe = 0; Pe < this.local.length; Pe++) {
          var $e = this.local[Pe].map(E, H, Y);
          $e && $e.type.valid(N, $e) ? (me || (me = [])).push($e) : le.onRemove && le.onRemove(this.local[Pe].spec);
        }
        return this.children.length ? Ip(this.children, me || [], E, N, H, Y, le) : me ? new A(me.sort(Uo), ks) : Mn;
      }
    }, {
      key: "add",
      value: function(E, N) {
        return N.length ? this == Mn ? A.create(E, N) : this.addInner(E, N, 0) : this;
      }
    }, {
      key: "addInner",
      value: function(E, N, H) {
        var Y = this, le, me = 0;
        E.forEach(function(st, Tt) {
          var ht = Tt + H, _t;
          if (_t = Lr(N, st, ht)) {
            for (le || (le = Y.children.slice()); me < le.length && le[me] < Tt; )
              me += 3;
            le[me] == Tt ? le[me + 2] = le[me + 2].addInner(st, _t, ht + 1) : le.splice(me, 0, Tt, Tt + st.nodeSize, Il(_t, st, ht + 1, Ga)), me += 3;
          }
        });
        for (var Pe = Jc(me ? Ks(N) : N, -H), $e = 0; $e < Pe.length; $e++)
          Pe[$e].type.valid(E, Pe[$e]) || Pe.splice($e--, 1);
        return new A(Pe.length ? this.local.concat(Pe).sort(Uo) : this.local, le || this.children);
      }
    }, {
      key: "remove",
      value: function(E) {
        return E.length == 0 || this == Mn ? this : this.removeInner(E, 0);
      }
    }, {
      key: "removeInner",
      value: function(E, N) {
        for (var H = this.children, Y = this.local, le = 0; le < H.length; le += 3) {
          for (var me = void 0, Pe = H[le] + N, $e = H[le + 1] + N, st = 0, Tt; st < E.length; st++)
            (Tt = E[st]) && Tt.from > Pe && Tt.to < $e && (E[st] = null, (me || (me = [])).push(Tt));
          if (me) {
            H == this.children && (H = this.children.slice());
            var ht = H[le + 2].removeInner(me, Pe + 1);
            ht != Mn ? H[le + 2] = ht : (H.splice(le, 3), le -= 3);
          }
        }
        if (Y.length) {
          for (var _t = 0, Ht; _t < E.length; _t++)
            if (Ht = E[_t])
              for (var nr = 0; nr < Y.length; nr++)
                Y[nr].eq(Ht, N) && (Y == this.local && (Y = this.local.slice()), Y.splice(nr--, 1));
        }
        return H == this.children && Y == this.local ? this : Y.length || H.length ? new A(Y, H) : Mn;
      }
    }, {
      key: "forChild",
      value: function(E, N) {
        if (this == Mn) return this;
        if (N.isLeaf) return A.empty;
        for (var H, Y, le = 0; le < this.children.length; le += 3)
          if (this.children[le] >= E) {
            this.children[le] == E && (H = this.children[le + 2]);
            break;
          }
        for (var me = E + 1, Pe = me + N.content.size, $e = 0; $e < this.local.length; $e++) {
          var st = this.local[$e];
          if (st.from < Pe && st.to > me && st.type instanceof qs) {
            var Tt = Math.max(me, st.from) - me, ht = Math.min(Pe, st.to) - me;
            Tt < ht && (Y || (Y = [])).push(st.copy(Tt, ht));
          }
        }
        if (Y) {
          var _t = new A(Y.sort(Uo), ks);
          return H ? new Xc([_t, H]) : _t;
        }
        return H || Mn;
      }
    }, {
      key: "eq",
      value: function(E) {
        if (this == E) return !0;
        if (!(E instanceof A) || this.local.length != E.local.length || this.children.length != E.children.length) return !1;
        for (var N = 0; N < this.local.length; N++)
          if (!this.local[N].eq(E.local[N])) return !1;
        for (var H = 0; H < this.children.length; H += 3)
          if (this.children[H] != E.children[H] || this.children[H + 1] != E.children[H + 1] || !this.children[H + 2].eq(E.children[H + 2])) return !1;
        return !0;
      }
    }, {
      key: "locals",
      value: function(E) {
        return Gu(this.localsInner(E));
      }
    }, {
      key: "localsInner",
      value: function(E) {
        if (this == Mn) return ks;
        if (E.inlineContent || !this.local.some(qs.is)) return this.local;
        for (var N = [], H = 0; H < this.local.length; H++)
          this.local[H].type instanceof qs || N.push(this.local[H]);
        return N;
      }
    }], [{
      key: "create",
      value: function(E, N) {
        return N.length ? Il(N, E, 0, Ga) : Mn;
      }
    }]), A;
  }();
  zi.empty = new zi([], []), zi.removeOverlap = Gu;
  var Mn = zi.empty, Xc = function() {
    function A(B) {
      w(this, A), this.members = B;
    }
    return O(A, [{
      key: "map",
      value: function(E, N) {
        var H = this.members.map(function(Y) {
          return Y.map(E, N, Ga);
        });
        return A.from(H);
      }
    }, {
      key: "forChild",
      value: function(E, N) {
        if (N.isLeaf) return zi.empty;
        for (var H = [], Y = 0; Y < this.members.length; Y++) {
          var le = this.members[Y].forChild(E, N);
          le != Mn && (le instanceof A ? H = H.concat(le.members) : H.push(le));
        }
        return A.from(H);
      }
    }, {
      key: "eq",
      value: function(E) {
        if (!(E instanceof A) || E.members.length != this.members.length) return !1;
        for (var N = 0; N < this.members.length; N++)
          if (!this.members[N].eq(E.members[N])) return !1;
        return !0;
      }
    }, {
      key: "locals",
      value: function(E) {
        for (var N, H = !0, Y = 0; Y < this.members.length; Y++) {
          var le = this.members[Y].localsInner(E);
          if (le.length)
            if (!N)
              N = le;
            else {
              H && (N = N.slice(), H = !1);
              for (var me = 0; me < le.length; me++)
                N.push(le[me]);
            }
        }
        return N ? Gu(H ? N : N.sort(Uo)) : ks;
      }
    }], [{
      key: "from",
      value: function(E) {
        switch (E.length) {
          case 0:
            return Mn;
          case 1:
            return E[0];
          default:
            return new A(E.every(function(N) {
              return N instanceof zi;
            }) ? E : E.reduce(function(N, H) {
              return N.concat(H instanceof zi ? H : H.members);
            }, []));
        }
      }
    }]), A;
  }();
  function Ip(A, B, E, N, H, Y, le) {
    for (var me = A.slice(), Pe = function(aa, Ca) {
      var Ya = 0;
      E.maps[aa].forEach(function(oa, yn, uf, Up) {
        for (var Cs = Up - uf - (yn - oa), Vo = 0; Vo < me.length; Vo += 3) {
          var cf = me[Vo + 1];
          if (!(cf < 0 || oa > cf + Ca - Ya)) {
            var sa = me[Vo] + Ca - Ya;
            yn >= sa ? me[Vo + 1] = oa <= sa ? -2 : -1 : uf >= H && Cs && (me[Vo] += Cs, me[Vo + 1] += Cs);
          }
        }
        Ya += Cs;
      }), Ca = E.maps[aa].map(Ca, -1), st = Ca;
    }, $e = 0, st = Y; $e < E.maps.length; $e++)
      Pe($e, st);
    for (var Tt = !1, ht = 0; ht < me.length; ht += 3)
      if (me[ht + 1] < 0) {
        if (me[ht + 1] == -2) {
          Tt = !0, me[ht + 1] = -1;
          continue;
        }
        var _t = E.map(A[ht] + Y), Ht = _t - H;
        if (Ht < 0 || Ht >= N.content.size) {
          Tt = !0;
          continue;
        }
        var nr = E.map(A[ht + 1] + Y, -1), Tr = nr - H, Zt = N.content.findIndex(Ht), Gr = Zt.index, Or = Zt.offset, en = N.maybeChild(Gr);
        if (en && Or == Ht && Or + en.nodeSize == Tr) {
          var Nr = me[ht + 2].mapInner(E, en, _t + 1, A[ht] + Y + 1, le);
          Nr != Mn ? (me[ht] = Ht, me[ht + 1] = Tr, me[ht + 2] = Nr) : (me[ht + 1] = -2, Tt = !0);
        } else
          Tt = !0;
      }
    if (Tt) {
      var zr = Hi(me, A, B, E, H, Y, le), fn = Il(zr, N, 0, le);
      B = fn.local;
      for (var ki = 0; ki < me.length; ki += 3)
        me[ki + 1] < 0 && (me.splice(ki, 3), ki -= 3);
      for (var na = 0, Rn = 0; na < fn.children.length; na += 3) {
        for (var ia = fn.children[na]; Rn < me.length && me[Rn] < ia; )
          Rn += 3;
        me.splice(Rn, 0, fn.children[na], fn.children[na + 1], fn.children[na + 2]);
      }
    }
    return new zi(B.sort(Uo), me);
  }
  function Jc(A, B) {
    if (!B || !A.length) return A;
    for (var E = [], N = 0; N < A.length; N++) {
      var H = A[N];
      E.push(new $o(H.from + B, H.to + B, H.type));
    }
    return E;
  }
  function Hi(A, B, E, N, H, Y, le) {
    function me($e, st) {
      for (var Tt = 0; Tt < $e.local.length; Tt++) {
        var ht = $e.local[Tt].map(N, H, st);
        ht ? E.push(ht) : le.onRemove && le.onRemove($e.local[Tt].spec);
      }
      for (var _t = 0; _t < $e.children.length; _t += 3)
        me($e.children[_t + 2], $e.children[_t] + st + 1);
    }
    for (var Pe = 0; Pe < A.length; Pe += 3)
      A[Pe + 1] == -1 && me(A[Pe + 2], B[Pe] + Y + 1);
    return E;
  }
  function Lr(A, B, E) {
    if (B.isLeaf) return null;
    for (var N = E + B.nodeSize, H = null, Y = 0, le; Y < A.length; Y++)
      (le = A[Y]) && le.from > E && le.to < N && ((H || (H = [])).push(le), A[Y] = null);
    return H;
  }
  function Ks(A) {
    for (var B = [], E = 0; E < A.length; E++)
      A[E] != null && B.push(A[E]);
    return B;
  }
  function Il(A, B, E, N) {
    var H = [], Y = !1;
    B.forEach(function(Pe, $e) {
      var st = Lr(A, Pe, $e + E);
      if (st) {
        Y = !0;
        var Tt = Il(st, Pe, E + $e + 1, N);
        Tt != Mn && H.push($e, $e + Pe.nodeSize, Tt);
      }
    });
    for (var le = Jc(Y ? Ks(A) : A, -E).sort(Uo), me = 0; me < le.length; me++)
      le[me].type.valid(B, le[me]) || (N.onRemove && N.onRemove(le[me].spec), le.splice(me--, 1));
    return le.length || H.length ? new zi(le, H) : Mn;
  }
  function Uo(A, B) {
    return A.from - B.from || A.to - B.to;
  }
  function Gu(A) {
    for (var B = A, E = 0; E < B.length - 1; E++) {
      var N = B[E];
      if (N.from != N.to) for (var H = E + 1; H < B.length; H++) {
        var Y = B[H];
        if (Y.from == N.from) {
          Y.to != N.to && (B == A && (B = A.slice()), B[H] = Y.copy(Y.from, N.to), Zc(B, H + 1, Y.copy(N.to, Y.to)));
          continue;
        } else {
          Y.from < N.to && (B == A && (B = A.slice()), B[E] = N.copy(N.from, Y.from), Zc(B, H, N.copy(Y.from, N.to)));
          break;
        }
      }
    }
    return B;
  }
  function Zc(A, B, E) {
    for (; B < A.length && Uo(E, A[B]) > 0; )
      B++;
    A.splice(B, 0, E);
  }
  function Yu(A) {
    var B = [];
    return A.someProp("decorations", function(E) {
      var N = E(A.state);
      N && N != Mn && B.push(N);
    }), A.cursorWrapper && B.push(zi.create(A.state.doc, [A.cursorWrapper.deco])), Xc.from(B);
  }
  var qu = {
    childList: !0,
    characterData: !0,
    characterDataOldValue: !0,
    attributes: !0,
    attributeOldValue: !0,
    subtree: !0
  }, Qc = At && Mt <= 11, _p = function() {
    function A() {
      w(this, A), this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
    }
    return O(A, [{
      key: "set",
      value: function(E) {
        this.anchorNode = E.anchorNode, this.anchorOffset = E.anchorOffset, this.focusNode = E.focusNode, this.focusOffset = E.focusOffset;
      }
    }, {
      key: "clear",
      value: function() {
        this.anchorNode = this.focusNode = null;
      }
    }, {
      key: "eq",
      value: function(E) {
        return E.anchorNode == this.anchorNode && E.anchorOffset == this.anchorOffset && E.focusNode == this.focusNode && E.focusOffset == this.focusOffset;
      }
    }]), A;
  }(), Np = function() {
    function A(B, E) {
      var N = this;
      w(this, A), this.view = B, this.handleDOMChange = E, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new _p(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.observer = window.MutationObserver && new window.MutationObserver(function(H) {
        for (var Y = 0; Y < H.length; Y++)
          N.queue.push(H[Y]);
        At && Mt <= 11 && H.some(function(le) {
          return le.type == "childList" && le.removedNodes.length || le.type == "characterData" && le.oldValue.length > le.target.nodeValue.length;
        }) ? N.flushSoon() : N.flush();
      }), Qc && (this.onCharData = function(H) {
        N.queue.push({
          target: H.target,
          type: "characterData",
          oldValue: H.prevValue
        }), N.flushSoon();
      }), this.onSelectionChange = this.onSelectionChange.bind(this);
    }
    return O(A, [{
      key: "flushSoon",
      value: function() {
        var E = this;
        this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(function() {
          E.flushingSoon = -1, E.flush();
        }, 20));
      }
    }, {
      key: "forceFlush",
      value: function() {
        this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
      }
    }, {
      key: "start",
      value: function() {
        this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, qu)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
      }
    }, {
      key: "stop",
      value: function() {
        var E = this;
        if (this.observer) {
          var N = this.observer.takeRecords();
          if (N.length) {
            for (var H = 0; H < N.length; H++)
              this.queue.push(N[H]);
            window.setTimeout(function() {
              return E.flush();
            }, 20);
          }
          this.observer.disconnect();
        }
        this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
      }
    }, {
      key: "connectSelection",
      value: function() {
        this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
      }
    }, {
      key: "disconnectSelection",
      value: function() {
        this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
      }
    }, {
      key: "suppressSelectionUpdates",
      value: function() {
        var E = this;
        this.suppressingSelectionUpdates = !0, setTimeout(function() {
          return E.suppressingSelectionUpdates = !1;
        }, 50);
      }
    }, {
      key: "onSelectionChange",
      value: function() {
        if (_i(this.view)) {
          if (this.suppressingSelectionUpdates) return Di(this.view);
          if (At && Mt <= 11 && !this.view.state.selection.empty) {
            var E = this.view.domSelectionRange();
            if (E.focusNode && re(E.focusNode, E.focusOffset, E.anchorNode, E.anchorOffset)) return this.flushSoon();
          }
          this.flush();
        }
      }
    }, {
      key: "setCurSelection",
      value: function() {
        this.currentSelection.set(this.view.domSelectionRange());
      }
    }, {
      key: "ignoreSelectionChange",
      value: function(E) {
        if (!E.focusNode) return !0;
        for (var N = /* @__PURE__ */ new Set(), H, Y = E.focusNode; Y; Y = J(Y))
          N.add(Y);
        for (var le = E.anchorNode; le; le = J(le))
          if (N.has(le)) {
            H = le;
            break;
          }
        var me = H && this.view.docView.nearestDesc(H);
        if (me && me.ignoreMutation({
          type: "selection",
          target: H.nodeType == 3 ? H.parentNode : H
        }))
          return this.setCurSelection(), !0;
      }
    }, {
      key: "pendingRecords",
      value: function() {
        if (this.observer) {
          var E = e(this.observer.takeRecords()), N;
          try {
            for (E.s(); !(N = E.n()).done; ) {
              var H = N.value;
              this.queue.push(H);
            }
          } catch (Y) {
            E.e(Y);
          } finally {
            E.f();
          }
        }
        return this.queue;
      }
    }, {
      key: "flush",
      value: function() {
        var E = this.view;
        if (!(!E.docView || this.flushingSoon > -1)) {
          var N = this.pendingRecords();
          N.length && (this.queue = []);
          var H = E.domSelectionRange(), Y = !this.suppressingSelectionUpdates && !this.currentSelection.eq(H) && _i(E) && !this.ignoreSelectionChange(H), le = -1, me = -1, Pe = !1, $e = [];
          if (E.editable)
            for (var st = 0; st < N.length; st++) {
              var Tt = this.registerMutation(N[st], $e);
              Tt && (le = le < 0 ? Tt.from : Math.min(Tt.from, le), me = me < 0 ? Tt.to : Math.max(Tt.to, me), Tt.typeOver && (Pe = !0));
            }
          if (St && $e.length > 1) {
            var ht = $e.filter(function(Tr) {
              return Tr.nodeName == "BR";
            });
            if (ht.length == 2) {
              var _t = ht[0], Ht = ht[1];
              _t.parentNode && _t.parentNode.parentNode == Ht.parentNode ? Ht.remove() : _t.remove();
            }
          }
          var nr = null;
          le < 0 && Y && E.input.lastFocus > Date.now() - 200 && Math.max(E.input.lastTouch, E.input.lastClick.time) < Date.now() - 300 && ge(H) && (nr = bi(E)) && nr.eq(T.Selection.near(E.state.doc.resolve(0), 1)) ? (E.input.lastFocus = 0, Di(E), this.currentSelection.set(H), E.scrollToSelection()) : (le > -1 || Y) && (le > -1 && (E.docView.markDirty(le, me), Bp(E)), this.handleDOMChange(le, me, Pe, $e), E.docView && E.docView.dirty ? E.updateState(E.state) : this.currentSelection.eq(H) || Di(E), this.currentSelection.set(H));
        }
      }
    }, {
      key: "registerMutation",
      value: function(E, N) {
        if (N.indexOf(E.target) > -1) return null;
        var H = this.view.docView.nearestDesc(E.target);
        if (E.type == "attributes" && (H == this.view.docView || E.attributeName == "contenteditable" || E.attributeName == "style" && !E.oldValue && !E.target.getAttribute("style")) || !H || H.ignoreMutation(E)) return null;
        if (E.type == "childList") {
          for (var Y = 0; Y < E.addedNodes.length; Y++)
            N.push(E.addedNodes[Y]);
          if (H.contentDOM && H.contentDOM != H.dom && !H.contentDOM.contains(E.target)) return {
            from: H.posBefore,
            to: H.posAfter
          };
          var le = E.previousSibling, me = E.nextSibling;
          if (At && Mt <= 11 && E.addedNodes.length)
            for (var Pe = 0; Pe < E.addedNodes.length; Pe++) {
              var $e = E.addedNodes[Pe], st = $e.previousSibling, Tt = $e.nextSibling;
              (!st || Array.prototype.indexOf.call(E.addedNodes, st) < 0) && (le = st), (!Tt || Array.prototype.indexOf.call(E.addedNodes, Tt) < 0) && (me = Tt);
            }
          var ht = le && le.parentNode == E.target ? z(le) + 1 : 0, _t = H.localPosFromDOM(E.target, ht, -1), Ht = me && me.parentNode == E.target ? z(me) : E.target.childNodes.length, nr = H.localPosFromDOM(E.target, Ht, 1);
          return {
            from: _t,
            to: nr
          };
        } else return E.type == "attributes" ? {
          from: H.posAtStart - H.border,
          to: H.posAtEnd + H.border
        } : {
          from: H.posAtStart,
          to: H.posAtEnd,
          typeOver: E.target.nodeValue == E.oldValue
        };
      }
    }]), A;
  }(), ef = /* @__PURE__ */ new WeakMap(), tf = !1;
  function Bp(A) {
    if (!ef.has(A) && (ef.set(A, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(A.dom).whiteSpace) !== -1)) {
      if (A.requiresGeckoHackNode = St, tf) return;
      console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), tf = !0;
    }
  }
  function Ku(A) {
    var B;
    function E($e) {
      $e.preventDefault(), $e.stopImmediatePropagation(), B = $e.getTargetRanges()[0];
    }
    A.dom.addEventListener("beforeinput", E, !0), document.execCommand("indent"), A.dom.removeEventListener("beforeinput", E, !0);
    var N = B.startContainer, H = B.startOffset, Y = B.endContainer, le = B.endOffset, me = A.domAtPos(A.state.selection.anchor);
    if (re(me.node, me.offset, Y, le)) {
      var Pe = [Y, le, N, H];
      N = Pe[0], H = Pe[1], Y = Pe[2], le = Pe[3];
    }
    return {
      anchorNode: N,
      anchorOffset: H,
      focusNode: Y,
      focusOffset: le
    };
  }
  function Fp(A, B, E) {
    var N = A.docView.parseRange(B, E), H = N.node, Y = N.fromOffset, le = N.toOffset, me = N.from, Pe = N.to, $e = A.domSelectionRange(), st, Tt = $e.anchorNode;
    if (Tt && A.dom.contains(Tt.nodeType == 1 ? Tt : Tt.parentNode) && (st = [{
      node: Tt,
      offset: $e.anchorOffset
    }], ge($e) || st.push({
      node: $e.focusNode,
      offset: $e.focusOffset
    })), Ue && A.input.lastKeyCode === 8)
      for (var ht = le; ht > Y; ht--) {
        var _t = H.childNodes[ht - 1], Ht = _t.pmViewDesc;
        if (_t.nodeName == "BR" && !Ht) {
          le = ht;
          break;
        }
        if (!Ht || Ht.size) break;
      }
    var nr = A.state.doc, Tr = A.someProp("domParser") || L.DOMParser.fromSchema(A.state.schema), Zt = nr.resolve(me), Gr = null, Or = Tr.parse(H, {
      topNode: Zt.parent,
      topMatch: Zt.parent.contentMatchAt(Zt.index()),
      topOpen: !0,
      from: Y,
      to: le,
      preserveWhitespace: Zt.parent.type.whitespace == "pre" ? "full" : !0,
      findPositions: st,
      ruleFromNode: zp,
      context: Zt
    });
    if (st && st[0].pos != null) {
      var en = st[0].pos, Nr = st[1] && st[1].pos;
      Nr == null && (Nr = en), Gr = {
        anchor: en + me,
        head: Nr + me
      };
    }
    return {
      doc: Or,
      sel: Gr,
      from: me,
      to: Pe
    };
  }
  function zp(A) {
    var B = A.pmViewDesc;
    if (B)
      return B.parseRule();
    if (A.nodeName == "BR" && A.parentNode) {
      if (We && /^(ul|ol)$/i.test(A.parentNode.nodeName)) {
        var E = document.createElement("div");
        return E.appendChild(document.createElement("li")), {
          skip: E
        };
      } else if (A.parentNode.lastChild == A || We && /^(tr|table)$/i.test(A.parentNode.nodeName))
        return {
          ignore: !0
        };
    } else if (A.nodeName == "IMG" && A.getAttribute("mark-placeholder"))
      return {
        ignore: !0
      };
    return null;
  }
  var Os = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
  function Hp(A, B, E, N, H) {
    var Y = A.input.compositionPendingChanges || (A.composing ? A.input.compositionID : 0);
    if (A.input.compositionPendingChanges = 0, B < 0) {
      var le = A.input.lastSelectionTime > Date.now() - 50 ? A.input.lastSelectionOrigin : null, me = bi(A, le);
      if (me && !A.state.selection.eq(me)) {
        if (Ue && tt && A.input.lastKeyCode === 13 && Date.now() - 100 < A.input.lastKeyCodeTime && A.someProp("handleKeyDown", function(yn) {
          return yn(A, we(13, "Enter"));
        })) return;
        var Pe = A.state.tr.setSelection(me);
        le == "pointer" ? Pe.setMeta("pointer", !0) : le == "key" && Pe.scrollIntoView(), Y && Pe.setMeta("composition", Y), A.dispatch(Pe);
      }
      return;
    }
    var $e = A.state.doc.resolve(B), st = $e.sharedDepth(E);
    B = $e.before(st + 1), E = A.state.doc.resolve(E).after(st + 1);
    var Tt = A.state.selection, ht = Fp(A, B, E), _t = A.state.doc, Ht = _t.slice(ht.from, ht.to), nr, Tr;
    A.input.lastKeyCode === 8 && Date.now() - 100 < A.input.lastKeyCodeTime ? (nr = A.state.selection.to, Tr = "end") : (nr = A.state.selection.from, Tr = "start"), A.input.lastKeyCode = null;
    var Zt = Vr(Ht.content, ht.doc.content, ht.from, nr, Tr);
    if ((ze && A.input.lastIOSEnter > Date.now() - 225 || tt) && H.some(function(yn) {
      return yn.nodeType == 1 && !Os.test(yn.nodeName);
    }) && (!Zt || Zt.endA >= Zt.endB) && A.someProp("handleKeyDown", function(yn) {
      return yn(A, we(13, "Enter"));
    })) {
      A.input.lastIOSEnter = 0;
      return;
    }
    if (!Zt)
      if (N && Tt instanceof T.TextSelection && !Tt.empty && Tt.$head.sameParent(Tt.$anchor) && !A.composing && !(ht.sel && ht.sel.anchor != ht.sel.head))
        Zt = {
          start: Tt.from,
          endA: Tt.to,
          endB: Tt.to
        };
      else {
        if (ht.sel) {
          var Gr = Xs(A, A.state.doc, ht.sel);
          if (Gr && !Gr.eq(A.state.selection)) {
            var Or = A.state.tr.setSelection(Gr);
            Y && Or.setMeta("composition", Y), A.dispatch(Or);
          }
        }
        return;
      }
    if (Ue && A.cursorWrapper && ht.sel && ht.sel.anchor == A.cursorWrapper.deco.from && ht.sel.head == ht.sel.anchor) {
      var en = Zt.endB - Zt.start;
      ht.sel = {
        anchor: ht.sel.anchor + en,
        head: ht.sel.anchor + en
      };
    }
    A.input.domChangeCount++, A.state.selection.from < A.state.selection.to && Zt.start == Zt.endB && A.state.selection instanceof T.TextSelection && (Zt.start > A.state.selection.from && Zt.start <= A.state.selection.from + 2 && A.state.selection.from >= ht.from ? Zt.start = A.state.selection.from : Zt.endA < A.state.selection.to && Zt.endA >= A.state.selection.to - 2 && A.state.selection.to <= ht.to && (Zt.endB += A.state.selection.to - Zt.endA, Zt.endA = A.state.selection.to)), At && Mt <= 11 && Zt.endB == Zt.start + 1 && Zt.endA == Zt.start && Zt.start > ht.from && ht.doc.textBetween(Zt.start - ht.from - 1, Zt.start - ht.from + 1) == "  " && (Zt.start--, Zt.endA--, Zt.endB--);
    var Nr = ht.doc.resolveNoCache(Zt.start - ht.from), zr = ht.doc.resolveNoCache(Zt.endB - ht.from), fn = _t.resolve(Zt.start), ki = Nr.sameParent(zr) && Nr.parent.inlineContent && fn.end() >= Zt.endA, na;
    if ((ze && A.input.lastIOSEnter > Date.now() - 225 && (!ki || H.some(function(yn) {
      return yn.nodeName == "DIV" || yn.nodeName == "P";
    })) || !ki && Nr.pos < ht.doc.content.size && !Nr.sameParent(zr) && (na = T.Selection.findFrom(ht.doc.resolve(Nr.pos + 1), 1, !0)) && na.head == zr.pos) && A.someProp("handleKeyDown", function(yn) {
      return yn(A, we(13, "Enter"));
    })) {
      A.input.lastIOSEnter = 0;
      return;
    }
    if (A.state.selection.anchor > Zt.start && _r(_t, Zt.start, Zt.endA, Nr, zr) && A.someProp("handleKeyDown", function(yn) {
      return yn(A, we(8, "Backspace"));
    })) {
      tt && Ue && A.domObserver.suppressSelectionUpdates();
      return;
    }
    Ue && tt && Zt.endB == Zt.start && (A.input.lastAndroidDelete = Date.now()), tt && !ki && Nr.start() != zr.start() && zr.parentOffset == 0 && Nr.depth == zr.depth && ht.sel && ht.sel.anchor == ht.sel.head && ht.sel.head == Zt.endA && (Zt.endB -= 2, zr = ht.doc.resolveNoCache(Zt.endB - ht.from), setTimeout(function() {
      A.someProp("handleKeyDown", function(yn) {
        return yn(A, we(13, "Enter"));
      });
    }, 20));
    var Rn = Zt.start, ia = Zt.endA, ii, aa, Ca;
    if (ki) {
      if (Nr.pos == zr.pos)
        At && Mt <= 11 && Nr.parentOffset == 0 && (A.domObserver.suppressSelectionUpdates(), setTimeout(function() {
          return Di(A);
        }, 20)), ii = A.state.tr.delete(Rn, ia), aa = _t.resolve(Zt.start).marksAcross(_t.resolve(Zt.endA));
      else if (Zt.endA == Zt.endB && (Ca = ji(Nr.parent.content.cut(Nr.parentOffset, zr.parentOffset), fn.parent.content.cut(fn.parentOffset, Zt.endA - fn.start()))))
        ii = A.state.tr, Ca.type == "add" ? ii.addMark(Rn, ia, Ca.mark) : ii.removeMark(Rn, ia, Ca.mark);
      else if (Nr.parent.child(Nr.index()).isText && Nr.index() == zr.index() - (zr.textOffset ? 0 : 1)) {
        var Ya = Nr.parent.textBetween(Nr.parentOffset, zr.parentOffset);
        if (A.someProp("handleTextInput", function(yn) {
          return yn(A, Rn, ia, Ya);
        })) return;
        ii = A.state.tr.insertText(Ya, Rn, ia);
      }
    }
    if (ii || (ii = A.state.tr.replace(Rn, ia, ht.doc.slice(Zt.start - ht.from, Zt.endB - ht.from))), ht.sel) {
      var oa = Xs(A, ii.doc, ht.sel);
      oa && !(Ue && tt && A.composing && oa.empty && (Zt.start != Zt.endB || A.input.lastAndroidDelete < Date.now() - 100) && (oa.head == Rn || oa.head == ii.mapping.map(ia) - 1) || At && oa.empty && oa.head == Rn) && ii.setSelection(oa);
    }
    aa && ii.ensureMarks(aa), Y && ii.setMeta("composition", Y), A.dispatch(ii.scrollIntoView());
  }
  function Xs(A, B, E) {
    return Math.max(E.anchor, E.head) > B.content.size ? null : Ii(A, B.resolve(E.anchor), B.resolve(E.head));
  }
  function ji(A, B) {
    for (var E = A.firstChild.marks, N = B.firstChild.marks, H = E, Y = N, le, me, Pe, $e = 0; $e < N.length; $e++)
      H = N[$e].removeFromSet(H);
    for (var st = 0; st < E.length; st++)
      Y = E[st].removeFromSet(Y);
    if (H.length == 1 && Y.length == 0)
      me = H[0], le = "add", Pe = function(Ht) {
        return Ht.mark(me.addToSet(Ht.marks));
      };
    else if (H.length == 0 && Y.length == 1)
      me = Y[0], le = "remove", Pe = function(Ht) {
        return Ht.mark(me.removeFromSet(Ht.marks));
      };
    else
      return null;
    for (var Tt = [], ht = 0; ht < B.childCount; ht++)
      Tt.push(Pe(B.child(ht)));
    if (L.Fragment.from(Tt).eq(A)) return {
      mark: me,
      type: le
    };
  }
  function _r(A, B, E, N, H) {
    if (!N.parent.isTextblock || E - B <= H.pos - N.pos || Xu(N, !0, !1) < H.pos) return !1;
    var Y = A.resolve(B);
    if (Y.parentOffset < Y.parent.content.size || !Y.parent.isTextblock) return !1;
    var le = A.resolve(Xu(Y, !0, !0));
    return !le.parent.isTextblock || le.pos > E || Xu(le, !0, !1) < E ? !1 : N.parent.content.cut(N.parentOffset).eq(le.parent.content);
  }
  function Xu(A, B, E) {
    for (var N = A.depth, H = B ? A.end() : A.pos; N > 0 && (B || A.indexAfter(N) == A.node(N).childCount); )
      N--, H++, B = !1;
    if (E)
      for (var Y = A.node(N).maybeChild(A.indexAfter(N)); Y && !Y.isLeaf; )
        Y = Y.firstChild, H++;
    return H;
  }
  function Vr(A, B, E, N, H) {
    var Y = A.findDiffStart(B, E);
    if (Y == null) return null;
    var le = A.findDiffEnd(B, E + A.size, E + B.size), me = le.a, Pe = le.b;
    if (H == "end") {
      var $e = Math.max(0, Y - Math.min(me, Pe));
      N -= me + $e - Y;
    }
    if (me < Y && A.size < B.size) {
      var st = N <= Y && N >= me ? Y - N : 0;
      Y -= st, Pe = Y + (Pe - me), me = Y;
    } else if (Pe < Y) {
      var Tt = N <= Y && N >= Pe ? Y - N : 0;
      Y -= Tt, me = Y + (me - Pe), Pe = Y;
    }
    return {
      start: Y,
      endA: me,
      endB: Pe
    };
  }
  var rf = hn, nf = go, jp = Oa, af = function() {
    function A(B, E) {
      var N = this;
      w(this, A), this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new Ml(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = E, this.state = E.state, this.directPlugins = E.plugins || [], this.directPlugins.forEach(Zu), this.dispatch = this.dispatch.bind(this), this.dom = B && B.mount || document.createElement("div"), B && (B.appendChild ? B.appendChild(this.dom) : typeof B == "function" ? B(this.dom) : B.mount && (this.mounted = !0)), this.editable = sf(this), of(this), this.nodeViews = lf(this), this.docView = It(this.state.doc, Ju(this), Yu(this), this.dom, this), this.domObserver = new Np(this, function(H, Y, le, me) {
        return Hp(N, H, Y, le, me);
      }), this.domObserver.start(), Fu(this), this.updatePluginViews();
    }
    return O(A, [{
      key: "composing",
      get: function() {
        return this.input.composing;
      }
    }, {
      key: "props",
      get: function() {
        if (this._props.state != this.state) {
          var E = this._props;
          this._props = {};
          for (var N in E)
            this._props[N] = E[N];
          this._props.state = this.state;
        }
        return this._props;
      }
    }, {
      key: "update",
      value: function(E) {
        E.handleDOMEvents != this._props.handleDOMEvents && zu(this);
        var N = this._props;
        this._props = E, E.plugins && (E.plugins.forEach(Zu), this.directPlugins = E.plugins), this.updateStateInner(E.state, N);
      }
    }, {
      key: "setProps",
      value: function(E) {
        var N = {};
        for (var H in this._props)
          N[H] = this._props[H];
        N.state = this.state;
        for (var Y in E)
          N[Y] = E[Y];
        this.update(N);
      }
    }, {
      key: "updateState",
      value: function(E) {
        this.updateStateInner(E, this._props);
      }
    }, {
      key: "updateStateInner",
      value: function(E, N) {
        var H = this.state, Y = !1, le = !1;
        E.storedMarks && this.composing && (bo(this), le = !0), this.state = E;
        var me = H.plugins != E.plugins || this._props.plugins != N.plugins;
        if (me || this._props.plugins != N.plugins || this._props.nodeViews != N.nodeViews) {
          var Pe = lf(this);
          $p(Pe, this.nodeViews) && (this.nodeViews = Pe, Y = !0);
        }
        (me || N.handleDOMEvents != this._props.handleDOMEvents) && zu(this), this.editable = sf(this), of(this);
        var $e = Yu(this), st = Ju(this), Tt = H.plugins != E.plugins && !H.doc.eq(E.doc) ? "reset" : E.scrollToSelection > H.scrollToSelection ? "to selection" : "preserve", ht = Y || !this.docView.matchesNode(E.doc, st, $e);
        (ht || !E.selection.eq(H.selection)) && (le = !0);
        var _t = Tt == "preserve" && le && this.dom.style.overflowAnchor == null && lt(this);
        if (le) {
          this.domObserver.stop();
          var Ht = ht && (At || Ue) && !this.composing && !H.selection.empty && !E.selection.empty && Wp(H.selection, E.selection);
          if (ht) {
            var nr = Ue ? this.trackWrites = this.domSelectionRange().focusNode : null;
            (Y || !this.docView.update(E.doc, st, $e, this)) && (this.docView.updateOuterDeco([]), this.docView.destroy(), this.docView = It(E.doc, st, $e, this.dom, this)), nr && !this.trackWrites && (Ht = !0);
          }
          Ht || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && ys(this)) ? Di(this, Ht) : (Fo(this, E.selection), this.domObserver.setCurSelection()), this.domObserver.start();
        }
        this.updatePluginViews(H), Tt == "reset" ? this.dom.scrollTop = 0 : Tt == "to selection" ? this.scrollToSelection() : _t && te(_t);
      }
    }, {
      key: "scrollToSelection",
      value: function() {
        var E = this, N = this.domSelectionRange().focusNode;
        if (!this.someProp("handleScrollToSelection", function(Y) {
          return Y(E);
        })) if (this.state.selection instanceof T.NodeSelection) {
          var H = this.docView.domAfterPos(this.state.selection.from);
          H.nodeType == 1 && Xe(this, H.getBoundingClientRect(), N);
        } else
          Xe(this, this.coordsAtPos(this.state.selection.head, 1), N);
      }
    }, {
      key: "destroyPluginViews",
      value: function() {
        for (var E; E = this.pluginViews.pop(); )
          E.destroy && E.destroy();
      }
    }, {
      key: "updatePluginViews",
      value: function(E) {
        if (!E || E.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
          this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
          for (var N = 0; N < this.directPlugins.length; N++) {
            var H = this.directPlugins[N];
            H.spec.view && this.pluginViews.push(H.spec.view(this));
          }
          for (var Y = 0; Y < this.state.plugins.length; Y++) {
            var le = this.state.plugins[Y];
            le.spec.view && this.pluginViews.push(le.spec.view(this));
          }
        } else
          for (var me = 0; me < this.pluginViews.length; me++) {
            var Pe = this.pluginViews[me];
            Pe.update && Pe.update(this, E);
          }
      }
    }, {
      key: "someProp",
      value: function(E, N) {
        var H = this._props && this._props[E], Y;
        if (H != null && (Y = N ? N(H) : H)) return Y;
        for (var le = 0; le < this.directPlugins.length; le++) {
          var me = this.directPlugins[le].props[E];
          if (me != null && (Y = N ? N(me) : me)) return Y;
        }
        var Pe = this.state.plugins;
        if (Pe) for (var $e = 0; $e < Pe.length; $e++) {
          var st = Pe[$e].props[E];
          if (st != null && (Y = N ? N(st) : st)) return Y;
        }
      }
    }, {
      key: "hasFocus",
      value: function() {
        if (At) {
          var E = this.root.activeElement;
          if (E == this.dom) return !0;
          if (!E || !this.dom.contains(E)) return !1;
          for (; E && this.dom != E && this.dom.contains(E); ) {
            if (E.contentEditable == "false") return !1;
            E = E.parentElement;
          }
          return !0;
        }
        return this.root.activeElement == this.dom;
      }
    }, {
      key: "focus",
      value: function() {
        this.domObserver.stop(), this.editable && be(this.dom), Di(this), this.domObserver.start();
      }
    }, {
      key: "root",
      get: function() {
        var E = this, N = this._root;
        if (N == null)
          for (var H = function(Pe) {
            if (Pe.nodeType == 9 || Pe.nodeType == 11 && Pe.host)
              return Pe.getSelection || (Object.getPrototypeOf(Pe).getSelection = function() {
                return Pe.ownerDocument.getSelection();
              }), {
                v: E._root = Pe
              };
          }, Y = this.dom.parentNode; Y; Y = Y.parentNode) {
            var le = H(Y);
            if (i(le) === "object") return le.v;
          }
        return N || document;
      }
    }, {
      key: "posAtCoords",
      value: function(E) {
        return Gt(this, E);
      }
    }, {
      key: "coordsAtPos",
      value: function(E) {
        var N = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        return vt(this, E, N);
      }
    }, {
      key: "domAtPos",
      value: function(E) {
        var N = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return this.docView.domFromPos(E, N);
      }
    }, {
      key: "nodeDOM",
      value: function(E) {
        var N = this.docView.descAt(E);
        return N ? N.nodeDOM : null;
      }
    }, {
      key: "posAtDOM",
      value: function(E, N) {
        var H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1, Y = this.docView.posFromDOM(E, N, H);
        if (Y == null) throw new RangeError("DOM position not inside the editor");
        return Y;
      }
    }, {
      key: "endOfTextblock",
      value: function(E, N) {
        return ce(this, N || this.state, E);
      }
    }, {
      key: "pasteHTML",
      value: function(E, N) {
        return Ys(this, "", E, !1, N || new ClipboardEvent("paste"));
      }
    }, {
      key: "pasteText",
      value: function(E, N) {
        return Ys(this, E, null, !0, N || new ClipboardEvent("paste"));
      }
    }, {
      key: "destroy",
      value: function() {
        this.docView && (Tp(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], Yu(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null);
      }
    }, {
      key: "isDestroyed",
      get: function() {
        return this.docView == null;
      }
    }, {
      key: "dispatchEvent",
      value: function(E) {
        return Rl(this, E);
      }
    }, {
      key: "dispatch",
      value: function(E) {
        var N = this._props.dispatchTransaction;
        N ? N.call(this, E) : this.updateState(this.state.apply(E));
      }
    }, {
      key: "domSelectionRange",
      value: function() {
        return We && this.root.nodeType === 11 && Oe(this.dom.ownerDocument) == this.dom ? Ku(this) : this.domSelection();
      }
    }, {
      key: "domSelection",
      value: function() {
        return this.root.getSelection();
      }
    }]), A;
  }();
  function Ju(A) {
    var B = /* @__PURE__ */ Object.create(null);
    return B.class = "ProseMirror", B.contenteditable = String(A.editable), A.someProp("attributes", function(E) {
      if (typeof E == "function" && (E = E(A.state)), E) for (var N in E)
        N == "class" ? B.class += " " + E[N] : N == "style" ? B.style = (B.style ? B.style + ";" : "") + E[N] : !B[N] && N != "contenteditable" && N != "nodeName" && (B[N] = String(E[N]));
    }), B.translate || (B.translate = "no"), [$o.node(0, A.state.doc.content.size, B)];
  }
  function of(A) {
    if (A.markCursor) {
      var B = document.createElement("img");
      B.className = "ProseMirror-separator", B.setAttribute("mark-placeholder", "true"), B.setAttribute("alt", ""), A.cursorWrapper = {
        dom: B,
        deco: $o.widget(A.state.selection.head, B, {
          raw: !0,
          marks: A.markCursor
        })
      };
    } else
      A.cursorWrapper = null;
  }
  function sf(A) {
    return !A.someProp("editable", function(B) {
      return B(A.state) === !1;
    });
  }
  function Wp(A, B) {
    var E = Math.min(A.$anchor.sharedDepth(A.head), B.$anchor.sharedDepth(B.head));
    return A.$anchor.start(E) != B.$anchor.start(E);
  }
  function lf(A) {
    var B = /* @__PURE__ */ Object.create(null);
    function E(N) {
      for (var H in N)
        Object.prototype.hasOwnProperty.call(B, H) || (B[H] = N[H]);
    }
    return A.someProp("nodeViews", E), A.someProp("markViews", E), B;
  }
  function $p(A, B) {
    var E = 0, N = 0;
    for (var H in A) {
      if (A[H] != B[H]) return !0;
      E++;
    }
    for (var Y in B)
      N++;
    return E != N;
  }
  function Zu(A) {
    if (A.spec.state || A.spec.filterTransaction || A.spec.appendTransaction) throw new RangeError("Plugins passed directly to the view must not have a state component");
  }
  return vl.Decoration = $o, vl.DecorationSet = zi, vl.EditorView = af, vl.__endComposition = jp, vl.__parseFromClipboard = nf, vl.__serializeForClipboard = rf, vl;
}
/*!
 * @toast-ui/editor
 * @version 3.2.2 | Fri Feb 17 2023
 * @author NHN Cloud FE Development Lab <dl_javascript@nhn.com>
 * @license MIT
 */
var CV;
function CGe() {
  return CV || (CV = 1, function(i, e) {
    (function(s, l) {
      i.exports = l(/* @__PURE__ */ wGe(), /* @__PURE__ */ kGe(), /* @__PURE__ */ ek(), /* @__PURE__ */ tk(), /* @__PURE__ */ OGe());
    })(self, function(r, s, l, c, f) {
      return (
        /******/
        function() {
          var p = {
            /***/
            368: (
              /***/
              function(S) {
                /*! @license DOMPurify 2.3.3 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.3.3/LICENSE */
                (function(x, w) {
                  S.exports = w();
                })(this, function() {
                  function x(V) {
                    if (Array.isArray(V)) {
                      for (var ve = 0, Ne = Array(V.length); ve < V.length; ve++)
                        Ne[ve] = V[ve];
                      return Ne;
                    } else
                      return Array.from(V);
                  }
                  var w = Object.hasOwnProperty, k = Object.setPrototypeOf, O = Object.isFrozen, T = Object.getPrototypeOf, L = Object.getOwnPropertyDescriptor, j = Object.freeze, z = Object.seal, J = Object.create, ie = typeof Reflect < "u" && Reflect, K = ie.apply, re = ie.construct;
                  K || (K = function(ve, Ne, it) {
                    return ve.apply(Ne, it);
                  }), j || (j = function(ve) {
                    return ve;
                  }), z || (z = function(ve) {
                    return ve;
                  }), re || (re = function(ve, Ne) {
                    return new (Function.prototype.bind.apply(ve, [null].concat(x(Ne))))();
                  });
                  var ee = Ie(Array.prototype.forEach), de = Ie(Array.prototype.pop), Ce = Ie(Array.prototype.push), he = Ie(String.prototype.toLowerCase), oe = Ie(String.prototype.match), ge = Ie(String.prototype.replace), we = Ie(String.prototype.indexOf), Oe = Ie(String.prototype.trim), Qe = Ie(RegExp.prototype.test), Me = rt(TypeError);
                  function Ie(V) {
                    return function(ve) {
                      for (var Ne = arguments.length, it = Array(Ne > 1 ? Ne - 1 : 0), yt = 1; yt < Ne; yt++)
                        it[yt - 1] = arguments[yt];
                      return K(V, ve, it);
                    };
                  }
                  function rt(V) {
                    return function() {
                      for (var ve = arguments.length, Ne = Array(ve), it = 0; it < ve; it++)
                        Ne[it] = arguments[it];
                      return re(V, Ne);
                    };
                  }
                  function ot(V, ve) {
                    k && k(V, null);
                    for (var Ne = ve.length; Ne--; ) {
                      var it = ve[Ne];
                      if (typeof it == "string") {
                        var yt = he(it);
                        yt !== it && (O(ve) || (ve[Ne] = yt), it = yt);
                      }
                      V[it] = !0;
                    }
                    return V;
                  }
                  function Et(V) {
                    var ve = J(null), Ne = void 0;
                    for (Ne in V)
                      K(w, V, [Ne]) && (ve[Ne] = V[Ne]);
                    return ve;
                  }
                  function gt(V, ve) {
                    for (; V !== null; ) {
                      var Ne = L(V, ve);
                      if (Ne) {
                        if (Ne.get)
                          return Ie(Ne.get);
                        if (typeof Ne.value == "function")
                          return Ie(Ne.value);
                      }
                      V = T(V);
                    }
                    function it(yt) {
                      return console.warn("fallback value for", yt), null;
                    }
                    return it;
                  }
                  var At = j(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), Mt = j(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), St = j(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), Ve = j(["animate", "color-profile", "cursor", "discard", "fedropshadow", "feimage", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), Ue = j(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]), He = j(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), We = j(["#text"]), ze = j(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]), at = j(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), Ye = j(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), tt = j(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), wt = z(/\{\{[\s\S]*|[\s\S]*\}\}/gm), Ft = z(/<%[\s\S]*|[\s\S]*%>/gm), qe = z(/^data-[\-\w.\u00B7-\uFFFF]/), pe = z(/^aria-[\-\w]+$/), _e = z(
                    /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
                    // eslint-disable-line no-useless-escape
                  ), Xe = z(/^(?:\w+script|data):/i), lt = z(
                    /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
                    // eslint-disable-line no-control-regex
                  ), Q = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(V) {
                    return typeof V;
                  } : function(V) {
                    return V && typeof Symbol == "function" && V.constructor === Symbol && V !== Symbol.prototype ? "symbol" : typeof V;
                  };
                  function te(V) {
                    if (Array.isArray(V)) {
                      for (var ve = 0, Ne = Array(V.length); ve < V.length; ve++)
                        Ne[ve] = V[ve];
                      return Ne;
                    } else
                      return Array.from(V);
                  }
                  var De = function() {
                    return typeof window > "u" ? null : window;
                  }, nt = function(ve, Ne) {
                    if ((typeof ve > "u" ? "undefined" : Q(ve)) !== "object" || typeof ve.createPolicy != "function")
                      return null;
                    var it = null, yt = "data-tt-policy-suffix";
                    Ne.currentScript && Ne.currentScript.hasAttribute(yt) && (it = Ne.currentScript.getAttribute(yt));
                    var $t = "dompurify" + (it ? "#" + it : "");
                    try {
                      return ve.createPolicy($t, {
                        createHTML: function(Jt) {
                          return Jt;
                        }
                      });
                    } catch {
                      return console.warn("TrustedTypes policy " + $t + " could not be created."), null;
                    }
                  };
                  function be() {
                    var V = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : De(), ve = function(kt) {
                      return be(kt);
                    };
                    if (ve.version = "2.3.3", ve.removed = [], !V || !V.document || V.document.nodeType !== 9)
                      return ve.isSupported = !1, ve;
                    var Ne = V.document, it = V.document, yt = V.DocumentFragment, $t = V.HTMLTemplateElement, Gt = V.Node, Jt = V.Element, Xt = V.NodeFilter, Ae = V.NamedNodeMap, vt = Ae === void 0 ? V.NamedNodeMap || V.MozNamedAttrMap : Ae, Ot = V.Text, Vt = V.Comment, et = V.DOMParser, ft = V.trustedTypes, $ = Jt.prototype, Se = gt($, "cloneNode"), se = gt($, "nextSibling"), M = gt($, "childNodes"), ne = gt($, "parentNode");
                    if (typeof $t == "function") {
                      var ce = it.createElement("template");
                      ce.content && ce.content.ownerDocument && (it = ce.content.ownerDocument);
                    }
                    var X = nt(ft, Ne), Re = X && Pi ? X.createHTML("") : "", Ge = it, pt = Ge.implementation, xt = Ge.createNodeIterator, Pt = Ge.createDocumentFragment, Yt = Ge.getElementsByTagName, gr = Ne.importNode, dr = {};
                    try {
                      dr = Et(it).documentMode ? it.documentMode : {};
                    } catch {
                    }
                    var It = {};
                    ve.isSupported = typeof ne == "function" && pt && typeof pt.createHTMLDocument < "u" && dr !== 9;
                    var ct = wt, zt = Ft, xe = qe, ae = pe, _ = Xe, U = lt, fe = _e, Te = null, Be = ot({}, [].concat(te(At), te(Mt), te(St), te(Ue), te(We))), Je = null, Ct = ot({}, [].concat(te(ze), te(at), te(Ye), te(tt))), jt = null, tr = null, Kt = !0, rr = !0, kr = !1, on = !1, cr = !1, An = !1, ei = !1, bi = !1, wa = !1, Di = !0, Pi = !1, Bo = !0, an = !0, En = !1, Si = {}, ta = null, Fo = ot({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]), Li = null, Ii = ot({}, ["audio", "video", "img", "source", "image", "track"]), _i = null, gs = ot({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), ys = "http://www.w3.org/1998/Math/MathML", Ni = "http://www.w3.org/2000/svg", Fn = "http://www.w3.org/1999/xhtml", $a = Fn, ra = !1, Bi = void 0, mo = ["application/xhtml+xml", "text/html"], Nu = "text/html", Ua = void 0, wi = null, Bu = it.createElement("form"), Dr = function(kt) {
                      wi && wi === kt || ((!kt || (typeof kt > "u" ? "undefined" : Q(kt)) !== "object") && (kt = {}), kt = Et(kt), Te = "ALLOWED_TAGS" in kt ? ot({}, kt.ALLOWED_TAGS) : Be, Je = "ALLOWED_ATTR" in kt ? ot({}, kt.ALLOWED_ATTR) : Ct, _i = "ADD_URI_SAFE_ATTR" in kt ? ot(Et(gs), kt.ADD_URI_SAFE_ATTR) : gs, Li = "ADD_DATA_URI_TAGS" in kt ? ot(Et(Ii), kt.ADD_DATA_URI_TAGS) : Ii, ta = "FORBID_CONTENTS" in kt ? ot({}, kt.FORBID_CONTENTS) : Fo, jt = "FORBID_TAGS" in kt ? ot({}, kt.FORBID_TAGS) : {}, tr = "FORBID_ATTR" in kt ? ot({}, kt.FORBID_ATTR) : {}, Si = "USE_PROFILES" in kt ? kt.USE_PROFILES : !1, Kt = kt.ALLOW_ARIA_ATTR !== !1, rr = kt.ALLOW_DATA_ATTR !== !1, kr = kt.ALLOW_UNKNOWN_PROTOCOLS || !1, on = kt.SAFE_FOR_TEMPLATES || !1, cr = kt.WHOLE_DOCUMENT || !1, bi = kt.RETURN_DOM || !1, wa = kt.RETURN_DOM_FRAGMENT || !1, Di = kt.RETURN_DOM_IMPORT !== !1, Pi = kt.RETURN_TRUSTED_TYPE || !1, ei = kt.FORCE_BODY || !1, Bo = kt.SANITIZE_DOM !== !1, an = kt.KEEP_CONTENT !== !1, En = kt.IN_PLACE || !1, fe = kt.ALLOWED_URI_REGEXP || fe, $a = kt.NAMESPACE || Fn, Bi = // eslint-disable-next-line unicorn/prefer-includes
                      mo.indexOf(kt.PARSER_MEDIA_TYPE) === -1 ? Bi = Nu : Bi = kt.PARSER_MEDIA_TYPE, Ua = Bi === "application/xhtml+xml" ? function(er) {
                        return er;
                      } : he, on && (rr = !1), wa && (bi = !0), Si && (Te = ot({}, [].concat(te(We))), Je = [], Si.html === !0 && (ot(Te, At), ot(Je, ze)), Si.svg === !0 && (ot(Te, Mt), ot(Je, at), ot(Je, tt)), Si.svgFilters === !0 && (ot(Te, St), ot(Je, at), ot(Je, tt)), Si.mathMl === !0 && (ot(Te, Ue), ot(Je, Ye), ot(Je, tt))), kt.ADD_TAGS && (Te === Be && (Te = Et(Te)), ot(Te, kt.ADD_TAGS)), kt.ADD_ATTR && (Je === Ct && (Je = Et(Je)), ot(Je, kt.ADD_ATTR)), kt.ADD_URI_SAFE_ATTR && ot(_i, kt.ADD_URI_SAFE_ATTR), kt.FORBID_CONTENTS && (ta === Fo && (ta = Et(ta)), ot(ta, kt.FORBID_CONTENTS)), an && (Te["#text"] = !0), cr && ot(Te, ["html", "head", "body"]), Te.table && (ot(Te, ["tbody"]), delete jt.tbody), j && j(kt), wi = kt);
                    }, gn = ot({}, ["mi", "mo", "mn", "ms", "mtext"]), ti = ot({}, ["foreignobject", "desc", "title", "annotation-xml"]), ri = ot({}, Mt);
                    ot(ri, St), ot(ri, Ve);
                    var bs = ot({}, Ue);
                    ot(bs, He);
                    var xa = function(kt) {
                      var er = ne(kt);
                      (!er || !er.tagName) && (er = {
                        namespaceURI: Fn,
                        tagName: "template"
                      });
                      var hr = he(kt.tagName), Rr = he(er.tagName);
                      if (kt.namespaceURI === Ni)
                        return er.namespaceURI === Fn ? hr === "svg" : er.namespaceURI === ys ? hr === "svg" && (Rr === "annotation-xml" || gn[Rr]) : !!ri[hr];
                      if (kt.namespaceURI === ys)
                        return er.namespaceURI === Fn ? hr === "math" : er.namespaceURI === Ni ? hr === "math" && ti[Rr] : !!bs[hr];
                      if (kt.namespaceURI === Fn) {
                        if (er.namespaceURI === Ni && !ti[Rr] || er.namespaceURI === ys && !gn[Rr])
                          return !1;
                        var Wr = ot({}, ["title", "style", "font", "a", "script"]);
                        return !bs[hr] && (Wr[hr] || !ri[hr]);
                      }
                      return !1;
                    }, Pr = function(kt) {
                      Ce(ve.removed, { element: kt });
                      try {
                        kt.parentNode.removeChild(kt);
                      } catch {
                        try {
                          kt.outerHTML = Re;
                        } catch {
                          kt.remove();
                        }
                      }
                    }, El = function(kt, er) {
                      try {
                        Ce(ve.removed, {
                          attribute: er.getAttributeNode(kt),
                          from: er
                        });
                      } catch {
                        Ce(ve.removed, {
                          attribute: null,
                          from: er
                        });
                      }
                      if (er.removeAttribute(kt), kt === "is" && !Je[kt])
                        if (bi || wa)
                          try {
                            Pr(er);
                          } catch {
                          }
                        else
                          try {
                            er.setAttribute(kt, "");
                          } catch {
                          }
                    }, ka = function(kt) {
                      var er = void 0, hr = void 0;
                      if (ei)
                        kt = "<remove></remove>" + kt;
                      else {
                        var Rr = oe(kt, /^[\r\n\t ]+/);
                        hr = Rr && Rr[0];
                      }
                      Bi === "application/xhtml+xml" && (kt = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + kt + "</body></html>");
                      var Wr = X ? X.createHTML(kt) : kt;
                      if ($a === Fn)
                        try {
                          er = new et().parseFromString(Wr, Bi);
                        } catch {
                        }
                      if (!er || !er.documentElement) {
                        er = pt.createDocument($a, "template", null);
                        try {
                          er.documentElement.innerHTML = ra ? "" : Wr;
                        } catch {
                        }
                      }
                      var cn = er.body || er.documentElement;
                      return kt && hr && cn.insertBefore(it.createTextNode(hr), cn.childNodes[0] || null), $a === Fn ? Yt.call(er, cr ? "html" : "body")[0] : cr ? er.documentElement : cn;
                    }, hn = function(kt) {
                      return xt.call(kt.ownerDocument || kt, kt, Xt.SHOW_ELEMENT | Xt.SHOW_COMMENT | Xt.SHOW_TEXT, null, !1);
                    }, go = function(kt) {
                      return kt instanceof Ot || kt instanceof Vt ? !1 : typeof kt.nodeName != "string" || typeof kt.textContent != "string" || typeof kt.removeChild != "function" || !(kt.attributes instanceof vt) || typeof kt.removeAttribute != "function" || typeof kt.setAttribute != "function" || typeof kt.namespaceURI != "string" || typeof kt.insertBefore != "function";
                    }, zo = function(kt) {
                      return (typeof Gt > "u" ? "undefined" : Q(Gt)) === "object" ? kt instanceof Gt : kt && (typeof kt > "u" ? "undefined" : Q(kt)) === "object" && typeof kt.nodeType == "number" && typeof kt.nodeName == "string";
                    }, xi = function(kt, er, hr) {
                      It[kt] && ee(It[kt], function(Rr) {
                        Rr.call(ve, er, hr, wi);
                      });
                    }, $s = function(kt) {
                      var er = void 0;
                      if (xi("beforeSanitizeElements", kt, null), go(kt) || oe(kt.nodeName, /[\u0080-\uFFFF]/))
                        return Pr(kt), !0;
                      var hr = Ua(kt.nodeName);
                      if (xi("uponSanitizeElement", kt, {
                        tagName: hr,
                        allowedTags: Te
                      }), !zo(kt.firstElementChild) && (!zo(kt.content) || !zo(kt.content.firstElementChild)) && Qe(/<[/\w]/g, kt.innerHTML) && Qe(/<[/\w]/g, kt.textContent) || hr === "select" && Qe(/<template/i, kt.innerHTML))
                        return Pr(kt), !0;
                      if (!Te[hr] || jt[hr]) {
                        if (an && !ta[hr]) {
                          var Rr = ne(kt) || kt.parentNode, Wr = M(kt) || kt.childNodes;
                          if (Wr && Rr)
                            for (var cn = Wr.length, Hr = cn - 1; Hr >= 0; --Hr)
                              Rr.insertBefore(Se(Wr[Hr], !0), se(kt));
                        }
                        return Pr(kt), !0;
                      }
                      return kt instanceof Jt && !xa(kt) || (hr === "noscript" || hr === "noembed") && Qe(/<\/no(script|embed)/i, kt.innerHTML) ? (Pr(kt), !0) : (on && kt.nodeType === 3 && (er = kt.textContent, er = ge(er, ct, " "), er = ge(er, zt, " "), kt.textContent !== er && (Ce(ve.removed, { element: kt.cloneNode() }), kt.textContent = er)), xi("afterSanitizeElements", kt, null), !1);
                    }, Ss = function(kt, er, hr) {
                      if (Bo && (er === "id" || er === "name") && (hr in it || hr in Bu))
                        return !1;
                      if (!(rr && !tr[er] && Qe(xe, er))) {
                        if (!(Kt && Qe(ae, er))) {
                          if (!Je[er] || tr[er])
                            return !1;
                          if (!_i[er]) {
                            if (!Qe(fe, ge(hr, U, ""))) {
                              if (!((er === "src" || er === "xlink:href" || er === "href") && kt !== "script" && we(hr, "data:") === 0 && Li[kt])) {
                                if (!(kr && !Qe(_, ge(hr, U, "")))) {
                                  if (hr) return !1;
                                }
                              }
                            }
                          }
                        }
                      }
                      return !0;
                    }, ws = function(kt) {
                      var er = void 0, hr = void 0, Rr = void 0, Wr = void 0;
                      xi("beforeSanitizeAttributes", kt, null);
                      var cn = kt.attributes;
                      if (cn) {
                        var Hr = {
                          attrName: "",
                          attrValue: "",
                          keepAttr: !0,
                          allowedAttributes: Je
                        };
                        for (Wr = cn.length; Wr--; ) {
                          er = cn[Wr];
                          var Ur = er, Ho = Ur.name, Ml = Ur.namespaceURI;
                          if (hr = Oe(er.value), Rr = Ua(Ho), Hr.attrName = Rr, Hr.attrValue = hr, Hr.keepAttr = !0, Hr.forceKeepAttr = void 0, xi("uponSanitizeAttribute", kt, Hr), hr = Hr.attrValue, !Hr.forceKeepAttr && (El(Ho, kt), !!Hr.keepAttr)) {
                            if (Qe(/\/>/i, hr)) {
                              El(Ho, kt);
                              continue;
                            }
                            on && (hr = ge(hr, ct, " "), hr = ge(hr, zt, " "));
                            var Fu = Ua(kt.nodeName);
                            if (Ss(Fu, Rr, hr))
                              try {
                                Ml ? kt.setAttributeNS(Ml, Ho, hr) : kt.setAttribute(Ho, hr), de(ve.removed);
                              } catch {
                              }
                          }
                        }
                        xi("afterSanitizeAttributes", kt, null);
                      }
                    }, zn = function mr(kt) {
                      var er = void 0, hr = hn(kt);
                      for (xi("beforeSanitizeShadowDOM", kt, null); er = hr.nextNode(); )
                        xi("uponSanitizeShadowNode", er, null), !$s(er) && (er.content instanceof yt && mr(er.content), ws(er));
                      xi("afterSanitizeShadowDOM", kt, null);
                    };
                    return ve.sanitize = function(mr, kt) {
                      var er = void 0, hr = void 0, Rr = void 0, Wr = void 0, cn = void 0;
                      if (ra = !mr, ra && (mr = "<!-->"), typeof mr != "string" && !zo(mr)) {
                        if (typeof mr.toString != "function")
                          throw Me("toString is not a function");
                        if (mr = mr.toString(), typeof mr != "string")
                          throw Me("dirty is not a string, aborting");
                      }
                      if (!ve.isSupported) {
                        if (Q(V.toStaticHTML) === "object" || typeof V.toStaticHTML == "function") {
                          if (typeof mr == "string")
                            return V.toStaticHTML(mr);
                          if (zo(mr))
                            return V.toStaticHTML(mr.outerHTML);
                        }
                        return mr;
                      }
                      if (An || Dr(kt), ve.removed = [], typeof mr == "string" && (En = !1), !En) if (mr instanceof Gt)
                        er = ka("<!---->"), hr = er.ownerDocument.importNode(mr, !0), hr.nodeType === 1 && hr.nodeName === "BODY" || hr.nodeName === "HTML" ? er = hr : er.appendChild(hr);
                      else {
                        if (!bi && !on && !cr && // eslint-disable-next-line unicorn/prefer-includes
                        mr.indexOf("<") === -1)
                          return X && Pi ? X.createHTML(mr) : mr;
                        if (er = ka(mr), !er)
                          return bi ? null : Re;
                      }
                      er && ei && Pr(er.firstChild);
                      for (var Hr = hn(En ? mr : er); Rr = Hr.nextNode(); )
                        Rr.nodeType === 3 && Rr === Wr || $s(Rr) || (Rr.content instanceof yt && zn(Rr.content), ws(Rr), Wr = Rr);
                      if (Wr = null, En)
                        return mr;
                      if (bi) {
                        if (wa)
                          for (cn = Pt.call(er.ownerDocument); er.firstChild; )
                            cn.appendChild(er.firstChild);
                        else
                          cn = er;
                        return Di && (cn = gr.call(Ne, cn, !0)), cn;
                      }
                      var Ur = cr ? er.outerHTML : er.innerHTML;
                      return on && (Ur = ge(Ur, ct, " "), Ur = ge(Ur, zt, " ")), X && Pi ? X.createHTML(Ur) : Ur;
                    }, ve.setConfig = function(mr) {
                      Dr(mr), An = !0;
                    }, ve.clearConfig = function() {
                      wi = null, An = !1;
                    }, ve.isValidAttribute = function(mr, kt, er) {
                      wi || Dr({});
                      var hr = Ua(mr), Rr = Ua(kt);
                      return Ss(hr, Rr, er);
                    }, ve.addHook = function(mr, kt) {
                      typeof kt == "function" && (It[mr] = It[mr] || [], Ce(It[mr], kt));
                    }, ve.removeHook = function(mr) {
                      It[mr] && de(It[mr]);
                    }, ve.removeHooks = function(mr) {
                      It[mr] && (It[mr] = []);
                    }, ve.removeAllHooks = function() {
                      It = {};
                    }, ve;
                  }
                  var G = be();
                  return G;
                });
              }
            ),
            /***/
            928: (
              /***/
              function(S, x, w) {
                var k = w(322);
                function O(T, L, j) {
                  var z, J;
                  if (j = j || 0, !k(L))
                    return -1;
                  if (Array.prototype.indexOf)
                    return Array.prototype.indexOf.call(L, T, j);
                  for (J = L.length, z = j; j >= 0 && z < J; z += 1)
                    if (L[z] === T)
                      return z;
                  return -1;
                }
                S.exports = O;
              }
            ),
            /***/
            690: (
              /***/
              function(S, x, w) {
                var k = w(322), O = w(893), T = w(956);
                function L(j, z, J) {
                  k(j) ? O(j, z, J) : T(j, z, J);
                }
                S.exports = L;
              }
            ),
            /***/
            893: (
              /***/
              function(S) {
                function x(w, k, O) {
                  var T = 0, L = w.length;
                  for (O = O || null; T < L && k.call(O, w[T], T, w) !== !1; T += 1)
                    ;
                }
                S.exports = x;
              }
            ),
            /***/
            956: (
              /***/
              function(S) {
                function x(w, k, O) {
                  var T;
                  O = O || null;
                  for (T in w)
                    if (w.hasOwnProperty(T) && k.call(O, w[T], T, w) === !1)
                      break;
                }
                S.exports = x;
              }
            ),
            /***/
            990: (
              /***/
              function(S, x, w) {
                var k = w(893);
                function O(T) {
                  var L;
                  try {
                    L = Array.prototype.slice.call(T);
                  } catch {
                    L = [], k(T, function(z) {
                      L.push(z);
                    });
                  }
                  return L;
                }
                S.exports = O;
              }
            ),
            /***/
            755: (
              /***/
              function(S) {
                var x = "_feEventKey";
                function w(k, O) {
                  var T = k[x], L;
                  return T || (T = k[x] = {}), L = T[O], L || (L = T[O] = []), L;
                }
                S.exports = w;
              }
            ),
            /***/
            349: (
              /***/
              function(S, x, w) {
                var k = w(758), O = w(690), T = w(755);
                function L(J, ie, K) {
                  if (k(ie)) {
                    O(ie.split(/\s+/g), function(re) {
                      j(J, re, K);
                    });
                    return;
                  }
                  O(ie, function(re, ee) {
                    j(J, ee, re);
                  });
                }
                function j(J, ie, K) {
                  var re = T(J, ie), ee;
                  K ? (O(re, function(de, Ce) {
                    return K === de.handler ? (z(J, ie, de.wrappedHandler), ee = Ce, !1) : !0;
                  }), re.splice(ee, 1)) : (O(re, function(de) {
                    z(J, ie, de.wrappedHandler);
                  }), re.splice(0, re.length));
                }
                function z(J, ie, K) {
                  "removeEventListener" in J ? J.removeEventListener(ie, K) : "detachEvent" in J && J.detachEvent("on" + ie, K);
                }
                S.exports = L;
              }
            ),
            /***/
            348: (
              /***/
              function(S, x, w) {
                var k = w(758), O = w(690), T = w(755);
                function L(J, ie, K, re) {
                  if (k(ie)) {
                    O(ie.split(/\s+/g), function(ee) {
                      j(J, ee, K, re);
                    });
                    return;
                  }
                  O(ie, function(ee, de) {
                    j(J, de, ee, K);
                  });
                }
                function j(J, ie, K, re) {
                  function ee(de) {
                    K.call(re || J, de || window.event);
                  }
                  "addEventListener" in J ? J.addEventListener(ie, ee) : "attachEvent" in J && J.attachEvent("on" + ie, ee), z(J, ie, K, ee);
                }
                function z(J, ie, K, re) {
                  var ee = T(J, ie), de = !1;
                  O(ee, function(Ce) {
                    return Ce.handler === K ? (de = !0, !1) : !0;
                  }), de || ee.push({
                    handler: K,
                    wrappedHandler: re
                  });
                }
                S.exports = L;
              }
            ),
            /***/
            24: (
              /***/
              function(S, x, w) {
                var k = w(322), O = w(929);
                function T(L, j) {
                  if (j = k(j) ? j.join(" ") : j, j = j.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), O(L.className.baseVal)) {
                    L.className = j;
                    return;
                  }
                  L.className.baseVal = j;
                }
                S.exports = T;
              }
            ),
            /***/
            204: (
              /***/
              function(S, x, w) {
                var k = w(690), O = w(928), T = w(902), L = w(24);
                function j(z) {
                  var J = Array.prototype.slice.call(arguments, 1), ie = z.classList, K = [], re;
                  if (ie) {
                    k(J, function(ee) {
                      z.classList.add(ee);
                    });
                    return;
                  }
                  re = T(z), re && (J = [].concat(re.split(/\s+/), J)), k(J, function(ee) {
                    O(ee, K) < 0 && K.push(ee);
                  }), L(z, K);
                }
                S.exports = j;
              }
            ),
            /***/
            522: (
              /***/
              function(S, x, w) {
                var k = w(758), O = w(690);
                function T(L, j, z) {
                  var J = L.style;
                  if (k(j)) {
                    J[j] = z;
                    return;
                  }
                  O(j, function(ie, K) {
                    J[K] = ie;
                  });
                }
                S.exports = T;
              }
            ),
            /***/
            902: (
              /***/
              function(S, x, w) {
                var k = w(929);
                function O(T) {
                  return !T || !T.className ? "" : k(T.className.baseVal) ? T.className : T.className.baseVal;
                }
                S.exports = O;
              }
            ),
            /***/
            714: (
              /***/
              function(S, x, w) {
                var k = w(928), O = w(902);
                function T(L, j) {
                  var z;
                  return L.classList ? L.classList.contains(j) : (z = O(L).split(/\s+/), k(j, z) > -1);
                }
                S.exports = T;
              }
            ),
            /***/
            471: (
              /***/
              function(S, x, w) {
                var k = w(928), O = w(990), T = Element.prototype, L = T.matches || T.webkitMatchesSelector || T.mozMatchesSelector || T.msMatchesSelector || function(z) {
                  var J = this.document || this.ownerDocument;
                  return k(this, O(J.querySelectorAll(z))) > -1;
                };
                function j(z, J) {
                  return L.call(z, J);
                }
                S.exports = j;
              }
            ),
            /***/
            462: (
              /***/
              function(S, x, w) {
                var k = w(893), O = w(928), T = w(902), L = w(24);
                function j(z) {
                  var J = Array.prototype.slice.call(arguments, 1), ie = z.classList, K, re;
                  if (ie) {
                    k(J, function(ee) {
                      ie.remove(ee);
                    });
                    return;
                  }
                  K = T(z).split(/\s+/), re = [], k(K, function(ee) {
                    O(ee, J) < 0 && re.push(ee);
                  }), L(z, re);
                }
                S.exports = j;
              }
            ),
            /***/
            969: (
              /***/
              function(S) {
                function x(w, k) {
                  var O = Object.prototype.hasOwnProperty, T, L, j, z;
                  for (j = 1, z = arguments.length; j < z; j += 1) {
                    T = arguments[j];
                    for (L in T)
                      O.call(T, L) && (w[L] = T[L]);
                  }
                  return w;
                }
                S.exports = x;
              }
            ),
            /***/
            254: (
              /***/
              function(S, x, w) {
                var k = w(956);
                function O(T, L) {
                  var j = document.createElement("img"), z = "";
                  return k(L, function(J, ie) {
                    z += "&" + ie + "=" + J;
                  }), z = z.substring(1), j.src = T + "?" + z, j.style.display = "none", document.body.appendChild(j), document.body.removeChild(j), j;
                }
                S.exports = O;
              }
            ),
            /***/
            391: (
              /***/
              function(S, x, w) {
                var k = w(929), O = w(254), T = 7 * 24 * 60 * 60 * 1e3;
                function L(z) {
                  var J = (/* @__PURE__ */ new Date()).getTime();
                  return J - z > T;
                }
                function j(z, J) {
                  var ie = "https://www.google-analytics.com/collect", K = location.hostname, re = "event", ee = "use", de = "TOAST UI " + z + " for " + K + ": Statistics", Ce = window.localStorage.getItem(de);
                  !k(window.tui) && window.tui.usageStatistics === !1 || Ce && !L(Ce) || (window.localStorage.setItem(de, (/* @__PURE__ */ new Date()).getTime()), setTimeout(function() {
                    (document.readyState === "interactive" || document.readyState === "complete") && O(ie, {
                      v: 1,
                      t: re,
                      tid: J,
                      cid: K,
                      dp: K,
                      dh: z,
                      el: z,
                      ec: ee
                    });
                  }, 1e3));
                }
                S.exports = j;
              }
            ),
            /***/
            322: (
              /***/
              function(S) {
                function x(w) {
                  return w instanceof Array;
                }
                S.exports = x;
              }
            ),
            /***/
            65: (
              /***/
              function(S, x, w) {
                var k = w(929), O = w(934);
                function T(L) {
                  return !k(L) && !O(L);
                }
                S.exports = T;
              }
            ),
            /***/
            404: (
              /***/
              function(S, x, w) {
                var k = w(790);
                function O(T) {
                  return !k(T);
                }
                S.exports = O;
              }
            ),
            /***/
            294: (
              /***/
              function(S) {
                function x(w) {
                  return w instanceof Function;
                }
                S.exports = x;
              }
            ),
            /***/
            934: (
              /***/
              function(S) {
                function x(w) {
                  return w === null;
                }
                S.exports = x;
              }
            ),
            /***/
            758: (
              /***/
              function(S) {
                function x(w) {
                  return typeof w == "string" || w instanceof String;
                }
                S.exports = x;
              }
            ),
            /***/
            790: (
              /***/
              function(S, x, w) {
                var k = w(65);
                function O(T) {
                  return k(T) && T !== !1;
                }
                S.exports = O;
              }
            ),
            /***/
            929: (
              /***/
              function(S) {
                function x(w) {
                  return w === void 0;
                }
                S.exports = x;
              }
            ),
            /***/
            479: (
              /***/
              function(S) {
                S.exports = r;
              }
            ),
            /***/
            481: (
              /***/
              function(S) {
                S.exports = s;
              }
            ),
            /***/
            43: (
              /***/
              function(S) {
                S.exports = l;
              }
            ),
            /***/
            814: (
              /***/
              function(S) {
                S.exports = c;
              }
            ),
            /***/
            311: (
              /***/
              function(S) {
                S.exports = f;
              }
            )
            /******/
          }, d = {};
          function m(S) {
            var x = d[S];
            if (x !== void 0)
              return x.exports;
            var w = d[S] = {
              /******/
              // no module.id needed
              /******/
              // no module.loaded needed
              /******/
              exports: {}
              /******/
            };
            return p[S].call(w.exports, w, w.exports, m), w.exports;
          }
          (function() {
            m.n = function(S) {
              var x = S && S.__esModule ? (
                /******/
                function() {
                  return S.default;
                }
              ) : (
                /******/
                function() {
                  return S;
                }
              );
              return m.d(x, { a: x }), x;
            };
          })(), function() {
            m.d = function(S, x) {
              for (var w in x)
                m.o(x, w) && !m.o(S, w) && Object.defineProperty(S, w, { enumerable: !0, get: x[w] });
            };
          }(), function() {
            m.g = function() {
              if (typeof globalThis == "object") return globalThis;
              try {
                return this || new Function("return this")();
              } catch {
                if (typeof window == "object") return window;
              }
            }();
          }(), function() {
            m.o = function(S, x) {
              return Object.prototype.hasOwnProperty.call(S, x);
            };
          }();
          var y = {};
          return function() {
            m.d(y, {
              default: function() {
                return (
                  /* binding */
                  uQ
                );
              }
            });
            var S = function() {
              return S = Object.assign || function(D) {
                for (var F, q = 1, ye = arguments.length; q < ye; q++) {
                  F = arguments[q];
                  for (var Fe in F) Object.prototype.hasOwnProperty.call(F, Fe) && (D[Fe] = F[Fe]);
                }
                return D;
              }, S.apply(this, arguments);
            };
            function x(P, D, F) {
              if (arguments.length === 2) for (var q = 0, ye = D.length, Fe; q < ye; q++)
                (Fe || !(q in D)) && (Fe || (Fe = Array.prototype.slice.call(D, 0, q)), Fe[q] = D[q]);
              return P.concat(Fe || Array.prototype.slice.call(D));
            }
            /*! *****************************************************************************
            		Copyright (c) Microsoft Corporation.
            
            		Permission to use, copy, modify, and/or distribute this software for any
            		purpose with or without fee is hereby granted.
            
            		THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
            		REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
            		AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
            		INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
            		LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
            		OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
            		PERFORMANCE OF THIS SOFTWARE.
            		***************************************************************************** */
            var w = function(P, D) {
              return w = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(F, q) {
                F.__proto__ = q;
              } || function(F, q) {
                for (var ye in q)
                  Object.prototype.hasOwnProperty.call(q, ye) && (F[ye] = q[ye]);
              }, w(P, D);
            };
            function k(P, D) {
              if (typeof D != "function" && D !== null)
                throw new TypeError("Class extends value " + String(D) + " is not a constructor or null");
              w(P, D);
              function F() {
                this.constructor = P;
              }
              P.prototype = D === null ? Object.create(D) : (F.prototype = D.prototype, new F());
            }
            var O = function() {
              return O = Object.assign || function(D) {
                for (var F, q = 1, ye = arguments.length; q < ye; q++) {
                  F = arguments[q];
                  for (var Fe in F)
                    Object.prototype.hasOwnProperty.call(F, Fe) && (D[Fe] = F[Fe]);
                }
                return D;
              }, O.apply(this, arguments);
            };
            function T(P, D, F) {
              if (arguments.length === 2)
                for (var q = 0, ye = D.length, Fe; q < ye; q++)
                  (Fe || !(q in D)) && (Fe || (Fe = Array.prototype.slice.call(D, 0, q)), Fe[q] = D[q]);
              return P.concat(Fe || Array.prototype.slice.call(D));
            }
            var L = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof m.g < "u" ? m.g : typeof self < "u" ? self : {}, j = {};
            function z(P) {
              var D, F, q = j[P];
              if (q)
                return q;
              for (q = j[P] = [], D = 0; D < 128; D++)
                F = String.fromCharCode(D), /^[0-9a-z]$/i.test(F) ? q.push(F) : q.push("%" + ("0" + D.toString(16).toUpperCase()).slice(-2));
              for (D = 0; D < P.length; D++)
                q[P.charCodeAt(D)] = P[D];
              return q;
            }
            function J(P, D, F) {
              var q, ye, Fe, Ze, dt, Bt = "";
              for (typeof D != "string" && (F = D, D = J.defaultChars), typeof F > "u" && (F = !0), dt = z(D), q = 0, ye = P.length; q < ye; q++) {
                if (Fe = P.charCodeAt(q), F && Fe === 37 && q + 2 < ye && /^[0-9a-f]{2}$/i.test(P.slice(q + 1, q + 3))) {
                  Bt += P.slice(q, q + 3), q += 2;
                  continue;
                }
                if (Fe < 128) {
                  Bt += dt[Fe];
                  continue;
                }
                if (Fe >= 55296 && Fe <= 57343) {
                  if (Fe >= 55296 && Fe <= 56319 && q + 1 < ye && (Ze = P.charCodeAt(q + 1), Ze >= 56320 && Ze <= 57343)) {
                    Bt += encodeURIComponent(P[q] + P[q + 1]), q++;
                    continue;
                  }
                  Bt += "%EF%BF%BD";
                  continue;
                }
                Bt += encodeURIComponent(P[q]);
              }
              return Bt;
            }
            J.defaultChars = ";/?:@&=+$,-_.!~*'()#", J.componentChars = "-_.!~*'()";
            var ie = J, K = {}, re = {}, ee = "Á", de = "á", Ce = "Ă", he = "ă", oe = "∾", ge = "∿", we = "∾̳", Oe = "Â", Qe = "â", Me = "´", Ie = "А", rt = "а", ot = "Æ", Et = "æ", gt = "⁡", At = "𝔄", Mt = "𝔞", St = "À", Ve = "à", Ue = "ℵ", He = "ℵ", We = "Α", ze = "α", at = "Ā", Ye = "ā", tt = "⨿", wt = "&", Ft = "&", qe = "⩕", pe = "⩓", _e = "∧", Xe = "⩜", lt = "⩘", Q = "⩚", te = "∠", De = "⦤", nt = "∠", be = "⦨", G = "⦩", V = "⦪", ve = "⦫", Ne = "⦬", it = "⦭", yt = "⦮", $t = "⦯", Gt = "∡", Jt = "∟", Xt = "⊾", Ae = "⦝", vt = "∢", Ot = "Å", Vt = "⍼", et = "Ą", ft = "ą", $ = "𝔸", Se = "𝕒", se = "⩯", M = "≈", ne = "⩰", ce = "≊", X = "≋", Re = "'", Ge = "⁡", pt = "≈", xt = "≊", Pt = "Å", Yt = "å", gr = "𝒜", dr = "𝒶", It = "≔", ct = "*", zt = "≈", xe = "≍", ae = "Ã", _ = "ã", U = "Ä", fe = "ä", Te = "∳", Be = "⨑", Je = "≌", Ct = "϶", jt = "‵", tr = "∽", Kt = "⋍", rr = "∖", kr = "⫧", on = "⊽", cr = "⌅", An = "⌆", ei = "⌅", bi = "⎵", wa = "⎶", Di = "≌", Pi = "Б", Bo = "б", an = "„", En = "∵", Si = "∵", ta = "∵", Fo = "⦰", Li = "϶", Ii = "ℬ", _i = "ℬ", gs = "Β", ys = "β", Ni = "ℶ", Fn = "≬", $a = "𝔅", ra = "𝔟", Bi = "⋂", mo = "◯", Nu = "⋃", Ua = "⨀", wi = "⨁", Bu = "⨂", Dr = "⨆", gn = "★", ti = "▽", ri = "△", bs = "⨄", xa = "⋁", Pr = "⋀", El = "⤍", ka = "⧫", hn = "▪", go = "▴", zo = "▾", xi = "◂", $s = "▸", Ss = "␣", ws = "▒", zn = "░", mr = "▓", kt = "█", er = "=⃥", hr = "≡⃥", Rr = "⫭", Wr = "⌐", cn = "𝔹", Hr = "𝕓", Ur = "⊥", Ho = "⊥", Ml = "⋈", Fu = "⧉", Va = "┐", Tp = "╕", zu = "╖", Us = "╗", Ap = "┌", Rl = "╒", ni = "╓", Vs = "╔", Dl = "─", jo = "═", Ep = "┬", Pl = "╤", Hu = "╥", ju = "╦", qc = "┴", Wu = "╧", $u = "╨", yo = "╩", Fi = "⊟", Cr = "⊞", Mp = "⊠", Gs = "┘", bo = "╛", Uu = "╜", Oa = "╝", Vu = "└", xs = "╘", Rp = "╙", Dp = "╚", Ys = "│", Pp = "║", Ll = "┼", Kc = "╪", Wo = "╫", So = "╬", qs = "┤", Lp = "╡", $o = "╢", ks = "╣", Ga = "├", zi = "╞", Mn = "╟", Xc = "╠", Ip = "‵", Jc = "˘", Hi = "˘", Lr = "¦", Ks = "𝒷", Il = "ℬ", Uo = "⁏", Gu = "∽", Zc = "⋍", Yu = "⧅", qu = "\\", Qc = "⟈", _p = "•", Np = "•", ef = "≎", tf = "⪮", Bp = "≏", Ku = "≎", Fp = "≏", zp = "Ć", Os = "ć", Hp = "⩄", Xs = "⩉", ji = "⩋", _r = "∩", Xu = "⋒", Vr = "⩇", rf = "⩀", nf = "ⅅ", jp = "∩︀", af = "⁁", Ju = "ˇ", of = "ℭ", sf = "⩍", Wp = "Č", lf = "č", $p = "Ç", Zu = "ç", A = "Ĉ", B = "ĉ", E = "∰", N = "⩌", H = "⩐", Y = "Ċ", le = "ċ", me = "¸", Pe = "¸", $e = "⦲", st = "¢", Tt = "·", ht = "·", _t = "𝔠", Ht = "ℭ", nr = "Ч", Tr = "ч", Zt = "✓", Gr = "✓", Or = "Χ", en = "χ", Nr = "ˆ", zr = "≗", fn = "↺", ki = "↻", na = "⊛", Rn = "⊚", ia = "⊝", ii = "⊙", aa = "®", Ca = "Ⓢ", Ya = "⊖", oa = "⊕", yn = "⊗", uf = "○", Up = "⧃", Cs = "≗", Vo = "⨐", cf = "⫯", sa = "⧂", oy = "∲", rk = "”", sy = "’", nk = "♣", ff = "♣", df = ":", Vp = "∷", ly = "⩴", qa = "≔", Qu = "≔", uy = ",", Go = "@", ik = "∁", cy = "∘", ak = "∁", ok = "ℂ", fy = "≅", dy = "⩭", Gp = "≡", Yp = "∮", hy = "∯", py = "∮", vy = "𝕔", Yo = "ℂ", qp = "∐", hf = "∐", sk = "©", my = "©", lk = "℗", Kp = "∳", qo = "↵", Ka = "✗", uk = "⨯", Xp = "𝒞", ck = "𝒸", _l = "⫏", fk = "⫑", dk = "⫐", gy = "⫒", Ko = "⋯", hk = "⤸", Jp = "⤵", pk = "⋞", vk = "⋟", mk = "↶", gk = "⤽", Zp = "⩈", yy = "⩆", yk = "≍", bk = "∪", by = "⋓", Sy = "⩊", Sk = "⊍", Qp = "⩅", wk = "∪︀", xk = "↷", kk = "⤼", Ok = "⋞", Ck = "⋟", Tk = "⋎", Xa = "⋏", wy = "¤", Ak = "↶", pn = "↷", Ek = "⋎", Mk = "⋏", Rk = "∲", Dk = "∱", ev = "⌭", xy = "†", Pk = "‡", Lk = "ℸ", Ik = "↓", _k = "↡", Nk = "⇓", Bk = "‐", Fk = "⫤", ky = "⊣", zk = "⤏", Hk = "˝", Oy = "Ď", jk = "ď", Wk = "Д", $k = "д", Uk = "‡", Vk = "⇊", Gk = "ⅅ", Yk = "ⅆ", qk = "⤑", Kk = "⩷", Xk = "°", Cy = "∇", Jk = "Δ", pf = "δ", Zk = "⦱", Qk = "⥿", eO = "𝔇", tO = "𝔡", tv = "⥥", rO = "⇃", nO = "⇂", Wi = "´", iO = "˙", vf = "˝", la = "`", aO = "˜", Ty = "⋄", sn = "⋄", Hn = "⋄", Ay = "♦", mf = "♦", oO = "¨", sO = "ⅆ", Ey = "ϝ", rv = "⋲", lO = "÷", uO = "÷", cO = "⋇", fO = "⋇", My = "Ђ", gf = "ђ", dO = "⌞", wo = "⌍", Ta = "$", Aa = "𝔻", hO = "𝕕", pO = "¨", nv = "˙", vO = "⃜", mO = "≐", gO = "≑", yO = "≐", bO = "∸", Ry = "∔", Js = "⊡", SO = "⌆", Br = "∯", yf = "¨", wO = "⇓", xo = "⇐", iv = "⇔", xO = "⫤", Dy = "⟸", kO = "⟺", OO = "⟹", av = "⇒", CO = "⊨", TO = "⇑", Py = "⇕", AO = "∥", EO = "⤓", MO = "↓", RO = "↓", DO = "⇓", PO = "⇵", LO = "̑", IO = "⇊", Ly = "⇃", _O = "⇂", NO = "⥐", BO = "⥞", ov = "⥖", Iy = "↽", _y = "⥟", bf = "⥗", sv = "⇁", FO = "↧", Ny = "⊤", zO = "⤐", HO = "⌟", jO = "⌌", WO = "𝒟", $O = "𝒹", UO = "Ѕ", ko = "ѕ", By = "⧶", VO = "Đ", Ts = "đ", Fy = "⋱", zy = "▿", GO = "▾", ec = "⇵", YO = "⥯", qO = "⦦", Hy = "Џ", KO = "џ", XO = "⟿", JO = "É", jy = "é", tc = "⩮", ZO = "Ě", rc = "ě", QO = "Ê", Wy = "ê", lv = "≖", eC = "≕", tC = "Э", uv = "э", rC = "⩷", $y = "Ė", nC = "ė", iC = "≑", aC = "ⅇ", oC = "≒", Uy = "𝔈", sC = "𝔢", lC = "⪚", uC = "È", cC = "è", fC = "⪖", dC = "⪘", cv = "⪙", Vy = "∈", Sf = "⏧", hC = "ℓ", pC = "⪕", vC = "⪗", mC = "Ē", gC = "ē", Gy = "∅", Zs = "∅", $i = "◻", Ui = "∅", Nl = "▫", yC = " ", nc = " ", fv = " ", bC = "Ŋ", Bl = "ŋ", wf = " ", SC = "Ę", wC = "ę", xC = "𝔼", kC = "𝕖", OC = "⋕", CC = "⧣", TC = "⩱", Yy = "ε", ir = "Ε", dv = "ε", AC = "ϵ", ic = "≖", qy = "≕", EC = "≂", MC = "⪖", Xo = "⪕", hi = "⩵", Qs = "=", RC = "≂", Fl = "≟", ac = "⇌", oc = "≡", Jo = "⩸", Ky = "⧥", DC = "⥱", Xy = "≓", Jy = "ℯ", Oo = "ℰ", Zy = "≐", Qy = "⩳", eb = "≂", tb = "Η", hv = "η", rb = "Ð", PC = "ð", xf = "Ë", kf = "ë", pv = "€", nb = "!", ib = "∃", ab = "∃", Ea = "ℰ", LC = "ⅇ", ob = "ⅇ", sb = "≒", IC = "Ф", _C = "ф", NC = "♀", BC = "ﬃ", lb = "ﬀ", FC = "ﬄ", zC = "𝔉", HC = "𝔣", jC = "ﬁ", ub = "◼", sc = "▪", WC = "fj", el = "♭", $C = "ﬂ", cb = "▱", UC = "ƒ", VC = "𝔽", vv = "𝕗", GC = "∀", mv = "∀", YC = "⋔", fb = "⫙", qC = "ℱ", gv = "⨍", KC = "½", XC = "⅓", JC = "¼", ZC = "⅕", QC = "⅙", e1 = "⅛", t1 = "⅔", r1 = "⅖", db = "¾", n1 = "⅗", hb = "⅜", pb = "⅘", i1 = "⅚", a1 = "⅝", vb = "⅞", mb = "⁄", o1 = "⌢", s1 = "𝒻", l1 = "ℱ", u1 = "ǵ", c1 = "Γ", gb = "γ", f1 = "Ϝ", d1 = "ϝ", yb = "⪆", h1 = "Ğ", p1 = "ğ", v1 = "Ģ", m1 = "Ĝ", yv = "ĝ", bb = "Г", jn = "г", lc = "Ġ", g1 = "ġ", y1 = "≥", b1 = "≧", S1 = "⪌", w1 = "⋛", x1 = "≥", Sb = "≧", k1 = "⩾", O1 = "⪩", C1 = "⩾", T1 = "⪀", A1 = "⪂", E1 = "⪄", M1 = "⋛︀", R1 = "⪔", D1 = "𝔊", P1 = "𝔤", bv = "≫", L1 = "⋙", I1 = "⋙", _1 = "ℷ", N1 = "Ѓ", zl = "ѓ", B1 = "⪥", F1 = "≷", z1 = "⪒", H1 = "⪤", Of = "⪊", j1 = "⪊", W1 = "⪈", $1 = "≩", U1 = "⪈", wb = "≩", V1 = "⋧", G1 = "𝔾", Y1 = "𝕘", Cf = "`", q1 = "≥", K1 = "⋛", X1 = "≧", J1 = "⪢", Z1 = "≷", Q1 = "⩾", eT = "≳", tT = "𝒢", rT = "ℊ", Sv = "≳", xb = "⪎", uc = "⪐", nT = "⪧", iT = "⩺", aT = ">", dn = ">", kb = "≫", oT = "⋗", Wn = "⦕", sT = "⩼", lT = "⪆", uT = "⥸", cT = "⋗", Ja = "⋛", fT = "⪌", Ob = "≷", dT = "≳", hT = "≩︀", wv = "≩︀", xv = "ˇ", cc = " ", pT = "½", vT = "ℋ", mT = "Ъ", gT = "ъ", yT = "⥈", bT = "↔", Vi = "⇔", Cb = "↭", ST = "^", wT = "ℏ", Tb = "Ĥ", xT = "ĥ", kT = "♥", OT = "♥", CT = "…", kv = "⊹", Ov = "𝔥", TT = "ℌ", AT = "ℋ", ET = "⤥", fc = "⤦", MT = "⇿", RT = "∻", DT = "↩", Ab = "↪", Eb = "𝕙", PT = "ℍ", LT = "―", Mb = "─", dc = "𝒽", IT = "ℋ", _T = "ℏ", Rb = "Ħ", Tf = "ħ", NT = "≎", Db = "≏", BT = "⁃", Cv = "‐", FT = "Í", zT = "í", HT = "⁣", Pb = "Î", Lb = "î", jT = "И", Zo = "и", WT = "İ", $T = "Е", UT = "е", VT = "¡", Tv = "⇔", Af = "𝔦", hc = "ℑ", GT = "Ì", Av = "ì", Ib = "ⅈ", YT = "⨌", _b = "∭", qT = "⧜", KT = "℩", XT = "Ĳ", Nb = "ĳ", JT = "Ī", ZT = "ī", QT = "ℑ", eA = "ⅈ", tA = "ℐ", Hl = "ℑ", Ev = "ı", rA = "ℑ", nA = "⊷", iA = "Ƶ", aA = "⇒", Gi = "℅", Mv = "∞", Bb = "⧝", oA = "ı", sA = "⊺", lA = "∫", Fb = "∬", uA = "ℤ", zb = "∫", Rv = "⊺", cA = "⋂", fA = "⨗", dA = "⨼", hA = "⁣", Hb = "⁢", pA = "Ё", vA = "ё", mA = "Į", Za = "į", gA = "𝕀", yA = "𝕚", bA = "Ι", SA = "ι", wA = "⨼", xA = "¿", jb = "𝒾", kA = "ℐ", Wb = "∈", OA = "⋵", CA = "⋹", Dv = "⋴", pc = "⋳", $b = "∈", TA = "⁢", AA = "Ĩ", EA = "ĩ", MA = "І", RA = "і", DA = "Ï", PA = "ï", LA = "Ĵ", IA = "ĵ", _A = "Й", NA = "й", Pv = "𝔍", BA = "𝔧", Ub = "ȷ", FA = "𝕁", zA = "𝕛", HA = "𝒥", jA = "𝒿", WA = "Ј", $A = "ј", UA = "Є", VA = "є", GA = "Κ", YA = "κ", qA = "ϰ", KA = "Ķ", Ef = "ķ", Vb = "К", Mf = "к", XA = "𝔎", JA = "𝔨", ZA = "ĸ", QA = "Х", eE = "х", Lv = "Ќ", tE = "ќ", rE = "𝕂", nE = "𝕜", iE = "𝒦", Iv = "𝓀", aE = "⇚", oE = "Ĺ", Co = "ĺ", sE = "⦴", Rf = "ℒ", To = "Λ", lE = "λ", $n = "⟨", Df = "⟪", Gb = "⦑", Yb = "⟨", Qo = "⪅", uE = "ℒ", cE = "«", fE = "⇤", dE = "⤟", hE = "←", qb = "↞", _v = "⇐", pE = "⤝", vE = "↩", mE = "↫", gE = "⤹", yE = "⥳", bE = "↢", Nv = "⤙", SE = "⤛", wE = "⪫", Pf = "⪭", xE = "⪭︀", Lf = "⤌", If = "⤎", kE = "❲", Kb = "{", _f = "[", Qa = "⦋", Xb = "⦏", Jb = "⦍", OE = "Ľ", CE = "ľ", TE = "Ļ", AE = "ļ", EE = "⌈", ME = "{", Bv = "Л", Zb = "л", jl = "⤶", Nf = "“", Qb = "„", e0 = "⥧", t0 = "⥋", Fv = "↲", RE = "≤", zv = "≦", DE = "⟨", r0 = "⇤", PE = "←", LE = "←", n0 = "⇐", Ir = "⇆", IE = "↢", Bf = "⌈", _E = "⟦", NE = "⥡", BE = "⥙", FE = "⇃", zE = "⌊", HE = "↽", jE = "↼", WE = "⇇", $E = "↔", UE = "↔", VE = "⇔", GE = "⇆", YE = "⇋", qE = "↭", KE = "⥎", XE = "↤", JE = "⊣", ZE = "⥚", Ma = "⋋", QE = "⧏", i0 = "⊲", eM = "⊴", tM = "⥑", a0 = "⥠", Ff = "⥘", o0 = "↿", ai = "⥒", rM = "↼", nM = "⪋", iM = "⋚", aM = "≤", Hv = "≦", oM = "⩽", sM = "⪨", ua = "⩽", lM = "⩿", zf = "⪁", ca = "⪃", Hf = "⋚︀", jf = "⪓", s0 = "⪅", uM = "⋖", cM = "⋚", fM = "⪋", dM = "⋚", jv = "≦", l0 = "≶", tl = "≶", hM = "⪡", pM = "≲", vM = "⩽", mM = "≲", Wv = "⥼", gM = "⌊", yM = "𝔏", es = "𝔩", bM = "≶", Wf = "⪑", ts = "⥢", Oi = "↽", $f = "↼", u0 = "⥪", Wl = "▄", $l = "Љ", SM = "љ", wM = "⇇", xM = "≪", kM = "⋘", $v = "⌞", OM = "⇚", CM = "⥫", TM = "◺", AM = "Ŀ", Uv = "ŀ", EM = "⎰", MM = "⎰", Ul = "⪉", RM = "⪉", Uf = "⪇", As = "≨", DM = "⪇", Yi = "≨", Vf = "⋦", PM = "⟬", LM = "⇽", IM = "⟦", c0 = "⟵", _M = "⟵", NM = "⟸", BM = "⟷", FM = "⟷", zM = "⟺", HM = "⟼", Vv = "⟶", jM = "⟶", WM = "⟹", vc = "↫", $M = "↬", Gf = "⦅", Yf = "𝕃", Yr = "𝕝", qf = "⨭", UM = "⨴", VM = "∗", GM = "_", YM = "↙", Gv = "↘", qM = "◊", KM = "◊", Yv = "⧫", XM = "(", Kf = "⦓", f0 = "⇆", Un = "⌟", Xf = "⇋", JM = "⥭", ZM = "‎", QM = "⊿", eR = "‹", tR = "𝓁", rR = "ℒ", nR = "↰", iR = "↰", d0 = "≲", aR = "⪍", oR = "⪏", qv = "[", sR = "‘", lR = "‚", uR = "Ł", cR = "ł", Kv = "⪦", fR = "⩹", dR = "<", Vl = "<", hR = "≪", Jf = "⋖", mc = "⋋", h0 = "⋉", Vn = "⥶", Zf = "⩻", pR = "◃", vR = "⊴", mR = "◂", gR = "⦖", yR = "⥊", bR = "⥦", p0 = "≨︀", Xv = "≨︀", SR = "¯", wR = "♂", v0 = "✠", Qf = "✠", xR = "↦", kR = "↦", OR = "↧", CR = "↤", Jv = "↥", TR = "▮", AR = "⨩", rl = "М", ER = "м", ed = "—", nl = "∺", MR = "∡", Gl = " ", td = "ℳ", RR = "𝔐", DR = "𝔪", PR = "℧", LR = "µ", Zv = "*", IR = "⫰", _R = "∣", Qv = "·", NR = "⊟", rd = "−", m0 = "∸", em = "⨪", nd = "∓", g0 = "⫛", y0 = "…", BR = "∓", FR = "⊧", zR = "𝕄", HR = "𝕞", tm = "∓", jR = "𝓂", WR = "ℳ", il = "∾", $R = "Μ", id = "μ", al = "⊸", Gn = "⊸", ad = "∇", b0 = "Ń", S0 = "ń", UR = "∠⃒", VR = "≉", GR = "⩰̸", YR = "≋̸", rm = "ŉ", qR = "≉", KR = "♮", nm = "ℕ", XR = "♮", od = " ", im = "≎̸", Yn = "≏̸", sd = "⩃", w0 = "Ň", x0 = "ň", JR = "Ņ", ZR = "ņ", QR = "≇", eD = "⩭̸", am = "⩂", tD = "Н", rD = "н", k0 = "–", nD = "⤤", ld = "↗", O0 = "⇗", iD = "↗", qn = "≠", C0 = "≐̸", om = "​", T0 = "​", ud = "​", aD = "​", oD = "≢", sD = "⤨", lD = "≂̸", A0 = "≫", cd = "≪", uD = `
`, cD = "∄", fD = "∄", dD = "𝔑", fd = "𝔫", E0 = "≧̸", hD = "≱", pD = "≱", vD = "≧̸", mD = "⩾̸", gD = "⩾̸", dd = "⋙̸", yD = "≵", bD = "≫⃒", sm = "≯", SD = "≯", wD = "≫̸", xD = "↮", kD = "⇎", Yl = "⫲", OD = "∋", hd = "⋼", M0 = "⋺", Dn = "∋", CD = "Њ", TD = "њ", AD = "↚", ED = "⇍", lm = "‥", MD = "≦̸", RD = "≰", Ao = "↚", DD = "⇍", pd = "↮", eo = "⇎", PD = "≰", LD = "≦̸", R0 = "⩽̸", gc = "⩽̸", ID = "≮", _D = "⋘̸", ND = "≴", vd = "≪⃒", D0 = "≮", P0 = "⋪", BD = "⋬", FD = "≪̸", zD = "∤", HD = "⁠", md = " ", jD = "𝕟", WD = "ℕ", um = "⫬", $D = "¬", UD = "≢", VD = "≭", GD = "∦", ql = "∉", YD = "≠", L0 = "≂̸", cm = "∄", qD = "≯", I0 = "≱", KD = "≧̸", XD = "≫̸", JD = "≹", ZD = "⩾̸", QD = "≵", _0 = "≎̸", eP = "≏̸", tP = "∉", rP = "⋵̸", nP = "⋹̸", fm = "∉", N0 = "⋷", ol = "⋶", B0 = "⧏̸", iP = "⋪", aP = "⋬", oP = "≮", sP = "≰", lP = "≸", uP = "≪̸", F0 = "⩽̸", cP = "≴", fP = "⪢̸", dP = "⪡̸", hP = "∌", dm = "∌", pP = "⋾", z0 = "⋽", gd = "⊀", vP = "⪯̸", mP = "⋠", gP = "∌", yP = "⧐̸", bP = "⋫", SP = "⋭", H0 = "⊏̸", hm = "⋢", wP = "⊐̸", xP = "⋣", kP = "⊂⃒", OP = "⊈", CP = "⊁", TP = "⪰̸", pm = "⋡", AP = "≿̸", EP = "⊃⃒", Kl = "⊉", MP = "≁", yd = "≄", bd = "≇", j0 = "≉", RP = "∤", DP = "∦", PP = "∦", LP = "⫽⃥", IP = "∂̸", vm = "⨔", W0 = "⊀", $0 = "⋠", U0 = "⊀", Sd = "⪯̸", _P = "⪯̸", NP = "⤳̸", BP = "↛", FP = "⇏", V0 = "↝̸", Eo = "↛", G0 = "⇏", zP = "⋫", Y0 = "⋭", HP = "⊁", jP = "⋡", mm = "⪰̸", WP = "𝒩", $P = "𝓃", UP = "∤", VP = "∦", gm = "≁", GP = "≄", YP = "≄", Es = "∤", qP = "∦", wd = "⋢", Ms = "⋣", KP = "⊄", xd = "⫅̸", q0 = "⊈", ym = "⊂⃒", XP = "⊈", JP = "⫅̸", ZP = "⊁", QP = "⪰̸", kd = "⊅", eL = "⫆̸", tL = "⊉", bm = "⊃⃒", rL = "⊉", nL = "⫆̸", iL = "≹", aL = "Ñ", Xl = "ñ", K0 = "≸", oL = "⋪", Od = "⋬", qi = "⋫", sL = "⋭", lL = "Ν", uL = "ν", cL = "#", Sm = "№", X0 = " ", vn = "≍⃒", fL = "⊬", dL = "⊭", hL = "⊮", pL = "⊯", wm = "≥⃒", vL = ">⃒", mL = "⤄", oi = "⧞", gL = "⤂", Cd = "≤⃒", si = "<⃒", J0 = "⊴⃒", Z0 = "⤃", Td = "⊵⃒", Q0 = "∼⃒", yL = "⤣", bL = "↖", SL = "⇖", wL = "↖", xL = "⤧", Ad = "Ó", kL = "ó", OL = "⊛", xm = "Ô", CL = "ô", TL = "⊚", AL = "О", EL = "о", Jl = "⊝", ML = "Ő", Ed = "ő", RL = "⨸", DL = "⊙", PL = "⦼", LL = "Œ", IL = "œ", km = "⦿", eS = "𝔒", yc = "𝔬", _L = "˛", NL = "Ò", BL = "ò", FL = "⧁", Om = "⦵", zL = "Ω", HL = "∮", to = "↺", jL = "⦾", Md = "⦻", ro = "‾", tS = "⧀", Rd = "Ō", rS = "ō", Cm = "Ω", WL = "ω", $L = "Ο", UL = "ο", VL = "⦶", Dd = "⊖", GL = "𝕆", YL = "𝕠", Tm = "⦷", qL = "“", KL = "‘", XL = "⦹", JL = "⊕", Zl = "↻", ZL = "⩔", Pd = "∨", nS = "⩝", iS = "ℴ", QL = "ℴ", eI = "ª", tI = "º", rI = "⊶", Ld = "⩖", nI = "⩗", iI = "⩛", Am = "Ⓢ", aI = "𝒪", oI = "ℴ", sI = "Ø", lI = "ø", Ql = "⊘", uI = "Õ", cI = "õ", fI = "⨶", aS = "⨷", Rs = "⊗", dI = "Ö", hI = "ö", Id = "⌽", sl = "‾", pI = "⏞", vI = "⎴", mI = "⏜", oS = "¶", mn = "∥", gI = "∥", yI = "⫳", bI = "⫽", SI = "∂", Em = "∂", wI = "П", xI = "п", wn = "%", kI = ".", _d = "‰", xn = "⊥", Mm = "‱", OI = "𝔓", sS = "𝔭", Rm = "Φ", CI = "φ", TI = "ϕ", fa = "ℳ", AI = "☎", Nd = "Π", EI = "π", Bd = "⋔", Fd = "ϖ", Mo = "ℏ", MI = "ℎ", RI = "ℏ", DI = "⨣", PI = "⊞", LI = "⨢", lS = "+", Dm = "∔", II = "⨥", _I = "⩲", NI = "±", BI = "±", FI = "⨦", zI = "⨧", Pm = "±", HI = "ℌ", jI = "⨕", uS = "𝕡", WI = "ℙ", zd = "£", cS = "⪷", Ra = "⪻", Lm = "≺", $I = "≼", UI = "⪷", VI = "≺", GI = "≼", Im = "≺", Hd = "⪯", YI = "≼", qI = "≾", KI = "⪯", XI = "⪹", _m = "⪵", JI = "⋨", ZI = "⪯", fS = "⪳", QI = "≾", jd = "′", e_ = "″", Nm = "ℙ", Wd = "⪹", Bm = "⪵", t_ = "⋨", r_ = "∏", n_ = "∏", i_ = "⌮", Fm = "⌒", dS = "⌓", eu = "∝", a_ = "∝", o_ = "∷", s_ = "∝", l_ = "≾", zm = "⊰", u_ = "𝒫", c_ = "𝓅", tu = "Ψ", f_ = "ψ", $d = " ", Da = "𝔔", hS = "𝔮", Ud = "⨌", pS = "𝕢", d_ = "ℚ", h_ = "⁗", p_ = "𝒬", v_ = "𝓆", m_ = "ℍ", Vd = "⨖", g_ = "?", y_ = "≟", Hm = '"', b_ = '"', S_ = "⇛", w_ = "∽̱", x_ = "Ŕ", ru = "ŕ", k_ = "√", Gd = "⦳", vS = "⟩", O_ = "⟫", C_ = "⦒", T_ = "⦥", A_ = "⟩", E_ = "»", Yd = "⥵", M_ = "⇥", R_ = "⤠", jm = "⤳", D_ = "→", P_ = "↠", L_ = "⇒", I_ = "⤞", nu = "↪", __ = "↬", qd = "⥅", mS = "⥴", gS = "⤖", N_ = "↣", B_ = "↝", F_ = "⤚", z_ = "⤜", Kd = "∶", H_ = "ℚ", j_ = "⤍", Wm = "⤏", W_ = "⤐", $_ = "❳", U_ = "}", V_ = "]", iu = "⦌", yS = "⦎", G_ = "⦐", Y_ = "Ř", Xd = "ř", bS = "Ŗ", SS = "ŗ", q_ = "⌉", K_ = "}", X_ = "Р", J_ = "р", $m = "⤷", Z_ = "⥩", Q_ = "”", Pa = "”", eN = "↳", Jd = "ℜ", La = "ℛ", wS = "ℜ", tN = "ℝ", rN = "ℜ", nN = "▭", iN = "®", Um = "®", aN = "∋", oN = "⇋", xS = "⥯", sN = "⥽", Zd = "⌋", lN = "𝔯", uN = "ℜ", cN = "⥤", fN = "⇁", Vm = "⇀", dN = "⥬", hN = "Ρ", kS = "ρ", pN = "ϱ", Qd = "⟩", vN = "⇥", mN = "→", gN = "→", eh = "⇒", OS = "⇄", CS = "↣", yN = "⌉", bN = "⟧", SN = "⥝", wN = "⥕", th = "⇂", xN = "⌋", kN = "⇁", Gm = "⇀", ON = "⇄", CN = "⇌", TN = "⇉", AN = "↝", au = "↦", EN = "⊢", rh = "⥛", MN = "⋌", RN = "⧐", DN = "⊳", nh = "⊵", PN = "⥏", LN = "⥜", Ym = "⥔", IN = "↾", _N = "⥓", NN = "⇀", BN = "˚", ou = "≓", FN = "⇄", zN = "⇌", HN = "‏", jN = "⎱", WN = "⎱", qm = "⫮", TS = "⟭", ih = "⇾", $N = "⟧", UN = "⦆", VN = "𝕣", ah = "ℝ", GN = "⨮", YN = "⨵", qN = "⥰", KN = ")", XN = "⦔", JN = "⨒", ZN = "⇉", QN = "⇛", Km = "›", eB = "𝓇", tB = "ℛ", da = "↱", rB = "↱", oh = "]", AS = "’", ln = "’", ha = "⋌", Ia = "⋊", nB = "▹", ES = "⊵", iB = "▸", aB = "⧎", Xm = "⧴", oB = "⥨", sB = "℞", MS = "Ś", Jm = "ś", lB = "‚", uB = "⪸", sh = "Š", RS = "š", DS = "⪼", cB = "≻", fB = "≽", dB = "⪰", lh = "⪴", hB = "Ş", pB = "ş", Zm = "Ŝ", vB = "ŝ", mB = "⪺", PS = "⪶", gB = "⋩", su = "⨓", LS = "≿", yB = "С", IS = "с", _S = "⊡", bB = "⋅", NS = "⩦", SB = "⤥", wB = "↘", uh = "⇘", BS = "↘", FS = "§", xB = ";", kB = "⤩", OB = "∖", CB = "∖", ch = "✶", TB = "𝔖", AB = "𝔰", Qm = "⌢", EB = "♯", MB = "Щ", RB = "щ", DB = "Ш", lu = "ш", PB = "↓", fh = "←", uu = "∣", LB = "∥", IB = "→", _B = "↑", NB = "­", eg = "Σ", zS = "σ", _a = "ς", BB = "ς", FB = "∼", zB = "⩪", HB = "≃", tg = "≃", jB = "⪞", WB = "⪠", rs = "⪝", $B = "⪟", dh = "≆", ns = "⨤", UB = "⥲", HS = "←", VB = "∘", hh = "∖", GB = "⨳", YB = "⧤", qB = "∣", KB = "⌣", XB = "⪪", rg = "⪬", JB = "⪬︀", ZB = "Ь", QB = "ь", e2 = "⌿", ng = "⧄", t2 = "/", r2 = "𝕊", ig = "𝕤", n2 = "♠", ph = "♠", jS = "∥", WS = "⊓", $S = "⊓︀", ag = "⊔", vh = "⊔︀", US = "√", i2 = "⊏", mh = "⊑", a2 = "⊏", o2 = "⊑", s2 = "⊐", l2 = "⊒", og = "⊐", u2 = "⊒", c2 = "□", f2 = "□", d2 = "⊓", sg = "⊏", h2 = "⊑", p2 = "⊐", gh = "⊒", v2 = "⊔", yh = "▪", bh = "□", Sh = "▪", VS = "→", m2 = "𝒮", lg = "𝓈", wh = "∖", GS = "⌣", YS = "⋆", g2 = "⋆", y2 = "☆", b2 = "★", S2 = "ϵ", xh = "ϕ", w2 = "¯", x2 = "⊂", ug = "⋐", k2 = "⪽", O2 = "⫅", C2 = "⊆", T2 = "⫃", cu = "⫁", A2 = "⫋", qS = "⊊", E2 = "⪿", M2 = "⥹", R2 = "⊂", D2 = "⋐", cg = "⊆", P2 = "⫅", KS = "⊆", L2 = "⊊", I2 = "⫋", XS = "⫇", _2 = "⫕", JS = "⫓", ZS = "⪸", QS = "≻", N2 = "≽", B2 = "≻", F2 = "⪰", z2 = "≽", kh = "≿", ew = "⪰", Kn = "⪺", H2 = "⪶", j2 = "⋩", W2 = "≿", $2 = "∋", U2 = "∑", fg = "∑", V2 = "♪", G2 = "¹", Y2 = "²", q2 = "³", dg = "⊃", K2 = "⋑", X2 = "⪾", is = "⫘", J2 = "⫆", Oh = "⊇", as = "⫄", Z2 = "⊃", Ch = "⊇", Q2 = "⟉", eF = "⫗", tF = "⥻", rF = "⫂", hg = "⫌", nF = "⊋", iF = "⫀", pg = "⊃", aF = "⋑", Th = "⊇", tw = "⫆", oF = "⊋", Ah = "⫌", rw = "⫈", vg = "⫔", sF = "⫖", lF = "⤦", uF = "↙", cF = "⇙", Eh = "↙", fF = "⤪", dF = "ß", mg = "	", hF = "⌖", pF = "Τ", vF = "τ", mF = "⎴", fu = "Ť", gF = "ť", Mh = "Ţ", nw = "ţ", yF = "Т", bF = "т", SF = "⃛", Rh = "⌕", wF = "𝔗", iw = "𝔱", gg = "∴", xF = "∴", kF = "∴", aw = "Θ", $r = "θ", OF = "ϑ", CF = "ϑ", TF = "≈", AF = "∼", yg = "  ", EF = " ", MF = " ", no = "≈", RF = "∼", Dh = "Þ", io = "þ", DF = "˜", PF = "∼", du = "≃", LF = "≅", ow = "≈", hu = "⨱", IF = "⊠", _F = "×", Ph = "⨰", sw = "∭", lw = "⤨", NF = "⌶", BF = "⫱", FF = "⊤", zF = "𝕋", Lh = "𝕥", HF = "⫚", jF = "⤩", bg = "‴", WF = "™", $F = "™", UF = "▵", VF = "▿", pu = "◃", GF = "⊴", Ih = "≜", uw = "▹", Xn = "⊵", bc = "◬", YF = "≜", qF = "⨺", KF = "⃛", XF = "⨹", Sg = "⧍", JF = "⨻", ZF = "⏢", QF = "𝒯", ez = "𝓉", wg = "Ц", tz = "ц", rz = "Ћ", Na = "ћ", nz = "Ŧ", _h = "ŧ", Ba = "≬", iz = "↞", Nh = "↠", cw = "Ú", fw = "ú", az = "↑", oz = "↟", sz = "⇑", lz = "⥉", Bh = "Ў", uz = "ў", cz = "Ŭ", xg = "ŭ", fz = "Û", dz = "û", hz = "У", pz = "у", vu = "⇅", vz = "Ű", mz = "ű", gz = "⥮", yz = "⥾", bz = "𝔘", Sz = "𝔲", kg = "Ù", dw = "ù", Fh = "⥣", wz = "↿", xz = "↾", Og = "▀", hw = "⌜", pw = "⌜", kz = "⌏", Oz = "◸", vw = "Ū", Cz = "ū", Tz = "¨", Az = "_", Ez = "⏟", Mz = "⎵", zh = "⏝", Hh = "⋃", Rz = "⊎", Dz = "Ų", Pz = "ų", Lz = "𝕌", Cg = "𝕦", mw = "⤒", kn = "↑", Iz = "↑", _z = "⇑", Nz = "⇅", Bz = "↕", Tg = "↕", Fz = "⇕", zz = "⥮", ao = "↿", Hz = "↾", jh = "⊎", oo = "↖", jz = "↗", Wz = "υ", $z = "ϒ", Uz = "ϒ", Wh = "Υ", gw = "υ", yw = "↥", Vz = "⊥", Gz = "⇈", Yz = "⌝", qz = "⌝", $h = "⌎", Kz = "Ů", Xz = "ů", Ag = "◹", Jz = "𝒰", Zz = "𝓊", Qz = "⋰", eH = "Ũ", mu = "ũ", tH = "▵", rH = "▴", Jn = "⇈", Pn = "Ü", t = "ü", n = "⦧", a = "⦜", o = "ϵ", u = "ϰ", h = "∅", v = "ϕ", g = "ϖ", b = "∝", C = "↕", R = "⇕", I = "ϱ", W = "ς", Z = "⊊︀", ue = "⫋︀", ke = "⊋︀", Ee = "⫌︀", Le = "ϑ", je = "⊲", Ke = "⊳", ut = "⫨", bt = "⫫", mt = "⫩", Rt = "В", Dt = "в", Lt = "⊢", Wt = "⊨", Qt = "⊩", or = "⊫", lr = "⫦", xr = "⊻", br = "∨", yr = "⋁", Ar = "≚", qr = "⋮", nn = "|", tn = "‖", bn = "|", Tn = "‖", un = "∣", Ln = "|", so = "❘", Ro = "≀", Ds = " ", gu = "𝔙", nH = "𝔳", bw = "⊲", iH = "⊂⃒", K9 = "⊃⃒", X9 = "𝕍", J9 = "𝕧", Z9 = "∝", Q9 = "⊳", eG = "𝒱", tG = "𝓋", rG = "⫋︀", nG = "⊊︀", iG = "⫌︀", aG = "⊋︀", oG = "⊪", sG = "⦚", lG = "Ŵ", uG = "ŵ", cG = "⩟", fG = "∧", dG = "⋀", hG = "≙", pG = "℘", vG = "𝔚", mG = "𝔴", gG = "𝕎", yG = "𝕨", bG = "℘", SG = "≀", wG = "≀", xG = "𝒲", kG = "𝓌", OG = "⋂", CG = "◯", TG = "⋃", AG = "▽", EG = "𝔛", MG = "𝔵", RG = "⟷", DG = "⟺", PG = "Ξ", LG = "ξ", IG = "⟵", _G = "⟸", NG = "⟼", BG = "⋻", FG = "⨀", zG = "𝕏", HG = "𝕩", jG = "⨁", WG = "⨂", $G = "⟶", UG = "⟹", VG = "𝒳", GG = "𝓍", YG = "⨆", qG = "⨄", KG = "△", XG = "⋁", JG = "⋀", ZG = "Ý", QG = "ý", e7 = "Я", t7 = "я", r7 = "Ŷ", n7 = "ŷ", i7 = "Ы", a7 = "ы", o7 = "¥", s7 = "𝔜", l7 = "𝔶", u7 = "Ї", c7 = "ї", f7 = "𝕐", d7 = "𝕪", h7 = "𝒴", p7 = "𝓎", v7 = "Ю", m7 = "ю", g7 = "ÿ", y7 = "Ÿ", b7 = "Ź", S7 = "ź", w7 = "Ž", x7 = "ž", k7 = "З", O7 = "з", C7 = "Ż", T7 = "ż", A7 = "ℨ", E7 = "​", M7 = "Ζ", R7 = "ζ", D7 = "𝔷", P7 = "ℨ", L7 = "Ж", I7 = "ж", _7 = "⇝", N7 = "𝕫", B7 = "ℤ", F7 = "𝒵", z7 = "𝓏", H7 = "‍", j7 = "‌", OW = {
              Aacute: ee,
              aacute: de,
              Abreve: Ce,
              abreve: he,
              ac: oe,
              acd: ge,
              acE: we,
              Acirc: Oe,
              acirc: Qe,
              acute: Me,
              Acy: Ie,
              acy: rt,
              AElig: ot,
              aelig: Et,
              af: gt,
              Afr: At,
              afr: Mt,
              Agrave: St,
              agrave: Ve,
              alefsym: Ue,
              aleph: He,
              Alpha: We,
              alpha: ze,
              Amacr: at,
              amacr: Ye,
              amalg: tt,
              amp: wt,
              AMP: Ft,
              andand: qe,
              And: pe,
              and: _e,
              andd: Xe,
              andslope: lt,
              andv: Q,
              ang: te,
              ange: De,
              angle: nt,
              angmsdaa: be,
              angmsdab: G,
              angmsdac: V,
              angmsdad: ve,
              angmsdae: Ne,
              angmsdaf: it,
              angmsdag: yt,
              angmsdah: $t,
              angmsd: Gt,
              angrt: Jt,
              angrtvb: Xt,
              angrtvbd: Ae,
              angsph: vt,
              angst: Ot,
              angzarr: Vt,
              Aogon: et,
              aogon: ft,
              Aopf: $,
              aopf: Se,
              apacir: se,
              ap: M,
              apE: ne,
              ape: ce,
              apid: X,
              apos: Re,
              ApplyFunction: Ge,
              approx: pt,
              approxeq: xt,
              Aring: Pt,
              aring: Yt,
              Ascr: gr,
              ascr: dr,
              Assign: It,
              ast: ct,
              asymp: zt,
              asympeq: xe,
              Atilde: ae,
              atilde: _,
              Auml: U,
              auml: fe,
              awconint: Te,
              awint: Be,
              backcong: Je,
              backepsilon: Ct,
              backprime: jt,
              backsim: tr,
              backsimeq: Kt,
              Backslash: rr,
              Barv: kr,
              barvee: on,
              barwed: cr,
              Barwed: An,
              barwedge: ei,
              bbrk: bi,
              bbrktbrk: wa,
              bcong: Di,
              Bcy: Pi,
              bcy: Bo,
              bdquo: an,
              becaus: En,
              because: Si,
              Because: ta,
              bemptyv: Fo,
              bepsi: Li,
              bernou: Ii,
              Bernoullis: _i,
              Beta: gs,
              beta: ys,
              beth: Ni,
              between: Fn,
              Bfr: $a,
              bfr: ra,
              bigcap: Bi,
              bigcirc: mo,
              bigcup: Nu,
              bigodot: Ua,
              bigoplus: wi,
              bigotimes: Bu,
              bigsqcup: Dr,
              bigstar: gn,
              bigtriangledown: ti,
              bigtriangleup: ri,
              biguplus: bs,
              bigvee: xa,
              bigwedge: Pr,
              bkarow: El,
              blacklozenge: ka,
              blacksquare: hn,
              blacktriangle: go,
              blacktriangledown: zo,
              blacktriangleleft: xi,
              blacktriangleright: $s,
              blank: Ss,
              blk12: ws,
              blk14: zn,
              blk34: mr,
              block: kt,
              bne: er,
              bnequiv: hr,
              bNot: Rr,
              bnot: Wr,
              Bopf: cn,
              bopf: Hr,
              bot: Ur,
              bottom: Ho,
              bowtie: Ml,
              boxbox: Fu,
              boxdl: Va,
              boxdL: Tp,
              boxDl: zu,
              boxDL: Us,
              boxdr: Ap,
              boxdR: Rl,
              boxDr: ni,
              boxDR: Vs,
              boxh: Dl,
              boxH: jo,
              boxhd: Ep,
              boxHd: Pl,
              boxhD: Hu,
              boxHD: ju,
              boxhu: qc,
              boxHu: Wu,
              boxhU: $u,
              boxHU: yo,
              boxminus: Fi,
              boxplus: Cr,
              boxtimes: Mp,
              boxul: Gs,
              boxuL: bo,
              boxUl: Uu,
              boxUL: Oa,
              boxur: Vu,
              boxuR: xs,
              boxUr: Rp,
              boxUR: Dp,
              boxv: Ys,
              boxV: Pp,
              boxvh: Ll,
              boxvH: Kc,
              boxVh: Wo,
              boxVH: So,
              boxvl: qs,
              boxvL: Lp,
              boxVl: $o,
              boxVL: ks,
              boxvr: Ga,
              boxvR: zi,
              boxVr: Mn,
              boxVR: Xc,
              bprime: Ip,
              breve: Jc,
              Breve: Hi,
              brvbar: Lr,
              bscr: Ks,
              Bscr: Il,
              bsemi: Uo,
              bsim: Gu,
              bsime: Zc,
              bsolb: Yu,
              bsol: qu,
              bsolhsub: Qc,
              bull: _p,
              bullet: Np,
              bump: ef,
              bumpE: tf,
              bumpe: Bp,
              Bumpeq: Ku,
              bumpeq: Fp,
              Cacute: zp,
              cacute: Os,
              capand: Hp,
              capbrcup: Xs,
              capcap: ji,
              cap: _r,
              Cap: Xu,
              capcup: Vr,
              capdot: rf,
              CapitalDifferentialD: nf,
              caps: jp,
              caret: af,
              caron: Ju,
              Cayleys: of,
              ccaps: sf,
              Ccaron: Wp,
              ccaron: lf,
              Ccedil: $p,
              ccedil: Zu,
              Ccirc: A,
              ccirc: B,
              Cconint: E,
              ccups: N,
              ccupssm: H,
              Cdot: Y,
              cdot: le,
              cedil: me,
              Cedilla: Pe,
              cemptyv: $e,
              cent: st,
              centerdot: Tt,
              CenterDot: ht,
              cfr: _t,
              Cfr: Ht,
              CHcy: nr,
              chcy: Tr,
              check: Zt,
              checkmark: Gr,
              Chi: Or,
              chi: en,
              circ: Nr,
              circeq: zr,
              circlearrowleft: fn,
              circlearrowright: ki,
              circledast: na,
              circledcirc: Rn,
              circleddash: ia,
              CircleDot: ii,
              circledR: aa,
              circledS: Ca,
              CircleMinus: Ya,
              CirclePlus: oa,
              CircleTimes: yn,
              cir: uf,
              cirE: Up,
              cire: Cs,
              cirfnint: Vo,
              cirmid: cf,
              cirscir: sa,
              ClockwiseContourIntegral: oy,
              CloseCurlyDoubleQuote: rk,
              CloseCurlyQuote: sy,
              clubs: nk,
              clubsuit: ff,
              colon: df,
              Colon: Vp,
              Colone: ly,
              colone: qa,
              coloneq: Qu,
              comma: uy,
              commat: Go,
              comp: ik,
              compfn: cy,
              complement: ak,
              complexes: ok,
              cong: fy,
              congdot: dy,
              Congruent: Gp,
              conint: Yp,
              Conint: hy,
              ContourIntegral: py,
              copf: vy,
              Copf: Yo,
              coprod: qp,
              Coproduct: hf,
              copy: sk,
              COPY: my,
              copysr: lk,
              CounterClockwiseContourIntegral: Kp,
              crarr: qo,
              cross: Ka,
              Cross: uk,
              Cscr: Xp,
              cscr: ck,
              csub: _l,
              csube: fk,
              csup: dk,
              csupe: gy,
              ctdot: Ko,
              cudarrl: hk,
              cudarrr: Jp,
              cuepr: pk,
              cuesc: vk,
              cularr: mk,
              cularrp: gk,
              cupbrcap: Zp,
              cupcap: yy,
              CupCap: yk,
              cup: bk,
              Cup: by,
              cupcup: Sy,
              cupdot: Sk,
              cupor: Qp,
              cups: wk,
              curarr: xk,
              curarrm: kk,
              curlyeqprec: Ok,
              curlyeqsucc: Ck,
              curlyvee: Tk,
              curlywedge: Xa,
              curren: wy,
              curvearrowleft: Ak,
              curvearrowright: pn,
              cuvee: Ek,
              cuwed: Mk,
              cwconint: Rk,
              cwint: Dk,
              cylcty: ev,
              dagger: xy,
              Dagger: Pk,
              daleth: Lk,
              darr: Ik,
              Darr: _k,
              dArr: Nk,
              dash: Bk,
              Dashv: Fk,
              dashv: ky,
              dbkarow: zk,
              dblac: Hk,
              Dcaron: Oy,
              dcaron: jk,
              Dcy: Wk,
              dcy: $k,
              ddagger: Uk,
              ddarr: Vk,
              DD: Gk,
              dd: Yk,
              DDotrahd: qk,
              ddotseq: Kk,
              deg: Xk,
              Del: Cy,
              Delta: Jk,
              delta: pf,
              demptyv: Zk,
              dfisht: Qk,
              Dfr: eO,
              dfr: tO,
              dHar: tv,
              dharl: rO,
              dharr: nO,
              DiacriticalAcute: Wi,
              DiacriticalDot: iO,
              DiacriticalDoubleAcute: vf,
              DiacriticalGrave: la,
              DiacriticalTilde: aO,
              diam: Ty,
              diamond: sn,
              Diamond: Hn,
              diamondsuit: Ay,
              diams: mf,
              die: oO,
              DifferentialD: sO,
              digamma: Ey,
              disin: rv,
              div: lO,
              divide: uO,
              divideontimes: cO,
              divonx: fO,
              DJcy: My,
              djcy: gf,
              dlcorn: dO,
              dlcrop: wo,
              dollar: Ta,
              Dopf: Aa,
              dopf: hO,
              Dot: pO,
              dot: nv,
              DotDot: vO,
              doteq: mO,
              doteqdot: gO,
              DotEqual: yO,
              dotminus: bO,
              dotplus: Ry,
              dotsquare: Js,
              doublebarwedge: SO,
              DoubleContourIntegral: Br,
              DoubleDot: yf,
              DoubleDownArrow: wO,
              DoubleLeftArrow: xo,
              DoubleLeftRightArrow: iv,
              DoubleLeftTee: xO,
              DoubleLongLeftArrow: Dy,
              DoubleLongLeftRightArrow: kO,
              DoubleLongRightArrow: OO,
              DoubleRightArrow: av,
              DoubleRightTee: CO,
              DoubleUpArrow: TO,
              DoubleUpDownArrow: Py,
              DoubleVerticalBar: AO,
              DownArrowBar: EO,
              downarrow: MO,
              DownArrow: RO,
              Downarrow: DO,
              DownArrowUpArrow: PO,
              DownBreve: LO,
              downdownarrows: IO,
              downharpoonleft: Ly,
              downharpoonright: _O,
              DownLeftRightVector: NO,
              DownLeftTeeVector: BO,
              DownLeftVectorBar: ov,
              DownLeftVector: Iy,
              DownRightTeeVector: _y,
              DownRightVectorBar: bf,
              DownRightVector: sv,
              DownTeeArrow: FO,
              DownTee: Ny,
              drbkarow: zO,
              drcorn: HO,
              drcrop: jO,
              Dscr: WO,
              dscr: $O,
              DScy: UO,
              dscy: ko,
              dsol: By,
              Dstrok: VO,
              dstrok: Ts,
              dtdot: Fy,
              dtri: zy,
              dtrif: GO,
              duarr: ec,
              duhar: YO,
              dwangle: qO,
              DZcy: Hy,
              dzcy: KO,
              dzigrarr: XO,
              Eacute: JO,
              eacute: jy,
              easter: tc,
              Ecaron: ZO,
              ecaron: rc,
              Ecirc: QO,
              ecirc: Wy,
              ecir: lv,
              ecolon: eC,
              Ecy: tC,
              ecy: uv,
              eDDot: rC,
              Edot: $y,
              edot: nC,
              eDot: iC,
              ee: aC,
              efDot: oC,
              Efr: Uy,
              efr: sC,
              eg: lC,
              Egrave: uC,
              egrave: cC,
              egs: fC,
              egsdot: dC,
              el: cv,
              Element: Vy,
              elinters: Sf,
              ell: hC,
              els: pC,
              elsdot: vC,
              Emacr: mC,
              emacr: gC,
              empty: Gy,
              emptyset: Zs,
              EmptySmallSquare: $i,
              emptyv: Ui,
              EmptyVerySmallSquare: Nl,
              emsp13: yC,
              emsp14: nc,
              emsp: fv,
              ENG: bC,
              eng: Bl,
              ensp: wf,
              Eogon: SC,
              eogon: wC,
              Eopf: xC,
              eopf: kC,
              epar: OC,
              eparsl: CC,
              eplus: TC,
              epsi: Yy,
              Epsilon: ir,
              epsilon: dv,
              epsiv: AC,
              eqcirc: ic,
              eqcolon: qy,
              eqsim: EC,
              eqslantgtr: MC,
              eqslantless: Xo,
              Equal: hi,
              equals: Qs,
              EqualTilde: RC,
              equest: Fl,
              Equilibrium: ac,
              equiv: oc,
              equivDD: Jo,
              eqvparsl: Ky,
              erarr: DC,
              erDot: Xy,
              escr: Jy,
              Escr: Oo,
              esdot: Zy,
              Esim: Qy,
              esim: eb,
              Eta: tb,
              eta: hv,
              ETH: rb,
              eth: PC,
              Euml: xf,
              euml: kf,
              euro: pv,
              excl: nb,
              exist: ib,
              Exists: ab,
              expectation: Ea,
              exponentiale: LC,
              ExponentialE: ob,
              fallingdotseq: sb,
              Fcy: IC,
              fcy: _C,
              female: NC,
              ffilig: BC,
              fflig: lb,
              ffllig: FC,
              Ffr: zC,
              ffr: HC,
              filig: jC,
              FilledSmallSquare: ub,
              FilledVerySmallSquare: sc,
              fjlig: WC,
              flat: el,
              fllig: $C,
              fltns: cb,
              fnof: UC,
              Fopf: VC,
              fopf: vv,
              forall: GC,
              ForAll: mv,
              fork: YC,
              forkv: fb,
              Fouriertrf: qC,
              fpartint: gv,
              frac12: KC,
              frac13: XC,
              frac14: JC,
              frac15: ZC,
              frac16: QC,
              frac18: e1,
              frac23: t1,
              frac25: r1,
              frac34: db,
              frac35: n1,
              frac38: hb,
              frac45: pb,
              frac56: i1,
              frac58: a1,
              frac78: vb,
              frasl: mb,
              frown: o1,
              fscr: s1,
              Fscr: l1,
              gacute: u1,
              Gamma: c1,
              gamma: gb,
              Gammad: f1,
              gammad: d1,
              gap: yb,
              Gbreve: h1,
              gbreve: p1,
              Gcedil: v1,
              Gcirc: m1,
              gcirc: yv,
              Gcy: bb,
              gcy: jn,
              Gdot: lc,
              gdot: g1,
              ge: y1,
              gE: b1,
              gEl: S1,
              gel: w1,
              geq: x1,
              geqq: Sb,
              geqslant: k1,
              gescc: O1,
              ges: C1,
              gesdot: T1,
              gesdoto: A1,
              gesdotol: E1,
              gesl: M1,
              gesles: R1,
              Gfr: D1,
              gfr: P1,
              gg: bv,
              Gg: L1,
              ggg: I1,
              gimel: _1,
              GJcy: N1,
              gjcy: zl,
              gla: B1,
              gl: F1,
              glE: z1,
              glj: H1,
              gnap: Of,
              gnapprox: j1,
              gne: W1,
              gnE: $1,
              gneq: U1,
              gneqq: wb,
              gnsim: V1,
              Gopf: G1,
              gopf: Y1,
              grave: Cf,
              GreaterEqual: q1,
              GreaterEqualLess: K1,
              GreaterFullEqual: X1,
              GreaterGreater: J1,
              GreaterLess: Z1,
              GreaterSlantEqual: Q1,
              GreaterTilde: eT,
              Gscr: tT,
              gscr: rT,
              gsim: Sv,
              gsime: xb,
              gsiml: uc,
              gtcc: nT,
              gtcir: iT,
              gt: aT,
              GT: dn,
              Gt: kb,
              gtdot: oT,
              gtlPar: Wn,
              gtquest: sT,
              gtrapprox: lT,
              gtrarr: uT,
              gtrdot: cT,
              gtreqless: Ja,
              gtreqqless: fT,
              gtrless: Ob,
              gtrsim: dT,
              gvertneqq: hT,
              gvnE: wv,
              Hacek: xv,
              hairsp: cc,
              half: pT,
              hamilt: vT,
              HARDcy: mT,
              hardcy: gT,
              harrcir: yT,
              harr: bT,
              hArr: Vi,
              harrw: Cb,
              Hat: ST,
              hbar: wT,
              Hcirc: Tb,
              hcirc: xT,
              hearts: kT,
              heartsuit: OT,
              hellip: CT,
              hercon: kv,
              hfr: Ov,
              Hfr: TT,
              HilbertSpace: AT,
              hksearow: ET,
              hkswarow: fc,
              hoarr: MT,
              homtht: RT,
              hookleftarrow: DT,
              hookrightarrow: Ab,
              hopf: Eb,
              Hopf: PT,
              horbar: LT,
              HorizontalLine: Mb,
              hscr: dc,
              Hscr: IT,
              hslash: _T,
              Hstrok: Rb,
              hstrok: Tf,
              HumpDownHump: NT,
              HumpEqual: Db,
              hybull: BT,
              hyphen: Cv,
              Iacute: FT,
              iacute: zT,
              ic: HT,
              Icirc: Pb,
              icirc: Lb,
              Icy: jT,
              icy: Zo,
              Idot: WT,
              IEcy: $T,
              iecy: UT,
              iexcl: VT,
              iff: Tv,
              ifr: Af,
              Ifr: hc,
              Igrave: GT,
              igrave: Av,
              ii: Ib,
              iiiint: YT,
              iiint: _b,
              iinfin: qT,
              iiota: KT,
              IJlig: XT,
              ijlig: Nb,
              Imacr: JT,
              imacr: ZT,
              image: QT,
              ImaginaryI: eA,
              imagline: tA,
              imagpart: Hl,
              imath: Ev,
              Im: rA,
              imof: nA,
              imped: iA,
              Implies: aA,
              incare: Gi,
              in: "∈",
              infin: Mv,
              infintie: Bb,
              inodot: oA,
              intcal: sA,
              int: lA,
              Int: Fb,
              integers: uA,
              Integral: zb,
              intercal: Rv,
              Intersection: cA,
              intlarhk: fA,
              intprod: dA,
              InvisibleComma: hA,
              InvisibleTimes: Hb,
              IOcy: pA,
              iocy: vA,
              Iogon: mA,
              iogon: Za,
              Iopf: gA,
              iopf: yA,
              Iota: bA,
              iota: SA,
              iprod: wA,
              iquest: xA,
              iscr: jb,
              Iscr: kA,
              isin: Wb,
              isindot: OA,
              isinE: CA,
              isins: Dv,
              isinsv: pc,
              isinv: $b,
              it: TA,
              Itilde: AA,
              itilde: EA,
              Iukcy: MA,
              iukcy: RA,
              Iuml: DA,
              iuml: PA,
              Jcirc: LA,
              jcirc: IA,
              Jcy: _A,
              jcy: NA,
              Jfr: Pv,
              jfr: BA,
              jmath: Ub,
              Jopf: FA,
              jopf: zA,
              Jscr: HA,
              jscr: jA,
              Jsercy: WA,
              jsercy: $A,
              Jukcy: UA,
              jukcy: VA,
              Kappa: GA,
              kappa: YA,
              kappav: qA,
              Kcedil: KA,
              kcedil: Ef,
              Kcy: Vb,
              kcy: Mf,
              Kfr: XA,
              kfr: JA,
              kgreen: ZA,
              KHcy: QA,
              khcy: eE,
              KJcy: Lv,
              kjcy: tE,
              Kopf: rE,
              kopf: nE,
              Kscr: iE,
              kscr: Iv,
              lAarr: aE,
              Lacute: oE,
              lacute: Co,
              laemptyv: sE,
              lagran: Rf,
              Lambda: To,
              lambda: lE,
              lang: $n,
              Lang: Df,
              langd: Gb,
              langle: Yb,
              lap: Qo,
              Laplacetrf: uE,
              laquo: cE,
              larrb: fE,
              larrbfs: dE,
              larr: hE,
              Larr: qb,
              lArr: _v,
              larrfs: pE,
              larrhk: vE,
              larrlp: mE,
              larrpl: gE,
              larrsim: yE,
              larrtl: bE,
              latail: Nv,
              lAtail: SE,
              lat: wE,
              late: Pf,
              lates: xE,
              lbarr: Lf,
              lBarr: If,
              lbbrk: kE,
              lbrace: Kb,
              lbrack: _f,
              lbrke: Qa,
              lbrksld: Xb,
              lbrkslu: Jb,
              Lcaron: OE,
              lcaron: CE,
              Lcedil: TE,
              lcedil: AE,
              lceil: EE,
              lcub: ME,
              Lcy: Bv,
              lcy: Zb,
              ldca: jl,
              ldquo: Nf,
              ldquor: Qb,
              ldrdhar: e0,
              ldrushar: t0,
              ldsh: Fv,
              le: RE,
              lE: zv,
              LeftAngleBracket: DE,
              LeftArrowBar: r0,
              leftarrow: PE,
              LeftArrow: LE,
              Leftarrow: n0,
              LeftArrowRightArrow: Ir,
              leftarrowtail: IE,
              LeftCeiling: Bf,
              LeftDoubleBracket: _E,
              LeftDownTeeVector: NE,
              LeftDownVectorBar: BE,
              LeftDownVector: FE,
              LeftFloor: zE,
              leftharpoondown: HE,
              leftharpoonup: jE,
              leftleftarrows: WE,
              leftrightarrow: $E,
              LeftRightArrow: UE,
              Leftrightarrow: VE,
              leftrightarrows: GE,
              leftrightharpoons: YE,
              leftrightsquigarrow: qE,
              LeftRightVector: KE,
              LeftTeeArrow: XE,
              LeftTee: JE,
              LeftTeeVector: ZE,
              leftthreetimes: Ma,
              LeftTriangleBar: QE,
              LeftTriangle: i0,
              LeftTriangleEqual: eM,
              LeftUpDownVector: tM,
              LeftUpTeeVector: a0,
              LeftUpVectorBar: Ff,
              LeftUpVector: o0,
              LeftVectorBar: ai,
              LeftVector: rM,
              lEg: nM,
              leg: iM,
              leq: aM,
              leqq: Hv,
              leqslant: oM,
              lescc: sM,
              les: ua,
              lesdot: lM,
              lesdoto: zf,
              lesdotor: ca,
              lesg: Hf,
              lesges: jf,
              lessapprox: s0,
              lessdot: uM,
              lesseqgtr: cM,
              lesseqqgtr: fM,
              LessEqualGreater: dM,
              LessFullEqual: jv,
              LessGreater: l0,
              lessgtr: tl,
              LessLess: hM,
              lesssim: pM,
              LessSlantEqual: vM,
              LessTilde: mM,
              lfisht: Wv,
              lfloor: gM,
              Lfr: yM,
              lfr: es,
              lg: bM,
              lgE: Wf,
              lHar: ts,
              lhard: Oi,
              lharu: $f,
              lharul: u0,
              lhblk: Wl,
              LJcy: $l,
              ljcy: SM,
              llarr: wM,
              ll: xM,
              Ll: kM,
              llcorner: $v,
              Lleftarrow: OM,
              llhard: CM,
              lltri: TM,
              Lmidot: AM,
              lmidot: Uv,
              lmoustache: EM,
              lmoust: MM,
              lnap: Ul,
              lnapprox: RM,
              lne: Uf,
              lnE: As,
              lneq: DM,
              lneqq: Yi,
              lnsim: Vf,
              loang: PM,
              loarr: LM,
              lobrk: IM,
              longleftarrow: c0,
              LongLeftArrow: _M,
              Longleftarrow: NM,
              longleftrightarrow: BM,
              LongLeftRightArrow: FM,
              Longleftrightarrow: zM,
              longmapsto: HM,
              longrightarrow: Vv,
              LongRightArrow: jM,
              Longrightarrow: WM,
              looparrowleft: vc,
              looparrowright: $M,
              lopar: Gf,
              Lopf: Yf,
              lopf: Yr,
              loplus: qf,
              lotimes: UM,
              lowast: VM,
              lowbar: GM,
              LowerLeftArrow: YM,
              LowerRightArrow: Gv,
              loz: qM,
              lozenge: KM,
              lozf: Yv,
              lpar: XM,
              lparlt: Kf,
              lrarr: f0,
              lrcorner: Un,
              lrhar: Xf,
              lrhard: JM,
              lrm: ZM,
              lrtri: QM,
              lsaquo: eR,
              lscr: tR,
              Lscr: rR,
              lsh: nR,
              Lsh: iR,
              lsim: d0,
              lsime: aR,
              lsimg: oR,
              lsqb: qv,
              lsquo: sR,
              lsquor: lR,
              Lstrok: uR,
              lstrok: cR,
              ltcc: Kv,
              ltcir: fR,
              lt: dR,
              LT: Vl,
              Lt: hR,
              ltdot: Jf,
              lthree: mc,
              ltimes: h0,
              ltlarr: Vn,
              ltquest: Zf,
              ltri: pR,
              ltrie: vR,
              ltrif: mR,
              ltrPar: gR,
              lurdshar: yR,
              luruhar: bR,
              lvertneqq: p0,
              lvnE: Xv,
              macr: SR,
              male: wR,
              malt: v0,
              maltese: Qf,
              Map: "⤅",
              map: xR,
              mapsto: kR,
              mapstodown: OR,
              mapstoleft: CR,
              mapstoup: Jv,
              marker: TR,
              mcomma: AR,
              Mcy: rl,
              mcy: ER,
              mdash: ed,
              mDDot: nl,
              measuredangle: MR,
              MediumSpace: Gl,
              Mellintrf: td,
              Mfr: RR,
              mfr: DR,
              mho: PR,
              micro: LR,
              midast: Zv,
              midcir: IR,
              mid: _R,
              middot: Qv,
              minusb: NR,
              minus: rd,
              minusd: m0,
              minusdu: em,
              MinusPlus: nd,
              mlcp: g0,
              mldr: y0,
              mnplus: BR,
              models: FR,
              Mopf: zR,
              mopf: HR,
              mp: tm,
              mscr: jR,
              Mscr: WR,
              mstpos: il,
              Mu: $R,
              mu: id,
              multimap: al,
              mumap: Gn,
              nabla: ad,
              Nacute: b0,
              nacute: S0,
              nang: UR,
              nap: VR,
              napE: GR,
              napid: YR,
              napos: rm,
              napprox: qR,
              natural: KR,
              naturals: nm,
              natur: XR,
              nbsp: od,
              nbump: im,
              nbumpe: Yn,
              ncap: sd,
              Ncaron: w0,
              ncaron: x0,
              Ncedil: JR,
              ncedil: ZR,
              ncong: QR,
              ncongdot: eD,
              ncup: am,
              Ncy: tD,
              ncy: rD,
              ndash: k0,
              nearhk: nD,
              nearr: ld,
              neArr: O0,
              nearrow: iD,
              ne: qn,
              nedot: C0,
              NegativeMediumSpace: om,
              NegativeThickSpace: T0,
              NegativeThinSpace: ud,
              NegativeVeryThinSpace: aD,
              nequiv: oD,
              nesear: sD,
              nesim: lD,
              NestedGreaterGreater: A0,
              NestedLessLess: cd,
              NewLine: uD,
              nexist: cD,
              nexists: fD,
              Nfr: dD,
              nfr: fd,
              ngE: E0,
              nge: hD,
              ngeq: pD,
              ngeqq: vD,
              ngeqslant: mD,
              nges: gD,
              nGg: dd,
              ngsim: yD,
              nGt: bD,
              ngt: sm,
              ngtr: SD,
              nGtv: wD,
              nharr: xD,
              nhArr: kD,
              nhpar: Yl,
              ni: OD,
              nis: hd,
              nisd: M0,
              niv: Dn,
              NJcy: CD,
              njcy: TD,
              nlarr: AD,
              nlArr: ED,
              nldr: lm,
              nlE: MD,
              nle: RD,
              nleftarrow: Ao,
              nLeftarrow: DD,
              nleftrightarrow: pd,
              nLeftrightarrow: eo,
              nleq: PD,
              nleqq: LD,
              nleqslant: R0,
              nles: gc,
              nless: ID,
              nLl: _D,
              nlsim: ND,
              nLt: vd,
              nlt: D0,
              nltri: P0,
              nltrie: BD,
              nLtv: FD,
              nmid: zD,
              NoBreak: HD,
              NonBreakingSpace: md,
              nopf: jD,
              Nopf: WD,
              Not: um,
              not: $D,
              NotCongruent: UD,
              NotCupCap: VD,
              NotDoubleVerticalBar: GD,
              NotElement: ql,
              NotEqual: YD,
              NotEqualTilde: L0,
              NotExists: cm,
              NotGreater: qD,
              NotGreaterEqual: I0,
              NotGreaterFullEqual: KD,
              NotGreaterGreater: XD,
              NotGreaterLess: JD,
              NotGreaterSlantEqual: ZD,
              NotGreaterTilde: QD,
              NotHumpDownHump: _0,
              NotHumpEqual: eP,
              notin: tP,
              notindot: rP,
              notinE: nP,
              notinva: fm,
              notinvb: N0,
              notinvc: ol,
              NotLeftTriangleBar: B0,
              NotLeftTriangle: iP,
              NotLeftTriangleEqual: aP,
              NotLess: oP,
              NotLessEqual: sP,
              NotLessGreater: lP,
              NotLessLess: uP,
              NotLessSlantEqual: F0,
              NotLessTilde: cP,
              NotNestedGreaterGreater: fP,
              NotNestedLessLess: dP,
              notni: hP,
              notniva: dm,
              notnivb: pP,
              notnivc: z0,
              NotPrecedes: gd,
              NotPrecedesEqual: vP,
              NotPrecedesSlantEqual: mP,
              NotReverseElement: gP,
              NotRightTriangleBar: yP,
              NotRightTriangle: bP,
              NotRightTriangleEqual: SP,
              NotSquareSubset: H0,
              NotSquareSubsetEqual: hm,
              NotSquareSuperset: wP,
              NotSquareSupersetEqual: xP,
              NotSubset: kP,
              NotSubsetEqual: OP,
              NotSucceeds: CP,
              NotSucceedsEqual: TP,
              NotSucceedsSlantEqual: pm,
              NotSucceedsTilde: AP,
              NotSuperset: EP,
              NotSupersetEqual: Kl,
              NotTilde: MP,
              NotTildeEqual: yd,
              NotTildeFullEqual: bd,
              NotTildeTilde: j0,
              NotVerticalBar: RP,
              nparallel: DP,
              npar: PP,
              nparsl: LP,
              npart: IP,
              npolint: vm,
              npr: W0,
              nprcue: $0,
              nprec: U0,
              npreceq: Sd,
              npre: _P,
              nrarrc: NP,
              nrarr: BP,
              nrArr: FP,
              nrarrw: V0,
              nrightarrow: Eo,
              nRightarrow: G0,
              nrtri: zP,
              nrtrie: Y0,
              nsc: HP,
              nsccue: jP,
              nsce: mm,
              Nscr: WP,
              nscr: $P,
              nshortmid: UP,
              nshortparallel: VP,
              nsim: gm,
              nsime: GP,
              nsimeq: YP,
              nsmid: Es,
              nspar: qP,
              nsqsube: wd,
              nsqsupe: Ms,
              nsub: KP,
              nsubE: xd,
              nsube: q0,
              nsubset: ym,
              nsubseteq: XP,
              nsubseteqq: JP,
              nsucc: ZP,
              nsucceq: QP,
              nsup: kd,
              nsupE: eL,
              nsupe: tL,
              nsupset: bm,
              nsupseteq: rL,
              nsupseteqq: nL,
              ntgl: iL,
              Ntilde: aL,
              ntilde: Xl,
              ntlg: K0,
              ntriangleleft: oL,
              ntrianglelefteq: Od,
              ntriangleright: qi,
              ntrianglerighteq: sL,
              Nu: lL,
              nu: uL,
              num: cL,
              numero: Sm,
              numsp: X0,
              nvap: vn,
              nvdash: fL,
              nvDash: dL,
              nVdash: hL,
              nVDash: pL,
              nvge: wm,
              nvgt: vL,
              nvHarr: mL,
              nvinfin: oi,
              nvlArr: gL,
              nvle: Cd,
              nvlt: si,
              nvltrie: J0,
              nvrArr: Z0,
              nvrtrie: Td,
              nvsim: Q0,
              nwarhk: yL,
              nwarr: bL,
              nwArr: SL,
              nwarrow: wL,
              nwnear: xL,
              Oacute: Ad,
              oacute: kL,
              oast: OL,
              Ocirc: xm,
              ocirc: CL,
              ocir: TL,
              Ocy: AL,
              ocy: EL,
              odash: Jl,
              Odblac: ML,
              odblac: Ed,
              odiv: RL,
              odot: DL,
              odsold: PL,
              OElig: LL,
              oelig: IL,
              ofcir: km,
              Ofr: eS,
              ofr: yc,
              ogon: _L,
              Ograve: NL,
              ograve: BL,
              ogt: FL,
              ohbar: Om,
              ohm: zL,
              oint: HL,
              olarr: to,
              olcir: jL,
              olcross: Md,
              oline: ro,
              olt: tS,
              Omacr: Rd,
              omacr: rS,
              Omega: Cm,
              omega: WL,
              Omicron: $L,
              omicron: UL,
              omid: VL,
              ominus: Dd,
              Oopf: GL,
              oopf: YL,
              opar: Tm,
              OpenCurlyDoubleQuote: qL,
              OpenCurlyQuote: KL,
              operp: XL,
              oplus: JL,
              orarr: Zl,
              Or: ZL,
              or: Pd,
              ord: nS,
              order: iS,
              orderof: QL,
              ordf: eI,
              ordm: tI,
              origof: rI,
              oror: Ld,
              orslope: nI,
              orv: iI,
              oS: Am,
              Oscr: aI,
              oscr: oI,
              Oslash: sI,
              oslash: lI,
              osol: Ql,
              Otilde: uI,
              otilde: cI,
              otimesas: fI,
              Otimes: aS,
              otimes: Rs,
              Ouml: dI,
              ouml: hI,
              ovbar: Id,
              OverBar: sl,
              OverBrace: pI,
              OverBracket: vI,
              OverParenthesis: mI,
              para: oS,
              parallel: mn,
              par: gI,
              parsim: yI,
              parsl: bI,
              part: SI,
              PartialD: Em,
              Pcy: wI,
              pcy: xI,
              percnt: wn,
              period: kI,
              permil: _d,
              perp: xn,
              pertenk: Mm,
              Pfr: OI,
              pfr: sS,
              Phi: Rm,
              phi: CI,
              phiv: TI,
              phmmat: fa,
              phone: AI,
              Pi: Nd,
              pi: EI,
              pitchfork: Bd,
              piv: Fd,
              planck: Mo,
              planckh: MI,
              plankv: RI,
              plusacir: DI,
              plusb: PI,
              pluscir: LI,
              plus: lS,
              plusdo: Dm,
              plusdu: II,
              pluse: _I,
              PlusMinus: NI,
              plusmn: BI,
              plussim: FI,
              plustwo: zI,
              pm: Pm,
              Poincareplane: HI,
              pointint: jI,
              popf: uS,
              Popf: WI,
              pound: zd,
              prap: cS,
              Pr: Ra,
              pr: Lm,
              prcue: $I,
              precapprox: UI,
              prec: VI,
              preccurlyeq: GI,
              Precedes: Im,
              PrecedesEqual: Hd,
              PrecedesSlantEqual: YI,
              PrecedesTilde: qI,
              preceq: KI,
              precnapprox: XI,
              precneqq: _m,
              precnsim: JI,
              pre: ZI,
              prE: fS,
              precsim: QI,
              prime: jd,
              Prime: e_,
              primes: Nm,
              prnap: Wd,
              prnE: Bm,
              prnsim: t_,
              prod: r_,
              Product: n_,
              profalar: i_,
              profline: Fm,
              profsurf: dS,
              prop: eu,
              Proportional: a_,
              Proportion: o_,
              propto: s_,
              prsim: l_,
              prurel: zm,
              Pscr: u_,
              pscr: c_,
              Psi: tu,
              psi: f_,
              puncsp: $d,
              Qfr: Da,
              qfr: hS,
              qint: Ud,
              qopf: pS,
              Qopf: d_,
              qprime: h_,
              Qscr: p_,
              qscr: v_,
              quaternions: m_,
              quatint: Vd,
              quest: g_,
              questeq: y_,
              quot: Hm,
              QUOT: b_,
              rAarr: S_,
              race: w_,
              Racute: x_,
              racute: ru,
              radic: k_,
              raemptyv: Gd,
              rang: vS,
              Rang: O_,
              rangd: C_,
              range: T_,
              rangle: A_,
              raquo: E_,
              rarrap: Yd,
              rarrb: M_,
              rarrbfs: R_,
              rarrc: jm,
              rarr: D_,
              Rarr: P_,
              rArr: L_,
              rarrfs: I_,
              rarrhk: nu,
              rarrlp: __,
              rarrpl: qd,
              rarrsim: mS,
              Rarrtl: gS,
              rarrtl: N_,
              rarrw: B_,
              ratail: F_,
              rAtail: z_,
              ratio: Kd,
              rationals: H_,
              rbarr: j_,
              rBarr: Wm,
              RBarr: W_,
              rbbrk: $_,
              rbrace: U_,
              rbrack: V_,
              rbrke: iu,
              rbrksld: yS,
              rbrkslu: G_,
              Rcaron: Y_,
              rcaron: Xd,
              Rcedil: bS,
              rcedil: SS,
              rceil: q_,
              rcub: K_,
              Rcy: X_,
              rcy: J_,
              rdca: $m,
              rdldhar: Z_,
              rdquo: Q_,
              rdquor: Pa,
              rdsh: eN,
              real: Jd,
              realine: La,
              realpart: wS,
              reals: tN,
              Re: rN,
              rect: nN,
              reg: iN,
              REG: Um,
              ReverseElement: aN,
              ReverseEquilibrium: oN,
              ReverseUpEquilibrium: xS,
              rfisht: sN,
              rfloor: Zd,
              rfr: lN,
              Rfr: uN,
              rHar: cN,
              rhard: fN,
              rharu: Vm,
              rharul: dN,
              Rho: hN,
              rho: kS,
              rhov: pN,
              RightAngleBracket: Qd,
              RightArrowBar: vN,
              rightarrow: mN,
              RightArrow: gN,
              Rightarrow: eh,
              RightArrowLeftArrow: OS,
              rightarrowtail: CS,
              RightCeiling: yN,
              RightDoubleBracket: bN,
              RightDownTeeVector: SN,
              RightDownVectorBar: wN,
              RightDownVector: th,
              RightFloor: xN,
              rightharpoondown: kN,
              rightharpoonup: Gm,
              rightleftarrows: ON,
              rightleftharpoons: CN,
              rightrightarrows: TN,
              rightsquigarrow: AN,
              RightTeeArrow: au,
              RightTee: EN,
              RightTeeVector: rh,
              rightthreetimes: MN,
              RightTriangleBar: RN,
              RightTriangle: DN,
              RightTriangleEqual: nh,
              RightUpDownVector: PN,
              RightUpTeeVector: LN,
              RightUpVectorBar: Ym,
              RightUpVector: IN,
              RightVectorBar: _N,
              RightVector: NN,
              ring: BN,
              risingdotseq: ou,
              rlarr: FN,
              rlhar: zN,
              rlm: HN,
              rmoustache: jN,
              rmoust: WN,
              rnmid: qm,
              roang: TS,
              roarr: ih,
              robrk: $N,
              ropar: UN,
              ropf: VN,
              Ropf: ah,
              roplus: GN,
              rotimes: YN,
              RoundImplies: qN,
              rpar: KN,
              rpargt: XN,
              rppolint: JN,
              rrarr: ZN,
              Rrightarrow: QN,
              rsaquo: Km,
              rscr: eB,
              Rscr: tB,
              rsh: da,
              Rsh: rB,
              rsqb: oh,
              rsquo: AS,
              rsquor: ln,
              rthree: ha,
              rtimes: Ia,
              rtri: nB,
              rtrie: ES,
              rtrif: iB,
              rtriltri: aB,
              RuleDelayed: Xm,
              ruluhar: oB,
              rx: sB,
              Sacute: MS,
              sacute: Jm,
              sbquo: lB,
              scap: uB,
              Scaron: sh,
              scaron: RS,
              Sc: DS,
              sc: cB,
              sccue: fB,
              sce: dB,
              scE: lh,
              Scedil: hB,
              scedil: pB,
              Scirc: Zm,
              scirc: vB,
              scnap: mB,
              scnE: PS,
              scnsim: gB,
              scpolint: su,
              scsim: LS,
              Scy: yB,
              scy: IS,
              sdotb: _S,
              sdot: bB,
              sdote: NS,
              searhk: SB,
              searr: wB,
              seArr: uh,
              searrow: BS,
              sect: FS,
              semi: xB,
              seswar: kB,
              setminus: OB,
              setmn: CB,
              sext: ch,
              Sfr: TB,
              sfr: AB,
              sfrown: Qm,
              sharp: EB,
              SHCHcy: MB,
              shchcy: RB,
              SHcy: DB,
              shcy: lu,
              ShortDownArrow: PB,
              ShortLeftArrow: fh,
              shortmid: uu,
              shortparallel: LB,
              ShortRightArrow: IB,
              ShortUpArrow: _B,
              shy: NB,
              Sigma: eg,
              sigma: zS,
              sigmaf: _a,
              sigmav: BB,
              sim: FB,
              simdot: zB,
              sime: HB,
              simeq: tg,
              simg: jB,
              simgE: WB,
              siml: rs,
              simlE: $B,
              simne: dh,
              simplus: ns,
              simrarr: UB,
              slarr: HS,
              SmallCircle: VB,
              smallsetminus: hh,
              smashp: GB,
              smeparsl: YB,
              smid: qB,
              smile: KB,
              smt: XB,
              smte: rg,
              smtes: JB,
              SOFTcy: ZB,
              softcy: QB,
              solbar: e2,
              solb: ng,
              sol: t2,
              Sopf: r2,
              sopf: ig,
              spades: n2,
              spadesuit: ph,
              spar: jS,
              sqcap: WS,
              sqcaps: $S,
              sqcup: ag,
              sqcups: vh,
              Sqrt: US,
              sqsub: i2,
              sqsube: mh,
              sqsubset: a2,
              sqsubseteq: o2,
              sqsup: s2,
              sqsupe: l2,
              sqsupset: og,
              sqsupseteq: u2,
              square: c2,
              Square: f2,
              SquareIntersection: d2,
              SquareSubset: sg,
              SquareSubsetEqual: h2,
              SquareSuperset: p2,
              SquareSupersetEqual: gh,
              SquareUnion: v2,
              squarf: yh,
              squ: bh,
              squf: Sh,
              srarr: VS,
              Sscr: m2,
              sscr: lg,
              ssetmn: wh,
              ssmile: GS,
              sstarf: YS,
              Star: g2,
              star: y2,
              starf: b2,
              straightepsilon: S2,
              straightphi: xh,
              strns: w2,
              sub: x2,
              Sub: ug,
              subdot: k2,
              subE: O2,
              sube: C2,
              subedot: T2,
              submult: cu,
              subnE: A2,
              subne: qS,
              subplus: E2,
              subrarr: M2,
              subset: R2,
              Subset: D2,
              subseteq: cg,
              subseteqq: P2,
              SubsetEqual: KS,
              subsetneq: L2,
              subsetneqq: I2,
              subsim: XS,
              subsub: _2,
              subsup: JS,
              succapprox: ZS,
              succ: QS,
              succcurlyeq: N2,
              Succeeds: B2,
              SucceedsEqual: F2,
              SucceedsSlantEqual: z2,
              SucceedsTilde: kh,
              succeq: ew,
              succnapprox: Kn,
              succneqq: H2,
              succnsim: j2,
              succsim: W2,
              SuchThat: $2,
              sum: U2,
              Sum: fg,
              sung: V2,
              sup1: G2,
              sup2: Y2,
              sup3: q2,
              sup: dg,
              Sup: K2,
              supdot: X2,
              supdsub: is,
              supE: J2,
              supe: Oh,
              supedot: as,
              Superset: Z2,
              SupersetEqual: Ch,
              suphsol: Q2,
              suphsub: eF,
              suplarr: tF,
              supmult: rF,
              supnE: hg,
              supne: nF,
              supplus: iF,
              supset: pg,
              Supset: aF,
              supseteq: Th,
              supseteqq: tw,
              supsetneq: oF,
              supsetneqq: Ah,
              supsim: rw,
              supsub: vg,
              supsup: sF,
              swarhk: lF,
              swarr: uF,
              swArr: cF,
              swarrow: Eh,
              swnwar: fF,
              szlig: dF,
              Tab: mg,
              target: hF,
              Tau: pF,
              tau: vF,
              tbrk: mF,
              Tcaron: fu,
              tcaron: gF,
              Tcedil: Mh,
              tcedil: nw,
              Tcy: yF,
              tcy: bF,
              tdot: SF,
              telrec: Rh,
              Tfr: wF,
              tfr: iw,
              there4: gg,
              therefore: xF,
              Therefore: kF,
              Theta: aw,
              theta: $r,
              thetasym: OF,
              thetav: CF,
              thickapprox: TF,
              thicksim: AF,
              ThickSpace: yg,
              ThinSpace: EF,
              thinsp: MF,
              thkap: no,
              thksim: RF,
              THORN: Dh,
              thorn: io,
              tilde: DF,
              Tilde: PF,
              TildeEqual: du,
              TildeFullEqual: LF,
              TildeTilde: ow,
              timesbar: hu,
              timesb: IF,
              times: _F,
              timesd: Ph,
              tint: sw,
              toea: lw,
              topbot: NF,
              topcir: BF,
              top: FF,
              Topf: zF,
              topf: Lh,
              topfork: HF,
              tosa: jF,
              tprime: bg,
              trade: WF,
              TRADE: $F,
              triangle: UF,
              triangledown: VF,
              triangleleft: pu,
              trianglelefteq: GF,
              triangleq: Ih,
              triangleright: uw,
              trianglerighteq: Xn,
              tridot: bc,
              trie: YF,
              triminus: qF,
              TripleDot: KF,
              triplus: XF,
              trisb: Sg,
              tritime: JF,
              trpezium: ZF,
              Tscr: QF,
              tscr: ez,
              TScy: wg,
              tscy: tz,
              TSHcy: rz,
              tshcy: Na,
              Tstrok: nz,
              tstrok: _h,
              twixt: Ba,
              twoheadleftarrow: iz,
              twoheadrightarrow: Nh,
              Uacute: cw,
              uacute: fw,
              uarr: az,
              Uarr: oz,
              uArr: sz,
              Uarrocir: lz,
              Ubrcy: Bh,
              ubrcy: uz,
              Ubreve: cz,
              ubreve: xg,
              Ucirc: fz,
              ucirc: dz,
              Ucy: hz,
              ucy: pz,
              udarr: vu,
              Udblac: vz,
              udblac: mz,
              udhar: gz,
              ufisht: yz,
              Ufr: bz,
              ufr: Sz,
              Ugrave: kg,
              ugrave: dw,
              uHar: Fh,
              uharl: wz,
              uharr: xz,
              uhblk: Og,
              ulcorn: hw,
              ulcorner: pw,
              ulcrop: kz,
              ultri: Oz,
              Umacr: vw,
              umacr: Cz,
              uml: Tz,
              UnderBar: Az,
              UnderBrace: Ez,
              UnderBracket: Mz,
              UnderParenthesis: zh,
              Union: Hh,
              UnionPlus: Rz,
              Uogon: Dz,
              uogon: Pz,
              Uopf: Lz,
              uopf: Cg,
              UpArrowBar: mw,
              uparrow: kn,
              UpArrow: Iz,
              Uparrow: _z,
              UpArrowDownArrow: Nz,
              updownarrow: Bz,
              UpDownArrow: Tg,
              Updownarrow: Fz,
              UpEquilibrium: zz,
              upharpoonleft: ao,
              upharpoonright: Hz,
              uplus: jh,
              UpperLeftArrow: oo,
              UpperRightArrow: jz,
              upsi: Wz,
              Upsi: $z,
              upsih: Uz,
              Upsilon: Wh,
              upsilon: gw,
              UpTeeArrow: yw,
              UpTee: Vz,
              upuparrows: Gz,
              urcorn: Yz,
              urcorner: qz,
              urcrop: $h,
              Uring: Kz,
              uring: Xz,
              urtri: Ag,
              Uscr: Jz,
              uscr: Zz,
              utdot: Qz,
              Utilde: eH,
              utilde: mu,
              utri: tH,
              utrif: rH,
              uuarr: Jn,
              Uuml: Pn,
              uuml: t,
              uwangle: n,
              vangrt: a,
              varepsilon: o,
              varkappa: u,
              varnothing: h,
              varphi: v,
              varpi: g,
              varpropto: b,
              varr: C,
              vArr: R,
              varrho: I,
              varsigma: W,
              varsubsetneq: Z,
              varsubsetneqq: ue,
              varsupsetneq: ke,
              varsupsetneqq: Ee,
              vartheta: Le,
              vartriangleleft: je,
              vartriangleright: Ke,
              vBar: ut,
              Vbar: bt,
              vBarv: mt,
              Vcy: Rt,
              vcy: Dt,
              vdash: Lt,
              vDash: Wt,
              Vdash: Qt,
              VDash: or,
              Vdashl: lr,
              veebar: xr,
              vee: br,
              Vee: yr,
              veeeq: Ar,
              vellip: qr,
              verbar: nn,
              Verbar: tn,
              vert: bn,
              Vert: Tn,
              VerticalBar: un,
              VerticalLine: Ln,
              VerticalSeparator: so,
              VerticalTilde: Ro,
              VeryThinSpace: Ds,
              Vfr: gu,
              vfr: nH,
              vltri: bw,
              vnsub: iH,
              vnsup: K9,
              Vopf: X9,
              vopf: J9,
              vprop: Z9,
              vrtri: Q9,
              Vscr: eG,
              vscr: tG,
              vsubnE: rG,
              vsubne: nG,
              vsupnE: iG,
              vsupne: aG,
              Vvdash: oG,
              vzigzag: sG,
              Wcirc: lG,
              wcirc: uG,
              wedbar: cG,
              wedge: fG,
              Wedge: dG,
              wedgeq: hG,
              weierp: pG,
              Wfr: vG,
              wfr: mG,
              Wopf: gG,
              wopf: yG,
              wp: bG,
              wr: SG,
              wreath: wG,
              Wscr: xG,
              wscr: kG,
              xcap: OG,
              xcirc: CG,
              xcup: TG,
              xdtri: AG,
              Xfr: EG,
              xfr: MG,
              xharr: RG,
              xhArr: DG,
              Xi: PG,
              xi: LG,
              xlarr: IG,
              xlArr: _G,
              xmap: NG,
              xnis: BG,
              xodot: FG,
              Xopf: zG,
              xopf: HG,
              xoplus: jG,
              xotime: WG,
              xrarr: $G,
              xrArr: UG,
              Xscr: VG,
              xscr: GG,
              xsqcup: YG,
              xuplus: qG,
              xutri: KG,
              xvee: XG,
              xwedge: JG,
              Yacute: ZG,
              yacute: QG,
              YAcy: e7,
              yacy: t7,
              Ycirc: r7,
              ycirc: n7,
              Ycy: i7,
              ycy: a7,
              yen: o7,
              Yfr: s7,
              yfr: l7,
              YIcy: u7,
              yicy: c7,
              Yopf: f7,
              yopf: d7,
              Yscr: h7,
              yscr: p7,
              YUcy: v7,
              yucy: m7,
              yuml: g7,
              Yuml: y7,
              Zacute: b7,
              zacute: S7,
              Zcaron: w7,
              zcaron: x7,
              Zcy: k7,
              zcy: O7,
              Zdot: C7,
              zdot: T7,
              zeetrf: A7,
              ZeroWidthSpace: E7,
              Zeta: M7,
              zeta: R7,
              zfr: D7,
              Zfr: P7,
              ZHcy: L7,
              zhcy: I7,
              zigrarr: _7,
              zopf: N7,
              Zopf: B7,
              Zscr: F7,
              zscr: z7,
              zwj: H7,
              zwnj: j7
            }, W7 = "Á", $7 = "á", U7 = "Â", V7 = "â", G7 = "´", Y7 = "Æ", q7 = "æ", K7 = "À", X7 = "à", J7 = "&", Z7 = "&", Q7 = "Å", eY = "å", tY = "Ã", rY = "ã", nY = "Ä", iY = "ä", aY = "¦", oY = "Ç", sY = "ç", lY = "¸", uY = "¢", cY = "©", fY = "©", dY = "¤", hY = "°", pY = "÷", vY = "É", mY = "é", gY = "Ê", yY = "ê", bY = "È", SY = "è", wY = "Ð", xY = "ð", kY = "Ë", OY = "ë", CY = "½", TY = "¼", AY = "¾", EY = ">", MY = ">", RY = "Í", DY = "í", PY = "Î", LY = "î", IY = "¡", _Y = "Ì", NY = "ì", BY = "¿", FY = "Ï", zY = "ï", HY = "«", jY = "<", WY = "<", $Y = "¯", UY = "µ", VY = "·", GY = " ", YY = "¬", qY = "Ñ", KY = "ñ", XY = "Ó", JY = "ó", ZY = "Ô", QY = "ô", eq = "Ò", tq = "ò", rq = "ª", nq = "º", iq = "Ø", aq = "ø", oq = "Õ", sq = "õ", lq = "Ö", uq = "ö", cq = "¶", fq = "±", dq = "£", hq = '"', pq = '"', vq = "»", mq = "®", gq = "®", yq = "§", bq = "­", Sq = "¹", wq = "²", xq = "³", kq = "ß", Oq = "Þ", Cq = "þ", Tq = "×", Aq = "Ú", Eq = "ú", Mq = "Û", Rq = "û", Dq = "Ù", Pq = "ù", Lq = "¨", Iq = "Ü", _q = "ü", Nq = "Ý", Bq = "ý", Fq = "¥", zq = "ÿ", Hq = {
              Aacute: W7,
              aacute: $7,
              Acirc: U7,
              acirc: V7,
              acute: G7,
              AElig: Y7,
              aelig: q7,
              Agrave: K7,
              agrave: X7,
              amp: J7,
              AMP: Z7,
              Aring: Q7,
              aring: eY,
              Atilde: tY,
              atilde: rY,
              Auml: nY,
              auml: iY,
              brvbar: aY,
              Ccedil: oY,
              ccedil: sY,
              cedil: lY,
              cent: uY,
              copy: cY,
              COPY: fY,
              curren: dY,
              deg: hY,
              divide: pY,
              Eacute: vY,
              eacute: mY,
              Ecirc: gY,
              ecirc: yY,
              Egrave: bY,
              egrave: SY,
              ETH: wY,
              eth: xY,
              Euml: kY,
              euml: OY,
              frac12: CY,
              frac14: TY,
              frac34: AY,
              gt: EY,
              GT: MY,
              Iacute: RY,
              iacute: DY,
              Icirc: PY,
              icirc: LY,
              iexcl: IY,
              Igrave: _Y,
              igrave: NY,
              iquest: BY,
              Iuml: FY,
              iuml: zY,
              laquo: HY,
              lt: jY,
              LT: WY,
              macr: $Y,
              micro: UY,
              middot: VY,
              nbsp: GY,
              not: YY,
              Ntilde: qY,
              ntilde: KY,
              Oacute: XY,
              oacute: JY,
              Ocirc: ZY,
              ocirc: QY,
              Ograve: eq,
              ograve: tq,
              ordf: rq,
              ordm: nq,
              Oslash: iq,
              oslash: aq,
              Otilde: oq,
              otilde: sq,
              Ouml: lq,
              ouml: uq,
              para: cq,
              plusmn: fq,
              pound: dq,
              quot: hq,
              QUOT: pq,
              raquo: vq,
              reg: mq,
              REG: gq,
              sect: yq,
              shy: bq,
              sup1: Sq,
              sup2: wq,
              sup3: xq,
              szlig: kq,
              THORN: Oq,
              thorn: Cq,
              times: Tq,
              Uacute: Aq,
              uacute: Eq,
              Ucirc: Mq,
              ucirc: Rq,
              Ugrave: Dq,
              ugrave: Pq,
              uml: Lq,
              Uuml: Iq,
              uuml: _q,
              Yacute: Nq,
              yacute: Bq,
              yen: Fq,
              yuml: zq
            }, jq = "&", Wq = "'", $q = ">", Uq = "<", Vq = '"', CW = {
              amp: jq,
              apos: Wq,
              gt: $q,
              lt: Uq,
              quot: Vq
            }, aH = {}, Gq = {
              0: 65533,
              128: 8364,
              130: 8218,
              131: 402,
              132: 8222,
              133: 8230,
              134: 8224,
              135: 8225,
              136: 710,
              137: 8240,
              138: 352,
              139: 8249,
              140: 338,
              142: 381,
              145: 8216,
              146: 8217,
              147: 8220,
              148: 8221,
              149: 8226,
              150: 8211,
              151: 8212,
              152: 732,
              153: 8482,
              154: 353,
              155: 8250,
              156: 339,
              158: 382,
              159: 376
            }, Yq = L && L.__importDefault || function(P) {
              return P && P.__esModule ? P : { default: P };
            };
            Object.defineProperty(aH, "__esModule", { value: !0 });
            var TW = Yq(Gq), qq = (
              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
              String.fromCodePoint || function(P) {
                var D = "";
                return P > 65535 && (P -= 65536, D += String.fromCharCode(P >>> 10 & 1023 | 55296), P = 56320 | P & 1023), D += String.fromCharCode(P), D;
              }
            );
            function Kq(P) {
              return P >= 55296 && P <= 57343 || P > 1114111 ? "�" : (P in TW.default && (P = TW.default[P]), qq(P));
            }
            aH.default = Kq;
            var Sw = L && L.__importDefault || function(P) {
              return P && P.__esModule ? P : { default: P };
            };
            Object.defineProperty(re, "__esModule", { value: !0 }), re.decodeHTML = re.decodeHTMLStrict = re.decodeXML = void 0;
            var oH = Sw(OW), Xq = Sw(Hq), Jq = Sw(CW), AW = Sw(aH), Zq = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
            re.decodeXML = EW(Jq.default), re.decodeHTMLStrict = EW(oH.default);
            function EW(P) {
              var D = RW(P);
              return function(F) {
                return String(F).replace(Zq, D);
              };
            }
            var MW = function(P, D) {
              return P < D ? 1 : -1;
            };
            re.decodeHTML = function() {
              for (var P = Object.keys(Xq.default).sort(MW), D = Object.keys(oH.default).sort(MW), F = 0, q = 0; F < D.length; F++)
                P[q] === D[F] ? (D[F] += ";?", q++) : D[F] += ";";
              var ye = new RegExp("&(?:" + D.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"), Fe = RW(oH.default);
              function Ze(dt) {
                return dt.substr(-1) !== ";" && (dt += ";"), Fe(dt);
              }
              return function(dt) {
                return String(dt).replace(ye, Ze);
              };
            }();
            function RW(P) {
              return function(F) {
                if (F.charAt(1) === "#") {
                  var q = F.charAt(2);
                  return q === "X" || q === "x" ? AW.default(parseInt(F.substr(3), 16)) : AW.default(parseInt(F.substr(2), 10));
                }
                return P[F.slice(1, -1)] || F;
              };
            }
            var lo = {}, DW = L && L.__importDefault || function(P) {
              return P && P.__esModule ? P : { default: P };
            };
            Object.defineProperty(lo, "__esModule", { value: !0 }), lo.escapeUTF8 = lo.escape = lo.encodeNonAsciiHTML = lo.encodeHTML = lo.encodeXML = void 0;
            var Qq = DW(CW), PW = IW(Qq.default), LW = _W(PW);
            lo.encodeXML = FW(PW);
            var eK = DW(OW), sH = IW(eK.default), tK = _W(sH);
            lo.encodeHTML = nK(sH, tK), lo.encodeNonAsciiHTML = FW(sH);
            function IW(P) {
              return Object.keys(P).sort().reduce(function(D, F) {
                return D[P[F]] = "&" + F + ";", D;
              }, {});
            }
            function _W(P) {
              for (var D = [], F = [], q = 0, ye = Object.keys(P); q < ye.length; q++) {
                var Fe = ye[q];
                Fe.length === 1 ? D.push("\\" + Fe) : F.push(Fe);
              }
              D.sort();
              for (var Ze = 0; Ze < D.length - 1; Ze++) {
                for (var dt = Ze; dt < D.length - 1 && D[dt].charCodeAt(1) + 1 === D[dt + 1].charCodeAt(1); )
                  dt += 1;
                var Bt = 1 + dt - Ze;
                Bt < 3 || D.splice(Ze, Bt, D[Ze] + "-" + D[dt]);
              }
              return F.unshift("[" + D.join("") + "]"), new RegExp(F.join("|"), "g");
            }
            var NW = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g, rK = (
              // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
              String.prototype.codePointAt != null ? (
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                function(P) {
                  return P.codePointAt(0);
                }
              ) : (
                // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                function(P) {
                  return (P.charCodeAt(0) - 55296) * 1024 + P.charCodeAt(1) - 56320 + 65536;
                }
              )
            );
            function ww(P) {
              return "&#x" + (P.length > 1 ? rK(P) : P.charCodeAt(0)).toString(16).toUpperCase() + ";";
            }
            function nK(P, D) {
              return function(F) {
                return F.replace(D, function(q) {
                  return P[q];
                }).replace(NW, ww);
              };
            }
            var BW = new RegExp(LW.source + "|" + NW.source, "g");
            function iK(P) {
              return P.replace(BW, ww);
            }
            lo.escape = iK;
            function aK(P) {
              return P.replace(LW, ww);
            }
            lo.escapeUTF8 = aK;
            function FW(P) {
              return function(D) {
                return D.replace(BW, function(F) {
                  return P[F] || ww(F);
                });
              };
            }
            (function(P) {
              Object.defineProperty(P, "__esModule", { value: !0 }), P.decodeXMLStrict = P.decodeHTML5Strict = P.decodeHTML4Strict = P.decodeHTML5 = P.decodeHTML4 = P.decodeHTMLStrict = P.decodeHTML = P.decodeXML = P.encodeHTML5 = P.encodeHTML4 = P.escapeUTF8 = P.escape = P.encodeNonAsciiHTML = P.encodeHTML = P.encodeXML = P.encode = P.decodeStrict = P.decode = void 0;
              var D = re, F = lo;
              function q(Bt, Ut) {
                return (!Ut || Ut <= 0 ? D.decodeXML : D.decodeHTML)(Bt);
              }
              P.decode = q;
              function ye(Bt, Ut) {
                return (!Ut || Ut <= 0 ? D.decodeXML : D.decodeHTMLStrict)(Bt);
              }
              P.decodeStrict = ye;
              function Fe(Bt, Ut) {
                return (!Ut || Ut <= 0 ? F.encodeXML : F.encodeHTML)(Bt);
              }
              P.encode = Fe;
              var Ze = lo;
              Object.defineProperty(P, "encodeXML", { enumerable: !0, get: function() {
                return Ze.encodeXML;
              } }), Object.defineProperty(P, "encodeHTML", { enumerable: !0, get: function() {
                return Ze.encodeHTML;
              } }), Object.defineProperty(P, "encodeNonAsciiHTML", { enumerable: !0, get: function() {
                return Ze.encodeNonAsciiHTML;
              } }), Object.defineProperty(P, "escape", { enumerable: !0, get: function() {
                return Ze.escape;
              } }), Object.defineProperty(P, "escapeUTF8", { enumerable: !0, get: function() {
                return Ze.escapeUTF8;
              } }), Object.defineProperty(P, "encodeHTML4", { enumerable: !0, get: function() {
                return Ze.encodeHTML;
              } }), Object.defineProperty(P, "encodeHTML5", { enumerable: !0, get: function() {
                return Ze.encodeHTML;
              } });
              var dt = re;
              Object.defineProperty(P, "decodeXML", { enumerable: !0, get: function() {
                return dt.decodeXML;
              } }), Object.defineProperty(P, "decodeHTML", { enumerable: !0, get: function() {
                return dt.decodeHTML;
              } }), Object.defineProperty(P, "decodeHTMLStrict", { enumerable: !0, get: function() {
                return dt.decodeHTMLStrict;
              } }), Object.defineProperty(P, "decodeHTML4", { enumerable: !0, get: function() {
                return dt.decodeHTML;
              } }), Object.defineProperty(P, "decodeHTML5", { enumerable: !0, get: function() {
                return dt.decodeHTML;
              } }), Object.defineProperty(P, "decodeHTML4Strict", { enumerable: !0, get: function() {
                return dt.decodeHTMLStrict;
              } }), Object.defineProperty(P, "decodeHTML5Strict", { enumerable: !0, get: function() {
                return dt.decodeHTMLStrict;
              } }), Object.defineProperty(P, "decodeXMLStrict", { enumerable: !0, get: function() {
                return dt.decodeXML;
              } });
            })(K);
            var zW = "&(?:#x[a-f0-9]{1,6}|#[0-9]{1,7}|[a-z][a-z0-9]{1,31});", oK = 92, sK = /[\\&]/, lH = "[!\"#$%&'()*+,./:;<=>?@[\\\\\\]^_`{|}~-]", lK = new RegExp("\\\\" + lH + "|" + zW, "gi"), uK = '[&<>"]', HW = new RegExp(uK, "g"), cK = function(P) {
              return P.charCodeAt(0) === oK ? P.charAt(1) : K.decodeHTML(P);
            };
            function Eg(P) {
              return sK.test(P) ? P.replace(lK, cK) : P;
            }
            function xw(P) {
              try {
                return ie(P);
              } catch {
                return P;
              }
            }
            function fK(P) {
              switch (P) {
                case "&":
                  return "&amp;";
                case "<":
                  return "&lt;";
                case ">":
                  return "&gt;";
                case '"':
                  return "&quot;";
                default:
                  return P;
              }
            }
            function Uh(P) {
              return HW.test(P) ? P.replace(HW, fK) : P;
            }
            function uH(P, D) {
              for (var F = [], q = 0; q < D; q++)
                F.push(P);
              return F.join("");
            }
            function jW(P) {
              return P ? !/[^ \t]+/.test(P) : !0;
            }
            var dK = (
              /** @class */
              function() {
                function P(D) {
                  this.current = D, this.root = D, this.entering = !0;
                }
                return P.prototype.next = function() {
                  var D = this.current, F = this.entering;
                  if (D === null)
                    return null;
                  var q = cH(D);
                  return F && q ? D.firstChild ? (this.current = D.firstChild, this.entering = !0) : this.entering = !1 : D === this.root ? this.current = null : D.next === null ? (this.current = D.parent, this.entering = !1) : (this.current = D.next, this.entering = !0), { entering: F, node: D };
                }, P.prototype.resumeAt = function(D, F) {
                  this.current = D, this.entering = F === !0;
                }, P;
              }()
            );
            function cH(P) {
              switch (P.type) {
                case "document":
                case "blockQuote":
                case "list":
                case "item":
                case "paragraph":
                case "heading":
                case "emph":
                case "strong":
                case "strike":
                case "link":
                case "image":
                case "table":
                case "tableHead":
                case "tableBody":
                case "tableRow":
                case "tableCell":
                case "tableDelimRow":
                case "customInline":
                  return !0;
                default:
                  return !1;
              }
            }
            var hK = 1, kw = {};
            function pK(P) {
              return kw[P];
            }
            function fH(P) {
              delete kw[P];
            }
            function vK() {
              kw = {};
            }
            var Mg = (
              /** @class */
              function() {
                function P(D, F) {
                  this.parent = null, this.prev = null, this.next = null, this.firstChild = null, this.lastChild = null, this.literal = null, D === "document" ? this.id = -1 : this.id = hK++, this.type = D, this.sourcepos = F, kw[this.id] = this;
                }
                return P.prototype.isContainer = function() {
                  return cH(this);
                }, P.prototype.unlink = function() {
                  this.prev ? this.prev.next = this.next : this.parent && (this.parent.firstChild = this.next), this.next ? this.next.prev = this.prev : this.parent && (this.parent.lastChild = this.prev), this.parent = null, this.next = null, this.prev = null;
                }, P.prototype.replaceWith = function(D) {
                  this.insertBefore(D), this.unlink();
                }, P.prototype.insertAfter = function(D) {
                  D.unlink(), D.next = this.next, D.next && (D.next.prev = D), D.prev = this, this.next = D, this.parent && (D.parent = this.parent, D.next || (D.parent.lastChild = D));
                }, P.prototype.insertBefore = function(D) {
                  D.unlink(), D.prev = this.prev, D.prev && (D.prev.next = D), D.next = this, this.prev = D, D.parent = this.parent, D.prev || (D.parent.firstChild = D);
                }, P.prototype.appendChild = function(D) {
                  D.unlink(), D.parent = this, this.lastChild ? (this.lastChild.next = D, D.prev = this.lastChild, this.lastChild = D) : (this.firstChild = D, this.lastChild = D);
                }, P.prototype.prependChild = function(D) {
                  D.unlink(), D.parent = this, this.firstChild ? (this.firstChild.prev = D, D.next = this.firstChild, this.firstChild = D) : (this.firstChild = D, this.lastChild = D);
                }, P.prototype.walker = function() {
                  return new dK(this);
                }, P;
              }()
            ), ll = (
              /** @class */
              function(P) {
                k(D, P);
                function D(F, q) {
                  var ye = P.call(this, F, q) || this;
                  return ye.open = !0, ye.lineOffsets = null, ye.stringContent = null, ye.lastLineBlank = !1, ye.lastLineChecked = !1, ye.type = F, ye;
                }
                return D;
              }(Mg)
            ), mK = (
              /** @class */
              function(P) {
                k(D, P);
                function D() {
                  var F = P !== null && P.apply(this, arguments) || this;
                  return F.listData = null, F;
                }
                return D;
              }(ll)
            ), gK = (
              /** @class */
              function(P) {
                k(D, P);
                function D() {
                  var F = P !== null && P.apply(this, arguments) || this;
                  return F.level = 0, F.headingType = "atx", F;
                }
                return D;
              }(ll)
            ), yK = (
              /** @class */
              function(P) {
                k(D, P);
                function D() {
                  var F = P !== null && P.apply(this, arguments) || this;
                  return F.isFenced = !1, F.fenceChar = null, F.fenceLength = 0, F.fenceOffset = -1, F.info = null, F.infoPadding = 0, F;
                }
                return D;
              }(ll)
            ), bK = (
              /** @class */
              function(P) {
                k(D, P);
                function D() {
                  var F = P !== null && P.apply(this, arguments) || this;
                  return F.columns = [], F;
                }
                return D;
              }(ll)
            ), SK = (
              /** @class */
              function(P) {
                k(D, P);
                function D() {
                  var F = P !== null && P.apply(this, arguments) || this;
                  return F.startIdx = 0, F.endIdx = 0, F.paddingLeft = 0, F.paddingRight = 0, F.ignored = !1, F;
                }
                return D;
              }(ll)
            ), wK = (
              /** @class */
              function(P) {
                k(D, P);
                function D() {
                  var F = P !== null && P.apply(this, arguments) || this;
                  return F.title = "", F.dest = "", F.label = "", F;
                }
                return D;
              }(ll)
            ), xK = (
              /** @class */
              function(P) {
                k(D, P);
                function D() {
                  var F = P !== null && P.apply(this, arguments) || this;
                  return F.syntaxLength = 0, F.offset = -1, F.info = "", F;
                }
                return D;
              }(ll)
            ), kK = (
              /** @class */
              function(P) {
                k(D, P);
                function D() {
                  var F = P !== null && P.apply(this, arguments) || this;
                  return F.htmlBlockType = -1, F;
                }
                return D;
              }(ll)
            ), OK = (
              /** @class */
              function(P) {
                k(D, P);
                function D() {
                  var F = P !== null && P.apply(this, arguments) || this;
                  return F.destination = null, F.title = null, F.extendedAutolink = !1, F;
                }
                return D;
              }(Mg)
            ), CK = (
              /** @class */
              function(P) {
                k(D, P);
                function D() {
                  var F = P !== null && P.apply(this, arguments) || this;
                  return F.tickCount = 0, F;
                }
                return D;
              }(Mg)
            ), TK = (
              /** @class */
              function(P) {
                k(D, P);
                function D() {
                  var F = P !== null && P.apply(this, arguments) || this;
                  return F.info = "", F;
                }
                return D;
              }(Mg)
            );
            function In(P, D) {
              switch (P) {
                case "heading":
                  return new gK(P, D);
                case "list":
                case "item":
                  return new mK(P, D);
                case "link":
                case "image":
                  return new OK(P, D);
                case "codeBlock":
                  return new yK(P, D);
                case "htmlBlock":
                  return new kK(P, D);
                case "table":
                  return new bK(P, D);
                case "tableCell":
                  return new SK(P, D);
                case "document":
                case "paragraph":
                case "blockQuote":
                case "thematicBreak":
                case "tableRow":
                case "tableBody":
                case "tableHead":
                case "frontMatter":
                  return new ll(P, D);
                case "code":
                  return new CK(P, D);
                case "refDef":
                  return new wK(P, D);
                case "customBlock":
                  return new xK(P, D);
                case "customInline":
                  return new TK(P, D);
                default:
                  return new Mg(P, D);
              }
            }
            function WW(P) {
              return P.type === "codeBlock";
            }
            function AK(P) {
              return P.type === "htmlBlock";
            }
            function EK(P) {
              return P.type === "heading";
            }
            function $W(P) {
              return P.type === "list";
            }
            function MK(P) {
              return P.type === "table";
            }
            function Vh(P) {
              return P.type === "refDef";
            }
            function UW(P) {
              return P.type === "customBlock";
            }
            function RK(P) {
              return P.type === "customInline";
            }
            function li(P, D) {
              var F = In("text", D);
              return F.literal = P, F;
            }
            var VW = "[A-Za-z][A-Za-z0-9-]*", DK = "[a-zA-Z_:][a-zA-Z0-9:._-]*", PK = "[^\"'=<>`\\x00-\\x20]+", LK = "'[^']*'", IK = '"[^"]*"', _K = "(?:" + PK + "|" + LK + "|" + IK + ")", NK = "(?:\\s*=\\s*" + _K + ")", BK = "(?:\\s+" + DK + NK + "?)", GW = "<" + VW + BK + "*\\s*/?>", YW = "</" + VW + "\\s*[>]", FK = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->", zK = "[<][?].*?[?][>]", HK = "<![A-Z]+\\s+[^>]*>", jK = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", WK = "(?:" + GW + "|" + YW + "|" + FK + "|" + zK + "|" + HK + "|" + jK + ")", $K = new RegExp("^" + WK, "i");
            /*! http://mths.be/fromcodepoint v0.2.1 by @mathias */
            var dH;
            if (String.fromCodePoint)
              dH = function(P) {
                try {
                  return String.fromCodePoint(P);
                } catch (D) {
                  if (D instanceof RangeError)
                    return "�";
                  throw D;
                }
              };
            else {
              var UK = String.fromCharCode, VK = Math.floor;
              dH = function() {
                for (var P = [], D = 0; D < arguments.length; D++)
                  P[D] = arguments[D];
                var F = 16384, q = [], ye, Fe, Ze = -1, dt = P.length;
                if (!dt)
                  return "";
                for (var Bt = ""; ++Ze < dt; ) {
                  var Ut = Number(P[Ze]);
                  if (!isFinite(Ut) || // `NaN`, `+Infinity`, or `-Infinity`
                  Ut < 0 || // not a valid Unicode code point
                  Ut > 1114111 || // not a valid Unicode code point
                  VK(Ut) !== Ut)
                    return "�";
                  Ut <= 65535 ? q.push(Ut) : (Ut -= 65536, ye = (Ut >> 10) + 55296, Fe = Ut % 1024 + 56320, q.push(ye, Fe)), (Ze + 1 === dt || q.length > F) && (Bt += UK.apply(void 0, q), q.length = 0);
                }
                return Bt;
              };
            }
            var hH = dH, GK = "(?:[w-]+.)*[A-Za-z0-9-]+.[A-Za-z0-9-]+", YK = "[^<\\s]*[^<?!.,:*_?~\\s]", qK = "[\\w.+-]+@(?:[\\w-]+\\.)+[\\w-]+";
            function KK(P) {
              var D = /\)+$/.exec(P);
              if (D) {
                for (var F = 0, q = 0, ye = P; q < ye.length; q++) {
                  var Fe = ye[q];
                  Fe === "(" ? F < 0 ? F = 1 : F += 1 : Fe === ")" && (F -= 1);
                }
                if (F < 0) {
                  var Ze = Math.min(-F, D[0].length);
                  return P.substring(0, P.length - Ze);
                }
              }
              return P;
            }
            function XK(P) {
              return P.replace(/&[A-Za-z0-9]+;$/, "");
            }
            function JK(P) {
              for (var D = new RegExp(qK, "g"), F = [], q; q = D.exec(P); ) {
                var ye = q[0];
                /[_-]+$/.test(ye) || F.push({
                  text: ye,
                  range: [q.index, q.index + ye.length - 1],
                  url: "mailto:" + ye
                });
              }
              return F;
            }
            function ZK(P) {
              for (var D = new RegExp("(www|https?://)." + GK + YK, "g"), F = [], q; q = D.exec(P); ) {
                var ye = XK(KK(q[0])), Fe = q[1] === "www" ? "http://" : "";
                F.push({
                  text: ye,
                  range: [q.index, q.index + ye.length - 1],
                  url: "" + Fe + ye
                });
              }
              return F;
            }
            function QK(P) {
              return T(T([], ZK(P)), JK(P)).sort(function(D, F) {
                return D.range[0] - F.range[0];
              });
            }
            function eX(P, D) {
              typeof D == "boolean" && (D = QK);
              for (var F, q = function() {
                var ye = F.entering, Fe = F.node;
                if (ye && Fe.type === "text" && Fe.parent.type !== "link") {
                  var Ze = Fe.literal, dt = D(Ze);
                  if (!dt || !dt.length)
                    return "continue";
                  for (var Bt = 0, Ut = Fe.sourcepos[0], sr = Ut[0], fr = Ut[1], ar = function(dl, cQ) {
                    return [
                      [sr, fr + dl],
                      [sr, fr + cQ]
                    ];
                  }, wr = [], Sr = 0, Jr = dt; Sr < Jr.length; Sr++) {
                    var _n = Jr[Sr], pi = _n.range, ul = _n.url, Do = _n.text;
                    pi[0] > Bt && wr.push(li(Ze.substring(Bt, pi[0]), ar(Bt, pi[0] - 1)));
                    var co = In("link", ar.apply(void 0, pi));
                    co.appendChild(li(Do, ar.apply(void 0, pi))), co.destination = ul, co.extendedAutolink = !0, wr.push(co), Bt = pi[1] + 1;
                  }
                  Bt < Ze.length && wr.push(li(Ze.substring(Bt), ar(Bt, Ze.length - 1)));
                  for (var ss = 0, cl = wr; ss < cl.length; ss++) {
                    var fl = cl[ss];
                    Fe.insertBefore(fl);
                  }
                  Fe.unlink();
                }
              }; F = P.next(); )
                q();
            }
            function Ow(P) {
              return P[P.length - 1];
            }
            function qW(P) {
              return P.slice(1, P.length - 1).trim().replace(/[ \t\r\n]+/, " ").toLowerCase().toUpperCase();
            }
            function Cw(P, D) {
              Object.keys(P).forEach(function(F) {
                D(F, P[F]);
              });
            }
            function tX(P) {
              for (var D = [], F = 1; F < arguments.length; F++)
                D[F - 1] = arguments[F];
              var q = O({}, P);
              return D.forEach(function(ye) {
                delete q[ye];
              }), q;
            }
            function Gh(P) {
              return !Object.keys(P).length;
            }
            function rX(P) {
              Object.keys(P).forEach(function(D) {
                delete P[D];
              });
            }
            var pH = 10, vH = 42, Tw = 95, nX = 96, KW = 91, iX = 93, Aw = 126, XW = 60, aX = 33, JW = 92, oX = 38, ZW = 40, mH = 41, sX = 58, Sc = 39, wc = 34, xc = 36, gH = "\\\\" + lH, QW = new RegExp(/[!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/), lX = new RegExp('^(?:"(' + gH + '|[^"\\x00])*"|' + ("'(" + gH + "|[^'\\x00])*'") + "|" + ("\\((" + gH + "|[^()\\x00])*\\))")), uX = /^(?:<(?:[^<>\n\\\x00]|\\.)*>)/, e$ = new RegExp("^" + lH), cX = new RegExp("^" + zW, "i"), fX = /`+/, dX = /^`+/, hX = /\.\.\./g, pX = /--+/g, vX = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/, mX = /^<[A-Za-z][A-Za-z0-9.+-]{1,31}:[^<>\x00-\x20]*>/i, gX = /^ *(?:\n *)?/, yH = /^[ \t\n\x0b\x0c\x0d]/, t$ = /^\s/, yX = / *$/, bX = /^ */, r$ = /^ *(?:\n|$)/, SX = /^\[(?:[^\\\[\]]|\\.){0,1000}\]/, wX = /^[^\n`\[\]\\!<&*_'"~$]+/m, xX = (
              /** @class */
              function() {
                function P(D) {
                  this.subject = "", this.delimiters = null, this.brackets = null, this.pos = 0, this.lineStartNum = 0, this.lineIdx = 0, this.lineOffsets = [0], this.linePosOffset = 0, this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.options = D;
                }
                return P.prototype.sourcepos = function(D, F) {
                  var q = this.linePosOffset + this.lineOffsets[this.lineIdx], ye = this.lineStartNum + this.lineIdx, Fe = [ye, D + q];
                  return typeof F == "number" ? [Fe, [ye, F + q]] : Fe;
                }, P.prototype.nextLine = function() {
                  this.lineIdx += 1, this.linePosOffset = -this.pos;
                }, P.prototype.match = function(D) {
                  var F = D.exec(this.subject.slice(this.pos));
                  return F === null ? null : (this.pos += F.index + F[0].length, F[0]);
                }, P.prototype.peek = function() {
                  return this.pos < this.subject.length ? this.subject.charCodeAt(this.pos) : -1;
                }, P.prototype.spnl = function() {
                  return this.match(gX), !0;
                }, P.prototype.parseBackticks = function(D) {
                  var F = this.pos + 1, q = this.match(dX);
                  if (q === null)
                    return !1;
                  for (var ye = this.pos, Fe; (Fe = this.match(fX)) !== null; )
                    if (Fe === q) {
                      var Ze = this.subject.slice(ye, this.pos - q.length), dt = this.sourcepos(F, this.pos), Bt = Ze.split(`
`);
                      if (Bt.length > 1) {
                        var Ut = Ow(Bt);
                        this.lineIdx += Bt.length - 1, this.linePosOffset = -(this.pos - Ut.length - q.length), dt[1] = this.sourcepos(this.pos), Ze = Bt.join(" ");
                      }
                      var sr = In("code", dt);
                      return Ze.length > 0 && Ze.match(/[^ ]/) !== null && Ze[0] == " " && Ze[Ze.length - 1] == " " ? sr.literal = Ze.slice(1, Ze.length - 1) : sr.literal = Ze, sr.tickCount = q.length, D.appendChild(sr), !0;
                    }
                  return this.pos = ye, D.appendChild(li(q, this.sourcepos(F, this.pos - 1))), !0;
                }, P.prototype.parseBackslash = function(D) {
                  var F = this.subject, q;
                  this.pos += 1;
                  var ye = this.pos;
                  return this.peek() === pH ? (this.pos += 1, q = In("linebreak", this.sourcepos(this.pos - 1, this.pos)), D.appendChild(q), this.nextLine()) : e$.test(F.charAt(this.pos)) ? (D.appendChild(li(F.charAt(this.pos), this.sourcepos(ye, this.pos))), this.pos += 1) : D.appendChild(li("\\", this.sourcepos(ye, ye))), !0;
                }, P.prototype.parseAutolink = function(D) {
                  var F, q, ye, Fe = this.pos + 1;
                  return (F = this.match(vX)) ? (q = F.slice(1, F.length - 1), ye = In("link", this.sourcepos(Fe, this.pos)), ye.destination = xw("mailto:" + q), ye.title = "", ye.appendChild(li(q, this.sourcepos(Fe + 1, this.pos - 1))), D.appendChild(ye), !0) : (F = this.match(mX)) ? (q = F.slice(1, F.length - 1), ye = In("link", this.sourcepos(Fe, this.pos)), ye.destination = xw(q), ye.title = "", ye.appendChild(li(q, this.sourcepos(Fe + 1, this.pos - 1))), D.appendChild(ye), !0) : !1;
                }, P.prototype.parseHtmlTag = function(D) {
                  var F = this.pos + 1, q = this.match($K);
                  if (q === null)
                    return !1;
                  var ye = In("htmlInline", this.sourcepos(F, this.pos));
                  return ye.literal = q, D.appendChild(ye), !0;
                }, P.prototype.scanDelims = function(D) {
                  var F = 0, q = this.pos;
                  if (D === Sc || D === wc)
                    F++, this.pos++;
                  else
                    for (; this.peek() === D; )
                      F++, this.pos++;
                  if (F === 0 || F < 2 && (D === Aw || D === xc))
                    return this.pos = q, null;
                  var ye = q === 0 ? `
` : this.subject.charAt(q - 1), Fe = this.peek(), Ze;
                  Fe === -1 ? Ze = `
` : Ze = hH(Fe);
                  var dt = t$.test(Ze), Bt = QW.test(Ze), Ut = t$.test(ye), sr = QW.test(ye), fr = !dt && (!Bt || Ut || sr), ar = !Ut && (!sr || dt || Bt), wr, Sr;
                  return D === Tw ? (wr = fr && (!ar || sr), Sr = ar && (!fr || Bt)) : D === Sc || D === wc ? (wr = fr && !ar, Sr = ar) : D === xc ? (wr = !dt, Sr = !Ut) : (wr = fr, Sr = ar), this.pos = q, { numdelims: F, canOpen: wr, canClose: Sr };
                }, P.prototype.handleDelim = function(D, F) {
                  var q = this.scanDelims(D);
                  if (!q)
                    return !1;
                  var ye = q.numdelims, Fe = this.pos + 1, Ze;
                  this.pos += ye, D === Sc ? Ze = "’" : D === wc ? Ze = "“" : Ze = this.subject.slice(Fe - 1, this.pos);
                  var dt = li(Ze, this.sourcepos(Fe, this.pos));
                  return F.appendChild(dt), (q.canOpen || q.canClose) && (this.options.smart || D !== Sc && D !== wc) && (this.delimiters = {
                    cc: D,
                    numdelims: ye,
                    origdelims: ye,
                    node: dt,
                    previous: this.delimiters,
                    next: null,
                    canOpen: q.canOpen,
                    canClose: q.canClose
                  }, this.delimiters.previous && (this.delimiters.previous.next = this.delimiters)), !0;
                }, P.prototype.removeDelimiter = function(D) {
                  D.previous !== null && (D.previous.next = D.next), D.next === null ? this.delimiters = D.previous : D.next.previous = D.previous;
                }, P.prototype.removeDelimitersBetween = function(D, F) {
                  D.next !== F && (D.next = F, F.previous = D);
                }, P.prototype.processEmphasis = function(D) {
                  var F, q, ye, Fe, Ze, dt, Bt, Ut = !1, sr = (F = {}, F[Tw] = [D, D, D], F[vH] = [D, D, D], F[Sc] = [D], F[wc] = [D], F[Aw] = [D], F[xc] = [D], F);
                  for (ye = this.delimiters; ye !== null && ye.previous !== D; )
                    ye = ye.previous;
                  for (; ye !== null; ) {
                    var fr = ye.cc, ar = fr === Tw || fr === vH;
                    if (!ye.canClose)
                      ye = ye.next;
                    else {
                      for (q = ye.previous, Bt = !1; q !== null && q !== D && q !== sr[fr][ar ? ye.origdelims % 3 : 0]; ) {
                        if (Ut = ar && (ye.canOpen || q.canClose) && ye.origdelims % 3 !== 0 && (q.origdelims + ye.origdelims) % 3 === 0, q.cc === ye.cc && q.canOpen && !Ut) {
                          Bt = !0;
                          break;
                        }
                        q = q.previous;
                      }
                      if (Fe = ye, ar || fr === Aw || fr === xc) {
                        if (!Bt)
                          ye = ye.next;
                        else if (q) {
                          var wr = ye.numdelims >= 2 && q.numdelims >= 2 ? 2 : 1, Sr = ar ? 0 : 1;
                          Ze = q.node, dt = ye.node;
                          var Jr = ar ? wr === 1 ? "emph" : "strong" : "strike";
                          fr === xc && (Jr = "customInline");
                          var _n = In(Jr), pi = Ze.sourcepos[1], ul = dt.sourcepos[0];
                          _n.sourcepos = [
                            [pi[0], pi[1] - wr + 1],
                            [ul[0], ul[1] + wr - 1]
                          ], Ze.sourcepos[1][1] -= wr, dt.sourcepos[0][1] += wr, Ze.literal = Ze.literal.slice(wr), dt.literal = dt.literal.slice(wr), q.numdelims -= wr, ye.numdelims -= wr;
                          for (var Do = Ze.next, co = void 0; Do && Do !== dt; )
                            co = Do.next, Do.unlink(), _n.appendChild(Do), Do = co;
                          if (fr === xc) {
                            var ss = _n.firstChild, cl = ss.literal || "", fl = cl.split(/\s/)[0];
                            _n.info = fl, cl.length <= fl.length ? ss.unlink() : (ss.sourcepos[0][1] += fl.length, ss.literal = cl.replace(fl + " ", ""));
                          }
                          if (Ze.insertAfter(_n), this.removeDelimitersBetween(q, ye), q.numdelims <= Sr && (q.numdelims === 0 && Ze.unlink(), this.removeDelimiter(q)), ye.numdelims <= Sr) {
                            ye.numdelims === 0 && dt.unlink();
                            var dl = ye.next;
                            this.removeDelimiter(ye), ye = dl;
                          }
                        }
                      } else fr === Sc ? (ye.node.literal = "’", Bt && (q.node.literal = "‘"), ye = ye.next) : fr === wc && (ye.node.literal = "”", Bt && (q.node.literal = "“"), ye = ye.next);
                      Bt || (sr[fr][ar ? Fe.origdelims % 3 : 0] = Fe.previous, Fe.canOpen || this.removeDelimiter(Fe));
                    }
                  }
                  for (; this.delimiters !== null && this.delimiters !== D; )
                    this.removeDelimiter(this.delimiters);
                }, P.prototype.parseLinkTitle = function() {
                  var D = this.match(lX);
                  return D === null ? null : Eg(D.substr(1, D.length - 2));
                }, P.prototype.parseLinkDestination = function() {
                  var D = this.match(uX);
                  if (D === null) {
                    if (this.peek() === XW)
                      return null;
                    for (var F = this.pos, q = 0, ye = void 0; (ye = this.peek()) !== -1; )
                      if (ye === JW && e$.test(this.subject.charAt(this.pos + 1)))
                        this.pos += 1, this.peek() !== -1 && (this.pos += 1);
                      else if (ye === ZW)
                        this.pos += 1, q += 1;
                      else if (ye === mH) {
                        if (q < 1)
                          break;
                        this.pos += 1, q -= 1;
                      } else {
                        if (yH.exec(hH(ye)) !== null)
                          break;
                        this.pos += 1;
                      }
                    return this.pos === F && ye !== mH || q !== 0 ? null : (D = this.subject.substr(F, this.pos - F), xw(Eg(D)));
                  }
                  return xw(Eg(D.substr(1, D.length - 2)));
                }, P.prototype.parseLinkLabel = function() {
                  var D = this.match(SX);
                  return D === null || D.length > 1001 ? 0 : D.length;
                }, P.prototype.parseOpenBracket = function(D) {
                  var F = this.pos;
                  this.pos += 1;
                  var q = li("[", this.sourcepos(this.pos, this.pos));
                  return D.appendChild(q), this.addBracket(q, F, !1), !0;
                }, P.prototype.parseBang = function(D) {
                  var F = this.pos;
                  if (this.pos += 1, this.peek() === KW) {
                    this.pos += 1;
                    var q = li("![", this.sourcepos(this.pos - 1, this.pos));
                    D.appendChild(q), this.addBracket(q, F + 1, !0);
                  } else {
                    var q = li("!", this.sourcepos(this.pos, this.pos));
                    D.appendChild(q);
                  }
                  return !0;
                }, P.prototype.parseCloseBracket = function(D) {
                  var F = null, q = null, ye = !1;
                  this.pos += 1;
                  var Fe = this.pos, Ze = this.brackets;
                  if (Ze === null)
                    return D.appendChild(li("]", this.sourcepos(Fe, Fe))), !0;
                  if (!Ze.active)
                    return D.appendChild(li("]", this.sourcepos(Fe, Fe))), this.removeBracket(), !0;
                  var dt = Ze.image, Bt = this.pos;
                  this.peek() === ZW && (this.pos++, this.spnl() && (F = this.parseLinkDestination()) !== null && this.spnl() && // make sure there's a space before the title:
                  (yH.test(this.subject.charAt(this.pos - 1)) && (q = this.parseLinkTitle()) || !0) && this.spnl() && this.peek() === mH ? (this.pos += 1, ye = !0) : this.pos = Bt);
                  var Ut = "";
                  if (!ye) {
                    var sr = this.pos, fr = this.parseLinkLabel();
                    if (fr > 2 ? Ut = this.subject.slice(sr, sr + fr) : Ze.bracketAfter || (Ut = this.subject.slice(Ze.index, Fe)), fr === 0 && (this.pos = Bt), Ut) {
                      Ut = qW(Ut);
                      var ar = this.refMap[Ut];
                      ar && (F = ar.destination, q = ar.title, ye = !0);
                    }
                  }
                  if (ye) {
                    var wr = In(dt ? "image" : "link");
                    wr.destination = F, wr.title = q || "", wr.sourcepos = [Ze.startpos, this.sourcepos(this.pos)];
                    for (var Sr = Ze.node.next, Jr = void 0; Sr; )
                      Jr = Sr.next, Sr.unlink(), wr.appendChild(Sr), Sr = Jr;
                    if (D.appendChild(wr), this.processEmphasis(Ze.previousDelimiter), this.removeBracket(), Ze.node.unlink(), !dt)
                      for (Ze = this.brackets; Ze !== null; )
                        Ze.image || (Ze.active = !1), Ze = Ze.previous;
                    return this.options.referenceDefinition && (this.refLinkCandidateMap[D.id] = { node: D, refLabel: Ut }), !0;
                  }
                  return this.removeBracket(), this.pos = Fe, D.appendChild(li("]", this.sourcepos(Fe, Fe))), this.options.referenceDefinition && (this.refLinkCandidateMap[D.id] = { node: D, refLabel: Ut }), !0;
                }, P.prototype.addBracket = function(D, F, q) {
                  this.brackets !== null && (this.brackets.bracketAfter = !0), this.brackets = {
                    node: D,
                    startpos: this.sourcepos(F + (q ? 0 : 1)),
                    previous: this.brackets,
                    previousDelimiter: this.delimiters,
                    index: F,
                    image: q,
                    active: !0
                  };
                }, P.prototype.removeBracket = function() {
                  this.brackets && (this.brackets = this.brackets.previous);
                }, P.prototype.parseEntity = function(D) {
                  var F, q = this.pos + 1;
                  return (F = this.match(cX)) ? (D.appendChild(li(K.decodeHTML(F), this.sourcepos(q, this.pos))), !0) : !1;
                }, P.prototype.parseString = function(D) {
                  var F, q = this.pos + 1;
                  if (F = this.match(wX)) {
                    if (this.options.smart) {
                      var ye = F.replace(hX, "…").replace(pX, function(Ze) {
                        var dt = 0, Bt = 0;
                        return Ze.length % 3 === 0 ? Bt = Ze.length / 3 : Ze.length % 2 === 0 ? dt = Ze.length / 2 : Ze.length % 3 === 2 ? (dt = 1, Bt = (Ze.length - 2) / 3) : (dt = 2, Bt = (Ze.length - 4) / 3), uH("—", Bt) + uH("–", dt);
                      });
                      D.appendChild(li(ye, this.sourcepos(q, this.pos)));
                    } else {
                      var Fe = li(F, this.sourcepos(q, this.pos));
                      D.appendChild(Fe);
                    }
                    return !0;
                  }
                  return !1;
                }, P.prototype.parseNewline = function(D) {
                  this.pos += 1;
                  var F = D.lastChild;
                  if (F && F.type === "text" && F.literal[F.literal.length - 1] === " ") {
                    var q = F.literal[F.literal.length - 2] === " ", ye = F.literal.length;
                    F.literal = F.literal.replace(yX, "");
                    var Fe = ye - F.literal.length;
                    F.sourcepos[1][1] -= Fe, D.appendChild(In(q ? "linebreak" : "softbreak", this.sourcepos(this.pos - Fe, this.pos)));
                  } else
                    D.appendChild(In("softbreak", this.sourcepos(this.pos, this.pos)));
                  return this.nextLine(), this.match(bX), !0;
                }, P.prototype.parseReference = function(D, F) {
                  if (!this.options.referenceDefinition)
                    return 0;
                  this.subject = D.stringContent, this.pos = 0;
                  var q = null, ye = this.pos, Fe = this.parseLinkLabel();
                  if (Fe === 0)
                    return 0;
                  var Ze = this.subject.substr(0, Fe);
                  if (this.peek() === sX)
                    this.pos++;
                  else
                    return this.pos = ye, 0;
                  this.spnl();
                  var dt = this.parseLinkDestination();
                  if (dt === null)
                    return this.pos = ye, 0;
                  var Bt = this.pos;
                  this.spnl(), this.pos !== Bt && (q = this.parseLinkTitle()), q === null && (q = "", this.pos = Bt);
                  var Ut = !0;
                  if (this.match(r$) === null && (q === "" ? Ut = !1 : (q = "", this.pos = Bt, Ut = this.match(r$) !== null)), !Ut)
                    return this.pos = ye, 0;
                  var sr = qW(Ze);
                  if (sr === "")
                    return this.pos = ye, 0;
                  var fr = this.getReferenceDefSourcepos(D);
                  D.sourcepos[0][0] = fr[1][0] + 1;
                  var ar = In("refDef", fr);
                  return ar.title = q, ar.dest = dt, ar.label = sr, D.insertBefore(ar), F[sr] ? this.refDefCandidateMap[ar.id] = ar : F[sr] = OH(ar), this.pos - ye;
                }, P.prototype.mergeTextNodes = function(D) {
                  for (var F, q = []; F = D.next(); ) {
                    var ye = F.entering, Fe = F.node;
                    if (ye && Fe.type === "text")
                      q.push(Fe);
                    else if (q.length === 1)
                      q = [];
                    else if (q.length > 1) {
                      var Ze = q[0], dt = q[q.length - 1];
                      Ze.sourcepos && dt.sourcepos && (Ze.sourcepos[1] = dt.sourcepos[1]), Ze.next = dt.next, Ze.next && (Ze.next.prev = Ze);
                      for (var Bt = 1; Bt < q.length; Bt += 1)
                        Ze.literal += q[Bt].literal, q[Bt].unlink();
                      q = [];
                    }
                  }
                }, P.prototype.getReferenceDefSourcepos = function(D) {
                  for (var F = D.stringContent.split(/\n|\r\n/), q = !1, ye = 0, Fe = { line: 0, ch: 0 }, Ze = 0; Ze < F.length; Ze += 1) {
                    var dt = F[Ze];
                    if (yH.test(dt))
                      break;
                    if (/\:/.test(dt) && ye === 0) {
                      if (q)
                        break;
                      var Bt = dt.indexOf(":") === dt.length - 1 ? Ze + 1 : Ze;
                      Fe = { line: Bt, ch: F[Bt].length }, q = !0;
                    }
                    var Ut = dt.match(/'|"/g);
                    if (Ut && (ye += Ut.length), ye === 2) {
                      Fe = { line: Ze, ch: dt.length };
                      break;
                    }
                  }
                  return [
                    [D.sourcepos[0][0], D.sourcepos[0][1]],
                    [D.sourcepos[0][0] + Fe.line, Fe.ch]
                  ];
                }, P.prototype.parseInline = function(D) {
                  var F, q = !1, ye = this.peek();
                  if (ye === -1)
                    return !1;
                  switch (ye) {
                    case pH:
                      q = this.parseNewline(D);
                      break;
                    case JW:
                      q = this.parseBackslash(D);
                      break;
                    case nX:
                      q = this.parseBackticks(D);
                      break;
                    case vH:
                    case Tw:
                    case Aw:
                    case xc:
                      q = this.handleDelim(ye, D);
                      break;
                    case Sc:
                    case wc:
                      q = !!(!((F = this.options) === null || F === void 0) && F.smart) && this.handleDelim(ye, D);
                      break;
                    case KW:
                      q = this.parseOpenBracket(D);
                      break;
                    case aX:
                      q = this.parseBang(D);
                      break;
                    case iX:
                      q = this.parseCloseBracket(D);
                      break;
                    case XW:
                      q = this.parseAutolink(D) || this.parseHtmlTag(D);
                      break;
                    case oX:
                      D.disabledEntityParse || (q = this.parseEntity(D));
                      break;
                    default:
                      q = this.parseString(D);
                      break;
                  }
                  return q || (this.pos += 1, D.appendChild(li(hH(ye), this.sourcepos(this.pos, this.pos + 1)))), !0;
                }, P.prototype.parse = function(D) {
                  for (this.subject = D.stringContent.trim(), this.pos = 0, this.delimiters = null, this.brackets = null, this.lineOffsets = D.lineOffsets || [0], this.lineIdx = 0, this.linePosOffset = 0, this.lineStartNum = D.sourcepos[0][0], EK(D) && (this.lineOffsets[0] += D.level + 1); this.parseInline(D); )
                    ;
                  D.stringContent = null, this.processEmphasis(null), this.mergeTextNodes(D.walker());
                  var F = this.options, q = F.extendedAutolinks, ye = F.customParser;
                  if (q && eX(D.walker(), q), ye && D.firstChild)
                    for (var Fe, Ze = D.firstChild.walker(); Fe = Ze.next(); ) {
                      var dt = Fe.node, Bt = Fe.entering;
                      ye[dt.type] && ye[dt.type](dt, { entering: Bt, options: this.options });
                    }
                }, P;
              }()
            ), kX = /^\[([ \txX])\][ \t]+/;
            function OX(P, D) {
              if (D.firstChild && D.firstChild.type === "paragraph") {
                var F = D.firstChild, q = F.stringContent.match(kX);
                if (q) {
                  var ye = q[0].length;
                  F.stringContent = F.stringContent.substring(ye - 1), F.sourcepos[0][1] += ye, F.lineOffsets[0] += ye, D.listData.task = !0, D.listData.checked = /[xX]/.test(q[1]);
                }
              }
            }
            var CX = {
              continue: function() {
                return 0;
              },
              finalize: function() {
              },
              canContain: function(P) {
                return P === "tableHead" || P === "tableBody";
              },
              acceptsLines: !1
            }, TX = {
              continue: function() {
                return 0;
              },
              finalize: function() {
              },
              canContain: function(P) {
                return P === "tableRow";
              },
              acceptsLines: !1
            }, AX = {
              continue: function() {
                return 1;
              },
              finalize: function() {
              },
              canContain: function(P) {
                return P === "tableRow" || P === "tableDelimRow";
              },
              acceptsLines: !1
            }, EX = {
              continue: function() {
                return 1;
              },
              finalize: function() {
              },
              canContain: function(P) {
                return P === "tableDelimCell";
              },
              acceptsLines: !1
            }, MX = {
              continue: function() {
                return 1;
              },
              finalize: function() {
              },
              canContain: function() {
                return !1;
              },
              acceptsLines: !1
            }, RX = {
              continue: function() {
                return 1;
              },
              finalize: function() {
              },
              canContain: function(P) {
                return P === "tableCell";
              },
              acceptsLines: !1
            }, DX = {
              continue: function() {
                return 1;
              },
              finalize: function() {
              },
              canContain: function() {
                return !1;
              },
              acceptsLines: !1
            }, Ew = 4, n$ = 9, i$ = 62, PX = 60, a$ = 32, o$ = 91, s$ = /[^ \t\f\v\r\n]/, LX = /^(?:`{3,}|~{3,})(?= *$)/;
            function l$(P) {
              for (var D = P; D; ) {
                if (D.lastLineBlank)
                  return !0;
                var F = D.type;
                if (!D.lastLineChecked && (F === "list" || F === "item"))
                  D.lastLineChecked = !0, D = D.lastChild;
                else {
                  D.lastLineChecked = !0;
                  break;
                }
              }
              return !1;
            }
            function uo(P, D) {
              return D < P.length ? P.charCodeAt(D) : -1;
            }
            function u$(P) {
              return !s$.test(P);
            }
            function Yh(P) {
              return P === a$ || P === n$;
            }
            var IX = /^\$\$$/, _X = {
              continue: function(P, D) {
                var F = P.currentLine, q = F.match(IX);
                if (q)
                  return P.lastLineLength = q[0].length, P.finalize(D, P.lineNumber), 2;
                for (var ye = D.offset; ye > 0 && Yh(uo(F, P.offset)); )
                  P.advanceOffset(1, !0), ye--;
                return 0;
              },
              finalize: function(P, D) {
                if (D.stringContent !== null) {
                  var F = D.stringContent, q = F.indexOf(`
`), ye = F.slice(0, q), Fe = F.slice(q + 1), Ze = ye.match(/^(\s*)(.*)/);
                  D.info = Eg(Ze[2].trim()), D.literal = Fe, D.stringContent = null;
                }
              },
              canContain: function() {
                return !1;
              },
              acceptsLines: !0
            }, c$ = {
              continue: function() {
                return 1;
              },
              finalize: function() {
              },
              canContain: function() {
                return !1;
              },
              acceptsLines: !0
            }, NX = {
              continue: function() {
                return 0;
              },
              finalize: function() {
              },
              canContain: function(P) {
                return P !== "item";
              },
              acceptsLines: !1
            }, BX = {
              continue: function() {
                return 0;
              },
              finalize: function(P, D) {
                for (var F = D.firstChild; F; ) {
                  if (l$(F) && F.next) {
                    D.listData.tight = !1;
                    break;
                  }
                  for (var q = F.firstChild; q; ) {
                    if (l$(q) && (F.next || q.next)) {
                      D.listData.tight = !1;
                      break;
                    }
                    q = q.next;
                  }
                  F = F.next;
                }
              },
              canContain: function(P) {
                return P === "item";
              },
              acceptsLines: !1
            }, FX = {
              continue: function(P) {
                var D = P.currentLine;
                if (!P.indented && uo(D, P.nextNonspace) === i$)
                  P.advanceNextNonspace(), P.advanceOffset(1, !1), Yh(uo(D, P.offset)) && P.advanceOffset(1, !0);
                else
                  return 1;
                return 0;
              },
              finalize: function() {
              },
              canContain: function(P) {
                return P !== "item";
              },
              acceptsLines: !1
            }, zX = {
              continue: function(P, D) {
                if (P.blank) {
                  if (D.firstChild === null)
                    return 1;
                  P.advanceNextNonspace();
                } else if (P.indent >= D.listData.markerOffset + D.listData.padding)
                  P.advanceOffset(D.listData.markerOffset + D.listData.padding, !0);
                else
                  return 1;
                return 0;
              },
              finalize: OX,
              canContain: function(P) {
                return P !== "item";
              },
              acceptsLines: !1
            }, HX = {
              continue: function() {
                return 1;
              },
              finalize: function() {
              },
              canContain: function() {
                return !1;
              },
              acceptsLines: !1
            }, jX = {
              continue: function() {
                return 1;
              },
              finalize: function() {
              },
              canContain: function() {
                return !1;
              },
              acceptsLines: !1
            }, WX = {
              continue: function(P, D) {
                var F = P.currentLine, q = P.indent;
                if (D.isFenced) {
                  var ye = q <= 3 && F.charAt(P.nextNonspace) === D.fenceChar && F.slice(P.nextNonspace).match(LX);
                  if (ye && ye[0].length >= D.fenceLength)
                    return P.lastLineLength = P.offset + q + ye[0].length, P.finalize(D, P.lineNumber), 2;
                  for (var Fe = D.fenceOffset; Fe > 0 && Yh(uo(F, P.offset)); )
                    P.advanceOffset(1, !0), Fe--;
                } else if (q >= Ew)
                  P.advanceOffset(Ew, !0);
                else if (P.blank)
                  P.advanceNextNonspace();
                else
                  return 1;
                return 0;
              },
              finalize: function(P, D) {
                var F;
                if (D.stringContent !== null) {
                  if (D.isFenced) {
                    var q = D.stringContent, ye = q.indexOf(`
`), Fe = q.slice(0, ye), Ze = q.slice(ye + 1), dt = Fe.match(/^(\s*)(.*)/);
                    D.infoPadding = dt[1].length, D.info = Eg(dt[2].trim()), D.literal = Ze;
                  } else
                    D.literal = (F = D.stringContent) === null || F === void 0 ? void 0 : F.replace(/(\n *)+$/, `
`);
                  D.stringContent = null;
                }
              },
              canContain: function() {
                return !1;
              },
              acceptsLines: !0
            }, $X = {
              continue: function(P, D) {
                return P.blank && (D.htmlBlockType === 6 || D.htmlBlockType === 7) ? 1 : 0;
              },
              finalize: function(P, D) {
                var F;
                D.literal = ((F = D.stringContent) === null || F === void 0 ? void 0 : F.replace(/(\n *)+$/, "")) || null, D.stringContent = null;
              },
              canContain: function() {
                return !1;
              },
              acceptsLines: !0
            }, UX = {
              continue: function(P) {
                return P.blank ? 1 : 0;
              },
              finalize: function(P, D) {
                if (D.stringContent !== null) {
                  for (var F, q = !1; uo(D.stringContent, 0) === o$ && (F = P.inlineParser.parseReference(D, P.refMap)); )
                    D.stringContent = D.stringContent.slice(F), q = !0;
                  q && u$(D.stringContent) && D.unlink();
                }
              },
              canContain: function() {
                return !1;
              },
              acceptsLines: !0
            }, VX = c$, GX = c$, qh = {
              document: NX,
              list: BX,
              blockQuote: FX,
              item: zX,
              heading: HX,
              thematicBreak: jX,
              codeBlock: WX,
              htmlBlock: $X,
              paragraph: UX,
              table: CX,
              tableBody: TX,
              tableHead: AX,
              tableRow: RX,
              tableCell: DX,
              tableDelimRow: EX,
              tableDelimCell: MX,
              refDef: VX,
              customBlock: _X,
              frontMatter: GX
            };
            function bH(P) {
              for (var D = 0, F = 0, q = [], ye = 0; ye < P.length; ye += 1)
                if (P[ye] === "|" && P[ye - 1] !== "\\") {
                  var Fe = P.substring(D, ye);
                  D === 0 && jW(Fe) ? F = ye + 1 : q.push(Fe), D = ye + 1;
                }
              if (D < P.length) {
                var Fe = P.substring(D, P.length);
                jW(Fe) || q.push(Fe);
              }
              return [F, q];
            }
            function SH(P, D, F, q) {
              for (var ye = [], Fe = 0, Ze = D; Fe < Ze.length; Fe++) {
                var dt = Ze[Fe], Bt = dt.match(/^[ \t]+/), Ut = Bt ? Bt[0].length : 0, sr = void 0, fr = void 0;
                if (Ut === dt.length)
                  Ut = 0, sr = 0, fr = "";
                else {
                  var ar = dt.match(/[ \t]+$/);
                  sr = ar ? ar[0].length : 0, fr = dt.slice(Ut, dt.length - sr);
                }
                var wr = q + Ut, Sr = In(P, [
                  [F, q],
                  [F, q + dt.length - 1]
                ]);
                Sr.stringContent = fr.replace(/\\\|/g, "|"), Sr.startIdx = ye.length, Sr.endIdx = ye.length, Sr.lineOffsets = [wr - 1], Sr.paddingLeft = Ut, Sr.paddingRight = sr, ye.push(Sr), q += dt.length + 1;
              }
              return ye;
            }
            function YX(P) {
              var D = null, F = P.stringContent, q = F[0], ye = F[F.length - 1];
              return ye === ":" ? D = q === ":" ? "center" : "right" : q === ":" && (D = "left"), { align: D };
            }
            var qX = function(P, D) {
              var F = D.stringContent;
              if (D.type === "paragraph" && !P.indented && !P.blank) {
                var q = F.length - 1, ye = F.lastIndexOf(`
`, q - 1) + 1, Fe = F.slice(ye, q), Ze = P.currentLine.slice(P.nextNonspace), dt = bH(Fe), Bt = dt[0], Ut = dt[1], sr = bH(Ze), fr = sr[0], ar = sr[1], wr = /^[ \t]*:?-+:?[ \t]*$/;
                if (
                  // not checking if the number of header cells and delimiter cells are the same
                  // to consider the case of merged-column (via plugin)
                  !Ut.length || !ar.length || ar.some(function(dl) {
                    return !wr.test(dl);
                  }) || // to prevent to regard setTextHeading as tabel delim cell with 'disallowDeepHeading' option
                  ar.length === 1 && Ze.indexOf("|") !== 0
                )
                  return 0;
                var Sr = D.lineOffsets, Jr = P.lineNumber - 1, _n = Ow(Sr) + 1, pi = In("table", [
                  [Jr, _n],
                  [P.lineNumber, P.offset]
                ]);
                if (pi.columns = ar.map(function() {
                  return { align: null };
                }), D.insertAfter(pi), Sr.length === 1)
                  D.unlink();
                else {
                  D.stringContent = F.slice(0, ye);
                  var ul = F.lastIndexOf(`
`, ye - 2) + 1, Do = ye - ul - 1;
                  P.lastLineLength = Sr[Sr.length - 2] + Do, P.finalize(D, Jr - 1);
                }
                P.advanceOffset(P.currentLine.length - P.offset, !1);
                var co = In("tableHead", [
                  [Jr, _n],
                  [P.lineNumber, P.offset]
                ]);
                pi.appendChild(co);
                var ss = In("tableRow", [
                  [Jr, _n],
                  [Jr, _n + Fe.length - 1]
                ]), cl = In("tableDelimRow", [
                  [P.lineNumber, P.nextNonspace + 1],
                  [P.lineNumber, P.offset]
                ]);
                co.appendChild(ss), co.appendChild(cl), SH("tableCell", Ut, Jr, _n + Bt).forEach(function(dl) {
                  ss.appendChild(dl);
                });
                var fl = SH("tableDelimCell", ar, P.lineNumber, P.nextNonspace + 1 + fr);
                return fl.forEach(function(dl) {
                  cl.appendChild(dl);
                }), pi.columns = fl.map(YX), P.tip = pi, 2;
              }
              return 0;
            }, KX = function(P, D) {
              if (D.type !== "table" && D.type !== "tableBody" || !P.blank && P.currentLine.indexOf("|") === -1)
                return 0;
              if (P.advanceOffset(P.currentLine.length - P.offset, !1), P.blank) {
                var F = D;
                return D.type === "tableBody" && (F = D.parent, P.finalize(D, P.lineNumber - 1)), P.finalize(F, P.lineNumber - 1), 0;
              }
              var q = D;
              D.type === "table" && (q = P.addChild("tableBody", P.nextNonspace), q.stringContent = null);
              var ye = In("tableRow", [
                [P.lineNumber, P.nextNonspace + 1],
                [P.lineNumber, P.currentLine.length]
              ]);
              q.appendChild(ye);
              var Fe = q.parent, Ze = P.currentLine.slice(P.nextNonspace), dt = bH(Ze), Bt = dt[0], Ut = dt[1];
              return SH("tableCell", Ut, P.lineNumber, P.nextNonspace + 1 + Bt).forEach(function(sr, fr) {
                fr >= Fe.columns.length && (sr.ignored = !0), ye.appendChild(sr);
              }), 2;
            }, XX = /^(\$\$)(\s*[a-zA-Z])+/, JX = /^(\$\$)(\s*[a-zA-Z])+.*(\$\$)/, ZX = function(P) {
              var D;
              if (!P.indented && !JX.test(P.currentLine) && (D = P.currentLine.match(XX))) {
                var F = D[1].length;
                P.closeUnmatchedBlocks();
                var q = P.addChild("customBlock", P.nextNonspace);
                return q.syntaxLength = F, q.offset = P.indent, P.advanceNextNonspace(), P.advanceOffset(F, !1), 2;
              }
              return 0;
            }, QX = /^`{3,}(?!.*`)|^~{3,}/, eJ = [
              /./,
              /^<(?:script|pre|style)(?:\s|>|$)/i,
              /^<!--/,
              /^<[?]/,
              /^<![A-Z]/,
              /^<!\[CDATA\[/,
              /^<[/]?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[123456]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|[/]?[>]|$)/i,
              new RegExp("^(?:" + GW + "|" + YW + ")\\s*$", "i")
            ], tJ = /^(?:=+|-+)[ \t]*$/, rJ = /^#{1,6}(?:[ \t]+|$)/, nJ = /^(?:(?:\*[ \t]*){3,}|(?:_[ \t]*){3,}|(?:-[ \t]*){3,})[ \t]*$/, f$ = /^[*+-]/, d$ = /^(\d{1,9})([.)])/;
            function iJ(P, D) {
              var F = P.currentLine.slice(P.nextNonspace), q, ye, Fe = {
                type: "bullet",
                tight: !0,
                bulletChar: "",
                start: 0,
                delimiter: "",
                padding: 0,
                markerOffset: P.indent,
                // GFM: Task List Item
                task: !1,
                checked: !1
              };
              if (P.indent >= 4)
                return null;
              if (q = F.match(f$))
                Fe.type = "bullet", Fe.bulletChar = q[0][0];
              else if ((q = F.match(d$)) && (D.type !== "paragraph" || q[1] === "1"))
                Fe.type = "ordered", Fe.start = parseInt(q[1], 10), Fe.delimiter = q[2];
              else
                return null;
              if (ye = uo(P.currentLine, P.nextNonspace + q[0].length), !(ye === -1 || ye === n$ || ye === a$) || D.type === "paragraph" && !P.currentLine.slice(P.nextNonspace + q[0].length).match(s$))
                return null;
              P.advanceNextNonspace(), P.advanceOffset(q[0].length, !0);
              var Ze = P.column, dt = P.offset;
              do
                P.advanceOffset(1, !0), ye = uo(P.currentLine, P.offset);
              while (P.column - Ze < 5 && Yh(ye));
              var Bt = uo(P.currentLine, P.offset) === -1, Ut = P.column - Ze;
              return Ut >= 5 || Ut < 1 || Bt ? (Fe.padding = q[0].length + 1, P.column = Ze, P.offset = dt, Yh(uo(P.currentLine, P.offset)) && P.advanceOffset(1, !0)) : Fe.padding = q[0].length + Ut, Fe;
            }
            function aJ(P, D) {
              return P.type === D.type && P.delimiter === D.delimiter && P.bulletChar === D.bulletChar;
            }
            function h$(P, D) {
              return P.options.disallowDeepHeading && (D.type === "blockQuote" || D.type === "item");
            }
            var oJ = function(P) {
              return !P.indented && uo(P.currentLine, P.nextNonspace) === i$ ? (P.advanceNextNonspace(), P.advanceOffset(1, !1), Yh(uo(P.currentLine, P.offset)) && P.advanceOffset(1, !0), P.closeUnmatchedBlocks(), P.addChild("blockQuote", P.nextNonspace), 1) : 0;
            }, sJ = function(P, D) {
              var F;
              if (!P.indented && // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
              !h$(P, D) && (F = P.currentLine.slice(P.nextNonspace).match(rJ))) {
                P.advanceNextNonspace(), P.advanceOffset(F[0].length, !1), P.closeUnmatchedBlocks();
                var q = P.addChild("heading", P.nextNonspace);
                return q.level = F[0].trim().length, q.headingType = "atx", q.stringContent = P.currentLine.slice(P.offset).replace(/^[ \t]*#+[ \t]*$/, "").replace(/[ \t]+#+[ \t]*$/, ""), P.advanceOffset(P.currentLine.length - P.offset), 2;
              }
              return 0;
            }, lJ = function(P) {
              var D;
              if (!P.indented && (D = P.currentLine.slice(P.nextNonspace).match(QX))) {
                var F = D[0].length;
                P.closeUnmatchedBlocks();
                var q = P.addChild("codeBlock", P.nextNonspace);
                return q.isFenced = !0, q.fenceLength = F, q.fenceChar = D[0][0], q.fenceOffset = P.indent, P.advanceNextNonspace(), P.advanceOffset(F, !1), 2;
              }
              return 0;
            }, uJ = function(P, D) {
              if (!P.indented && uo(P.currentLine, P.nextNonspace) === PX) {
                var F = P.currentLine.slice(P.nextNonspace), q = P.options.disallowedHtmlBlockTags, ye = void 0;
                for (ye = 1; ye <= 7; ye++) {
                  var Fe = F.match(eJ[ye]);
                  if (Fe) {
                    if (ye === 7) {
                      if (D.type === "paragraph")
                        return 0;
                      if (q.length > 0) {
                        var Ze = new RegExp("</?(?:" + q.join("|") + ")", "i");
                        if (Ze.test(Fe[0]))
                          return 0;
                      }
                    }
                    P.closeUnmatchedBlocks();
                    var dt = P.addChild("htmlBlock", P.offset);
                    return dt.htmlBlockType = ye, 2;
                  }
                }
              }
              return 0;
            }, cJ = function(P, D) {
              var F;
              if (D.stringContent !== null && !P.indented && D.type === "paragraph" && // The nested Heading is disallowed in list and blockquote with 'disallowDeepHeading' option
              !h$(P, D.parent) && (F = P.currentLine.slice(P.nextNonspace).match(tJ))) {
                P.closeUnmatchedBlocks();
                for (var q = void 0; uo(D.stringContent, 0) === o$ && (q = P.inlineParser.parseReference(D, P.refMap)); )
                  D.stringContent = D.stringContent.slice(q);
                if (D.stringContent.length > 0) {
                  var ye = In("heading", D.sourcepos);
                  return ye.level = F[0][0] === "=" ? 1 : 2, ye.headingType = "setext", ye.stringContent = D.stringContent, D.insertAfter(ye), D.unlink(), P.tip = ye, P.advanceOffset(P.currentLine.length - P.offset, !1), 2;
                }
                return 0;
              }
              return 0;
            }, fJ = function(P) {
              return !P.indented && nJ.test(P.currentLine.slice(P.nextNonspace)) ? (P.closeUnmatchedBlocks(), P.addChild("thematicBreak", P.nextNonspace), P.advanceOffset(P.currentLine.length - P.offset, !1), 2) : 0;
            }, dJ = function(P, D) {
              var F, q = D;
              return (!P.indented || D.type === "list") && (F = iJ(P, q)) ? (P.closeUnmatchedBlocks(), (P.tip.type !== "list" || !aJ(q.listData, F)) && (q = P.addChild("list", P.nextNonspace), q.listData = F), q = P.addChild("item", P.nextNonspace), q.listData = F, 1) : 0;
            }, hJ = function(P) {
              return P.indented && P.tip.type !== "paragraph" && !P.blank ? (P.advanceOffset(Ew, !0), P.closeUnmatchedBlocks(), P.addChild("codeBlock", P.offset), 2) : 0;
            }, wH = [
              oJ,
              sJ,
              lJ,
              uJ,
              cJ,
              fJ,
              dJ,
              hJ,
              qX,
              KX,
              ZX
            ], p$ = /^(-{3}|\+{3}|;{3})$/, pJ = function(P, D) {
              var F = P.currentLine, q = P.lineNumber, ye = P.indented;
              if (q === 1 && !ye && D.type === "document" && p$.test(F)) {
                P.closeUnmatchedBlocks();
                var Fe = P.addChild("frontMatter", P.nextNonspace);
                return Fe.stringContent = F, P.advanceNextNonspace(), P.advanceOffset(F.length, !1), 2;
              }
              return 0;
            }, vJ = {
              continue: function(P, D) {
                var F = P.currentLine, q = F.match(p$);
                return D.type === "frontMatter" && q ? (D.stringContent += F, P.lastLineLength = q[0].length, P.finalize(D, P.lineNumber), 2) : 0;
              },
              finalize: function(P, D) {
                D.stringContent !== null && (D.literal = D.stringContent, D.stringContent = null);
              },
              canContain: function() {
                return !1;
              },
              acceptsLines: !0
            }, mJ = [
              /./,
              /<\/(?:script|pre|style)>/i,
              /-->/,
              /\?>/,
              />/,
              /\]\]>/
            ], gJ = /^[#`~*+_=<>0-9-;$]/, yJ = /\r\n|\n|\r/;
            function xH() {
              return In("document", [
                [1, 1],
                [0, 0]
              ]);
            }
            var bJ = {
              smart: !1,
              tagFilter: !1,
              extendedAutolinks: !1,
              disallowedHtmlBlockTags: [],
              referenceDefinition: !1,
              disallowDeepHeading: !1,
              customParser: null,
              frontMatter: !1
            }, SJ = (
              /** @class */
              function() {
                function P(D) {
                  this.options = O(O({}, bJ), D), this.doc = xH(), this.tip = this.doc, this.oldtip = this.doc, this.lineNumber = 0, this.offset = 0, this.column = 0, this.nextNonspace = 0, this.nextNonspaceColumn = 0, this.indent = 0, this.currentLine = "", this.indented = !1, this.blank = !1, this.partiallyConsumedTab = !1, this.allClosed = !0, this.lastMatchedContainer = this.doc, this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.lastLineLength = 0, this.lines = [], this.options.frontMatter && (qh.frontMatter = vJ, wH.unshift(pJ)), this.inlineParser = new xX(this.options);
                }
                return P.prototype.advanceOffset = function(D, F) {
                  F === void 0 && (F = !1);
                  for (var q = this.currentLine, ye, Fe, Ze; D > 0 && (Ze = q[this.offset]); )
                    Ze === "	" ? (ye = 4 - this.column % 4, F ? (this.partiallyConsumedTab = ye > D, Fe = ye > D ? D : ye, this.column += Fe, this.offset += this.partiallyConsumedTab ? 0 : 1, D -= Fe) : (this.partiallyConsumedTab = !1, this.column += ye, this.offset += 1, D -= 1)) : (this.partiallyConsumedTab = !1, this.offset += 1, this.column += 1, D -= 1);
                }, P.prototype.advanceNextNonspace = function() {
                  this.offset = this.nextNonspace, this.column = this.nextNonspaceColumn, this.partiallyConsumedTab = !1;
                }, P.prototype.findNextNonspace = function() {
                  for (var D = this.currentLine, F = this.offset, q = this.column, ye; (ye = D.charAt(F)) !== ""; )
                    if (ye === " ")
                      F++, q++;
                    else if (ye === "	")
                      F++, q += 4 - q % 4;
                    else
                      break;
                  this.blank = ye === `
` || ye === "\r" || ye === "", this.nextNonspace = F, this.nextNonspaceColumn = q, this.indent = this.nextNonspaceColumn - this.column, this.indented = this.indent >= Ew;
                }, P.prototype.addLine = function() {
                  if (this.partiallyConsumedTab) {
                    this.offset += 1;
                    var D = 4 - this.column % 4;
                    this.tip.stringContent += uH(" ", D);
                  }
                  this.tip.lineOffsets ? this.tip.lineOffsets.push(this.offset) : this.tip.lineOffsets = [this.offset], this.tip.stringContent += this.currentLine.slice(this.offset) + `
`;
                }, P.prototype.addChild = function(D, F) {
                  for (; !qh[this.tip.type].canContain(D); )
                    this.finalize(this.tip, this.lineNumber - 1);
                  var q = F + 1, ye = In(D, [
                    [this.lineNumber, q],
                    [0, 0]
                  ]);
                  return ye.stringContent = "", this.tip.appendChild(ye), this.tip = ye, ye;
                }, P.prototype.closeUnmatchedBlocks = function() {
                  if (!this.allClosed) {
                    for (; this.oldtip !== this.lastMatchedContainer; ) {
                      var D = this.oldtip.parent;
                      this.finalize(this.oldtip, this.lineNumber - 1), this.oldtip = D;
                    }
                    this.allClosed = !0;
                  }
                }, P.prototype.finalize = function(D, F) {
                  var q = D.parent;
                  D.open = !1, D.sourcepos[1] = [F, this.lastLineLength], qh[D.type].finalize(this, D), this.tip = q;
                }, P.prototype.processInlines = function(D) {
                  var F, q = this.options.customParser, ye = D.walker();
                  for (this.inlineParser.refMap = this.refMap, this.inlineParser.refLinkCandidateMap = this.refLinkCandidateMap, this.inlineParser.refDefCandidateMap = this.refDefCandidateMap, this.inlineParser.options = this.options; F = ye.next(); ) {
                    var Fe = F.node, Ze = F.entering, dt = Fe.type;
                    q && q[dt] && q[dt](Fe, { entering: Ze, options: this.options }), !Ze && (dt === "paragraph" || dt === "heading" || dt === "tableCell" && !Fe.ignored) && this.inlineParser.parse(Fe);
                  }
                }, P.prototype.incorporateLine = function(D) {
                  var F = this.doc;
                  this.oldtip = this.tip, this.offset = 0, this.column = 0, this.blank = !1, this.partiallyConsumedTab = !1, this.lineNumber += 1, D.indexOf("\0") !== -1 && (D = D.replace(/\0/g, "�")), this.currentLine = D;
                  for (var q = !0, ye; (ye = F.lastChild) && ye.open; ) {
                    switch (F = ye, this.findNextNonspace(), qh[F.type].continue(this, F)) {
                      case 0:
                        break;
                      case 1:
                        q = !1;
                        break;
                      case 2:
                        this.lastLineLength = D.length;
                        return;
                      default:
                        throw new Error("continue returned illegal value, must be 0, 1, or 2");
                    }
                    if (!q) {
                      F = F.parent;
                      break;
                    }
                  }
                  this.allClosed = F === this.oldtip, this.lastMatchedContainer = F;
                  for (var Fe = F.type !== "paragraph" && qh[F.type].acceptsLines, Ze = wH.length; !Fe; ) {
                    if (this.findNextNonspace(), F.type !== "table" && F.type !== "tableBody" && F.type !== "paragraph" && !this.indented && !gJ.test(D.slice(this.nextNonspace))) {
                      this.advanceNextNonspace();
                      break;
                    }
                    for (var dt = 0; dt < Ze; ) {
                      var Bt = wH[dt](this, F);
                      if (Bt === 1) {
                        F = this.tip;
                        break;
                      } else if (Bt === 2) {
                        F = this.tip, Fe = !0;
                        break;
                      } else
                        dt++;
                    }
                    if (dt === Ze) {
                      this.advanceNextNonspace();
                      break;
                    }
                  }
                  if (!this.allClosed && !this.blank && this.tip.type === "paragraph")
                    this.addLine();
                  else {
                    this.closeUnmatchedBlocks(), this.blank && F.lastChild && (F.lastChild.lastLineBlank = !0);
                    for (var Ut = F.type, sr = this.blank && !(Ut === "blockQuote" || WW(F) && F.isFenced || Ut === "item" && !F.firstChild && F.sourcepos[0][0] === this.lineNumber), fr = F; fr; )
                      fr.lastLineBlank = sr, fr = fr.parent;
                    qh[Ut].acceptsLines ? (this.addLine(), AK(F) && F.htmlBlockType >= 1 && F.htmlBlockType <= 5 && mJ[F.htmlBlockType].test(this.currentLine.slice(this.offset)) && (this.lastLineLength = D.length, this.finalize(F, this.lineNumber))) : this.offset < D.length && !this.blank && (F = this.addChild("paragraph", this.offset), this.advanceNextNonspace(), this.addLine());
                  }
                  this.lastLineLength = D.length;
                }, P.prototype.parse = function(D, F) {
                  this.doc = xH(), this.tip = this.doc, this.lineNumber = 0, this.lastLineLength = 0, this.offset = 0, this.column = 0, this.lastMatchedContainer = this.doc, this.currentLine = "";
                  var q = D.split(yJ), ye = q.length;
                  this.lines = F || q, this.options.referenceDefinition && this.clearRefMaps(), D.charCodeAt(D.length - 1) === pH && (ye -= 1);
                  for (var Fe = 0; Fe < ye; Fe++)
                    this.incorporateLine(q[Fe]);
                  for (; this.tip; )
                    this.finalize(this.tip, ye);
                  return this.processInlines(this.doc), this.doc;
                }, P.prototype.partialParseStart = function(D, F) {
                  this.doc = xH(), this.tip = this.doc, this.lineNumber = D - 1, this.lastLineLength = 0, this.offset = 0, this.column = 0, this.lastMatchedContainer = this.doc, this.currentLine = "";
                  for (var q = F.length, ye = 0; ye < q; ye++)
                    this.incorporateLine(F[ye]);
                  return this.doc;
                }, P.prototype.partialParseExtends = function(D) {
                  for (var F = 0; F < D.length; F++)
                    this.incorporateLine(D[F]);
                }, P.prototype.partialParseFinish = function() {
                  for (; this.tip; )
                    this.finalize(this.tip, this.lineNumber);
                  this.processInlines(this.doc);
                }, P.prototype.setRefMaps = function(D, F, q) {
                  this.refMap = D, this.refLinkCandidateMap = F, this.refDefCandidateMap = q;
                }, P.prototype.clearRefMaps = function() {
                  [this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function(D) {
                    rX(D);
                  });
                }, P;
              }()
            );
            function v$(P, D) {
              return P[0] < D[0] ? 1 : P[0] > D[0] ? -1 : P[1] < D[1] ? 1 : P[1] > D[1] ? -1 : 0;
            }
            function wJ(P, D) {
              var F = P[0], q = P[1];
              return v$(q, D) === 1 ? 1 : v$(F, D) === -1 ? -1 : 0;
            }
            function xJ(P, D) {
              if (!(P.parent !== D.parent || P === D)) {
                for (var F = P.next; F && F !== D; ) {
                  for (var q = F.next, ye = 0, Fe = ["parent", "prev", "next"]; ye < Fe.length; ye++) {
                    var Ze = Fe[ye];
                    F[Ze] && (fH(F[Ze].id), F[Ze] = null);
                  }
                  F = q;
                }
                P.next = D.next, D.next ? D.next.prev = P : P.parent.lastChild = P;
              }
            }
            function kJ(P) {
              for (var D = [], F = P.firstChild; F; )
                D.push(F), F = F.next;
              return D;
            }
            function m$(P, D) {
              for (var F = 0, q = D; F < q.length; F++) {
                var ye = q[F];
                P.insertBefore(ye);
              }
            }
            function OJ(P, D) {
              for (var F = D.length - 1; F >= 0; F -= 1)
                P.prependChild(D[F]);
            }
            function CJ(P, D) {
              if (!(!P || !P.parent || D === 0)) {
                var F = P.parent.walker();
                F.resumeAt(P, !0);
                for (var q; q = F.next(); ) {
                  var ye = q.node, Fe = q.entering;
                  Fe && (ye.sourcepos[0][0] += D, ye.sourcepos[1][0] += D);
                }
              }
            }
            function g$(P, D) {
              var F = P[0], q = P[1];
              return q[0] < D ? 1 : F[0] > D ? -1 : 0;
            }
            function Mw(P, D) {
              for (var F = P.firstChild; F; ) {
                var q = g$(F.sourcepos, D);
                if (q === 0)
                  return F;
                if (q === -1)
                  return F.prev || F;
                F = F.next;
              }
              return P.lastChild;
            }
            function TJ(P) {
              for (; P.lastChild; )
                P = P.lastChild;
              return P;
            }
            function AJ(P) {
              for (; P.parent && P.parent.type !== "document" && P.parent.sourcepos[0][0] === P.sourcepos[0][0]; )
                P = P.parent;
              return P;
            }
            function EJ(P, D) {
              for (var F = P.firstChild, q = null; F; ) {
                var ye = g$(F.sourcepos, D);
                if (ye === 0) {
                  if (F.sourcepos[0][0] === D || !F.firstChild)
                    return F;
                  q = F, F = F.firstChild;
                } else {
                  if (ye === -1)
                    break;
                  q = F, F = F.next;
                }
              }
              return q ? AJ(TJ(q)) : null;
            }
            function MJ(P, D) {
              for (var F = P, q = null; F; ) {
                var ye = wJ(F.sourcepos, D);
                if (ye === 0)
                  if (F.firstChild)
                    q = F, F = F.firstChild;
                  else
                    return F;
                else {
                  if (ye === -1)
                    return q;
                  if (F.next)
                    F = F.next;
                  else
                    return q;
                }
              }
              return F;
            }
            function y$(P) {
              return pK(P) || null;
            }
            function kH(P, D, F) {
              if (F === void 0 && (F = null), D)
                for (var q = D.walker(); D && D !== F; ) {
                  P(D);
                  var ye = q.next();
                  if (ye)
                    D = ye.node;
                  else
                    break;
                }
            }
            function RJ(P) {
              var D = y$(P);
              if (!D)
                return !0;
              for (; D && D.type !== "document"; ) {
                if (!D.parent && !D.prev && !D.next)
                  return !0;
                D = D.parent;
              }
              return !1;
            }
            var b$ = /\r\n|\n|\r/;
            function DJ(P) {
              var D = P.match(/^[ \t]+/);
              if (D && (D[0].length >= 2 || /\t/.test(D[0])))
                return !0;
              var F = D ? P.slice(D.length) : P;
              return f$.test(F) || d$.test(F);
            }
            function PJ(P) {
              return !u$(P) && P.indexOf("|") !== -1;
            }
            function OH(P) {
              var D = P.id, F = P.title, q = P.sourcepos, ye = P.dest;
              return {
                id: D,
                title: F,
                sourcepos: q,
                unlinked: !1,
                destination: ye
              };
            }
            var LJ = (
              /** @class */
              function() {
                function P(D, F) {
                  this.refMap = {}, this.refLinkCandidateMap = {}, this.refDefCandidateMap = {}, this.referenceDefinition = !!(F != null && F.referenceDefinition), this.parser = new SJ(F), this.parser.setRefMaps(this.refMap, this.refLinkCandidateMap, this.refDefCandidateMap), this.eventHandlerMap = { change: [] }, D = D || "", this.lineTexts = D.split(b$), this.root = this.parser.parse(D, this.lineTexts);
                }
                return P.prototype.updateLineTexts = function(D, F, q) {
                  var ye, Fe = D[0], Ze = D[1], dt = F[0], Bt = F[1], Ut = q.split(b$), sr = Ut.length, fr = this.lineTexts[Fe - 1], ar = this.lineTexts[dt - 1];
                  Ut[0] = fr.slice(0, Ze - 1) + Ut[0], Ut[sr - 1] = Ut[sr - 1] + ar.slice(Bt - 1);
                  var wr = dt - Fe + 1;
                  return (ye = this.lineTexts).splice.apply(ye, T([Fe - 1, wr], Ut)), sr - wr;
                }, P.prototype.updateRootNodeState = function() {
                  if (this.lineTexts.length === 1 && this.lineTexts[0] === "") {
                    this.root.lastLineBlank = !0, this.root.sourcepos = [
                      [1, 1],
                      [1, 0]
                    ];
                    return;
                  }
                  this.root.lastChild && (this.root.lastLineBlank = this.root.lastChild.lastLineBlank);
                  for (var D = this.lineTexts, F = D.length - 1; D[F] === ""; )
                    F -= 1;
                  D.length - 2 > F && (F += 1), this.root.sourcepos[1] = [F + 1, D[F].length];
                }, P.prototype.replaceRangeNodes = function(D, F, q) {
                  D ? (m$(D, q), xJ(D, F), [D.id, F.id].forEach(function(ye) {
                    return fH(ye);
                  }), D.unlink()) : F ? (m$(F, q), fH(F.id), F.unlink()) : OJ(this.root, q);
                }, P.prototype.getNodeRange = function(D, F) {
                  var q = Mw(this.root, D[0]), ye = Mw(this.root, F[0]);
                  return ye && ye.next && F[0] + 1 === ye.next.sourcepos[0][0] && (ye = ye.next), [q, ye];
                }, P.prototype.trigger = function(D, F) {
                  this.eventHandlerMap[D].forEach(function(q) {
                    q(F);
                  });
                }, P.prototype.extendEndLine = function(D) {
                  for (; this.lineTexts[D] === ""; )
                    D += 1;
                  return D;
                }, P.prototype.parseRange = function(D, F, q, ye) {
                  D && D.prev && ($W(D.prev) && DJ(this.lineTexts[q - 1]) || MK(D.prev) && PJ(this.lineTexts[q - 1])) && (D = D.prev, q = D.sourcepos[0][0]);
                  for (var Fe = this.lineTexts.slice(q - 1, ye), Ze = this.parser.partialParseStart(q, Fe), dt = F ? F.next : this.root.firstChild, Bt = Ze.lastChild, Ut = Bt && WW(Bt) && Bt.open, sr = Bt && UW(Bt) && Bt.open, fr = Bt && $W(Bt); (Ut || sr) && dt || fr && dt && (dt.type === "list" || dt.sourcepos[0][1] >= 2); ) {
                    var ar = this.extendEndLine(dt.sourcepos[1][0]);
                    this.parser.partialParseExtends(this.lineTexts.slice(ye, ar)), D || (D = F), F = dt, ye = ar, dt = dt.next;
                  }
                  this.parser.partialParseFinish();
                  var wr = kJ(Ze);
                  return { newNodes: wr, extStartNode: D, extEndNode: F };
                }, P.prototype.getRemovedNodeRange = function(D, F) {
                  return !D || D && Vh(D) || F && Vh(F) ? null : {
                    id: [D.id, F.id],
                    line: [D.sourcepos[0][0] - 1, F.sourcepos[1][0] - 1]
                  };
                }, P.prototype.markDeletedRefMap = function(D, F) {
                  var q = this;
                  if (!Gh(this.refMap)) {
                    var ye = function(Fe) {
                      if (Vh(Fe)) {
                        var Ze = q.refMap[Fe.label];
                        Ze && Fe.id === Ze.id && (Ze.unlinked = !0);
                      }
                    };
                    D && kH(ye, D.parent, F), F && kH(ye, F);
                  }
                }, P.prototype.replaceWithNewRefDefState = function(D) {
                  var F = this;
                  if (!Gh(this.refMap)) {
                    var q = function(ye) {
                      if (Vh(ye)) {
                        var Fe = ye.label, Ze = F.refMap[Fe];
                        (!Ze || Ze.unlinked) && (F.refMap[Fe] = OH(ye));
                      }
                    };
                    D.forEach(function(ye) {
                      kH(q, ye);
                    });
                  }
                }, P.prototype.replaceWithRefDefCandidate = function() {
                  var D = this;
                  Gh(this.refDefCandidateMap) || Cw(this.refDefCandidateMap, function(F, q) {
                    var ye = q.label, Fe = q.sourcepos, Ze = D.refMap[ye];
                    (!Ze || Ze.unlinked || Ze.sourcepos[0][0] > Fe[0][0]) && (D.refMap[ye] = OH(q));
                  });
                }, P.prototype.getRangeWithRefDef = function(D, F, q, ye, Fe) {
                  if (this.referenceDefinition && !Gh(this.refMap)) {
                    var Ze = Mw(this.root, D - 1), dt = Mw(this.root, F + 1);
                    Ze && Vh(Ze) && Ze !== q && Ze !== ye && (q = Ze, D = q.sourcepos[0][0]), dt && Vh(dt) && dt !== q && dt !== ye && (ye = dt, F = this.extendEndLine(ye.sourcepos[1][0] + Fe));
                  }
                  return [q, ye, D, F];
                }, P.prototype.parse = function(D, F, q) {
                  q === void 0 && (q = 0);
                  var ye = this.getNodeRange(D, F), Fe = ye[0], Ze = ye[1], dt = Fe ? Math.min(Fe.sourcepos[0][0], D[0]) : D[0], Bt = this.extendEndLine((Ze ? Math.max(Ze.sourcepos[1][0], F[0]) : F[0]) + q), Ut = this.parseRange.apply(this, this.getRangeWithRefDef(dt, Bt, Fe, Ze, q)), sr = Ut.newNodes, fr = Ut.extStartNode, ar = Ut.extEndNode, wr = this.getRemovedNodeRange(fr, ar), Sr = ar ? ar.next : this.root.firstChild;
                  return this.referenceDefinition ? (this.markDeletedRefMap(fr, ar), this.replaceRangeNodes(fr, ar, sr), this.replaceWithNewRefDefState(sr)) : this.replaceRangeNodes(fr, ar, sr), { nodes: sr, removedNodeRange: wr, nextNode: Sr };
                }, P.prototype.parseRefLink = function() {
                  var D = this, F = [];
                  return Gh(this.refMap) || Cw(this.refMap, function(q, ye) {
                    ye.unlinked && delete D.refMap[q], Cw(D.refLinkCandidateMap, function(Fe, Ze) {
                      var dt = Ze.node, Bt = Ze.refLabel;
                      Bt === q && F.push(D.parse(dt.sourcepos[0], dt.sourcepos[1]));
                    });
                  }), F;
                }, P.prototype.removeUnlinkedCandidate = function() {
                  Gh(this.refDefCandidateMap) || [this.refLinkCandidateMap, this.refDefCandidateMap].forEach(function(D) {
                    Cw(D, function(F) {
                      RJ(F) && delete D[F];
                    });
                  });
                }, P.prototype.editMarkdown = function(D, F, q) {
                  var ye = this.updateLineTexts(D, F, q), Fe = this.parse(D, F, ye), Ze = tX(Fe, "nextNode");
                  CJ(Fe.nextNode, ye), this.updateRootNodeState();
                  var dt = [Ze];
                  return this.referenceDefinition && (this.removeUnlinkedCandidate(), this.replaceWithRefDefCandidate(), dt = dt.concat(this.parseRefLink())), this.trigger("change", dt), dt;
                }, P.prototype.getLineTexts = function() {
                  return this.lineTexts;
                }, P.prototype.getRootNode = function() {
                  return this.root;
                }, P.prototype.findNodeAtPosition = function(D) {
                  var F = MJ(this.root, D);
                  return !F || F === this.root ? null : F;
                }, P.prototype.findFirstNodeAtLine = function(D) {
                  return EJ(this.root, D);
                }, P.prototype.on = function(D, F) {
                  this.eventHandlerMap[D].push(F);
                }, P.prototype.off = function(D, F) {
                  var q = this.eventHandlerMap[D], ye = q.indexOf(F);
                  q.splice(ye, 1);
                }, P.prototype.findNodeById = function(D) {
                  return y$(D);
                }, P.prototype.removeAllNode = function() {
                  vK();
                }, P;
              }()
            ), IJ = [
              "title",
              "textarea",
              "style",
              "xmp",
              "iframe",
              "noembed",
              "noframes",
              "script",
              "plaintext"
            ], S$ = new RegExp("<(/?(?:" + IJ.join("|") + ")[^>]*>)", "ig");
            function w$(P) {
              return S$.test(P) ? P.replace(S$, function(D, F) {
                return "&lt;" + F;
              }) : P;
            }
            var x$ = {
              heading: function(P, D) {
                var F = D.entering;
                return {
                  type: F ? "openTag" : "closeTag",
                  tagName: "h" + P.level,
                  outerNewLine: !0
                };
              },
              text: function(P) {
                return {
                  type: "text",
                  content: P.literal
                };
              },
              softbreak: function(P, D) {
                var F = D.options;
                return {
                  type: "html",
                  content: F.softbreak
                };
              },
              linebreak: function() {
                return {
                  type: "html",
                  content: `<br />
`
                };
              },
              emph: function(P, D) {
                var F = D.entering;
                return {
                  type: F ? "openTag" : "closeTag",
                  tagName: "em"
                };
              },
              strong: function(P, D) {
                var F = D.entering;
                return {
                  type: F ? "openTag" : "closeTag",
                  tagName: "strong"
                };
              },
              paragraph: function(P, D) {
                var F, q = D.entering, ye = (F = P.parent) === null || F === void 0 ? void 0 : F.parent;
                return ye && ye.type === "list" && ye.listData.tight ? null : {
                  type: q ? "openTag" : "closeTag",
                  tagName: "p",
                  outerNewLine: !0
                };
              },
              thematicBreak: function() {
                return {
                  type: "openTag",
                  tagName: "hr",
                  outerNewLine: !0,
                  selfClose: !0
                };
              },
              blockQuote: function(P, D) {
                var F = D.entering;
                return {
                  type: F ? "openTag" : "closeTag",
                  tagName: "blockquote",
                  outerNewLine: !0,
                  innerNewLine: !0
                };
              },
              list: function(P, D) {
                var F = D.entering, q = P.listData, ye = q.type, Fe = q.start, Ze = ye === "bullet" ? "ul" : "ol", dt = {};
                return Ze === "ol" && Fe !== null && Fe !== 1 && (dt.start = Fe.toString()), {
                  type: F ? "openTag" : "closeTag",
                  tagName: Ze,
                  attributes: dt,
                  outerNewLine: !0
                };
              },
              item: function(P, D) {
                var F = D.entering;
                return {
                  type: F ? "openTag" : "closeTag",
                  tagName: "li",
                  outerNewLine: !0
                };
              },
              htmlInline: function(P, D) {
                var F = D.options, q = F.tagFilter ? w$(P.literal) : P.literal;
                return { type: "html", content: q };
              },
              htmlBlock: function(P, D) {
                var F = D.options, q = F.tagFilter ? w$(P.literal) : P.literal;
                return F.nodeId ? [
                  { type: "openTag", tagName: "div", outerNewLine: !0 },
                  { type: "html", content: q },
                  { type: "closeTag", tagName: "div", outerNewLine: !0 }
                ] : { type: "html", content: q, outerNewLine: !0 };
              },
              code: function(P) {
                return [
                  { type: "openTag", tagName: "code" },
                  { type: "text", content: P.literal },
                  { type: "closeTag", tagName: "code" }
                ];
              },
              codeBlock: function(P) {
                var D = P.info, F = D ? D.split(/\s+/) : [], q = [];
                return F.length > 0 && F[0].length > 0 && q.push("language-" + Uh(F[0])), [
                  { type: "openTag", tagName: "pre", outerNewLine: !0 },
                  { type: "openTag", tagName: "code", classNames: q },
                  { type: "text", content: P.literal },
                  { type: "closeTag", tagName: "code" },
                  { type: "closeTag", tagName: "pre", outerNewLine: !0 }
                ];
              },
              link: function(P, D) {
                var F = D.entering;
                if (F) {
                  var q = P, ye = q.title, Fe = q.destination;
                  return {
                    type: "openTag",
                    tagName: "a",
                    attributes: O({ href: Uh(Fe) }, ye && { title: Uh(ye) })
                  };
                }
                return { type: "closeTag", tagName: "a" };
              },
              image: function(P, D) {
                var F = D.getChildrenText, q = D.skipChildren, ye = P, Fe = ye.title, Ze = ye.destination;
                return q(), {
                  type: "openTag",
                  tagName: "img",
                  selfClose: !0,
                  attributes: O({ src: Uh(Ze), alt: F(P) }, Fe && { title: Uh(Fe) })
                };
              },
              customBlock: function(P, D, F) {
                var q = P.info.trim().toLowerCase(), ye = F[q];
                if (ye)
                  try {
                    return ye(P, D);
                  } catch (Fe) {
                    console.warn("[@toast-ui/editor] - The error occurred when " + q + " block node was parsed in markdown renderer: " + Fe);
                  }
                return [
                  { type: "openTag", tagName: "div", outerNewLine: !0 },
                  { type: "text", content: P.literal },
                  { type: "closeTag", tagName: "div", outerNewLine: !0 }
                ];
              },
              frontMatter: function(P) {
                return [
                  {
                    type: "openTag",
                    tagName: "div",
                    outerNewLine: !0,
                    // Because front matter is metadata, it should not be render.
                    attributes: { style: "white-space: pre; display: none;" }
                  },
                  { type: "text", content: P.literal },
                  { type: "closeTag", tagName: "div", outerNewLine: !0 }
                ];
              },
              customInline: function(P, D, F) {
                var q = P, ye = q.info, Fe = q.firstChild, Ze = ye.trim().toLowerCase(), dt = F[Ze], Bt = D.entering;
                if (dt)
                  try {
                    return dt(P, D);
                  } catch (Ut) {
                    console.warn("[@toast-ui/editor] - The error occurred when " + Ze + " inline node was parsed in markdown renderer: " + Ut);
                  }
                return Bt ? [
                  { type: "openTag", tagName: "span" },
                  { type: "text", content: "$$" + ye + (Fe ? " " : "") }
                ] : [
                  { type: "text", content: "$$" },
                  { type: "closeTag", tagName: "span" }
                ];
              }
            }, k$ = {
              strike: function(P, D) {
                var F = D.entering;
                return {
                  type: F ? "openTag" : "closeTag",
                  tagName: "del"
                };
              },
              item: function(P, D) {
                var F = D.entering, q = P.listData, ye = q.checked, Fe = q.task;
                if (F) {
                  var Ze = {
                    type: "openTag",
                    tagName: "li",
                    outerNewLine: !0
                  };
                  return Fe ? [
                    Ze,
                    {
                      type: "openTag",
                      tagName: "input",
                      selfClose: !0,
                      attributes: O(O({}, ye && { checked: "" }), { disabled: "", type: "checkbox" })
                    },
                    {
                      type: "text",
                      content: " "
                    }
                  ] : Ze;
                }
                return {
                  type: "closeTag",
                  tagName: "li",
                  outerNewLine: !0
                };
              },
              table: function(P, D) {
                var F = D.entering;
                return {
                  type: F ? "openTag" : "closeTag",
                  tagName: "table",
                  outerNewLine: !0
                };
              },
              tableHead: function(P, D) {
                var F = D.entering;
                return {
                  type: F ? "openTag" : "closeTag",
                  tagName: "thead",
                  outerNewLine: !0
                };
              },
              tableBody: function(P, D) {
                var F = D.entering;
                return {
                  type: F ? "openTag" : "closeTag",
                  tagName: "tbody",
                  outerNewLine: !0
                };
              },
              tableRow: function(P, D) {
                var F = D.entering;
                if (F)
                  return {
                    type: "openTag",
                    tagName: "tr",
                    outerNewLine: !0
                  };
                var q = [];
                if (P.lastChild)
                  for (var ye = P.parent.parent.columns.length, Fe = P.lastChild.endIdx, Ze = Fe + 1; Ze < ye; Ze += 1)
                    q.push({
                      type: "openTag",
                      tagName: "td",
                      outerNewLine: !0
                    }, {
                      type: "closeTag",
                      tagName: "td",
                      outerNewLine: !0
                    });
                return q.push({
                  type: "closeTag",
                  tagName: "tr",
                  outerNewLine: !0
                }), q;
              },
              tableCell: function(P, D) {
                var F = D.entering;
                if (P.ignored)
                  return {
                    type: "text",
                    content: ""
                  };
                var q = P.parent.parent, ye = q.type === "tableHead" ? "th" : "td", Fe = q.parent, Ze = Fe.columns[P.startIdx], dt = Ze != null && Ze.align ? { align: Ze.align } : null;
                return F ? O({ type: "openTag", tagName: ye, outerNewLine: !0 }, dt && { attributes: dt }) : {
                  type: "closeTag",
                  tagName: ye,
                  outerNewLine: !0
                };
              }
            }, _J = {
              softbreak: `
`,
              gfm: !1,
              tagFilter: !1,
              nodeId: !1
            };
            function NJ(P) {
              for (var D = [], F = P.walker(), q = null; q = F.next(); ) {
                var ye = q.node;
                ye.type === "text" && D.push(ye.literal);
              }
              return D.join("");
            }
            var BJ = (
              /** @class */
              function() {
                function P(D) {
                  this.buffer = [], this.options = O(O({}, _J), D), this.convertors = this.createConvertors(), delete this.options.convertors;
                }
                return P.prototype.createConvertors = function() {
                  var D = O({}, x$);
                  if (this.options.gfm && (D = O(O({}, D), k$)), this.options.convertors) {
                    var F = this.options.convertors, q = Object.keys(F), ye = O(O({}, x$), k$);
                    q.forEach(function(Fe) {
                      var Ze = D[Fe], dt = F[Fe], Bt = Object.keys(ye).indexOf(Fe) === -1 ? Fe.toLowerCase() : Fe;
                      Ze ? D[Bt] = function(Ut, sr, fr) {
                        return sr.origin = function() {
                          return Ze(Ut, sr, fr);
                        }, dt(Ut, sr);
                      } : D[Bt] = dt;
                    });
                  }
                  return D;
                }, P.prototype.getConvertors = function() {
                  return this.convertors;
                }, P.prototype.getOptions = function() {
                  return this.options;
                }, P.prototype.render = function(D) {
                  var F = this;
                  this.buffer = [];
                  for (var q = D.walker(), ye = null, Fe = function() {
                    var dt = ye.node, Bt = ye.entering, Ut = Ze.convertors[dt.type];
                    if (!Ut)
                      return "continue";
                    var sr = !1, fr = {
                      entering: Bt,
                      leaf: !cH(dt),
                      options: Ze.options,
                      getChildrenText: NJ,
                      skipChildren: function() {
                        sr = !0;
                      }
                    }, ar = UW(dt) || RK(dt) ? Ut(dt, fr, Ze.convertors) : Ut(dt, fr);
                    if (ar) {
                      var wr = Array.isArray(ar) ? ar : [ar];
                      wr.forEach(function(Sr, Jr) {
                        Sr.type === "openTag" && F.options.nodeId && Jr === 0 && (Sr.attributes || (Sr.attributes = {}), Sr.attributes["data-nodeid"] = String(dt.id)), F.renderHTMLNode(Sr);
                      }), sr && (q.resumeAt(dt, !1), q.next());
                    }
                  }, Ze = this; ye = q.next(); )
                    Fe();
                  return this.addNewLine(), this.buffer.join("");
                }, P.prototype.renderHTMLNode = function(D) {
                  switch (D.type) {
                    case "openTag":
                    case "closeTag":
                      this.renderElementNode(D);
                      break;
                    case "text":
                      this.renderTextNode(D);
                      break;
                    case "html":
                      this.renderRawHtmlNode(D);
                      break;
                  }
                }, P.prototype.generateOpenTagString = function(D) {
                  var F = this, q = D.tagName, ye = D.classNames, Fe = D.attributes;
                  this.buffer.push("<" + q), ye && ye.length > 0 && this.buffer.push(' class="' + ye.join(" ") + '"'), Fe && Object.keys(Fe).forEach(function(Ze) {
                    var dt = Fe[Ze];
                    F.buffer.push(" " + Ze + '="' + dt + '"');
                  }), D.selfClose && this.buffer.push(" /"), this.buffer.push(">");
                }, P.prototype.generateCloseTagString = function(D) {
                  var F = D.tagName;
                  this.buffer.push("</" + F + ">");
                }, P.prototype.addNewLine = function() {
                  this.buffer.length && Ow(Ow(this.buffer)) !== `
` && this.buffer.push(`
`);
                }, P.prototype.addOuterNewLine = function(D) {
                  D.outerNewLine && this.addNewLine();
                }, P.prototype.addInnerNewLine = function(D) {
                  D.innerNewLine && this.addNewLine();
                }, P.prototype.renderTextNode = function(D) {
                  this.buffer.push(Uh(D.content));
                }, P.prototype.renderRawHtmlNode = function(D) {
                  this.addOuterNewLine(D), this.buffer.push(D.content), this.addOuterNewLine(D);
                }, P.prototype.renderElementNode = function(D) {
                  D.type === "openTag" ? (this.addOuterNewLine(D), this.generateOpenTagString(D), D.selfClose ? this.addOuterNewLine(D) : this.addInnerNewLine(D)) : (this.addInnerNewLine(D), this.generateCloseTagString(D), this.addOuterNewLine(D));
                }, P;
              }()
            ), FJ = m(956), zJ = /* @__PURE__ */ m.n(FJ), HJ = m(969), O$ = /* @__PURE__ */ m.n(HJ), jJ = m(348), C$ = /* @__PURE__ */ m.n(jJ), WJ = m(349), T$ = /* @__PURE__ */ m.n(WJ), $J = m(204), A$ = /* @__PURE__ */ m.n($J), UJ = m(462), CH = /* @__PURE__ */ m.n(UJ), VJ = m(522), E$ = /* @__PURE__ */ m.n(VJ), GJ = m(990), YJ = /* @__PURE__ */ m.n(GJ), qJ = m(322), KJ = /* @__PURE__ */ m.n(qJ), XJ = m(758), JJ = /* @__PURE__ */ m.n(XJ), ZJ = m(929), Rw = /* @__PURE__ */ m.n(ZJ), QJ = m(714), eZ = /* @__PURE__ */ m.n(QJ);
            m(471);
            var M$ = "[A-Za-z][A-Za-z0-9-]*", tZ = "[a-zA-Z_:][a-zA-Z0-9:._-]*", rZ = "[^\"'=<>`\\x00-\\x20]+", nZ = "'[^']*'", iZ = '"[^"]*"', aZ = "(?:" + rZ + "|" + nZ + "|" + iZ + ")", oZ = "(?:\\s*=\\s*" + aZ + ")", R$ = "(?:\\s+" + tZ + oZ + "?)", sZ = "<(" + M$ + ")(" + R$ + ")*\\s*/?>", lZ = "</(" + M$ + ")\\s*[>]", uZ = "(?:" + sZ + "|" + lZ + ")", D$ = new RegExp("^" + uZ, "i");
            m(934), m(391);
            function TH(P, D) {
              return P.indexOf(D) !== -1;
            }
            var cZ = ["rel", "target", "hreflang", "type"];
            function fZ(P) {
              if (!P)
                return null;
              var D = {};
              return cZ.forEach(function(F) {
                Rw()(P[F]) || (D[F] = P[F]);
              }), D;
            }
            function dZ(P) {
              return P[P.length - 1];
            }
            function AH(P) {
              return typeof P == "object" && P !== null;
            }
            function EH(P, D) {
              var F = S({}, P);
              return P && D && Object.keys(D).forEach(function(q) {
                AH(F[q]) ? Array.isArray(D[q]) ? F[q] = MH(D[q]) : F.hasOwnProperty(q) ? F[q] = EH(F[q], D[q]) : F[q] = RH(D[q]) : F[q] = D[q];
              }), F;
            }
            function MH(P) {
              return P.map(function(D) {
                return AH(D) ? Array.isArray(D) ? MH(D) : RH(D) : D;
              });
            }
            function RH(P) {
              var D = Object.keys(P);
              return D.length ? D.reduce(function(F, q) {
                return AH(P[q]) ? F[q] = Array.isArray(P[q]) ? MH(P[q]) : RH(P[q]) : F[q] = P[q], F;
              }, {}) : P;
            }
            function P$(P, D) {
              return D === void 0 && (D = {}), Object.keys(D).forEach(function(F) {
                P.hasOwnProperty(F) && typeof P[F] == "object" ? Array.isArray(D[F]) ? P[F] = D[F] : P$(P[F], D[F]) : P[F] = D[F];
              }), P;
            }
            function L$(P, D) {
              return P > D ? [D, P] : [P, D];
            }
            function hZ(P, D, F) {
              var q = parseInt(P.left, 10), ye = parseInt(P.top, 10), Fe = parseInt(P.width, 10) + parseInt(P.paddingLeft, 10) + parseInt(P.paddingRight, 10), Ze = parseInt(P.height, 10) + parseInt(P.paddingTop, 10) + parseInt(P.paddingBottom, 10);
              return D >= q && D <= q + Fe && F >= ye && F <= ye + Ze;
            }
            var pZ = "toastui-editor-";
            function Dw() {
              for (var P = [], D = 0; D < arguments.length; D++)
                P[D] = arguments[D];
              for (var F = [], q = 0, ye = P; q < ye.length; q++) {
                var Fe = ye[q], Ze = void 0;
                Array.isArray(Fe) ? Ze = Fe[0] ? Fe[1] : null : Ze = Fe, Ze && F.push("" + pZ + Ze);
              }
              return F.join(" ");
            }
            function I$(P) {
              P.parentNode && P.parentNode.removeChild(P);
            }
            function _$(P, D, F) {
              Rw()(F) && (F = !eZ()(P, D));
              var q = F ? A$() : CH();
              q(P, D);
            }
            function vZ(P, D) {
              var F = document.createElement("div");
              JJ()(P) ? F.innerHTML = P : F.appendChild(P);
              var q = F.firstChild;
              return q;
            }
            function mZ(P) {
              var D = /<img class="ProseMirror-separator" alt="">/g, F = / class="ProseMirror-trailingBreak"/g, q = P;
              return q = q.replace(D, ""), q = q.replace(F, ""), q;
            }
            var gZ = m(294), N$ = /* @__PURE__ */ m.n(gZ);
            function yZ(P) {
              return P.sourcepos[0][1];
            }
            function bZ(P) {
              switch (P.type) {
                case "code":
                case "text":
                case "emph":
                case "strong":
                case "strike":
                case "link":
                case "image":
                case "htmlInline":
                case "linebreak":
                case "softbreak":
                case "customInline":
                  return !0;
                default:
                  return !1;
              }
            }
            function SZ(P, D, F) {
              for (F === void 0 && (F = !0), P = F ? P : P.parent; P && P.type !== "document"; ) {
                if (D(P))
                  return P;
                P = P.parent;
              }
              return null;
            }
            function wZ(P) {
              var D = P.firstChild.literal;
              switch (P.type) {
                case "emph":
                  return "*" + D + "*";
                case "strong":
                  return "**" + D + "**";
                case "strike":
                  return "~~" + D + "~~";
                case "code":
                  return "`" + D + "`";
                case "link":
                case "image":
                  var F = P, q = F.destination, ye = F.title, Fe = P.type === "link" ? "" : "!";
                  return Fe + "[" + D + "](" + q + (ye ? ' "' + ye + '"' : "") + ")";
                default:
                  return null;
              }
            }
            var xZ = {}, B$ = /\$\$widget\d+\s/;
            function F$(P) {
              var D = P.search(B$);
              if (D !== -1) {
                var F = P.substring(D), q = F.replace(B$, "").replace("$$", "");
                P = P.substring(0, D), P += F$(q);
              }
              return P;
            }
            function kZ(P, D) {
              var F = xZ[P], q = F.rule, ye = F.toDOM, Fe = F$(D).match(q);
              return Fe && (D = Fe[0]), ye(D);
            }
            function OZ(P) {
              for (var D, F = "", q = P.walker(); D = q.next(); ) {
                var ye = D.node, Fe = D.entering;
                Fe && (ye !== P && ye.type !== "text" ? (F += wZ(ye), q.resumeAt(P, !1), q.next()) : ye.type === "text" && (F += ye.literal));
              }
              return F;
            }
            var CZ = m(368), TZ = /* @__PURE__ */ m.n(CZ), AZ = ["iframe", "embed"], z$ = [];
            function EZ(P) {
              TH(AZ, P) && z$.push(P.toLowerCase());
            }
            function MZ(P, D) {
              return TZ().sanitize(P, S({ ADD_TAGS: z$, ADD_ATTR: ["rel", "target", "hreflang", "type"], FORBID_TAGS: [
                "input",
                "script",
                "textarea",
                "form",
                "button",
                "select",
                "meta",
                "style",
                "link",
                "title",
                "object",
                "base"
              ] }, D));
            }
            function RZ(P, D) {
              return P.literal.replace(new RegExp("(<\\s*" + D + "[^>]*>)|(</" + D + "\\s*[>])", "ig"), "").trim();
            }
            function DZ(P) {
              P = P.match(D$)[0];
              var D = P.match(new RegExp(R$, "g"));
              return D ? D.reduce(function(F, q) {
                var ye = q.trim().split("="), Fe = ye[0], Ze = ye.slice(1);
                return Ze.length && (F[Fe] = Ze.join("=").replace(/'|"/g, "").trim()), F;
              }, {}) : {};
            }
            var PZ = /^\s*<\s*\//, LZ = {
              paragraph: function(P, D) {
                var F = D.entering, q = D.origin, ye = D.options;
                return ye.nodeId ? {
                  type: F ? "openTag" : "closeTag",
                  outerNewLine: !0,
                  tagName: "p"
                } : q();
              },
              softbreak: function(P) {
                var D = P.prev && P.prev.type === "htmlInline", F = D && /<br ?\/?>/.test(P.prev.literal), q = F ? `
` : `<br>
`;
                return { type: "html", content: q };
              },
              item: function(P, D) {
                var F = D.entering;
                if (F) {
                  var q = {}, ye = [];
                  return P.listData.task && (q["data-task"] = "", ye.push("task-list-item"), P.listData.checked && (ye.push("checked"), q["data-task-checked"] = "")), {
                    type: "openTag",
                    tagName: "li",
                    classNames: ye,
                    attributes: q,
                    outerNewLine: !0
                  };
                }
                return {
                  type: "closeTag",
                  tagName: "li",
                  outerNewLine: !0
                };
              },
              code: function(P) {
                var D = { "data-backticks": String(P.tickCount) };
                return [
                  { type: "openTag", tagName: "code", attributes: D },
                  { type: "text", content: P.literal },
                  { type: "closeTag", tagName: "code" }
                ];
              },
              codeBlock: function(P) {
                var D = P, F = D.fenceLength, q = D.info, ye = q ? q.split(/\s+/) : [], Fe = [], Ze = {};
                if (F > 3 && (Ze["data-backticks"] = F), ye.length > 0 && ye[0].length > 0) {
                  var dt = ye[0];
                  Fe.push("lang-" + dt), Ze["data-language"] = dt;
                }
                return [
                  { type: "openTag", tagName: "pre", classNames: Fe },
                  { type: "openTag", tagName: "code", attributes: Ze },
                  { type: "text", content: P.literal },
                  { type: "closeTag", tagName: "code" },
                  { type: "closeTag", tagName: "pre" }
                ];
              },
              customInline: function(P, D) {
                var F = D.origin, q = D.entering, ye = D.skipChildren, Fe = P.info;
                if (Fe.indexOf("widget") !== -1 && q) {
                  ye();
                  var Ze = OZ(P), dt = kZ(Fe, Ze).outerHTML;
                  return [
                    { type: "openTag", tagName: "span", classNames: ["tui-widget"] },
                    { type: "html", content: dt },
                    { type: "closeTag", tagName: "span" }
                  ];
                }
                return F();
              }
            };
            function IZ(P, D) {
              var F = S({}, LZ);
              return P && (F.link = function(q, ye) {
                var Fe = ye.entering, Ze = ye.origin, dt = Ze();
                return Fe && (dt.attributes = S(S({}, dt.attributes), P)), dt;
              }), D && Object.keys(D).forEach(function(q) {
                var ye = F[q], Fe = D[q];
                ye && N$()(Fe) ? F[q] = function(Ze, dt) {
                  var Bt = S({}, dt);
                  return Bt.origin = function() {
                    return ye(Ze, dt);
                  }, Fe(Ze, Bt);
                } : TH(["htmlBlock", "htmlInline"], q) && !N$()(Fe) ? F[q] = function(Ze, dt) {
                  var Bt = Ze.literal.match(D$);
                  if (Bt) {
                    var Ut = Bt[0], sr = Bt[1], fr = Bt[3], ar = (sr || fr).toLowerCase(), wr = Fe[ar], Sr = RZ(Ze, ar);
                    if (wr) {
                      var Jr = S({}, Ze);
                      return Jr.attrs = DZ(Ut), Jr.childrenHTML = Sr, Jr.type = ar, dt.entering = !PZ.test(Ze.literal), wr(Jr, dt);
                    }
                  }
                  return dt.origin();
                } : F[q] = Fe;
              }), F;
            }
            var _Z = ["UL", "OL", "BLOCKQUOTE"];
            function NZ(P, D) {
              for (var F = 0; P && P !== D && (TH(_Z, P.tagName) || (F += P.offsetTop), P.offsetParent !== D.offsetParent); )
                P = P.parentElement;
              return F;
            }
            function BZ(P, D) {
              for (var F = D, q = null; F; ) {
                var ye = F.firstElementChild;
                if (!ye)
                  break;
                var Fe = H$(ye, P, NZ(F, D));
                q = F, F = Fe;
              }
              var Ze = F || q;
              return Ze === D ? null : Ze;
            }
            function H$(P, D, F) {
              return P && D > F + P.offsetTop ? H$(P.nextElementSibling, D, F) || P : null;
            }
            var FZ = {};
            function DH(P) {
              P && (delete FZ[Number(P.getAttribute("data-nodeid"))], YJ()(P.children).forEach(function(D) {
                DH(D);
              }));
            }
            var PH = Dw("md-preview-highlight");
            function zZ(P, D) {
              for (var F = P.firstChild; F && F.next && !(yZ(F.next) > D + 1); )
                F = F.next;
              return F;
            }
            var HZ = (
              /** @class */
              function() {
                function P(D, F) {
                  var q = document.createElement("div");
                  this.el = q, this.eventEmitter = D, this.isViewer = !!F.isViewer, this.el.className = Dw("md-preview");
                  var ye = F.linkAttributes, Fe = F.customHTMLRenderer, Ze = F.sanitizer, dt = F.highlight, Bt = dt === void 0 ? !1 : dt;
                  this.renderer = new BJ({
                    gfm: !0,
                    nodeId: !0,
                    convertors: IZ(ye, Fe)
                  }), this.cursorNodeId = null, this.sanitizer = Ze, this.initEvent(Bt), this.initContentSection(), this.isViewer && (this.previewContent.style.overflowWrap = "break-word");
                }
                return P.prototype.initContentSection = function() {
                  this.previewContent = vZ('<div class="' + Dw("contents") + '"></div>'), this.isViewer || this.el.appendChild(this.previewContent);
                }, P.prototype.toggleActive = function(D) {
                  _$(this.el, "active", D);
                }, P.prototype.initEvent = function(D) {
                  var F = this;
                  this.eventEmitter.listen("updatePreview", this.update.bind(this)), !this.isViewer && (D && (this.eventEmitter.listen("changeToolbarState", function(q) {
                    var ye = q.mdNode, Fe = q.cursorPos;
                    F.updateCursorNode(ye, Fe);
                  }), this.eventEmitter.listen("blur", function() {
                    F.removeHighlight();
                  })), C$()(this.el, "scroll", function(q) {
                    F.eventEmitter.emit("scroll", "preview", BZ(q.target.scrollTop, F.previewContent));
                  }), this.eventEmitter.listen("changePreviewTabPreview", function() {
                    return F.toggleActive(!0);
                  }), this.eventEmitter.listen("changePreviewTabWrite", function() {
                    return F.toggleActive(!1);
                  }));
                }, P.prototype.removeHighlight = function() {
                  if (this.cursorNodeId) {
                    var D = this.getElementByNodeId(this.cursorNodeId);
                    D && CH()(D, PH);
                  }
                }, P.prototype.updateCursorNode = function(D, F) {
                  D && (D = SZ(D, function(Ze) {
                    return !bZ(Ze);
                  }), D.type === "tableRow" ? D = zZ(D, F[1]) : D.type === "tableBody" && (D = null));
                  var q = D ? D.id : null;
                  if (this.cursorNodeId !== q) {
                    var ye = this.getElementByNodeId(this.cursorNodeId), Fe = this.getElementByNodeId(q);
                    ye && CH()(ye, PH), Fe && A$()(Fe, PH), this.cursorNodeId = q;
                  }
                }, P.prototype.getElementByNodeId = function(D) {
                  return D ? this.previewContent.querySelector('[data-nodeid="' + D + '"]') : null;
                }, P.prototype.update = function(D) {
                  var F = this;
                  D.forEach(function(q) {
                    return F.replaceRangeNodes(q);
                  }), this.eventEmitter.emit("afterPreviewRender", this);
                }, P.prototype.replaceRangeNodes = function(D) {
                  var F = this, q = D.nodes, ye = D.removedNodeRange, Fe = this.previewContent, Ze = this.eventEmitter.emitReduce("beforePreviewRender", this.sanitizer(q.map(function(Sr) {
                    return F.renderer.render(Sr);
                  }).join("")));
                  if (!ye)
                    Fe.insertAdjacentHTML("afterbegin", Ze);
                  else {
                    var dt = ye.id, Bt = dt[0], Ut = dt[1], sr = this.getElementByNodeId(Bt), fr = this.getElementByNodeId(Ut);
                    if (sr) {
                      sr.insertAdjacentHTML("beforebegin", Ze);
                      for (var ar = sr; ar && ar !== fr; ) {
                        var wr = ar.nextElementSibling;
                        I$(ar), DH(ar), ar = wr;
                      }
                      ar != null && ar.parentNode && (I$(ar), DH(ar));
                    }
                  }
                }, P.prototype.getRenderer = function() {
                  return this.renderer;
                }, P.prototype.destroy = function() {
                  T$()(this.el, "scroll"), this.el = null;
                }, P.prototype.getElement = function() {
                  return this.el;
                }, P.prototype.getHTML = function() {
                  return mZ(this.previewContent.innerHTML);
                }, P.prototype.setHTML = function(D) {
                  this.previewContent.innerHTML = D;
                }, P.prototype.setHeight = function(D) {
                  E$()(this.el, { height: D + "px" });
                }, P.prototype.setMinHeight = function(D) {
                  E$()(this.el, { minHeight: D + "px" });
                }, P;
              }()
            ), jZ = HZ, Pw = m(814), LH = m(479), j$ = m(311), WZ = m(481), $Z = m(43), UZ = m(928), VZ = /* @__PURE__ */ m.n(UZ), GZ = (
              /** @class */
              function() {
                function P() {
                  this.keys = [], this.values = [];
                }
                return P.prototype.getKeyIndex = function(D) {
                  return VZ()(D, this.keys);
                }, P.prototype.get = function(D) {
                  return this.values[this.getKeyIndex(D)];
                }, P.prototype.set = function(D, F) {
                  var q = this.getKeyIndex(D);
                  return q > -1 ? this.values[q] = F : (this.keys.push(D), this.values.push(F)), this;
                }, P.prototype.has = function(D) {
                  return this.getKeyIndex(D) > -1;
                }, P.prototype.delete = function(D) {
                  var F = this.getKeyIndex(D);
                  return F > -1 ? (this.keys.splice(F, 1), this.values.splice(F, 1), !0) : !1;
                }, P.prototype.forEach = function(D, F) {
                  var q = this;
                  F === void 0 && (F = this), this.values.forEach(function(ye, Fe) {
                    ye && q.keys[Fe] && D.call(F, ye, q.keys[Fe], q);
                  });
                }, P.prototype.clear = function() {
                  this.keys = [], this.values = [];
                }, P;
              }()
            ), W$ = GZ, IH = "en-US", YZ = (
              /** @class */
              function() {
                function P() {
                  this.code = IH, this.langs = new W$();
                }
                return P.prototype.setCode = function(D) {
                  this.code = D || IH;
                }, P.prototype.setLanguage = function(D, F) {
                  var q = this;
                  D = [].concat(D), D.forEach(function(ye) {
                    if (!q.langs.has(ye))
                      q.langs.set(ye, F);
                    else {
                      var Fe = q.langs.get(ye);
                      q.langs.set(ye, O$()(Fe, F));
                    }
                  });
                }, P.prototype.get = function(D, F) {
                  F || (F = this.code);
                  var q = this.langs.get(F);
                  q || (q = this.langs.get(IH));
                  var ye = q[D];
                  if (!ye)
                    throw new Error('There is no text key "' + D + '" in ' + F);
                  return ye;
                }, P;
              }()
            ), qZ = new YZ();
            function KZ(P, D) {
              for (var F = P.depth; F; ) {
                var q = P.node(F);
                if (D(q, F))
                  return {
                    node: q,
                    depth: F,
                    offset: F > 0 ? P.before(F) : 0
                  };
                F -= 1;
              }
              return null;
            }
            var $$ = /* @__PURE__ */ new Map(), U$ = (
              /** @class */
              function() {
                function P(D, F, q, ye) {
                  this.table = D, this.tableRows = F, this.tableStartPos = q, this.rowInfo = ye;
                }
                return P.create = function(D) {
                  var F = KZ(D, function(Sr) {
                    var Jr = Sr.type;
                    return Jr.name === "table";
                  });
                  if (F) {
                    var q = F.node, ye = F.depth, Fe = F.offset, Ze = $$.get(q);
                    if ((Ze == null ? void 0 : Ze.tableStartPos) === Fe + 1)
                      return Ze;
                    var dt = [], Bt = D.start(ye), Ut = q.child(0), sr = q.child(1), fr = _H(Ut, Bt), ar = _H(sr, Bt + Ut.nodeSize);
                    Ut.forEach(function(Sr) {
                      return dt.push(Sr);
                    }), sr.forEach(function(Sr) {
                      return dt.push(Sr);
                    });
                    var wr = new P(q, dt, Bt, fr.concat(ar));
                    return $$.set(q, wr), wr;
                  }
                  return null;
                }, Object.defineProperty(P.prototype, "totalRowCount", {
                  get: function() {
                    return this.rowInfo.length;
                  },
                  enumerable: !1,
                  configurable: !0
                }), Object.defineProperty(P.prototype, "totalColumnCount", {
                  get: function() {
                    return this.rowInfo[0].length;
                  },
                  enumerable: !1,
                  configurable: !0
                }), Object.defineProperty(P.prototype, "tableStartOffset", {
                  get: function() {
                    return this.tableStartPos;
                  },
                  enumerable: !1,
                  configurable: !0
                }), Object.defineProperty(P.prototype, "tableEndOffset", {
                  get: function() {
                    return this.tableStartPos + this.table.nodeSize - 1;
                  },
                  enumerable: !1,
                  configurable: !0
                }), P.prototype.getCellInfo = function(D, F) {
                  return this.rowInfo[D][F];
                }, P.prototype.posAt = function(D, F) {
                  for (var q = 0, ye = this.tableStartPos; ; q += 1) {
                    var Fe = ye + this.tableRows[q].nodeSize;
                    if (q === D) {
                      for (var Ze = F; Ze < this.totalColumnCount && this.rowInfo[q][Ze].offset < ye; )
                        Ze += 1;
                      return Ze === this.totalColumnCount ? Fe : this.rowInfo[q][Ze].offset;
                    }
                    ye = Fe;
                  }
                }, P.prototype.getNodeAndPos = function(D, F) {
                  var q = this.rowInfo[D][F];
                  return {
                    node: this.table.nodeAt(q.offset - this.tableStartOffset),
                    pos: q.offset
                  };
                }, P.prototype.extendedRowspan = function(D, F) {
                  return !1;
                }, P.prototype.extendedColspan = function(D, F) {
                  return !1;
                }, P.prototype.getRowspanCount = function(D, F) {
                  return 0;
                }, P.prototype.getColspanCount = function(D, F) {
                  return 0;
                }, P.prototype.decreaseColspanCount = function(D, F) {
                  return 0;
                }, P.prototype.decreaseRowspanCount = function(D, F) {
                  return 0;
                }, P.prototype.getColspanStartInfo = function(D, F) {
                  return null;
                }, P.prototype.getRowspanStartInfo = function(D, F) {
                  return null;
                }, P.prototype.getCellStartOffset = function(D, F) {
                  var q = this.rowInfo[D][F].offset;
                  return this.extendedRowspan(D, F) ? this.posAt(D, F) : q;
                }, P.prototype.getCellEndOffset = function(D, F) {
                  var q = this.rowInfo[D][F], ye = q.offset, Fe = q.nodeSize;
                  return this.extendedRowspan(D, F) ? this.posAt(D, F) : ye + Fe;
                }, P.prototype.getCellIndex = function(D) {
                  for (var F = 0; F < this.totalRowCount; F += 1)
                    for (var q = this.rowInfo[F], ye = 0; ye < this.totalColumnCount; ye += 1)
                      if (q[ye].offset + 1 > D.pos)
                        return [F, ye];
                  return [0, 0];
                }, P.prototype.getRectOffsets = function(D, F) {
                  var q, ye, Fe;
                  F === void 0 && (F = D), D.pos > F.pos && (q = [F, D], D = q[0], F = q[1]);
                  var Ze = this.getCellIndex(D), dt = Ze[0], Bt = Ze[1], Ut = this.getCellIndex(F), sr = Ut[0], fr = Ut[1];
                  return ye = L$(dt, sr), dt = ye[0], sr = ye[1], Fe = L$(Bt, fr), Bt = Fe[0], fr = Fe[1], this.getSpannedOffsets({ startRowIdx: dt, startColIdx: Bt, endRowIdx: sr, endColIdx: fr });
                }, P.prototype.getSpannedOffsets = function(D) {
                  return D;
                }, P;
              }()
            ), _H = function(P, D) {
              var F = [];
              return P.forEach(function(q, ye) {
                var Fe = { rowspanMap: {}, colspanMap: {}, length: 0 };
                q.forEach(function(Ze, dt) {
                  for (var Bt = Ze.nodeSize, Ut = 0; Fe[Ut]; )
                    Ut += 1;
                  Fe[Ut] = {
                    // 2 is the sum of the front and back positions of the tag
                    offset: D + ye + dt + 2,
                    nodeSize: Bt
                  }, Fe.length += 1;
                }), F.push(Fe);
              }), F;
            };
            function XZ(P, D) {
              return P$(U$.prototype, P), _H = D, U$;
            }
            function JZ(P) {
              var D = P.plugin, F = P.eventEmitter, q = P.usageStatistics, ye = P.instance, Fe = { Plugin: Pw.Plugin, PluginKey: Pw.PluginKey, Selection: Pw.Selection, TextSelection: Pw.TextSelection }, Ze = { Decoration: j$.Decoration, DecorationSet: j$.DecorationSet }, dt = { Fragment: $Z.Fragment }, Bt = { InputRule: LH.InputRule, inputRules: LH.inputRules, undoInputRule: LH.undoInputRule }, Ut = { keymap: WZ.keymap }, sr = {
                eventEmitter: F,
                usageStatistics: q,
                instance: ye,
                pmState: Fe,
                pmView: Ze,
                pmModel: dt,
                pmRules: Bt,
                pmKeymap: Ut,
                i18n: qZ
              };
              if (KJ()(D)) {
                var fr = D[0], ar = D[1], wr = ar === void 0 ? {} : ar;
                return fr(sr, wr);
              }
              return D(sr);
            }
            function ZZ(P) {
              var D = P.plugins, F = P.eventEmitter, q = P.usageStatistics, ye = P.instance;
              return F.listen("mixinTableOffsetMapPrototype", XZ), (D ?? []).reduce(function(Fe, Ze) {
                var dt = JZ({
                  plugin: Ze,
                  eventEmitter: F,
                  usageStatistics: q,
                  instance: ye
                });
                if (!dt)
                  throw new Error("The return value of the executed plugin is empty.");
                var Bt = dt.markdownParsers, Ut = dt.toHTMLRenderers, sr = dt.toMarkdownRenderers, fr = dt.markdownPlugins, ar = dt.wysiwygPlugins, wr = dt.wysiwygNodeViews, Sr = dt.markdownCommands, Jr = dt.wysiwygCommands, _n = dt.toolbarItems;
                return Ut && (Fe.toHTMLRenderers = EH(Fe.toHTMLRenderers, Ut)), sr && (Fe.toMarkdownRenderers = EH(Fe.toMarkdownRenderers, sr)), fr && (Fe.mdPlugins = Fe.mdPlugins.concat(fr)), ar && (Fe.wwPlugins = Fe.wwPlugins.concat(ar)), wr && (Fe.wwNodeViews = S(S({}, Fe.wwNodeViews), wr)), Sr && (Fe.mdCommands = S(S({}, Fe.mdCommands), Sr)), Jr && (Fe.wwCommands = S(S({}, Fe.wwCommands), Jr)), _n && (Fe.toolbarItems = Fe.toolbarItems.concat(_n)), Bt && (Fe.markdownParsers = S(S({}, Fe.markdownParsers), Bt)), Fe;
              }, {
                toHTMLRenderers: {},
                toMarkdownRenderers: {},
                mdPlugins: [],
                wwPlugins: [],
                wwNodeViews: {},
                mdCommands: {},
                wwCommands: {},
                toolbarItems: [],
                markdownParsers: {}
              });
            }
            var QZ = m(404), eQ = /* @__PURE__ */ m.n(QZ), V$ = [
              "afterPreviewRender",
              "updatePreview",
              "changeMode",
              "needChangeMode",
              "command",
              "changePreviewStyle",
              "changePreviewTabPreview",
              "changePreviewTabWrite",
              "scroll",
              "contextmenu",
              "show",
              "hide",
              "changeLanguage",
              "changeToolbarState",
              "toggleScrollSync",
              "mixinTableOffsetMapPrototype",
              "setFocusedNode",
              "removePopupWidget",
              "query",
              // provide event for user
              "openPopup",
              "closePopup",
              "addImageBlobHook",
              "beforePreviewRender",
              "beforeConvertWysiwygToMarkdown",
              "load",
              "loadUI",
              "change",
              "caretChange",
              "destroy",
              "focus",
              "blur",
              "keydown",
              "keyup"
            ], tQ = (
              /** @class */
              function() {
                function P() {
                  var D = this;
                  this.events = new W$(), this.eventTypes = V$.reduce(function(F, q) {
                    return S(S({}, F), { type: q });
                  }, {}), this.hold = !1, V$.forEach(function(F) {
                    D.addEventType(F);
                  });
                }
                return P.prototype.listen = function(D, F) {
                  var q = this.getTypeInfo(D), ye = this.events.get(q.type) || [];
                  if (!this.hasEventType(q.type))
                    throw new Error("There is no event type " + q.type);
                  q.namespace && (F.namespace = q.namespace), ye.push(F), this.events.set(q.type, ye);
                }, P.prototype.emit = function(D) {
                  for (var F = [], q = 1; q < arguments.length; q++)
                    F[q - 1] = arguments[q];
                  var ye = this.getTypeInfo(D), Fe = this.events.get(ye.type), Ze = [];
                  return !this.hold && Fe && Fe.forEach(function(dt) {
                    var Bt = dt.apply(void 0, F);
                    Rw()(Bt) || Ze.push(Bt);
                  }), Ze;
                }, P.prototype.emitReduce = function(D, F) {
                  for (var q = [], ye = 2; ye < arguments.length; ye++)
                    q[ye - 2] = arguments[ye];
                  var Fe = this.events.get(D);
                  return !this.hold && Fe && Fe.forEach(function(Ze) {
                    var dt = Ze.apply(void 0, x([F], q));
                    eQ()(dt) || (F = dt);
                  }), F;
                }, P.prototype.getTypeInfo = function(D) {
                  var F = D.split(".");
                  return {
                    type: F[0],
                    namespace: F[1]
                  };
                }, P.prototype.hasEventType = function(D) {
                  return !Rw()(this.eventTypes[this.getTypeInfo(D).type]);
                }, P.prototype.addEventType = function(D) {
                  if (this.hasEventType(D))
                    throw new Error("There is already have event type " + D);
                  this.eventTypes[D] = D;
                }, P.prototype.removeEventHandler = function(D, F) {
                  var q = this, ye = this.getTypeInfo(D), Fe = ye.type, Ze = ye.namespace;
                  Fe && F ? this.removeEventHandlerWithHandler(Fe, F) : Fe && !Ze ? this.events.delete(Fe) : !Fe && Ze ? this.events.forEach(function(dt, Bt) {
                    q.removeEventHandlerWithTypeInfo(Bt, Ze);
                  }) : Fe && Ze && this.removeEventHandlerWithTypeInfo(Fe, Ze);
                }, P.prototype.removeEventHandlerWithHandler = function(D, F) {
                  var q = this.events.get(D);
                  if (q) {
                    var ye = q.indexOf(F);
                    q.indexOf(F) >= 0 && q.splice(ye, 1);
                  }
                }, P.prototype.removeEventHandlerWithTypeInfo = function(D, F) {
                  var q = [], ye = this.events.get(D);
                  ye && (ye.map(function(Fe) {
                    return Fe.namespace !== F && q.push(Fe), null;
                  }), this.events.set(D, q));
                }, P.prototype.getEvents = function() {
                  return this.events;
                }, P.prototype.holdEventInvoke = function(D) {
                  this.hold = !0, D(), this.hold = !1;
                }, P;
              }()
            ), rQ = tQ, nQ = "data-task", iQ = "data-task-disabled", aQ = "checked";
            function oQ(P) {
              ["htmlBlock", "htmlInline"].forEach(function(D) {
                P[D] && Object.keys(P[D]).forEach(function(F) {
                  return EZ(F);
                });
              });
            }
            var sQ = (
              /** @class */
              function() {
                function P(D) {
                  var F = this;
                  this.options = O$()({
                    linkAttributes: null,
                    extendedAutolinks: !1,
                    customHTMLRenderer: null,
                    referenceDefinition: !1,
                    customHTMLSanitizer: null,
                    frontMatter: !1,
                    usageStatistics: !0,
                    theme: "light"
                  }, D), this.eventEmitter = new rQ();
                  var q = fZ(this.options.linkAttributes), ye = ZZ({
                    plugins: this.options.plugins,
                    eventEmitter: this.eventEmitter,
                    usageStatistics: this.options.usageStatistics,
                    instance: this
                  }) || {}, Fe = ye.toHTMLRenderers, Ze = ye.markdownParsers, dt = this.options, Bt = dt.customHTMLRenderer, Ut = dt.extendedAutolinks, sr = dt.referenceDefinition, fr = dt.frontMatter, ar = dt.customHTMLSanitizer, wr = {
                    linkAttributes: q,
                    customHTMLRenderer: S(S({}, Fe), Bt),
                    extendedAutolinks: Ut,
                    referenceDefinition: sr,
                    frontMatter: fr,
                    sanitizer: ar || MZ
                  };
                  oQ(wr.customHTMLRenderer), this.options.events && zJ()(this.options.events, function(Do, co) {
                    F.on(co, Do);
                  });
                  var Sr = this.options, Jr = Sr.el, _n = Sr.initialValue, pi = Sr.theme, ul = Jr.innerHTML;
                  pi !== "light" && Jr.classList.add(Dw(pi)), Jr.innerHTML = "", this.toastMark = new LJ("", {
                    disallowedHtmlBlockTags: ["br", "img"],
                    extendedAutolinks: Ut,
                    referenceDefinition: sr,
                    disallowDeepHeading: !0,
                    frontMatter: fr,
                    customParser: Ze
                  }), this.preview = new jZ(this.eventEmitter, S(S({}, wr), { isViewer: !0 })), C$()(this.preview.previewContent, "mousedown", this.toggleTask.bind(this)), _n ? this.setMarkdown(_n) : ul && this.preview.setHTML(ul), Jr.appendChild(this.preview.previewContent), this.eventEmitter.emit("load", this);
                }
                return P.prototype.toggleTask = function(D) {
                  var F = D.target, q = getComputedStyle(F, ":before");
                  !F.hasAttribute(iQ) && F.hasAttribute(nQ) && hZ(q, D.offsetX, D.offsetY) && (_$(F, aQ), this.eventEmitter.emit("change", {
                    source: "viewer",
                    date: D
                  }));
                }, P.prototype.setMarkdown = function(D) {
                  var F = this.toastMark.getLineTexts(), q = F.length, ye = dZ(F), Fe = [q, ye.length + 1], Ze = this.toastMark.editMarkdown([1, 1], Fe, D || "");
                  this.eventEmitter.emit("updatePreview", Ze);
                }, P.prototype.on = function(D, F) {
                  this.eventEmitter.listen(D, F);
                }, P.prototype.off = function(D) {
                  this.eventEmitter.removeEventHandler(D);
                }, P.prototype.addHook = function(D, F) {
                  this.eventEmitter.removeEventHandler(D), this.eventEmitter.listen(D, F);
                }, P.prototype.destroy = function() {
                  T$()(this.preview.el, "mousedown", this.toggleTask.bind(this)), this.preview.destroy(), this.eventEmitter.emit("destroy");
                }, P.prototype.isViewer = function() {
                  return !0;
                }, P.prototype.isMarkdownMode = function() {
                  return !1;
                }, P.prototype.isWysiwygMode = function() {
                  return !1;
                }, P;
              }()
            ), lQ = sQ, uQ = lQ;
          }(), y = y.default, y;
        }()
      );
    });
  }(Lj)), Lj.exports;
}
var TGe = CGe();
const AGe = /* @__PURE__ */ Cp(TGe), EGe = (i, e) => {
  if (!i.value)
    throw new Error("Reference to the element is set");
  return new AGe({
    el: i.value,
    plugins: e.plugins !== void 0 ? q9(e.plugins) : void 0,
    initialValue: e.initialValue
  });
}, MGe = /* @__PURE__ */ (0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({
  __name: "Viewer",
  props: {
    value: {},
    plugins: { default: () => [] },
    darkMode: { type: Boolean, default: !1 }
  },
  setup(i) {
    const e = i, r = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(null);
    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(() => {
      EGe(r, {
        initialValue: e.value,
        plugins: e.plugins
      });
    }), (s, l) => ((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createElementBlock)("div", {
      class: (0,vue__WEBPACK_IMPORTED_MODULE_0__.normalizeClass)({ "toastui-editor-dark": s.darkMode }),
      ref_key: "viewer",
      ref: r
    }, null, 2));
  }
}), TV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Editor: bGe,
  Viewer: MGe
}, Symbol.toStringTag, { value: "Module" }));
function RGe(i) {
  for (const e in TV)
    i.component(e, TV[e]);
}
const PGe = { install: RGe };



/***/ }),

/***/ "./node_modules/uid/single/index.mjs":
/*!*******************************************!*\
  !*** ./node_modules/uid/single/index.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   uid: () => (/* binding */ uid)
/* harmony export */ });
var IDX=36, HEX='';
while (IDX--) HEX += IDX.toString(36);

function uid(len) {
	var str='', num = len || 11;
	while (num--) str += HEX[Math.random() * 36 | 0];
	return str;
}


/***/ }),

/***/ "./node_modules/vue-loader/dist/exportHelper.js":
/*!******************************************************!*\
  !*** ./node_modules/vue-loader/dist/exportHelper.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// runtime helper for setting properties on components
// in a tree-shakable way
exports["default"] = (sfc, props) => {
    const target = sfc.__vccOpts || sfc;
    for (const [key, val] of props) {
        target[key] = val;
    }
    return target;
};


/***/ }),

/***/ "./node_modules/vuex/dist/vuex.esm-bundler.js":
/*!****************************************************!*\
  !*** ./node_modules/vuex/dist/vuex.esm-bundler.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Store: () => (/* binding */ Store),
/* harmony export */   createLogger: () => (/* binding */ createLogger),
/* harmony export */   createNamespacedHelpers: () => (/* binding */ createNamespacedHelpers),
/* harmony export */   createStore: () => (/* binding */ createStore),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   mapActions: () => (/* binding */ mapActions),
/* harmony export */   mapGetters: () => (/* binding */ mapGetters),
/* harmony export */   mapMutations: () => (/* binding */ mapMutations),
/* harmony export */   mapState: () => (/* binding */ mapState),
/* harmony export */   storeKey: () => (/* binding */ storeKey),
/* harmony export */   useStore: () => (/* binding */ useStore)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _vue_devtools_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @vue/devtools-api */ "./node_modules/@vue/devtools-api/lib/esm/index.js");
/*!
 * vuex v4.1.0
 * (c) 2022 Evan You
 * @license MIT
 */



var storeKey = 'store';

function useStore (key) {
  if ( key === void 0 ) key = null;

  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.inject)(key !== null ? key : storeKey)
}

/**
 * Get the first item that pass the test
 * by second argument function
 *
 * @param {Array} list
 * @param {Function} f
 * @return {*}
 */
function find (list, f) {
  return list.filter(f)[0]
}

/**
 * Deep copy the given object considering circular structure.
 * This function caches all nested objects and its copies.
 * If it detects circular structure, use cached copy to avoid infinite loop.
 *
 * @param {*} obj
 * @param {Array<Object>} cache
 * @return {*}
 */
function deepCopy (obj, cache) {
  if ( cache === void 0 ) cache = [];

  // just return if obj is immutable value
  if (obj === null || typeof obj !== 'object') {
    return obj
  }

  // if obj is hit, it is in circular structure
  var hit = find(cache, function (c) { return c.original === obj; });
  if (hit) {
    return hit.copy
  }

  var copy = Array.isArray(obj) ? [] : {};
  // put the copy into cache at first
  // because we want to refer it in recursive deepCopy
  cache.push({
    original: obj,
    copy: copy
  });

  Object.keys(obj).forEach(function (key) {
    copy[key] = deepCopy(obj[key], cache);
  });

  return copy
}

/**
 * forEach for object
 */
function forEachValue (obj, fn) {
  Object.keys(obj).forEach(function (key) { return fn(obj[key], key); });
}

function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

function isPromise (val) {
  return val && typeof val.then === 'function'
}

function assert (condition, msg) {
  if (!condition) { throw new Error(("[vuex] " + msg)) }
}

function partial (fn, arg) {
  return function () {
    return fn(arg)
  }
}

function genericSubscribe (fn, subs, options) {
  if (subs.indexOf(fn) < 0) {
    options && options.prepend
      ? subs.unshift(fn)
      : subs.push(fn);
  }
  return function () {
    var i = subs.indexOf(fn);
    if (i > -1) {
      subs.splice(i, 1);
    }
  }
}

function resetStore (store, hot) {
  store._actions = Object.create(null);
  store._mutations = Object.create(null);
  store._wrappedGetters = Object.create(null);
  store._modulesNamespaceMap = Object.create(null);
  var state = store.state;
  // init all modules
  installModule(store, state, [], store._modules.root, true);
  // reset state
  resetStoreState(store, state, hot);
}

function resetStoreState (store, state, hot) {
  var oldState = store._state;
  var oldScope = store._scope;

  // bind store public getters
  store.getters = {};
  // reset local getters cache
  store._makeLocalGettersCache = Object.create(null);
  var wrappedGetters = store._wrappedGetters;
  var computedObj = {};
  var computedCache = {};

  // create a new effect scope and create computed object inside it to avoid
  // getters (computed) getting destroyed on component unmount.
  var scope = (0,vue__WEBPACK_IMPORTED_MODULE_0__.effectScope)(true);

  scope.run(function () {
    forEachValue(wrappedGetters, function (fn, key) {
      // use computed to leverage its lazy-caching mechanism
      // direct inline function use will lead to closure preserving oldState.
      // using partial to return function with only arguments preserved in closure environment.
      computedObj[key] = partial(fn, store);
      computedCache[key] = (0,vue__WEBPACK_IMPORTED_MODULE_0__.computed)(function () { return computedObj[key](); });
      Object.defineProperty(store.getters, key, {
        get: function () { return computedCache[key].value; },
        enumerable: true // for local getters
      });
    });
  });

  store._state = (0,vue__WEBPACK_IMPORTED_MODULE_0__.reactive)({
    data: state
  });

  // register the newly created effect scope to the store so that we can
  // dispose the effects when this method runs again in the future.
  store._scope = scope;

  // enable strict mode for new state
  if (store.strict) {
    enableStrictMode(store);
  }

  if (oldState) {
    if (hot) {
      // dispatch changes in all subscribed watchers
      // to force getter re-evaluation for hot reloading.
      store._withCommit(function () {
        oldState.data = null;
      });
    }
  }

  // dispose previously registered effect scope if there is one.
  if (oldScope) {
    oldScope.stop();
  }
}

function installModule (store, rootState, path, module, hot) {
  var isRoot = !path.length;
  var namespace = store._modules.getNamespace(path);

  // register in namespace map
  if (module.namespaced) {
    if (store._modulesNamespaceMap[namespace] && ("development" !== 'production')) {
      console.error(("[vuex] duplicate namespace " + namespace + " for the namespaced module " + (path.join('/'))));
    }
    store._modulesNamespaceMap[namespace] = module;
  }

  // set state
  if (!isRoot && !hot) {
    var parentState = getNestedState(rootState, path.slice(0, -1));
    var moduleName = path[path.length - 1];
    store._withCommit(function () {
      if ((true)) {
        if (moduleName in parentState) {
          console.warn(
            ("[vuex] state field \"" + moduleName + "\" was overridden by a module with the same name at \"" + (path.join('.')) + "\"")
          );
        }
      }
      parentState[moduleName] = module.state;
    });
  }

  var local = module.context = makeLocalContext(store, namespace, path);

  module.forEachMutation(function (mutation, key) {
    var namespacedType = namespace + key;
    registerMutation(store, namespacedType, mutation, local);
  });

  module.forEachAction(function (action, key) {
    var type = action.root ? key : namespace + key;
    var handler = action.handler || action;
    registerAction(store, type, handler, local);
  });

  module.forEachGetter(function (getter, key) {
    var namespacedType = namespace + key;
    registerGetter(store, namespacedType, getter, local);
  });

  module.forEachChild(function (child, key) {
    installModule(store, rootState, path.concat(key), child, hot);
  });
}

/**
 * make localized dispatch, commit, getters and state
 * if there is no namespace, just use root ones
 */
function makeLocalContext (store, namespace, path) {
  var noNamespace = namespace === '';

  var local = {
    dispatch: noNamespace ? store.dispatch : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (( true) && !store._actions[type]) {
          console.error(("[vuex] unknown local action type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      return store.dispatch(type, payload)
    },

    commit: noNamespace ? store.commit : function (_type, _payload, _options) {
      var args = unifyObjectStyle(_type, _payload, _options);
      var payload = args.payload;
      var options = args.options;
      var type = args.type;

      if (!options || !options.root) {
        type = namespace + type;
        if (( true) && !store._mutations[type]) {
          console.error(("[vuex] unknown local mutation type: " + (args.type) + ", global type: " + type));
          return
        }
      }

      store.commit(type, payload, options);
    }
  };

  // getters and state object must be gotten lazily
  // because they will be changed by state update
  Object.defineProperties(local, {
    getters: {
      get: noNamespace
        ? function () { return store.getters; }
        : function () { return makeLocalGetters(store, namespace); }
    },
    state: {
      get: function () { return getNestedState(store.state, path); }
    }
  });

  return local
}

function makeLocalGetters (store, namespace) {
  if (!store._makeLocalGettersCache[namespace]) {
    var gettersProxy = {};
    var splitPos = namespace.length;
    Object.keys(store.getters).forEach(function (type) {
      // skip if the target getter is not match this namespace
      if (type.slice(0, splitPos) !== namespace) { return }

      // extract local getter type
      var localType = type.slice(splitPos);

      // Add a port to the getters proxy.
      // Define as getter property because
      // we do not want to evaluate the getters in this time.
      Object.defineProperty(gettersProxy, localType, {
        get: function () { return store.getters[type]; },
        enumerable: true
      });
    });
    store._makeLocalGettersCache[namespace] = gettersProxy;
  }

  return store._makeLocalGettersCache[namespace]
}

function registerMutation (store, type, handler, local) {
  var entry = store._mutations[type] || (store._mutations[type] = []);
  entry.push(function wrappedMutationHandler (payload) {
    handler.call(store, local.state, payload);
  });
}

function registerAction (store, type, handler, local) {
  var entry = store._actions[type] || (store._actions[type] = []);
  entry.push(function wrappedActionHandler (payload) {
    var res = handler.call(store, {
      dispatch: local.dispatch,
      commit: local.commit,
      getters: local.getters,
      state: local.state,
      rootGetters: store.getters,
      rootState: store.state
    }, payload);
    if (!isPromise(res)) {
      res = Promise.resolve(res);
    }
    if (store._devtoolHook) {
      return res.catch(function (err) {
        store._devtoolHook.emit('vuex:error', err);
        throw err
      })
    } else {
      return res
    }
  });
}

function registerGetter (store, type, rawGetter, local) {
  if (store._wrappedGetters[type]) {
    if ((true)) {
      console.error(("[vuex] duplicate getter key: " + type));
    }
    return
  }
  store._wrappedGetters[type] = function wrappedGetter (store) {
    return rawGetter(
      local.state, // local state
      local.getters, // local getters
      store.state, // root state
      store.getters // root getters
    )
  };
}

function enableStrictMode (store) {
  (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(function () { return store._state.data; }, function () {
    if ((true)) {
      assert(store._committing, "do not mutate vuex store state outside mutation handlers.");
    }
  }, { deep: true, flush: 'sync' });
}

function getNestedState (state, path) {
  return path.reduce(function (state, key) { return state[key]; }, state)
}

function unifyObjectStyle (type, payload, options) {
  if (isObject(type) && type.type) {
    options = payload;
    payload = type;
    type = type.type;
  }

  if ((true)) {
    assert(typeof type === 'string', ("expects string as the type, but found " + (typeof type) + "."));
  }

  return { type: type, payload: payload, options: options }
}

var LABEL_VUEX_BINDINGS = 'vuex bindings';
var MUTATIONS_LAYER_ID = 'vuex:mutations';
var ACTIONS_LAYER_ID = 'vuex:actions';
var INSPECTOR_ID = 'vuex';

var actionId = 0;

function addDevtools (app, store) {
  (0,_vue_devtools_api__WEBPACK_IMPORTED_MODULE_1__.setupDevtoolsPlugin)(
    {
      id: 'org.vuejs.vuex',
      app: app,
      label: 'Vuex',
      homepage: 'https://next.vuex.vuejs.org/',
      logo: 'https://vuejs.org/images/icons/favicon-96x96.png',
      packageName: 'vuex',
      componentStateTypes: [LABEL_VUEX_BINDINGS]
    },
    function (api) {
      api.addTimelineLayer({
        id: MUTATIONS_LAYER_ID,
        label: 'Vuex Mutations',
        color: COLOR_LIME_500
      });

      api.addTimelineLayer({
        id: ACTIONS_LAYER_ID,
        label: 'Vuex Actions',
        color: COLOR_LIME_500
      });

      api.addInspector({
        id: INSPECTOR_ID,
        label: 'Vuex',
        icon: 'storage',
        treeFilterPlaceholder: 'Filter stores...'
      });

      api.on.getInspectorTree(function (payload) {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          if (payload.filter) {
            var nodes = [];
            flattenStoreForInspectorTree(nodes, store._modules.root, payload.filter, '');
            payload.rootNodes = nodes;
          } else {
            payload.rootNodes = [
              formatStoreForInspectorTree(store._modules.root, '')
            ];
          }
        }
      });

      api.on.getInspectorState(function (payload) {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          var modulePath = payload.nodeId;
          makeLocalGetters(store, modulePath);
          payload.state = formatStoreForInspectorState(
            getStoreModule(store._modules, modulePath),
            modulePath === 'root' ? store.getters : store._makeLocalGettersCache,
            modulePath
          );
        }
      });

      api.on.editInspectorState(function (payload) {
        if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {
          var modulePath = payload.nodeId;
          var path = payload.path;
          if (modulePath !== 'root') {
            path = modulePath.split('/').filter(Boolean).concat( path);
          }
          store._withCommit(function () {
            payload.set(store._state.data, path, payload.state.value);
          });
        }
      });

      store.subscribe(function (mutation, state) {
        var data = {};

        if (mutation.payload) {
          data.payload = mutation.payload;
        }

        data.state = state;

        api.notifyComponentUpdate();
        api.sendInspectorTree(INSPECTOR_ID);
        api.sendInspectorState(INSPECTOR_ID);

        api.addTimelineEvent({
          layerId: MUTATIONS_LAYER_ID,
          event: {
            time: Date.now(),
            title: mutation.type,
            data: data
          }
        });
      });

      store.subscribeAction({
        before: function (action, state) {
          var data = {};
          if (action.payload) {
            data.payload = action.payload;
          }
          action._id = actionId++;
          action._time = Date.now();
          data.state = state;

          api.addTimelineEvent({
            layerId: ACTIONS_LAYER_ID,
            event: {
              time: action._time,
              title: action.type,
              groupId: action._id,
              subtitle: 'start',
              data: data
            }
          });
        },
        after: function (action, state) {
          var data = {};
          var duration = Date.now() - action._time;
          data.duration = {
            _custom: {
              type: 'duration',
              display: (duration + "ms"),
              tooltip: 'Action duration',
              value: duration
            }
          };
          if (action.payload) {
            data.payload = action.payload;
          }
          data.state = state;

          api.addTimelineEvent({
            layerId: ACTIONS_LAYER_ID,
            event: {
              time: Date.now(),
              title: action.type,
              groupId: action._id,
              subtitle: 'end',
              data: data
            }
          });
        }
      });
    }
  );
}

// extracted from tailwind palette
var COLOR_LIME_500 = 0x84cc16;
var COLOR_DARK = 0x666666;
var COLOR_WHITE = 0xffffff;

var TAG_NAMESPACED = {
  label: 'namespaced',
  textColor: COLOR_WHITE,
  backgroundColor: COLOR_DARK
};

/**
 * @param {string} path
 */
function extractNameFromPath (path) {
  return path && path !== 'root' ? path.split('/').slice(-2, -1)[0] : 'Root'
}

/**
 * @param {*} module
 * @return {import('@vue/devtools-api').CustomInspectorNode}
 */
function formatStoreForInspectorTree (module, path) {
  return {
    id: path || 'root',
    // all modules end with a `/`, we want the last segment only
    // cart/ -> cart
    // nested/cart/ -> cart
    label: extractNameFromPath(path),
    tags: module.namespaced ? [TAG_NAMESPACED] : [],
    children: Object.keys(module._children).map(function (moduleName) { return formatStoreForInspectorTree(
        module._children[moduleName],
        path + moduleName + '/'
      ); }
    )
  }
}

/**
 * @param {import('@vue/devtools-api').CustomInspectorNode[]} result
 * @param {*} module
 * @param {string} filter
 * @param {string} path
 */
function flattenStoreForInspectorTree (result, module, filter, path) {
  if (path.includes(filter)) {
    result.push({
      id: path || 'root',
      label: path.endsWith('/') ? path.slice(0, path.length - 1) : path || 'Root',
      tags: module.namespaced ? [TAG_NAMESPACED] : []
    });
  }
  Object.keys(module._children).forEach(function (moduleName) {
    flattenStoreForInspectorTree(result, module._children[moduleName], filter, path + moduleName + '/');
  });
}

/**
 * @param {*} module
 * @return {import('@vue/devtools-api').CustomInspectorState}
 */
function formatStoreForInspectorState (module, getters, path) {
  getters = path === 'root' ? getters : getters[path];
  var gettersKeys = Object.keys(getters);
  var storeState = {
    state: Object.keys(module.state).map(function (key) { return ({
      key: key,
      editable: true,
      value: module.state[key]
    }); })
  };

  if (gettersKeys.length) {
    var tree = transformPathsToObjectTree(getters);
    storeState.getters = Object.keys(tree).map(function (key) { return ({
      key: key.endsWith('/') ? extractNameFromPath(key) : key,
      editable: false,
      value: canThrow(function () { return tree[key]; })
    }); });
  }

  return storeState
}

function transformPathsToObjectTree (getters) {
  var result = {};
  Object.keys(getters).forEach(function (key) {
    var path = key.split('/');
    if (path.length > 1) {
      var target = result;
      var leafKey = path.pop();
      path.forEach(function (p) {
        if (!target[p]) {
          target[p] = {
            _custom: {
              value: {},
              display: p,
              tooltip: 'Module',
              abstract: true
            }
          };
        }
        target = target[p]._custom.value;
      });
      target[leafKey] = canThrow(function () { return getters[key]; });
    } else {
      result[key] = canThrow(function () { return getters[key]; });
    }
  });
  return result
}

function getStoreModule (moduleMap, path) {
  var names = path.split('/').filter(function (n) { return n; });
  return names.reduce(
    function (module, moduleName, i) {
      var child = module[moduleName];
      if (!child) {
        throw new Error(("Missing module \"" + moduleName + "\" for path \"" + path + "\"."))
      }
      return i === names.length - 1 ? child : child._children
    },
    path === 'root' ? moduleMap : moduleMap.root._children
  )
}

function canThrow (cb) {
  try {
    return cb()
  } catch (e) {
    return e
  }
}

// Base data struct for store's module, package with some attribute and method
var Module = function Module (rawModule, runtime) {
  this.runtime = runtime;
  // Store some children item
  this._children = Object.create(null);
  // Store the origin module object which passed by programmer
  this._rawModule = rawModule;
  var rawState = rawModule.state;

  // Store the origin module's state
  this.state = (typeof rawState === 'function' ? rawState() : rawState) || {};
};

var prototypeAccessors$1 = { namespaced: { configurable: true } };

prototypeAccessors$1.namespaced.get = function () {
  return !!this._rawModule.namespaced
};

Module.prototype.addChild = function addChild (key, module) {
  this._children[key] = module;
};

Module.prototype.removeChild = function removeChild (key) {
  delete this._children[key];
};

Module.prototype.getChild = function getChild (key) {
  return this._children[key]
};

Module.prototype.hasChild = function hasChild (key) {
  return key in this._children
};

Module.prototype.update = function update (rawModule) {
  this._rawModule.namespaced = rawModule.namespaced;
  if (rawModule.actions) {
    this._rawModule.actions = rawModule.actions;
  }
  if (rawModule.mutations) {
    this._rawModule.mutations = rawModule.mutations;
  }
  if (rawModule.getters) {
    this._rawModule.getters = rawModule.getters;
  }
};

Module.prototype.forEachChild = function forEachChild (fn) {
  forEachValue(this._children, fn);
};

Module.prototype.forEachGetter = function forEachGetter (fn) {
  if (this._rawModule.getters) {
    forEachValue(this._rawModule.getters, fn);
  }
};

Module.prototype.forEachAction = function forEachAction (fn) {
  if (this._rawModule.actions) {
    forEachValue(this._rawModule.actions, fn);
  }
};

Module.prototype.forEachMutation = function forEachMutation (fn) {
  if (this._rawModule.mutations) {
    forEachValue(this._rawModule.mutations, fn);
  }
};

Object.defineProperties( Module.prototype, prototypeAccessors$1 );

var ModuleCollection = function ModuleCollection (rawRootModule) {
  // register root module (Vuex.Store options)
  this.register([], rawRootModule, false);
};

ModuleCollection.prototype.get = function get (path) {
  return path.reduce(function (module, key) {
    return module.getChild(key)
  }, this.root)
};

ModuleCollection.prototype.getNamespace = function getNamespace (path) {
  var module = this.root;
  return path.reduce(function (namespace, key) {
    module = module.getChild(key);
    return namespace + (module.namespaced ? key + '/' : '')
  }, '')
};

ModuleCollection.prototype.update = function update$1 (rawRootModule) {
  update([], this.root, rawRootModule);
};

ModuleCollection.prototype.register = function register (path, rawModule, runtime) {
    var this$1$1 = this;
    if ( runtime === void 0 ) runtime = true;

  if ((true)) {
    assertRawModule(path, rawModule);
  }

  var newModule = new Module(rawModule, runtime);
  if (path.length === 0) {
    this.root = newModule;
  } else {
    var parent = this.get(path.slice(0, -1));
    parent.addChild(path[path.length - 1], newModule);
  }

  // register nested modules
  if (rawModule.modules) {
    forEachValue(rawModule.modules, function (rawChildModule, key) {
      this$1$1.register(path.concat(key), rawChildModule, runtime);
    });
  }
};

ModuleCollection.prototype.unregister = function unregister (path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];
  var child = parent.getChild(key);

  if (!child) {
    if ((true)) {
      console.warn(
        "[vuex] trying to unregister module '" + key + "', which is " +
        "not registered"
      );
    }
    return
  }

  if (!child.runtime) {
    return
  }

  parent.removeChild(key);
};

ModuleCollection.prototype.isRegistered = function isRegistered (path) {
  var parent = this.get(path.slice(0, -1));
  var key = path[path.length - 1];

  if (parent) {
    return parent.hasChild(key)
  }

  return false
};

function update (path, targetModule, newModule) {
  if ((true)) {
    assertRawModule(path, newModule);
  }

  // update target module
  targetModule.update(newModule);

  // update nested modules
  if (newModule.modules) {
    for (var key in newModule.modules) {
      if (!targetModule.getChild(key)) {
        if ((true)) {
          console.warn(
            "[vuex] trying to add a new module '" + key + "' on hot reloading, " +
            'manual reload is needed'
          );
        }
        return
      }
      update(
        path.concat(key),
        targetModule.getChild(key),
        newModule.modules[key]
      );
    }
  }
}

var functionAssert = {
  assert: function (value) { return typeof value === 'function'; },
  expected: 'function'
};

var objectAssert = {
  assert: function (value) { return typeof value === 'function' ||
    (typeof value === 'object' && typeof value.handler === 'function'); },
  expected: 'function or object with "handler" function'
};

var assertTypes = {
  getters: functionAssert,
  mutations: functionAssert,
  actions: objectAssert
};

function assertRawModule (path, rawModule) {
  Object.keys(assertTypes).forEach(function (key) {
    if (!rawModule[key]) { return }

    var assertOptions = assertTypes[key];

    forEachValue(rawModule[key], function (value, type) {
      assert(
        assertOptions.assert(value),
        makeAssertionMessage(path, key, type, value, assertOptions.expected)
      );
    });
  });
}

function makeAssertionMessage (path, key, type, value, expected) {
  var buf = key + " should be " + expected + " but \"" + key + "." + type + "\"";
  if (path.length > 0) {
    buf += " in module \"" + (path.join('.')) + "\"";
  }
  buf += " is " + (JSON.stringify(value)) + ".";
  return buf
}

function createStore (options) {
  return new Store(options)
}

var Store = function Store (options) {
  var this$1$1 = this;
  if ( options === void 0 ) options = {};

  if ((true)) {
    assert(typeof Promise !== 'undefined', "vuex requires a Promise polyfill in this browser.");
    assert(this instanceof Store, "store must be called with the new operator.");
  }

  var plugins = options.plugins; if ( plugins === void 0 ) plugins = [];
  var strict = options.strict; if ( strict === void 0 ) strict = false;
  var devtools = options.devtools;

  // store internal state
  this._committing = false;
  this._actions = Object.create(null);
  this._actionSubscribers = [];
  this._mutations = Object.create(null);
  this._wrappedGetters = Object.create(null);
  this._modules = new ModuleCollection(options);
  this._modulesNamespaceMap = Object.create(null);
  this._subscribers = [];
  this._makeLocalGettersCache = Object.create(null);

  // EffectScope instance. when registering new getters, we wrap them inside
  // EffectScope so that getters (computed) would not be destroyed on
  // component unmount.
  this._scope = null;

  this._devtools = devtools;

  // bind commit and dispatch to self
  var store = this;
  var ref = this;
  var dispatch = ref.dispatch;
  var commit = ref.commit;
  this.dispatch = function boundDispatch (type, payload) {
    return dispatch.call(store, type, payload)
  };
  this.commit = function boundCommit (type, payload, options) {
    return commit.call(store, type, payload, options)
  };

  // strict mode
  this.strict = strict;

  var state = this._modules.root.state;

  // init root module.
  // this also recursively registers all sub-modules
  // and collects all module getters inside this._wrappedGetters
  installModule(this, state, [], this._modules.root);

  // initialize the store state, which is responsible for the reactivity
  // (also registers _wrappedGetters as computed properties)
  resetStoreState(this, state);

  // apply plugins
  plugins.forEach(function (plugin) { return plugin(this$1$1); });
};

var prototypeAccessors = { state: { configurable: true } };

Store.prototype.install = function install (app, injectKey) {
  app.provide(injectKey || storeKey, this);
  app.config.globalProperties.$store = this;

  var useDevtools = this._devtools !== undefined
    ? this._devtools
    : ( true) || 0;

  if (useDevtools) {
    addDevtools(app, this);
  }
};

prototypeAccessors.state.get = function () {
  return this._state.data
};

prototypeAccessors.state.set = function (v) {
  if ((true)) {
    assert(false, "use store.replaceState() to explicit replace store state.");
  }
};

Store.prototype.commit = function commit (_type, _payload, _options) {
    var this$1$1 = this;

  // check object-style commit
  var ref = unifyObjectStyle(_type, _payload, _options);
    var type = ref.type;
    var payload = ref.payload;
    var options = ref.options;

  var mutation = { type: type, payload: payload };
  var entry = this._mutations[type];
  if (!entry) {
    if ((true)) {
      console.error(("[vuex] unknown mutation type: " + type));
    }
    return
  }
  this._withCommit(function () {
    entry.forEach(function commitIterator (handler) {
      handler(payload);
    });
  });

  this._subscribers
    .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
    .forEach(function (sub) { return sub(mutation, this$1$1.state); });

  if (
    ( true) &&
    options && options.silent
  ) {
    console.warn(
      "[vuex] mutation type: " + type + ". Silent option has been removed. " +
      'Use the filter functionality in the vue-devtools'
    );
  }
};

Store.prototype.dispatch = function dispatch (_type, _payload) {
    var this$1$1 = this;

  // check object-style dispatch
  var ref = unifyObjectStyle(_type, _payload);
    var type = ref.type;
    var payload = ref.payload;

  var action = { type: type, payload: payload };
  var entry = this._actions[type];
  if (!entry) {
    if ((true)) {
      console.error(("[vuex] unknown action type: " + type));
    }
    return
  }

  try {
    this._actionSubscribers
      .slice() // shallow copy to prevent iterator invalidation if subscriber synchronously calls unsubscribe
      .filter(function (sub) { return sub.before; })
      .forEach(function (sub) { return sub.before(action, this$1$1.state); });
  } catch (e) {
    if ((true)) {
      console.warn("[vuex] error in before action subscribers: ");
      console.error(e);
    }
  }

  var result = entry.length > 1
    ? Promise.all(entry.map(function (handler) { return handler(payload); }))
    : entry[0](payload);

  return new Promise(function (resolve, reject) {
    result.then(function (res) {
      try {
        this$1$1._actionSubscribers
          .filter(function (sub) { return sub.after; })
          .forEach(function (sub) { return sub.after(action, this$1$1.state); });
      } catch (e) {
        if ((true)) {
          console.warn("[vuex] error in after action subscribers: ");
          console.error(e);
        }
      }
      resolve(res);
    }, function (error) {
      try {
        this$1$1._actionSubscribers
          .filter(function (sub) { return sub.error; })
          .forEach(function (sub) { return sub.error(action, this$1$1.state, error); });
      } catch (e) {
        if ((true)) {
          console.warn("[vuex] error in error action subscribers: ");
          console.error(e);
        }
      }
      reject(error);
    });
  })
};

Store.prototype.subscribe = function subscribe (fn, options) {
  return genericSubscribe(fn, this._subscribers, options)
};

Store.prototype.subscribeAction = function subscribeAction (fn, options) {
  var subs = typeof fn === 'function' ? { before: fn } : fn;
  return genericSubscribe(subs, this._actionSubscribers, options)
};

Store.prototype.watch = function watch$1 (getter, cb, options) {
    var this$1$1 = this;

  if ((true)) {
    assert(typeof getter === 'function', "store.watch only accepts a function.");
  }
  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.watch)(function () { return getter(this$1$1.state, this$1$1.getters); }, cb, Object.assign({}, options))
};

Store.prototype.replaceState = function replaceState (state) {
    var this$1$1 = this;

  this._withCommit(function () {
    this$1$1._state.data = state;
  });
};

Store.prototype.registerModule = function registerModule (path, rawModule, options) {
    if ( options === void 0 ) options = {};

  if (typeof path === 'string') { path = [path]; }

  if ((true)) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
    assert(path.length > 0, 'cannot register the root module by using registerModule.');
  }

  this._modules.register(path, rawModule);
  installModule(this, this.state, path, this._modules.get(path), options.preserveState);
  // reset store to update getters...
  resetStoreState(this, this.state);
};

Store.prototype.unregisterModule = function unregisterModule (path) {
    var this$1$1 = this;

  if (typeof path === 'string') { path = [path]; }

  if ((true)) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }

  this._modules.unregister(path);
  this._withCommit(function () {
    var parentState = getNestedState(this$1$1.state, path.slice(0, -1));
    delete parentState[path[path.length - 1]];
  });
  resetStore(this);
};

Store.prototype.hasModule = function hasModule (path) {
  if (typeof path === 'string') { path = [path]; }

  if ((true)) {
    assert(Array.isArray(path), "module path must be a string or an Array.");
  }

  return this._modules.isRegistered(path)
};

Store.prototype.hotUpdate = function hotUpdate (newOptions) {
  this._modules.update(newOptions);
  resetStore(this, true);
};

Store.prototype._withCommit = function _withCommit (fn) {
  var committing = this._committing;
  this._committing = true;
  fn();
  this._committing = committing;
};

Object.defineProperties( Store.prototype, prototypeAccessors );

/**
 * Reduce the code which written in Vue.js for getting the state.
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} states # Object's item can be a function which accept state and getters for param, you can do something for state and getters in it.
 * @param {Object}
 */
var mapState = normalizeNamespace(function (namespace, states) {
  var res = {};
  if (( true) && !isValidMap(states)) {
    console.error('[vuex] mapState: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(states).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedState () {
      var state = this.$store.state;
      var getters = this.$store.getters;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapState', namespace);
        if (!module) {
          return
        }
        state = module.context.state;
        getters = module.context.getters;
      }
      return typeof val === 'function'
        ? val.call(this, state, getters)
        : state[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for committing the mutation
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} mutations # Object's item can be a function which accept `commit` function as the first param, it can accept another params. You can commit mutation and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */
var mapMutations = normalizeNamespace(function (namespace, mutations) {
  var res = {};
  if (( true) && !isValidMap(mutations)) {
    console.error('[vuex] mapMutations: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(mutations).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedMutation () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      // Get the commit method from store
      var commit = this.$store.commit;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapMutations', namespace);
        if (!module) {
          return
        }
        commit = module.context.commit;
      }
      return typeof val === 'function'
        ? val.apply(this, [commit].concat(args))
        : commit.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for getting the getters
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} getters
 * @return {Object}
 */
var mapGetters = normalizeNamespace(function (namespace, getters) {
  var res = {};
  if (( true) && !isValidMap(getters)) {
    console.error('[vuex] mapGetters: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(getters).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    // The namespace has been mutated by normalizeNamespace
    val = namespace + val;
    res[key] = function mappedGetter () {
      if (namespace && !getModuleByNamespace(this.$store, 'mapGetters', namespace)) {
        return
      }
      if (( true) && !(val in this.$store.getters)) {
        console.error(("[vuex] unknown getter: " + val));
        return
      }
      return this.$store.getters[val]
    };
    // mark vuex getter for devtools
    res[key].vuex = true;
  });
  return res
});

/**
 * Reduce the code which written in Vue.js for dispatch the action
 * @param {String} [namespace] - Module's namespace
 * @param {Object|Array} actions # Object's item can be a function which accept `dispatch` function as the first param, it can accept anthor params. You can dispatch action and do any other things in this function. specially, You need to pass anthor params from the mapped function.
 * @return {Object}
 */
var mapActions = normalizeNamespace(function (namespace, actions) {
  var res = {};
  if (( true) && !isValidMap(actions)) {
    console.error('[vuex] mapActions: mapper parameter must be either an Array or an Object');
  }
  normalizeMap(actions).forEach(function (ref) {
    var key = ref.key;
    var val = ref.val;

    res[key] = function mappedAction () {
      var args = [], len = arguments.length;
      while ( len-- ) args[ len ] = arguments[ len ];

      // get dispatch function from store
      var dispatch = this.$store.dispatch;
      if (namespace) {
        var module = getModuleByNamespace(this.$store, 'mapActions', namespace);
        if (!module) {
          return
        }
        dispatch = module.context.dispatch;
      }
      return typeof val === 'function'
        ? val.apply(this, [dispatch].concat(args))
        : dispatch.apply(this.$store, [val].concat(args))
    };
  });
  return res
});

/**
 * Rebinding namespace param for mapXXX function in special scoped, and return them by simple object
 * @param {String} namespace
 * @return {Object}
 */
var createNamespacedHelpers = function (namespace) { return ({
  mapState: mapState.bind(null, namespace),
  mapGetters: mapGetters.bind(null, namespace),
  mapMutations: mapMutations.bind(null, namespace),
  mapActions: mapActions.bind(null, namespace)
}); };

/**
 * Normalize the map
 * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]
 * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]
 * @param {Array|Object} map
 * @return {Object}
 */
function normalizeMap (map) {
  if (!isValidMap(map)) {
    return []
  }
  return Array.isArray(map)
    ? map.map(function (key) { return ({ key: key, val: key }); })
    : Object.keys(map).map(function (key) { return ({ key: key, val: map[key] }); })
}

/**
 * Validate whether given map is valid or not
 * @param {*} map
 * @return {Boolean}
 */
function isValidMap (map) {
  return Array.isArray(map) || isObject(map)
}

/**
 * Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map.
 * @param {Function} fn
 * @return {Function}
 */
function normalizeNamespace (fn) {
  return function (namespace, map) {
    if (typeof namespace !== 'string') {
      map = namespace;
      namespace = '';
    } else if (namespace.charAt(namespace.length - 1) !== '/') {
      namespace += '/';
    }
    return fn(namespace, map)
  }
}

/**
 * Search a special module from store by namespace. if module not exist, print error message.
 * @param {Object} store
 * @param {String} helper
 * @param {String} namespace
 * @return {Object}
 */
function getModuleByNamespace (store, helper, namespace) {
  var module = store._modulesNamespaceMap[namespace];
  if (( true) && !module) {
    console.error(("[vuex] module namespace not found in " + helper + "(): " + namespace));
  }
  return module
}

// Credits: borrowed code from fcomb/redux-logger

function createLogger (ref) {
  if ( ref === void 0 ) ref = {};
  var collapsed = ref.collapsed; if ( collapsed === void 0 ) collapsed = true;
  var filter = ref.filter; if ( filter === void 0 ) filter = function (mutation, stateBefore, stateAfter) { return true; };
  var transformer = ref.transformer; if ( transformer === void 0 ) transformer = function (state) { return state; };
  var mutationTransformer = ref.mutationTransformer; if ( mutationTransformer === void 0 ) mutationTransformer = function (mut) { return mut; };
  var actionFilter = ref.actionFilter; if ( actionFilter === void 0 ) actionFilter = function (action, state) { return true; };
  var actionTransformer = ref.actionTransformer; if ( actionTransformer === void 0 ) actionTransformer = function (act) { return act; };
  var logMutations = ref.logMutations; if ( logMutations === void 0 ) logMutations = true;
  var logActions = ref.logActions; if ( logActions === void 0 ) logActions = true;
  var logger = ref.logger; if ( logger === void 0 ) logger = console;

  return function (store) {
    var prevState = deepCopy(store.state);

    if (typeof logger === 'undefined') {
      return
    }

    if (logMutations) {
      store.subscribe(function (mutation, state) {
        var nextState = deepCopy(state);

        if (filter(mutation, prevState, nextState)) {
          var formattedTime = getFormattedTime();
          var formattedMutation = mutationTransformer(mutation);
          var message = "mutation " + (mutation.type) + formattedTime;

          startMessage(logger, message, collapsed);
          logger.log('%c prev state', 'color: #9E9E9E; font-weight: bold', transformer(prevState));
          logger.log('%c mutation', 'color: #03A9F4; font-weight: bold', formattedMutation);
          logger.log('%c next state', 'color: #4CAF50; font-weight: bold', transformer(nextState));
          endMessage(logger);
        }

        prevState = nextState;
      });
    }

    if (logActions) {
      store.subscribeAction(function (action, state) {
        if (actionFilter(action, state)) {
          var formattedTime = getFormattedTime();
          var formattedAction = actionTransformer(action);
          var message = "action " + (action.type) + formattedTime;

          startMessage(logger, message, collapsed);
          logger.log('%c action', 'color: #03A9F4; font-weight: bold', formattedAction);
          endMessage(logger);
        }
      });
    }
  }
}

function startMessage (logger, message, collapsed) {
  var startMessage = collapsed
    ? logger.groupCollapsed
    : logger.group;

  // render
  try {
    startMessage.call(logger, message);
  } catch (e) {
    logger.log(message);
  }
}

function endMessage (logger) {
  try {
    logger.groupEnd();
  } catch (e) {
    logger.log('—— log end ——');
  }
}

function getFormattedTime () {
  var time = new Date();
  return (" @ " + (pad(time.getHours(), 2)) + ":" + (pad(time.getMinutes(), 2)) + ":" + (pad(time.getSeconds(), 2)) + "." + (pad(time.getMilliseconds(), 3)))
}

function repeat (str, times) {
  return (new Array(times + 1)).join(str)
}

function pad (num, maxLength) {
  return repeat('0', maxLength - num.toString().length) + num
}

var index = {
  version: '4.1.0',
  Store: Store,
  storeKey: storeKey,
  createStore: createStore,
  useStore: useStore,
  mapState: mapState,
  mapMutations: mapMutations,
  mapGetters: mapGetters,
  mapActions: mapActions,
  createNamespacedHelpers: createNamespacedHelpers,
  createLogger: createLogger
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (index);



/***/ }),

/***/ "./resources/components/DetailField.vue":
/*!**********************************************!*\
  !*** ./resources/components/DetailField.vue ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _DetailField_vue_vue_type_template_id_70611348__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DetailField.vue?vue&type=template&id=70611348 */ "./resources/components/DetailField.vue?vue&type=template&id=70611348");
/* harmony import */ var _DetailField_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DetailField.vue?vue&type=script&lang=js */ "./resources/components/DetailField.vue?vue&type=script&lang=js");
/* harmony import */ var _node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;
const __exports__ = /*#__PURE__*/(0,_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_DetailField_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_DetailField_vue_vue_type_template_id_70611348__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"resources/components/DetailField.vue"]])
/* hot reload */
if (false) // removed by dead control flow
{}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./resources/components/DetailField.vue?vue&type=script&lang=js":
/*!**********************************************************************!*\
  !*** ./resources/components/DetailField.vue?vue&type=script&lang=js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_DetailField_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_DetailField_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./DetailField.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/components/DetailField.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./resources/components/DetailField.vue?vue&type=template&id=70611348":
/*!****************************************************************************!*\
  !*** ./resources/components/DetailField.vue?vue&type=template&id=70611348 ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_DetailField_vue_vue_type_template_id_70611348__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_DetailField_vue_vue_type_template_id_70611348__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./DetailField.vue?vue&type=template&id=70611348 */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/components/DetailField.vue?vue&type=template&id=70611348");


/***/ }),

/***/ "./resources/components/FormField.vue":
/*!********************************************!*\
  !*** ./resources/components/FormField.vue ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _FormField_vue_vue_type_template_id_c97f7416__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FormField.vue?vue&type=template&id=c97f7416 */ "./resources/components/FormField.vue?vue&type=template&id=c97f7416");
/* harmony import */ var _FormField_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./FormField.vue?vue&type=script&lang=js */ "./resources/components/FormField.vue?vue&type=script&lang=js");
/* harmony import */ var _node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");




;
const __exports__ = /*#__PURE__*/(0,_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_2__["default"])(_FormField_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__["default"], [['render',_FormField_vue_vue_type_template_id_c97f7416__WEBPACK_IMPORTED_MODULE_0__.render],['__file',"resources/components/FormField.vue"]])
/* hot reload */
if (false) // removed by dead control flow
{}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__exports__);

/***/ }),

/***/ "./resources/components/FormField.vue?vue&type=script&lang=js":
/*!********************************************************************!*\
  !*** ./resources/components/FormField.vue?vue&type=script&lang=js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_FormField_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_FormField_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./FormField.vue?vue&type=script&lang=js */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/components/FormField.vue?vue&type=script&lang=js");
 

/***/ }),

/***/ "./resources/components/FormField.vue?vue&type=template&id=c97f7416":
/*!**************************************************************************!*\
  !*** ./resources/components/FormField.vue?vue&type=template&id=c97f7416 ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   render: () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_FormField_vue_vue_type_template_id_c97f7416__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_FormField_vue_vue_type_template_id_c97f7416__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./FormField.vue?vue&type=template&id=c97f7416 */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/components/FormField.vue?vue&type=template&id=c97f7416");


/***/ }),

/***/ "./resources/field.css":
/*!*****************************!*\
  !*** ./resources/field.css ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./resources/field.js":
/*!****************************!*\
  !*** ./resources/field.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _components_DetailField_vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/DetailField.vue */ "./resources/components/DetailField.vue");
/* harmony import */ var _components_FormField_vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/FormField.vue */ "./resources/components/FormField.vue");


Nova.booting(function (Vue) {
  Vue.component('detail-nova-tui-editor', _components_DetailField_vue__WEBPACK_IMPORTED_MODULE_0__["default"]);
  Vue.component('form-nova-tui-editor', _components_FormField_vue__WEBPACK_IMPORTED_MODULE_1__["default"]);
});

/***/ }),

/***/ "./resources/utils/novaDarkMode.js":
/*!*****************************************!*\
  !*** ./resources/utils/novaDarkMode.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   makeObserver: () => (/* binding */ makeObserver),
/* harmony export */   resolveNovaDarkMode: () => (/* binding */ resolveNovaDarkMode)
/* harmony export */ });
var makeObserver = function makeObserver(ctx, attribute, element) {
  var observer = new MutationObserver(resolveNovaDarkMode(ctx, attribute));
  observer.observe(element, {
    attributes: true,
    attributeOldValue: true,
    attributeFilter: ['class']
  });
  return observer;
};
var resolveNovaDarkMode = function resolveNovaDarkMode(ctx, attribute) {
  return function () {
    var cls = document.documentElement.classList;
    var novaDarkModeEnabled = cls.contains('dark');
    if (novaDarkModeEnabled && !ctx[attribute]) {
      ctx[attribute] = true;
    } else if (!novaDarkModeEnabled && ctx[attribute]) {
      ctx[attribute] = false;
    }
  };
};

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/composables/useLocalization.js":
/*!*************************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/composables/useLocalization.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useLocalization: () => (/* binding */ useLocalization)
/* harmony export */ });
/* harmony import */ var _util_localization__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/localization */ "./vendor/laravel/nova/resources/js/util/localization.js");

function useLocalization() {
  return {
    /**
     * @param {string} key
     * @param {{[key: string]: string}} replace
     * @returns {string}
     */
    __: function __(key, replace) {
      return (0,_util_localization__WEBPACK_IMPORTED_MODULE_0__["default"])(key, replace);
    }
  };
}

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/composables/usePanelVisibility.js":
/*!****************************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/composables/usePanelVisibility.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   usePanelVisibility: () => (/* binding */ usePanelVisibility)
/* harmony export */ });
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "vue");
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vue__WEBPACK_IMPORTED_MODULE_0__);

function usePanelVisibility() {
  var panel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    attribute: 'default',
    fields: []
  };
  var emitter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var visibleFieldsForPanel = {};
  var visibleFieldsCount = (0,vue__WEBPACK_IMPORTED_MODULE_0__.ref)(0);
  panel.fields.forEach(function (field) {
    visibleFieldsForPanel[field.attribute] = field.visible;
  });
  var handleFieldShown = function handleFieldShown(field) {
    visibleFieldsForPanel[field] = true;
    if (emitter !== null) {
      emitter('field-shown', field);
    }
    syncVisibleFieldsCount(visibleFieldsForPanel);
  };
  var handleFieldHidden = function handleFieldHidden(field) {
    visibleFieldsForPanel[field] = false;
    if (emitter !== null) {
      emitter('field-shown', field);
    }
    syncVisibleFieldsCount(visibleFieldsForPanel);
  };
  var syncVisibleFieldsCount = function syncVisibleFieldsCount(fields) {
    visibleFieldsCount.value = Object.values(fields).filter(function (visible) {
      return visible === true;
    }).length;
  };
  syncVisibleFieldsCount(visibleFieldsForPanel);
  return {
    handleFieldShown: handleFieldShown,
    handleFieldHidden: handleFieldHidden,
    visibleFieldsCount: visibleFieldsCount
  };
}

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/composables/useResourceInformation.js":
/*!********************************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/composables/useResourceInformation.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useResourceInformation: () => (/* binding */ useResourceInformation)
/* harmony export */ });
function useResourceInformation() {
  var resourceInformation = function resourceInformation(resourceName) {
    return Nova.config('resources').find(function (resource) {
      return resource.uriKey === resourceName;
    }) || null;
  };
  var viaResourceInformation = function viaResourceInformation(viaRelation) {
    return Nova.config('resources').find(function (resource) {
      return resource.uriKey === viaRelation;
    }) || null;
  };
  var authorizedToCreate = function authorizedToCreate(resourceName) {
    var relationshipType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    if (['hasOneThrough', 'hasManyThrough'].indexOf(relationshipType) >= 0) {
      return false;
    }
    return resourceInformation(resourceName).authorizedToCreate || false;
  };
  return {
    resourceInformation: resourceInformation,
    viaResourceInformation: viaResourceInformation,
    authorizedToCreate: authorizedToCreate
  };
}

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/mixins/BehavesAsPanel.js":
/*!*******************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/mixins/BehavesAsPanel.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  emits: ['actionExecuted'],
  props: ['resourceName', 'resourceId', 'resource', 'panel'],
  methods: {
    /**
     * Handle the actionExecuted event and pass it up the chain.
     */
    actionExecuted: function actionExecuted() {
      this.$emit('actionExecuted');
    }
  }
});

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/mixins/CopiesToClipboard.js":
/*!**********************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/mixins/CopiesToClipboard.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   useCopyValueToClipboard: () => (/* binding */ useCopyValueToClipboard)
/* harmony export */ });
var mixin = {
  methods: {
    /**
     * @param {string} value
     */
    copyValueToClipboard: function copyValueToClipboard(value) {
      if (navigator.clipboard) {
        navigator.clipboard.writeText(value);
      } else if (window.clipboardData) {
        window.clipboardData.setData('Text', value);
      } else {
        var input = document.createElement('input');
        var _ref = [document.documentElement.scrollTop, document.documentElement.scrollLeft],
          scrollTop = _ref[0],
          scrollLeft = _ref[1];
        document.body.appendChild(input);
        input.value = value;
        input.focus();
        input.select();
        document.documentElement.scrollTop = scrollTop;
        document.documentElement.scrollLeft = scrollLeft;
        document.execCommand('copy');
        input.remove();
      }
    }
  }
};
function useCopyValueToClipboard() {
  return {
    copyValueToClipboard: function copyValueToClipboard(value) {
      return mixin.methods.copyValueToClipboard(value);
    }
  };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (mixin);

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/mixins/DependentFormField.js":
/*!***********************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/mixins/DependentFormField.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/debounce */ "./node_modules/lodash/debounce.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_forIn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/forIn */ "./node_modules/lodash/forIn.js");
/* harmony import */ var lodash_forIn__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_forIn__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/get */ "./node_modules/lodash/get.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var lodash_identity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/identity */ "./node_modules/lodash/identity.js");
/* harmony import */ var lodash_identity__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_identity__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/isEmpty */ "./node_modules/lodash/isEmpty.js");
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_isEmpty__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var lodash_pickBy__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/pickBy */ "./node_modules/lodash/pickBy.js");
/* harmony import */ var lodash_pickBy__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_pickBy__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _FormField__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./FormField */ "./vendor/laravel/nova/resources/js/mixins/FormField.js");
/* harmony import */ var _propTypes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./propTypes */ "./vendor/laravel/nova/resources/js/mixins/propTypes.js");
/* harmony import */ var _util_filled__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../util/filled */ "./vendor/laravel/nova/resources/js/util/filled.js");
/* harmony import */ var _util_escapeUnicode__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../util/escapeUnicode */ "./vendor/laravel/nova/resources/js/util/escapeUnicode.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }











/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  "extends": _FormField__WEBPACK_IMPORTED_MODULE_6__["default"],
  emits: ['field-shown', 'field-hidden'],
  props: _objectSpread(_objectSpread({}, (0,_propTypes__WEBPACK_IMPORTED_MODULE_7__.mapProps)(['shownViaNewRelationModal', 'field', 'viaResource', 'viaResourceId', 'viaRelationship', 'resourceName', 'resourceId', 'relatedResourceName', 'relatedResourceId'])), {}, {
    syncEndpoint: {
      type: String,
      required: false
    }
  }),
  data: function data() {
    return {
      dependentFieldDebouncer: null,
      canceller: null,
      watchedFields: {},
      watchedEvents: {},
      syncedField: null,
      pivot: false,
      editMode: 'create'
    };
  },
  created: function created() {
    this.dependentFieldDebouncer = lodash_debounce__WEBPACK_IMPORTED_MODULE_0___default()(function (callback) {
      return callback();
    }, 50);
  },
  mounted: function mounted() {
    var _this = this;
    if ((0,_util_filled__WEBPACK_IMPORTED_MODULE_8__["default"])(this.relatedResourceName)) {
      this.pivot = true;
      if ((0,_util_filled__WEBPACK_IMPORTED_MODULE_8__["default"])(this.relatedResourceId)) {
        this.editMode = 'update-attached';
      } else {
        this.editMode = 'attach';
      }
    } else {
      if ((0,_util_filled__WEBPACK_IMPORTED_MODULE_8__["default"])(this.resourceId)) {
        this.editMode = 'update';
      }
    }
    if (!lodash_isEmpty__WEBPACK_IMPORTED_MODULE_4___default()(this.dependsOn)) {
      lodash_forIn__WEBPACK_IMPORTED_MODULE_1___default()(this.dependsOn, function (defaultValue, dependsOn) {
        _this.watchedEvents[dependsOn] = function (value) {
          _this.watchedFields[dependsOn] = value;
          _this.dependentFieldDebouncer(function () {
            _this.watchedFields[dependsOn] = value;
            _this.syncField();
          });
        };
        _this.watchedFields[dependsOn] = defaultValue;
        Nova.$on(_this.getFieldAttributeChangeEventName(dependsOn), _this.watchedEvents[dependsOn]);
      });
    }
  },
  beforeUnmount: function beforeUnmount() {
    var _this2 = this;
    if (this.canceller !== null) this.canceller();
    if (!lodash_isEmpty__WEBPACK_IMPORTED_MODULE_4___default()(this.watchedEvents)) {
      lodash_forIn__WEBPACK_IMPORTED_MODULE_1___default()(this.watchedEvents, function (event, dependsOn) {
        Nova.$off(_this2.getFieldAttributeChangeEventName(dependsOn), event);
      });
    }
  },
  methods: {
    /*
     * Set the initial value for the field
     */
    setInitialValue: function setInitialValue() {
      this.value = !(this.currentField.value === undefined || this.currentField.value === null) ? this.currentField.value : this.value;
    },
    /**
     * Provide a function to fills FormData when field is visible.
     *
     * @param {FormData} formData
     * @param {string} attribute
     * @param {any} value
     */
    fillIfVisible: function fillIfVisible(formData, attribute, value) {
      if (this.currentlyIsVisible) {
        this.fillInto(formData, attribute, value);
      }
    },
    syncField: function syncField() {
      var _this3 = this;
      if (this.canceller !== null) this.canceller();
      Nova.request().patch(this.syncEndpoint || this.syncFieldEndpoint, this.dependentFieldValues, {
        params: lodash_pickBy__WEBPACK_IMPORTED_MODULE_5___default()({
          editing: true,
          editMode: this.editMode,
          viaResource: this.viaResource,
          viaResourceId: this.viaResourceId,
          viaRelationship: this.viaRelationship,
          field: this.fieldAttribute,
          inline: this.shownViaNewRelationModal,
          component: this.field.dependentComponentKey
        }, (lodash_identity__WEBPACK_IMPORTED_MODULE_3___default())),
        cancelToken: new axios__WEBPACK_IMPORTED_MODULE_10__.CancelToken(function (canceller) {
          _this3.canceller = canceller;
        })
      }).then(function (response) {
        var snapshot = JSON.parse(JSON.stringify(_this3.currentField));
        var wasVisible = _this3.currentlyIsVisible;
        _this3.syncedField = response.data;
        if (_this3.syncedField.visible !== wasVisible) {
          _this3.$emit(_this3.syncedField.visible === true ? 'field-shown' : 'field-hidden', _this3.fieldAttribute);
        }
        if (_this3.syncedField.value == null) {
          _this3.syncedField.value = snapshot.value;
          _this3.revertSyncedFieldToPreviousValue(snapshot);
        } else {
          _this3.setInitialValue();
        }
        var emitChangesEvent = !_this3.syncedFieldValueHasNotChanged();
        _this3.onSyncedField();
        if (_this3.syncedField.dependentShouldEmitChangesEvent && emitChangesEvent) {
          _this3.emitOnSyncedFieldValueChange();
        }
      })["catch"](function (e) {
        if ((0,axios__WEBPACK_IMPORTED_MODULE_10__.isCancel)(e)) {
          return;
        }
        throw e;
      });
    },
    revertSyncedFieldToPreviousValue: function revertSyncedFieldToPreviousValue(field) {
      //
    },
    onSyncedField: function onSyncedField() {
      //
    },
    emitOnSyncedFieldValueChange: function emitOnSyncedFieldValueChange() {
      this.emitFieldValueChange(this.field.attribute, this.currentField.value);
    },
    /**
     * @returns {boolean}
     */
    syncedFieldValueHasNotChanged: function syncedFieldValueHasNotChanged() {
      var _this$value;
      var value = this.currentField.value;
      if ((0,_util_filled__WEBPACK_IMPORTED_MODULE_8__["default"])(value)) {
        return !(0,_util_filled__WEBPACK_IMPORTED_MODULE_8__["default"])(this.value);
      }
      return value != null && (value === null || value === void 0 ? void 0 : value.toString()) === ((_this$value = this.value) === null || _this$value === void 0 ? void 0 : _this$value.toString());
    }
  },
  computed: {
    /**
     * Determine the current field
     *
     * @returns {object}
     */
    currentField: function currentField() {
      return this.syncedField || this.field;
    },
    /**
     * Determine if the field is in visible mode.
     *
     * @returns {boolean}
     */
    currentlyIsVisible: function currentlyIsVisible() {
      return this.currentField.visible;
    },
    /**
     * Determine if the field is in readonly mode.
     *
     * @returns {boolean}
     */
    currentlyIsReadonly: function currentlyIsReadonly() {
      if (this.syncedField !== null) {
        return Boolean(this.syncedField.readonly || lodash_get__WEBPACK_IMPORTED_MODULE_2___default()(this.syncedField, 'extraAttributes.readonly'));
      }
      return this.isReadonly;
    },
    /**
     * Determine if the field is in immutable state.
     *
     * @return {boolean}
     */
    currentlyIsImmutable: function currentlyIsImmutable() {
      if (this.syncedField !== null) {
        return Boolean(this.syncedField.readonly === false && this.syncedField.writable === true && lodash_get__WEBPACK_IMPORTED_MODULE_2___default()(this.syncedField, 'extraAttributes.readonly') === true);
      }
      return this.isImmutable;
    },
    /**
     * @returns {string[]}
     */
    dependsOn: function dependsOn() {
      return this.field.dependsOn || [];
    },
    /**
     * @returns {{[key: string]: any}}
     */
    currentFieldValues: function currentFieldValues() {
      return _defineProperty({}, this.fieldAttribute, this.value);
    },
    /**
     * @returns {{[key: string]: any}}
     */
    dependentFieldValues: function dependentFieldValues() {
      return _objectSpread(_objectSpread({}, this.currentFieldValues), this.watchedFields);
    },
    /**
     * @returns {string}
     */
    encodedDependentFieldValues: function encodedDependentFieldValues() {
      return btoa((0,_util_escapeUnicode__WEBPACK_IMPORTED_MODULE_9__.escapeUnicode)(JSON.stringify(this.dependentFieldValues)));
    },
    /**
     * Get the correct field sync endpoint URL.
     *
     * @returns {string}
     */
    syncFieldEndpoint: function syncFieldEndpoint() {
      if (this.editMode === 'update-attached') {
        return "/nova-api/".concat(this.resourceName, "/").concat(this.resourceId, "/update-pivot-fields/").concat(this.relatedResourceName, "/").concat(this.relatedResourceId);
      } else if (this.editMode === 'attach') {
        return "/nova-api/".concat(this.resourceName, "/").concat(this.resourceId, "/creation-pivot-fields/").concat(this.relatedResourceName);
      } else if (this.editMode === 'update') {
        return "/nova-api/".concat(this.resourceName, "/").concat(this.resourceId, "/update-fields");
      }
      return "/nova-api/".concat(this.resourceName, "/creation-fields");
    }
  }
});

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/mixins/FieldValue.js":
/*!***************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/mixins/FieldValue.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_filled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/filled */ "./vendor/laravel/nova/resources/js/util/filled.js");
/* harmony import */ var lodash_isArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash/isArray */ "./node_modules/lodash/isArray.js");
/* harmony import */ var lodash_isArray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_isArray__WEBPACK_IMPORTED_MODULE_1__);


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: ['field'],
  methods: {
    /**
     * @param {any} value
     * @returns {boolean}
     */
    isEqualsToValue: function isEqualsToValue(value) {
      var _this$field$value, _this$field$value2;
      if (lodash_isArray__WEBPACK_IMPORTED_MODULE_1___default()(this.field.value) && (0,_util_filled__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
        return Boolean(this.field.value.includes(value) || this.field.value.includes(value.toString()));
      }
      return Boolean(this.field.value === value || ((_this$field$value = this.field.value) === null || _this$field$value === void 0 ? void 0 : _this$field$value.toString()) === value || this.field.value === (value === null || value === void 0 ? void 0 : value.toString()) || ((_this$field$value2 = this.field.value) === null || _this$field$value2 === void 0 ? void 0 : _this$field$value2.toString()) === (value === null || value === void 0 ? void 0 : value.toString()));
    }
  },
  computed: {
    /**
     * @returns {string}
     */
    fieldAttribute: function fieldAttribute() {
      return this.field.attribute;
    },
    /**
     * @returns {boolean}
     */
    fieldHasValue: function fieldHasValue() {
      return (0,_util_filled__WEBPACK_IMPORTED_MODULE_0__["default"])(this.field.value);
    },
    /**
     * @returns {boolean}
     */
    usesCustomizedDisplay: function usesCustomizedDisplay() {
      return this.field.usesCustomizedDisplay && (0,_util_filled__WEBPACK_IMPORTED_MODULE_0__["default"])(this.field.displayedAs);
    },
    /**
     * @returns {boolean}
     */
    fieldHasValueOrCustomizedDisplay: function fieldHasValueOrCustomizedDisplay() {
      return this.usesCustomizedDisplay || this.fieldHasValue;
    },
    /**
     * @returns {string|null}
     */
    fieldValue: function fieldValue() {
      var _this$field$displayed;
      if (!this.fieldHasValueOrCustomizedDisplay) {
        return null;
      }
      return String((_this$field$displayed = this.field.displayedAs) !== null && _this$field$displayed !== void 0 ? _this$field$displayed : this.field.value);
    },
    /**
     * @returns {string|null}
     */
    shouldDisplayAsHtml: function shouldDisplayAsHtml() {
      return this.field.asHtml;
    }
  }
});

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/mixins/FormEvents.js":
/*!***************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/mixins/FormEvents.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: {
    formUniqueId: {
      type: String
    }
  },
  methods: {
    /**
     * @param {string} attribute
     * @param {any} value
     */
    emitFieldValue: function emitFieldValue(attribute, value) {
      Nova.$emit("".concat(attribute, "-value"), value);
      if (this.hasFormUniqueId === true) {
        Nova.$emit("".concat(this.formUniqueId, "-").concat(attribute, "-value"), value);
      }
    },
    /**
     * @param {string} attribute
     * @param {any} value
     */
    emitFieldValueChange: function emitFieldValueChange(attribute, value) {
      Nova.$emit("".concat(attribute, "-change"), value);
      if (this.hasFormUniqueId === true) {
        Nova.$emit("".concat(this.formUniqueId, "-").concat(attribute, "-change"), value);
      }
    },
    /**
     * Get field attribute value event name.
     *
     * @param {string} attribute
     * @returns {string}
     */
    getFieldAttributeValueEventName: function getFieldAttributeValueEventName(attribute) {
      return this.hasFormUniqueId === true ? "".concat(this.formUniqueId, "-").concat(attribute, "-value") : "".concat(attribute, "-value");
    },
    /**
     * Get field attribue value event name.
     *
     * @param {string} attribute
     * @returns {string}
     */
    getFieldAttributeChangeEventName: function getFieldAttributeChangeEventName(attribute) {
      return this.hasFormUniqueId === true ? "".concat(this.formUniqueId, "-").concat(attribute, "-change") : "".concat(attribute, "-change");
    }
  },
  computed: {
    /**
     * Return the field attribute.
     *
     * @returns {string}
     */
    fieldAttribute: function fieldAttribute() {
      return this.field.attribute;
    },
    /**
     * Determine if the field has Form Unique ID.
     *
     * @returns {boolean}
     */
    hasFormUniqueId: function hasFormUniqueId() {
      return this.formUniqueId != null && this.formUniqueId !== '';
    },
    /**
     * Get field attribue value event name.
     *
     * @returns {string}
     */
    fieldAttributeValueEventName: function fieldAttributeValueEventName() {
      return this.getFieldAttributeValueEventName(this.fieldAttribute);
    },
    /**
     * Get field attribue value event name.
     *
     * @returns {string}
     */
    fieldAttributeChangeEventName: function fieldAttributeChangeEventName() {
      return this.getFieldAttributeChangeEventName(this.fieldAttribute);
    }
  }
});

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/mixins/FormField.js":
/*!**************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/mixins/FormField.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/get */ "./node_modules/lodash/get.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _propTypes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./propTypes */ "./vendor/laravel/nova/resources/js/mixins/propTypes.js");
/* harmony import */ var _FormEvents__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FormEvents */ "./vendor/laravel/nova/resources/js/mixins/FormEvents.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  "extends": _FormEvents__WEBPACK_IMPORTED_MODULE_2__["default"],
  props: _objectSpread({}, (0,_propTypes__WEBPACK_IMPORTED_MODULE_1__.mapProps)(['nested', 'shownViaNewRelationModal', 'field', 'viaResource', 'viaResourceId', 'viaRelationship', 'resourceName', 'resourceId', 'showHelpText', 'mode'])),
  emits: ['field-changed'],
  data: function data() {
    return {
      value: this.fieldDefaultValue()
    };
  },
  created: function created() {
    this.setInitialValue();
  },
  mounted: function mounted() {
    // Add a default fill method for the field
    this.field.fill = this.fill;

    // Register a global event for setting the field's value
    Nova.$on(this.fieldAttributeValueEventName, this.listenToValueChanges);
  },
  beforeUnmount: function beforeUnmount() {
    Nova.$off(this.fieldAttributeValueEventName, this.listenToValueChanges);
  },
  methods: {
    /*
     * Set the initial value for the field
     */
    setInitialValue: function setInitialValue() {
      this.value = !(this.field.value === undefined || this.field.value === null) ? this.field.value : this.fieldDefaultValue();
    },
    /**
     * Return the field default value.
     *
     * @returns {string}
     */
    fieldDefaultValue: function fieldDefaultValue() {
      return '';
    },
    /**
     * Provide a function that fills a passed FormData object with the
     * field's internal value attribute.
     *
     * @param {FormData} formData
     */
    fill: function fill(formData) {
      this.fillIfVisible(formData, this.fieldAttribute, String(this.value));
    },
    /**
     * Provide a function to fills FormData when field.
     *
     * @param {FormData} formData
     * @param {string} attribute
     * @param {any} value
     */
    fillInto: function fillInto(formData, attribute, value) {
      formData.append(attribute, value);
    },
    /**
     * Provide a function to fills FormData when field is visible.
     *
     * @param {FormData} formData
     * @param {string} attribute
     * @param {any} value
     */
    fillIfVisible: function fillIfVisible(formData, attribute, value) {
      if (this.isVisible) {
        this.fillInto(formData, attribute, value);
      }
    },
    /**
     * Update the field's internal value..
     *
     * @param {Event} event
     */
    handleChange: function handleChange(event) {
      this.value = event.target.value;
      if (this.field) {
        this.emitFieldValueChange(this.fieldAttribute, this.value);
        this.$emit('field-changed');
      }
    },
    /**
     * Clean up any side-effects when removing this field dynamically (Repeater).
     */
    beforeRemove: function beforeRemove() {
      //
    },
    /**
     * @param {any} value
     */
    listenToValueChanges: function listenToValueChanges(value) {
      this.value = value;
    }
  },
  computed: {
    /**
     * Determine the current field.
     *
     * @returns {object}
     */
    currentField: function currentField() {
      return this.field;
    },
    /**
     * Determine if the field should use all the available white-space.
     *
     * @returns {boolean}
     */
    fullWidthContent: function fullWidthContent() {
      return this.currentField.fullWidth || this.field.fullWidth;
    },
    /**
     * Return the placeholder text for the field.
     *
     * @returns {string}
     */
    placeholder: function placeholder() {
      return this.currentField.placeholder || this.field.name;
    },
    /**
     * Determine if the field is in visible mode
     *
     * @returns {boolean}
     */
    isVisible: function isVisible() {
      return this.field.visible;
    },
    /**
     * Determine if the field is in readonly mode.
     *
     * @returns {boolean}
     */
    isReadonly: function isReadonly() {
      return Boolean(this.field.readonly || lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(this.field, 'extraAttributes.readonly'));
    },
    /**
     * Determine if the field is in immutable state.
     *
     * @return {boolean}
     */
    isImmutable: function isImmutable() {
      return Boolean(this.field.readonly === false && this.field.writable === true && lodash_get__WEBPACK_IMPORTED_MODULE_0___default()(this.field, 'extraAttributes.readonly') === true);
    },
    /**
     * Determine if the field is accessed from Action.
     *
     * @returns {boolean}
     */
    isActionRequest: function isActionRequest() {
      return ['action-fullscreen', 'action-modal'].includes(this.mode);
    }
  }
});

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/mixins/HandlesFieldAttachments.js":
/*!****************************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/mixins/HandlesFieldAttachments.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _propTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./propTypes */ "./vendor/laravel/nova/resources/js/mixins/propTypes.js");
/* harmony import */ var _util_FormValidation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/FormValidation */ "./vendor/laravel/nova/resources/js/util/FormValidation.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _toArray(r) { return _arrayWithHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return r; }; var t, r = {}, e = Object.prototype, n = e.hasOwnProperty, o = "function" == typeof Symbol ? Symbol : {}, i = o.iterator || "@@iterator", a = o.asyncIterator || "@@asyncIterator", u = o.toStringTag || "@@toStringTag"; function c(t, r, e, n) { return Object.defineProperty(t, r, { value: e, enumerable: !n, configurable: !n, writable: !n }); } try { c({}, ""); } catch (t) { c = function c(t, r, e) { return t[r] = e; }; } function h(r, e, n, o) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype); return c(a, "_invoke", function (r, e, n) { var o = 1; return function (i, a) { if (3 === o) throw Error("Generator is already running"); if (4 === o) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var u = n.delegate; if (u) { var c = d(u, n); if (c) { if (c === f) continue; return c; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (1 === o) throw o = 4, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = 3; var h = s(r, e, n); if ("normal" === h.type) { if (o = n.done ? 4 : 2, h.arg === f) continue; return { value: h.arg, done: n.done }; } "throw" === h.type && (o = 4, n.method = "throw", n.arg = h.arg); } }; }(r, n, new Context(o || [])), !0), a; } function s(t, r, e) { try { return { type: "normal", arg: t.call(r, e) }; } catch (t) { return { type: "throw", arg: t }; } } r.wrap = h; var f = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var l = {}; c(l, i, function () { return this; }); var p = Object.getPrototypeOf, y = p && p(p(x([]))); y && y !== e && n.call(y, i) && (l = y); var v = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(l); function g(t) { ["next", "throw", "return"].forEach(function (r) { c(t, r, function (t) { return this._invoke(r, t); }); }); } function AsyncIterator(t, r) { function e(o, i, a, u) { var c = s(t[o], t, i); if ("throw" !== c.type) { var h = c.arg, f = h.value; return f && "object" == _typeof(f) && n.call(f, "__await") ? r.resolve(f.__await).then(function (t) { e("next", t, a, u); }, function (t) { e("throw", t, a, u); }) : r.resolve(f).then(function (t) { h.value = t, a(h); }, function (t) { return e("throw", t, a, u); }); } u(c.arg); } var o; c(this, "_invoke", function (t, n) { function i() { return new r(function (r, o) { e(t, n, r, o); }); } return o = o ? o.then(i, i) : i(); }, !0); } function d(r, e) { var n = e.method, o = r.i[n]; if (o === t) return e.delegate = null, "throw" === n && r.i["return"] && (e.method = "return", e.arg = t, d(r, e), "throw" === e.method) || "return" !== n && (e.method = "throw", e.arg = new TypeError("The iterator does not provide a '" + n + "' method")), f; var i = s(o, r.i, e.arg); if ("throw" === i.type) return e.method = "throw", e.arg = i.arg, e.delegate = null, f; var a = i.arg; return a ? a.done ? (e[r.r] = a.value, e.next = r.n, "return" !== e.method && (e.method = "next", e.arg = t), e.delegate = null, f) : a : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, f); } function w(t) { this.tryEntries.push(t); } function m(r) { var e = r[4] || {}; e.type = "normal", e.arg = t, r[4] = e; } function Context(t) { this.tryEntries = [[-1]], t.forEach(w, this), this.reset(!0); } function x(r) { if (null != r) { var e = r[i]; if (e) return e.call(r); if ("function" == typeof r.next) return r; if (!isNaN(r.length)) { var o = -1, a = function e() { for (; ++o < r.length;) if (n.call(r, o)) return e.value = r[o], e.done = !1, e; return e.value = t, e.done = !0, e; }; return a.next = a; } } throw new TypeError(_typeof(r) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, c(v, "constructor", GeneratorFunctionPrototype), c(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = c(GeneratorFunctionPrototype, u, "GeneratorFunction"), r.isGeneratorFunction = function (t) { var r = "function" == typeof t && t.constructor; return !!r && (r === GeneratorFunction || "GeneratorFunction" === (r.displayName || r.name)); }, r.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, c(t, u, "GeneratorFunction")), t.prototype = Object.create(v), t; }, r.awrap = function (t) { return { __await: t }; }, g(AsyncIterator.prototype), c(AsyncIterator.prototype, a, function () { return this; }), r.AsyncIterator = AsyncIterator, r.async = function (t, e, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(h(t, e, n, o), i); return r.isGeneratorFunction(e) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, g(v), c(v, u, "Generator"), c(v, i, function () { return this; }), c(v, "toString", function () { return "[object Generator]"; }), r.keys = function (t) { var r = Object(t), e = []; for (var n in r) e.unshift(n); return function t() { for (; e.length;) if ((n = e.pop()) in r) return t.value = n, t.done = !1, t; return t.done = !0, t; }; }, r.values = x, Context.prototype = { constructor: Context, reset: function reset(r) { if (this.prev = this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(m), !r) for (var e in this) "t" === e.charAt(0) && n.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0][4]; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(r) { if (this.done) throw r; var e = this; function n(t) { a.type = "throw", a.arg = r, e.next = t; } for (var o = e.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i[4], u = this.prev, c = i[1], h = i[2]; if (-1 === i[0]) return n("end"), !1; if (!c && !h) throw Error("try statement without catch or finally"); if (null != i[0] && i[0] <= u) { if (u < c) return this.method = "next", this.arg = t, n(c), !0; if (u < h) return n(h), !1; } } }, abrupt: function abrupt(t, r) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var n = this.tryEntries[e]; if (n[0] > -1 && n[0] <= this.prev && this.prev < n[2]) { var o = n; break; } } o && ("break" === t || "continue" === t) && o[0] <= r && r <= o[2] && (o = null); var i = o ? o[4] : {}; return i.type = t, i.arg = r, o ? (this.method = "next", this.next = o[2], f) : this.complete(i); }, complete: function complete(t, r) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && r && (this.next = r), f; }, finish: function finish(t) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var e = this.tryEntries[r]; if (e[2] === t) return this.complete(e[4], e[3]), m(e), f; } }, "catch": function _catch(t) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var e = this.tryEntries[r]; if (e[0] === t) { var n = e[4]; if ("throw" === n.type) { var o = n.arg; m(e); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(r, e, n) { return this.delegate = { i: x(r), r: e, n: n }, "next" === this.method && (this.arg = t), f; } }, r; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  emits: ['file-upload-started', 'file-upload-finished'],
  props: (0,_propTypes__WEBPACK_IMPORTED_MODULE_0__.mapProps)(['resourceName']),
  created: function created() {
    var _this = this;
    return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var _yield$Nova$request$g, draftId;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            if (!_this.field.withFiles) {
              _context.next = 6;
              break;
            }
            _context.next = 3;
            return Nova.request().get("/nova-api/".concat(_this.resourceName, "/field-attachment/").concat(_this.fieldAttribute, "/draftId"));
          case 3:
            _yield$Nova$request$g = _context.sent;
            draftId = _yield$Nova$request$g.data.draftId;
            _this.draftId = draftId;
          case 6:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }))();
  },
  data: function data() {
    return {
      draftId: null,
      files: [],
      filesToRemove: []
    };
  },
  methods: {
    /**
     * Upload an attachment.
     *
     * @param {any} file
     * @param {{onUploadProgress?: Function, onCompleted?: Function, onFailure?: Function}}
     */
    uploadAttachment: function uploadAttachment(file, _ref) {
      var _this2 = this;
      var onUploadProgress = _ref.onUploadProgress,
        onCompleted = _ref.onCompleted,
        onFailure = _ref.onFailure;
      var data = new FormData();
      data.append('Content-Type', file.type);
      data.append('attachment', file);
      data.append('draftId', this.draftId);
      if (onUploadProgress == null) {
        onUploadProgress = function onUploadProgress() {};
      }
      if (onFailure == null) {
        onFailure = function onFailure() {};
      }
      if (onCompleted == null) {
        throw 'Missing onCompleted parameter';
      }
      this.$emit('file-upload-started');
      Nova.request().post("/nova-api/".concat(this.resourceName, "/field-attachment/").concat(this.fieldAttribute), data, {
        onUploadProgress: onUploadProgress
      }).then(function (_ref2) {
        var _ref2$data = _ref2.data,
          path = _ref2$data.path,
          url = _ref2$data.url;
        _this2.files.push({
          path: path,
          url: url
        });
        var response = onCompleted(path, url);
        _this2.$emit('file-upload-finished');
        return response;
      })["catch"](function (error) {
        onFailure(error);
        if (error.response.status == 422) {
          var validationErrors = new _util_FormValidation__WEBPACK_IMPORTED_MODULE_1__.Errors(error.response.data.errors);
          Nova.error(_this2.__('An error occurred while uploading the file: :error', {
            error: validationErrors.first('attachment')
          }));
        } else {
          Nova.error(_this2.__('An error occurred while uploading the file.'));
        }
      });
    },
    /**
     * Remove an attachment from the server.
     *
     * @param {string} url
     */
    flagFileForRemoval: function flagFileForRemoval(url) {
      var fileIndex = this.files.findIndex(function (file) {
        return file.url === url;
      });
      if (fileIndex !== -1) {
        this.filesToRemove.push(this.files[fileIndex]);
        return;
      }
      // Case of deleting a file which was added prior to this draft
      this.filesToRemove.push({
        url: url
      });
    },
    /**
     * Unflag an attachment from removal.
     *
     * @param {string} url
     */
    unflagFileForRemoval: function unflagFileForRemoval(url) {
      var fileIndex = this.filesToRemove.findIndex(function (file) {
        return file.url === url;
      });
      if (fileIndex === -1) {
        return;
      }
      this.filesToRemove.splice(fileIndex, 1);
    },
    /**
     * Purge pending attachments for the draft
     */
    clearAttachments: function clearAttachments() {
      if (this.field.withFiles) {
        Nova.request()["delete"]("/nova-api/".concat(this.resourceName, "/field-attachment/").concat(this.fieldAttribute, "/").concat(this.draftId)).then(function (response) {})["catch"](function (error) {});
      }
    },
    clearFilesMarkedForRemoval: function clearFilesMarkedForRemoval() {
      var _this3 = this;
      if (this.field.withFiles) {
        this.filesToRemove.forEach(function (file) {
          Nova.debug('deleting', file);
          Nova.request()["delete"]("/nova-api/".concat(_this3.resourceName, "/field-attachment/").concat(_this3.fieldAttribute), {
            params: {
              attachment: file.path,
              attachmentUrl: file.url,
              draftId: _this3.draftId
            }
          }).then(function (response) {})["catch"](function (error) {});
        });
      }
    },
    /**
     * Fill draft id for the field.
     *
     * @param {FormData} formData
     */
    fillAttachmentDraftId: function fillAttachmentDraftId(formData) {
      var attribute = this.fieldAttribute;
      var _attribute$split = attribute.split('['),
        _attribute$split2 = _toArray(_attribute$split),
        name = _attribute$split2[0],
        nested = _attribute$split2.slice(1);
      if (nested != null && nested.length > 0) {
        var last = nested.pop();
        if (nested.length > 0) {
          attribute = "".concat(name, "[").concat(nested.join('['), "[").concat(last.slice(0, -1), "DraftId]");
        } else {
          attribute = "".concat(name, "[").concat(last.slice(0, -1), "DraftId]");
        }
      } else {
        attribute = "".concat(attribute, "DraftId");
      }
      this.fillIfVisible(formData, attribute, this.draftId);
    }
  }
});

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/mixins/HandlesFieldPreviews.js":
/*!*************************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/mixins/HandlesFieldPreviews.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _propTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./propTypes */ "./vendor/laravel/nova/resources/js/mixins/propTypes.js");
/* harmony import */ var _util_filled__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/filled */ "./vendor/laravel/nova/resources/js/util/filled.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return r; }; var t, r = {}, e = Object.prototype, n = e.hasOwnProperty, o = "function" == typeof Symbol ? Symbol : {}, i = o.iterator || "@@iterator", a = o.asyncIterator || "@@asyncIterator", u = o.toStringTag || "@@toStringTag"; function c(t, r, e, n) { return Object.defineProperty(t, r, { value: e, enumerable: !n, configurable: !n, writable: !n }); } try { c({}, ""); } catch (t) { c = function c(t, r, e) { return t[r] = e; }; } function h(r, e, n, o) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype); return c(a, "_invoke", function (r, e, n) { var o = 1; return function (i, a) { if (3 === o) throw Error("Generator is already running"); if (4 === o) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var u = n.delegate; if (u) { var c = d(u, n); if (c) { if (c === f) continue; return c; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (1 === o) throw o = 4, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = 3; var h = s(r, e, n); if ("normal" === h.type) { if (o = n.done ? 4 : 2, h.arg === f) continue; return { value: h.arg, done: n.done }; } "throw" === h.type && (o = 4, n.method = "throw", n.arg = h.arg); } }; }(r, n, new Context(o || [])), !0), a; } function s(t, r, e) { try { return { type: "normal", arg: t.call(r, e) }; } catch (t) { return { type: "throw", arg: t }; } } r.wrap = h; var f = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var l = {}; c(l, i, function () { return this; }); var p = Object.getPrototypeOf, y = p && p(p(x([]))); y && y !== e && n.call(y, i) && (l = y); var v = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(l); function g(t) { ["next", "throw", "return"].forEach(function (r) { c(t, r, function (t) { return this._invoke(r, t); }); }); } function AsyncIterator(t, r) { function e(o, i, a, u) { var c = s(t[o], t, i); if ("throw" !== c.type) { var h = c.arg, f = h.value; return f && "object" == _typeof(f) && n.call(f, "__await") ? r.resolve(f.__await).then(function (t) { e("next", t, a, u); }, function (t) { e("throw", t, a, u); }) : r.resolve(f).then(function (t) { h.value = t, a(h); }, function (t) { return e("throw", t, a, u); }); } u(c.arg); } var o; c(this, "_invoke", function (t, n) { function i() { return new r(function (r, o) { e(t, n, r, o); }); } return o = o ? o.then(i, i) : i(); }, !0); } function d(r, e) { var n = e.method, o = r.i[n]; if (o === t) return e.delegate = null, "throw" === n && r.i["return"] && (e.method = "return", e.arg = t, d(r, e), "throw" === e.method) || "return" !== n && (e.method = "throw", e.arg = new TypeError("The iterator does not provide a '" + n + "' method")), f; var i = s(o, r.i, e.arg); if ("throw" === i.type) return e.method = "throw", e.arg = i.arg, e.delegate = null, f; var a = i.arg; return a ? a.done ? (e[r.r] = a.value, e.next = r.n, "return" !== e.method && (e.method = "next", e.arg = t), e.delegate = null, f) : a : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, f); } function w(t) { this.tryEntries.push(t); } function m(r) { var e = r[4] || {}; e.type = "normal", e.arg = t, r[4] = e; } function Context(t) { this.tryEntries = [[-1]], t.forEach(w, this), this.reset(!0); } function x(r) { if (null != r) { var e = r[i]; if (e) return e.call(r); if ("function" == typeof r.next) return r; if (!isNaN(r.length)) { var o = -1, a = function e() { for (; ++o < r.length;) if (n.call(r, o)) return e.value = r[o], e.done = !1, e; return e.value = t, e.done = !0, e; }; return a.next = a; } } throw new TypeError(_typeof(r) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, c(v, "constructor", GeneratorFunctionPrototype), c(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = c(GeneratorFunctionPrototype, u, "GeneratorFunction"), r.isGeneratorFunction = function (t) { var r = "function" == typeof t && t.constructor; return !!r && (r === GeneratorFunction || "GeneratorFunction" === (r.displayName || r.name)); }, r.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, c(t, u, "GeneratorFunction")), t.prototype = Object.create(v), t; }, r.awrap = function (t) { return { __await: t }; }, g(AsyncIterator.prototype), c(AsyncIterator.prototype, a, function () { return this; }), r.AsyncIterator = AsyncIterator, r.async = function (t, e, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(h(t, e, n, o), i); return r.isGeneratorFunction(e) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, g(v), c(v, u, "Generator"), c(v, i, function () { return this; }), c(v, "toString", function () { return "[object Generator]"; }), r.keys = function (t) { var r = Object(t), e = []; for (var n in r) e.unshift(n); return function t() { for (; e.length;) if ((n = e.pop()) in r) return t.value = n, t.done = !1, t; return t.done = !0, t; }; }, r.values = x, Context.prototype = { constructor: Context, reset: function reset(r) { if (this.prev = this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(m), !r) for (var e in this) "t" === e.charAt(0) && n.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0][4]; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(r) { if (this.done) throw r; var e = this; function n(t) { a.type = "throw", a.arg = r, e.next = t; } for (var o = e.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i[4], u = this.prev, c = i[1], h = i[2]; if (-1 === i[0]) return n("end"), !1; if (!c && !h) throw Error("try statement without catch or finally"); if (null != i[0] && i[0] <= u) { if (u < c) return this.method = "next", this.arg = t, n(c), !0; if (u < h) return n(h), !1; } } }, abrupt: function abrupt(t, r) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var n = this.tryEntries[e]; if (n[0] > -1 && n[0] <= this.prev && this.prev < n[2]) { var o = n; break; } } o && ("break" === t || "continue" === t) && o[0] <= r && r <= o[2] && (o = null); var i = o ? o[4] : {}; return i.type = t, i.arg = r, o ? (this.method = "next", this.next = o[2], f) : this.complete(i); }, complete: function complete(t, r) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && r && (this.next = r), f; }, finish: function finish(t) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var e = this.tryEntries[r]; if (e[2] === t) return this.complete(e[4], e[3]), m(e), f; } }, "catch": function _catch(t) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var e = this.tryEntries[r]; if (e[0] === t) { var n = e[4]; if ("throw" === n.type) { var o = n.arg; m(e); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(r, e, n) { return this.delegate = { i: x(r), r: e, n: n }, "next" === this.method && (this.arg = t), f; } }, r; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: (0,_propTypes__WEBPACK_IMPORTED_MODULE_0__.mapProps)(['field', 'resourceName', 'resourceId', 'viaResource', 'viaResourceId', 'viaRelationship', 'relatedResourceName', 'relatedResourceId', 'mode']),
  methods: {
    fetchPreviewContent: function fetchPreviewContent(value) {
      var _this = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var editMode, endpoint, _yield$Nova$request$p, preview;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              Nova.$progress.start();
              editMode = _this.resourceId == null ? 'create' : 'update';
              endpoint = _this.resourceId == null ? "/nova-api/".concat(_this.resourceName, "/field/").concat(_this.field.attribute, "/preview") : "/nova-api/".concat(_this.resourceName, "/").concat(_this.resourceId, "/field/").concat(_this.field.attribute, "/preview");
              if ((0,_util_filled__WEBPACK_IMPORTED_MODULE_1__["default"])(_this.relatedResourceName)) {
                editMode = _this.relatedResourceId == null ? 'attach' : 'update-attached';
                endpoint = "".concat(endpoint, "/").concat(_this.relatedResourceName);
              }
              _context.next = 6;
              return Nova.request().post(endpoint, {
                value: value
              }, {
                params: {
                  editing: true,
                  editMode: editMode,
                  viaResource: _this.viaResource,
                  viaResourceId: _this.viaResourceId,
                  viaRelationship: _this.viaRelationship
                }
              });
            case 6:
              _yield$Nova$request$p = _context.sent;
              preview = _yield$Nova$request$p.data.preview;
              Nova.$progress.done();
              return _context.abrupt("return", preview);
            case 10:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  }
});

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/mixins/HandlesFormRequest.js":
/*!***********************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/mixins/HandlesFormRequest.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_FormValidation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/FormValidation */ "./vendor/laravel/nova/resources/js/util/FormValidation.js");


/**
 * @typedef {import('axios').AxiosResponse} AxiosResponse
 */

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: {
    formUniqueId: {
      type: String
    }
  },
  data: function data() {
    return {
      validationErrors: new _util_FormValidation__WEBPACK_IMPORTED_MODULE_0__.Errors()
    };
  },
  methods: {
    /**
     * Handle all response error.
     *
     * @param {AxiosResponse} error
     */
    handleResponseError: function handleResponseError(error) {
      Nova.debug(error, 'error');
      if (error.response === undefined || error.response.status == 500) {
        Nova.error(this.__('There was a problem submitting the form.'));
      } else if (error.response.status == 422) {
        this.validationErrors = new _util_FormValidation__WEBPACK_IMPORTED_MODULE_0__.Errors(error.response.data.errors);
        Nova.error(this.__('There was a problem submitting the form.'));
      } else {
        Nova.error(this.__('There was a problem submitting the form.') + ' "' + error.response.statusText + '"');
      }
    },
    /**
     * Handle creating response error.
     *
     * @param {AxiosResponse} error
     */
    handleOnCreateResponseError: function handleOnCreateResponseError(error) {
      this.handleResponseError(error);
    },
    /**
     * Handle updating response error.
     *
     * @param {AxiosResponse} error
     */
    handleOnUpdateResponseError: function handleOnUpdateResponseError(error) {
      if (error.response && error.response.status == 409) {
        Nova.error(this.__('Another user has updated this resource since this page was loaded. Please refresh the page and try again.'));
      } else {
        this.handleResponseError(error);
      }
    },
    /**
     * Reset validation errors.
     */
    resetErrors: function resetErrors() {
      this.validationErrors = new _util_FormValidation__WEBPACK_IMPORTED_MODULE_0__.Errors();
    }
  }
});

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/mixins/HandlesPanelVisibility.js":
/*!***************************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/mixins/HandlesPanelVisibility.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _composables_usePanelVisibility__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../composables/usePanelVisibility */ "./vendor/laravel/nova/resources/js/composables/usePanelVisibility.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  emits: ['field-shown', 'field-hidden'],
  data: function data() {
    return {
      visibleFieldsForPanel: null
    };
  },
  created: function created() {
    this.visibleFieldsForPanel = (0,_composables_usePanelVisibility__WEBPACK_IMPORTED_MODULE_0__.usePanelVisibility)(this.panel, this.$emit);
  },
  methods: {
    /**
     * @param {string} field
     */
    handleFieldShown: function handleFieldShown(field) {
      this.visibleFieldsForPanel.handleFieldShown(field);
    },
    /**
     * @param {string} field
     */
    handleFieldHidden: function handleFieldHidden(field) {
      this.visibleFieldsForPanel.handleFieldHidden(field);
    }
  },
  computed: {
    /**
     * @returns {number}
     */
    visibleFieldsCount: function visibleFieldsCount() {
      return this.visibleFieldsForPanel.visibleFieldsCount;
    }
  }
});

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/mixins/HandlesUploads.js":
/*!*******************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/mixins/HandlesUploads.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  data: function data() {
    return {
      isWorking: false,
      fileUploadsCount: 0
    };
  },
  methods: {
    /**
     * Handle file upload finishing
     */
    handleFileUploadFinished: function handleFileUploadFinished() {
      this.fileUploadsCount--;
      if (this.fileUploadsCount < 1) {
        this.fileUploadsCount = 0;
        this.isWorking = false;
      }
    },
    /**
     * Handle file upload starting
     */
    handleFileUploadStarted: function handleFileUploadStarted() {
      this.isWorking = true;
      this.fileUploadsCount++;
    }
  }
});

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/mixins/HandlesValidationErrors.js":
/*!****************************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/mixins/HandlesValidationErrors.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _propTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./propTypes */ "./vendor/laravel/nova/resources/js/mixins/propTypes.js");
/* harmony import */ var _util_FormValidation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/FormValidation */ "./vendor/laravel/nova/resources/js/util/FormValidation.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: _objectSpread({
    errors: {
      "default": function _default() {
        return new _util_FormValidation__WEBPACK_IMPORTED_MODULE_1__.Errors();
      }
    }
  }, (0,_propTypes__WEBPACK_IMPORTED_MODULE_0__.mapProps)(['field'])),
  inject: {
    index: {
      "default": null
    },
    viaParent: {
      "default": null
    }
  },
  data: function data() {
    return {
      errorClass: 'form-control-bordered-error'
    };
  },
  computed: {
    /**
     * @returns {string[]}
     */
    errorClasses: function errorClasses() {
      return this.hasError ? [this.errorClass] : [];
    },
    /**
     * @returns {string}
     */
    fieldAttribute: function fieldAttribute() {
      return this.field.attribute;
    },
    /**
     * @returns {string}
     */
    validationKey: function validationKey() {
      return this.nestedValidationKey || this.field.validationKey;
    },
    /**
     * @returns {boolean}
     */
    hasError: function hasError() {
      return this.errors.has(this.validationKey);
    },
    /**
     * @returns {string}
     */
    firstError: function firstError() {
      if (this.hasError) {
        return this.errors.first(this.validationKey);
      }
    },
    /**
     * @returns {string|null}
     */
    nestedAttribute: function nestedAttribute() {
      if (this.viaParent) {
        return "".concat(this.viaParent, "[").concat(this.index, "][").concat(this.field.attribute, "]");
      }
    },
    /**
     * @returns {string|null}
     */
    nestedValidationKey: function nestedValidationKey() {
      if (this.viaParent) {
        return "".concat(this.viaParent, ".").concat(this.index, ".fields.").concat(this.field.attribute);
      }
    }
  }
});

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/mixins/HasCards.js":
/*!*************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/mixins/HasCards.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return r; }; var t, r = {}, e = Object.prototype, n = e.hasOwnProperty, o = "function" == typeof Symbol ? Symbol : {}, i = o.iterator || "@@iterator", a = o.asyncIterator || "@@asyncIterator", u = o.toStringTag || "@@toStringTag"; function c(t, r, e, n) { return Object.defineProperty(t, r, { value: e, enumerable: !n, configurable: !n, writable: !n }); } try { c({}, ""); } catch (t) { c = function c(t, r, e) { return t[r] = e; }; } function h(r, e, n, o) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype); return c(a, "_invoke", function (r, e, n) { var o = 1; return function (i, a) { if (3 === o) throw Error("Generator is already running"); if (4 === o) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var u = n.delegate; if (u) { var c = d(u, n); if (c) { if (c === f) continue; return c; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (1 === o) throw o = 4, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = 3; var h = s(r, e, n); if ("normal" === h.type) { if (o = n.done ? 4 : 2, h.arg === f) continue; return { value: h.arg, done: n.done }; } "throw" === h.type && (o = 4, n.method = "throw", n.arg = h.arg); } }; }(r, n, new Context(o || [])), !0), a; } function s(t, r, e) { try { return { type: "normal", arg: t.call(r, e) }; } catch (t) { return { type: "throw", arg: t }; } } r.wrap = h; var f = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var l = {}; c(l, i, function () { return this; }); var p = Object.getPrototypeOf, y = p && p(p(x([]))); y && y !== e && n.call(y, i) && (l = y); var v = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(l); function g(t) { ["next", "throw", "return"].forEach(function (r) { c(t, r, function (t) { return this._invoke(r, t); }); }); } function AsyncIterator(t, r) { function e(o, i, a, u) { var c = s(t[o], t, i); if ("throw" !== c.type) { var h = c.arg, f = h.value; return f && "object" == _typeof(f) && n.call(f, "__await") ? r.resolve(f.__await).then(function (t) { e("next", t, a, u); }, function (t) { e("throw", t, a, u); }) : r.resolve(f).then(function (t) { h.value = t, a(h); }, function (t) { return e("throw", t, a, u); }); } u(c.arg); } var o; c(this, "_invoke", function (t, n) { function i() { return new r(function (r, o) { e(t, n, r, o); }); } return o = o ? o.then(i, i) : i(); }, !0); } function d(r, e) { var n = e.method, o = r.i[n]; if (o === t) return e.delegate = null, "throw" === n && r.i["return"] && (e.method = "return", e.arg = t, d(r, e), "throw" === e.method) || "return" !== n && (e.method = "throw", e.arg = new TypeError("The iterator does not provide a '" + n + "' method")), f; var i = s(o, r.i, e.arg); if ("throw" === i.type) return e.method = "throw", e.arg = i.arg, e.delegate = null, f; var a = i.arg; return a ? a.done ? (e[r.r] = a.value, e.next = r.n, "return" !== e.method && (e.method = "next", e.arg = t), e.delegate = null, f) : a : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, f); } function w(t) { this.tryEntries.push(t); } function m(r) { var e = r[4] || {}; e.type = "normal", e.arg = t, r[4] = e; } function Context(t) { this.tryEntries = [[-1]], t.forEach(w, this), this.reset(!0); } function x(r) { if (null != r) { var e = r[i]; if (e) return e.call(r); if ("function" == typeof r.next) return r; if (!isNaN(r.length)) { var o = -1, a = function e() { for (; ++o < r.length;) if (n.call(r, o)) return e.value = r[o], e.done = !1, e; return e.value = t, e.done = !0, e; }; return a.next = a; } } throw new TypeError(_typeof(r) + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, c(v, "constructor", GeneratorFunctionPrototype), c(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = c(GeneratorFunctionPrototype, u, "GeneratorFunction"), r.isGeneratorFunction = function (t) { var r = "function" == typeof t && t.constructor; return !!r && (r === GeneratorFunction || "GeneratorFunction" === (r.displayName || r.name)); }, r.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, c(t, u, "GeneratorFunction")), t.prototype = Object.create(v), t; }, r.awrap = function (t) { return { __await: t }; }, g(AsyncIterator.prototype), c(AsyncIterator.prototype, a, function () { return this; }), r.AsyncIterator = AsyncIterator, r.async = function (t, e, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(h(t, e, n, o), i); return r.isGeneratorFunction(e) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, g(v), c(v, u, "Generator"), c(v, i, function () { return this; }), c(v, "toString", function () { return "[object Generator]"; }), r.keys = function (t) { var r = Object(t), e = []; for (var n in r) e.unshift(n); return function t() { for (; e.length;) if ((n = e.pop()) in r) return t.value = n, t.done = !1, t; return t.done = !0, t; }; }, r.values = x, Context.prototype = { constructor: Context, reset: function reset(r) { if (this.prev = this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(m), !r) for (var e in this) "t" === e.charAt(0) && n.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0][4]; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(r) { if (this.done) throw r; var e = this; function n(t) { a.type = "throw", a.arg = r, e.next = t; } for (var o = e.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i[4], u = this.prev, c = i[1], h = i[2]; if (-1 === i[0]) return n("end"), !1; if (!c && !h) throw Error("try statement without catch or finally"); if (null != i[0] && i[0] <= u) { if (u < c) return this.method = "next", this.arg = t, n(c), !0; if (u < h) return n(h), !1; } } }, abrupt: function abrupt(t, r) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var n = this.tryEntries[e]; if (n[0] > -1 && n[0] <= this.prev && this.prev < n[2]) { var o = n; break; } } o && ("break" === t || "continue" === t) && o[0] <= r && r <= o[2] && (o = null); var i = o ? o[4] : {}; return i.type = t, i.arg = r, o ? (this.method = "next", this.next = o[2], f) : this.complete(i); }, complete: function complete(t, r) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && r && (this.next = r), f; }, finish: function finish(t) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var e = this.tryEntries[r]; if (e[2] === t) return this.complete(e[4], e[3]), m(e), f; } }, "catch": function _catch(t) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var e = this.tryEntries[r]; if (e[0] === t) { var n = e[4]; if ("throw" === n.type) { var o = n.arg; m(e); } return o; } } throw Error("illegal catch attempt"); }, delegateYield: function delegateYield(r, e, n) { return this.delegate = { i: x(r), r: e, n: n }, "next" === this.method && (this.arg = t), f; } }, r; }
function asyncGeneratorStep(n, t, e, r, o, a, c) { try { var i = n[a](c), u = i.value; } catch (n) { return void e(n); } i.done ? t(u) : Promise.resolve(u).then(r, o); }
function _asyncToGenerator(n) { return function () { var t = this, e = arguments; return new Promise(function (r, o) { var a = n.apply(t, e); function _next(n) { asyncGeneratorStep(a, r, o, _next, _throw, "next", n); } function _throw(n) { asyncGeneratorStep(a, r, o, _next, _throw, "throw", n); } _next(void 0); }); }; }
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: {
    loadCards: {
      type: Boolean,
      "default": true
    }
  },
  data: function data() {
    return {
      cards: []
    };
  },
  /**
   * Fetch all of the metrics panels for this view
   */
  created: function created() {
    this.fetchCards();
  },
  watch: {
    cardsEndpoint: function cardsEndpoint() {
      this.fetchCards();
    }
  },
  methods: {
    fetchCards: function fetchCards() {
      var _this = this;
      return _asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var _yield$Nova$request$g, cards;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (!_this.loadCards) {
                _context.next = 6;
                break;
              }
              _context.next = 3;
              return Nova.request().get(_this.cardsEndpoint, {
                params: _this.extraCardParams
              });
            case 3:
              _yield$Nova$request$g = _context.sent;
              cards = _yield$Nova$request$g.data;
              _this.cards = cards;
            case 6:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }))();
    }
  },
  computed: {
    /**
     * Determine whether we have cards to show on the Dashboard.
     *
     * @returns {boolean}
     */
    shouldShowCards: function shouldShowCards() {
      return this.cards.length > 0;
    },
    /**
     * Determine if the cards array contains some detail-only cards.
     *
     * @returns {boolean}
     */
    hasDetailOnlyCards: function hasDetailOnlyCards() {
      return this.cards.filter(function (c) {
        return c.onlyOnDetail == true;
      }).length > 0;
    },
    /**
     * Get the extra card params to pass to the endpoint.
     *
     * @returns {null}
     */
    extraCardParams: function extraCardParams() {
      return null;
    }
  }
});

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/mixins/InteractsWithDates.js":
/*!***********************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/mixins/InteractsWithDates.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_hourCycle__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/hourCycle */ "./vendor/laravel/nova/resources/js/util/hourCycle.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  computed: {
    /**
     * Get the user's local timezone.
     *
     * @returns {string}
     */
    userTimezone: function userTimezone() {
      return Nova.config('userTimezone') || Nova.config('timezone');
    },
    /**
     * Determine if the user is used to 12 hour time.
     *
     * @returns {boolean}
     */
    usesTwelveHourTime: function usesTwelveHourTime() {
      var locale = new Intl.DateTimeFormat().resolvedOptions().locale;
      return (0,_util_hourCycle__WEBPACK_IMPORTED_MODULE_0__["default"])(locale) === 12;
    }
  }
});

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/mixins/InteractsWithResourceInformation.js":
/*!*************************************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/mixins/InteractsWithResourceInformation.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _composables_useResourceInformation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../composables/useResourceInformation */ "./vendor/laravel/nova/resources/js/composables/useResourceInformation.js");

var _useResourceInformati = (0,_composables_useResourceInformation__WEBPACK_IMPORTED_MODULE_0__.useResourceInformation)(),
  _resourceInformation = _useResourceInformati.resourceInformation,
  _viaResourceInformation = _useResourceInformati.viaResourceInformation,
  _authorizedToCreate = _useResourceInformati.authorizedToCreate;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  computed: {
    /**
     * Get the resource information object for the current resource.
     *
     * @returns {object|null}
     */
    resourceInformation: function resourceInformation() {
      return _resourceInformation(this.resourceName);
    },
    /**
     * Get the resource information object for the current resource.
     *
     * @returns {object|null}
     */
    viaResourceInformation: function viaResourceInformation() {
      return _viaResourceInformation(this.viaResource);
    },
    /**
     * Determine if the user is authorized to create the current resource.
     *
     * @returns {boolean}
     */
    authorizedToCreate: function authorizedToCreate() {
      return _authorizedToCreate(this.resourceName, this.relationshipType);
    }
  }
});

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/mixins/Localization.js":
/*!*****************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/mixins/Localization.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_localization__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/localization */ "./vendor/laravel/nova/resources/js/util/localization.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  methods: {
    /**
     * Translate the given key.
     *
     * @param {string} key
     * @param {{[key: string]: string}} replace
     * @returns {string}
     */
    __: function __(key, replace) {
      return (0,_util_localization__WEBPACK_IMPORTED_MODULE_0__["default"])(key, replace);
    }
  }
});

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/mixins/MetricBehavior.js":
/*!*******************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/mixins/MetricBehavior.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var uid_single__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uid/single */ "./node_modules/uid/single/index.mjs");
/* harmony import */ var _util_minimum__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/minimum */ "./vendor/laravel/nova/resources/js/util/minimum.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: {
    card: {
      type: Object,
      required: true
    },
    dashboard: {
      type: String,
      required: false
    },
    resourceName: {
      type: String,
      "default": ''
    },
    resourceId: {
      type: [Number, String],
      "default": ''
    },
    lens: {
      type: String,
      "default": ''
    }
  },
  data: function data() {
    return {
      metricUniqueId: (0,uid_single__WEBPACK_IMPORTED_MODULE_0__.uid)()
    };
  },
  created: function created() {
    Nova.$on('metric-refresh', this.fetch);
    Nova.$on('resources-deleted', this.fetch);
    Nova.$on('resources-detached', this.fetch);
    Nova.$on('resources-restored', this.fetch);
    if (this.card.refreshWhenActionRuns) {
      Nova.$on('action-executed', this.fetch);
    }
  },
  mounted: function mounted() {
    Nova.$emit('vue.mounted:metric', {
      component: this,
      id: this.metricUniqueId
    });
  },
  beforeUnmount: function beforeUnmount() {
    Nova.$off('metric-refresh', this.fetch);
    Nova.$off('resources-deleted', this.fetch);
    Nova.$off('resources-detached', this.fetch);
    Nova.$off('resources-restored', this.fetch);
    Nova.$off('action-executed', this.fetch);
    Nova.$emit('vue.unmounted:metric', {
      component: this,
      id: this.metricUniqueId
    });
  },
  methods: {
    fetch: function fetch() {
      this.loading = true;
      (0,_util_minimum__WEBPACK_IMPORTED_MODULE_1__["default"])(Nova.request().get(this.metricEndpoint, this.metricPayload)).then(this.handleFetchCallback());
    },
    /**
     * @returns [Function]
     */
    handleFetchCallback: function handleFetchCallback() {
      return function () {
        return;
      };
    }
  },
  computed: {
    /**
     * @returns {string}
     */
    metricEndpoint: function metricEndpoint() {
      var lens = this.lens !== '' ? "/lens/".concat(this.lens) : '';
      if (this.resourceName && this.resourceId) {
        return "/nova-api/".concat(this.resourceName).concat(lens, "/").concat(this.resourceId, "/metrics/").concat(this.card.uriKey);
      } else if (this.resourceName) {
        return "/nova-api/".concat(this.resourceName).concat(lens, "/metrics/").concat(this.card.uriKey);
      }
      return "/nova-api/dashboards/cards/".concat(this.dashboard, "/metrics/").concat(this.card.uriKey);
    },
    /**
     * @returns {{[key: string]: any}}
     */
    metricPayload: function metricPayload() {
      return {};
    }
  }
});

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/mixins/PreventsFormAbandonment.js":
/*!****************************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/mixins/PreventsFormAbandonment.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _util_filled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/filled */ "./vendor/laravel/nova/resources/js/util/filled.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  data: function data() {
    return {
      navigateBackUsingHistory: true
    };
  },
  methods: {
    enableNavigateBackUsingHistory: function enableNavigateBackUsingHistory() {
      this.navigateBackUsingHistory = false;
    },
    disableNavigateBackUsingHistory: function disableNavigateBackUsingHistory() {
      this.navigateBackUsingHistory = false;
    },
    /**
     * @param {boolean} [reset=false]
     */
    handleProceedingToPreviousPage: function handleProceedingToPreviousPage() {
      var reset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (reset && this.navigateBackUsingHistory) {
        window.history.back();
      }
    },
    /**
     * @api
     * @param {string} url
     */
    proceedToPreviousPage: function proceedToPreviousPage(url) {
      if ((0,_util_filled__WEBPACK_IMPORTED_MODULE_0__["default"])(url)) {
        Nova.visit(url);
      } else {
        Nova.visit('/');
      }
    }
  }
});

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/mixins/PreventsModalAbandonment.js":
/*!*****************************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/mixins/PreventsModalAbandonment.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var vuex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vuex */ "./node_modules/vuex/dist/vuex.esm-bundler.js");
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  props: {
    show: {
      type: Boolean,
      "default": false
    }
  },
  methods: _objectSpread(_objectSpread({}, (0,vuex__WEBPACK_IMPORTED_MODULE_0__.mapMutations)(['allowLeavingModal', 'preventLeavingModal'])), {}, {
    /**
     * Prevent accidental abandonment only if form was changed.
     */
    updateModalStatus: function updateModalStatus() {
      this.preventLeavingModal();
    },
    /**
     * @param {Function} proceed
     * @param {Function} revert
     */
    handlePreventModalAbandonment: function handlePreventModalAbandonment(proceed, revert) {
      if (this.canLeaveModal) {
        proceed();
        return;
      }
      if (window.confirm(this.__('Do you really want to leave? You have unsaved changes.'))) {
        this.allowLeavingModal();
        proceed();
        return;
      }
      revert();
    }
  }),
  computed: _objectSpread({}, (0,vuex__WEBPACK_IMPORTED_MODULE_0__.mapGetters)(['canLeaveModal']))
});

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/mixins/packages.js":
/*!*************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/mixins/packages.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BehavesAsPanel: () => (/* reexport safe */ _BehavesAsPanel__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   CopiesToClipboard: () => (/* reexport safe */ _CopiesToClipboard__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   DependentFormField: () => (/* reexport safe */ _DependentFormField__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   Errors: () => (/* reexport safe */ _util_FormValidation__WEBPACK_IMPORTED_MODULE_20__.Errors),
/* harmony export */   FieldValue: () => (/* reexport safe */ _FieldValue__WEBPACK_IMPORTED_MODULE_12__["default"]),
/* harmony export */   FormEvents: () => (/* reexport safe */ _FormEvents__WEBPACK_IMPORTED_MODULE_13__["default"]),
/* harmony export */   FormField: () => (/* reexport safe */ _FormField__WEBPACK_IMPORTED_MODULE_14__["default"]),
/* harmony export */   HandlesFieldAttachments: () => (/* reexport safe */ _HandlesFieldAttachments__WEBPACK_IMPORTED_MODULE_15__["default"]),
/* harmony export */   HandlesFieldPreviews: () => (/* reexport safe */ _HandlesFieldPreviews__WEBPACK_IMPORTED_MODULE_16__["default"]),
/* harmony export */   HandlesFormRequest: () => (/* reexport safe */ _HandlesFormRequest__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   HandlesPanelVisibility: () => (/* reexport safe */ _HandlesPanelVisibility__WEBPACK_IMPORTED_MODULE_19__["default"]),
/* harmony export */   HandlesUploads: () => (/* reexport safe */ _HandlesUploads__WEBPACK_IMPORTED_MODULE_7__["default"]),
/* harmony export */   HandlesValidationErrors: () => (/* reexport safe */ _HandlesValidationErrors__WEBPACK_IMPORTED_MODULE_17__["default"]),
/* harmony export */   HasCards: () => (/* reexport safe */ _HasCards__WEBPACK_IMPORTED_MODULE_18__["default"]),
/* harmony export */   InteractsWithDates: () => (/* reexport safe */ _InteractsWithDates__WEBPACK_IMPORTED_MODULE_9__["default"]),
/* harmony export */   InteractsWithResourceInformation: () => (/* reexport safe */ _InteractsWithResourceInformation__WEBPACK_IMPORTED_MODULE_8__["default"]),
/* harmony export */   Localization: () => (/* reexport safe */ _Localization__WEBPACK_IMPORTED_MODULE_10__["default"]),
/* harmony export */   MetricBehavior: () => (/* reexport safe */ _MetricBehavior__WEBPACK_IMPORTED_MODULE_11__["default"]),
/* harmony export */   PreventsFormAbandonment: () => (/* reexport safe */ _PreventsFormAbandonment__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   PreventsModalAbandonment: () => (/* reexport safe */ _PreventsModalAbandonment__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   mapProps: () => (/* reexport safe */ _propTypes__WEBPACK_IMPORTED_MODULE_0__.mapProps),
/* harmony export */   useCopyValueToClipboard: () => (/* reexport safe */ _CopiesToClipboard__WEBPACK_IMPORTED_MODULE_1__.useCopyValueToClipboard),
/* harmony export */   useLocalization: () => (/* reexport safe */ _composables_useLocalization__WEBPACK_IMPORTED_MODULE_21__.useLocalization),
/* harmony export */   useResourceInformation: () => (/* reexport safe */ _composables_useResourceInformation__WEBPACK_IMPORTED_MODULE_22__.useResourceInformation)
/* harmony export */ });
/* harmony import */ var _propTypes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./propTypes */ "./vendor/laravel/nova/resources/js/mixins/propTypes.js");
/* harmony import */ var _CopiesToClipboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CopiesToClipboard */ "./vendor/laravel/nova/resources/js/mixins/CopiesToClipboard.js");
/* harmony import */ var _PreventsFormAbandonment__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PreventsFormAbandonment */ "./vendor/laravel/nova/resources/js/mixins/PreventsFormAbandonment.js");
/* harmony import */ var _PreventsModalAbandonment__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PreventsModalAbandonment */ "./vendor/laravel/nova/resources/js/mixins/PreventsModalAbandonment.js");
/* harmony import */ var _BehavesAsPanel__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BehavesAsPanel */ "./vendor/laravel/nova/resources/js/mixins/BehavesAsPanel.js");
/* harmony import */ var _DependentFormField__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DependentFormField */ "./vendor/laravel/nova/resources/js/mixins/DependentFormField.js");
/* harmony import */ var _HandlesFormRequest__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./HandlesFormRequest */ "./vendor/laravel/nova/resources/js/mixins/HandlesFormRequest.js");
/* harmony import */ var _HandlesUploads__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./HandlesUploads */ "./vendor/laravel/nova/resources/js/mixins/HandlesUploads.js");
/* harmony import */ var _InteractsWithResourceInformation__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./InteractsWithResourceInformation */ "./vendor/laravel/nova/resources/js/mixins/InteractsWithResourceInformation.js");
/* harmony import */ var _InteractsWithDates__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./InteractsWithDates */ "./vendor/laravel/nova/resources/js/mixins/InteractsWithDates.js");
/* harmony import */ var _Localization__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Localization */ "./vendor/laravel/nova/resources/js/mixins/Localization.js");
/* harmony import */ var _MetricBehavior__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./MetricBehavior */ "./vendor/laravel/nova/resources/js/mixins/MetricBehavior.js");
/* harmony import */ var _FieldValue__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./FieldValue */ "./vendor/laravel/nova/resources/js/mixins/FieldValue.js");
/* harmony import */ var _FormEvents__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./FormEvents */ "./vendor/laravel/nova/resources/js/mixins/FormEvents.js");
/* harmony import */ var _FormField__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./FormField */ "./vendor/laravel/nova/resources/js/mixins/FormField.js");
/* harmony import */ var _HandlesFieldAttachments__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./HandlesFieldAttachments */ "./vendor/laravel/nova/resources/js/mixins/HandlesFieldAttachments.js");
/* harmony import */ var _HandlesFieldPreviews__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./HandlesFieldPreviews */ "./vendor/laravel/nova/resources/js/mixins/HandlesFieldPreviews.js");
/* harmony import */ var _HandlesValidationErrors__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./HandlesValidationErrors */ "./vendor/laravel/nova/resources/js/mixins/HandlesValidationErrors.js");
/* harmony import */ var _HasCards__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./HasCards */ "./vendor/laravel/nova/resources/js/mixins/HasCards.js");
/* harmony import */ var _HandlesPanelVisibility__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./HandlesPanelVisibility */ "./vendor/laravel/nova/resources/js/mixins/HandlesPanelVisibility.js");
/* harmony import */ var _util_FormValidation__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../util/FormValidation */ "./vendor/laravel/nova/resources/js/util/FormValidation.js");
/* harmony import */ var _composables_useLocalization__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../composables/useLocalization */ "./vendor/laravel/nova/resources/js/composables/useLocalization.js");
/* harmony import */ var _composables_useResourceInformation__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../composables/useResourceInformation */ "./vendor/laravel/nova/resources/js/composables/useResourceInformation.js");
























/***/ }),

/***/ "./vendor/laravel/nova/resources/js/mixins/propTypes.js":
/*!**************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/mixins/propTypes.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mapProps: () => (/* binding */ mapProps)
/* harmony export */ });
/* harmony import */ var lodash_pick__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash/pick */ "./node_modules/lodash/pick.js");
/* harmony import */ var lodash_pick__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_pick__WEBPACK_IMPORTED_MODULE_0__);

var propTypes = {
  nested: {
    type: Boolean,
    "default": false
  },
  preventInitialLoading: {
    type: Boolean,
    "default": false
  },
  showHelpText: {
    type: Boolean,
    "default": false
  },
  shownViaNewRelationModal: {
    type: Boolean,
    "default": false
  },
  resourceId: {
    type: [Number, String]
  },
  resourceName: {
    type: String
  },
  relatedResourceId: {
    type: [Number, String]
  },
  relatedResourceName: {
    type: String
  },
  field: {
    type: Object,
    required: true
  },
  viaResource: {
    type: String,
    required: false
  },
  viaResourceId: {
    type: [String, Number],
    required: false
  },
  viaRelationship: {
    type: String,
    required: false
  },
  relationshipType: {
    type: String,
    "default": ''
  },
  shouldOverrideMeta: {
    type: Boolean,
    "default": false
  },
  disablePagination: {
    type: Boolean,
    "default": false
  },
  clickAction: {
    type: String,
    "default": 'view',
    validator: function validator(val) {
      return ['edit', 'select', 'ignore', 'detail'].includes(val);
    }
  },
  mode: {
    type: String,
    "default": 'form',
    validator: function validator(v) {
      return ['form', 'modal', 'action-modal', 'action-fullscreen'].includes(v);
    }
  }
};

/**
 * @param {string[]} attributes
 * @returns {{[key: string]: object}}
 */
function mapProps(attributes) {
  return lodash_pick__WEBPACK_IMPORTED_MODULE_0___default()(propTypes, attributes);
}

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/util/FormValidation.js":
/*!*****************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/util/FormValidation.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Errors: () => (/* binding */ Errors),
/* harmony export */   Form: () => (/* binding */ Form)
/* harmony export */ });
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _readOnlyError(r) { throw new TypeError('"' + r + '" is read-only'); }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
/**
 * Class extracted from https://github.com/spatie/form-backend-validation
 */

var reservedFieldNames = ['__http', '__options', '__validateRequestType', 'clear', 'data', 'delete', 'errors', 'getError', 'getErrors', 'hasError', 'initial', 'onFail', 'only', 'onSuccess', 'patch', 'populate', 'post', 'processing', 'successful', 'put', 'reset', 'submit', 'withData', 'withErrors', 'withOptions'];

/**
 * @param {string} fieldName
 * @throws {Error}
 */
function guardAgainstReservedFieldName(fieldName) {
  if (reservedFieldNames.indexOf(fieldName) !== -1) {
    throw new Error("Field name ".concat(fieldName, " isn't allowed to be used in a Form or Errors instance."));
  }
}

/**
 * @param {any} object
 * @returns {boolean}
 */
function isArray(object) {
  return Object.prototype.toString.call(object) === '[object Array]';
}

/**
 * @param {File|FileList|any} object
 * @returns {boolean}
 */
function isFile(object) {
  return object instanceof File || object instanceof FileList;
}
function merge(a, b) {
  for (var key in b) {
    a[key] = cloneDeep(b[key]);
  }
}
function cloneDeep(object) {
  if (object === null) {
    return null;
  }
  if (isFile(object)) {
    return object;
  }
  if (Array.isArray(object)) {
    var clone = [];
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        clone[key] = cloneDeep(object[key]);
      }
    }
    return clone;
  }
  if (_typeof(object) === 'object') {
    var _clone = {};
    for (var _key in object) {
      if (object.hasOwnProperty(_key)) {
        _clone[_key] = cloneDeep(object[_key]);
      }
    }
    return _clone;
  }
  return object;
}

/**
 *
 * @param {FormPayloads} object
 * @param {FormData} formData
 * @param {string|null} [parent=null]
 * @returns {FormData|void}
 */
function objectToFormData(object) {
  var formData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new FormData();
  var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (object === null || object === 'undefined' || object.length === 0) {
    return formData.append(parent, object);
  }
  for (var property in object) {
    if (object.hasOwnProperty(property)) {
      appendToFormData(formData, getKey(parent, property), object[property]);
    }
  }
  return formData;
}

/**
 * @param {string|null} parent
 * @param {string} property
 * @returns {string}
 */
function getKey(parent, property) {
  return parent ? parent + '[' + property + ']' : property;
}

/**
 * @param {FormData} formData
 * @param {string} key
 * @param {any} value
 * @returns {void}
 */
function appendToFormData(formData, key, value) {
  if (value instanceof Date) {
    return formData.append(key, value.toISOString());
  }
  if (value instanceof File) {
    return formData.append(key, value, value.name);
  }
  if (typeof value === 'boolean') {
    return formData.append(key, value ? '1' : '0');
  }
  if (value === null) {
    return formData.append(key, '');
  }
  if (_typeof(value) !== 'object') {
    return formData.append(key, value);
  }
  objectToFormData(value, formData, key);
}

/**
 * @typedef {import('axios').AxiosInstance} AxiosInstance
 * @typedef {import('axios').AxiosResponse} AxiosResponse
 * @typedef {{[key: string]: any}} FormPayloads
 * @typedef {{http?: AxiosInstance, resetOnSuccess?: boolean, onSuccess?: Function, onFail?: Function}} FormOptions
 */

var Form = /*#__PURE__*/function () {
  /**
   * Create a new Form instance.
   *
   * @param {FormPayloads} data
   * @param {FormOptions} options
   */
  function Form() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    _classCallCheck(this, Form);
    this.processing = false;
    this.successful = false;
    this.withData(data).withOptions(options).withErrors({});
  }

  /**
   * @param {FormPayloads} data
   */
  return _createClass(Form, [{
    key: "withData",
    value: function withData(data) {
      if (isArray(data)) {
        data = data.reduce(function (carry, element) {
          carry[element] = '';
          return carry;
        }, {});
      }
      this.setInitialValues(data);
      this.errors = new Errors();
      this.processing = false;
      this.successful = false;
      for (var field in data) {
        guardAgainstReservedFieldName(field);
        this[field] = data[field];
      }
      return this;
    }

    /**
     * @param {ErrorCollection} errors
     */
  }, {
    key: "withErrors",
    value: function withErrors(errors) {
      this.errors = new Errors(errors);
      return this;
    }

    /**
     * @param {FormOptions} options
     */
  }, {
    key: "withOptions",
    value: function withOptions(options) {
      /** @private */
      this.__options = {
        resetOnSuccess: true
      };
      if (options.hasOwnProperty('resetOnSuccess')) {
        this.__options.resetOnSuccess = options.resetOnSuccess;
      }
      if (options.hasOwnProperty('onSuccess')) {
        this.onSuccess = options.onSuccess;
      }
      if (options.hasOwnProperty('onFail')) {
        this.onFail = options.onFail;
      }
      var windowAxios = typeof window === 'undefined' ? false : window.axios;

      /**
       * @protected
       * @type {AxiosInstance}
       */
      this.__http = options.http || windowAxios || __webpack_require__(/*! axios */ "./node_modules/axios/dist/browser/axios.cjs");
      if (!this.__http) {
        throw new Error('No http library provided. Either pass an http option, or install axios.');
      }
      return this;
    }

    /**
     * Fetch all relevant data for the form.
     *
     * @returns {FormPayloads}
     */
  }, {
    key: "data",
    value: function data() {
      var data = {};
      for (var property in this.initial) {
        data[property] = this[property];
      }
      return data;
    }

    /**
     * Fetch specific data for the form.
     *
     * @param {string[]} fields
     * @returns {FormPayloads}
     */
  }, {
    key: "only",
    value: function only(fields) {
      var _this = this;
      return fields.reduce(function (filtered, field) {
        filtered[field] = _this[field];
        return filtered;
      }, {});
    }

    /**
     * Reset the form fields.
     */
  }, {
    key: "reset",
    value: function reset() {
      merge(this, this.initial);
      this.errors.clear();
    }

    /**
     * @param {FormPayloads} values
     */
  }, {
    key: "setInitialValues",
    value: function setInitialValues(values) {
      /** @private */
      this.initial = {};
      merge(this.initial, values);
    }

    /**
     * @param {FormPayloads} data
     */
  }, {
    key: "populate",
    value: function populate(data) {
      var _this2 = this;
      Object.keys(data).forEach(function (field) {
        guardAgainstReservedFieldName(field);
        if (_this2.hasOwnProperty(field)) {
          merge(_this2, _defineProperty({}, field, data[field]));
        }
      });
      return this;
    }

    /**
     * Clear the form fields.
     */
  }, {
    key: "clear",
    value: function clear() {
      for (var field in this.initial) {
        this[field] = '';
      }
      this.errors.clear();
    }

    /**
     * Send a POST request to the given URL.
     *
     * @param {string} url
     */
  }, {
    key: "post",
    value: function post(url) {
      return this.submit('post', url);
    }

    /**
     * Send a PUT request to the given URL.
     *
     * @param {string} url
     */
  }, {
    key: "put",
    value: function put(url) {
      return this.submit('put', url);
    }

    /**
     * Send a PATCH request to the given URL.
     *
     * @param {string} url
     */
  }, {
    key: "patch",
    value: function patch(url) {
      return this.submit('patch', url);
    }

    /**
     * Send a DELETE request to the given URL.
     *
     * @param {string} url
     */
  }, {
    key: "delete",
    value: function _delete(url) {
      return this.submit('delete', url);
    }

    /**
     * Submit the form.
     *
     * @param {string} requestType
     * @param {string} url
     */
  }, {
    key: "submit",
    value: function submit(requestType, url) {
      var _this3 = this;
      this.__validateRequestType(requestType);
      this.errors.clear();
      this.processing = true;
      this.successful = false;
      return new Promise(function (resolve, reject) {
        _this3.__http[requestType](url, _this3.hasFiles() ? objectToFormData(_this3.data()) : _this3.data()).then(function (response) {
          _this3.processing = false;
          _this3.onSuccess(response.data);
          resolve(response.data);
        })["catch"](function (error) {
          _this3.processing = false;
          _this3.onFail(error);
          reject(error);
        });
      });
    }

    /**
     * @returns {boolean}
     */
  }, {
    key: "hasFiles",
    value: function hasFiles() {
      for (var property in this.initial) {
        if (this.hasFilesDeep(this[property])) {
          return true;
        }
      }
      return false;
    }

    /**
     * @param {Object|Array} object
     * @returns {boolean}
     */
  }, {
    key: "hasFilesDeep",
    value: function hasFilesDeep(object) {
      if (object === null) {
        return false;
      }
      if (_typeof(object) === 'object') {
        for (var key in object) {
          if (object.hasOwnProperty(key)) {
            if (this.hasFilesDeep(object[key])) {
              return true;
            }
          }
        }
      }
      if (Array.isArray(object)) {
        for (var _key2 in object) {
          if (object.hasOwnProperty(_key2)) {
            return this.hasFilesDeep(object[_key2]);
          }
        }
      }
      return isFile(object);
    }

    /**
     * Handle a successful form submission.
     *
     * @param {any} data
     */
  }, {
    key: "onSuccess",
    value: function onSuccess(data) {
      this.successful = true;
      if (this.__options.resetOnSuccess) {
        this.reset();
      }
    }

    /**
     * Handle a failed form submission.
     *
     * @param {AxiosResponse} error
     */
  }, {
    key: "onFail",
    value: function onFail(error) {
      this.successful = false;
      if (error.response && error.response.data.errors) {
        this.errors.record(error.response.data.errors);
      }
    }

    /**
     * Get the error message(s) for the given field.
     *
     * @param {string} field
     * @returns {boolean}
     */
  }, {
    key: "hasError",
    value: function hasError(field) {
      return this.errors.has(field);
    }

    /**
     * Get the first error message for the given field.
     *
     * @param {string} field
     * @returns {string|null}
     */
  }, {
    key: "getError",
    value: function getError(field) {
      return this.errors.first(field);
    }

    /**
     * Get the error messages for the given field.
     *
     * @param {string} field
     * @returns {string[]}
     */
  }, {
    key: "getErrors",
    value: function getErrors(field) {
      return this.errors.get(field);
    }

    /**
     * @param {string} requestType
     */
  }, {
    key: "__validateRequestType",
    value: function __validateRequestType(requestType) {
      var requestTypes = ['get', 'delete', 'head', 'post', 'put', 'patch'];
      if (requestTypes.indexOf(requestType) === -1) {
        throw new Error("`".concat(requestType, "` is not a valid request type, ") + "must be one of: `".concat(requestTypes.join('`, `'), "`."));
      }
    }
  }], [{
    key: "create",
    value: function create() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return new Form().withData(data);
    }
  }]);
}();

/**
 * @typedef {{[key: string]: string[]}} ErrorCollection
 */

var Errors = /*#__PURE__*/function () {
  /**
   * Create a new Errors instance.
   *
   * @param {ErrorCollection} [errors={}]
   */
  function Errors() {
    var errors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _classCallCheck(this, Errors);
    this.record(errors);
  }

  /**
   * Get all the errors.
   *
   * @returns {ErrorCollection}
   */
  return _createClass(Errors, [{
    key: "all",
    value: function all() {
      return this.errors;
    }

    /**
     * Determine if any errors exists for the given field or object.
     *
     * @param {string} field
     * @returns {boolean}
     */
  }, {
    key: "has",
    value: function has(field) {
      var hasError = this.errors.hasOwnProperty(field);
      if (!hasError) {
        var errors = Object.keys(this.errors).filter(function (e) {
          return e.startsWith("".concat(field, ".")) || e.startsWith("".concat(field, "["));
        });
        hasError = errors.length > 0;
      }
      return hasError;
    }

    /**
     * Get the first error for the given field or object.
     *
     * @param {string} field
     * @returns {string|null}
     */
  }, {
    key: "first",
    value: function first(field) {
      return this.get(field)[0];
    }

    /**
     * Get the errors for the given field or object.
     *
     * @param {string} field
     * @returns {string[]}
     */
  }, {
    key: "get",
    value: function get(field) {
      return this.errors[field] || [];
    }

    /**
     * Determine if we have any errors.
     * Or return errors for the given keys.
     *
     * @param {string[]} [keys=[]]
     * @returns {ErrorCollection}
     */
  }, {
    key: "any",
    value: function any() {
      var _this4 = this;
      var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      if (keys.length === 0) {
        return Object.keys(this.errors).length > 0;
      }
      var errors = {};
      keys.forEach(function (key) {
        return errors[key] = _this4.get(key);
      });
      return errors;
    }

    /**
     * Record the new errors.
     *
     * @param {ErrorCollection} [errors={}]
     */
  }, {
    key: "record",
    value: function record() {
      var errors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      /** @type {ErrorCollection} */
      this.errors = errors;
    }

    /**
     * Clear a specific field, object or all error fields.
     *
     * @param {string|null} field
     */
  }, {
    key: "clear",
    value: function clear(field) {
      if (!field) {
        this.errors = {};
        return;
      }
      var errors = Object.assign({}, this.errors);
      Object.keys(errors).filter(function (e) {
        return e === field || e.startsWith("".concat(field, ".")) || e.startsWith("".concat(field, "["));
      }).forEach(function (e) {
        return delete errors[e];
      });
      this.errors = errors;
    }
  }]);
}();

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/util/escapeUnicode.js":
/*!****************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/util/escapeUnicode.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   escapeUnicode: () => (/* binding */ escapeUnicode)
/* harmony export */ });
/**
 * @param {string} str
 * @returns {string}
 */
function escapeUnicode(str) {
  return str.replace(/[^\0-~]/g, function (c) {
    return "\\u" + ('000' + c.charCodeAt().toString(16)).slice(-4);
  });
}

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/util/filled.js":
/*!*********************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/util/filled.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ filled)
/* harmony export */ });
/**
 * @param {any} value
 * @returns {boolean}
 */
function filled(value) {
  return Boolean(value != null && value !== '');
}

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/util/hourCycle.js":
/*!************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/util/hourCycle.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @param {string} locale
 * @returns {number}
 */
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(locale) {
  var hourCycle = Intl.DateTimeFormat(locale, {
    hour: 'numeric'
  }).resolvedOptions().hourCycle;
  if (hourCycle == 'h23' || hourCycle == 'h24') {
    return 24;
  }
  return 12;
}

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/util/localization.js":
/*!***************************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/util/localization.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ __)
/* harmony export */ });
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
/**
 * @param {string} key
 * @param {string} replace
 * @returns {string}
 */
function __(key, replace) {
  /** @type {string} */
  var translation = Nova.config('translations')[key] ? Nova.config('translations')[key] : key;
  Object.entries(replace !== null && replace !== void 0 ? replace : {}).forEach(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
      key = _ref2[0],
      value = _ref2[1];
    key = new String(key);
    if (value === null) {
      console.error("Translation '".concat(translation, "' for key '").concat(key, "' contains a null replacement."));
      return;
    }
    value = new String(value);
    var searches = [':' + key, ':' + key.toUpperCase(), ':' + key.charAt(0).toUpperCase() + key.slice(1)];
    var replacements = [value, value.toUpperCase(), value.charAt(0).toUpperCase() + value.slice(1)];
    for (var i = searches.length - 1; i >= 0; i--) {
      translation = translation.replace(searches[i], replacements[i]);
    }
  });
  return translation;
}

/***/ }),

/***/ "./vendor/laravel/nova/resources/js/util/minimum.js":
/*!**********************************************************!*\
  !*** ./vendor/laravel/nova/resources/js/util/minimum.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @param {Promise<any>} originalPromise
 * @delay {number} [delay=100]
 * @returns {Promise<any>}
 */
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(originalPromise) {
  var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
  return Promise.all([originalPromise, new Promise(function (resolve) {
    setTimeout(function () {
      return resolve();
    }, delay);
  })]).then(function (result) {
    return result[0];
  });
}

// Usage
// minimum(axios.get('/'))
//     .then(response => console.log('done'))
//     .catch(error => console.log(error))

/***/ }),

/***/ "vue":
/*!**********************!*\
  !*** external "Vue" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = Vue;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/field": 0,
/******/ 			"css/field": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunklyhty_nova_tui_editor"] = self["webpackChunklyhty_nova_tui_editor"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/field"], () => (__webpack_require__("./resources/field.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/field"], () => (__webpack_require__("./resources/field.css")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;